{"repo":"neoclide/coc.nvim","url":"https://github.com/neoclide/coc.nvim","branch":"master","configs":[{"package":"coc.nvim-master","lang":"ts","dir":"src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"lang":"js","dir":"src/__tests__/extensions/test","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should send file change notification","suites":["Client integration"],"updatePoint":{"line":24,"column":42},"line":24,"code":"  it('should send file change notification', (done) => {\n    if (global.hasOwnProperty('__TEST__')) return done()\n    let serverModule = path.join(__dirname, './server/testFileWatcher.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.ipc\n    }\n    let clientOptions: lsclient.LanguageClientOptions = {\n      documentSelector: ['css'],\n      synchronize: {}, initializationOptions: {},\n      middleware: {\n      }\n    }\n    let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions)\n    let disposable = client.start()\n\n    client.onReady().then(_ => {\n      setTimeout(async () => {\n        let file = path.join(__dirname, 'test.js')\n        fs.writeFileSync(file, '', 'utf8')\n        await helper.wait(300)\n        let res = await client.sendRequest('custom/received')\n        expect(res).toEqual({\n          changes: [{\n            uri: URI.file(file).toString(),\n            type: 1\n          }]\n        })\n        fs.unlinkSync(file)\n        disposable.dispose()\n        done()\n      }, 200)\n    }, e => {\n      disposable.dispose()\n      done(e)\n    })\n  })","file":"client/changedFiles.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ensure proper param passing","suites":["Connection Tests"],"updatePoint":{"line":37,"column":40},"line":37,"code":"  it('should ensure proper param passing', async () => {\n    let paramsCorrect = false\n    serverConnection.onRequest(InitializeRequest.type, params => {\n      paramsCorrect = !Array.isArray(params)\n      let result: InitializeResult = {\n        capabilities: {\n        }\n      }\n      return result\n    })\n\n    const init: InitializeParams = {\n      rootUri: 'file:///home/dirkb',\n      processId: 1,\n      capabilities: {},\n      workspaceFolders: null,\n    }\n    await clientConnection.sendRequest(InitializeRequest.type, init)\n    expect(paramsCorrect).toBe(true)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provid token","suites":["Connection Tests"],"updatePoint":{"line":58,"column":25},"line":58,"code":"  it('should provid token', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.partialResultToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      partialResultToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report result","suites":["Connection Tests"],"updatePoint":{"line":71,"column":26},"line":71,"code":"  it('should report result', async () => {\n    let result: SymbolInformation = {\n      name: 'abc',\n      kind: SymbolKind.Class,\n      location: {\n        uri: 'file:///abc.txt',\n        range: { start: { line: 0, character: 1 }, end: { line: 2, character: 3 } }\n      }\n    }\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.partialResultToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      serverConnection.sendProgress(progressType, params.partialResultToken, [result])\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      partialResultToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    let progressOK = false\n    clientConnection.onProgress(progressType, '3b1db4c9-e011-489e-a9d1-0653e64707c2', values => {\n      progressOK = (values !== undefined && values.length === 1)\n    })\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n    expect(progressOK).toBeTruthy()\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide workDoneToken","suites":["Connection Tests"],"updatePoint":{"line":98,"column":34},"line":98,"code":"  it('should provide workDoneToken', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.workDoneToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      workDoneToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report work done progress","suites":["Connection Tests"],"updatePoint":{"line":111,"column":38},"line":111,"code":"  it('should report work done progress', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.workDoneToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'begin',\n        title: 'progress'\n      })\n      serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'report',\n        message: 'message'\n      })\n      serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'end',\n        message: 'message'\n      })\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      workDoneToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    let result = ''\n    clientConnection.onProgress(progressType, '3b1db4c9-e011-489e-a9d1-0653e64707c2', value => {\n      result += value.kind\n    })\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n    expect(result).toBe('beginreportend')\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asLanguageIds","suites":["converter"],"updatePoint":{"line":12,"column":26},"line":12,"code":"  it('should asLanguageIds', () => {\n    let selector = ['css', { language: 'javascript' }]\n    expect(cv.asLanguageIds(selector)).toEqual(['css', 'javascript'])\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convertToTextDocumentItem","suites":["converter"],"updatePoint":{"line":17,"column":38},"line":17,"code":"  it('should convertToTextDocumentItem', () => {\n    let doc = createDocument()\n    expect(cv.convertToTextDocumentItem(doc).uri).toBe(doc.uri)\n    expect(TextDocumentItem.is(cv.convertToTextDocumentItem(doc))).toBe(true)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCloseTextDocumentParams","suites":["converter"],"updatePoint":{"line":23,"column":38},"line":23,"code":"  it('should asCloseTextDocumentParams', () => {\n    let doc = createDocument()\n    expect(cv.asCloseTextDocumentParams(doc).textDocument.uri).toBe(doc.uri)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asChangeTextDocumentParams","suites":["converter"],"updatePoint":{"line":28,"column":39},"line":28,"code":"  it('should asChangeTextDocumentParams', () => {\n    let doc = createDocument()\n    expect(cv.asChangeTextDocumentParams(doc).textDocument.uri).toBe(doc.uri)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asWillSaveTextDocumentParams","suites":["converter"],"updatePoint":{"line":33,"column":41},"line":33,"code":"  it('should asWillSaveTextDocumentParams', () => {\n    let res = cv.asWillSaveTextDocumentParams({ document: createDocument(), reason: TextDocumentSaveReason.Manual, waitUntil: () => { } })\n    expect(res.textDocument).toBeDefined()\n    expect(res.reason).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asVersionedTextDocumentIdentifier","suites":["converter"],"updatePoint":{"line":39,"column":46},"line":39,"code":"  it('should asVersionedTextDocumentIdentifier', () => {\n    let res = cv.asVersionedTextDocumentIdentifier(createDocument())\n    expect(res.uri).toBeDefined()\n    expect(res.version).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asSaveTextDocumentParams","suites":["converter"],"updatePoint":{"line":45,"column":37},"line":45,"code":"  it('should asSaveTextDocumentParams', () => {\n    let res = cv.asSaveTextDocumentParams(createDocument(), true)\n    expect(res.textDocument.uri).toBeDefined()\n    expect(res.text).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asUri","suites":["converter"],"updatePoint":{"line":51,"column":18},"line":51,"code":"  it('should asUri', () => {\n    let uri = URI.file('/tmp/a')\n    expect(cv.asUri(uri)).toBe(uri.toString())\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCompletionParams","suites":["converter"],"updatePoint":{"line":56,"column":31},"line":56,"code":"  it('should asCompletionParams', () => {\n    let params = cv.asCompletionParams(createDocument(), Position.create(0, 0), { triggerKind: CompletionTriggerKind.Invoked })\n    expect(params.textDocument).toBeDefined()\n    expect(params.position).toBeDefined()\n    expect(params.context).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asTextDocumentPositionParams","suites":["converter"],"updatePoint":{"line":63,"column":41},"line":63,"code":"  it('should asTextDocumentPositionParams', () => {\n    let params = cv.asTextDocumentPositionParams(createDocument(), Position.create(0, 0))\n    expect(params.textDocument).toBeDefined()\n    expect(params.position).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asTextDocumentIdentifier","suites":["converter"],"updatePoint":{"line":69,"column":37},"line":69,"code":"  it('should asTextDocumentIdentifier', () => {\n    let doc = cv.asTextDocumentIdentifier(createDocument())\n    expect(doc.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asReferenceParams","suites":["converter"],"updatePoint":{"line":74,"column":30},"line":74,"code":"  it('should asReferenceParams', () => {\n    let params = cv.asReferenceParams(createDocument(), Position.create(0, 0), { includeDeclaration: false })\n    expect(params.textDocument.uri).toBeDefined()\n    expect(params.position).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asDocumentSymbolParams","suites":["converter"],"updatePoint":{"line":80,"column":35},"line":80,"code":"  it('should asDocumentSymbolParams', () => {\n    let doc = cv.asDocumentSymbolParams(createDocument())\n    expect(doc.textDocument.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCodeLensParams","suites":["converter"],"updatePoint":{"line":85,"column":29},"line":85,"code":"  it('should asCodeLensParams', () => {\n    let doc = cv.asCodeLensParams(createDocument())\n    expect(doc.textDocument.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Delayer","suites":[],"updatePoint":{"line":5,"column":13},"line":5,"code":"test('Delayer', () => {\n  let count = 0\n  let factory = () => {\n    return Promise.resolve(++count)\n  }\n\n  let delayer = new Delayer(0)\n  let promises: Thenable<any>[] = []\n\n  assert(!delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  return Promise.all(promises).then(() => {\n    assert(!delayer.isTriggered())\n  }).finally(() => {\n    delayer.dispose()\n  })\n})","file":"client/delayer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Delayer - last task should be the one getting called","suites":[],"updatePoint":{"line":133,"column":58},"line":133,"code":"test('Delayer - last task should be the one getting called', function() {\n  let factoryFactory = (n: number) => () => {\n    return Promise.resolve(n)\n  }\n\n  let delayer = new Delayer(0)\n  let promises: Thenable<any>[] = []\n\n  assert(!delayer.isTriggered())\n\n  promises.push(delayer.trigger(factoryFactory(1)).then((n) => { assert.equal(n, 3) }))\n  promises.push(delayer.trigger(factoryFactory(2)).then((n) => { assert.equal(n, 3) }))\n  promises.push(delayer.trigger(factoryFactory(3)).then((n) => { assert.equal(n, 3) }))\n\n  const p = Promise.all(promises).then(() => {\n    assert(!delayer.isTriggered())\n  })\n\n  assert(delayer.isTriggered())\n\n  return p\n})","file":"client/delayer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"InitializeResult","suites":["Client integration"],"updatePoint":{"line":98,"column":24},"line":98,"code":"  test('InitializeResult', () => {\n    let expected = {\n      capabilities: {\n        textDocumentSync: 1,\n        definitionProvider: true,\n        hoverProvider: true,\n        completionProvider: { resolveProvider: true, triggerCharacters: ['\"', ':'] },\n        signatureHelpProvider: {\n          triggerCharacters: [':'],\n          retriggerCharacters: [':']\n        },\n        referencesProvider: true,\n        documentHighlightProvider: true,\n        codeActionProvider: {\n          resolveProvider: true\n        },\n        documentFormattingProvider: true,\n        documentRangeFormattingProvider: true,\n        documentOnTypeFormattingProvider: {\n          firstTriggerCharacter: ':'\n        },\n        renameProvider: {\n          prepareProvider: true\n        },\n        documentLinkProvider: {\n          resolveProvider: true\n        },\n        colorProvider: true,\n        declarationProvider: true,\n        foldingRangeProvider: true,\n        implementationProvider: true,\n        selectionRangeProvider: true,\n        typeDefinitionProvider: true,\n        callHierarchyProvider: true,\n        semanticTokensProvider: {\n          legend: {\n            tokenTypes: [],\n            tokenModifiers: []\n          },\n          range: true,\n          full: {\n            delta: true\n          }\n        },\n        workspace: {\n          fileOperations: {\n            didCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },\n            didRename: {\n              filters: [\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }\n              ]\n            },\n            didDelete: { filters: [{ scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },\n            willCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },\n            willRename: {\n              filters: [\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }\n              ]\n            },\n            willDelete: { filters: [ {scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },\n          },\n        },\n        linkedEditingRangeProvider: true\n      },\n      customResults: {\n        hello: 'world'\n      }\n    }\n    assert.deepEqual(client.initializeResult, expected)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Definition","suites":["Client integration"],"updatePoint":{"line":171,"column":23},"line":171,"code":"  test('Goto Definition', async () => {\n    const provider = client.getFeature(DefinitionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideDefinition(document, position, tokenSource.token)) as Location\n    assert.strictEqual(Location.is(result), true)\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 0, 0, 0, 1)\n    let middlewareCalled = false\n    middleware.provideDefinition = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideDefinition(document, position, tokenSource.token)\n    middleware.provideDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Hover","suites":["Client integration"],"updatePoint":{"line":188,"column":13},"line":188,"code":"  test('Hover', async () => {\n    const provider = client.getFeature(HoverRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideHover(document, position, tokenSource.token)\n    assert.ok(Hover.is(result))\n    assert.strictEqual((result.contents as any).kind, 'plaintext')\n    assert.strictEqual((result.contents as any).value, 'foo')\n    let middlewareCalled = false\n    middleware.provideHover = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideHover(document, position, tokenSource.token)\n    middleware.provideHover = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion","suites":["Client integration"],"updatePoint":{"line":205,"column":18},"line":205,"code":"  test('Completion', async () => {\n    const provider = client.getFeature(CompletionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: CompletionTriggerKind.Invoked, triggerCharacter: ':' })) as CompletionItem[]\n\n    isArray(result, CompletionItem)\n    const item = result[0]\n    assert.strictEqual(item.label, 'item')\n    assert.strictEqual(item.insertText, 'text')\n    assert.strictEqual(item.detail, undefined)\n    isDefined(provider.resolveCompletionItem)\n\n    const resolved = await provider.resolveCompletionItem(item, tokenSource.token)\n    isDefined(resolved)\n    assert.strictEqual(resolved.detail, 'detail')\n\n    let middlewareCalled = 0\n    middleware.provideCompletionItem = (document, position, context, token, next) => {\n      middlewareCalled++\n      return next(document, position, context, token)\n    }\n    middleware.resolveCompletionItem = (item, token, next) => {\n      middlewareCalled++\n      return next(item, token)\n    }\n    await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: CompletionTriggerKind.Invoked, triggerCharacter: ':' })\n    await provider.resolveCompletionItem(item, tokenSource.token)\n    middleware.provideCompletionItem = undefined\n    middleware.resolveCompletionItem = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"SignatureHelpRequest","suites":["Client integration"],"updatePoint":{"line":237,"column":28},"line":237,"code":"  test('SignatureHelpRequest', async () => {\n    const provider = client.getFeature(SignatureHelpRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideSignatureHelp(document, position, tokenSource.token,\n      {\n        isRetrigger: false,\n        triggerKind: SignatureHelpTriggerKind.Invoked,\n        triggerCharacter: ':'\n      }\n    )\n\n    assert.strictEqual(result.activeSignature, 1)\n    assert.strictEqual(result.activeParameter, 1)\n    isArray(result.signatures, SignatureInformation)\n\n    const signature = result.signatures[0]\n    assert.strictEqual(signature.label, 'label')\n    assert.strictEqual(signature.documentation, 'doc')\n    isArray(signature.parameters, ParameterInformation)\n\n    const parameter = signature.parameters[0]\n    assert.strictEqual(parameter.label, 'label')\n    assert.strictEqual(parameter.documentation, 'doc')\n\n    let middlewareCalled = false\n    middleware.provideSignatureHelp = (d, p, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, c, t)\n    }\n    await provider.provideSignatureHelp(document, position, tokenSource.token,\n      {\n        isRetrigger: false,\n        triggerKind: SignatureHelpTriggerKind.Invoked,\n        triggerCharacter: ':'\n      }\n    )\n    middleware.provideSignatureHelp = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"References","suites":["Client integration"],"updatePoint":{"line":277,"column":18},"line":277,"code":"  test('References', async () => {\n    const provider = client.getFeature(ReferencesRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideReferences(document, position, {\n      includeDeclaration: true\n    }, tokenSource.token)\n\n    isArray(result, Location, 2)\n    for (let i = 0; i < result.length; i++) {\n      const location = result[i]\n      rangeEqual(location.range, i, i, i, i)\n      assert.strictEqual(location.uri.toString(), document.uri.toString())\n    }\n\n    let middlewareCalled = false\n    middleware.provideReferences = (d, p, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, c, t)\n    }\n    await provider.provideReferences(document, position, {\n      includeDeclaration: true\n    }, tokenSource.token)\n    middleware.provideReferences = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Highlight","suites":["Client integration"],"updatePoint":{"line":303,"column":26},"line":303,"code":"  test('Document Highlight', async () => {\n    const provider = client.getFeature(DocumentHighlightRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentHighlights(document, position, tokenSource.token)\n\n    isArray(result, DocumentHighlight, 1)\n\n    const highlight = result[0]\n    assert.strictEqual(highlight.kind, DocumentHighlightKind.Read)\n    rangeEqual(highlight.range, 2, 2, 2, 2)\n\n    let middlewareCalled = false\n    middleware.provideDocumentHighlights = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.provideDocumentHighlights(document, position, tokenSource.token)\n    middleware.provideDocumentHighlights = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Code Actions","suites":["Client integration"],"updatePoint":{"line":324,"column":20},"line":324,"code":"  test('Code Actions', async () => {\n    const provider = client.getFeature(CodeActionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideCodeActions(document, range, {\n      diagnostics: []\n    }, tokenSource.token)) as CodeAction[]\n\n    isArray(result, CodeAction)\n    const action = result[0]\n    assert.strictEqual(action.title, 'title')\n    assert.strictEqual(action.command?.title, 'title')\n    assert.strictEqual(action.command?.command, 'id')\n\n    const resolved = (await provider.resolveCodeAction(result[0], tokenSource.token))\n    assert.strictEqual(resolved?.title, 'resolved')\n\n    let middlewareCalled = false\n    middleware.provideCodeActions = (d, r, c, t, n) => {\n      middlewareCalled = true\n      return n(d, r, c, t)\n    }\n\n    await provider.provideCodeActions(document, range, { diagnostics: [] }, tokenSource.token)\n    middleware.provideCodeActions = undefined\n    assert.ok(middlewareCalled)\n\n    middlewareCalled = false\n    middleware.resolveCodeAction = (c, t, n) => {\n      middlewareCalled = true\n      return n(c, t)\n    }\n\n    await provider.resolveCodeAction!(result[0], tokenSource.token)\n    middleware.resolveCodeAction = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Progress","suites":["Client integration"],"updatePoint":{"line":361,"column":16},"line":361,"code":"  test('Progress', async () => {\n    const progressToken = 'TEST-PROGRESS-TOKEN'\n    const middlewareEvents: Array<WorkDoneProgressBegin | WorkDoneProgressReport | WorkDoneProgressEnd> = []\n    let currentProgressResolver: (value: unknown) => void | undefined\n\n    // Set up middleware that calls the current resolve function when it gets its 'end' progress event.\n    middleware.handleWorkDoneProgress = (token: ProgressToken, params, next) => {\n      if (token === progressToken) {\n        middlewareEvents.push(params)\n        if (params.kind === 'end') {\n          setImmediate(currentProgressResolver)\n        }\n      }\n      return next(token, params)\n    }\n\n    // Trigger multiple sample progress events.\n    for (let i = 0; i < 2; i++) {\n      await new Promise<unknown>((resolve, reject) => {\n        currentProgressResolver = resolve\n        client.sendRequest(\n          new ProtocolRequestType<any, null, never, any, any>('testing/sendSampleProgress'),\n          {},\n          tokenSource.token,\n        ).catch(reject)\n      })\n    }\n\n    middleware.handleWorkDoneProgress = undefined\n\n    // Ensure all events were handled.\n    assert.deepStrictEqual(\n      middlewareEvents.map(p => p.kind),\n      ['begin', 'report', 'end', 'begin', 'report', 'end'],\n    )\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Formatting","suites":["Client integration"],"updatePoint":{"line":398,"column":27},"line":398,"code":"  test('Document Formatting', async () => {\n    const provider = client.getFeature(DocumentFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, 'insert')\n    rangeEqual(edit.range, 0, 0, 0, 0)\n\n    let middlewareCalled = true\n    middleware.provideDocumentFormattingEdits = (d, c, t, n) => {\n      middlewareCalled = true\n      return n(d, c, t)\n    }\n    await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Range Formatting","suites":["Client integration"],"updatePoint":{"line":418,"column":33},"line":418,"code":"  test('Document Range Formatting', async () => {\n    const provider = client.getFeature(DocumentRangeFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, '')\n    rangeEqual(edit.range, 1, 1, 1, 2)\n\n    let middlewareCalled = true\n    middleware.provideDocumentRangeFormattingEdits = (d, r, c, t, n) => {\n      middlewareCalled = true\n      return n(d, r, c, t)\n    }\n    await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document on Type Formatting","suites":["Client integration"],"updatePoint":{"line":438,"column":35},"line":438,"code":"  test('Document on Type Formatting', async () => {\n    const provider = client.getFeature(DocumentOnTypeFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, 'replace')\n    rangeEqual(edit.range, 2, 2, 2, 3)\n\n    let middlewareCalled = true\n    middleware.provideOnTypeFormattingEdits = (d, p, s, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, s, c, t)\n    }\n    await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Rename","suites":["Client integration"],"updatePoint":{"line":458,"column":14},"line":458,"code":"  test('Rename', async () => {\n    const provider = client.getFeature(RenameRequest.method).getProvider(document)\n    isDefined(provider)\n    isDefined(provider.prepareRename)\n    const prepareResult = await provider.prepareRename(document, position, tokenSource.token) as Range\n\n    rangeEqual(prepareResult, 1, 1, 1, 2)\n    const renameResult = await provider.provideRenameEdits(document, position, 'newName', tokenSource.token)\n    assert.ok(WorkspaceEdit.is(renameResult))\n    let middlewareCalled = 0\n    middleware.prepareRename = (d, p, t, n) => {\n      middlewareCalled++\n      return n(d, p, t)\n    }\n    await provider.prepareRename(document, position, tokenSource.token)\n    middleware.prepareRename = undefined\n    middleware.provideRenameEdits = (d, p, w, t, n) => {\n      middlewareCalled++\n      return n(d, p, w, t)\n    }\n    await provider.provideRenameEdits(document, position, 'newName', tokenSource.token)\n    middleware.provideRenameEdits = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Link","suites":["Client integration"],"updatePoint":{"line":483,"column":21},"line":483,"code":"  test('Document Link', async () => {\n    const provider = client.getFeature(DocumentLinkRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentLinks(document, tokenSource.token)\n\n    isArray(result, DocumentLink)\n    const documentLink = result[0]\n    rangeEqual(documentLink.range, 1, 1, 1, 2)\n\n    let middlewareCalled = 0\n    middleware.provideDocumentLinks = (d, t, n) => {\n      middlewareCalled++\n      return n(d, t)\n    }\n    await provider.provideDocumentLinks(document, tokenSource.token)\n    middleware.provideDocumentLinks = undefined\n\n    isDefined(provider.resolveDocumentLink)\n    const resolved = await provider.resolveDocumentLink(documentLink, tokenSource.token)\n    isDefined(resolved.target)\n    assert.strictEqual(resolved.target.toString(), URI.file('/target.txt').toString())\n\n    middleware.resolveDocumentLink = (i, t, n) => {\n      middlewareCalled++\n      return n(i, t)\n    }\n    await provider.resolveDocumentLink(documentLink, tokenSource.token)\n    middleware.resolveDocumentLink = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Color","suites":["Client integration"],"updatePoint":{"line":514,"column":22},"line":514,"code":"  test('Document Color', async () => {\n    const provider = client.getFeature(DocumentColorRequest.method).getProvider(document)\n    isDefined(provider)\n    const colors = await provider.provideDocumentColors(document, tokenSource.token)\n\n    isArray(colors, ColorInformation)\n    const color = colors[0]\n\n    rangeEqual(color.range, 1, 1, 1, 2)\n    colorEqual(color.color, 1, 1, 1, 1)\n\n    let middlewareCalled = 0\n    middleware.provideDocumentColors = (d, t, n) => {\n      middlewareCalled++\n      return n(d, t)\n    }\n    await provider.provideDocumentColors(document, tokenSource.token)\n    middleware.provideDocumentColors = undefined\n\n    const presentations = await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token)\n\n    isArray(presentations, ColorPresentation)\n    const presentation = presentations[0]\n    assert.strictEqual(presentation.label, 'label')\n\n    middleware.provideColorPresentations = (c, x, t, n) => {\n      middlewareCalled++\n      return n(c, x, t)\n    }\n    await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token)\n    middleware.provideColorPresentations = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Declaration","suites":["Client integration"],"updatePoint":{"line":548,"column":24},"line":548,"code":"  test('Goto Declaration', async () => {\n    const provider = client.getFeature(DeclarationRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideDeclaration(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 1, 1, 1, 2)\n\n    let middlewareCalled = false\n    middleware.provideDeclaration = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideDeclaration(document, position, tokenSource.token)\n    middleware.provideDeclaration = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Folding Ranges","suites":["Client integration"],"updatePoint":{"line":566,"column":22},"line":566,"code":"  test('Folding Ranges', async () => {\n    const provider = client.getFeature(FoldingRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideFoldingRanges(document, {}, tokenSource.token))\n\n    isArray(result, FoldingRange, 1)\n    const range = result[0]\n    assert.strictEqual(range.startLine, 1)\n    assert.strictEqual(range.endLine, 2)\n    let middlewareCalled = true\n    middleware.provideFoldingRanges = (d, c, t, n) => {\n      middlewareCalled = true\n      return n(d, c, t)\n    }\n    await provider.provideFoldingRanges(document, {}, tokenSource.token)\n    middleware.provideFoldingRanges = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Implementation","suites":["Client integration"],"updatePoint":{"line":585,"column":27},"line":585,"code":"  test('Goto Implementation', async () => {\n    const provider = client.getFeature(ImplementationRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideImplementation(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 2, 2, 3, 3)\n\n    let middlewareCalled = false\n    middleware.provideImplementation = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideImplementation(document, position, tokenSource.token)\n    middleware.provideImplementation = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Selection Range","suites":["Client integration"],"updatePoint":{"line":603,"column":23},"line":603,"code":"  test('Selection Range', async () => {\n    const provider = client.getFeature(SelectionRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideSelectionRanges(document, [position], tokenSource.token))\n\n    isArray(result, SelectionRange, 1)\n    const range = result[0]\n    rangeEqual(range.range, 1, 2, 3, 4)\n    let middlewareCalled = false\n    middleware.provideSelectionRanges = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.provideSelectionRanges(document, [position], tokenSource.token)\n    middleware.provideSelectionRanges = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Type Definition","suites":["Client integration"],"updatePoint":{"line":621,"column":23},"line":621,"code":"  test('Type Definition', async () => {\n    const provider = client.getFeature(TypeDefinitionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideTypeDefinition(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 2, 2, 3, 3)\n\n    let middlewareCalled = false\n    middleware.provideTypeDefinition = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideTypeDefinition(document, position, tokenSource.token)\n    middleware.provideTypeDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Call Hierarchy","suites":["Client integration"],"updatePoint":{"line":639,"column":22},"line":639,"code":"  test('Call Hierarchy', async () => {\n    const provider = client.getFeature(CallHierarchyPrepareRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.prepareCallHierarchy(document, position, tokenSource.token)) as CallHierarchyItem[]\n    expect(result.length).toBe(1)\n\n    let middlewareCalled = false\n    middleware.prepareCallHierarchy = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.prepareCallHierarchy(document, position, tokenSource.token)\n    middleware.prepareCallHierarchy = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const item = result[0]\n    const incoming = (await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token)) as CallHierarchyIncomingCall[]\n    expect(incoming.length).toBe(1)\n    assert.deepEqual(incoming[0].from, item)\n    middlewareCalled = false\n    middleware.provideCallHierarchyIncomingCalls = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token)\n    middleware.provideCallHierarchyIncomingCalls = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const outgoing = (await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token)) as CallHierarchyOutgoingCall[]\n    expect(outgoing.length).toBe(1)\n    assert.deepEqual(outgoing[0].to, item)\n    middlewareCalled = false\n    middleware.provideCallHierarchyOutgoingCalls = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token)\n    middleware.provideCallHierarchyOutgoingCalls = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Create Files","suites":["Client integration"],"updatePoint":{"line":745,"column":43},"line":745,"code":"  test('File Operations - Will Create Files', async () => {\n    const feature = client.getFeature(WillCreateFilesRequest.method)\n    isDefined(feature)\n\n    const sendCreateRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ files: createFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendCreateRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL CREATE',\n      [\n        'file:///my/created-static/file.txt',\n        'file:///my/created-static/folder/',\n        'file:///my/created-dynamic/file.js',\n        'file:///my/created-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willCreateFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendCreateRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL CREATE',\n      [\n        'file:///my/created-static/file.txt',\n        'file:///my/created-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willCreateFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Create Files","suites":["Client integration"],"updatePoint":{"line":790,"column":42},"line":790,"code":"  test('File Operations - Did Create Files', async () => {\n    const feature = client.getFeature(DidCreateFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: createFiles })\n    await ensureNotificationReceived(\n      'create',\n      {\n        files: [\n          { uri: 'file:///my/created-static/file.txt' },\n          { uri: 'file:///my/created-static/folder/' },\n          { uri: 'file:///my/created-dynamic/file.js' },\n          { uri: 'file:///my/created-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didCreateFiles = (event, next) => next({\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: createFiles })\n    await ensureNotificationReceived(\n      'create',\n      {\n        files: [\n          { uri: 'file:///my/created-static/file.txt' },\n          { uri: 'file:///my/created-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didCreateFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Rename Files","suites":["Client integration"],"updatePoint":{"line":829,"column":43},"line":829,"code":"  test('File Operations - Will Rename Files', async () => {\n    const feature = client.getFeature(WillRenameFilesRequest.method)\n    isDefined(feature)\n\n    const sendRenameRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ files: renameFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendRenameRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL RENAME',\n      [\n        'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',\n        'file:///my/renamed-static/folder/ -> file:///my-new/renamed-static/folder/',\n        'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',\n        'file:///my/renamed-dynamic/folder/ -> file:///my-new/renamed-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willRenameFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.oldUri.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendRenameRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL RENAME',\n      [\n        'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',\n        'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willRenameFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Rename Files","suites":["Client integration"],"updatePoint":{"line":874,"column":42},"line":874,"code":"  test('File Operations - Did Rename Files', async () => {\n    const feature = client.getFeature(DidRenameFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: renameFiles })\n    await ensureNotificationReceived(\n      'rename',\n      {\n        files: [\n          { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },\n          { oldUri: 'file:///my/renamed-static/folder/', newUri: 'file:///my-new/renamed-static/folder/' },\n          { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },\n          { oldUri: 'file:///my/renamed-dynamic/folder/', newUri: 'file:///my-new/renamed-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didRenameFiles = (event, next) => next({\n      files: event.files.filter(f => !f.oldUri.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: renameFiles })\n    await ensureNotificationReceived(\n      'rename',\n      {\n        files: [\n          { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },\n          { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didRenameFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Delete Files","suites":["Client integration"],"updatePoint":{"line":913,"column":43},"line":913,"code":"  test('File Operations - Will Delete Files', async () => {\n    const feature = client.getFeature(WillDeleteFilesRequest.method)\n    isDefined(feature)\n\n    const sendDeleteRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ files: deleteFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendDeleteRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL DELETE',\n      [\n        'file:///my/deleted-static/file.txt',\n        'file:///my/deleted-static/folder/',\n        'file:///my/deleted-dynamic/file.js',\n        'file:///my/deleted-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willDeleteFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendDeleteRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL DELETE',\n      [\n        'file:///my/deleted-static/file.txt',\n        'file:///my/deleted-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willDeleteFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Delete Files","suites":["Client integration"],"updatePoint":{"line":958,"column":42},"line":958,"code":"  test('File Operations - Did Delete Files', async () => {\n    const feature = client.getFeature(DidDeleteFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: deleteFiles })\n    await ensureNotificationReceived(\n      'delete',\n      {\n        files: [\n          { uri: 'file:///my/deleted-static/file.txt' },\n          { uri: 'file:///my/deleted-static/folder/' },\n          { uri: 'file:///my/deleted-dynamic/file.js' },\n          { uri: 'file:///my/deleted-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didDeleteFiles = (event, next) => next({\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: deleteFiles })\n    await ensureNotificationReceived(\n      'delete',\n      {\n        files: [\n          { uri: 'file:///my/deleted-static/file.txt' },\n          { uri: 'file:///my/deleted-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didDeleteFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Semantic Tokens","suites":["Client integration"],"updatePoint":{"line":997,"column":23},"line":997,"code":"  test('Semantic Tokens', async () => {\n    const provider = client.getFeature(SemanticTokensRegistrationType.method).getProvider(document)\n    const rangeProvider = provider?.range\n    isDefined(rangeProvider)\n    const rangeResult = await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token)\n    assert.ok(rangeResult !== undefined)\n\n    let middlewareCalled = false\n    middleware.provideDocumentRangeSemanticTokens = (d, r, t, n) => {\n      middlewareCalled = true\n      return n(d, r, t)\n    }\n    await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token)\n    middleware.provideDocumentRangeSemanticTokens = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const fullProvider = provider?.full\n    isDefined(fullProvider)\n    const fullResult = await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token)\n    assert.ok(fullResult !== undefined)\n\n    middlewareCalled = false\n    middleware.provideDocumentSemanticTokens = (d, t, n) => {\n      middlewareCalled = true\n      return n(d, t)\n    }\n    await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token)\n    middleware.provideDocumentSemanticTokens = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    middlewareCalled = false\n    middleware.provideDocumentSemanticTokensEdits = (d, i, t, n) => {\n      middlewareCalled = true\n      return n(d, i, t)\n    }\n    await fullProvider.provideDocumentSemanticTokensEdits!(document, '2', tokenSource.token)\n    middleware.provideDocumentSemanticTokensEdits = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Linked Editing Ranges","suites":["Client integration"],"updatePoint":{"line":1037,"column":29},"line":1037,"code":"  test('Linked Editing Ranges', async () => {\n    const provider = client.getFeature(LinkedEditingRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideLinkedEditingRanges(document, position, tokenSource.token)\n\n    isArray(result.ranges, Range, 1)\n    rangeEqual(result.ranges[0], 1, 1, 1, 1)\n\n    let middlewareCalled = false\n    middleware.provideLinkedEditingRange = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideLinkedEditingRanges(document, position, tokenSource.token)\n    middleware.provideTypeDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use IPC channel","suites":["Client integration"],"updatePoint":{"line":39,"column":39},"line":39,"code":"  it('should initialize use IPC channel', (done) => {\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      run: { module: serverModule, transport: lsclient.TransportKind.ipc },\n      debug: { module: serverModule, transport: lsclient.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }\n    }\n    let clientOptions: lsclient.LanguageClientOptions = {\n      documentSelector: ['css'],\n      synchronize: {}, initializationOptions: {},\n      middleware: {\n        handleDiagnostics: (uri, diagnostics, next) => {\n          assert.equal(uri, \"uri:/test.ts\")\n          assert.ok(Array.isArray(diagnostics))\n          assert.equal(diagnostics.length, 0)\n          next(uri, diagnostics)\n          disposable.dispose()\n          done()\n        }\n      }\n    }\n    let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions)\n    let disposable = client.start()\n\n    assert.equal(client.initializeResult, undefined)\n\n    client.onReady().then(_ => {\n      try {\n        let expected = {\n          capabilities: {\n            textDocumentSync: 1,\n            completionProvider: { resolveProvider: true, triggerCharacters: ['\"', ':'] },\n            hoverProvider: true,\n            renameProvider: {\n              prepareProvider: true\n            }\n          },\n          customResults: {\n            \"hello\": \"world\"\n          }\n        }\n        assert.deepEqual(client.initializeResult, expected)\n      } catch (e) {\n        disposable.dispose()\n        done(e)\n      }\n    }, e => {\n      disposable.dispose()\n      done(e)\n    })\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use stdio","suites":["Client integration"],"updatePoint":{"line":90,"column":33},"line":90,"code":"  it('should initialize use stdio', async () => {\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    await testLanguageServer(serverOptions)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use pipe","suites":["Client integration"],"updatePoint":{"line":99,"column":32},"line":99,"code":"  it('should initialize use pipe', async () => {\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.pipe\n    }\n    await testLanguageServer(serverOptions)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use socket","suites":["Client integration"],"updatePoint":{"line":108,"column":34},"line":108,"code":"  it('should initialize use socket', async () => {\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: {\n        kind: lsclient.TransportKind.socket,\n        port: 8088\n      }\n    }\n    await testLanguageServer(serverOptions)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize as command","suites":["Client integration"],"updatePoint":{"line":120,"column":34},"line":120,"code":"  it('should initialize as command', async () => {\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      command: 'node',\n      args: [serverModule, '--stdio']\n    }\n    await testLanguageServer(serverOptions)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show word of word source on empty input","suites":["completion"],"updatePoint":{"line":26,"column":56},"line":26,"code":"  it('should not show word of word source on empty input', async () => {\n    await nvim.setLine('foo bar')\n    await helper.wait(200)\n    await nvim.input('of')\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n    await nvim.input('<backspace>')\n    await helper.wait(200)\n    res = await helper.notVisible('foo')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on first letter insert","suites":["completion"],"updatePoint":{"line":38,"column":43},"line":38,"code":"  it('should trigger on first letter insert', async () => {\n    await helper.edit()\n    await nvim.setLine('foo bar')\n    await helper.wait(30)\n    await nvim.input('of')\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on force refresh","suites":["completion"],"updatePoint":{"line":47,"column":37},"line":47,"code":"  it('should trigger on force refresh', async () => {\n    await helper.edit()\n    await nvim.setLine('foo f')\n    await helper.wait(100)\n    await nvim.input('A')\n    await helper.wait(10)\n    await nvim.call('coc#start')\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter and sort on increment search","suites":["completion"],"updatePoint":{"line":58,"column":48},"line":58,"code":"  it('should filter and sort on increment search', async () => {\n    await helper.edit()\n    await nvim.setLine('forceDocumentSync format  fallback')\n    await helper.wait(30)\n    await nvim.input('of')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    let l = items.length\n    await nvim.input('oa')\n    await helper.wait(100)\n    items = await helper.getItems()\n    expect(items.findIndex(o => o.word == 'fallback')).toBe(-1)\n    expect(items.length).toBeLessThan(l)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger on insert enter","suites":["completion"],"updatePoint":{"line":73,"column":40},"line":73,"code":"  it('should not trigger on insert enter', async () => {\n    await helper.edit()\n    await nvim.setLine('foo bar')\n    await helper.wait(30)\n    await nvim.input('o')\n    let visible = await nvim.call('pumvisible')\n    expect(visible).toBe(0)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter on fast input","suites":["completion"],"updatePoint":{"line":82,"column":33},"line":82,"code":"  it('should filter on fast input', async () => {\n    await helper.edit()\n    await nvim.setLine('foo bar')\n    await helper.wait(60)\n    await nvim.input('oba')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    let item = items.find(o => o.word == 'foo')\n    expect(item).toBeFalsy()\n    expect(items[0].word).toBe('bar')\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix start column","suites":["completion"],"updatePoint":{"line":94,"column":29},"line":94,"code":"  it('should fix start column', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'test',\n      priority: 10,\n      enable: true,\n      firstMatch: false,\n      sourceType: SourceType.Native,\n      triggerCharacters: [],\n      doComplete: async (): Promise<CompleteResult> => {\n        let result: CompleteResult = {\n          startcol: 0,\n          items: [{ word: 'foo.bar' }]\n        }\n        return Promise.resolve(result)\n      }\n    }\n    let disposable = sources.addSource(source)\n    await nvim.setLine('foo.')\n    await nvim.input('Ab')\n    await helper.waitPopup()\n    let val = await nvim.getVar('coc#_context') as any\n    expect(val.start).toBe(0)\n    disposable.dispose()\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop completion when type none trigger character","suites":["completion"],"updatePoint":{"line":120,"column":61},"line":120,"code":"  it('should stop completion when type none trigger character', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'test',\n      priority: 10,\n      enable: true,\n      firstMatch: false,\n      sourceType: SourceType.Native,\n      triggerCharacters: [],\n      doComplete: async (): Promise<CompleteResult> => {\n        let result: CompleteResult = {\n          items: [{ word: 'if(' }]\n        }\n        return Promise.resolve(result)\n      }\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.setLine('')\n    await nvim.input('iif')\n    await helper.waitPopup()\n    await nvim.input('(')\n    await helper.wait(300)\n    let res = await helper.pumvisible()\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on triggerCharacters","suites":["completion"],"updatePoint":{"line":146,"column":41},"line":146,"code":"  it('should trigger on triggerCharacters', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'trigger',\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('.')\n    await helper.waitPopup()\n    let res = await helper.visible('foo', 'trigger')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should complete items without input","suites":["completion"],"updatePoint":{"line":167,"column":48},"line":167,"code":"  it('should should complete items without input', async () => {\n    await helper.edit()\n    let source: ISource = {\n      enable: true,\n      name: 'trigger',\n      priority: 10,\n      sourceType: SourceType.Native,\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo' }, { word: 'bar' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.command('inoremap <silent><expr> <c-space> coc#refresh()')\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('<c-space>')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toBeGreaterThan(1)\n    await helper.wait(300)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show float window","suites":["completion"],"updatePoint":{"line":189,"column":30},"line":189,"code":"  it('should show float window', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'float',\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      doComplete: (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo', info: 'bar' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('f')\n    await helper.waitPopup()\n    await nvim.eval('feedkeys(\"\\\\<down>\",\"in\")')\n    await helper.wait(800)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(1)\n    let res = await helper.visible('foo', 'float')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on triggerPatterns","suites":["completion"],"updatePoint":{"line":213,"column":39},"line":213,"code":"  it('should trigger on triggerPatterns', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'pattern',\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerPatterns: [/\\w+\\.$/],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(10)\n    await nvim.input('.')\n    await helper.wait(30)\n    let pumvisible = await nvim.call('pumvisible')\n    expect(pumvisible).toBe(0)\n    await nvim.input('a')\n    await helper.wait(30)\n    await nvim.input('.')\n    await helper.waitPopup()\n    let res = await helper.visible('foo', 'pattern')\n    expect(res).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger triggerOnly source","suites":["completion"],"updatePoint":{"line":240,"column":43},"line":240,"code":"  it('should not trigger triggerOnly source', async () => {\n    await helper.edit()\n    await nvim.setLine('foo bar')\n    let source: ISource = {\n      name: 'pattern',\n      triggerOnly: true,\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerPatterns: [/^From:\\s*/],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('o')\n    await helper.wait(10)\n    await nvim.input('f')\n    await helper.wait(10)\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n    let items = await helper.items()\n    expect(items.length).toBe(1)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger when cursor moved","suites":["completion"],"updatePoint":{"line":265,"column":42},"line":265,"code":"  it('should not trigger when cursor moved', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'trigger',\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo' }]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.setLine('.a')\n    await nvim.input('A')\n    await nvim.eval('feedkeys(\"\\\\<bs>\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"\\\\<left>\")')\n    await helper.wait(200)\n    let visible = await nvim.call('pumvisible')\n    expect(visible).toBe(0)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger when completion is not completed","suites":["completion"],"updatePoint":{"line":288,"column":53},"line":288,"code":"  it('should trigger when completion is not completed', async () => {\n    await helper.edit()\n    let token: CancellationToken\n    let source: ISource = {\n      name: 'completion',\n      priority: 10,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (opt, cancellationToken): Promise<CompleteResult> => {\n        if (opt.triggerCharacter != '.') {\n          token = cancellationToken\n          return new Promise<CompleteResult>((resolve, reject) => {\n            let timer = setTimeout(() => {\n              resolve({ items: [{ word: 'foo' }] })\n            }, 200)\n            if (cancellationToken.isCancellationRequested) {\n              clearTimeout(timer)\n              reject(new Error('Cancelled'))\n            }\n          })\n        }\n        return Promise.resolve({\n          items: [{ word: 'bar' }]\n        })\n      }\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('if')\n    await helper.wait(100)\n    await nvim.input('.')\n    await helper.visible('bar', 'completion')\n    expect(token.isCancellationRequested).toBe(true)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should limit results for low priority source","suites":["completion"],"updatePoint":{"line":323,"column":50},"line":323,"code":"  it('should limit results for low priority source', async () => {\n    await helper.edit()\n    helper.updateConfiguration('suggest.lowPrioritySourceLimit', 2)\n    await nvim.setLine('filename filepath find filter findIndex')\n    await helper.wait(200)\n    await nvim.input('of')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    helper.updateConfiguration('suggest.lowPrioritySourceLimit', null)\n    items = items.filter(o => o.menu == '[A]')\n    expect(items.length).toBe(2)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should limit result for high priority source","suites":["completion"],"updatePoint":{"line":336,"column":50},"line":336,"code":"  it('should limit result for high priority source', async () => {\n    helper.updateConfiguration('suggest.highPrioritySourceLimit', 2)\n    await helper.edit()\n    let source: ISource = {\n      name: 'high',\n      priority: 90,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: ['filename', 'filepath', 'filter', 'file'].map(key => ({ word: key }))\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('.')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    helper.updateConfiguration('suggest.highPrioritySourceLimit', null)\n    expect(items.length).toBeGreaterThan(1)\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should truncate label of complete items","suites":["completion"],"updatePoint":{"line":359,"column":45},"line":359,"code":"  it('should truncate label of complete items', async () => {\n    helper.updateConfiguration('suggest.labelMaxLength', 10)\n    await helper.edit()\n    let source: ISource = {\n      name: 'high',\n      priority: 90,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: ['a', 'b', 'c', 'd'].map(key => ({ word: key.repeat(20) }))\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('.')\n    await helper.waitPopup()\n    helper.updateConfiguration('suggest.labelMaxLength', 200)\n    let items = await helper.getItems()\n    for (let item of items) {\n      expect(item.abbr.length).toBeLessThanOrEqual(10)\n    }\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete previous items if complete item is null","suites":["completion"],"updatePoint":{"line":384,"column":59},"line":384,"code":"  it('should delete previous items if complete item is null', async () => {\n    await helper.edit()\n    let source1: ISource = {\n      name: 'source1',\n      priority: 90,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [{ word: 'foo', dup: 1 }]\n      })\n    }\n    let source2: ISource = {\n      name: 'source2',\n      priority: 90,\n      enable: true,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.'],\n      doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n        let result: CompleteResult = opt.input == 'foo' ? null : {\n          items: [{ word: 'foo', dup: 1 }], isIncomplete: true\n        }\n        return Promise.resolve(result)\n      }\n    }\n    disposables.push(sources.addSource(source1))\n    disposables.push(sources.addSource(source2))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('.f')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toEqual(2)\n    await nvim.input('oo')\n    await helper.waitPopup()\n    items = await helper.getItems()\n    expect(items.length).toEqual(1)\n    expect(items[0].word).toBe('foo')\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent lines on TextChangedP #1","suites":["completion"],"updatePoint":{"line":424,"column":44},"line":424,"code":"  it('should indent lines on TextChangedP #1', async () => {\n    await helper.createDocument()\n    await helper.mockFunction('MyIndentExpr', 0)\n    await nvim.command('setl indentexpr=MyIndentExpr()')\n    await nvim.command('setl indentkeys=\\\\=~end,0\\\\=\\\\\\\\item')\n    let source: ISource = {\n      name: 'source1',\n      priority: 90,\n      enable: true,\n      sourceType: SourceType.Native,\n      doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n        items: [\n          { word: 'item' },\n          { word: 'items' },\n          { word: 'END' },\n          { word: 'ENDIF' }\n        ]\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('  \\\\ite')\n    await helper.waitPopup()\n    await nvim.input('m')\n    await helper.wait(300)\n    let line = await nvim.line\n    expect(line).toBe('\\\\item')\n    await nvim.input('<cr>')\n    await helper.wait(30)\n    await nvim.input('  END')\n    await helper.wait(300)\n    line = await nvim.line\n    expect(line).toBe('END')\n  })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show float window when disabled","suites":["completion float"],"updatePoint":{"line":42,"column":48},"line":42,"code":"  it('should not show float window when disabled', async () => {\n    helper.updateConfiguration('suggest.floatEnable', false)\n    await helper.edit()\n    await nvim.input('if')\n    await helper.visible('foo', 'float')\n    helper.updateConfiguration('suggest.floatEnable', true)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel float window","suites":["completion float"],"updatePoint":{"line":52,"column":32},"line":52,"code":"  it('should cancel float window', async () => {\n    await helper.edit()\n    await nvim.input('if')\n    await helper.visible('foo', 'float')\n    let items = await helper.getItems()\n    expect(items[0].word).toBe('foo')\n    expect(items[0].info.length > 0).toBeTruthy()\n    await nvim.input('<C-n>')\n    await helper.wait(500)\n    await nvim.input('<esc>')\n    await helper.wait(100)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust float window position","suites":["completion float"],"updatePoint":{"line":67,"column":41},"line":67,"code":"  it('should adjust float window position', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.input('<C-n>')\n    await helper.wait(300)\n    let floatWin = await helper.getFloat()\n    let config = await floatWin.getConfig()\n    expect(config.col + config.width).toBeLessThan(180)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should redraw float window on item change","suites":["completion float"],"updatePoint":{"line":79,"column":47},"line":79,"code":"  it('should redraw float window on item change', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.input('<C-n>')\n    await helper.wait(50)\n    await nvim.input('<C-n>')\n    await helper.wait(300)\n    let floatWin = await helper.getFloat()\n    let buf = await floatWin.buffer\n    let lines = await buf.lines\n    expect(lines.length).toBeGreaterThan(0)\n    expect(lines[0]).toMatch('foot')\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide float window when item info is empty","suites":["completion float"],"updatePoint":{"line":95,"column":54},"line":95,"code":"  it('should hide float window when item info is empty', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.input('<C-n>')\n    await helper.wait(10)\n    await nvim.input('<C-n>')\n    await helper.wait(10)\n    await nvim.input('<C-n>')\n    await helper.wait(100)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide float window after completion","suites":["completion float"],"updatePoint":{"line":110,"column":47},"line":110,"code":"  it('should hide float window after completion', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.input('<C-n>')\n    await helper.wait(100)\n    await nvim.input('<C-y>')\n    await helper.wait(30)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match score for last letter","suites":["matchScore"],"updatePoint":{"line":10,"column":40},"line":10,"code":"  it('should match score for last letter', () => {\n    expect(score('#!3', '3')).toBe(1)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match first letter","suites":["matchScore"],"updatePoint":{"line":14,"column":31},"line":14,"code":"  it('should match first letter', () => {\n    expect(score('abc', 'a')).toBe(5)\n    expect(score('Abc', 'a')).toBe(2.5)\n    expect(score('__abc', 'a')).toBe(2.5)\n    expect(score('$Abc', 'a')).toBe(2)\n    expect(score('$Abc', 'A')).toBe(2.5)\n    expect(score('$Abc', '$A')).toBe(6)\n    expect(score('$Abc', '$a')).toBe(5.5)\n    expect(score('foo_bar', 'b')).toBe(2.5)\n    expect(score('foo_Bar', 'b')).toBe(2)\n    expect(score('_foo_Bar', 'b')).toBe(0.5)\n    expect(score('_foo_Bar', 'f')).toBe(2.5)\n    expect(score('bar', 'a')).toBe(1)\n    expect(score('fooBar', 'B')).toBe(2.5)\n    expect(score('fooBar', 'b')).toBe(2)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match follow letters","suites":["matchScore"],"updatePoint":{"line":31,"column":33},"line":31,"code":"  it('should match follow letters', () => {\n    expect(score('abc', 'ab')).toBe(6)\n    expect(score('adB', 'ab')).toBe(5.75)\n    expect(score('adb', 'ab')).toBe(5.1)\n    expect(score('adCB', 'ab')).toBe(5.05)\n    expect(score('a_b_c', 'ab')).toBe(6)\n    expect(score('FooBar', 'fb')).toBe(3.25)\n    expect(score('FBar', 'fb')).toBe(3)\n    expect(score('FooBar', 'FB')).toBe(6)\n    expect(score('FBar', 'FB')).toBe(6)\n    expect(score('a__b', 'a__b')).toBe(8)\n    expect(score('aBc', 'ab')).toBe(5.5)\n    expect(score('a_B_c', 'ab')).toBe(5.75)\n    expect(score('abc', 'abc')).toBe(7)\n    expect(score('abc', 'aC')).toBe(0)\n    expect(score('abc', 'ac')).toBe(5.1)\n    expect(score('abC', 'ac')).toBe(5.75)\n    expect(score('abC', 'aC')).toBe(6)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only allow search once","suites":["matchScore"],"updatePoint":{"line":51,"column":35},"line":51,"code":"  it('should only allow search once', () => {\n    expect(score('foobar', 'fbr')).toBe(0)\n    expect(score('foobaRow', 'fbr')).toBe(5.85)\n    expect(score('foobaRow', 'fbR')).toBe(6.1)\n    expect(score('foobar', 'fa')).toBe(5.1)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have higher score for strict match","suites":["matchScore"],"updatePoint":{"line":58,"column":47},"line":58,"code":"  it('should have higher score for strict match', () => {\n    expect(score('language-client-protocol', 'lct')).toBe(6.1)\n    expect(score('language-client-types', 'lct')).toBe(7)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find highest score","suites":["matchScore"],"updatePoint":{"line":63,"column":31},"line":63,"code":"  it('should find highest score', () => {\n    expect(score('ArrayRotateTail', 'art')).toBe(4)\n  })","file":"completion/match.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for around source","suites":["native sources"],"updatePoint":{"line":22,"column":36},"line":22,"code":"  it('should works for around source', async () => {\n    await helper.createDocument()\n    await nvim.setLine('foo ')\n    await helper.wait(100)\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.input('Af')\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n    await nvim.input('<esc>')\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for buffer source","suites":["native sources"],"updatePoint":{"line":34,"column":36},"line":34,"code":"  it('should works for buffer source', async () => {\n    await nvim.command('set hidden')\n    await helper.createDocument()\n    await helper.createDocument()\n    await nvim.setLine('other')\n    await nvim.command('bp')\n    await helper.wait(300)\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.input('io')\n    let res = await helper.visible('other', 'buffer')\n    expect(res).toBe(true)\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for file source","suites":["native sources"],"updatePoint":{"line":48,"column":34},"line":48,"code":"  it('should works for file source', async () => {\n    await helper.edit()\n    await nvim.input('i/')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toBeGreaterThan(0)\n    let res = await helper.visible(items[0].word, 'file')\n    expect(res).toBe(true)\n    await nvim.input('<esc>')\n    await nvim.input('o./')\n    await helper.waitPopup()\n    items = await helper.getItems()\n    let item = items.find(o => o.word == 'vimrc')\n    expect(item).toBeTruthy()\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for file source with other source use same triggerCharacter","suites":["native sources"],"updatePoint":{"line":64,"column":78},"line":64,"code":"  it('should works for file source with other source use same triggerCharacter', async () => {\n    await helper.edit()\n    let source: ISource = {\n      name: 'test',\n      priority: 50,\n      enable: true,\n      firstMatch: false,\n      sourceType: SourceType.Native,\n      triggerCharacters: ['.', '/'],\n      doComplete: async (): Promise<CompleteResult> => {\n        let result: CompleteResult = {\n          items: [{ word: 'foo' }]\n        }\n        return Promise.resolve(result)\n      }\n    }\n    let disposable = sources.addSource(source)\n    await nvim.input('i.')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toBe(1)\n    await nvim.input('/')\n    await helper.waitPopup()\n    items = await helper.getItems()\n    expect(items.length).toBeGreaterThan(1)\n    expect(items[0].word).toBe('foo')\n    disposable.dispose()\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get kind text","suites":["getKindString()"],"updatePoint":{"line":5,"column":26},"line":5,"code":"  it('should get kind text', async () => {\n    let map = new Map()\n    map.set(CompletionItemKind.Enum, 'E')\n    let res = getKindString(CompletionItemKind.Enum, map, '')\n    expect(res).toBe('E')\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get default value","suites":["getKindString()"],"updatePoint":{"line":12,"column":30},"line":12,"code":"  it('should get default value', async () => {\n    let map = new Map()\n    let res = getKindString(CompletionItemKind.Enum, map, 'D')\n    expect(res).toBe('D')\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get start col","suites":["getStartColumn()"],"updatePoint":{"line":20,"column":26},"line":20,"code":"  it('should get start col', async () => {\n    expect(getStartColumn('', [{ label: 'foo' }])).toBe(null)\n    expect(getStartColumn('', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 0), 'a') },\n      { label: 'bar' }])).toBe(null)\n    expect(getStartColumn('foo', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 0), 'a') },\n      { label: 'bar', textEdit: TextEdit.insert(Position.create(0, 1), 'b') }])).toBe(null)\n    expect(getStartColumn('foo', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 2), 'a') },\n      { label: 'bar', textEdit: TextEdit.insert(Position.create(0, 2), 'b') }])).toBe(2)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for when provider not exists","suites":["CallHierarchy"],"updatePoint":{"line":43,"column":47},"line":43,"code":"  it('should throw for when provider not exists', async () => {\n    let err\n    try {\n      await callHierarchy.getIncoming()\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined when prepare failed","suites":["CallHierarchy"],"updatePoint":{"line":53,"column":46},"line":53,"code":"  it('should get undefined when prepare failed', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return undefined\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    let res = await callHierarchy.getOutgoing()\n    expect(res).toBeUndefined()\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get incoming & outgoing callHierarchy items","suites":["CallHierarchy"],"updatePoint":{"line":69,"column":56},"line":69,"code":"  it('should get incoming & outgoing callHierarchy items', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, 'test:///foo', Range.create(0, 0, 0, 5))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('bar', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return [{\n          to: createCallItem('bar', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(1, 0, 1, 5)]\n        }]\n      }\n    }))\n    let res = await callHierarchy.getIncoming()\n    expect(res.length).toBe(1)\n    expect(res[0].from.name).toBe('bar')\n    let outgoing = await callHierarchy.getOutgoing()\n    expect(outgoing.length).toBe(1)\n    res = await callHierarchy.getIncoming(outgoing[0].to)\n    expect(res.length).toBe(1)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when provider not exists","suites":["CallHierarchy"],"updatePoint":{"line":96,"column":50},"line":96,"code":"  it('should show message when provider not exists', async () => {\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toMatch('callHierarchy provider not found')\n    await nvim.command('wincmd p')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should no results when no result returned.","suites":["CallHierarchy"],"updatePoint":{"line":104,"column":48},"line":104,"code":"  it('should no results when no result returned.', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return []\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toBe('No results')\n    await nvim.command('wincmd p')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render description and support default action","suites":["CallHierarchy"],"updatePoint":{"line":123,"column":58},"line":123,"code":"  it('should render description and support default action', async () => {\n    let doc = await workspace.document\n    let bufnr = doc.bufnr\n    await doc.buffer.setLines(['foo'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(1, 0, 1, 3))\n        item.detail = 'Detail'\n        item.tags = [SymbolTag.Deprecated]\n        return [{\n          from: item,\n          fromRanges: [Range.create(2, 0, 2, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('t')\n    await helper.wait(50)\n    let line = await nvim.line\n    expect(line).toEqual('  - c bar Detail')\n    await nvim.input('<cr>')\n    await helper.wait(50)\n    doc = await workspace.document\n    expect(doc.uri).toBe(uri)\n    let res = await nvim.call('coc#cursor#position')\n    expect(res).toEqual([1, 0])\n    let matches = await nvim.call('getmatches') as any[]\n    expect(matches.length).toBe(2)\n    await nvim.command(`b ${bufnr}`)\n    await helper.wait(50)\n    matches = await nvim.call('getmatches')\n    expect(matches.length).toBe(0)\n    await nvim.command(`wincmd o`)\n    await helper.wait(50)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke open in new tab action","suites":["CallHierarchy"],"updatePoint":{"line":175,"column":42},"line":175,"code":"  it('should invoke open in new tab action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    let win = await nvim.window\n    let tab = await nvim.call('tabpagenr')\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('<cr>')\n    await helper.wait(200)\n    let newTab = await nvim.call('tabpagenr')\n    expect(newTab != tab).toBe(true)\n    doc = await workspace.document\n    expect(doc.uri).toBe(uri)\n    let res = await nvim.call('getmatches', [win.id])\n    expect(res.length).toBe(1)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke show incoming calls action","suites":["CallHierarchy"],"updatePoint":{"line":219,"column":46},"line":219,"code":"  it('should invoke show incoming calls action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('test', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('2')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c bar Detail',\n      '  + c test'\n    ])\n    await nvim.command('bd!')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke show outgoing calls action","suites":["CallHierarchy"],"updatePoint":{"line":265,"column":46},"line":265,"code":"  it('should invoke show outgoing calls action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('test', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c foo',\n      '  + c test'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('3')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c test',\n      '  + c bar Detail'\n    ])\n    await nvim.command('bd!')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke dismiss action #1","suites":["CallHierarchy"],"updatePoint":{"line":311,"column":37},"line":311,"code":"  it('should invoke dismiss action #1', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('4')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo'\n    ])\n    await nvim.command('wincmd c')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke dismiss action #2","suites":["CallHierarchy"],"updatePoint":{"line":353,"column":37},"line":353,"code":"  it('should invoke dismiss action #2', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('t')\n    await helper.wait(50)\n    await nvim.command('exe 4')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('4')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  - c bar Detail'\n    ])\n    await nvim.command('wincmd c')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when organize import action not found","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":49,"column":64},"line":49,"code":"    it('should throw error when organize import action not found', async () => {\n      currActions = []\n      await helper.createDocument()\n      let err\n      try {\n        await codeActions.organizeImport()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should perform organize import action","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":61,"column":45},"line":61,"code":"    it('should perform organize import action', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.replace(Range.create(0, 0, 0, 3), 'bar'))\n      edits.push(TextEdit.replace(Range.create(1, 0, 1, 3), 'foo'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('organize import', edit, CodeActionKind.SourceOrganizeImports)\n      currActions = [action, CodeAction.create('another action')]\n      await codeActions.organizeImport()\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar', 'foo'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.organizeImport command","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":75,"column":60},"line":75,"code":"    it('should register editor.action.organizeImport command', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.replace(Range.create(0, 0, 0, 3), 'bar'))\n      edits.push(TextEdit.replace(Range.create(1, 0, 1, 3), 'foo'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('organize import', edit, CodeActionKind.SourceOrganizeImports)\n      currActions = [action, CodeAction.create('another action')]\n      await commands.executeCommand('editor.action.organizeImport')\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar', 'foo'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when no action available","suites":["handler codeActions","codeActionRange"],"updatePoint":{"line":91,"column":52},"line":91,"code":"    it('should show warning when no action available', async () => {\n      await helper.createDocument()\n      currActions = []\n      await codeActions.codeActionRange(1, 2, CodeActionKind.QuickFix)\n      let line = await helper.getCmdline()\n      expect(line).toMatch(/No quickfix code action/)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply choosen action","suites":["handler codeActions","codeActionRange"],"updatePoint":{"line":99,"column":35},"line":99,"code":"    it('should apply choosen action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      let p = codeActions.codeActionRange(1, 2, CodeActionKind.QuickFix)\n      await helper.wait(50)\n      await nvim.input('<CR>')\n      await p\n      let buf = nvim.createBuffer(doc.bufnr)\n      let lines = await buf.lines\n      expect(lines[0]).toBe('bar')\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":117,"column":32},"line":117,"code":"    it('should get empty actions', async () => {\n      currActions = []\n      let doc = await helper.createDocument()\n      let res = await codeActions.getCodeActions(doc)\n      expect(res.length).toBe(0)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter disabled actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":124,"column":38},"line":124,"code":"    it('should filter disabled actions', async () => {\n      currActions = []\n      let action = CodeAction.create('foo', CodeActionKind.QuickFix)\n      action.disabled = { reason: 'disabled' }\n      currActions.push(action)\n      action = CodeAction.create('foo', CodeActionKind.QuickFix)\n      action.disabled = { reason: 'disabled' }\n      currActions.push(action)\n      let doc = await helper.createDocument()\n      let res = await codeActions.getCodeActions(doc)\n      expect(res.length).toBe(0)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":137,"column":30},"line":137,"code":"    it('should get all actions', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false })\n      let action = CodeAction.create('curr action', CodeActionKind.Empty)\n      currActions = [action]\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          return [CodeAction.create('a'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      let res = await codeActions.getCodeActions(doc)\n      expect(range).toEqual(Range.create(0, 0, 3, 0))\n      expect(res.length).toBe(4)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions by range","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":158,"column":38},"line":158,"code":"    it('should filter actions by range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false })\n      currActions = []\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          if (rangeInRange(r, Range.create(0, 0, 1, 0))) return [CodeAction.create('a')]\n          return [CodeAction.create('a'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      let res = await codeActions.getCodeActions(doc, Range.create(0, 0, 0, 0))\n      expect(range).toEqual(Range.create(0, 0, 0, 0))\n      expect(res.length).toBe(1)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions by kind prefix","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":179,"column":44},"line":179,"code":"    it('should filter actions by kind prefix', async () => {\n      let doc = await helper.createDocument()\n      let action = CodeAction.create('my action', CodeActionKind.SourceFixAll)\n      currActions = [action]\n      let res = await codeActions.getCodeActions(doc, undefined, [CodeActionKind.Source])\n      expect(res.length).toBe(1)\n      expect(res[0].kind).toBe(CodeActionKind.SourceFixAll)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by line","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":204,"column":38},"line":204,"code":"    it('should get codeActions by line', async () => {\n      currActions = []\n      await helper.createDocument()\n      let res = await codeActions.getCurrentCodeActions('line')\n      expect(range).toEqual(Range.create(0, 0, 1, 0))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by cursor","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":212,"column":40},"line":212,"code":"    it('should get codeActions by cursor', async () => {\n      currActions = []\n      await helper.createDocument()\n      let res = await codeActions.getCurrentCodeActions('cursor')\n      expect(range).toEqual(Range.create(0, 0, 0, 0))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by visual mode","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":220,"column":45},"line":220,"code":"    it('should get codeActions by visual mode', async () => {\n      currActions = []\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      await nvim.command('normal! 0v$')\n      await nvim.input('<esc>')\n      let res = await codeActions.getCurrentCodeActions('v')\n      expect(range).toEqual(Range.create(0, 0, 0, 3))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when no action exists","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":233,"column":46},"line":233,"code":"    it('should not throw when no action exists', async () => {\n      currActions = []\n      await helper.createDocument()\n      let err\n      try {\n        await codeActions.doCodeAction(undefined)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeUndefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply single code action when only is title","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":245,"column":58},"line":245,"code":"    it('should apply single code action when only is title', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      await codeActions.doCodeAction(undefined, 'code fix')\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply single code action when only is codeAction array","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":257,"column":69},"line":257,"code":"    it('should apply single code action when only is codeAction array', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      await codeActions.doCodeAction(undefined, [CodeActionKind.QuickFix])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should action dialog to choose action","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":269,"column":45},"line":269,"code":"    it('should action dialog to choose action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action, CodeAction.create('foo')]\n      let promise = codeActions.doCodeAction(null)\n      await helper.wait(50)\n      let ids = await nvim.call('coc#float#get_float_win_list') as number[]\n      expect(ids.length).toBeGreaterThan(0)\n      await nvim.input('<CR>')\n      await promise\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should choose code actions by range","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":286,"column":43},"line":286,"code":"    it('should choose code actions by range', async () => {\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          return [CodeAction.create('my title'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      await helper.createDocument()\n      await nvim.setLine('abc')\n      await nvim.command('normal! 0v$')\n      await nvim.input('<esc>')\n      await codeActions.doCodeAction('v', 'my title')\n      expect(range).toEqual({ start: { line: 0, character: 0 }, end: { line: 0, character: 3 } })\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when quickfix action not exists","suites":["handler codeActions","doQuickfix"],"updatePoint":{"line":308,"column":52},"line":308,"code":"    it('should throw when quickfix action not exists', async () => {\n      let err\n      currActions = []\n      await helper.createDocument()\n      try {\n        await codeActions.doQuickfix()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do preferred quickfix action","suites":["handler codeActions","doQuickfix"],"updatePoint":{"line":320,"column":43},"line":320,"code":"    it('should do preferred quickfix action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [CodeAction.create('foo', CodeActionKind.QuickFix), action, CodeAction.create('bar')]\n      await codeActions.doQuickfix()\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve codeAction","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":335,"column":33},"line":335,"code":"    it('should resolve codeAction', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [action]\n      resolvedAction = Object.assign({ edit }, action)\n      let arr = await codeActions.getCurrentCodeActions('line', [CodeActionKind.QuickFix])\n      await codeActions.applyCodeAction(arr[0])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for disabled action","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":350,"column":40},"line":350,"code":"    it('should throw for disabled action', async () => {\n      let action: any = CodeAction.create('my action', CodeActionKind.Empty)\n      action.disabled = { reason: 'disabled', providerId: 'x' }\n      let err\n      try {\n        await codeActions.applyCodeAction(action)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke registered command after apply edit","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":362,"column":57},"line":362,"code":"    it('should invoke registered command after apply edit', async () => {\n      let called\n      disposables.push(commands.registerCommand('test.execute', async (s: string) => {\n        called = s\n        await nvim.command(s)\n      }))\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [action]\n      resolvedAction = Object.assign({\n        edit,\n        command: Command.create('run vim command', 'test.execute', 'normal! $')\n      }, action)\n      let arr = await codeActions.getCurrentCodeActions('line', [CodeActionKind.QuickFix])\n      await codeActions.applyCodeAction(arr[0])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n      expect(called).toBe('normal! $')\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do codeLenes request and resolve codeLenes","suites":["codeLenes featrue"],"updatePoint":{"line":36,"column":55},"line":36,"code":"  it('should do codeLenes request and resolve codeLenes', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1)\n        }, {\n          range: Range.create(1, 0, 1, 1)\n        }]\n      },\n      resolveCodeLens: codeLens => {\n        codeLens.command = Command.create('save', '__save')\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await codeLens.checkProvider()\n    let buf = codeLens.buffers.getItem(doc.bufnr)\n    let codelens = buf.getCodelenses()\n    expect(codelens).toBeDefined()\n    expect(codelens[0].command).toBeDefined()\n    expect(codelens[1].command).toBeDefined()\n    let markers = await helper.getMarkers(doc.bufnr, srcId)\n    expect(markers.length).toBe(2)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh codeLens on CursorHold","suites":["codeLenes featrue"],"updatePoint":{"line":62,"column":43},"line":62,"code":"  it('should refresh codeLens on CursorHold', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: document => {\n        let n = document.lineCount\n        let arr: any[] = []\n        for (let i = 0; i <= n - 2; i++) {\n          arr.push({\n            range: Range.create(i, 0, i, 1),\n            command: Command.create('save', '__save', i)\n          })\n        }\n        return arr\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await helper.wait(100)\n    let markers = await helper.getMarkers(doc.bufnr, srcId)\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    await events.fire('CursorHold', [doc.bufnr])\n    await helper.wait(200)\n    markers = await helper.getMarkers(doc.bufnr, srcId)\n    expect(markers.length).toBe(3)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel codeLenes request on document change","suites":["codeLenes featrue"],"updatePoint":{"line":87,"column":56},"line":87,"code":"  it('should cancel codeLenes request on document change', async () => {\n    let cancelled = false\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: (_, token) => {\n        return new Promise(resolve => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            resolve(null)\n          })\n          let timer = setTimeout(() => {\n            resolve([{\n              range: Range.create(0, 0, 0, 1)\n            }, {\n              range: Range.create(1, 0, 1, 1)\n            }])\n          }, 2000)\n        })\n      },\n      resolveCodeLens: codeLens => {\n        codeLens.command = Command.create('save', '__save')\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('codelens.js')\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'a\\nb\\nc')])\n    let p = codeLens.checkProvider()\n    await doc.applyEdits([TextEdit.replace(Range.create(0, 0, 0, 1), 'foo')])\n    await p\n    expect(cancelled).toBe(true)\n    let buf = codeLens.buffers.getItem(doc.bufnr)\n    let codelens = buf.getCodelenses()\n    expect(codelens).toBeUndefined()\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve on CursorMoved","suites":["codeLenes featrue"],"updatePoint":{"line":122,"column":35},"line":122,"code":"  it('should resolve on CursorMoved', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(90, 0, 90, 1)\n        }, {\n          range: Range.create(91, 0, 91, 1)\n        }]\n      },\n      resolveCodeLens: async codeLens => {\n        await helper.wait(50)\n        codeLens.command = Command.create('save', '__save')\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    let arr = new Array(100)\n    arr.fill('')\n    await nvim.call('setline', [1, arr])\n    await doc.synchronize()\n    await codeLens.checkProvider()\n    await nvim.command('normal! gg')\n    await helper.wait(300)\n    await nvim.command('normal! G')\n    await helper.wait(300)\n    let buf = codeLens.buffers.getItem(doc.bufnr)\n    let codelens = buf.getCodelenses()\n    expect(codelens).toBeDefined()\n    expect(codelens[0].command).toBeDefined()\n    expect(codelens[1].command).toBeDefined()\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke codeLenes action","suites":["codeLenes featrue"],"updatePoint":{"line":154,"column":36},"line":154,"code":"  it('should invoke codeLenes action', async () => {\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1)\n        }]\n      },\n      resolveCodeLens: codeLens => {\n        codeLens.command = Command.create('save', '__save', 1, 2, 3)\n        return codeLens\n      }\n    }))\n    await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await codeLens.checkProvider()\n    await helper.doAction('codeLensAction')\n    expect(fn).toBeCalledWith(1, 2, 3)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use picker fo multiple codeLenses","suites":["codeLenes featrue"],"updatePoint":{"line":177,"column":46},"line":177,"code":"  it('should use picker fo multiple codeLenses', async () => {\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(commands.registerCommand('__delete', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('save', '__save', 1, 2, 3)\n        }, {\n          range: Range.create(0, 1, 0, 2),\n          command: Command.create('save', '__delete', 4, 5, 6)\n        }]\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    await codeLens.checkProvider()\n    let p = helper.doAction('codeLensAction')\n    await helper.wait(30)\n    await nvim.input('<cr>')\n    await p\n    expect(fn).toBeCalledWith(1, 2, 3)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh for failed codeLens request","suites":["codeLenes featrue"],"updatePoint":{"line":207,"column":48},"line":207,"code":"  it('should refresh for failed codeLens request', async () => {\n    let called = 0\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(commands.registerCommand('__foo', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        called++\n        if (called == 1) {\n          return null\n        }\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('foo', '__foo')\n        }]\n      }\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('save', '__save')\n        }]\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await codeLens.checkProvider()\n    let markers = await helper.getMarkers(doc.buffer.id, srcId)\n    expect(markers.length).toBeGreaterThan(0)\n    let codeLensBuffer = codeLens.buffers.getItem(doc.buffer.id)\n    await codeLensBuffer.forceFetch()\n    let curr = codeLensBuffer.currentCodeLens()\n    expect(curr.length).toBeGreaterThan(1)\n    expect(called).toBe(2)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on configuration change","suites":["codeLenes featrue"],"updatePoint":{"line":248,"column":44},"line":248,"code":"  it('should refresh on configuration change', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('save', '__save')\n        }]\n      }\n    }))\n    let filepath = await createTmpFile('abc')\n    let buffer = await helper.edit(filepath)\n    await codeLens.checkProvider()\n    helper.updateConfiguration('codeLens.enable', false)\n    await helper.wait(10)\n    let markers = await helper.getMarkers(buffer.id, srcId)\n    expect(markers.length).toBe(0)\n    helper.updateConfiguration('codeLens.enable', true)\n    await helper.wait(300)\n    markers = await helper.getMarkers(buffer.id, srcId)\n    expect(markers.length).toBeGreaterThan(0)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get hex string","suites":["Colors","utils"],"updatePoint":{"line":62,"column":29},"line":62,"code":"    it('should get hex string', () => {\n      let color = getColor(255, 255, 255)\n      let hex = toHexString(color)\n      expect(hex).toBe('ffffff')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle enable state on configuration change","suites":["Colors","configuration"],"updatePoint":{"line":70,"column":58},"line":70,"code":"    it('should toggle enable state on configuration change', async () => {\n      await helper.createDocument()\n      helper.updateConfiguration('coc.preferences.colorSupport', false)\n      expect(colors.enabled).toBe(false)\n      helper.updateConfiguration('coc.preferences.colorSupport', true)\n      expect(colors.enabled).toBe(true)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.pickColor command","suites":["Colors","commands"],"updatePoint":{"line":80,"column":55},"line":80,"code":"    it('should register editor.action.pickColor command', async () => {\n      await helper.mockFunction('coc#util#pick_color', [0, 0, 0])\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await commands.executeCommand('editor.action.pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#000000')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.colorPresentation command","suites":["Colors","commands"],"updatePoint":{"line":91,"column":63},"line":91,"code":"    it('should register editor.action.colorPresentation command', async () => {\n      colorPresentations = [ColorPresentation.create('red'), ColorPresentation.create('#ff0000')]\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      let p = commands.executeCommand('editor.action.colorPresentation')\n      await helper.wait(100)\n      await nvim.input('1<enter>')\n      await p\n      let line = await nvim.getLine()\n      expect(line).toBe('red')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clearHighlight on empty result","suites":["Colors","doHighlight"],"updatePoint":{"line":107,"column":45},"line":107,"code":"    it('should clearHighlight on empty result', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      state = 'empty'\n      await colors.doHighlight(doc.bufnr)\n      let res = colors.hasColor(doc.bufnr)\n      expect(res).toBe(false)\n      state = 'normal'\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not highlight on error result","suites":["Colors","doHighlight"],"updatePoint":{"line":117,"column":44},"line":117,"code":"    it('should not highlight on error result', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      state = 'error'\n      await colors.doHighlight(doc.bufnr)\n      let res = colors.hasColor(doc.bufnr)\n      expect(res).toBe(false)\n      state = 'normal'\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight after document changed","suites":["Colors","doHighlight"],"updatePoint":{"line":127,"column":47},"line":127,"code":"    it('should highlight after document changed', async () => {\n      let doc = await helper.createDocument()\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(false)\n      expect(colors.hasColorAtPosition(doc.bufnr, Position.create(0, 1))).toBe(false)\n      await nvim.setLine('#ffffff #ff0000')\n      doc.forceSync()\n      await helper.wait(300)\n      expect(colors.hasColorAtPosition(doc.bufnr, Position.create(0, 1))).toBe(true)\n      expect(colors.hasColor(doc.bufnr)).toBe(true)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clearHighlight on clearHighlight","suites":["Colors","doHighlight"],"updatePoint":{"line":140,"column":47},"line":140,"code":"    it('should clearHighlight on clearHighlight', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff #ff0000')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(true)\n      colors.clearHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight colors","suites":["Colors","doHighlight"],"updatePoint":{"line":150,"column":31},"line":150,"code":"    it('should highlight colors', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      await colors.doHighlight(doc.bufnr)\n      let exists = await nvim.call('hlexists', 'BGffffff')\n      expect(exists).toBe(1)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when bufnr not exists","suites":["Colors","hasColor()"],"updatePoint":{"line":160,"column":49},"line":160,"code":"    it('should return false when bufnr not exists', async () => {\n      let res = colors.hasColor(99)\n      colors.clearHighlight(99)\n      expect(res).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when highlighter not exists","suites":["Colors","getColorInformation()"],"updatePoint":{"line":168,"column":54},"line":168,"code":"    it('should return null when highlighter not exists', async () => {\n      let res = await colors.getColorInformation(99)\n      expect(res).toBe(null)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when color not found","suites":["Colors","getColorInformation()"],"updatePoint":{"line":173,"column":47},"line":173,"code":"    it('should return null when color not found', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff foo ')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await nvim.call('cursor', [1, 12])\n      let res = await colors.getColorInformation(doc.bufnr)\n      expect(res).toBe(null)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when bufnr not exists","suites":["Colors","hasColorAtPosition()"],"updatePoint":{"line":185,"column":49},"line":185,"code":"    it('should return false when bufnr not exists', async () => {\n      let res = colors.hasColorAtPosition(99, Position.create(0, 0))\n      expect(res).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when color not exists","suites":["Colors","pickPresentation()"],"updatePoint":{"line":192,"column":49},"line":192,"code":"    it('should show warning when color not exists', async () => {\n      await helper.createDocument()\n      await colors.pickPresentation()\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Color not found')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when presentations not exists","suites":["Colors","pickPresentation()"],"updatePoint":{"line":199,"column":54},"line":199,"code":"    it('should not throw when presentations not exists', async () => {\n      colorPresentations = []\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(99)\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('colorPresentation')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pick presentations","suites":["Colors","pickPresentation()"],"updatePoint":{"line":209,"column":33},"line":209,"code":"    it('should pick presentations', async () => {\n      colorPresentations = [ColorPresentation.create('red'), ColorPresentation.create('#ff0000')]\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      let p = helper.doAction('colorPresentation')\n      await helper.wait(100)\n      await nvim.input('1<enter>')\n      await p\n      let line = await nvim.getLine()\n      expect(line).toBe('red')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when color not exists","suites":["Colors","pickColor()"],"updatePoint":{"line":225,"column":49},"line":225,"code":"    it('should show warning when color not exists', async () => {\n      await helper.createDocument()\n      await colors.pickColor()\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('not found')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pickColor","suites":["Colors","pickColor()"],"updatePoint":{"line":232,"column":24},"line":232,"code":"    it('should pickColor', async () => {\n      await helper.mockFunction('coc#util#pick_color', [0, 0, 0])\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#000000')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when pick color return 0","suites":["Colors","pickColor()"],"updatePoint":{"line":243,"column":49},"line":243,"code":"    it('should not throw when pick color return 0', async () => {\n      await helper.mockFunction('coc#util#pick_color', 0)\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#ffffff')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register global vim commands","suites":["Commands","addVimCommand"],"updatePoint":{"line":32,"column":43},"line":32,"code":"    it('should register global vim commands', async () => {\n      await commandManager.executeCommand('vim.config')\n      await helper.wait(50)\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('coc-settings.json')\n      let list = commands.getCommandList()\n      expect(list.includes('vim.config')).toBe(true)\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add vim command with title","suites":["Commands","addVimCommand"],"updatePoint":{"line":41,"column":41},"line":41,"code":"    it('should add vim command with title', async () => {\n      commands.addVimCommand({ id: 'list', cmd: 'CocList', title: 'list of coc.nvim' })\n      let res = commandManager.titles.get('vim.list')\n      expect(res).toBe('list of coc.nvim')\n      commandManager.unregister('vim.list')\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get command items","suites":["Commands","getCommands"],"updatePoint":{"line":50,"column":32},"line":50,"code":"    it('should get command items', async () => {\n      let res = commands.getCommands()\n      let idx = res.findIndex(o => o.id == 'workspace.showOutput')\n      expect(idx != -1).toBe(true)\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should repeat command","suites":["Commands","repeat"],"updatePoint":{"line":58,"column":29},"line":58,"code":"    it('should repeat command', async () => {\n      // let buf = await nvim.buffer\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.call('cursor', [1, 1])\n      commands.addVimCommand({ id: 'remove', cmd: 'normal! dd' })\n      await commands.runCommand('vim.remove')\n      await helper.wait(50)\n      let res = await nvim.call('getline', [1, '$'])\n      expect(res).toEqual(['b', 'c'])\n      await commands.repeat()\n      await helper.wait(50)\n      res = await nvim.call('getline', [1, '$'])\n      expect(res).toEqual(['c'])\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open command list without id","suites":["Commands","runCommand"],"updatePoint":{"line":75,"column":43},"line":75,"code":"    it('should open command list without id', async () => {\n      await commands.runCommand()\n      await helper.wait(100)\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('list:///commands')\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when no fold ranges found","suites":["Folds"],"updatePoint":{"line":32,"column":51},"line":32,"code":"  it('should return false when no fold ranges found', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return []\n      }\n    }))\n    let res = await folds.fold()\n    expect(res).toBe(false)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fold all fold ranges","suites":["Folds"],"updatePoint":{"line":42,"column":33},"line":42,"code":"  it('should fold all fold ranges', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return [FoldingRange.create(1, 3), FoldingRange.create(4, 6, 0, 0, 'comment')]\n      }\n    }))\n    await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']])\n    let res = await folds.fold()\n    expect(res).toBe(true)\n    let closed = await nvim.call('foldclosed', [2])\n    expect(closed).toBe(2)\n    closed = await nvim.call('foldclosed', [5])\n    expect(closed).toBe(5)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fold comment ranges","suites":["Folds"],"updatePoint":{"line":57,"column":32},"line":57,"code":"  it('should fold comment ranges', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return [FoldingRange.create(1, 3), FoldingRange.create(4, 6, 0, 0, 'comment')]\n      }\n    }))\n    await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']])\n    let res = await folds.fold('comment')\n    expect(res).toBe(true)\n    let closed = await nvim.call('foldclosed', [2])\n    expect(closed).toBe(-1)\n    closed = await nvim.call('foldclosed', [5])\n    expect(closed).toBe(5)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provider not found","suites":["format handler","documentFormat"],"updatePoint":{"line":35,"column":44},"line":35,"code":"    it('should throw when provider not found', async () => {\n      let doc = await helper.createDocument()\n      let err\n      try {\n        await format.documentFormat(doc)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when get empty edits ","suites":["format handler","documentFormat"],"updatePoint":{"line":46,"column":49},"line":46,"code":"    it('should return false when get empty edits ', async () => {\n      disposables.push(languages.registerDocumentFormatProvider(['*'], {\n        provideDocumentFormattingEdits: () => {\n          return []\n        }\n      }))\n      let doc = await helper.createDocument()\n      let res = await format.documentFormat(doc)\n      expect(res).toBe(false)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["format handler","formatOnSave"],"updatePoint":{"line":59,"column":48},"line":59,"code":"    it('should not throw when provider not found', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['javascript'])\n      let filepath = await createTmpFile('')\n      await helper.edit(filepath)\n      await nvim.command('setf javascript')\n      await nvim.setLine('foo')\n      await nvim.command('silent w')\n      await helper.wait(100)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke format on save","suites":["format handler","formatOnSave"],"updatePoint":{"line":69,"column":36},"line":69,"code":"    it('should invoke format on save', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['text'])\n      disposables.push(languages.registerDocumentFormatProvider(['text'], {\n        provideDocumentFormattingEdits: document => {\n          let lines = document.getText().replace(/\\n$/, '').split(/\\n/)\n          let edits: TextEdit[] = []\n          for (let i = 0; i < lines.length; i++) {\n            let text = lines[i]\n            if (!text.startsWith(' ')) {\n              edits.push(TextEdit.insert(Position.create(i, 0), '  '))\n            }\n          }\n          return edits\n        }\n      }))\n      let filepath = await createTmpFile('a\\nb\\nc\\n')\n      let buf = await helper.edit(filepath)\n      await nvim.command('setf text')\n      await nvim.command('w')\n      let lines = await buf.lines\n      expect(lines).toEqual(['  a', '  b', '  c'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when timeout","suites":["format handler","formatOnSave"],"updatePoint":{"line":92,"column":34},"line":92,"code":"    it('should cancel when timeout', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['*'])\n      disposables.push(languages.registerDocumentFormatProvider(['*'], {\n        provideDocumentFormattingEdits: () => {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              resolve(undefined)\n            }, 2000)\n          })\n        }\n      }))\n      let filepath = await createTmpFile('a\\nb\\nc\\n')\n      await helper.edit(filepath)\n      let n = Date.now()\n      await nvim.command('w')\n      expect(Date.now() - n).toBeLessThan(1000)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke range format","suites":["format handler","rangeFormat"],"updatePoint":{"line":112,"column":34},"line":112,"code":"    it('should invoke range format', async () => {\n      disposables.push(languages.registerDocumentRangeFormatProvider(['text'], {\n        provideDocumentRangeFormattingEdits: (_document, range) => {\n          let lines: number[] = []\n          for (let i = range.start.line; i <= range.end.line; i++) {\n            lines.push(i)\n          }\n          return lines.map(i => {\n            return TextEdit.insert(Position.create(i, 0), '  ')\n          })\n        }\n      }))\n      let doc = await helper.createDocument()\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.command('setf text')\n      await nvim.command('normal! ggvG')\n      await nvim.input('<esc>')\n      await helper.doAction('formatSelected', 'v')\n      let buf = nvim.createBuffer(doc.bufnr)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  a', '  b', '  c'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format range by formatexpr option","suites":["format handler","rangeFormat"],"updatePoint":{"line":135,"column":48},"line":135,"code":"    it('should format range by formatexpr option', async () => {\n      let range: Range\n      disposables.push(languages.registerDocumentRangeFormatProvider(['text'], {\n        provideDocumentRangeFormattingEdits: (_document, r) => {\n          range = r\n          return []\n        }\n      }))\n      await helper.createDocument()\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.command('setf text')\n      await nvim.command(`setl formatexpr=CocAction('formatSelected')`)\n      await nvim.command('normal! ggvGgq')\n      expect(range).toEqual({\n        start: { line: 0, character: 0 }, end: { line: 3, character: 0 }\n      })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke format","suites":["format handler","formatOnType"],"updatePoint":{"line":155,"column":28},"line":155,"code":"    it('should invoke format', async () => {\n      disposables.push(languages.registerDocumentFormatProvider(['text'], {\n        provideDocumentFormattingEdits: () => {\n          return [TextEdit.insert(Position.create(0, 0), '  ')]\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      await nvim.command('setf text')\n      await helper.doAction('format')\n      let line = await nvim.line\n      expect(line).toEqual('  foo')\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should does format on type","suites":["format handler","formatOnType"],"updatePoint":{"line":169,"column":34},"line":169,"code":"    it('should does format on type', async () => {\n      disposables.push(languages.registerOnTypeFormattingEditProvider(['text'], {\n        provideOnTypeFormattingEdits: () => {\n          return [TextEdit.insert(Position.create(0, 0), '  ')]\n        }\n      }, ['|']))\n      await helper.edit()\n      await nvim.command('setf text')\n      await nvim.input('i|')\n      await helper.wait(200)\n      let line = await nvim.line\n      expect(line).toBe('  |')\n      let cursor = await window.getCursorPosition()\n      expect(cursor).toEqual({ line: 0, character: 3 })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor after format on type","suites":["format handler","formatOnType"],"updatePoint":{"line":185,"column":49},"line":185,"code":"    it('should adjust cursor after format on type', async () => {\n      disposables.push(languages.registerOnTypeFormattingEditProvider(['text'], {\n        provideOnTypeFormattingEdits: () => {\n          return [\n            TextEdit.insert(Position.create(0, 0), '  '),\n            TextEdit.insert(Position.create(0, 2), 'end')\n          ]\n        }\n      }, ['|']))\n      await helper.edit()\n      await nvim.command('setf text')\n      await nvim.setLine('\"')\n      await nvim.input('i|')\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toBe('  |\"end')\n      let cursor = await window.getCursorPosition()\n      expect(cursor).toEqual({ line: 0, character: 3 })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format vim file on enter","suites":["format handler","bracketEnterImprove"],"updatePoint":{"line":211,"column":39},"line":211,"code":"    it('should format vim file on enter', async () => {\n      let buf = await helper.edit('foo.vim')\n      await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : \"\\\\<C-g>u\\\\<CR>\\\\<c-r>=coc#on_enter()\\\\<CR>\"`)\n      await nvim.setLine('let foo={}')\n      await nvim.command(`normal! gg$`)\n      await nvim.input('i')\n      await nvim.eval(`feedkeys(\"\\\\<CR>\", 'im')`)\n      await helper.wait(100)\n      let lines = await buf.lines\n      expect(lines).toEqual(['let foo={', '  \\\\ ', '  \\\\ }'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add new line between bracket","suites":["format handler","bracketEnterImprove"],"updatePoint":{"line":223,"column":43},"line":223,"code":"    it('should add new line between bracket', async () => {\n      let buf = await helper.edit()\n      await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : \"\\\\<C-g>u\\\\<CR>\\\\<c-r>=coc#on_enter()\\\\<CR>\"`)\n      await nvim.setLine('  {}')\n      await nvim.command(`normal! gg$`)\n      await nvim.input('i')\n      await nvim.eval(`feedkeys(\"\\\\<CR>\", 'im')`)\n      await helper.wait(100)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  {', '  ', '  }'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when highlights provide not exists","suites":["document highlights"],"updatePoint":{"line":50,"column":59},"line":50,"code":"  it('should return null when highlights provide not exists', async () => {\n    let doc = await helper.createDocument()\n    let res = await highlights.getHighlights(doc, Position.create(0, 0))\n    expect(res).toBeNull()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel request on CursorMoved","suites":["document highlights"],"updatePoint":{"line":56,"column":42},"line":56,"code":"  it('should cancel request on CursorMoved', async () => {\n    let fn = jest.fn()\n    languages.registerDocumentHighlightProvider([{ language: '*' }], {\n      provideDocumentHighlights: (_document, _position, token) => {\n        return new Promise(resolve => {\n          token.onCancellationRequested(() => {\n            clearTimeout(timer)\n            fn()\n            resolve([])\n          })\n          let timer = setTimeout(() => {\n            resolve([{ range: Range.create(0, 0, 0, 3) }])\n          }, 3000)\n        })\n      }\n    })\n    await helper.edit()\n    await nvim.setLine('foo')\n    let p = highlights.highlight()\n    await helper.wait(50)\n    await nvim.call('cursor', [1, 2])\n    await p\n    expect(fn).toBeCalled()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlights to symbols","suites":["document highlights"],"updatePoint":{"line":81,"column":38},"line":81,"code":"  it('should add highlights to symbols', async () => {\n    registProvider()\n    await helper.createDocument()\n    await nvim.setLine('foo bar foo')\n    await helper.doAction('highlight')\n    let winid = await nvim.call('win_getid') as number\n    expect(highlights.hasHighlights(winid)).toBe(true)\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return highlight ranges","suites":["document highlights"],"updatePoint":{"line":90,"column":36},"line":90,"code":"  it('should return highlight ranges', async () => {\n    registProvider()\n    await helper.createDocument()\n    await nvim.setLine('foo bar foo')\n    let res = await helper.doAction('symbolRanges')\n    expect(res.length).toBe(2)\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when cursor not in word range","suites":["document highlights"],"updatePoint":{"line":98,"column":54},"line":98,"code":"  it('should return null when cursor not in word range', async () => {\n    disposables.push(languages.registerDocumentHighlightProvider([{ language: '*' }], {\n      provideDocumentHighlights: () => {\n        return [{ range: Range.create(0, 0, 0, 3) }]\n      }\n    }))\n    let doc = await helper.createDocument()\n    await nvim.setLine('  oo')\n    await nvim.call('cursor', [1, 2])\n    let res = await highlights.getHighlights(doc, Position.create(0, 0))\n    expect(res).toBeNull()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when document is command line","suites":["document highlights"],"updatePoint":{"line":111,"column":52},"line":111,"code":"  it('should not throw when document is command line', async () => {\n    await nvim.call('feedkeys', ['q:', 'in'])\n    let doc = await workspace.document\n    expect(doc.isCommandLine).toBe(true)\n    let err\n    try {\n      await highlights.highlight()\n    } catch (e) {\n      err = e\n    }\n    await nvim.input('<C-c>')\n    expect(err).toBeUndefined()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["document highlights"],"updatePoint":{"line":125,"column":46},"line":125,"code":"  it('should not throw when provider not found', async () => {\n    disposeAll(disposables)\n    await helper.createDocument()\n    await nvim.setLine('  oo')\n    await nvim.call('cursor', [1, 2])\n    let err\n    try {\n      await highlights.highlight()\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeUndefined()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when hover not found","suites":["Hover","onHover"],"updatePoint":{"line":44,"column":48},"line":44,"code":"    it('should return false when hover not found', async () => {\n      hoverResult = null\n      let res = await hover.onHover('preview')\n      expect(res).toBe(false)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkupContent hover","suites":["Hover","onHover"],"updatePoint":{"line":50,"column":39},"line":50,"code":"    it('should show MarkupContent hover', async () => {\n      hoverResult = { contents: { kind: 'plaintext', value: 'my hover' } }\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('my hover')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkedString hover","suites":["Hover","onHover"],"updatePoint":{"line":57,"column":38},"line":57,"code":"    it('should show MarkedString hover', async () => {\n      hoverResult = { contents: 'string hover' }\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: { language: 'typescript', value: 'language hover' } }\n        }\n      }))\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('string hover')\n      expect(res).toMatch('language hover')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkedString hover array","suites":["Hover","onHover"],"updatePoint":{"line":70,"column":44},"line":70,"code":"    it('should show MarkedString hover array', async () => {\n      hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] }\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('foo')\n      expect(res).toMatch('bar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight hover range","suites":["Hover","onHover"],"updatePoint":{"line":78,"column":36},"line":78,"code":"    it('should highlight hover range', async () => {\n      await nvim.setLine('var')\n      await nvim.command('normal! 0')\n      hoverResult = { contents: ['foo'], range: Range.create(0, 0, 0, 3) }\n      await hover.onHover('preview')\n      let res = await nvim.call('getmatches') as any[]\n      expect(res.length).toBe(1)\n      expect(res[0].group).toBe('CocHoverRange')\n      await helper.wait(600)\n      res = await nvim.call('getmatches')\n      expect(res.length).toBe(0)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo hover message","suites":["Hover","previewHover"],"updatePoint":{"line":93,"column":33},"line":93,"code":"    it('should echo hover message', async () => {\n      hoverResult = { contents: ['foo'] }\n      let res = await hover.onHover('echo')\n      expect(res).toBe(true)\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('foo')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show hover in float window","suites":["Hover","previewHover"],"updatePoint":{"line":101,"column":41},"line":101,"code":"    it('should show hover in float window', async () => {\n      hoverResult = { contents: { kind: 'markdown', value: '```typescript\\nconst foo:number\\n```' } }\n      await hover.onHover('float')\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await nvim.eval(`getbufline(winbufnr(${win.id}),1,'$')`)\n      expect(lines).toEqual(['const foo:number'])\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get hover from MarkedString array","suites":["Hover","getHover"],"updatePoint":{"line":112,"column":48},"line":112,"code":"    it('should get hover from MarkedString array', async () => {\n      hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] }\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: { language: 'typescript', value: 'MarkupContent hover' } }\n        }\n      }))\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: MarkedString.fromPlainText('MarkedString hover') }\n        }\n      }))\n      let res = await hover.getHover()\n      expect(res.includes('foo')).toBe(true)\n      expect(res.includes('bar')).toBe(true)\n      expect(res.includes('MarkupContent hover')).toBe(true)\n      expect(res.includes('MarkedString hover')).toBe(true)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter empty hover message","suites":["Hover","getHover"],"updatePoint":{"line":131,"column":41},"line":131,"code":"    it('should filter empty hover message', async () => {\n      hoverResult = { contents: [''] }\n      let res = await hover.getHover()\n      expect(res.length).toBe(0)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load definition from buffer","suites":["Hover","definitionHover"],"updatePoint":{"line":139,"column":42},"line":139,"code":"    it('should load definition from buffer', async () => {\n      hoverResult = { contents: 'string hover' }\n      let doc = await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar')])\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition() {\n          return [{\n            targetUri: doc.uri,\n            targetRange: Range.create(0, 0, 1, 3),\n            targetSelectionRange: Range.create(0, 0, 0, 3),\n          }]\n        }\n      }))\n      await hover.definitionHover('preview')\n      let res = await getDocumentText()\n      expect(res).toBe('string hover\\n\\nfoo\\nbar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load definition link from file","suites":["Hover","definitionHover"],"updatePoint":{"line":158,"column":45},"line":158,"code":"    it('should load definition link from file', async () => {\n      let fsPath = await createTmpFile('foo\\nbar\\n')\n      hoverResult = { contents: 'string hover' }\n      let doc = await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar')])\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition() {\n          return [{\n            targetUri: URI.file(fsPath).toString(),\n            targetRange: Range.create(0, 0, 1, 3),\n            targetSelectionRange: Range.create(0, 0, 0, 3),\n          }]\n        }\n      }))\n      await hover.definitionHover('preview')\n      let res = await getDocumentText()\n      expect(res).toBe('string hover\\n\\nfoo\\nbar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check provider for document","suites":["Handler","hasProvider"],"updatePoint":{"line":31,"column":42},"line":31,"code":"    it('should check provider for document', async () => {\n      let res = await handler.hasProvider('definition')\n      expect(res).toBe(false)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when provider not found","suites":["Handler","checkProvier"],"updatePoint":{"line":38,"column":50},"line":38,"code":"    it('should throw error when provider not found', async () => {\n      let doc = await helper.createDocument()\n      let err\n      try {\n        handler.checkProvier('definition', doc.textDocument)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel previous request when called again","suites":["Handler","withRequestToken"],"updatePoint":{"line":51,"column":56},"line":51,"code":"    it('should cancel previous request when called again', async () => {\n      let cancelled = false\n      let p = handler.withRequestToken('test', token => {\n        return new Promise(s => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            s(undefined)\n          })\n          let timer = setTimeout(() => {\n            s(undefined)\n          }, 3000)\n        })\n      }, false)\n      setTimeout(async () => {\n        await handler.withRequestToken('test', () => {\n          return Promise.resolve(undefined)\n        }, false)\n      }, 50)\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel request on insert start","suites":["Handler","withRequestToken"],"updatePoint":{"line":74,"column":45},"line":74,"code":"    it('should cancel request on insert start', async () => {\n      let cancelled = false\n      let p = handler.withRequestToken('test', token => {\n        return new Promise(s => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            s(undefined)\n          })\n          let timer = setTimeout(() => {\n            s(undefined)\n          }, 3000)\n        })\n      }, false)\n      await nvim.input('i')\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get document links","suites":["Links"],"updatePoint":{"line":31,"column":31},"line":31,"code":"  it('should get document links', async () => {\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks: (_doc, _token) => {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5), 'test:///foo'),\n          DocumentLink.create(Range.create(1, 0, 1, 5), 'test:///bar')\n        ]\n      }\n    }))\n    let res = await links.getLinks()\n    expect(res.length).toBe(2)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when link target not resolved","suites":["Links"],"updatePoint":{"line":44,"column":54},"line":44,"code":"  it('should throw error when link target not resolved', async () => {\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5))\n        ]\n      },\n      resolveDocumentLink(link) {\n        return link\n      }\n    }))\n    let res = await links.getLinks()\n    let err\n    try {\n      await links.openLink(res[0])\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open link at current position","suites":["Links"],"updatePoint":{"line":65,"column":42},"line":65,"code":"  it('should open link at current position', async () => {\n    await nvim.setLine('foo')\n    await nvim.command('normal! 0')\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5)),\n        ]\n      },\n      resolveDocumentLink(link) {\n        link.target = 'test:///foo'\n        return link\n      }\n    }))\n    await links.openCurrentLink()\n    let bufname = await nvim.call('bufname', '%')\n    expect(bufname).toBe('test:///foo')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await nvim.call('cursor', [3, 1])\n    let res = await links.openCurrentLink()\n    expect(res).toBe(false)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when current links not found","suites":["Links"],"updatePoint":{"line":88,"column":54},"line":88,"code":"  it('should return false when current links not found', async () => {\n    await nvim.setLine('foo')\n    await nvim.command('normal! 0')\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return []\n      }\n    }))\n    let res = await links.openCurrentLink()\n    expect(res).toBe(false)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get references","suites":["locations","reference"],"updatePoint":{"line":51,"column":29},"line":51,"code":"    it('should get references', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.references()\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to references","suites":["locations","reference"],"updatePoint":{"line":57,"column":33},"line":57,"code":"    it('should jump to references', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoReferences('edit', true)\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when references not found","suites":["locations","reference"],"updatePoint":{"line":65,"column":53},"line":65,"code":"    it('should return false when references not found', async () => {\n      currLocations = []\n      let res = await locations.gotoReferences('edit', true)\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get definitions","suites":["locations","definition"],"updatePoint":{"line":81,"column":30},"line":81,"code":"    it('should get definitions', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.definitions()\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to definitions","suites":["locations","definition"],"updatePoint":{"line":87,"column":34},"line":87,"code":"    it('should jump to definitions', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoDefinition('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when definitions not found","suites":["locations","definition"],"updatePoint":{"line":95,"column":54},"line":95,"code":"    it('should return false when definitions not found', async () => {\n      currLocations = []\n      let res = await locations.gotoDefinition('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get declarations","suites":["locations","declaration"],"updatePoint":{"line":111,"column":31},"line":111,"code":"    it('should get declarations', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.declarations() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to declaration","suites":["locations","declaration"],"updatePoint":{"line":117,"column":34},"line":117,"code":"    it('should jump to declaration', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoDeclaration('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when declaration not found","suites":["locations","declaration"],"updatePoint":{"line":125,"column":54},"line":125,"code":"    it('should return false when declaration not found', async () => {\n      currLocations = []\n      let res = await locations.gotoDeclaration('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get type definition","suites":["locations","typeDefinition"],"updatePoint":{"line":141,"column":34},"line":141,"code":"    it('should get type definition', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.typeDefinitions() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to type definition","suites":["locations","typeDefinition"],"updatePoint":{"line":147,"column":38},"line":147,"code":"    it('should jump to type definition', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoTypeDefinition('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when type definition not found","suites":["locations","typeDefinition"],"updatePoint":{"line":155,"column":58},"line":155,"code":"    it('should return false when type definition not found', async () => {\n      currLocations = []\n      let res = await locations.gotoTypeDefinition('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get implementations","suites":["locations","implementation"],"updatePoint":{"line":171,"column":34},"line":171,"code":"    it('should get implementations', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.implementations() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to implementation","suites":["locations","implementation"],"updatePoint":{"line":177,"column":37},"line":177,"code":"    it('should jump to implementation', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoImplementation('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when implementation not found","suites":["locations","implementation"],"updatePoint":{"line":185,"column":57},"line":185,"code":"    it('should return false when implementation not found', async () => {\n      currLocations = []\n      let res = await locations.gotoImplementation('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when cword not exists","suites":["locations","getTagList"],"updatePoint":{"line":193,"column":48},"line":193,"code":"    it('should return null when cword not exists', async () => {\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when provider not exists","suites":["locations","getTagList"],"updatePoint":{"line":198,"column":51},"line":198,"code":"    it('should return null when provider not exists', async () => {\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when result is empty","suites":["locations","getTagList"],"updatePoint":{"line":205,"column":47},"line":205,"code":"    it('should return null when result is empty', async () => {\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition: () => {\n          return []\n        }\n      }))\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return tag definitions","suites":["locations","getTagList"],"updatePoint":{"line":217,"column":37},"line":217,"code":"    it('should return tag definitions', async () => {\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition: () => {\n          return [createLocation('bar', 2, 0, 2, 5), Location.create(URI.file('/foo').toString(), Range.create(1, 0, 1, 5))]\n        }\n      }))\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toEqual([\n        {\n          name: 'foo',\n          cmd: 'keepjumps 3 | normal 1|',\n          filename: 'test://bar'\n        },\n        { name: 'foo', cmd: 'keepjumps 2 | normal 1|', filename: '/foo' }\n      ])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle locations from language client","suites":["locations","findLocations"],"updatePoint":{"line":252,"column":52},"line":252,"code":"    it('should handle locations from language client', async () => {\n      result = [createLocation('bar', 2, 0, 2, 5)]\n      await locations.findLocations('foo', 'mylocation', {}, false)\n      let res = await nvim.getVar('coc_jump_locations')\n      expect(res).toEqual([{\n        uri: 'test://bar',\n        lnum: 3,\n        end_lnum: 3,\n        col: 1,\n        end_col: 6,\n        filename: 'test://bar',\n        text: '',\n        range: Range.create(2, 0, 2, 5)\n      }])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle nested locations","suites":["locations","findLocations"],"updatePoint":{"line":268,"column":38},"line":268,"code":"    it('should handle nested locations', async () => {\n      let location: any = {\n        location: createLocation('file', 0, 0, 0, 0),\n        children: [{\n          location: createLocation('foo', 3, 0, 3, 5),\n          children: []\n        }, {\n          location: createLocation('bar', 4, 0, 4, 5),\n          children: []\n        }]\n      }\n      result = location\n      await locations.findLocations('foo', 'mylocation', {}, false)\n      let res = await nvim.getVar('coc_jump_locations') as any[]\n      expect(res.length).toBe(3)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when location is undefined","suites":["locations","handleLocations"],"updatePoint":{"line":287,"column":51},"line":287,"code":"    it('should not throw when location is undefined', async () => {\n      await locations.handleLocations(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when locations is empty array","suites":["locations","handleLocations"],"updatePoint":{"line":291,"column":54},"line":291,"code":"    it('should not throw when locations is empty array', async () => {\n      await locations.handleLocations([])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle single location","suites":["locations","handleLocations"],"updatePoint":{"line":295,"column":37},"line":295,"code":"    it('should handle single location', async () => {\n      await locations.handleLocations(createLocation('single', 0, 0, 0, 0))\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('test://single')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle location link","suites":["locations","handleLocations"],"updatePoint":{"line":301,"column":35},"line":301,"code":"    it('should handle location link', async () => {\n      let link = LocationLink.create('test://link', Range.create(0, 0, 0, 3), Range.create(1, 0, 1, 3))\n      await locations.handleLocations([link])\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('test://link')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should follow cursor","suites":["symbols outline","configuration"],"updatePoint":{"line":83,"column":28},"line":83,"code":"    it('should follow cursor', async () => {\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await nvim.command('wincmd p')\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [curr])\n      await helper.wait(50)\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.getLines()\n      expect(lines).toEqual([\n        'OUTLINE', '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n      let signs = await buf.getSigns({ group: 'CocTree' })\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 2,\n        id: 3001,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not follow cursor","suites":["symbols outline","configuration"],"updatePoint":{"line":108,"column":32},"line":108,"code":"    it('should not follow cursor', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.followCursor': false,\n      })\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await nvim.command('wincmd p')\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [curr])\n      await helper.wait(50)\n      let buf = nvim.createBuffer(bufnr)\n      let signs = await buf.getSigns({ group: 'CocTree' })\n      expect(signs.length).toBe(0)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep current window","suites":["symbols outline","configuration"],"updatePoint":{"line":125,"column":34},"line":125,"code":"    it('should keep current window', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.keepWindow': true,\n      })\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      expect(curr).toBe(bufnr)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check on buffer switch","suites":["symbols outline","configuration"],"updatePoint":{"line":136,"column":37},"line":136,"code":"    it('should check on buffer switch', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': true,\n      })\n      await createBuffer()\n      await symbols.showOutline(1)\n      await helper.edit('unnamed')\n      await helper.wait(300)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual(['Document symbol provider not found'])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not check on buffer switch","suites":["symbols outline","configuration"],"updatePoint":{"line":149,"column":41},"line":149,"code":"    it('should not check on buffer switch', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': false\n      })\n      await helper.wait(30)\n      await createBuffer()\n      await symbols.showOutline(1)\n      await helper.edit('unnamed')\n      await helper.wait(100)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE', '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not check on buffer reload","suites":["symbols outline","configuration"],"updatePoint":{"line":165,"column":41},"line":165,"code":"    it('should not check on buffer reload', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': false\n      })\n      await symbols.showOutline(1)\n      await helper.wait(50)\n      await createBuffer()\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by position","suites":["symbols outline","configuration"],"updatePoint":{"line":177,"column":31},"line":177,"code":"    it('should sort by position', async () => {\n      let code = `class myClass {\n  fun2() { }\n  fun1() {}\n}`\n      workspace.configurations.updateUserConfig({\n        'outline.sortBy': 'position',\n      })\n      await createBuffer(code)\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE', '- c myClass 1', '    m fun2 2', '    m fun1 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by name","suites":["symbols outline","configuration"],"updatePoint":{"line":194,"column":27},"line":194,"code":"    it('should sort by name', async () => {\n      let code = `class myClass {\n  fun2() {}\n  fun1() {}\n}`\n      workspace.configurations.updateUserConfig({\n        'outline.sortBy': 'name',\n      })\n      await createBuffer(code)\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE', '- c myClass 1', '    m fun1 3', '    m fun2 2'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose on buffer unload","suites":["symbols outline","events"],"updatePoint":{"line":214,"column":39},"line":214,"code":"    it('should dispose on buffer unload', async () => {\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await nvim.command('tabe')\n      await nvim.command(`bd! ${curr}`)\n      await helper.wait(30)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check current window on BufEnter","suites":["symbols outline","events"],"updatePoint":{"line":225,"column":47},"line":225,"code":"    it('should check current window on BufEnter', async () => {\n      await createBuffer()\n      await symbols.showOutline(0)\n      let winid = await nvim.call('win_getid', [])\n      await nvim.command('enew')\n      await helper.wait(200)\n      let win = await nvim.window\n      expect(win.id).toBe(winid)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should recreated when original window exists","suites":["symbols outline","events"],"updatePoint":{"line":235,"column":52},"line":235,"code":"    it('should recreated when original window exists', async () => {\n      await symbols.showOutline(1)\n      await helper.wait(50)\n      await createBuffer()\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep old outline when new buffer not attached","suites":["symbols outline","events"],"updatePoint":{"line":244,"column":60},"line":244,"code":"    it('should keep old outline when new buffer not attached', async () => {\n      await createBuffer()\n      await symbols.showOutline(1)\n      await nvim.command(`vnew +setl\\\\ buftype=nofile`)\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE', '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not reload when switch to original buffer","suites":["symbols outline","events"],"updatePoint":{"line":257,"column":56},"line":257,"code":"    it('should not reload when switch to original buffer', async () => {\n      await createBuffer()\n      await symbols.showOutline(0)\n      let buf = await getOutlineBuffer()\n      let name = await buf.name\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      buf = await getOutlineBuffer()\n      let curr = await buf.name\n      expect(curr).toBe(name)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose provider on outline hide","suites":["symbols outline","events"],"updatePoint":{"line":269,"column":47},"line":269,"code":"    it('should dispose provider on outline hide', async () => {\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await nvim.command('q')\n      await helper.wait(30)\n      let exists = symbols.hasOutline(bufnr)\n      expect(exists).toBe(false)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when document not attached","suites":["symbols outline","show()"],"updatePoint":{"line":281,"column":47},"line":281,"code":"    it('should throw when document not attached', async () => {\n      await nvim.command(`edit +setl\\\\ buftype=nofile t`)\n      await helper.wait(50)\n      let err\n      try {\n        await symbols.showOutline(1)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not exists","suites":["symbols outline","show()"],"updatePoint":{"line":293,"column":49},"line":293,"code":"    it('should not throw when provider not exists', async () => {\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when symbols is empty","suites":["symbols outline","show()"],"updatePoint":{"line":299,"column":46},"line":299,"code":"    it('should not throw when symbols is empty', async () => {\n      await createBuffer('')\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to selected symbol","suites":["symbols outline","show()"],"updatePoint":{"line":306,"column":38},"line":306,"code":"    it('should jump to selected symbol', async () => {\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      let curr = await nvim.call('bufnr', ['%'])\n      expect(curr).toBe(bufnr)\n      let cursor = await nvim.call('coc#cursor#position')\n      expect(cursor).toEqual([1, 2])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update symbols","suites":["symbols outline","show()"],"updatePoint":{"line":320,"column":29},"line":320,"code":"    it('should update symbols', async () => {\n      await createBuffer()\n      let doc = await workspace.document\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(1)\n      await helper.wait(10)\n      let buf = nvim.createBuffer(bufnr)\n      let code = 'class foo{}'\n      await buf.setLines(code.split('\\n'), {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await doc.synchronize()\n      await helper.wait(200)\n      buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'No results',\n        '',\n        'OUTLINE'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke visual select","suites":["symbols outline","actions"],"updatePoint":{"line":346,"column":35},"line":346,"code":"    it('should invoke visual select', async () => {\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      let m = await nvim.mode\n      expect(m.mode).toBe('v')\n      let buf = await nvim.buffer\n      expect(buf.id).toBe(bufnr)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke selected code action","suites":["symbols outline","actions"],"updatePoint":{"line":362,"column":42},"line":362,"code":"    it('should invoke selected code action', async () => {\n      const codeAction = CodeAction.create('my action', CodeActionKind.Refactor)\n      let uri: string\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document,\n          _range: Range,\n          _context: CodeActionContext,\n          _token: CancellationToken\n        ) => [codeAction],\n        resolveCodeAction: (action): ProviderResult<CodeAction> => {\n          action.edit = {\n            changes: {\n              [uri]: [TextEdit.del(Range.create(0, 0, 0, 5))]\n            }\n          }\n          return action\n        }\n      }, undefined))\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let doc = workspace.getDocument(bufnr)\n      uri = doc.uri\n      await symbols.showOutline(0)\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(200)\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines[0]).toBe(' myClass {')\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide outline","suites":["symbols outline","hide()"],"updatePoint":{"line":399,"column":27},"line":399,"code":"    it('should hide outline', async () => {\n      await createBuffer('')\n      await symbols.showOutline(0)\n      await symbols.hideOutline()\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when outline not exists","suites":["symbols outline","hide()"],"updatePoint":{"line":407,"column":48},"line":407,"code":"    it('should not throw when outline not exists', async () => {\n      await symbols.hideOutline()\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose provider and views","suites":["symbols outline","dispose"],"updatePoint":{"line":415,"column":41},"line":415,"code":"    it('should dispose provider and views', async () => {\n      await createBuffer('')\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(1)\n      symbols.dispose()\n      await helper.wait(50)\n      expect(symbols.hasOutline(bufnr)).toBe(false)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create from workspaceEdit","suites":["refactor","create"],"updatePoint":{"line":33,"column":40},"line":33,"code":"    it('should create from workspaceEdit', async () => {\n      let changes = {\n        [URI.file(__filename).toString()]: [{\n          range: Range.create(0, 0, 0, 6),\n          newText: ''\n        }, {\n          range: Range.create(1, 0, 1, 6),\n          newText: ''\n        }]\n      }\n      let edit: WorkspaceEdit = { changes }\n      let buf = await refactor.fromWorkspaceEdit(edit)\n      let shown = await buf.valid\n      expect(shown).toBe(true)\n      let items = buf.fileItems\n      expect(items.length).toBe(1)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create from locations","suites":["refactor","create"],"updatePoint":{"line":51,"column":36},"line":51,"code":"    it('should create from locations', async () => {\n      let uri = URI.file(__filename).toString()\n      let locations = [{\n        uri,\n        range: Range.create(0, 0, 0, 6),\n      }, {\n        uri,\n        range: Range.create(1, 0, 1, 6),\n      }]\n      let buf = await refactor.fromLocations(locations)\n      let shown = await buf.valid\n      expect(shown).toBe(true)\n      let items = buf.fileItems\n      expect(items.length).toBe(1)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore when change after range","suites":["refactor","onChange"],"updatePoint":{"line":69,"column":45},"line":69,"code":"    it('should ignore when change after range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['foo', 'bar'])\n      await refactor.fromLocations([{ uri: doc.uri, range: Range.create(0, 0, 0, 3) }])\n      let lines = await nvim.call('getline', [1, '$'])\n      await doc.buffer.append(['def'])\n      doc.forceSync()\n      await helper.wait(100)\n      let newLines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(newLines)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust when change before range","suites":["refactor","onChange"],"updatePoint":{"line":81,"column":46},"line":81,"code":"    it('should adjust when change before range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await helper.wait(50)\n      doc.forceSync()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines(['def'], { start: 0, end: 0, strictIndexing: false })\n      doc.forceSync()\n      await helper.wait(100)\n      let fileRange = buf.getFileRange(4)\n      expect(fileRange.start).toBe(2)\n      expect(fileRange.end).toBe(8)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should removed when lines empty","suites":["refactor","onChange"],"updatePoint":{"line":95,"column":39},"line":95,"code":"    it('should removed when lines empty', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await helper.wait(50)\n      doc.forceSync()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines([], { start: 0, end: -1, strictIndexing: false })\n      doc.forceSync()\n      await helper.wait(100)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines.length).toBe(3)\n      let items = buf.fileItems\n      expect(items.length).toBe(0)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change when liens changed","suites":["refactor","onChange"],"updatePoint":{"line":110,"column":40},"line":110,"code":"    it('should change when liens changed', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await helper.wait(50)\n      doc.forceSync()\n      await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines(['def'], { start: 5, end: 6, strictIndexing: false })\n      doc.forceSync()\n      await helper.wait(30)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines[lines.length - 2]).toBe('def')\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #1","suites":["refactor","refactor#getFileChanges"],"updatePoint":{"line":125,"column":29},"line":125,"code":"    it('should get changes #1', async () => {\n      await helper.createDocument()\n      let lines = `\nSave current buffer to make changes\n\\u3000\n\\u3000\n\\u3000/a.ts\n    })\n  } `\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 5, filepath: '/a.ts', lines: ['    })', '  } '] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #2","suites":["refactor","refactor#getFileChanges"],"updatePoint":{"line":139,"column":29},"line":139,"code":"    it('should get changes #2', async () => {\n      let lines = `\n\\u3000/a.ts\n    })\n  } `\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 2, filepath: '/a.ts', lines: ['    })', '  } '] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #3","suites":["refactor","refactor#getFileChanges"],"updatePoint":{"line":149,"column":29},"line":149,"code":"    it('should get changes #3', async () => {\n      let lines = `\n\\u3000/a.ts\n    })\n  }\n\\u3000`\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 2, filepath: '/a.ts', lines: ['    })', '  }'] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #4","suites":["refactor","refactor#getFileChanges"],"updatePoint":{"line":160,"column":29},"line":160,"code":"    it('should get changes #4', async () => {\n      let lines = `\n\\u3000/a.ts\nfoo\n\\u3000/b.ts\nbar\n\\u3000`\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([\n        { filepath: '/a.ts', lnum: 2, lines: ['foo'] },\n        { filepath: '/b.ts', lnum: 4, lines: ['bar'] }\n      ])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create refactor buffer","suites":["refactor","Refactor#createRefactorBuffer"],"updatePoint":{"line":177,"column":37},"line":177,"code":"    it('should create refactor buffer', async () => {\n      await helper.createDocument()\n      let winid = await nvim.call('win_getid')\n      let buf = await refactor.createRefactorBuffer()\n      let curr = await nvim.call('win_getid')\n      expect(curr).toBeGreaterThan(winid)\n      let valid = await buf.valid\n      expect(valid).toBe(true)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to position by <CR>","suites":["refactor","Refactor#createRefactorBuffer"],"updatePoint":{"line":187,"column":39},"line":187,"code":"    it('should jump to position by <CR>', async () => {\n      await helper.createDocument()\n      let buf = await refactor.createRefactorBuffer()\n      let fileItem: FileItem = {\n        filepath: __filename,\n        ranges: [{ start: 10, end: 11 }, { start: 15, end: 20 }]\n      }\n      await buf.addFileItems([fileItem])\n      await nvim.call('cursor', [5, 1])\n      await buf.splitOpen()\n      let line = await nvim.eval('line(\".\")')\n      let bufname = await nvim.eval('bufname(\"%\")')\n      expect(bufname).toMatch('refactor.test.ts')\n      expect(line).toBe(11)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust line ranges after change","suites":["refactor","Refactor#saveRefactor"],"updatePoint":{"line":205,"column":46},"line":205,"code":"    it('should adjust line ranges after change', async () => {\n      let filename = await createTmpFile('foo\\n\\nbar\\n')\n      let fileItem: FileItem = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 1 }, { start: 2, end: 3 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      await buf.addFileItems([fileItem])\n      nvim.pauseNotification()\n      nvim.call('setline', [5, ['xyz']], true)\n      nvim.command('undojoin', true)\n      nvim.call('append', [5, ['de']], true)\n      nvim.command('undojoin', true)\n      nvim.call('append', [8, ['bar']], true)\n      await nvim.resumeNotification()\n      await helper.wait(100)\n      let res = await refactor.save(buf.buffer.id)\n      expect(res).toBe(true)\n      let content = fs.readFileSync(filename, 'utf8')\n      expect(content).toBe('xyz\\nde\\n\\nbar\\nbar\\n')\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not save when no change made","suites":["refactor","Refactor#saveRefactor"],"updatePoint":{"line":227,"column":43},"line":227,"code":"    it('should not save when no change made', async () => {\n      let buf = await refactor.createRefactorBuffer()\n      let fileItem: FileItem = {\n        filepath: __filename,\n        ranges: [{ start: 10, end: 11 }, { start: 15, end: 20 }]\n      }\n      await buf.addFileItems([fileItem])\n      let res = await buf.save()\n      expect(res).toBe(false)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sync buffer change to file","suites":["refactor","Refactor#saveRefactor"],"updatePoint":{"line":238,"column":41},"line":238,"code":"    it('should sync buffer change to file', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.replace(['foo', 'bar', 'line'], 0)\n      await helper.wait(30)\n      let filename = URI.parse(doc.uri).fsPath\n      let fileItem: FileItem = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 2 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      await buf.addFileItems([fileItem])\n      await nvim.call('setline', [5, 'changed'])\n      let res = await buf.save()\n      expect(res).toBe(true)\n      expect(fs.existsSync(filename)).toBe(true)\n      let content = fs.readFileSync(filename, 'utf8')\n      let lines = content.split('\\n')\n      expect(lines).toEqual(['changed', 'bar', 'line', ''])\n      fs.unlinkSync(filename)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when rename provider not found","suites":["refactor","doRefactor"],"updatePoint":{"line":268,"column":51},"line":268,"code":"    it('should throw when rename provider not found', async () => {\n      await helper.createDocument()\n      let err\n      try {\n        await refactor.doRefactor()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when prepare failed","suites":["refactor","doRefactor"],"updatePoint":{"line":279,"column":47},"line":279,"code":"    it('should show message when prepare failed', async () => {\n      await helper.createDocument()\n      disposable = languages.registerRenameProvider(['*'], {\n        prepareRename: () => {\n          return undefined\n        },\n        provideRenameEdits: () => {\n          return null\n        }\n      })\n      await refactor.doRefactor()\n      let res = await helper.getCmdline()\n      expect(res).toMatch(/unable to rename/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when returned edits is null","suites":["refactor","doRefactor"],"updatePoint":{"line":294,"column":55},"line":294,"code":"    it('should show message when returned edits is null', async () => {\n      await helper.createDocument()\n      disposable = languages.registerRenameProvider(['*'], {\n        provideRenameEdits: () => {\n          return null\n        }\n      })\n      await refactor.doRefactor()\n      let res = await helper.getCmdline()\n      expect(res).toMatch(/returns null/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor window when edits is valid","suites":["refactor","doRefactor"],"updatePoint":{"line":306,"column":55},"line":306,"code":"    it('should open refactor window when edits is valid', async () => {\n      let filepath = __filename\n      disposable = languages.registerRenameProvider(['*'], {\n        provideRenameEdits: () => {\n          let changes = {\n            [URI.file(filepath).toString()]: [{\n              range: Range.create(0, 0, 0, 6),\n              newText: ''\n            }, {\n              range: Range.create(1, 0, 1, 6),\n              newText: ''\n            }]\n          }\n          let edit: WorkspaceEdit = { changes }\n          return edit\n        }\n      })\n      await helper.createDocument(filepath)\n      let winid = await nvim.call('win_getid')\n      await refactor.doRefactor()\n      let currWin = await nvim.call('win_getid')\n      expect(currWin - winid).toBeGreaterThan(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let b = refactor.getBuffer(bufnr)\n      expect(b).toBeDefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor buffer from search result","suites":["refactor","search"],"updatePoint":{"line":335,"column":54},"line":335,"code":"    it('should open refactor buffer from search result', async () => {\n      let escaped = await nvim.call('fnameescape', [__dirname])\n      await nvim.command(`cd ${escaped}`)\n      await helper.createDocument()\n      await refactor.search(['registerRenameProvider'])\n      let buf = await nvim.buffer\n      let name = await buf.name\n      expect(name).toMatch(/__coc_refactor__/)\n      let lines = await buf.lines\n      expect(lines[0]).toMatch(/Save current buffer/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["rename handler","getWordEdit"],"updatePoint":{"line":101,"column":48},"line":101,"code":"    it('should not throw when provider not found', async () => {\n      await helper.edit()\n      let res = await rename.getWordEdit()\n      expect(res).toBe(null)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when prepare failed","suites":["rename handler","getWordEdit"],"updatePoint":{"line":107,"column":46},"line":107,"code":"    it('should return null when prepare failed', async () => {\n      let doc = await helper.createDocument('t.js')\n      await nvim.setLine('')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res).toBe(null)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return workspace edit","suites":["rename handler","getWordEdit"],"updatePoint":{"line":115,"column":36},"line":115,"code":"    it('should return workspace edit', async () => {\n      let doc = await helper.createDocument('t.js')\n      await nvim.setLine('foo foo')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res).toBeDefined()\n      expect(res.changes[doc.uri].length).toBe(2)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extract words from buffer","suites":["rename handler","getWordEdit"],"updatePoint":{"line":124,"column":40},"line":124,"code":"    it('should extract words from buffer', async () => {\n      let doc = await helper.createDocument('t')\n      await nvim.setLine('  ')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res).toBeDefined()\n      expect(res.changes[doc.uri].length).toBe(3)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provider not found","suites":["rename handler","rename"],"updatePoint":{"line":135,"column":44},"line":135,"code":"    it('should throw when provider not found', async () => {\n      await helper.edit()\n      let err\n      try {\n        await rename.rename('foo')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for invalid position","suites":["rename handler","rename"],"updatePoint":{"line":146,"column":48},"line":146,"code":"    it('should return false for invalid position', async () => {\n      await helper.createDocument('t.js')\n      let res = await rename.rename('foo')\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from placeholder","suites":["rename handler","rename"],"updatePoint":{"line":152,"column":43},"line":152,"code":"    it('should use newName from placeholder', async () => {\n      await helper.createDocument('t.js')\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for empty name","suites":["rename handler","rename"],"updatePoint":{"line":165,"column":42},"line":165,"code":"    it('should return false for empty name', async () => {\n      await helper.createDocument('t.js')\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(20)\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from range","suites":["rename handler","rename"],"updatePoint":{"line":177,"column":37},"line":177,"code":"    it('should use newName from range', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: (doc, position: Position, newName: string) => {\n          let range = getWordRangeAtPosition(doc, position)\n          if (range) {\n            let word = doc.getText(range)\n            if (word) {\n              let ranges = getSymbolRanges(doc, word)\n              return {\n                changes: {\n                  [doc.uri]: ranges.map(o => TextEdit.replace(o, newName))\n                }\n              }\n            }\n          }\n          return undefined\n        },\n        prepareRename: (doc, position) => {\n          let range = getWordRangeAtPosition(doc, position)\n          return range ? range : null\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('bar bar bar')\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from cword","suites":["rename handler","rename"],"updatePoint":{"line":213,"column":37},"line":213,"code":"    it('should use newName from cword', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: (doc, position: Position, newName: string) => {\n          let range = getWordRangeAtPosition(doc, position)\n          if (range) {\n            let word = doc.getText(range)\n            if (word) {\n              let ranges = getSymbolRanges(doc, word)\n              return {\n                changes: {\n                  [doc.uri]: ranges.map(o => TextEdit.replace(o, newName))\n                }\n              }\n            }\n          }\n          return undefined\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('bar bar bar')\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when result is empty","suites":["rename handler","rename"],"updatePoint":{"line":245,"column":48},"line":245,"code":"    it('should return false when result is empty', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: () => {\n          return null\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined path","suites":["getPathFromArgs"],"updatePoint":{"line":29,"column":31},"line":29,"code":"  it('should get undefined path', async () => {\n    let res = getPathFromArgs(['a'])\n    expect(res).toBeUndefined()\n    res = getPathFromArgs(['a', 'b', '-c'])\n    expect(res).toBeUndefined()\n    res = getPathFromArgs(['a', '-b', 'c'])\n    expect(res).toBeUndefined()\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor window","suites":["search"],"updatePoint":{"line":41,"column":33},"line":41,"code":"  it('should open refactor window', async () => {\n    let search = new Search(nvim, cmd)\n    let buf = await refactor.createRefactorBuffer()\n    await search.run([], cwd, buf)\n    await helper.wait(50)\n    let fileItems = buf.fileItems\n    expect(fileItems.length).toBe(2)\n    expect(fileItems[0].ranges.length).toBe(2)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should abort task","suites":["search"],"updatePoint":{"line":51,"column":23},"line":51,"code":"  it('should abort task', async () => {\n    let search = new Search(nvim, cmd)\n    let buf = await refactor.createRefactorBuffer()\n    let p = search.run(['--sleep', '1000'], cwd, buf)\n    search.abort()\n    await p\n    let fileItems = buf.fileItems\n    expect(fileItems.length).toBe(0)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with CocAction search","suites":["search"],"updatePoint":{"line":61,"column":39},"line":61,"code":"  it('should work with CocAction search', async () => {\n    await helper.doAction('search', ['CocAction'])\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let buf = refactor.getBuffer(bufnr)\n    expect(buf).toBeDefined()\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fail on invalid command","suites":["search"],"updatePoint":{"line":68,"column":36},"line":68,"code":"  it('should fail on invalid command', async () => {\n    let search = new Search(nvim, 'rrg')\n    let buf = await refactor.createRefactorBuffer()\n    let err\n    try {\n      await search.run([], cwd, buf)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n    let msg = await helper.getCmdline()\n    expect(msg).toMatch(/Error on command \"rrg\"/)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show empty result when no result found","suites":["search"],"updatePoint":{"line":82,"column":51},"line":82,"code":"  it('should show empty result when no result found', async () => {\n    await helper.doAction('search', ['should found ' + ' no result'])\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let buf = refactor.getBuffer(bufnr)\n    expect(buf).toBeDefined()\n    let buffer = await nvim.buffer\n    let lines = await buffer.lines\n    expect(lines[1]).toMatch(/No match found/)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use corrent search folder for rg","suites":["search"],"updatePoint":{"line":92,"column":45},"line":92,"code":"  it('should use corrent search folder for rg', async () => {\n    let search = new Search(nvim, 'rg')\n    await helper.createDocument()\n    let buf = await refactor.createRefactorBuffer()\n    await search.run(['-w', 'createRefactorBuffer', 'src/__tests__'], cwd, buf)\n    let buffer = await nvim.buffer\n    let lines = await buffer.lines\n    expect(lines[1].startsWith('Files: ')).toBe(true)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when selectionRange provider not exists","suites":["selectionRange","getSelectionRanges()"],"updatePoint":{"line":31,"column":66},"line":31,"code":"    it('should throw error when selectionRange provider not exists', async () => {\n      let doc = await helper.createDocument()\n      await doc.synchronize()\n      let err\n      try {\n        await selection.getSelectionRanges()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return ranges","suites":["selectionRange","getSelectionRanges()"],"updatePoint":{"line":43,"column":28},"line":43,"code":"    it('should return ranges', async () => {\n      await helper.createDocument()\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{\n            range: Range.create(0, 0, 0, 1)\n          }]\n        }\n      }))\n      let res = await selection.getSelectionRanges()\n      expect(res).toBeDefined()\n      expect(Array.isArray(res)).toBe(true)\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select ranges forward","suites":["selectionRange","selectRange()"],"updatePoint":{"line":69,"column":36},"line":69,"code":"    it('should select ranges forward', async () => {\n      let doc = await helper.createDocument()\n      let called = 0\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar\\ntest\\n')])\n      await nvim.call('cursor', [1, 1])\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          called += 1\n          let arr = [{\n            range: Range.create(0, 0, 0, 1)\n          }, {\n            range: Range.create(0, 0, 0, 3)\n          }, {\n            range: Range.create(0, 0, 1, 3)\n          }]\n          return arr\n        }\n      }))\n      await doc.synchronize()\n      await selection.selectRange('', false)\n      await selection.selectRange('', true)\n      expect(called).toBe(1)\n      let res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 0, 1))\n      await selection.selectRange('v', true)\n      expect(called).toBe(2)\n      res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 0, 3))\n      await selection.selectRange('v', true)\n      expect(called).toBe(3)\n      res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 1, 3))\n      await selection.selectRange('v', true)\n      expect(called).toBe(4)\n      let m = await nvim.mode\n      expect(m.mode).toBe('n')\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select ranges backward","suites":["selectionRange","selectRange()"],"updatePoint":{"line":107,"column":37},"line":107,"code":"    it('should select ranges backward', async () => {\n      let doc = await helper.createDocument()\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar\\ntest\\n')])\n      await nvim.call('cursor', [1, 1])\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          let arr = [{\n            range: Range.create(0, 0, 0, 1)\n          }, {\n            range: Range.create(0, 0, 0, 3)\n          }, {\n            range: Range.create(0, 0, 1, 3)\n          }]\n          return arr\n        }\n      }))\n      await doc.synchronize()\n      await selection.selectRange('', true)\n      let mode = await nvim.call('mode')\n      expect(mode).toBe('v')\n      await nvim.input('<esc>')\n      await workspace.selectRange(Range.create(0, 0, 1, 3))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      let r = await getSelectedRange()\n      expect(r).toEqual(Range.create(0, 0, 0, 3))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      r = await getSelectedRange()\n      expect(r).toEqual(Range.create(0, 0, 0, 1))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      mode = await nvim.call('mode')\n      expect(mode).toBe('n')\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":143,"column":26},"line":143,"code":"    it('should be disabled', async () => {\n      await helper.createDocument()\n      workspace.configurations.updateUserConfig({\n        'coc.preferences.semanticTokensHighlights': false\n      })\n      const curr = await highlighter.getCurrentItem()\n      let err\n      try {\n        curr.checkState()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n      expect(err.message).toMatch('disabled by configuration')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get legend by API","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":159,"column":32},"line":159,"code":"    it('should get legend by API', async () => {\n      const doc = await workspace.document\n      const l = languages.getLegend(doc.textDocument)\n      expect(l).toEqual(legend)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get semanticTokens by API","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":165,"column":40},"line":165,"code":"    it('should get semanticTokens by API', async () => {\n      // const doc = await workspace.document\n      // const highlights = await highlighter.getHighlights(doc.bufnr)\n      // expect(highlights.length).toBe(11)\n      // expect(highlights[0].hlGroup).toBe('CocSem_keyword')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should doHighlight","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":172,"column":26},"line":172,"code":"    it('should doHighlight', async () => {\n      const doc = await workspace.document\n      await nvim.call('CocAction', 'semanticHighlight')\n      const highlights = await nvim.call(\"coc#highlight#get_highlights\", [doc.bufnr, 'semanticTokens'])\n      expect(highlights.length).toBe(11)\n      expect(highlights[0].hlGroup).toBe('CocSem_keyword')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show signature by api","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":32,"column":36},"line":32,"code":"    it('should show signature by api', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger by space","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":51,"column":31},"line":51,"code":"    it('should trigger by space', async () => {\n      let called = false\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          called = true\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, [' ']))\n      await helper.createDocument()\n      await nvim.input('i')\n      await helper.wait(30)\n      await nvim.input(' ')\n      await helper.wait(50)\n      expect(called).toBe(true)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show signature help with param label as string","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":71,"column":61},"line":71,"code":"    it('should show signature help with param label as string', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [\n              SignatureInformation.create('foo()', 'my signature'),\n              SignatureInformation.create('foo(a, b)', 'my signature', ParameterInformation.create('a', 'description')),\n            ],\n            activeParameter: 0,\n            activeSignature: 1\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines.join('\\n')).toMatch(/description/)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider coc_last_placeholder on select mode","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":93,"column":59},"line":93,"code":"    it('should consider coc_last_placeholder on select mode', async () => {\n      let pos: Position\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, position) => {\n          pos = position\n          return {\n            signatures: [\n              SignatureInformation.create('foo(a, b)', 'my signature', ParameterInformation.create('a', 'description')),\n            ],\n            activeParameter: 1,\n            activeSignature: null\n          }\n        }\n      }, []))\n      let doc = await helper.createDocument()\n      let line = await nvim.call('line', ['.'])\n      await nvim.setLine('  fn(abc, def)')\n      await nvim.command('normal! 0fave')\n      await nvim.input('<C-g>')\n      let placeholder = {\n        bufnr: doc.bufnr,\n        start: Position.create(line - 1, 5),\n        end: Position.create(line - 1, 8)\n      }\n      await nvim.setVar('coc_last_placeholder', placeholder)\n      let m = await nvim.mode\n      expect(m.mode).toBe('s')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      expect(pos).toEqual(Position.create(0, 5))\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger signature help","suites":["signatureHelp","events"],"updatePoint":{"line":128,"column":37},"line":128,"code":"    it('should trigger signature help', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(x, y)', 'my signature')],\n            activeParameter: 0,\n            activeSignature: 0\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await nvim.input('(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel trigger on InsertLeave","suites":["signatureHelp","events"],"updatePoint":{"line":148,"column":44},"line":148,"code":"    it('should cancel trigger on InsertLeave', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: async (_doc, _position, token) => {\n          await helper.wait(1000)\n          if (token.isCancellationRequested) return undefined\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      let p = signature.triggerSignatureHelp()\n      await helper.wait(10)\n      await nvim.command('stopinsert')\n      await nvim.call('feedkeys', [String.fromCharCode(27), 'in'])\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not close signature on type","suites":["signatureHelp","events"],"updatePoint":{"line":170,"column":42},"line":170,"code":"    it('should not close signature on type', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await helper.wait(100)\n      await nvim.input('bar')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close signature float when empty signatures returned","suites":["signatureHelp","events"],"updatePoint":{"line":191,"column":67},"line":191,"code":"    it('should close signature float when empty signatures returned', async () => {\n      let empty = false\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          if (empty) return undefined\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      empty = true\n      await signature.triggerSignatureHelp()\n      await helper.wait(50)\n      let res = await nvim.call('coc#float#valid', [win.id])\n      expect(res).toBe(0)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should align signature window to top","suites":["signatureHelp","float window"],"updatePoint":{"line":217,"column":44},"line":217,"code":"    it('should align signature window to top', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      let buf = await nvim.buffer\n      await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true })\n      await nvim.call('cursor', [5, 1])\n      await nvim.input('foo(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n      let res = await nvim.call('coc#float#cursor_relative', [win.id]) as any\n      expect(res.row).toBeLessThan(0)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show parameter docs","suites":["signatureHelp","float window"],"updatePoint":{"line":241,"column":34},"line":241,"code":"    it('should show parameter docs', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(a, b)', 'my signature',\n              ParameterInformation.create('a', 'foo'),\n              ParameterInformation.create([7, 8], 'bar'))],\n            activeParameter: 1,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      let buf = await nvim.buffer\n      await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true })\n      await nvim.call('cursor', [5, 1])\n      await nvim.input('foo(a,')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines.join('\\n')).toMatch('bar')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel signature on timeout","suites":["signatureHelp","configurations"],"updatePoint":{"line":277,"column":42},"line":277,"code":"    it('should cancel signature on timeout', async () => {\n      configurations.updateUserConfig({ 'signature.triggerSignatureWait': 50 })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position, token) => {\n          return new Promise(resolve => {\n            token.onCancellationRequested(() => {\n              clearTimeout(timer)\n              resolve(undefined)\n            })\n            let timer = setTimeout(() => {\n              resolve({\n                signatures: [SignatureInformation.create('foo()', 'my signature')],\n                activeParameter: null,\n                activeSignature: null\n              })\n            }, 200)\n          })\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeUndefined()\n      configurations.updateUserConfig({ 'signature.triggerSignatureWait': 100 })\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide signature window on text change","suites":["signatureHelp","configurations"],"updatePoint":{"line":303,"column":51},"line":303,"code":"    it('should hide signature window on text change', async () => {\n      configurations.updateUserConfig({ 'signature.hideOnTextChange': true })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('ifoo(')\n      let winid = await helper.waitFloat()\n      await nvim.input('x')\n      await helper.wait(100)\n      let res = await nvim.call('coc#float#valid', [winid])\n      expect(res).toBe(0)\n      configurations.updateUserConfig({ 'signature.hideOnTextChange': false })\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable signature help trigger","suites":["signatureHelp","configurations"],"updatePoint":{"line":324,"column":45},"line":324,"code":"    it('should disable signature help trigger', async () => {\n      configurations.updateUserConfig({ 'signature.enable': false })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await nvim.input('(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeUndefined()\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo simple signature help","suites":["signatureHelp","configurations"],"updatePoint":{"line":343,"column":41},"line":343,"code":"    it('should echo simple signature help', async () => {\n      let idx = 0\n      let activeSignature = null\n      configurations.updateUserConfig({ 'signature.target': 'echo' })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(a, b)', 'my signature',\n              ParameterInformation.create('a', 'foo'),\n              ParameterInformation.create([7, 8], 'bar')),\n            SignatureInformation.create('a'.repeat(workspace.env.columns + 10))\n            ],\n            activeParameter: idx,\n            activeSignature\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await signature.triggerSignatureHelp()\n      let line = await helper.getCmdline()\n      expect(line).toMatch('(a, b)')\n      await nvim.input('a,')\n      idx = 1\n      await signature.triggerSignatureHelp()\n      line = await helper.getCmdline()\n      expect(line).toMatch('foo(a, b)')\n      activeSignature = 1\n      await signature.triggerSignatureHelp()\n      line = await helper.getCmdline()\n      expect(line).toMatch('aaaaaa')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse content","suites":["Parser"],"updatePoint":{"line":42,"column":26},"line":42,"code":"  it('should parse content', async () => {\n    let code = `class myClass {\n      fun1() { }\n    }`\n    let parser = new Parser(code)\n    let res = parser.parse()\n    expect(res.length).toBeGreaterThan(0)\n  })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get configuration","suites":["symbols handler","configuration"],"updatePoint":{"line":69,"column":32},"line":69,"code":"    it('should get configuration', async () => {\n      let functionUpdate = symbols.functionUpdate\n      expect(functionUpdate).toBe(false)\n      helper.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true)\n      functionUpdate = symbols.functionUpdate\n      expect(functionUpdate).toBe(true)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update symbols automatically","suites":["symbols handler","configuration"],"updatePoint":{"line":77,"column":43},"line":77,"code":"    it('should update symbols automatically', async () => {\n      helper.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true)\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [2, 8])\n      await events.fire('CursorHold', [buf.id])\n      let val = await buf.getVar('coc_current_function')\n      expect(val).toBe('fun1')\n      await nvim.call('cursor', [1, 8])\n      await events.fire('CursorHold', [buf.id])\n      val = await buf.getVar('coc_current_function')\n      expect(val).toBe('myClass')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get symbols of current buffer","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":96,"column":44},"line":96,"code":"    it('should get symbols of current buffer', async () => {\n      let code = `class myClass {\n      fun1() { }\n    }`\n      await createBuffer(code)\n      let res = await helper.plugin.cocAction('documentSymbols')\n      expect(res.length).toBe(2)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current function symbols","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":105,"column":43},"line":105,"code":"    it('should get current function symbols', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n      fun2() {\n      }\n    }\n    `\n      await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      let res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('fun1')\n      await nvim.command('normal! G')\n      res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset coc_current_function when symbols not exists","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":122,"column":65},"line":122,"code":"    it('should reset coc_current_function when symbols not exists', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      let res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('fun1')\n      await nvim.command('normal! ggdG')\n      res = await symbols.getCurrentFunctionSymbol()\n      expect(res).toBe('')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support SymbolInformation","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":136,"column":40},"line":136,"code":"    it('should support SymbolInformation', async () => {\n      disposables.push(languages.registerDocumentSymbolProvider(['*'], {\n        provideDocumentSymbols: () => {\n          return [\n            SymbolInformation.create('root', SymbolKind.Function, Range.create(0, 0, 0, 10)),\n            SymbolInformation.create('child', SymbolKind.Function, Range.create(0, 0, 0, 10), '', 'root')\n          ]\n        }\n      }))\n      let doc = await helper.createDocument()\n      let res = await symbols.getDocumentSymbols(doc.bufnr)\n      expect(res.length).toBe(2)\n      expect(res[0].text).toBe('root')\n      expect(res[1].text).toBe('child')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when no symbols exists","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":154,"column":50},"line":154,"code":"    it('should show warning when no symbols exists', async () => {\n      disposables.push(languages.registerDocumentSymbolProvider(['*'], {\n        provideDocumentSymbols: () => {\n          return []\n        }\n      }))\n      await helper.createDocument()\n      await nvim.call('cursor', [3, 0])\n      await symbols.selectSymbolRange(false, '', ['Function'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch(/No symbols found/)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select symbol range at cursor position","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":167,"column":53},"line":167,"code":"    it('should select symbol range at cursor position', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      await helper.doAction('selectSymbolRange', false, '', ['Function', 'Method'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      let doc = workspace.getDocument(buf.id)\n      await nvim.input('<esc>')\n      let res = await workspace.getSelectedRange('v', doc)\n      expect(res).toEqual({ start: { line: 1, character: 6 }, end: { line: 2, character: 6 } })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select inner range","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":183,"column":33},"line":183,"code":"    it('should select inner range', async () => {\n      let code = `class myClass {\n      fun1() {\n        let foo;\n      }\n}`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [3, 3])\n      await symbols.selectSymbolRange(true, '', ['Method'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      let doc = workspace.getDocument(buf.id)\n      await nvim.input('<esc>')\n      let res = await workspace.getSelectedRange('v', doc)\n      expect(res).toEqual({\n        start: { line: 2, character: 8 }, end: { line: 2, character: 16 }\n      })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset visualmode when selection not found","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":202,"column":56},"line":202,"code":"    it('should reset visualmode when selection not found', async () => {\n      let code = `class myClass {}`\n      await createBuffer(code)\n      await nvim.call('cursor', [1, 1])\n      await nvim.command('normal! gg0v$')\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      await nvim.input('<esc>')\n      await symbols.selectSymbolRange(true, 'v', ['Method'])\n      mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select symbol range from select range","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":215,"column":52},"line":215,"code":"    it('should select symbol range from select range', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [2, 8])\n      await nvim.command('normal! viw')\n      await nvim.input('<esc>')\n      await helper.doAction('selectSymbolRange', false, 'v', ['Class'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      let doc = workspace.getDocument(buf.id)\n      await nvim.input('<esc>')\n      let res = await workspace.getSelectedRange('v', doc)\n      expect(res).toEqual({ start: { line: 0, character: 0 }, end: { line: 3, character: 4 } })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel symbols request on insert","suites":["symbols handler","cancel"],"updatePoint":{"line":235,"column":47},"line":235,"code":"    it('should cancel symbols request on insert', async () => {\n      let cancelled = false\n      disposables.push(languages.registerDocumentSymbolProvider([{ language: 'text' }], {\n        provideDocumentSymbols: (_doc, token) => {\n          return new Promise(s => {\n            token.onCancellationRequested(() => {\n              if (timer) clearTimeout(timer)\n              cancelled = true\n              s(undefined)\n            })\n            let timer = setTimeout(() => {\n              s(undefined)\n            }, 3000)\n          })\n        }\n      }))\n      let doc = await helper.createDocument('t.txt')\n      let p = symbols.getDocumentSymbols(doc.bufnr)\n      setTimeout(async () => {\n        await nvim.input('i')\n      }, 500)\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get workspace symbols","suites":["symbols handler","workspaceSymbols"],"updatePoint":{"line":262,"column":36},"line":262,"code":"    it('should get workspace symbols', async () => {\n      disposables.push(languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: (_query, _token) => {\n          return [SymbolInformation.create('far', SymbolKind.Class, Range.create(0, 0, 0, 0))]\n        },\n        resolveWorkspaceSymbol: sym => {\n          let res = Object.assign({}, sym)\n          res.location.uri = 'test:///foo'\n          return res\n        }\n      }))\n      disposables.push(languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: (_query, _token) => {\n          return [SymbolInformation.create('bar', SymbolKind.Function, Range.create(0, 0, 0, 0))]\n        }\n      }))\n      let res = await symbols.getWorkspaceSymbols('a')\n      expect(res.length).toBe(2)\n      let resolved = await symbols.resolveWorkspaceSymbol(res[0])\n      expect(resolved?.location?.uri).toBe('test:///foo')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup","suites":["Helper"],"updatePoint":{"line":14,"column":18},"line":14,"code":"  it('should setup', () => {\n    expect(nvim).toBeTruthy()\n    expect(plugin.isReady).toBeTruthy()\n  })","file":"helper.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get filetype","suites":["getFiletype()"],"updatePoint":{"line":52,"column":25},"line":52,"code":"  it('should get filetype', async () => {\n    expect(getFiletype('javascriptreact')).toBe('javascript')\n    expect(getFiletype('typescriptreact')).toBe('typescript')\n    expect(getFiletype('latex')).toBe('tex')\n    expect(getFiletype('foo.bar')).toBe('foo')\n    expect(getFiletype('foo')).toBe('foo')\n  })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview lines","suites":["BasicList","preview()"],"updatePoint":{"line":74,"column":28},"line":74,"code":"    it('should preview lines', async () => {\n      await doPreview({ filetype: '', lines: ['foo', 'bar'] })\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview with bufname","suites":["BasicList","preview()"],"updatePoint":{"line":78,"column":35},"line":78,"code":"    it('should preview with bufname', async () => {\n      await doPreview({\n        bufname: 't.js',\n        filetype: 'typescript',\n        lines: ['foo', 'bar']\n      })\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview with range highlight","suites":["BasicList","preview()"],"updatePoint":{"line":86,"column":43},"line":86,"code":"    it('should preview with range highlight', async () => {\n      let winid = await doPreview({\n        bufname: 't.js',\n        filetype: 'typescript',\n        lines: ['foo', 'bar'],\n        range: Range.create(0, 0, 0, 3)\n      })\n      let res = await nvim.call('getmatches', [winid])\n      expect(res.length).toBeGreaterThan(0)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should overwrite action","suites":["BasicList","createAction()"],"updatePoint":{"line":100,"column":31},"line":100,"code":"    it('should overwrite action', async () => {\n      let idx: number\n      list.createAction({\n        name: 'foo',\n        execute: () => { idx = 0 }\n      })\n      list.createAction({\n        name: 'foo',\n        execute: () => { idx = 1 }\n      })\n      await manager.start(['--normal', 'simple'])\n      await manager.session.ui.ready\n      await manager.doAction('foo')\n      expect(idx).toBe(1)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to uri","suites":["BasicList","jumpTo()"],"updatePoint":{"line":118,"column":26},"line":118,"code":"    it('should jump to uri', async () => {\n      let uri = URI.file(__filename).toString()\n      await list.jumpTo(uri, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('basicList.test.ts')\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to location","suites":["BasicList","jumpTo()"],"updatePoint":{"line":125,"column":31},"line":125,"code":"    it('should jump to location', async () => {\n      let uri = URI.file(__filename).toString()\n      let loc = Location.create(uri, Range.create(0, 0, 1, 0))\n      await list.jumpTo(loc, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('basicList.test.ts')\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to location with empty range","suites":["BasicList","jumpTo()"],"updatePoint":{"line":133,"column":48},"line":133,"code":"    it('should jump to location with empty range', async () => {\n      let uri = URI.file(__filename).toString()\n      let loc = Location.create(uri, Range.create(0, 0, 0, 0))\n      await list.jumpTo(loc, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('basicList.test.ts')\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert uri","suites":["BasicList","convertLocation()"],"updatePoint":{"line":143,"column":26},"line":143,"code":"    it('should convert uri', async () => {\n      let uri = URI.file(__filename).toString()\n      let res = await list.convertLocation(uri)\n      expect(res.uri).toBe(uri)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert location with line","suites":["BasicList","convertLocation()"],"updatePoint":{"line":149,"column":41},"line":149,"code":"    it('should convert location with line', async () => {\n      let uri = URI.file(__filename).toString()\n      let res = await list.convertLocation({ uri, line: 'convertLocation()', text: 'convertLocation' })\n      expect(res.uri).toBe(uri)\n      res = await list.convertLocation({ uri, line: 'convertLocation()' })\n      expect(res.uri).toBe(uri)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert location with custom schema","suites":["BasicList","convertLocation()"],"updatePoint":{"line":157,"column":50},"line":157,"code":"    it('should convert location with custom schema', async () => {\n      let uri = 'test:///foo'\n      let res = await list.convertLocation({ uri, line: 'convertLocation()'})\n      expect(res.uri).toBe(uri)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke quickfix action","suites":["BasicList","quickfix action"],"updatePoint":{"line":165,"column":37},"line":165,"code":"    it('should invoke quickfix action', async () => {\n      list.addLocationActions()\n      await manager.start(['--normal', 'simple', '-arg'])\n      await manager.session.ui.ready\n      await manager.session.ui.selectAll()\n      await manager.doAction('quickfix')\n      let res = await nvim.call('getqflist')\n      expect(res.length).toBeGreaterThan(1)\n    })","file":"list/basicList.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show stderr","suites":["Command task"],"updatePoint":{"line":95,"column":28},"line":95,"code":"  it('should not show stderr', async () => {\n    disposables.push(manager.registerList(new StderrList(nvim)))\n    await manager.start(['stderr'])\n    await manager.session.ui.ready\n    let lines = await nvim.call('getline', [1, '$']) as string[]\n    expect(lines).toEqual(['stdout'])\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show error","suites":["Command task"],"updatePoint":{"line":103,"column":27},"line":103,"code":"  it('should not show error', async () => {\n    disposables.push(manager.registerList(new ErrorTask(nvim)))\n    await manager.start(['error'])\n    await helper.wait(200)\n    let res = await helper.getCmdline()\n    expect(res).toMatch('NOT_EXISTS ENOENT')\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create command task","suites":["Command task"],"updatePoint":{"line":111,"column":32},"line":111,"code":"  it('should create command task', async () => {\n    let list = new DataList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['data'])\n    await helper.wait(500)\n    let lines = await nvim.call('getline', [1, '$']) as string[]\n    expect(lines).toEqual(['foo', 'bar'])\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop command task","suites":["Command task"],"updatePoint":{"line":120,"column":30},"line":120,"code":"  it('should stop command task', async () => {\n    let list = new SleepList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['sleep'])\n    manager.session.stop()\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for bad key","suites":["Command task"],"updatePoint":{"line":127,"column":35},"line":127,"code":"  it('should show error for bad key', async () => {\n    let list = new DataList(nvim)\n    list.config.fixKey('<X-a>')\n    await helper.wait(500)\n    let msg = await helper.getCmdline()\n    expect(msg).toMatch('not supported')\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format path","suites":["formatPath()"],"updatePoint":{"line":4,"column":24},"line":4,"code":"  it('should format path', async () => {\n    expect(formatPath('hidden', 'path')).toBe('')\n    expect(formatPath('full', __filename)).toMatch('formatting.test.ts')\n    expect(formatPath('short', __filename)).toMatch('formatting.test.ts')\n    expect(formatPath('filename', __filename)).toMatch('formatting.test.ts')\n  })","file":"list/formatting.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format list items","suites":["formatListItems"],"updatePoint":{"line":13,"column":30},"line":13,"code":"  it('should format list items', async () => {\n    expect(formatListItems(false, [])).toEqual([])\n    let items: UnformattedListItem[] = [{\n      label: ['a', 'b', 'c']\n    }]\n    expect(formatListItems(false, items)).toEqual([{\n      label: 'a\\tb\\tc'\n    }])\n    items = [{\n      label: ['a', 'b', 'c']\n    }, {\n      label: ['foo', 'bar', 'go']\n    }]\n    expect(formatListItems(true, items)).toEqual([{\n      label: 'a  \\tb  \\tc '\n    }, {\n      label: 'foo\\tbar\\tgo'\n    }])\n  })","file":"list/formatting.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight ranges","suites":["list commands"],"updatePoint":{"line":39,"column":29},"line":39,"code":"  it('should highlight ranges', async () => {\n    await manager.start(['--normal', '--auto-preview', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(200)\n    manager.prompt.cancel()\n    await nvim.command('wincmd k')\n    let name = await nvim.eval('bufname(\"%\")')\n    expect(name).toMatch('location.test.ts')\n    let res = await nvim.call('getmatches')\n    expect(res.length).toBe(1)\n  })","file":"list/location.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change highlight on cursor move","suites":["list commands"],"updatePoint":{"line":51,"column":44},"line":51,"code":"  it('should change highlight on cursor move', async () => {\n    await manager.start(['--normal', '--auto-preview', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(200)\n    await nvim.command('exe 2')\n    let bufnr = await nvim.eval('bufnr(\"%\")')\n    await events.fire('CursorMoved', [bufnr, [2, 1]])\n    await helper.wait(300)\n    await nvim.command('wincmd k')\n    let res = await nvim.call('getmatches')\n    expect(res.length).toBe(1)\n    expect(res[0]['pos1']).toEqual([3, 1, 6])\n  })","file":"list/location.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight multiple line range","suites":["list commands"],"updatePoint":{"line":65,"column":42},"line":65,"code":"  it('should highlight multiple line range', async () => {\n    await manager.start(['--normal', '--auto-preview', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(200)\n    await nvim.command('exe 3')\n    let bufnr = await nvim.eval('bufnr(\"%\")')\n    await events.fire('CursorMoved', [bufnr, [2, 1]])\n    await helper.wait(300)\n    await nvim.command('wincmd k')\n    let res = await nvim.call('getmatches')\n    expect(res.length).toBe(1)\n    expect(res[0]['pos1']).toBeDefined()\n    expect(res[0]['pos2']).toBeDefined()\n  })","file":"list/location.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel and enable prompt","suites":["list","events"],"updatePoint":{"line":43,"column":39},"line":43,"code":"    it('should cancel and enable prompt', async () => {\n      let winid = await nvim.call('win_getid')\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await nvim.call('win_gotoid', [winid])\n      await helper.wait(50)\n      let res = await nvim.call('coc#prompt#activated')\n      expect(res).toBe(0)\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      res = await nvim.call('coc#prompt#activated')\n      expect(res).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be activated","suites":["list","list commands"],"updatePoint":{"line":59,"column":27},"line":59,"code":"    it('should be activated', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      expect(manager.isActivated).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toMatch(/manager.test.ts/)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get list names","suites":["list","list commands"],"updatePoint":{"line":68,"column":29},"line":68,"code":"    it('should get list names', () => {\n      let names = manager.names\n      expect(names.length > 0).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume list","suites":["list","list commands"],"updatePoint":{"line":73,"column":26},"line":73,"code":"    it('should resume list', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(30)\n      await nvim.eval('feedkeys(\"j\", \"in\")')\n      await helper.wait(30)\n      let line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n      await manager.cancel()\n      await helper.wait(30)\n      await manager.resume()\n      await helper.wait(30)\n      line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not quit list with --no-quit","suites":["list","list commands"],"updatePoint":{"line":89,"column":43},"line":89,"code":"    it('should not quit list with --no-quit', async () => {\n      await manager.start(['--normal', '--no-quit', 'location'])\n      await manager.session.ui.ready\n      let winnr = await nvim.eval('win_getid()') as number\n      await manager.doAction()\n      await helper.wait(100)\n      let wins = await nvim.windows\n      let ids = wins.map(o => o.id)\n      expect(ids).toContain(winnr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do default action for first item","suites":["list","list commands"],"updatePoint":{"line":100,"column":47},"line":100,"code":"    it('should do default action for first item', async () => {\n      await manager.start(['--normal', '--first', 'location'])\n      await helper.wait(300)\n      let name = await nvim.eval('bufname(\"%\")') as string\n      let filename = path.basename(__filename)\n      expect(name.includes(filename)).toBe(true)\n      let pos = await nvim.eval('getcurpos()')\n      expect(pos[1]).toBe(1)\n      expect(pos[2]).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next & previous","suites":["list","list commands"],"updatePoint":{"line":111,"column":35},"line":111,"code":"    it('should goto next & previous', async () => {\n      await manager.start(['location'])\n      await manager.session?.ui.ready\n      await helper.wait(60)\n      await manager.doAction()\n      await manager.cancel()\n      let bufname = await nvim.eval('expand(\"%:p\")')\n      expect(bufname).toMatch('manager.test.ts')\n      await manager.next()\n      let line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n      await helper.wait(60)\n      await manager.previous()\n      line = await nvim.call('line', '.')\n      expect(line).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse arguments","suites":["list","list commands"],"updatePoint":{"line":128,"column":30},"line":128,"code":"    it('should parse arguments', async () => {\n      await manager.start(['--input=test', '--normal', '--no-sort', '--ignore-case', '--top', '--number-select', '--auto-preview', '--strict', 'location'])\n      await helper.wait(30)\n      let opts = manager.session?.listOptions\n      expect(opts).toEqual({\n        numberSelect: true,\n        autoPreview: true,\n        first: false,\n        input: 'test',\n        interactive: false,\n        matcher: 'strict',\n        ignorecase: true,\n        position: 'top',\n        mode: 'normal',\n        noQuit: false,\n        sort: false\n      })\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect input option","suites":["list","list options"],"updatePoint":{"line":149,"column":35},"line":149,"code":"    it('should respect input option', async () => {\n      await manager.start(['--input=foo', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(30)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('foo')\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect regex filter","suites":["list","list options"],"updatePoint":{"line":158,"column":35},"line":158,"code":"    it('should respect regex filter', async () => {\n      await manager.start(['--input=f.o', '--regex', 'location'])\n      await helper.wait(200)\n      let item = await manager.session?.ui.item\n      expect(item.label).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect normal option","suites":["list","list options"],"updatePoint":{"line":165,"column":36},"line":165,"code":"    it('should respect normal option', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      let line = await helper.getCmdline()\n      expect(line).toBe('')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect nosort option","suites":["list","list options"],"updatePoint":{"line":172,"column":36},"line":172,"code":"    it('should respect nosort option', async () => {\n      await manager.start(['--ignore-case', '--no-sort', 'location'])\n      await manager.session.ui.ready\n      expect(manager.isActivated).toBe(true)\n      await nvim.input('oo')\n      await helper.wait(100)\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect ignorecase option","suites":["list","list options"],"updatePoint":{"line":182,"column":40},"line":182,"code":"    it('should respect ignorecase option', async () => {\n      await manager.start(['--ignore-case', '--strict', 'location'])\n      await manager.session.ui.ready\n      expect(manager.isActivated).toBe(true)\n      await nvim.input('bar')\n      await helper.wait(100)\n      let n = manager.session?.ui.length\n      expect(n).toBe(1)\n      let line = await nvim.line\n      expect(line).toMatch('Bar')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect top option","suites":["list","list options"],"updatePoint":{"line":194,"column":33},"line":194,"code":"    it('should respect top option', async () => {\n      await manager.start(['--top', 'location'])\n      await manager.session.ui.ready\n      let nr = await nvim.call('winnr')\n      expect(nr).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect number select option","suites":["list","list options"],"updatePoint":{"line":201,"column":43},"line":201,"code":"    it('should respect number select option', async () => {\n      await manager.start(['--number-select', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await nvim.eval('feedkeys(\"2\", \"in\")')\n      await helper.wait(100)\n      let lnum = locations[1].lnum\n      let curr = await nvim.call('line', '.')\n      expect(lnum).toBe(curr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect auto preview option","suites":["list","list options"],"updatePoint":{"line":212,"column":42},"line":212,"code":"    it('should respect auto preview option', async () => {\n      await manager.start(['--auto-preview', 'location'])\n      await helper.wait(300)\n      let previewWinnr = await nvim.call('coc#list#has_preview')\n      expect(previewWinnr).toBe(2)\n      let bufnr = await nvim.call('winbufnr', previewWinnr)\n      let buf = nvim.createBuffer(bufnr)\n      let name = await buf.name\n      expect(name).toMatch('manager.test.ts')\n      await nvim.eval('feedkeys(\"j\", \"in\")')\n      await helper.wait(100)\n      let winnr = await nvim.call('coc#list#has_preview')\n      expect(winnr).toBe(previewWinnr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect tab option","suites":["list","list options"],"updatePoint":{"line":227,"column":33},"line":227,"code":"    it('should respect tab option', async () => {\n      await manager.start(['--tab', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(200)\n      await nvim.command('wincmd l')\n      let previewwindow = await nvim.eval('w:previewwindow')\n      expect(previewwindow).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change indicator","suites":["list","list configuration"],"updatePoint":{"line":238,"column":31},"line":238,"code":"    it('should change indicator', async () => {\n      helper.updateConfiguration('list.indicator', '>>')\n      await manager.start(['location'])\n      await helper.wait(200)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('>>')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should split right for preview window","suites":["list","list configuration"],"updatePoint":{"line":246,"column":45},"line":246,"code":"    it('should split right for preview window', async () => {\n      helper.updateConfiguration('list.previewSplitRight', true)\n      let win = await nvim.window\n      await manager.start(['location'])\n      await helper.wait(100)\n      await manager.doAction('preview')\n      await helper.wait(100)\n      manager.prompt.cancel()\n      await helper.wait(10)\n      await nvim.call('win_gotoid', [win.id])\n      await nvim.command('wincmd l')\n      let curr = await nvim.window\n      let isPreview = await curr.getVar('previewwindow')\n      expect(isPreview).toBe(1)\n      helper.updateConfiguration('list.previewSplitRight', false)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection mode","suites":["list","list configuration"],"updatePoint":{"line":263,"column":36},"line":263,"code":"    it('should toggle selection mode', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session?.ui.ready\n      await nvim.input('V')\n      await helper.wait(30)\n      await nvim.input('1')\n      await helper.wait(30)\n      await nvim.input('j')\n      await helper.wait(100)\n      await manager.session?.ui.toggleSelection()\n      let items = await manager.session?.ui.getItems()\n      expect(items.length).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change next/previous keymap","suites":["list","list configuration"],"updatePoint":{"line":277,"column":42},"line":277,"code":"    it('should change next/previous keymap', async () => {\n      helper.updateConfiguration('list.nextKeymap', '<tab>')\n      helper.updateConfiguration('list.previousKeymap', '<s-tab>')\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await nvim.eval('feedkeys(\"\\\\<tab>\", \"in\")')\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toMatch('Bar')\n      await nvim.eval('feedkeys(\"\\\\<s-tab>\", \"in\")')\n      await helper.wait(100)\n      line = await nvim.line\n      expect(line).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect mouse events","suites":["list","list configuration"],"updatePoint":{"line":293,"column":35},"line":293,"code":"    it('should respect mouse events', async () => {\n      async function setMouseEvent(line: number): Promise<void> {\n        let winid = manager.session?.ui.winid\n        await nvim.command(`let v:mouse_winid = ${winid}`)\n        await nvim.command(`let v:mouse_lnum = ${line}`)\n        await nvim.command(`let v:mouse_col = 1`)\n      }\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await setMouseEvent(1)\n      await manager.onNormalInput('<LeftMouse>')\n      await setMouseEvent(2)\n      await manager.onNormalInput('<LeftDrag>')\n      await setMouseEvent(3)\n      await manager.onNormalInput('<LeftRelease>')\n      await helper.wait(100)\n      let items = await manager.session?.ui.getItems()\n      expect(items.length).toBe(3)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle preview","suites":["list","list configuration"],"updatePoint":{"line":314,"column":29},"line":314,"code":"    it('should toggle preview', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await manager.togglePreview()\n      await helper.wait(100)\n      await manager.togglePreview()\n      await helper.wait(100)\n      let has = await nvim.call('coc#list#has_preview')\n      expect(has).toBeGreaterThan(0)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show help of current list","suites":["list","list configuration"],"updatePoint":{"line":326,"column":40},"line":326,"code":"    it('should show help of current list', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await helper.wait(200)\n      await manager.session?.showHelp()\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toBe('[LIST HELP]')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve list item","suites":["list","list configuration"],"updatePoint":{"line":334,"column":32},"line":334,"code":"    it('should resolve list item', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open', execute: _item => {\n            // noop\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }]),\n        resolveItem: item => {\n          item.label = item.label.slice(0, 1)\n          return Promise.resolve(item)\n        }\n      }\n      let disposable = manager.registerList(list)\n      await manager.start(['--normal', 'test'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      let line = await nvim.line\n      expect(line).toBe('f')\n      disposable.dispose()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get descriptions","suites":["list","descriptions"],"updatePoint":{"line":360,"column":31},"line":360,"code":"    it('should get descriptions', async () => {\n      let res = manager.descriptions\n      expect(res).toBeDefined()\n      expect(res.location).toBeDefined()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load items for list","suites":["list","loadItems()"],"updatePoint":{"line":368,"column":34},"line":368,"code":"    it('should load items for list', async () => {\n      let res = await manager.loadItems('location')\n      expect(res.length).toBeGreaterThan(0)\n        ; (manager as any).lastSession = undefined\n      manager.toggleMode()\n      manager.stop()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle insert input","suites":["list","onInsertInput()"],"updatePoint":{"line":378,"column":34},"line":378,"code":"    it('should handle insert input', async () => {\n      await manager.onInsertInput('k')\n      await manager.onInsertInput('<LeftMouse>')\n      await manager.start(['--number-select', 'location'])\n      await manager.session.ui.ready\n      await manager.onInsertInput('1')\n      await helper.wait(300)\n      let bufname = await nvim.call('expand', ['%:p'])\n      expect(bufname).toMatch('manager.test.ts')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore invalid input","suites":["list","onInsertInput()"],"updatePoint":{"line":389,"column":35},"line":389,"code":"    it('should ignore invalid input', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await manager.onInsertInput('<X-y>')\n      await manager.onInsertInput(String.fromCharCode(65533))\n      await manager.onInsertInput(String.fromCharCode(30))\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore <plug> insert","suites":["list","onInsertInput()"],"updatePoint":{"line":398,"column":35},"line":398,"code":"    it('should ignore <plug> insert', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await nvim.eval('feedkeys(\"\\\\<plug>x\", \"in\")')\n      await helper.wait(50)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for bad option","suites":["list","parseArgs()"],"updatePoint":{"line":408,"column":40},"line":408,"code":"    it('should show error for bad option', async () => {\n      manager.parseArgs(['$x', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Invalid list option')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for option not exists","suites":["list","parseArgs()"],"updatePoint":{"line":414,"column":47},"line":414,"code":"    it('should show error for option not exists', async () => {\n      manager.parseArgs(['-xyz', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Invalid option')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for interactive with list not support interactive","suites":["list","parseArgs()"],"updatePoint":{"line":420,"column":75},"line":420,"code":"    it('should show error for interactive with list not support interactive', async () => {\n      manager.parseArgs(['--interactive', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('not supported')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume by name","suites":["list","resume()"],"updatePoint":{"line":428,"column":29},"line":428,"code":"    it('should resume by name', async () => {\n      await events.fire('FocusGained', [])\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      await manager.session.hide()\n      await helper.wait(100)\n      await manager.resume('location')\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error when loadItems throws","suites":["list","start()"],"updatePoint":{"line":441,"column":47},"line":441,"code":"    it('should show error when loadItems throws', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open',\n          execute: (_item: ListItem) => {\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => {\n          throw new Error('test error')\n        }\n      }\n      manager.registerList(list)\n      await manager.start(['test'])\n      await nvim.command('redraw')\n      await helper.wait(200)\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('test error')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get session by name","suites":["list","first(), last()"],"updatePoint":{"line":464,"column":34},"line":464,"code":"    it('should get session by name', async () => {\n      let last: string\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open',\n          execute: (item: ListItem) => {\n            last = item.label\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }])\n      }\n      manager.registerList(list)\n      await manager.start(['test'])\n      await manager.session.ui.ready\n      await manager.first('a')\n      await manager.last('a')\n      await manager.first('test')\n      expect(last).toBe('foo')\n      await manager.last('test')\n      expect(last).toBe('bar')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should recreat list","suites":["list","registerList()"],"updatePoint":{"line":490,"column":27},"line":490,"code":"    it('should recreat list', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open', execute: _item => {\n            // noop\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }])\n      }\n      manager.registerList(list)\n      helper.updateConfiguration('list.source.test.defaultAction', 'open')\n      let disposable = manager.registerList(list)\n      disposable.dispose()\n      await helper.wait(30)\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('recreated')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should tabopen by t","suites":["list normal mappings"],"updatePoint":{"line":88,"column":25},"line":88,"code":"  it('should tabopen by t', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(100)\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open by <cr>","suites":["list normal mappings"],"updatePoint":{"line":97,"column":25},"line":97,"code":"  it('should open by <cr>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<cr>\", \"in\")')\n    await helper.wait(100)\n    let bufname = await nvim.call('expand', ['%:p'])\n    expect(bufname).toMatch('mappings.test.ts')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop by <C-c>","suites":["list normal mappings"],"updatePoint":{"line":106,"column":26},"line":106,"code":"  it('should stop by <C-c>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-c>\", \"in\")')\n    await helper.wait(50)\n    let loading = manager.session?.worker.isLoading\n    expect(loading).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back by <C-o>","suites":["list normal mappings"],"updatePoint":{"line":115,"column":31},"line":115,"code":"  it('should jump back by <C-o>', async () => {\n    let doc = await helper.createDocument()\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-o>\", \"in\")')\n    await helper.wait(50)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBe(doc.bufnr)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll preview window by <C-e>, <C-y>","suites":["list normal mappings"],"updatePoint":{"line":125,"column":50},"line":125,"code":"  it('should scroll preview window by <C-e>, <C-y>', async () => {\n    await helper.createDocument()\n    await manager.start(['--auto-preview', '--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(100)\n    let winnr = await nvim.call('coc#list#has_preview') as number\n    expect(winnr).toBeGreaterThan(0)\n    let winid = await nvim.call('win_getid', [winnr])\n    await nvim.eval('feedkeys(\"\\\\<C-e>\", \"in\")')\n    await helper.wait(50)\n    let res = await nvim.call('getwininfo', [winid])\n    expect(res[0].topline).toBeGreaterThan(1)\n    await nvim.eval('feedkeys(\"\\\\<C-y>\", \"in\")')\n    await helper.wait(50)\n    res = await nvim.call('getwininfo', [winid])\n    expect(res[0].topline).toBeLessThan(7)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert command by :","suites":["list normal mappings"],"updatePoint":{"line":143,"column":32},"line":143,"code":"  it('should insert command by :', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\":\", \"in\")')\n    await helper.wait(50)\n    await nvim.eval('feedkeys(\"let g:x = 1\\\\<cr>\", \"in\")')\n    await helper.wait(50)\n    let res = await nvim.getVar('x')\n    expect(res).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action by <tab>","suites":["list normal mappings"],"updatePoint":{"line":154,"column":35},"line":154,"code":"  it('should select action by <tab>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<tab>\", \"in\")')\n    await helper.wait(100)\n    await nvim.input('t')\n    await helper.wait(300)\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview by p","suites":["list normal mappings"],"updatePoint":{"line":165,"column":25},"line":165,"code":"  it('should preview by p', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(50)\n    await nvim.eval('feedkeys(\"p\", \"in\")')\n    await helper.wait(200)\n    let winnr = await nvim.call('coc#list#has_preview')\n    expect(winnr).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop task by <C-c>","suites":["list normal mappings"],"updatePoint":{"line":175,"column":31},"line":175,"code":"  it('should stop task by <C-c>', async () => {\n    let disposable = manager.registerList(new TestList(nvim))\n    let p = manager.start(['--normal', 'test'])\n    await helper.wait(200)\n    await nvim.input('<C-c>')\n    await helper.wait(200)\n    await p\n    let len = manager.session?.ui.length\n    expect(len).toBe(0)\n    disposable.dispose()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel list by <esc>","suites":["list normal mappings"],"updatePoint":{"line":187,"column":33},"line":187,"code":"  it('should cancel list by <esc>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<esc>\", \"in\")')\n    await helper.wait(200)\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload list by <C-l>","suites":["list normal mappings"],"updatePoint":{"line":195,"column":33},"line":195,"code":"  it('should reload list by <C-l>', async () => {\n    let list = new TestList(nvim)\n    list.timeout = 0\n    let disposable = manager.registerList(list)\n    await manager.start(['--normal', 'test'])\n    await manager.session.ui.ready\n    list.text = 'new'\n    await nvim.input('<C-l>')\n    await helper.wait(30)\n    let line = await nvim.line\n    expect(line).toMatch('new')\n    disposable.dispose()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select all items by <C-a>","suites":["list normal mappings"],"updatePoint":{"line":209,"column":38},"line":209,"code":"  it('should select all items by <C-a>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.input('<C-a>')\n    await helper.wait(30)\n    let selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection <space>","suites":["list normal mappings"],"updatePoint":{"line":218,"column":37},"line":218,"code":"  it('should toggle selection <space>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<space>\", \"in\")')\n    await helper.wait(100)\n    let selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(1)\n    await nvim.eval('feedkeys(\"k\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"\\\\<space>\", \"in\")')\n    await helper.wait(100)\n    selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to insert mode by i, o, a","suites":["list normal mappings"],"updatePoint":{"line":233,"column":45},"line":233,"code":"  it('should change to insert mode by i, o, a', async () => {\n    let keys = ['i', 'I', 'o', 'O', 'a', 'A']\n    for (let key of keys) {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      await nvim.eval(`feedkeys(\"${key}\", \"in\")`)\n      await helper.wait(100)\n      let mode = manager.prompt.mode\n      expect(mode).toBe('insert')\n    }\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show help by ?","suites":["list normal mappings"],"updatePoint":{"line":246,"column":27},"line":246,"code":"  it('should show help by ?', async () => {\n    await manager.start(['--normal', 'location'])\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"?\", \"in\")')\n    await helper.wait(30)\n    await nvim.input('<CR>')\n    await helper.wait(100)\n    let bufname = await nvim.call('bufname', '%')\n    expect(bufname).toBe('[LIST HELP]')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should drop by d","suites":["list normal mappings"],"updatePoint":{"line":257,"column":22},"line":257,"code":"  it('should drop by d', async () => {\n    await manager.start(['--normal', 'location'])\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"d\", \"in\")')\n    await helper.wait(100)\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should split by s","suites":["list normal mappings"],"updatePoint":{"line":266,"column":23},"line":266,"code":"  it('should split by s', async () => {\n    await manager.start(['--normal', 'location'])\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"s\", \"in\")')\n    await helper.wait(100)\n    let nr = await nvim.call('winnr')\n    expect(nr).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open by <cr>","suites":["list insert mappings"],"updatePoint":{"line":277,"column":25},"line":277,"code":"  it('should open by <cr>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<cr>\", \"in\")')\n    await helper.wait(100)\n    let bufname = await nvim.call('expand', ['%:p'])\n    expect(bufname).toMatch('mappings.test.ts')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should paste input by <C-v>","suites":["list insert mappings"],"updatePoint":{"line":286,"column":33},"line":286,"code":"  it('should paste input by <C-v>', async () => {\n    await nvim.call('setreg', ['*', 'foo'])\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-v>\", \"in\")')\n    await helper.wait(100)\n    let input = manager.prompt.input\n    expect(input).toBe('foo')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert register content by <C-r>","suites":["list insert mappings"],"updatePoint":{"line":296,"column":45},"line":296,"code":"  it('should insert register content by <C-r>', async () => {\n    await nvim.call('setreg', ['*', 'foo'])\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-r>\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"*\", \"in\")')\n    await helper.wait(100)\n    let input = manager.prompt.input\n    expect(input).toBe('foo')\n    await nvim.eval('feedkeys(\"\\\\<C-r>\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"<\", \"in\")')\n    await helper.wait(100)\n    input = manager.prompt.input\n    expect(input).toBe('foo')\n    manager.prompt.reset()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["list insert mappings"],"updatePoint":{"line":315,"column":28},"line":315,"code":"  it('should cancel by <esc>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<esc>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action by <tab>","suites":["list insert mappings"],"updatePoint":{"line":323,"column":35},"line":323,"code":"  it('should select action by <tab>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.wait(100)\n    nvim.call('eval', 'feedkeys(\"\\\\<tab>\", \"in\")', true)\n    await helper.wait(100)\n    await nvim.input('t')\n    await helper.wait(500)\n    let pages = await nvim.tabpages\n    expect(pages.length).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action for visual selected items","suites":["list insert mappings"],"updatePoint":{"line":335,"column":52},"line":335,"code":"  it('should select action for visual selected items', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(100)\n    await nvim.input('V')\n    await helper.wait(30)\n    await nvim.input('2')\n    await helper.wait(30)\n    await nvim.input('j')\n    await helper.wait(30)\n    await manager.doAction('tabe')\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBeGreaterThan(3)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop loading by <C-c>","suites":["list insert mappings"],"updatePoint":{"line":350,"column":34},"line":350,"code":"  it('should stop loading by <C-c>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-c>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload by <C-l>","suites":["list insert mappings"],"updatePoint":{"line":358,"column":28},"line":358,"code":"  it('should reload by <C-l>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-l>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to normal mode by <C-o>","suites":["list insert mappings"],"updatePoint":{"line":366,"column":43},"line":366,"code":"  it('should change to normal mode by <C-o>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-o>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(true)\n    let line = await helper.getCmdline()\n    expect(line).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select line by <down> and <up>","suites":["list insert mappings"],"updatePoint":{"line":376,"column":43},"line":376,"code":"  it('should select line by <down> and <up>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<down>\", \"in\")')\n    await helper.wait(50)\n    await nvim.eval('feedkeys(\"\\\\<up>\", \"in\")')\n    await helper.wait(50)\n    expect(manager.isActivated).toBe(true)\n    let line = await nvim.line\n    expect(line).toMatch('foo')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <left> and <right>","suites":["list insert mappings"],"updatePoint":{"line":388,"column":46},"line":388,"code":"  it('should move cursor by <left> and <right>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"\\\\<left>\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"\\\\<left>\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"a\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"\\\\<right>\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"\\\\<right>\", \"in\")')\n    await helper.wait(10)\n    await nvim.eval('feedkeys(\"c\", \"in\")')\n    await helper.wait(10)\n    let input = manager.prompt.input\n    expect(input).toBe('afc')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <end> and <home>","suites":["list insert mappings"],"updatePoint":{"line":409,"column":44},"line":409,"code":"  it('should move cursor by <end> and <home>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<home>\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<end>a\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    expect(input).toBe('a')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <PageUp> <PageDown> <C-d>","suites":["list insert mappings"],"updatePoint":{"line":420,"column":53},"line":420,"code":"  it('should move cursor by <PageUp> <PageDown> <C-d>', async () => {\n    let disposable = manager.registerList(lineList)\n    await manager.start(['lines'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<PageDown>\", \"in\")')\n    await helper.wait(100)\n    let line = await nvim.eval('line(\".\")')\n    expect(line).toBeGreaterThan(1)\n    await nvim.eval('feedkeys(\"\\\\<PageUp>\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"\\\\<C-d>\", \"in\")')\n    await helper.wait(100)\n    disposable.dispose()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll window by <C-f> and <C-b>","suites":["list insert mappings"],"updatePoint":{"line":435,"column":45},"line":435,"code":"  it('should scroll window by <C-f> and <C-b>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<C-f>\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"\\\\<C-b>\", \"in\")')\n    await helper.wait(100)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <Backspace>","suites":["list insert mappings"],"updatePoint":{"line":445,"column":40},"line":445,"code":"  it('should change input by <Backspace>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<Backspace>\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-x>","suites":["list insert mappings"],"updatePoint":{"line":456,"column":34},"line":456,"code":"  it('should change input by <C-x>', async () => {\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      '<C-b>': 'prompt:removetail',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"foo\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<C-a>\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<C-b>\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    revert()\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-h>","suites":["list insert mappings"],"updatePoint":{"line":473,"column":34},"line":473,"code":"  it('should change input by <C-h>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<C-h>\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-w>","suites":["list insert mappings"],"updatePoint":{"line":484,"column":34},"line":484,"code":"  it('should change input by <C-w>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-w>\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"a\", \"in\")')\n    await helper.wait(30)\n    await nvim.eval('feedkeys(\"\\\\<C-w>\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-u>","suites":["list insert mappings"],"updatePoint":{"line":499,"column":34},"line":499,"code":"  it('should change input by <C-u>', async () => {\n    await manager.start(['--input=a', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-u>\", \"in\")')\n    await helper.wait(30)\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-n> and <C-p>","suites":["list insert mappings"],"updatePoint":{"line":508,"column":44},"line":508,"code":"  it('should change input by <C-n> and <C-p>', async () => {\n    async function session(input: string): Promise<void> {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await nvim.eval(`feedkeys(\"${input}\", \"in\")`)\n      await helper.wait(100)\n      await manager.cancel()\n    }\n    await session('foo')\n    await session('bar')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.wait(50)\n    await nvim.eval('feedkeys(\"\\\\<C-n>\", \"in\")')\n    await helper.wait(100)\n    let input = manager.prompt.input\n    expect(input.length).toBeGreaterThan(0)\n    await nvim.eval('feedkeys(\"\\\\<C-p>\", \"in\")')\n    await helper.wait(100)\n    input = manager.prompt.input\n    expect(input.length).toBeGreaterThan(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change matcher by <C-s>","suites":["list insert mappings"],"updatePoint":{"line":531,"column":36},"line":531,"code":"  it('should change matcher by <C-s>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-s>\", \"in\")')\n    await helper.wait(10)\n    let matcher = manager.session?.listOptions.matcher\n    expect(matcher).toBe('strict')\n    await nvim.eval('feedkeys(\"\\\\<C-s>\", \"in\")')\n    await helper.wait(10)\n    matcher = manager.session?.listOptions.matcher\n    expect(matcher).toBe('regex')\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(30)\n    let len = manager.session?.ui.length\n    expect(len).toBeGreaterThan(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for bad expression","suites":["evalExpression"],"updatePoint":{"line":550,"column":37},"line":550,"code":"  it('should throw for bad expression', async () => {\n    let revert = helper.updateConfiguration('list.normalMappings', {\n      t: 'expr',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(30)\n    revert()\n    let msg = await helper.getCmdline()\n    expect(msg).toMatch('Invalid list mapping expression')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show help","suites":["evalExpression"],"updatePoint":{"line":563,"column":22},"line":563,"code":"  it('should show help', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:help',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let bufname = await nvim.call('bufname', ['%'])\n    expect(bufname).toMatch('[LIST HELP]')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should exit list","suites":["evalExpression"],"updatePoint":{"line":575,"column":22},"line":575,"code":"  it('should exit list', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:exit',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel prompt","suites":["evalExpression"],"updatePoint":{"line":586,"column":26},"line":586,"code":"  it('should cancel prompt', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:cancel',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let res = await nvim.call('coc#prompt#activated')\n    expect(res).toBe(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back","suites":["evalExpression"],"updatePoint":{"line":598,"column":22},"line":598,"code":"  it('should jump back', async () => {\n    let doc = await helper.createDocument()\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:jumpback',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBe(doc.bufnr)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke normal command","suites":["evalExpression"],"updatePoint":{"line":611,"column":34},"line":611,"code":"  it('should invoke normal command', async () => {\n    let revert = helper.updateConfiguration('list.normalMappings', {\n      x: 'normal!:G'\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"x\", \"in\")`)\n    await helper.wait(50)\n    revert()\n    let lnum = await nvim.call('line', ['.'])\n    expect(lnum).toBeGreaterThan(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle, scroll preview","suites":["evalExpression"],"updatePoint":{"line":624,"column":35},"line":624,"code":"  it('should toggle, scroll preview', async () => {\n    let revert = helper.updateConfiguration('list.normalMappings', {\n      '<space>': 'do:toggle',\n      a: 'do:toggle',\n      b: 'do:previewtoggle',\n      c: 'do:previewup',\n      d: 'do:previewdown',\n      e: 'prompt:insertregister',\n      f: 'do:stop',\n      g: 'do:togglemode',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\" \", \"in\")`)\n    await helper.wait(50)\n    for (let key of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {\n      await nvim.eval(`feedkeys(\"${key}\", \"in\")`)\n      await helper.wait(50)\n    }\n    revert()\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error when action not exists","suites":["evalExpression"],"updatePoint":{"line":647,"column":46},"line":647,"code":"  it('should show error when action not exists', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:invalid',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let cmd = await helper.getCmdline()\n    expect(cmd).toMatch('not supported')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error when prompt action not exists","suites":["evalExpression"],"updatePoint":{"line":659,"column":53},"line":659,"code":"  it('should show error when prompt action not exists', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'prompt:invalid',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let cmd = await helper.getCmdline()\n    expect(cmd).toMatch('not supported')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for invalid expression ","suites":["evalExpression"],"updatePoint":{"line":671,"column":47},"line":671,"code":"  it('should show error for invalid expression ', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'x:y',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"t\", \"in\")')\n    await helper.wait(50)\n    let cmd = await helper.getCmdline()\n    expect(cmd).toMatch('Invalid expression')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning for invalid key","suites":["User mappings"],"updatePoint":{"line":685,"column":41},"line":685,"code":"  it('should show warning for invalid key', async () => {\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      xy: 'action:tabe',\n    })\n    await helper.wait(30)\n    let msg = await helper.getCmdline()\n    revert()\n    await nvim.command('echo \"\"')\n    expect(msg).toMatch('Invalid list mappings key')\n    revert = helper.updateConfiguration('list.insertMappings', {\n      '<M-x>': 'action:tabe',\n    })\n    await helper.wait(30)\n    msg = await helper.getCmdline()\n    revert()\n    expect(msg).toMatch('Invalid list mappings key')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute action keymap","suites":["User mappings"],"updatePoint":{"line":703,"column":34},"line":703,"code":"  it('should execute action keymap', async () => {\n    await helper.wait(200)\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      '<C-d>': 'action:tabe',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-d>\", \"in\")`)\n    await helper.wait(200)\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n    revert()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute expr keymap","suites":["User mappings"],"updatePoint":{"line":717,"column":32},"line":717,"code":"  it('should execute expr keymap', async () => {\n    await helper.mockFunction('TabOpen', 'tabe')\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-t>': 'expr:TabOpen',\n    })\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'expr:TabOpen',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-t>\", \"in\")`)\n    await helper.wait(100)\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"t\", \"in\")`)\n    await helper.wait(100)\n    nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(3)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute do mappings","suites":["User mappings"],"updatePoint":{"line":739,"column":32},"line":739,"code":"  it('should execute do mappings', async () => {\n    helper.updateConfiguration('list.previousKeymap', '<c-j>')\n    helper.updateConfiguration('list.nextKeymap', '<c-k>')\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-r>': 'do:refresh',\n      '<C-a>': 'do:selectall',\n      '<C-s>': 'do:switch',\n      '<C-l>': 'do:cancel',\n      '<C-t>': 'do:toggle',\n      '<C-n>': 'do:next',\n      '<C-p>': 'do:previous',\n      '<C-x>': 'do:defaultaction',\n      '<C-h>': 'do:help',\n      '<C-d>': 'do:exit',\n      '<C-b>': 'do:toggleMode'\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-r>\", \"in\")')\n    await helper.wait(30)\n    expect(manager.isActivated).toBe(true)\n    await nvim.eval('feedkeys(\"\\\\<C-a>\", \"in\")')\n    await helper.wait(30)\n    expect(manager.session?.ui.selectedItems.length).toBe(locations.length)\n    await nvim.eval('feedkeys(\"\\\\<C-s>\", \"in\")')\n    await helper.wait(30)\n    expect(manager.session?.listOptions.matcher).toBe('strict')\n    await nvim.eval('feedkeys(\"\\\\<C-n>\", \"in\")')\n    await helper.wait(30)\n    let item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[1].text)\n    await nvim.eval('feedkeys(\"\\\\<C-p>\", \"in\")')\n    await helper.wait(30)\n    item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[0].text)\n    await nvim.eval('feedkeys(\"\\\\<C-x>\", \"in\")')\n    await helper.wait(30)\n    expect(manager.isActivated).toBe(false)\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-l>\", \"in\")')\n    await helper.wait(50)\n    let res = await nvim.call('coc#prompt#activated')\n    expect(res).toBe(0)\n    await manager.session.hide()\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"?\", \"in\")')\n    await helper.wait(30)\n    await nvim.input('<CR>')\n    await manager.cancel()\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-d>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(false)\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<C-b>\", \"in\")')\n    await helper.wait(100)\n    expect(manager.isActivated).toBe(true)\n    await nvim.call('coc#prompt#stop_prompt', ['list'])\n  }, 20000)","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute prompt mappings","suites":["User mappings"],"updatePoint":{"line":803,"column":36},"line":803,"code":"  it('should execute prompt mappings', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-p>': 'prompt:previous',\n      '<C-n>': 'prompt:next',\n      '<C-a>': 'prompt:start',\n      '<C-e>': 'prompt:end',\n      '<Left>': 'prompt:left',\n      '<Right>': 'prompt:right',\n      '<backspace>': 'prompt:deleteforward',\n      '<C-x>': 'prompt:deletebackward',\n      '<C-k>': 'prompt:removetail',\n      '<C-u>': 'prompt:removeahead',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    for (let key of ['<C-p>', '<C-n>', '<C-a>', '<C-e>', '<Left>', '<Right>', '<backspace>', '<C-x>', '<C-k>', '<C-u>']) {\n      await nvim.input(key)\n      await helper.wait(30)\n    }\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute feedkeys keymap","suites":["User mappings"],"updatePoint":{"line":825,"column":36},"line":825,"code":"  it('should execute feedkeys keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-f>': 'feedkeys:\\\\<C-f>',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-f>\", \"in\")`)\n    await helper.wait(30)\n    let line = await nvim.call('line', '.')\n    expect(line).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute normal keymap","suites":["User mappings"],"updatePoint":{"line":837,"column":34},"line":837,"code":"  it('should execute normal keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-g>': 'normal:G',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-g>\", \"in\")`)\n    await helper.wait(30)\n    let line = await nvim.call('line', '.')\n    expect(line).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute command keymap","suites":["User mappings"],"updatePoint":{"line":849,"column":35},"line":849,"code":"  it('should execute command keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-w>': 'command:wincmd p',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-w>\", \"in\")`)\n    await helper.wait(30)\n    expect(manager.isActivated).toBe(true)\n    let winnr = await nvim.call('winnr')\n    expect(winnr).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute call keymap","suites":["User mappings"],"updatePoint":{"line":862,"column":32},"line":862,"code":"  it('should execute call keymap', async () => {\n    await helper.mockFunction('Test', 1)\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-t>': 'call:Test',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-t>\", \"in\")`)\n    await helper.wait(30)\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert clipboard register to prompt","suites":["User mappings"],"updatePoint":{"line":874,"column":48},"line":874,"code":"  it('should insert clipboard register to prompt', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-r>': 'prompt:paste',\n    })\n    await nvim.command('let @* = \"foobar\"')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-r>\", \"in\")`)\n    await helper.wait(100)\n    let { input } = manager.prompt\n    expect(input).toMatch('foobar')\n    await nvim.command('let @* = \"\"')\n    await nvim.eval(`feedkeys(\"\\\\<C-r>\", \"in\")`)\n    await helper.wait(100)\n    expect(manager.prompt.input).toMatch('foobar')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert text from default register to prompt","suites":["User mappings"],"updatePoint":{"line":891,"column":56},"line":891,"code":"  it('should insert text from default register to prompt', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-v>': 'eval:@@',\n    })\n    await nvim.command('let @@ = \"bar\"')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval(`feedkeys(\"\\\\<C-v>\", \"in\")`)\n    await helper.wait(200)\n    let { input } = manager.prompt\n    expect(input).toMatch('bar')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when default action not exists","suites":["list session","doDefaultAction()"],"updatePoint":{"line":62,"column":57},"line":62,"code":"    it('should throw error when default action not exists', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      list.defaultAction = 'foo'\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      let err\n      try {\n        await manager.session.first()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n      err = null\n      try {\n        await manager.session.last()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke multiple action","suites":["list session","doItemAction()"],"updatePoint":{"line":88,"column":37},"line":88,"code":"    it('should invoke multiple action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectAll()\n      await manager.doAction('multiple')\n      expect(lastItems.length).toBe(3)\n      lastItems = undefined\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke parallel action","suites":["list session","doItemAction()"],"updatePoint":{"line":101,"column":37},"line":101,"code":"    it('should invoke parallel action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectAll()\n      let d = Date.now()\n      await manager.doAction('parallel')\n      expect(Date.now() - d).toBeLessThan(300)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke reload action","suites":["list session","doItemAction()"],"updatePoint":{"line":114,"column":35},"line":114,"code":"    it('should invoke reload action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      labels = ['d', 'e']\n      await manager.doAction('reload')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines).toEqual(['d', 'e'])\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do preview on resume","suites":["list session","resume()"],"updatePoint":{"line":131,"column":35},"line":131,"code":"    it('should do preview on resume', async () => {\n      labels = ['a', 'b', 'c']\n      let lastItem\n      let list = new SimpleList(nvim)\n      list.actions.push({\n        name: 'preview',\n        execute: item => {\n          lastItem = item\n        }\n      })\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', '--auto-preview', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(1, 2)\n      await helper.wait(50)\n      await nvim.call('coc#window#close', [ui.winid])\n      await helper.wait(100)\n      await manager.session.resume()\n      await helper.wait(100)\n      expect(lastItem).toBeDefined()\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back","suites":["list session","jumpBack()"],"updatePoint":{"line":156,"column":24},"line":156,"code":"    it('should jump back', async () => {\n      let win = await nvim.window\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      manager.session.jumpBack()\n      await helper.wait(50)\n      let winid = await nvim.call('win_getid')\n      expect(winid).toBe(win.id)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for invalid number","suites":["list session","doNumberSelect()"],"updatePoint":{"line":186,"column":46},"line":186,"code":"    it('should return false for invalid number', async () => {\n      let session = await create(5)\n      let res = await session.doNumberSelect('a')\n      expect(res).toBe(false)\n      res = await session.doNumberSelect('8')\n      expect(res).toBe(false)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider 0 as 10","suites":["list session","doNumberSelect()"],"updatePoint":{"line":194,"column":31},"line":194,"code":"    it('should consider 0 as 10', async () => {\n      let session = await create(15)\n      let res = await session.doNumberSelect('0')\n      expect(res).toBe(true)\n      expect(lastItem).toBe('j')\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show description and options in help","suites":["showHelp()"],"updatePoint":{"line":204,"column":49},"line":204,"code":"  it('should show description and options in help', async () => {\n    labels = ['a', 'b', 'c']\n    let list = new SimpleList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    await manager.session.showHelp()\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines.indexOf('DESCRIPTION')).toBeGreaterThan(0)\n    expect(lines.indexOf('ARGUMENTS')).toBeGreaterThan(0)\n  })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions not have shortcuts","suites":["chooseAction()"],"updatePoint":{"line":219,"column":46},"line":219,"code":"  it('should filter actions not have shortcuts', async () => {\n    labels = ['a', 'b', 'c']\n    let list = new SimpleList(nvim)\n    list.actions.push({\n      name: 'a',\n      execute: () => {\n      }\n    })\n    list.actions.push({\n      name: 'b',\n      execute: () => {\n      }\n    })\n    list.actions.push({\n      name: 'ab',\n      execute: () => {\n      }\n    })\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    let p = manager.session.chooseAction()\n    await helper.wait(100)\n    await nvim.input('a')\n    await p\n  })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #1","suites":["BasicList","parse arguments"],"updatePoint":{"line":51,"column":28},"line":51,"code":"    it('should parse args #1', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-w'])\n      expect(res).toEqual({ word: true })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #2","suites":["BasicList","parse arguments"],"updatePoint":{"line":57,"column":28},"line":57,"code":"    it('should parse args #2', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-word'])\n      expect(res).toEqual({ word: true })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #3","suites":["BasicList","parse arguments"],"updatePoint":{"line":63,"column":28},"line":63,"code":"    it('should parse args #3', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-input', 'foo'])\n      expect(res).toEqual({ input: 'foo' })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview sketch buffer","suites":["BasicList","preview()"],"updatePoint":{"line":71,"column":36},"line":71,"code":"    it('should preview sketch buffer', async () => {\n      await nvim.command('new')\n      await nvim.setLine('foo')\n      let buffer = await nvim.buffer\n      await helper.wait(30)\n      let doc = workspace.getDocument(buffer.id)\n      expect(doc.uri).toMatch('untitled')\n      let list = new OptionList(nvim)\n      listItems.push({\n        label: 'foo',\n        location: Location.create(doc.uri, Range.create(0, 0, 0, 0))\n      })\n      let disposable = manager.registerList(list)\n      await manager.start(['option'])\n      await helper.wait(100)\n      await manager.doAction('preview')\n      await helper.wait(100)\n      await nvim.command('wincmd p')\n      let win = await nvim.window\n      let isPreview = await win.getVar('previewwindow')\n      expect(isPreview).toBe(1)\n      let line = await nvim.line\n      expect(line).toBe('foo')\n      disposable.dispose()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load commands source","suites":["list sources","commands"],"updatePoint":{"line":102,"column":35},"line":102,"code":"    it('should load commands source', async () => {\n      await manager.start(['commands'])\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do run action","suites":["list sources","commands"],"updatePoint":{"line":108,"column":28},"line":108,"code":"    it('should do run action', async () => {\n      await manager.start(['commands'])\n      await helper.wait(100)\n      await manager.doAction()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load diagnostics source","suites":["list sources","diagnostics"],"updatePoint":{"line":116,"column":38},"line":116,"code":"    it('should load diagnostics source', async () => {\n      await manager.start(['diagnostics'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load extensions source","suites":["list sources","extensions"],"updatePoint":{"line":125,"column":37},"line":125,"code":"    it('should load extensions source', async () => {\n      await manager.start(['extensions'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load folders source","suites":["list sources","folders"],"updatePoint":{"line":134,"column":34},"line":134,"code":"    it('should load folders source', async () => {\n      await manager.start(['folders'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load lists source","suites":["list sources","lists"],"updatePoint":{"line":143,"column":32},"line":143,"code":"    it('should load lists source', async () => {\n      await manager.start(['lists'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load outline source","suites":["list sources","outline"],"updatePoint":{"line":152,"column":34},"line":152,"code":"    it('should load outline source', async () => {\n      await manager.start(['outline'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load services source","suites":["list sources","services"],"updatePoint":{"line":161,"column":35},"line":161,"code":"    it('should load services source', async () => {\n      await manager.start(['services'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load sources source","suites":["list sources","sources"],"updatePoint":{"line":170,"column":34},"line":170,"code":"    it('should load sources source', async () => {\n      await manager.start(['sources'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load symbols source","suites":["list sources","symbols"],"updatePoint":{"line":179,"column":34},"line":179,"code":"    it('should load symbols source', async () => {\n      let disposable = languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: () => []\n      })\n      await manager.start(['symbols'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n      disposable.dispose()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load links source","suites":["list sources","links"],"updatePoint":{"line":192,"column":32},"line":192,"code":"    it('should load links source', async () => {\n      let disposable = languages.registerDocumentLinkProvider([{ scheme: 'file' }, { scheme: 'untitled' }], {\n        provideDocumentLinks: () => []\n      })\n      await manager.start(['links'])\n      await manager.session?.ui.ready\n      await helper.wait(100)\n      expect(manager.isActivated).toBe(true)\n      disposable.dispose()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select lines","suites":["list ui","selectLines()"],"updatePoint":{"line":47,"column":27},"line":47,"code":"    it('should select lines', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(3, 1)\n      let buf = await nvim.buffer\n      let res = await buf.getSigns({ group: 'coc-list' })\n      expect(res.length).toBe(2)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume with selected lines","suites":["list ui","resume()"],"updatePoint":{"line":61,"column":41},"line":61,"code":"    it('should resume with selected lines', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(1, 2)\n      await nvim.call('coc#window#close', [ui.winid])\n      await helper.wait(100)\n      await manager.session.resume()\n      await helper.wait(100)\n      let buf = await nvim.buffer\n      let res = await buf.getSigns({ group: 'coc-list' })\n      expect(res.length).toBe(2)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire action on double click","suites":["list ui","events"],"updatePoint":{"line":85,"column":42},"line":85,"code":"    it('should fire action on double click', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(ui.winid, 1)\n      await manager.session.onMouseEvent('<2-LeftMouse>')\n      await helper.wait(100)\n      expect(lastItem).toBe('foo')\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select clicked line","suites":["list ui","events"],"updatePoint":{"line":97,"column":34},"line":97,"code":"    it('should select clicked line', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(ui.winid, 2)\n      await ui.onMouse('mouseDown')\n      await helper.wait(50)\n      await mockMouse(ui.winid, 2)\n      await ui.onMouse('mouseUp')\n      await helper.wait(50)\n      let item = await ui.item\n      expect(item.label).toBe('bar')\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to original window on click","suites":["list ui","events"],"updatePoint":{"line":113,"column":47},"line":113,"code":"    it('should jump to original window on click', async () => {\n      labels = ['foo', 'bar']\n      let win = await nvim.window\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(win.id, 1)\n      await ui.onMouse('mouseUp')\n      await helper.wait(50)\n      let curr = await nvim.window\n      expect(curr.id).toBe(win.id)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlights items on CursorMoved","suites":["list ui","events"],"updatePoint":{"line":127,"column":46},"line":127,"code":"    it('should highlights items on CursorMoved', async () => {\n      labels = (new Array(400)).fill('a')\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple', '--normal'])\n      let ui = manager.session.ui\n      await ui.ready\n      await nvim.call('cursor', [350, 1])\n      await events.fire('CursorMoved', [ui.bufnr, [350, 1]])\n      await helper.wait(300)\n      let res = await nvim.call('getmatches')\n      expect(res.length).toBeGreaterThan(300)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse input with space","suites":["parseInput"],"updatePoint":{"line":117,"column":35},"line":117,"code":"  it('should parse input with space', async () => {\n    let res = parseInput('a b')\n    expect(res).toEqual(['a', 'b'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse input with escaped space","suites":["parseInput"],"updatePoint":{"line":122,"column":43},"line":122,"code":"  it('should parse input with escaped space', async () => {\n    let res = parseInput('a\\\\ b')\n    expect(res).toEqual(['a b'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with long running task","suites":["list worker"],"updatePoint":{"line":130,"column":40},"line":130,"code":"  it('should work with long running task', async () => {\n    disposables.push(manager.registerList(new IntervalTaskList(nvim)))\n    await manager.start(['task'])\n    await helper.wait(300)\n    let len = manager.session?.length\n    expect(len > 2).toBe(true)\n    await manager.cancel()\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by sortText","suites":["list worker"],"updatePoint":{"line":139,"column":29},"line":139,"code":"  it('should sort by sortText', async () => {\n    items = [{\n      label: 'abc',\n      sortText: 'b'\n    }, {\n      label: 'ade',\n      sortText: 'a'\n    }]\n    disposables.push(manager.registerList(new DataList(nvim)))\n    await manager.start(['data'])\n    await helper.wait(100)\n    await nvim.input('a')\n    await helper.wait(100)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['ade', 'abc'])\n    await manager.cancel()\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel task by use CancellationToken","suites":["list worker"],"updatePoint":{"line":158,"column":49},"line":158,"code":"  it('should cancel task by use CancellationToken', async () => {\n    disposables.push(manager.registerList(new IntervalTaskList(nvim)))\n    await manager.start(['task'])\n    expect(manager.session?.worker.isLoading).toBe(true)\n    await helper.wait(100)\n    manager.session?.stop()\n    expect(manager.session?.worker.isLoading).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render slow interactive list","suites":["list worker"],"updatePoint":{"line":167,"column":41},"line":167,"code":"  it('should render slow interactive list', async () => {\n    disposables.push(manager.registerList(new DelayTask(nvim)))\n    await manager.start(['delay'])\n    await nvim.input('a')\n    await helper.wait(600)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['ahead', 'abort'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with interactive list","suites":["list worker"],"updatePoint":{"line":177,"column":39},"line":177,"code":"  it('should work with interactive list', async () => {\n    disposables.push(manager.registerList(new InteractiveList(nvim)))\n    await manager.start(['-I', 'test'])\n    await manager.session?.ui.ready\n    expect(manager.isActivated).toBe(true)\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"a\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"x\", \"in\")')\n    await helper.wait(300)\n    let item = await manager.session?.ui.item\n    expect(item.label).toBe('fax')\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not activate on load error","suites":["list worker"],"updatePoint":{"line":192,"column":39},"line":192,"code":"  it('should not activate on load error', async () => {\n    disposables.push(manager.registerList(new ErrorList(nvim)))\n    await manager.start(['test'])\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on task error","suites":["list worker"],"updatePoint":{"line":198,"column":37},"line":198,"code":"  it('should deactivate on task error', async () => {\n    disposables.push(manager.registerList(new ErrorTaskList(nvim)))\n    await manager.start(['task'])\n    await helper.wait(500)\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights in single line","suites":["getHighlightItems"],"updatePoint":{"line":4,"column":42},"line":4,"code":"  it('should get highlights in single line', async () => {\n    let res = getHighlightItems('this line has highlights', 0, [10, 15])\n    expect(res).toEqual([{\n      colStart: 10,\n      colEnd: 15,\n      lnum: 0,\n      hlGroup: 'CocUnderline'\n    }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights when active end extended","suites":["getHighlightItems"],"updatePoint":{"line":14,"column":52},"line":14,"code":"  it('should get highlights when active end extended', async () => {\n    let res = getHighlightItems('this line', 0, [5, 30])\n    expect(res).toEqual([{\n      colStart: 5,\n      colEnd: 9,\n      lnum: 0,\n      hlGroup: 'CocUnderline'\n    }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights across line","suites":["getHighlightItems"],"updatePoint":{"line":24,"column":39},"line":24,"code":"  it('should get highlights across line', async () => {\n    let res = getHighlightItems('this line\\nhas highlights', 0, [5, 15])\n    expect(res).toEqual([{\n      colStart: 5, colEnd: 9, lnum: 0, hlGroup: 'CocUnderline'\n    }, {\n      colStart: 0, colEnd: 5, lnum: 1, hlGroup: 'CocUnderline'\n    }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse code blocks","suites":["parseMarkdown"],"updatePoint":{"line":35,"column":30},"line":35,"code":"  it('should parse code blocks', async () => {\n    let content = `\n\\`\\`\\`js\nvar global = globalThis\n\\`\\`\\`\n\\`\\`\\`ts\nlet str:string\n\\`\\`\\`\n`\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual([\n      'var global = globalThis',\n      '',\n      'let str:string'\n    ])\n    expect(res.codes).toEqual([\n      { filetype: 'javascript', startLine: 0, endLine: 1 },\n      { filetype: 'typescript', startLine: 2, endLine: 3 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse html code block","suites":["parseMarkdown"],"updatePoint":{"line":56,"column":34},"line":56,"code":"  it('should parse html code block', async () => {\n    let content = `\nexample:\n\\`\\`\\`html\n<div>code</div>\n\\`\\`\\`\n    `\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['example:', '', '<div>code</div>'])\n    expect(res.codes).toEqual([{ filetype: 'html', startLine: 2, endLine: 3 }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should compose empty lines","suites":["parseMarkdown"],"updatePoint":{"line":68,"column":32},"line":68,"code":"  it('should compose empty lines', async () => {\n    let content = 'foo\\n\\n\\nbar\\n\\n\\n'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo', '', 'bar'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse ansi highlights","suites":["parseMarkdown"],"updatePoint":{"line":74,"column":34},"line":74,"code":"  it('should parse ansi highlights', async () => {\n    let content = '__foo__\\n[link](link)'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo', 'link'])\n    expect(res.highlights).toEqual([\n      { hlGroup: 'CocBold', lnum: 0, colStart: 0, colEnd: 3 },\n      { hlGroup: 'CocUnderline', lnum: 1, colStart: 0, colEnd: 4 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should exclude images by option","suites":["parseMarkdown"],"updatePoint":{"line":84,"column":37},"line":84,"code":"  it('should exclude images by option', async () => {\n    let content = 'head\\n![img](img)\\ncontent ![img](img) ![img](img)'\n    let res = parseMarkdown(content, { excludeImages: true })\n    expect(res.lines).toEqual(['head', '', 'content'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse documents with diagnostic filetypes","suites":["parseDocuments"],"updatePoint":{"line":92,"column":54},"line":92,"code":"  it('should parse documents with diagnostic filetypes', async () => {\n    let docs = [{\n      filetype: 'Error',\n      content: 'Error text'\n    }, {\n      filetype: 'Warning',\n      content: 'Warning text'\n    }]\n    let res = parseDocuments(docs)\n    expect(res.lines).toEqual([\n      'Error text',\n      '',\n      'Warning text'\n    ])\n    expect(res.codes).toEqual([\n      { hlGroup: 'CocErrorFloat', startLine: 0, endLine: 1 },\n      { hlGroup: 'CocWarningFloat', startLine: 2, endLine: 3 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse markdown document with filetype document","suites":["parseDocuments"],"updatePoint":{"line":112,"column":59},"line":112,"code":"  it('should parse markdown document with filetype document', async () => {\n    let docs = [{\n      filetype: 'typescript',\n      content: 'const workspace'\n    }, {\n      filetype: 'markdown',\n      content: '**header**'\n    }]\n    let res = parseDocuments(docs)\n    expect(res.lines).toEqual([\n      'const workspace',\n      '',\n      'header'\n    ])\n    expect(res.highlights).toEqual([{\n      hlGroup: 'CocBold',\n      lnum: 2,\n      colStart: 0,\n      colEnd: 6\n    }])\n    expect(res.codes).toEqual([\n      { filetype: 'typescript', startLine: 0, endLine: 1 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse documents with active highlights","suites":["parseDocuments"],"updatePoint":{"line":137,"column":51},"line":137,"code":"  it('should parse documents with active highlights', async () => {\n    let docs = [{\n      filetype: 'javascript',\n      content: 'func(foo, bar)',\n      active: [5, 8]\n    }, {\n      filetype: 'javascript',\n      content: 'func()',\n      active: [15, 20]\n    }]\n    let res = parseDocuments(docs as any)\n    expect(res.highlights).toEqual([{ colStart: 5, colEnd: 8, lnum: 0, hlGroup: 'CocUnderline' }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add styles","suites":["styles"],"updatePoint":{"line":17,"column":23},"line":17,"code":"  it('should add styles', async () => {\n    let keys = ['gray', 'magenta', 'bold', 'underline', 'italic', 'strikethrough', 'yellow', 'green', 'blue']\n    for (let key of keys) {\n      let res = styles[key]('text')\n      expect(res).toContain('text')\n    }\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create bold highlights","suites":["Renderer of marked"],"updatePoint":{"line":27,"column":35},"line":27,"code":"  it('should create bold highlights', async () => {\n    let res = parse('**note**.')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 4],\n      hlGroup: 'CocBold'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create italic highlights","suites":["Renderer of marked"],"updatePoint":{"line":35,"column":37},"line":35,"code":"  it('should create italic highlights', async () => {\n    let res = parse('_note_.')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 4],\n      hlGroup: 'CocItalic'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create underline highlights for link","suites":["Renderer of marked"],"updatePoint":{"line":43,"column":49},"line":43,"code":"  it('should create underline highlights for link', async () => {\n    let res = parse('[baidu](https://baidu.com)')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 5],\n      hlGroup: 'CocMarkdownLink'\n    })\n    res = parse('https://baidu.com')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 17],\n      hlGroup: 'CocUnderline'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse link","suites":["Renderer of marked"],"updatePoint":{"line":56,"column":23},"line":56,"code":"  it('should parse link', async () => {\n    // let res = parse('https://doc.rust-lang.org/nightly/core/iter/traits/iterator/Iterator.t.html#map.v')\n    // console.log(JSON.stringify(res, null, 2))\n    let link = 'https://doc.rust-lang.org/nightly/core/iter/traits/iterator/Iterator.t.html#map.v'\n    let parsed = marked(link)\n    let res = parseAnsiHighlights(parsed.split(/\\n/)[0], true)\n    expect(res.line).toEqual(link)\n    expect(res.highlights.length).toBeGreaterThan(0)\n    expect(res.highlights[0].hlGroup).toBe('CocUnderline')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create highlight for code span","suites":["Renderer of marked"],"updatePoint":{"line":67,"column":43},"line":67,"code":"  it('should create highlight for code span', async () => {\n    let res = parse('`let foo = \"bar\"`')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 15],\n      hlGroup: 'CocMarkdownCode'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create header highlights","suites":["Renderer of marked"],"updatePoint":{"line":75,"column":37},"line":75,"code":"  it('should create header highlights', async () => {\n    let res = parse('# header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 8],\n      hlGroup: 'CocMarkdownHeader'\n    })\n    res = parse('## header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 9],\n      hlGroup: 'CocMarkdownHeader'\n    })\n    res = parse('### header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 10],\n      hlGroup: 'CocMarkdownHeader'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent blockquote","suites":["Renderer of marked"],"updatePoint":{"line":93,"column":30},"line":93,"code":"  it('should indent blockquote', async () => {\n    let res = parse('> header')\n    expect(res.line).toBe('  header')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preserve code block","suites":["Renderer of marked"],"updatePoint":{"line":98,"column":32},"line":98,"code":"  it('should preserve code block', async () => {\n    let text = '``` js\\nconsole.log(\"foo\")\\n```'\n    let m = marked(text)\n    expect(m.split('\\n')).toEqual([\n      '``` js',\n      'console.log(\"foo\")',\n      '```',\n      ''\n    ])\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should renderer table","suites":["Renderer of marked"],"updatePoint":{"line":109,"column":27},"line":109,"code":"  it('should renderer table', async () => {\n    let text = `\n| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\n`\n    let res = marked(text)\n    expect(res).toContain('Syntax')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"distinct","suites":["Arrays"],"updatePoint":{"line":6,"column":16},"line":6,"code":"  test('distinct', () => {\n    function compare(a: string): string {\n      return a\n    }\n\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5'], compare), ['32', '4', '5'])\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5', '4'], compare), ['32', '4', '5'])\n    assert.deepStrictEqual(arrays.distinct(['32', 'constructor', '5', '1'], compare), ['32', 'constructor', '5', '1'])\n    assert.deepStrictEqual(arrays.distinct(['32', 'constructor', 'proto', 'proto', 'constructor'], compare), ['32', 'constructor', 'proto'])\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5', '32', '4', '5', '32', '4', '5', '5'], compare), ['32', '4', '5'])\n  })","file":"modules/array.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"tail","suites":["Arrays"],"updatePoint":{"line":18,"column":12},"line":18,"code":"  test('tail', () => {\n    assert.strictEqual(arrays.tail([1, 2, 3]), 3)\n  })","file":"modules/array.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"lastIndex","suites":["Arrays"],"updatePoint":{"line":22,"column":17},"line":22,"code":"  test('lastIndex', () => {\n    let res = arrays.lastIndex([1, 2, 3], x => x < 3)\n    assert.strictEqual(res, 1)\n  })","file":"modules/array.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"flatMap","suites":["Arrays"],"updatePoint":{"line":27,"column":15},"line":27,"code":"  test('flatMap', () => {\n    let objs: { [key: string]: number[] }[] = [{ x: [1, 2] }, { y: [3, 4] }, { z: [5, 6] }]\n    function values(item: { [key: string]: number[] }): number[] {\n      return Object.keys(item).reduce((p, c) => p.concat(item[c]), [])\n    }\n    let res = arrays.flatMap(objs, values)\n    assert.deepStrictEqual(res, [1, 2, 3, 4, 5, 6])\n  })","file":"modules/array.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should listen CocInstalled","suites":["attach"],"updatePoint":{"line":28,"column":32},"line":28,"code":"  it('should listen CocInstalled', async () => {\n    nvim.emit('notification', 'VimEnter')\n    await helper.wait(100)\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on event handler error","suites":["attach"],"updatePoint":{"line":33,"column":45},"line":33,"code":"  it('should not throw on event handler error', async () => {\n    events.on('CursorHold', async () => {\n      throw new Error('error')\n    })\n    let fn = jest.fn()\n    nvim.emit('request', 'CocAutocmd', ['CursorHold'], {\n      send: fn\n    })\n    await wait(100)\n    expect(fn).toBeCalled()\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when plugin method not found","suites":["attach"],"updatePoint":{"line":45,"column":51},"line":45,"code":"  it('should not throw when plugin method not found', async () => {\n    let fn = jest.fn()\n    nvim.emit('request', 'NotExists', [], {\n      send: fn\n    })\n    await wait(100)\n    expect(fn).toBeCalled()\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match @","suites":["chars keyword option"],"updatePoint":{"line":4,"column":20},"line":4,"code":"  it('should match @', () => {\n    let chars = new Chars('@')\n    expect(chars.isKeywordChar('a')).toBe(true)\n    expect(chars.isKeywordChar('z')).toBe(true)\n    expect(chars.isKeywordChar('A')).toBe(true)\n    expect(chars.isKeywordChar('Z')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match letter range","suites":["chars keyword option"],"updatePoint":{"line":12,"column":31},"line":12,"code":"  it('should match letter range', () => {\n    let chars = new Chars('a-z')\n    expect(chars.isKeywordChar('a')).toBe(true)\n    expect(chars.isKeywordChar('A')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match code range","suites":["chars keyword option"],"updatePoint":{"line":18,"column":29},"line":18,"code":"  it('should match code range', () => {\n    let chars = new Chars('48-57')\n    expect(chars.isKeywordChar('a')).toBe(false)\n    expect(chars.isKeywordChar('0')).toBe(true)\n    expect(chars.isKeywordChar('9')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match @-@","suites":["chars keyword option"],"updatePoint":{"line":25,"column":22},"line":25,"code":"  it('should match @-@', () => {\n    let chars = new Chars('@-@')\n    expect(chars.isKeywordChar('@')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match single code","suites":["chars keyword option"],"updatePoint":{"line":30,"column":30},"line":30,"code":"  it('should match single code', () => {\n    let chars = new Chars('58')\n    expect(chars.isKeywordChar(':')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match single character","suites":["chars keyword option"],"updatePoint":{"line":35,"column":35},"line":35,"code":"  it('should match single character', () => {\n    let chars = new Chars('_')\n    expect(chars.isKeywordChar('_')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add keyword","suites":["chars addKeyword"],"updatePoint":{"line":42,"column":24},"line":42,"code":"  it('should add keyword', () => {\n    let chars = new Chars('_')\n    chars.addKeyword(':')\n    expect(chars.isKeywordChar(':')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change keyword","suites":["chars change keyword"],"updatePoint":{"line":50,"column":27},"line":50,"code":"  it('should change keyword', () => {\n    let chars = new Chars('_')\n    chars.setKeywordOption(':')\n    expect(chars.isKeywordChar(':')).toBe(true)\n    expect(chars.isKeywordChar('_')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match keywords","suites":["chars match keywords"],"updatePoint":{"line":59,"column":27},"line":59,"code":"  it('should match keywords', () => {\n    let chars = new Chars('@')\n    let res = chars.matchKeywords('foo bar')\n    expect(res).toEqual(['foo', 'bar'])\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider unicode character as word","suites":["chars match keywords"],"updatePoint":{"line":65,"column":47},"line":65,"code":"  it('should consider unicode character as word', () => {\n    let chars = new Chars('@')\n    let res = chars.matchKeywords('black')\n    expect(res).toEqual(['black'])\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check isKeyword","suites":["chars isKeyword"],"updatePoint":{"line":73,"column":28},"line":73,"code":"  it('should check isKeyword', () => {\n    let chars = new Chars('@')\n    expect(chars.isKeyword('foo')).toBe(true)\n    expect(chars.isKeyword('f@')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with notify & request","suites":["node client pauseNotification"],"updatePoint":{"line":20,"column":39},"line":20,"code":"  it('should work with notify & request', async () => {\n    nvim.pauseNotification()\n    nvim.call('setline', [1, 'foo'], true)\n    nvim.call('append', [1, ['bar']], true)\n    await nvim.resumeNotification(false, true)\n    await helper.wait(500)\n    let buffer = await nvim.buffer\n    let lines = await buffer.lines\n    expect(lines).toEqual(['foo', 'bar'])\n    nvim.pauseNotification()\n    nvim.call('eval', ['&buftype'], true)\n    nvim.call('bufnr', ['%'], true)\n    let res = await nvim.resumeNotification()\n    expect(res).toEqual([['', buffer.id], null])\n  })","file":"modules/client.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load preferences","suites":["completion events"],"updatePoint":{"line":38,"column":29},"line":38,"code":"  it('should load preferences', () => {\n    let minTriggerInputLength = completion.config.minTriggerInputLength\n    expect(minTriggerInputLength).toBe(1)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload preferences onChange","suites":["completion events"],"updatePoint":{"line":43,"column":40},"line":43,"code":"  it('should reload preferences onChange', () => {\n    let { configurations } = workspace\n    configurations.updateUserConfig({ 'suggest.maxCompleteItemCount': 30 })\n    let snippetIndicator = completion.config.maxItemCount\n    expect(snippetIndicator).toBe(30)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on doComplete error","suites":["completion start"],"updatePoint":{"line":53,"column":43},"line":53,"code":"  it('should deactivate on doComplete error', async () => {\n    let fn = (completion as any)._doComplete\n      ; (completion as any)._doComplete = async () => {\n        throw new Error('fake')\n      }\n    let option: CompleteOption = await nvim.call('coc#util#get_complete_option')\n    await completion.startCompletion(option)\n      ; (completion as any)._doComplete = fn\n    expect(completion.isActivated).toBe(false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start completion","suites":["completion start"],"updatePoint":{"line":64,"column":29},"line":64,"code":"  it('should start completion', async () => {\n    await nvim.setLine('foo football')\n    await nvim.input('a')\n    await nvim.call('cursor', [1, 2])\n    let option: CompleteOption = await nvim.call('coc#util#get_complete_option')\n    await completion.startCompletion(option)\n    expect(completion.isActivated).toBe(true)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show slow source","suites":["completion start"],"updatePoint":{"line":73,"column":29},"line":73,"code":"  it('should show slow source', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'slow',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n        setTimeout(() => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n        }, 600)\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    let items = await helper.items()\n    expect(items.length).toBe(2)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop if no filtered items","suites":["completion resumeCompletion"],"updatePoint":{"line":98,"column":38},"line":98,"code":"  it('should stop if no filtered items', async () => {\n    await nvim.setLine('foo ')\n    await helper.wait(50)\n    await nvim.input('Af')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    await nvim.input('d')\n    await helper.wait(60)\n    expect(completion.isActivated).toBe(false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate without filtered items","suites":["completion resumeCompletion"],"updatePoint":{"line":109,"column":46},"line":109,"code":"  it('should deactivate without filtered items', async () => {\n    await nvim.setLine('foo fbi ')\n    await nvim.input('Af')\n    await helper.waitPopup()\n    await nvim.input('c')\n    await helper.wait(100)\n    let items = await helper.items()\n    expect(items.length).toBe(0)\n    expect(completion.isActivated).toBe(false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate when insert space","suites":["completion resumeCompletion"],"updatePoint":{"line":120,"column":41},"line":120,"code":"  it('should deactivate when insert space', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'empty',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n        resolve({ items: [{ word: 'foo bar' }] })\n      })\n    }\n    sources.addSource(source)\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    sources.removeSource(source)\n    let items = await helper.items()\n    expect(items[0].word).toBe('foo bar')\n    await nvim.input(' ')\n    await helper.wait(60)\n    expect(completion.isActivated).toBe(false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use resume input to filter","suites":["completion resumeCompletion"],"updatePoint":{"line":144,"column":39},"line":144,"code":"  it('should use resume input to filter', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'source',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (): Promise<CompleteResult> => new Promise(resolve => {\n        setTimeout(() => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n        }, 60)\n      })\n    }\n    sources.addSource(source)\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.wait(20)\n    await nvim.input('f')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    let items = await helper.items()\n    expect(items.length).toBe(1)\n    expect(items[0].word).toBe('foo')\n    sources.removeSource(source)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter slow source","suites":["completion resumeCompletion"],"updatePoint":{"line":170,"column":31},"line":170,"code":"  it('should filter slow source', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'slow',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (): Promise<CompleteResult> => new Promise(resolve => {\n        setTimeout(() => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n        }, 600)\n      })\n    }\n    disposables.push(sources.addSource(source))\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.wait(60)\n    await nvim.input('f')\n    await helper.waitPopup()\n    await nvim.input('o')\n    await helper.wait(100)\n    expect(completion.isActivated).toBe(true)\n    let items = await helper.items()\n    expect(items.length).toBe(1)\n    expect(items[0].word).toBe('foo')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should complete inComplete source","suites":["completion resumeCompletion"],"updatePoint":{"line":197,"column":39},"line":197,"code":"  it('should complete inComplete source', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'inComplete',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n        await helper.wait(30)\n        if (opt.input.length <= 1) {\n          return { isIncomplete: true, items: [{ word: 'foo' }, { word: opt.input }] }\n        }\n        return { isIncomplete: false, items: [{ word: 'foo' }, { word: opt.input }] }\n      }\n    }\n    disposables.push(sources.addSource(source))\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    await nvim.input('a')\n    await helper.wait(30)\n    await nvim.input('b')\n    await helper.wait(100)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not complete inComplete source when isIncomplete is false","suites":["completion resumeCompletion"],"updatePoint":{"line":223,"column":70},"line":223,"code":"  it('should not complete inComplete source when isIncomplete is false', async () => {\n    await helper.createDocument()\n    let lastOption: CompleteOption\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'inComplete',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n        lastOption = opt\n        await helper.wait(30)\n        if (opt.input.length <= 1) {\n          return { isIncomplete: true, items: [{ word: 'foobar' }] }\n        }\n        return { isIncomplete: false, items: [{ word: 'foobar' }] }\n      }\n    }\n    disposables.push(sources.addSource(source))\n    await helper.edit()\n    await nvim.input('i.')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    await nvim.input('fo')\n    await helper.wait(100)\n    await nvim.input('b')\n    await helper.wait(200)\n    expect(completion.isActivated).toBe(true)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger completion if triggerAfterInsertEnter is true","suites":["completion InsertEnter"],"updatePoint":{"line":255,"column":66},"line":255,"code":"  it('should trigger completion if triggerAfterInsertEnter is true', async () => {\n    await helper.createDocument()\n    await nvim.setLine('foo fo')\n    let config = workspace.getConfiguration('suggest')\n    config.update('triggerAfterInsertEnter', true)\n    await helper.wait(100)\n    let triggerAfterInsertEnter = completion.config.triggerAfterInsertEnter\n    expect(triggerAfterInsertEnter).toBe(true)\n    await nvim.input('A')\n    await helper.waitPopup()\n    expect(completion.isActivated).toBe(true)\n    config.update('triggerAfterInsertEnter', undefined)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger when input length too small","suites":["completion InsertEnter"],"updatePoint":{"line":269,"column":52},"line":269,"code":"  it('should not trigger when input length too small', async () => {\n    let config = workspace.getConfiguration('suggest')\n    config.update('triggerAfterInsertEnter', true)\n    await helper.wait(100)\n    let triggerAfterInsertEnter = completion.config.triggerAfterInsertEnter\n    expect(triggerAfterInsertEnter).toBe(true)\n    await nvim.setLine('foo ')\n    await nvim.input('A')\n    await helper.wait(100)\n    expect(completion.isActivated).toBe(false)\n    config.update('triggerAfterInsertEnter', undefined)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop when input length below option input length","suites":["completion TextChangedP"],"updatePoint":{"line":284,"column":61},"line":284,"code":"  it('should stop when input length below option input length', async () => {\n    await helper.edit()\n    await nvim.setLine('foo fbi ')\n    await nvim.input('Af')\n    await helper.waitPopup()\n    await nvim.input('<backspace>')\n    await helper.wait(100)\n    expect(completion.isActivated).toBe(false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with plain text on additionalTextEdits","suites":["completion TextChangedP"],"updatePoint":{"line":294,"column":71},"line":294,"code":"  it('should fix cursor position with plain text on additionalTextEdits', async () => {\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'foo',\n        filterText: 'foo',\n        additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'a\\nbar')]\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n    await nvim.input('if')\n    await helper.waitPopup()\n    await helper.selectCompleteItem(0)\n    await helper.wait(200)\n    let line = await nvim.line\n    expect(line).toBe('barfoo')\n    let [, lnum, col] = await nvim.call('getcurpos')\n    expect(lnum).toBe(2)\n    expect(col).toBe(7)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter in complete request","suites":["completion TextChangedP"],"updatePoint":{"line":314,"column":39},"line":314,"code":"  it('should filter in complete request', async () => {\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (doc, pos, token, context): Promise<CompletionList> => {\n        let option = (context as any).option\n        if (context.triggerCharacter == '.') {\n          return {\n            isIncomplete: true,\n            items: [\n              {\n                label: 'foo'\n              }, {\n                label: 'bar'\n              }\n            ]\n          }\n        }\n        if (option.input == 'f') {\n          await helper.wait(100)\n          if (token.isCancellationRequested) return\n          return {\n            isIncomplete: true,\n            items: [\n              {\n                label: 'foo'\n              }\n            ]\n          }\n        }\n        if (option.input == 'fo') {\n          await helper.wait(100)\n          if (token.isCancellationRequested) return\n          return {\n            isIncomplete: false,\n            items: [\n              {\n                label: 'foo'\n              }\n            ]\n          }\n        }\n      }\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']))\n    await nvim.input('i.')\n    await helper.waitPopup()\n    await nvim.input('f')\n    await helper.wait(60)\n    await nvim.input('o')\n    await helper.wait(300)\n    let res = await helper.getItems()\n    expect(res.length).toBe(1)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide word when textEdit after startcol","suites":["completion TextChangedP"],"updatePoint":{"line":367,"column":54},"line":367,"code":"  it('should provide word when textEdit after startcol', async () => {\n    // some LS would send textEdit after first character,\n    // need fix the word from newText\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (_, position): Promise<CompletionItem[]> => {\n        if (position.line != 0) return null\n        return [{\n          label: 'bar',\n          filterText: 'ar',\n          textEdit: {\n            range: Range.create(0, 1, 0, 1),\n            newText: 'ar'\n          }\n        }]\n      }\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n    await nvim.input('ib')\n    await helper.waitPopup()\n    let context = await nvim.getVar('coc#_context') as any\n    expect(context.start).toBe(1)\n    expect(context.candidates[0].word).toBe('ar')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust completion position by textEdit start position","suites":["completion TextChangedP"],"updatePoint":{"line":391,"column":66},"line":391,"code":"  it('should adjust completion position by textEdit start position', async () => {\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (_document, _position, _token, context): Promise<CompletionItem[]> => {\n        if (!context.triggerCharacter) return\n        return [{\n          label: 'foo',\n          textEdit: {\n            range: Range.create(0, 0, 0, 1),\n            newText: '?foo'\n          }\n        }]\n      }\n    }\n    disposables.push(languages.registerCompletionItemProvider('fix', 'f', null, provider, ['?']))\n    await nvim.input('i?')\n    await helper.waitPopup()\n    await nvim.eval('feedkeys(\"\\\\<C-n>\", \"in\")')\n    await helper.wait(200)\n    let line = await nvim.line\n    expect(line).toBe('?foo')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with snippet on additionalTextEdits","suites":["completion TextChangedP"],"updatePoint":{"line":413,"column":68},"line":413,"code":"  it('should fix cursor position with snippet on additionalTextEdits', async () => {\n    await helper.createDocument()\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'if',\n        insertTextFormat: InsertTextFormat.Snippet,\n        textEdit: { range: Range.create(0, 0, 0, 2), newText: 'if($1)' },\n        additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n        preselect: true\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n    await nvim.input('ii')\n    await helper.waitPopup()\n    let res = await helper.getItems()\n    let idx = res.findIndex(o => o.menu == '[edit]')\n    await helper.selectCompleteItem(idx)\n    await helper.wait(800)\n    let line = await nvim.line\n    expect(line).toBe('bar if()')\n    let [, lnum, col] = await nvim.call('getcurpos')\n    expect(lnum).toBe(1)\n    expect(col).toBe(8)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with plain text snippet on additionalTextEdits","suites":["completion TextChangedP"],"updatePoint":{"line":438,"column":79},"line":438,"code":"  it('should fix cursor position with plain text snippet on additionalTextEdits', async () => {\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'if',\n        insertTextFormat: InsertTextFormat.Snippet,\n        textEdit: { range: Range.create(0, 0, 0, 2), newText: 'do$0' },\n        additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n        preselect: true\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n    await nvim.input('iif')\n    await helper.waitPopup()\n    await helper.selectCompleteItem(0)\n    await helper.wait(200)\n    let line = await nvim.line\n    let [, lnum, col] = await nvim.call('getcurpos')\n    expect(line).toBe('bar do')\n    expect(lnum).toBe(1)\n    expect(col).toBe(7)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with nested snippet on additionalTextEdits","suites":["completion TextChangedP"],"updatePoint":{"line":460,"column":75},"line":460,"code":"  it('should fix cursor position with nested snippet on additionalTextEdits', async () => {\n    await helper.createDocument()\n    let res = await snippetManager.insertSnippet('func($1)$0')\n    expect(res).toBe(true)\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'if',\n        insertTextFormat: InsertTextFormat.Snippet,\n        insertText: 'do$0',\n        additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n        preselect: true\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n    await nvim.input('if')\n    await helper.waitPopup()\n    await helper.selectCompleteItem(0)\n    await helper.wait(200)\n    let line = await nvim.line\n    let [, lnum, col] = await nvim.call('getcurpos')\n    expect(line).toBe('bar func(do)')\n    expect(lnum).toBe(1)\n    expect(col).toBe(12)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position and keep placeholder with snippet on additionalTextEdits","suites":["completion TextChangedP"],"updatePoint":{"line":485,"column":89},"line":485,"code":"  it('should fix cursor position and keep placeholder with snippet on additionalTextEdits', async () => {\n    let doc = await helper.createDocument()\n    let text = 'foo0bar1'\n    await nvim.setLine(text)\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'var',\n        insertTextFormat: InsertTextFormat.Snippet,\n        textEdit: { range: Range.create(0, text.length + 1, 0, text.length + 1), newText: '${1:foo} = foo0bar1' },\n        additionalTextEdits: [TextEdit.del(Range.create(0, 0, 0, text.length + 1))],\n        preselect: true\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']))\n    await nvim.input('A.')\n    await helper.waitPopup()\n    let res = await helper.getItems()\n    let idx = res.findIndex(o => o.menu == '[edit]')\n    await helper.selectCompleteItem(idx)\n    await helper.wait(800)\n    let line = await nvim.line\n    expect(line).toBe('foo = foo0bar1')\n    expect(snippetManager.isActived(doc.bufnr)).toBe(true)\n    let [, lnum, col] = await nvim.call('getcurpos')\n    expect(lnum).toBe(1)\n    expect(col).toBe(3)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix input for snippet item","suites":["completion TextChangedP"],"updatePoint":{"line":513,"column":39},"line":513,"code":"  it('should fix input for snippet item', async () => {\n    let provider: CompletionItemProvider = {\n      provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n        label: 'foo',\n        filterText: 'foo',\n        insertText: '${1:foo}($2)',\n        insertTextFormat: InsertTextFormat.Snippet,\n      }]\n    }\n    disposables.push(languages.registerCompletionItemProvider('snippets-test', 'st', null, provider))\n    await nvim.input('if')\n    await helper.waitPopup()\n    await nvim.input('<C-n>')\n    await helper.wait(100)\n    let line = await nvim.line\n    expect(line).toBe('foo')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter on none keyword input","suites":["completion TextChangedP"],"updatePoint":{"line":531,"column":41},"line":531,"code":"  it('should filter on none keyword input', async () => {\n    let source: ISource = {\n      priority: 99,\n      enable: true,\n      name: 'temp',\n      sourceType: SourceType.Service,\n      doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo#abc' }] }),\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('if')\n    await helper.waitPopup()\n    await nvim.input('#')\n    await helper.wait(100)\n    let items = await helper.getItems()\n    expect(items[0].word).toBe('foo#abc')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use source-provided score","suites":["completion TextChangedP"],"updatePoint":{"line":548,"column":38},"line":548,"code":"  it('should use source-provided score', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'source',\n      sourceType: SourceType.Service,\n      doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({\n        items: [\n          { word: 'candidate_a', sourceScore: 0.1 },\n          { word: 'candidate_b', sourceScore: 10 },\n          { word: 'candidate_c' },\n        ]\n      }),\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('ocand')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items[0].word).toBe('candidate_b')\n    expect(items[1].word).toBe('candidate_c')\n    expect(items[2].word).toBe('candidate_a')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do resolve for complete item","suites":["completion TextChangedP"],"updatePoint":{"line":571,"column":41},"line":571,"code":"  it('should do resolve for complete item', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'resolve',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo' }] }),\n      onCompleteResolve: item => {\n        item.info = 'detail'\n      }\n    }\n    sources.addSource(source)\n    await nvim.input('i.')\n    await helper.waitPopup()\n    await helper.wait(100)\n    await nvim.input('<C-n>')\n    await helper.wait(100)\n    // let items = completion.completeItems\n    // expect(items[0].info).toBe('detail')\n    sources.removeSource(source)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix word on CompleteDone","suites":["completion done"],"updatePoint":{"line":596,"column":37},"line":596,"code":"  it('should fix word on CompleteDone', async () => {\n    await nvim.setLine('fball football')\n    await nvim.input('i')\n    await nvim.call('cursor', [1, 2])\n    let option: CompleteOption = await nvim.call('coc#util#get_complete_option')\n    await completion.startCompletion(option)\n    let items = await helper.items()\n    expect(items.length).toBe(1)\n    await nvim.input('<C-n>')\n    await helper.wait(30)\n    await nvim.call('coc#_select')\n    await helper.wait(100)\n    let line = await nvim.line\n    expect(line).toBe('football football')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide kind and menu when configured","suites":["completion option"],"updatePoint":{"line":614,"column":47},"line":614,"code":"  it('should hide kind and menu when configured', async () => {\n    helper.updateConfiguration('suggest.disableKind', true)\n    helper.updateConfiguration('suggest.disableMenu', true)\n    await nvim.setLine('fball football')\n    await nvim.input('of')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items[0].kind).toBeUndefined()\n    expect(items[0].menu).toBeUndefined()\n    helper.updateConfiguration('suggest.disableKind', false)\n    helper.updateConfiguration('suggest.disableMenu', false)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger completion on type trigger character","suites":["completion trigger"],"updatePoint":{"line":629,"column":57},"line":629,"code":"  it('should trigger completion on type trigger character', async () => {\n    let source: ISource = {\n      priority: 1,\n      enable: true,\n      name: 'trigger',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n        if (opt.triggerCharacter == '.') {\n          return Promise.resolve({ items: [{ word: 'bar' }] })\n        }\n        return Promise.resolve({ items: [{ word: 'foo#bar' }] })\n      }\n    }\n    sources.addSource(source)\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('.')\n    await helper.waitPopup()\n    let items = await helper.items()\n    expect(items.length).toBeGreaterThan(0)\n    sources.removeSource(source)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger if autoTrigger is none","suites":["completion trigger"],"updatePoint":{"line":653,"column":47},"line":653,"code":"  it('should not trigger if autoTrigger is none', async () => {\n    let config = workspace.getConfiguration('suggest')\n    config.update('autoTrigger', 'none')\n    let autoTrigger = completion.config.autoTrigger\n    expect(autoTrigger).toBe('none')\n    await nvim.setLine('foo fo')\n    await nvim.input('A')\n    await helper.wait(100)\n    expect(completion.isActivated).toBe(false)\n    config.update('autoTrigger', 'always')\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger complete on trigger patterns match","suites":["completion trigger"],"updatePoint":{"line":665,"column":55},"line":665,"code":"  it('should trigger complete on trigger patterns match', async () => {\n    let source: ISource = {\n      priority: 99,\n      enable: true,\n      name: 'temp',\n      triggerPatterns: [/EM/],\n      sourceType: SourceType.Service,\n      doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n        if (!opt.input.startsWith('EM')) return null\n        return Promise.resolve({\n          items: [\n            { word: 'foo', filterText: 'EMfoo' },\n            { word: 'bar', filterText: 'EMbar' }\n          ]\n        })\n      },\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('i')\n    await nvim.input('EM')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toBe(2)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger complete when pumvisible and triggerPatterns match","suites":["completion trigger"],"updatePoint":{"line":690,"column":71},"line":690,"code":"  it('should trigger complete when pumvisible and triggerPatterns match', async () => {\n    await nvim.setLine('EnumMember')\n    let source: ISource = {\n      priority: 99,\n      enable: true,\n      name: 'temp',\n      triggerPatterns: [/EM/],\n      sourceType: SourceType.Service,\n      doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n        if (!opt.input.startsWith('EM')) return null\n        return Promise.resolve({\n          items: [\n            { word: 'a', filterText: 'EMa' },\n            { word: 'b', filterText: 'EMb' }\n          ]\n        })\n      },\n    }\n    disposables.push(sources.addSource(source))\n    await nvim.input('o')\n    await helper.wait(10)\n    await nvim.input('E')\n    await helper.wait(30)\n    await nvim.input('M')\n    await helper.waitPopup()\n    let items = await helper.getItems()\n    expect(items.length).toBeGreaterThan(2)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect commitCharacter on TextChangedI","suites":["completion TextChangedI"],"updatePoint":{"line":721,"column":52},"line":721,"code":"  it('should respect commitCharacter on TextChangedI', async () => {\n    let source: ISource = {\n      priority: 0,\n      enable: true,\n      name: 'slow',\n      sourceType: SourceType.Service,\n      triggerCharacters: ['.'],\n      doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n        if (opt.triggerCharacter == '.') {\n          return Promise.resolve({ items: [{ word: 'bar' }] })\n        }\n        return Promise.resolve({ items: [{ word: 'foo' }] })\n      },\n      shouldCommit: (_item, character) => character == '.'\n    }\n    sources.addSource(source)\n    await nvim.input('if')\n    await helper.pumvisible()\n    await helper.wait(100)\n    await nvim.input('.')\n    await helper.wait(100)\n    sources.removeSource(source)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel completion with same pretext","suites":["completion TextChangedI"],"updatePoint":{"line":745,"column":48},"line":745,"code":"  it('should cancel completion with same pretext', async () => {\n    await nvim.setLine('foo')\n    await nvim.input('of')\n    await helper.pumvisible()\n    await helper.wait(30)\n    await nvim.call('coc#_cancel', [])\n    let line = await nvim.line\n    let visible = await nvim.call('pumvisible')\n    expect(line).toBe('f')\n    expect(visible).toBe(0)\n  })","file":"modules/completion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert errors","suites":["Configurations"],"updatePoint":{"line":26,"column":27},"line":26,"code":"  it('should convert errors', () => {\n    let errors: ParseError[] = []\n    for (let i = 0; i < 17; i++) {\n      errors.push({\n        error: i,\n        offset: 0,\n        length: 10\n      })\n    }\n    let res = convertErrors('file:///1', 'abc', errors)\n    expect(res.length).toBe(17)\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all keys","suites":["Configurations"],"updatePoint":{"line":39,"column":25},"line":39,"code":"  it('should get all keys', () => {\n    let res = getKeys({\n      foo: {\n        bar: 1,\n        from: {\n          to: 2\n        }\n      },\n      bar: [1, 2]\n    })\n    expect(res).toEqual(['foo', 'foo.bar', 'foo.from', 'foo.from.to', 'bar'])\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get configuration value","suites":["Configurations"],"updatePoint":{"line":52,"column":36},"line":52,"code":"  it('should get configuration value', () => {\n    let root = {\n      foo: {\n        bar: 1,\n        from: {\n          to: 2\n        }\n      },\n      bar: [1, 2]\n    }\n    let res = getConfigurationValue(root, 'foo.from.to', 1)\n    expect(res).toBe(2)\n    res = getConfigurationValue(root, 'foo.from', 1)\n    expect(res).toEqual({ to: 2 })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add folder as workspace configuration","suites":["Configurations"],"updatePoint":{"line":68,"column":50},"line":68,"code":"  it('should add folder as workspace configuration', () => {\n    let configurations = createConfigurations()\n    configurations.onDidChange(e => {\n      let affects = e.affectsConfiguration('coc')\n      expect(affects).toBe(true)\n    })\n    configurations.addFolderFile(workspaceConfigFile)\n    let o = configurations.configuration.workspace.contents\n    expect(o.coc.preferences.rootPath).toBe('./src')\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changed keys #1","suites":["Configurations"],"updatePoint":{"line":80,"column":32},"line":80,"code":"  it('should get changed keys #1', () => {\n    let res = getChangedKeys({ y: 2 }, { x: 1 })\n    expect(res).toEqual(['x', 'y'])\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changed keys #2","suites":["Configurations"],"updatePoint":{"line":85,"column":32},"line":85,"code":"  it('should get changed keys #2', () => {\n    let res = getChangedKeys({ x: 1, c: { d: 4 } }, { x: 1, b: { x: 5 } })\n    expect(res).toEqual(['b', 'b.x', 'c', 'c.d'])\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load default configurations","suites":["Configurations"],"updatePoint":{"line":90,"column":40},"line":90,"code":"  it('should load default configurations', () => {\n    let conf = new Configurations()\n    expect(conf.defaults.contents.coc).toBeDefined()\n    let c = conf.getConfiguration('languageserver')\n    expect(c).toEqual({})\n    conf.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse configurations","suites":["Configurations"],"updatePoint":{"line":98,"column":33},"line":98,"code":"  it('should parse configurations', () => {\n    let { contents } = getConfigurationModel()\n    expect(contents.foo.bar).toBe(1)\n    expect(contents.bar.foo).toBe(2)\n    expect(contents.schema).toEqual({ 'https://example.com': '*.yaml' })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update user config #1","suites":["Configurations"],"updatePoint":{"line":105,"column":34},"line":105,"code":"  it('should update user config #1', () => {\n    let conf = new Configurations()\n    let fn = jest.fn()\n    conf.onDidChange(e => {\n      expect(e.affectsConfiguration('x')).toBe(true)\n      fn()\n    })\n    conf.updateUserConfig({ x: 1 })\n    let config = conf.configuration.user\n    expect(config.contents).toEqual({ x: 1 })\n    expect(fn).toBeCalled()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update user config #2","suites":["Configurations"],"updatePoint":{"line":118,"column":34},"line":118,"code":"  it('should update user config #2', () => {\n    let conf = new Configurations()\n    conf.updateUserConfig({ x: 1 })\n    conf.updateUserConfig({ x: undefined })\n    let config = conf.configuration.user\n    expect(config.contents).toEqual({})\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update workspace config","suites":["Configurations"],"updatePoint":{"line":126,"column":36},"line":126,"code":"  it('should update workspace config', () => {\n    let conf = new Configurations()\n    conf.updateUserConfig({ foo: { bar: 1 } })\n    let curr = conf.getConfiguration('foo')\n    curr.update('bar', 2, false)\n    curr = conf.getConfiguration('foo')\n    let n = curr.get<number>('bar')\n    expect(n).toBe(2)\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle errors","suites":["Configurations"],"updatePoint":{"line":136,"column":26},"line":136,"code":"  it('should handle errors', () => {\n    let tmpFile = path.join(os.tmpdir(), uuidv1())\n    fs.writeFileSync(tmpFile, '{\"x\":', 'utf8')\n    let conf = new Configurations(tmpFile)\n    let errors = conf.errorItems\n    expect(errors.length > 1).toBe(true)\n    conf.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to new folder configuration","suites":["Configurations"],"updatePoint":{"line":145,"column":47},"line":145,"code":"  it('should change to new folder configuration', () => {\n    let conf = new Configurations()\n    conf.addFolderFile(workspaceConfigFile)\n    let configFile = path.join(__dirname, './settings.json')\n    conf.addFolderFile(configFile)\n    let file = path.resolve(__dirname, '../sample/tmp.js')\n    let fn = jest.fn()\n    conf.onDidChange(fn)\n    conf.setFolderConfiguration(URI.file(file).toString())\n    let { contents } = conf.workspace\n    expect(contents.foo).toBeUndefined()\n    expect(fn).toBeCalled()\n    conf.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get nested property","suites":["Configurations"],"updatePoint":{"line":160,"column":32},"line":160,"code":"  it('should get nested property', () => {\n    let config = createConfigurations()\n    let conf = config.getConfiguration('servers.c')\n    let res = conf.get<string>('trace.server', '')\n    expect(res).toBe('verbose')\n    config.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get user and workspace configuration","suites":["Configurations"],"updatePoint":{"line":168,"column":49},"line":168,"code":"  it('should get user and workspace configuration', () => {\n    let userConfigFile = path.join(__dirname, './settings.json')\n    let configurations = new Configurations(userConfigFile)\n    let data = configurations.configuration.toData()\n    expect(data.user).toBeDefined()\n    expect(data.workspace).toBeDefined()\n    expect(data.defaults).toBeDefined()\n    let value = configurations.configuration.getValue()\n    expect(value.foo).toBeDefined()\n    expect(value.foo.bar).toBe(1)\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should override with new value","suites":["Configurations"],"updatePoint":{"line":181,"column":36},"line":181,"code":"  it('should override with new value', () => {\n    let configurations = createConfigurations()\n    configurations.configuration.defaults.setValue('foo', 1)\n    let { contents } = configurations.defaults\n    expect(contents.foo).toBe(1)\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extends defaults","suites":["Configurations"],"updatePoint":{"line":189,"column":29},"line":189,"code":"  it('should extends defaults', () => {\n    let configurations = createConfigurations()\n    configurations.extendsDefaults({ 'a.b': 1 })\n    configurations.extendsDefaults({ 'a.b': 2 })\n    let o = configurations.defaults.contents\n    expect(o.a.b).toBe(2)\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update configuration","suites":["Configurations"],"updatePoint":{"line":198,"column":33},"line":198,"code":"  it('should update configuration', async () => {\n    let configurations = createConfigurations()\n    configurations.addFolderFile(workspaceConfigFile)\n    let fn = jest.fn()\n    configurations.onDidChange(e => {\n      expect(e.affectsConfiguration('foo')).toBe(true)\n      expect(e.affectsConfiguration('foo.bar')).toBe(true)\n      expect(e.affectsConfiguration('foo.bar', 'file://tmp/foo.js')).toBe(false)\n      fn()\n    })\n    let config = configurations.getConfiguration('foo')\n    let o = config.get<number>('bar')\n    expect(o).toBe(1)\n    config.update('bar', 6)\n    config = configurations.getConfiguration('foo')\n    expect(config.get<number>('bar')).toBe(6)\n    expect(fn).toBeCalledTimes(1)\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove configuration","suites":["Configurations"],"updatePoint":{"line":218,"column":33},"line":218,"code":"  it('should remove configuration', async () => {\n    let configurations = createConfigurations()\n    configurations.addFolderFile(workspaceConfigFile)\n    let fn = jest.fn()\n    configurations.onDidChange(e => {\n      expect(e.affectsConfiguration('foo')).toBe(true)\n      expect(e.affectsConfiguration('foo.bar')).toBe(true)\n      fn()\n    })\n    let config = configurations.getConfiguration('foo')\n    let o = config.get<number>('bar')\n    expect(o).toBe(1)\n    config.update('bar', null, true)\n    config = configurations.getConfiguration('foo')\n    expect(config.get<any>('bar')).toBeUndefined()\n    expect(fn).toBeCalledTimes(1)\n    configurations.dispose()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only split top level dot keys","suites":["parse configuration"],"updatePoint":{"line":239,"column":42},"line":239,"code":"  it('should only split top level dot keys', () => {\n    let o = { 'x.y': 'foo' }\n    let [, contents] = parseConfiguration(JSON.stringify(o))\n    expect(contents).toEqual({ x: { y: 'foo' } })\n    let schema = { 'my.schema': { 'foo.bar': 1 } }\n    let [, obj] = parseConfiguration(JSON.stringify(schema))\n    expect(obj).toEqual({ my: { schema: { 'foo.bar': 1 } } })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not parse uri properties","suites":["parse configuration"],"updatePoint":{"line":248,"column":37},"line":248,"code":"  it('should not parse uri properties', async () => {\n    let o: any = {\n      foo: {\n        'bar://x': '',\n        'file://y': ''\n      }\n    }\n    let [, contents] = parseConfiguration(JSON.stringify(o))\n    expect(contents).toEqual({\n      foo: {\n        'bar://x': '',\n        'file://y': ''\n      }\n    })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge preperties","suites":["parse configuration"],"updatePoint":{"line":264,"column":29},"line":264,"code":"  it('should merge preperties', async () => {\n    let res = mergeConfigProperties({\n      foo: 'bar',\n      \"x.y.a\": \"x\",\n      \"x.y.b\": \"y\",\n      \"x.t\": \"z\"\n    })\n    expect(res).toEqual({\n      foo: 'bar', x: { y: { a: 'x', b: 'y' }, t: 'z' }\n    })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by position","suites":["cursors#select"],"updatePoint":{"line":37,"column":31},"line":37,"code":"  it('should select by position', async () => {\n    let doc = await helper.createDocument()\n    await nvim.call('setline', [1, ['a', 'b']])\n    await nvim.call('cursor', [1, 1])\n    await helper.wait(100)\n    doc.forceSync()\n    await helper.wait(100)\n    await cursors.select(doc.bufnr, 'position', 'n')\n    await helper.wait(30)\n    let n = await rangeCount()\n    expect(n).toBe(1)\n    await nvim.setOption('virtualedit', 'onemore')\n    await nvim.call('cursor', [2, 2])\n    await cursors.select(doc.bufnr, 'position', 'n')\n    n = await rangeCount()\n    expect(n).toBe(2)\n    await cursors.select(doc.bufnr, 'position', 'n')\n    n = await rangeCount()\n    expect(n).toBe(1)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by word","suites":["cursors#select"],"updatePoint":{"line":58,"column":27},"line":58,"code":"  it('should select by word', async () => {\n    let doc = await helper.createDocument()\n    await nvim.call('setline', [1, ['foo', 'bar']])\n    await nvim.call('cursor', [1, 1])\n    await helper.wait(30)\n    doc.forceSync()\n    await cursors.select(doc.bufnr, 'word', 'n')\n    let n = await rangeCount()\n    expect(n).toBe(1)\n    await nvim.call('cursor', [2, 2])\n    await cursors.select(doc.bufnr, 'word', 'n')\n    n = await rangeCount()\n    expect(n).toBe(2)\n    await cursors.select(doc.bufnr, 'word', 'n')\n    n = await rangeCount()\n    expect(n).toBe(1)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select last character","suites":["cursors#select"],"updatePoint":{"line":76,"column":34},"line":76,"code":"  it('should select last character', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setOption('virtualedit', 'onemore')\n    await nvim.call('setline', [1, ['}', '{']])\n    await nvim.call('cursor', [1, 2])\n    await helper.wait(30)\n    doc.forceSync()\n    await cursors.select(doc.bufnr, 'word', 'n')\n    let n = await rangeCount()\n    expect(n).toBe(1)\n    await nvim.call('cursor', [2, 1])\n    await helper.wait(30)\n    doc.forceSync()\n    await cursors.select(doc.bufnr, 'word', 'n')\n    n = await rangeCount()\n    expect(n).toBe(2)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by visual range","suites":["cursors#select"],"updatePoint":{"line":94,"column":35},"line":94,"code":"  it('should select by visual range', async () => {\n    let doc = await helper.createDocument()\n    await nvim.call('setline', [1, ['\"foo\"', '\"bar\"']])\n    await nvim.call('cursor', [1, 1])\n    await nvim.command('normal! vE')\n    await helper.wait(30)\n    doc.forceSync()\n    await cursors.select(doc.bufnr, 'range', 'v')\n    let n = await rangeCount()\n    expect(n).toBe(1)\n    await nvim.call('cursor', [2, 1])\n    await nvim.command('normal! vE')\n    await cursors.select(doc.bufnr, 'range', 'v')\n    n = await rangeCount()\n    expect(n).toBe(2)\n    await cursors.select(doc.bufnr, 'range', 'v')\n    n = await rangeCount()\n    expect(n).toBe(1)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by operator","suites":["cursors#select"],"updatePoint":{"line":114,"column":31},"line":114,"code":"  it('should select by operator', async () => {\n    await nvim.command('nmap x  <Plug>(coc-cursors-operator)')\n    await helper.createDocument()\n    await nvim.call('setline', [1, ['\"short\"', '\"long\"']])\n    await nvim.call('cursor', [1, 2])\n    await nvim.input('xa\"')\n    await helper.wait(30)\n    await nvim.call('cursor', [2, 2])\n    await nvim.input('xa\"')\n    await helper.wait(30)\n    await nvim.command('nunmap x')\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add ranges","suites":["cursors#addRanges"],"updatePoint":{"line":129,"column":23},"line":129,"code":"  it('should add ranges', async () => {\n    let doc = await helper.createDocument()\n    await nvim.call('setline', [1, ['foo foo foo', 'bar bar']])\n    await helper.wait(30)\n    doc.forceSync()\n    let ranges = [\n      Range.create(0, 0, 0, 3),\n      Range.create(0, 4, 0, 7),\n      Range.create(0, 8, 0, 11),\n      Range.create(1, 0, 1, 3),\n      Range.create(1, 4, 1, 7)\n    ]\n    await cursors.addRanges(ranges)\n    let n = await rangeCount()\n    expect(n).toBe(5)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore change after last range","suites":["cursors#onchange"],"updatePoint":{"line":166,"column":43},"line":166,"code":"  it('should ignore change after last range', async () => {\n    let doc = await setup()\n    await doc.buffer.append(['append'])\n    doc.forceSync()\n    await helper.wait(50)\n    let n = await rangeCount()\n    expect(n).toBe(5)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust ranges on change before first line","suites":["cursors#onchange"],"updatePoint":{"line":175,"column":54},"line":175,"code":"  it('should adjust ranges on change before first line', async () => {\n    let doc = await setup()\n    await doc.buffer.setLines(['prepend'], { start: 0, end: 0, strictIndexing: false })\n    doc.forceSync()\n    await helper.wait(200)\n    let n = await rangeCount()\n    expect(n).toBe(5)\n    await nvim.call('cursor', [2, 1])\n    await nvim.input('ia')\n    await helper.wait(100)\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['prepend', 'afoo afoo afoo', 'abar abar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work when change made to unrelated line","suites":["cursors#onchange"],"updatePoint":{"line":191,"column":52},"line":191,"code":"  it('should work when change made to unrelated line', async () => {\n    let doc = await setup()\n    await doc.buffer.setLines(['prepend'], { start: 0, end: 0, strictIndexing: false })\n    doc.forceSync()\n    await helper.wait(200)\n    let n = await rangeCount()\n    expect(n).toBe(5)\n    await nvim.call('cursor', [1, 1])\n    await nvim.input('ia')\n    await helper.wait(200)\n    doc.forceSync()\n    await helper.wait(100)\n    await nvim.call('cursor', [2, 1])\n    await nvim.input('a')\n    await helper.wait(100)\n    await doc.synchronize()\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['aprepend', 'afoo afoo afoo', 'abar abar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add text before","suites":["cursors#onchange"],"updatePoint":{"line":211,"column":28},"line":211,"code":"  it('should add text before', async () => {\n    let doc = await setup()\n    await nvim.input('iabc')\n    await helper.wait(30)\n    await doc.synchronize()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['abcfoo abcfoo abcfoo', 'abcbar abcbar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add text after","suites":["cursors#onchange"],"updatePoint":{"line":221,"column":27},"line":221,"code":"  it('should add text after', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 4])\n    await nvim.input('iabc')\n    await helper.wait(30)\n    await doc.synchronize()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['fooabc fooabc fooabc', 'barabc barabc'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add text around","suites":["cursors#onchange"],"updatePoint":{"line":232,"column":28},"line":232,"code":"  it('should add text around', async () => {\n    let doc = await setup()\n    await nvim.setLine('\"foo\" foo foo')\n    await helper.wait(30)\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['\"foo\" \"foo\" \"foo\"', '\"bar\" \"bar\"'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove text before","suites":["cursors#onchange"],"updatePoint":{"line":242,"column":31},"line":242,"code":"  it('should remove text before', async () => {\n    let doc = await setup()\n    await nvim.command('normal! x')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['oo oo oo', 'ar ar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove text middle","suites":["cursors#onchange"],"updatePoint":{"line":251,"column":31},"line":251,"code":"  it('should remove text middle', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [2, 2])\n    await nvim.command('normal! x')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['fo fo fo', 'br br'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove text after","suites":["cursors#onchange"],"updatePoint":{"line":261,"column":30},"line":261,"code":"  it('should remove text after', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 3])\n    await nvim.command('normal! x')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['fo fo fo', 'ba ba'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove text around","suites":["cursors#onchange"],"updatePoint":{"line":271,"column":31},"line":271,"code":"  it('should remove text around', async () => {\n    let doc = await helper.createDocument()\n    await nvim.call('setline', [1, ['\"foo\" \"bar\"']])\n    await helper.wait(30)\n    doc.forceSync()\n    let ranges = [\n      Range.create(0, 0, 0, 5),\n      Range.create(0, 6, 0, 11)\n    ]\n    await cursors.addRanges(ranges)\n    await nvim.call('cursor', [1, 2])\n    await nvim.setLine('foo \"bar\"')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['foo bar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should replace text before","suites":["cursors#onchange"],"updatePoint":{"line":289,"column":32},"line":289,"code":"  it('should replace text before', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 1])\n    await nvim.command('normal! ra')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['aoo aoo aoo', 'aar aar'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should replace text after","suites":["cursors#onchange"],"updatePoint":{"line":299,"column":31},"line":299,"code":"  it('should replace text after', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 3])\n    await nvim.command('normal! ra')\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['foa foa foa', 'baa baa'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should replace text middle","suites":["cursors#onchange"],"updatePoint":{"line":309,"column":32},"line":309,"code":"  it('should replace text middle', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 2])\n    await nvim.input('sab')\n    await helper.wait(30)\n    doc.forceSync()\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['fabo fabo fabo', 'babr babr'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust undo & redo on add & remove","suites":["cursors#onchange"],"updatePoint":{"line":320,"column":47},"line":320,"code":"  it('should adjust undo & redo on add & remove', async () => {\n    let doc = await setup()\n    await nvim.call('cursor', [1, 4])\n    await nvim.input('iabc')\n    await helper.wait(30)\n    doc.forceSync()\n    let n = await rangeCount()\n    expect(n).toBe(5)\n    await helper.wait(30)\n    await nvim.command('undo')\n    await helper.wait(30)\n    doc.forceSync()\n    n = await rangeCount()\n    expect(n).toBe(5)\n    await helper.wait(30)\n    await nvim.command('redo')\n    await helper.wait(30)\n    doc.forceSync()\n    expect(await rangeCount()).toBe(5)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['fooabc fooabc fooabc', 'barabc barabc'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust undo & redo on change around","suites":["cursors#onchange"],"updatePoint":{"line":343,"column":48},"line":343,"code":"  it('should adjust undo & redo on change around', async () => {\n    let doc = await setup()\n    await nvim.setLine('\"foo\" foo foo')\n    await helper.wait(30)\n    doc.forceSync()\n    expect(await rangeCount()).toBe(5)\n    await helper.wait(30)\n    await nvim.command('undo')\n    await helper.wait(30)\n    doc.forceSync()\n    expect(await rangeCount()).toBe(5)\n    await helper.wait(30)\n    await nvim.command('redo')\n    await helper.wait(30)\n    doc.forceSync()\n    expect(await rangeCount()).toBe(5)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['\"foo\" \"foo\" \"foo\"', '\"bar\" \"bar\"'])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup cancel keymap","suites":["cursors#keymaps"],"updatePoint":{"line":386,"column":32},"line":386,"code":"  it('should setup cancel keymap', async () => {\n    await setup()\n    let count = await rangeCount()\n    expect(count).toBe(3)\n    await nvim.input('<esc>')\n    await helper.wait(100)\n    count = await rangeCount()\n    expect(count).toBe(0)\n    let has = await hasKeymap('<Esc>')\n    expect(has).toBe(false)\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup next key","suites":["cursors#keymaps"],"updatePoint":{"line":398,"column":27},"line":398,"code":"  it('should setup next key', async () => {\n    await setup()\n    await nvim.input('<C-n>')\n    await helper.wait(50)\n    let cursor = await nvim.call('coc#cursor#position')\n    expect(cursor).toEqual([0, 0])\n    await nvim.input('<C-n>')\n    await helper.wait(50)\n    cursor = await nvim.call('coc#cursor#position')\n    expect(cursor).toEqual([1, 0])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup previous key","suites":["cursors#keymaps"],"updatePoint":{"line":410,"column":31},"line":410,"code":"  it('should setup previous key', async () => {\n    await setup()\n    await nvim.input('<C-p>')\n    await helper.wait(50)\n    let cursor = await nvim.call('coc#cursor#position')\n    expect(cursor).toEqual([1, 0])\n    await nvim.input('<C-p>')\n    await helper.wait(50)\n    cursor = await nvim.call('coc#cursor#position')\n    expect(cursor).toEqual([0, 0])\n  })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.exists()","suites":["DB"],"updatePoint":{"line":19,"column":19},"line":19,"code":"  test('db.exists()', async () => {\n    let exists = db.exists('a.b')\n    expect(exists).toBe(false)\n    db.push('a.b', { foo: 1 })\n    exists = db.exists('a.b.foo')\n    expect(exists).toBe(true)\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.fetch()","suites":["DB"],"updatePoint":{"line":27,"column":18},"line":27,"code":"  test('db.fetch()', async () => {\n    let res = await db.fetch('x')\n    expect(res).toBeUndefined()\n    db.push('x', 1)\n    res = await db.fetch('x')\n    expect(res).toBe(1)\n    db.push('x', { foo: 1 })\n    res = await db.fetch('x')\n    expect(res).toEqual({ foo: 1 })\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.delete()","suites":["DB"],"updatePoint":{"line":38,"column":19},"line":38,"code":"  test('db.delete()', async () => {\n    db.push('foo.bar', 1)\n    db.delete('foo.bar')\n    let exists = db.exists('foo.bar')\n    expect(exists).toBe(false)\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.push()","suites":["DB"],"updatePoint":{"line":45,"column":17},"line":45,"code":"  test('db.push()', async () => {\n    db.push('foo.x', 1)\n    db.push('foo.y', '2')\n    db.push('foo.z', true)\n    db.push('foo.n', null)\n    db.push('foo.o', { x: 1 })\n    let res = db.fetch('foo')\n    expect(res).toEqual({\n      x: 1,\n      y: '2',\n      z: true,\n      n: null,\n      o: { x: 1 }\n    })\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"overlapping","suites":["memorize"],"updatePoint":{"line":11,"column":19},"line":11,"code":"  test('overlapping', async () => {\n    const c = new CallTest()\n\n    const first = c.memorized()\n    const second = c.memorized()\n    expect(await first).toBe(1)\n    expect(await second).toBe(2)\n  })","file":"modules/decorator.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"nonoverlapping","suites":["memorize"],"updatePoint":{"line":19,"column":22},"line":19,"code":"  test('nonoverlapping', async () => {\n    const c = new CallTest()\n\n    const first = c.memorized()\n    expect(await first).toBe(1)\n    const second = c.memorized()\n    expect(await second).toBe(1)\n  })","file":"modules/decorator.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add signs","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":65,"column":24},"line":65,"code":"    it('should add signs', async () => {\n      let diagnostics = [createDiagnostic('foo'), createDiagnostic('bar')]\n      let buf = await createDiagnosticBuffer()\n      buf.addSigns('a', diagnostics)\n      await helper.wait(30)\n      let res = await nvim.call('sign_getplaced', [buf.bufnr, { group: 'CocDiagnostica' }])\n      let signs = res[0].signs\n      expect(signs).toBeDefined()\n      expect(signs[0].name).toBe('CocError')\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostic info","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":76,"column":34},"line":76,"code":"    it('should set diagnostic info', async () => {\n      let r = Range.create(0, 1, 0, 2)\n      let diagnostics = [\n        createDiagnostic('foo', r, DiagnosticSeverity.Error),\n        createDiagnostic('bar', r, DiagnosticSeverity.Warning),\n        createDiagnostic('foo', r, DiagnosticSeverity.Hint),\n        createDiagnostic('bar', r, DiagnosticSeverity.Information)\n      ]\n      let buf = await createDiagnosticBuffer()\n      await buf.refresh({ '': diagnostics })\n      let buffer = await nvim.buffer\n      let res = await buffer.getVar('coc_diagnostic_info')\n      expect(res).toEqual({\n        lnums: [1, 1, 1, 1],\n        information: 1,\n        hint: 1,\n        warning: 1,\n        error: 1\n      })\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlight","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":97,"column":28},"line":97,"code":"    it('should add highlight', async () => {\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.setLine('abc')\n      await doc.patchChange(true)\n      nvim.pauseNotification()\n      buf.updateHighlights('', [\n        createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Error),\n        createDiagnostic('bar', Range.create(0, 0, 0, 1), DiagnosticSeverity.Warning)\n      ])\n      await nvim.resumeNotification()\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res).toEqual([\n        [\n          1,\n          0,\n          0,\n          {\n            hl_group: 'CocWarningHighlight',\n            priority: 4096,\n            end_col: 1,\n            end_row: 0\n          }\n        ],\n        [\n          2,\n          0,\n          0,\n          {\n            hl_group: 'CocErrorHighlight',\n            priority: 4096,\n            end_col: 1,\n            end_row: 0\n          }\n        ]\n      ])\n      nvim.pauseNotification()\n      buf.updateHighlights('', [])\n      await nvim.resumeNotification()\n      res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any[]\n      expect(res.length).toBe(0)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add deprecated highlight","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":140,"column":39},"line":140,"code":"    it('should add deprecated highlight', async () => {\n      let diagnostic = createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Information, [DiagnosticTag.Deprecated])\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.setLine('foo')\n      await doc.patchChange(true)\n      nvim.pauseNotification()\n      buf.updateHighlights('', [diagnostic])\n      await nvim.resumeNotification()\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, {}]) as [number, number, number][]\n      expect(res.length).toBe(1)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show virtual text on current line","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":166,"column":48},"line":166,"code":"    it('should show virtual text on current line', async () => {\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.refresh({ '': diagnostics })\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n      let texts = res[0][3].virt_text\n      expect(texts[0]).toEqual([' foo', 'CocErrorVirtualText'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show virtual text align right","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":178,"column":44},"line":178,"code":"    it('should show virtual text align right', async () => {\n      config.virtualTextAlignRight = true\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.refresh({ '': diagnostics })\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n      let texts = res[0][3].virt_text\n      expect(texts[0]).toEqual([' foo', 'CocErrorVirtualText'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show virtual text at window column","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":191,"column":49},"line":191,"code":"    it('should show virtual text at window column', async () => {\n      config.virtualTextWinCol = 90\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.refresh({ '': diagnostics })\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n      let texts = res[0][3].virt_text\n      expect(texts[0]).toEqual([' foo', 'CocErrorVirtualText'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should virtual text on all lines","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":204,"column":40},"line":204,"code":"    it('should virtual text on all lines', async () => {\n      config.virtualTextCurrentLineOnly = false\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [\n        createDiagnostic('foo', Range.create(0, 0, 0, 1)),\n        createDiagnostic('bar', Range.create(1, 0, 1, 1)),\n      ]\n      await buf.refresh({ '': diagnostics })\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(2)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update location list","suites":["diagnostic buffer","updateLocationList()"],"updatePoint":{"line":226,"column":35},"line":226,"code":"    it('should update location list', async () => {\n      let buf = await createDiagnosticBuffer()\n      await nvim.call('setloclist', [0, [], 'r', { title: 'Diagnostics of coc', items: [] }])\n      await buf.refresh({\n        a: [createDiagnostic('foo')]\n      })\n      let res = await nvim.eval(`getloclist(bufwinid(${buf.bufnr}))`) as any[]\n      expect(res.length).toBe(1)\n      expect(res[0].text).toBe('[test 999] foo [E]')\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear all diagnostics","suites":["diagnostic buffer","clear()"],"updatePoint":{"line":247,"column":36},"line":247,"code":"    it('should clear all diagnostics', async () => {\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.refresh({ '': diagnostics })\n      buf.clear()\n      await helper.wait(50)\n      let buffer = await nvim.buffer\n      let res = await buffer.getVar(\"coc_diagnostic_info\")\n      expect(res == null).toBe(true)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sorted diagnostics","suites":["diagnostic buffer","getDiagnostics()"],"updatePoint":{"line":261,"column":37},"line":261,"code":"    it('should get sorted diagnostics', async () => {\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [\n        createDiagnostic('three', Range.create(0, 1, 0, 2), DiagnosticSeverity.Error),\n        createDiagnostic('one', Range.create(0, 0, 0, 2), DiagnosticSeverity.Warning),\n        createDiagnostic('two', Range.create(0, 0, 0, 2), DiagnosticSeverity.Error),\n      ]\n      diagnostics[0].tags = [DiagnosticTag.Unnecessary]\n      await buf.refresh({\n        x: diagnostics,\n        y: [createDiagnostic('four', Range.create(0, 0, 0, 2), DiagnosticSeverity.Error)]\n      })\n      let res = buf.getDiagnosticsAt(Position.create(0, 1), false)\n      let arr = res.map(o => o.message)\n      expect(arr).toEqual(['four', 'two', 'three', 'one'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create collection","suites":["diagnostic collection"],"updatePoint":{"line":11,"column":30},"line":11,"code":"  it('should create collection', () => {\n    let collection = new DiagnosticCollection('test')\n    expect(collection.name).toBe('test')\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostic with uri","suites":["diagnostic collection"],"updatePoint":{"line":16,"column":36},"line":16,"code":"  it('should set diagnostic with uri', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    expect(collection.get(uri).length).toBe(1)\n    collection.set(uri, [])\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear diagnostics with null as diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":26,"column":55},"line":26,"code":"  it('should clear diagnostics with null as diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    expect(collection.get(uri).length).toBe(1)\n    collection.set(uri, null)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear diagnostics with undefined as diagnostics in entries","suites":["diagnostic collection"],"updatePoint":{"line":36,"column":71},"line":36,"code":"  it('should clear diagnostics with undefined as diagnostics in entries', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let entries: [string, Diagnostic[] | null][] = [\n      ['file:1', [diagnostic]],\n      ['file:1', undefined]\n    ]\n    let uri = 'file:///1'\n    collection.set(entries)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostics with entries","suites":["diagnostic collection"],"updatePoint":{"line":48,"column":41},"line":48,"code":"  it('should set diagnostics with entries', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    let other = 'file:///2'\n    let entries: [string, Diagnostic[]][] = [\n      [uri, [diagnostic]],\n      [other, [diagnostic]],\n      [uri, [createDiagnostic('other')]]\n    ]\n    collection.set(entries)\n    expect(collection.get(uri).length).toBe(2)\n    expect(collection.get(other).length).toBe(1)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete diagnostics for uri","suites":["diagnostic collection"],"updatePoint":{"line":63,"column":39},"line":63,"code":"  it('should delete diagnostics for uri', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    collection.delete(uri)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear all diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":72,"column":34},"line":72,"code":"  it('should clear all diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    collection.clear()\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call for every uri with diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":81,"column":48},"line":81,"code":"  it('should call for every uri with diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    let other = 'file:///2'\n    let entries: [string, Diagnostic[]][] = [\n      [uri, [diagnostic]],\n      [other, [diagnostic]],\n      [uri, [createDiagnostic('other')]]\n    ]\n    collection.set(entries)\n    let arr: string[] = []\n    collection.forEach(uri => {\n      arr.push(uri)\n    })\n    expect(arr).toEqual([uri, other])\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on buffer create","suites":["diagnostic manager","refresh()"],"updatePoint":{"line":53,"column":39},"line":53,"code":"    it('should refresh on buffer create', async () => {\n      let uri = URI.file(path.join(path.dirname(__dirname), 'doc')).toString()\n      let fn = jest.fn()\n      let disposable = manager.onDidRefresh(() => {\n        fn()\n      })\n      let collection = manager.create('tmp')\n      let diagnostic = createDiagnostic('My Error')\n      collection.set(uri, [diagnostic])\n      let doc = await helper.createDocument('doc')\n      let val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(fn).toBeCalled()\n      expect(val).toBeDefined()\n      expect(val.error).toBe(1)\n      collection.dispose()\n      disposable.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delay refresh on InsertLeave","suites":["diagnostic manager","refresh()"],"updatePoint":{"line":71,"column":43},"line":71,"code":"    it('should delay refresh on InsertLeave', async () => {\n      let doc = await helper.createDocument()\n      await nvim.input('i')\n      let collection = manager.create('test')\n      let diagnostics: Diagnostic[] = []\n      await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      diagnostics.push(createDiagnostic('error', Range.create(0, 2, 0, 4), DiagnosticSeverity.Error))\n      collection.set(doc.uri, diagnostics)\n      await helper.wait(10)\n      await nvim.input('<esc>')\n      await helper.wait(100)\n      let val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBe(null)\n      await helper.wait(600)\n      val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBeDefined()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle diagnostics","suites":["diagnostic manager","toggleDiagnostic()"],"updatePoint":{"line":95,"column":33},"line":95,"code":"    it('should toggle diagnostics', async () => {\n      let doc = await createDocument()\n      await helper.wait(50)\n      manager.toggleDiagnostic()\n      await helper.wait(50)\n      let val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBe(null)\n      manager.toggleDiagnostic()\n      await helper.wait(50)\n      val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBeDefined()\n      expect(val.error).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all diagnostics","suites":["diagnostic manager","getDiagnosticList()"],"updatePoint":{"line":111,"column":34},"line":111,"code":"    it('should get all diagnostics', async () => {\n      await createDocument()\n      let list = manager.getDiagnosticList()\n      expect(list).toBeDefined()\n      expect(list.length).toBeGreaterThanOrEqual(5)\n      expect(list[0].severity).toBe('Error')\n      expect(list[1].severity).toBe('Error')\n      expect(list[2].severity).toBe('Warning')\n      expect(list[3].severity).toBe('Information')\n      expect(list[4].severity).toBe('Hint')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter diagnostics by configuration","suites":["diagnostic manager","getDiagnosticList()"],"updatePoint":{"line":123,"column":50},"line":123,"code":"    it('should filter diagnostics by configuration', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('level', 'warning')\n      config.update('showUnused', false)\n      config.update('showDeprecated', false)\n      let doc = await createDocument()\n      let diagnostics = manager.getDiagnostics(doc.uri)['test']\n      diagnostics[0].tags = [DiagnosticTag.Unnecessary]\n      diagnostics[2].tags = [DiagnosticTag.Deprecated]\n      let collection = manager.getCollectionByName('test')\n      collection.set(doc.uri, diagnostics)\n      let list = manager.getDiagnosticList()\n      expect(list.length).toBe(1)\n      expect(list[0].severity).toBe('Warning')\n      let res = manager.getDiagnostics(doc.uri)['test']\n      expect(res.length).toBe(1)\n      helper.updateConfiguration('diagnostic.level', 'hint')\n      helper.updateConfiguration('diagnostic.showUnused', true)\n      helper.updateConfiguration('diagnostic.showDeprecated', true)\n      let ranges = manager.getSortedRanges(doc.uri)\n      expect(ranges.length).toBe(3)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw with empty diagnostics","suites":["diagnostic manager","preview()"],"updatePoint":{"line":148,"column":47},"line":148,"code":"    it('should not throw with empty diagnostics', async () => {\n      await helper.createDocument()\n      await manager.preview()\n      let tabpage = await nvim.tabpage\n      let wins = await tabpage.windows\n      expect(wins.length).toBe(1)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open preview window","suites":["diagnostic manager","preview()"],"updatePoint":{"line":156,"column":34},"line":156,"code":"    it('should open preview window', async () => {\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      await manager.preview()\n      let res = await nvim.call('coc#window#find', ['&previewwindow', 1])\n      expect(res).toBeDefined()\n      await nvim.call('win_gotoid', [res])\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines[0]).toEqual('[test] [E]')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set location list","suites":["diagnostic manager","setLocationlist()"],"updatePoint":{"line":170,"column":32},"line":170,"code":"    it('should set location list', async () => {\n      let doc = await createDocument()\n      await manager.setLocationlist(doc.bufnr)\n      await nvim.command('lopen')\n      let buftype = await nvim.eval('&buftype') as string\n      expect(buftype).toBe('quickfix')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set configuration errors","suites":["diagnostic manager","setConfigurationErrors()"],"updatePoint":{"line":180,"column":39},"line":180,"code":"    it('should set configuration errors', async () => {\n      let doc = await helper.createDocument()\n      let errors = [{\n        location: Location.create(doc.uri, Range.create(0, 0, 1, 0)),\n        message: 'foo',\n      }, {\n        location: Location.create(doc.uri, Range.create(1, 0, 2, 0)),\n        message: 'bar',\n      }]\n      manager.setConfigurationErrors(errors)\n      await helper.wait(50)\n      let res = manager.getDiagnostics(doc.uri, 'config')['config']\n      expect(res.length).toBe(2)\n      manager.setConfigurationErrors()\n      await helper.wait(50)\n      res = manager.getDiagnostics(doc.uri, 'config')['config']\n      expect(res.length).toBe(0)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create diagnostic collection","suites":["diagnostic manager","create()"],"updatePoint":{"line":201,"column":43},"line":201,"code":"    it('should create diagnostic collection', async () => {\n      let doc = await helper.createDocument()\n      let collection = manager.create('test')\n      collection.set(doc.uri, [createDiagnostic('foo')])\n      await helper.wait(50)\n      let info = await doc.buffer.getVar('coc_diagnostic_info')\n      expect(info).toBeDefined()\n      await nvim.command('bd!')\n      await helper.wait(50)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sorted ranges of document","suites":["diagnostic manager","getSortedRanges()"],"updatePoint":{"line":214,"column":44},"line":214,"code":"    it('should get sorted ranges of document', async () => {\n      let doc = await helper.createDocument()\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      let collection = manager.create('test')\n      let diagnostics: Diagnostic[] = []\n      diagnostics.push(createDiagnostic('x', Range.create(0, 0, 0, 1)))\n      diagnostics.push(createDiagnostic('y', Range.create(0, 1, 0, 2)))\n      diagnostics.push(createDiagnostic('z', Range.create(1, 0, 1, 2)))\n      collection.set(doc.uri, diagnostics)\n      let ranges = manager.getSortedRanges(doc.uri)\n      expect(ranges[0]).toEqual(Range.create(0, 0, 0, 1))\n      expect(ranges[1]).toEqual(Range.create(0, 1, 0, 2))\n      expect(ranges[2]).toEqual(Range.create(1, 0, 1, 2))\n      ranges = manager.getSortedRanges(doc.uri, 'error')\n      expect(ranges.length).toBe(3)\n      expect(manager.getSortedRanges(doc.uri, 'warning').length).toBe(0)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostics in range","suites":["diagnostic manager","getDiagnosticsInRange"],"updatePoint":{"line":234,"column":39},"line":234,"code":"    it('should get diagnostics in range', async () => {\n      let doc = await helper.createDocument()\n      let collection = manager.create('test')\n      let diagnostics: Diagnostic[] = []\n      await doc.buffer.setLines(['foo bar foo bar', 'foo bar'], {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await helper.wait(300)\n      diagnostics.push(createDiagnostic('a', Range.create(0, 0, 0, 1)))\n      diagnostics.push(createDiagnostic('b', Range.create(0, 2, 0, 3)))\n      diagnostics.push(createDiagnostic('c', Range.create(1, 0, 1, 2)))\n      collection.set(doc.uri, diagnostics)\n      let res = manager.getDiagnosticsInRange(doc.textDocument, Range.create(0, 0, 0, 3))\n      expect(res.length).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostics under corsor","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":254,"column":43},"line":254,"code":"    it('should get diagnostics under corsor', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      await createDocument()\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(0)\n      await nvim.call('cursor', [1, 4])\n      diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(1)\n      config.update('checkCurrentLine', true)\n      await nvim.call('cursor', [1, 2])\n      diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(2)\n      config.update('checkCurrentLine', false)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty diagnostic at end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":269,"column":50},"line":269,"code":"    it('should get empty diagnostic at end of line', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr, true)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic next to end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":284,"column":49},"line":284,"code":"    it('should get diagnostic next to end of line', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 0, 4), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr, true)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic with empty range at end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":299,"column":61},"line":299,"code":"    it('should get diagnostic with empty range at end of line', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr, true)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic pass end of the buffer lines","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":314,"column":58},"line":314,"code":"    it('should get diagnostic pass end of the buffer lines', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! ^')\n      let diagnostic = Diagnostic.create(Range.create(1, 0, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr, true)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to related position","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":332,"column":39},"line":332,"code":"    it('should jump to related position', async () => {\n      let doc = await helper.createDocument()\n      let range = Range.create(0, 0, 0, 10)\n      let location = Location.create(URI.file(__filename).toString(), range)\n      let diagnostic = Diagnostic.create(range, 'msg', DiagnosticSeverity.Error, 1000, 'test',\n        [{ location, message: 'test' }])\n      let collection = manager.create('positions')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.uri, true)\n      await nvim.call('cursor', [1, 1])\n      await manager.jumpRelated()\n      await helper.wait(100)\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toMatch('diagnosticManager')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open location list","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":348,"column":33},"line":348,"code":"    it('should open location list', async () => {\n      let doc = await helper.createDocument()\n      let range = Range.create(0, 0, 0, 10)\n      let diagnostic = Diagnostic.create(range, 'msg', DiagnosticSeverity.Error, 1000, 'test',\n        [{\n          location: Location.create(URI.file(__filename).toString(), Range.create(1, 0, 1, 10)),\n          message: 'foo'\n        }, {\n          location: Location.create(URI.file(__filename).toString(), Range.create(2, 0, 2, 10)),\n          message: 'bar'\n        }])\n      let collection = manager.create('positions')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.uri, true)\n      await nvim.call('cursor', [1, 1])\n      await manager.jumpRelated()\n      await helper.wait(100)\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toBe('list:///location')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to previous","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":371,"column":31},"line":371,"code":"    it('should jump to previous', async () => {\n      let doc = await createDocument()\n      await nvim.command('normal! G$')\n      let ranges = manager.getSortedRanges(doc.uri)\n      ranges.reverse()\n      for (let i = 0; i < ranges.length; i++) {\n        await manager.jumpPrevious()\n        let pos = await window.getCursorPosition()\n        expect(pos).toEqual(ranges[i].start)\n      }\n      await manager.jumpPrevious()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to next","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":384,"column":27},"line":384,"code":"    it('should jump to next', async () => {\n      let doc = await createDocument()\n      await nvim.call('cursor', [0, 0])\n      let ranges = manager.getSortedRanges(doc.uri)\n      for (let i = 0; i < ranges.length; i++) {\n        await manager.jumpNext()\n        let pos = await window.getCursorPosition()\n        expect(pos).toEqual(ranges[i].start)\n      }\n      await manager.jumpNext()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use filetype map from config","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":398,"column":43},"line":398,"code":"    it('should use filetype map from config', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('filetypeMap', { default: 'bufferType' })\n      let doc = await createDocument('foo.js')\n      let collection = manager.getCollectionByName('test')\n      let diagnostics = [createDiagnostic('99', Range.create(0, 0, 0, 2), DiagnosticSeverity.Error)]\n      collection.set(doc.uri, diagnostics)\n      await nvim.call('cursor', [1, 1])\n      await nvim.command('doautocmd CursorHold')\n      let winid = await helper.waitFloat()\n      await nvim.call('win_gotoid', [winid])\n      await nvim.command('normal! $')\n      let res = await nvim.eval('synIDattr(synID(line(\".\"),col(\".\"),1),\"name\")')\n      expect(res).toMatch(/javascript/i)\n      config.update('filetypeMap', {})\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show floating window on cursor hold","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":415,"column":50},"line":415,"code":"    it('should show floating window on cursor hold', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('messageTarget', 'float')\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      await nvim.command('doautocmd CursorHold')\n      let winid = await helper.waitFloat()\n      let bufnr = await nvim.call('nvim_win_get_buf', winid) as number\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.lines\n      expect(lines.join('\\n')).toMatch('error')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo messages on cursor hold","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":428,"column":43},"line":428,"code":"    it('should echo messages on cursor hold', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('messageTarget', 'echo')\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      await helper.wait(600)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('error')\n      config.update('messageTarget', 'float')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show diagnostics of current line","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":439,"column":47},"line":439,"code":"    it('should show diagnostics of current line', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('checkCurrentLine', true)\n      await createDocument()\n      await nvim.call('cursor', [1, 1])\n      let winid = await helper.waitFloat()\n      let bufnr = await nvim.call('nvim_win_get_buf', winid) as number\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.lines\n      expect(lines.length).toBe(3)\n      config.update('checkCurrentLine', false)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter diagnostics by level","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":452,"column":42},"line":452,"code":"    it('should filter diagnostics by level', async () => {\n      helper.updateConfiguration('diagnostic.level', 'warning')\n      let doc = await createDocument()\n      let diagnosticsMap = manager.getDiagnostics(doc.uri)\n      for (let diagnostics of Object.values(diagnosticsMap)) {\n        for (let diagnostic of diagnostics) {\n          expect(diagnostic.severity != DiagnosticSeverity.Hint).toBe(true)\n          expect(diagnostic.severity != DiagnosticSeverity.Information).toBe(true)\n        }\n      }\n      helper.updateConfiguration('diagnostic.level', 'hint')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send ale diagnostic items","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":465,"column":40},"line":465,"code":"    it('should send ale diagnostic items', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('displayByAle', true)\n      let content = `\n    function! MockAleResults(bufnr, collection, items)\n      let g:collection = a:collection\n      let g:items = a:items\n    endfunction\n    `\n      let file = await createTmpFile(content)\n      await nvim.command(`source ${file}`)\n      await createDocument()\n      await helper.wait(50)\n      let items = await nvim.getVar('items') as any[]\n      expect(Array.isArray(items)).toBe(true)\n      expect(items.length).toBeGreaterThan(0)\n      await nvim.command('bd!')\n      await helper.wait(50)\n      items = await nvim.getVar('items') as any[]\n      expect(items).toEqual([])\n      config.update('displayByAle', false)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get severity level","suites":["diagnostic manager","severityLevel & getNameFromSeverity"],"updatePoint":{"line":490,"column":33},"line":490,"code":"    it('should get severity level', () => {\n      expect(severityLevel('hint')).toBe(DiagnosticSeverity.Hint)\n      expect(severityLevel('error')).toBe(DiagnosticSeverity.Error)\n      expect(severityLevel('warning')).toBe(DiagnosticSeverity.Warning)\n      expect(severityLevel('information')).toBe(DiagnosticSeverity.Information)\n      expect(severityLevel('')).toBe(DiagnosticSeverity.Hint)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get severity name","suites":["diagnostic manager","severityLevel & getNameFromSeverity"],"updatePoint":{"line":498,"column":32},"line":498,"code":"    it('should get severity name', () => {\n      expect(getNameFromSeverity(null as any)).toBe('CocError')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle diagnostics for buffer","suites":["diagnostic manager","toggleDiagnosticBuffer"],"updatePoint":{"line":504,"column":44},"line":504,"code":"    it('should toggle diagnostics for buffer', async () => {\n      let doc = await createDocument()\n      // required to wait refresh finish\n      await helper.wait(50)\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n      await helper.wait(50)\n      let buf = nvim.createBuffer(doc.bufnr)\n      let res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res == null).toBe(true)\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n      await helper.wait(50)\n      res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res.error).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh by bufnr","suites":["diagnostic manager","refresh"],"updatePoint":{"line":529,"column":31},"line":529,"code":"    it('should refresh by bufnr', async () => {\n      let doc = await createDocument()\n      let buf = nvim.createBuffer(doc.bufnr)\n      let res = await buf.getVar('coc_diagnostic_info') as any\n      // should not refresh\n      expect(res == null).toBe(true)\n      manager.refresh(doc.bufnr)\n      await helper.wait(100)\n      res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res?.error).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh all buffers","suites":["diagnostic manager","refresh"],"updatePoint":{"line":541,"column":34},"line":541,"code":"    it('should refresh all buffers', async () => {\n      let one = await helper.createDocument('one')\n      let two = await helper.createDocument('two')\n      let collection = manager.create('tmp')\n      collection.set([[one.uri, [createDiagnostic('Error one')]], [two.uri, [createDiagnostic('Error two')]]])\n      manager.refresh()\n      await helper.wait(50)\n      for (let bufnr of [one.bufnr, two.bufnr]) {\n        let buf = nvim.createBuffer(bufnr)\n        let res = await buf.getVar('coc_diagnostic_info') as any\n        expect(res?.error).toBe(1)\n      }\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog","suites":["Dialog module"],"updatePoint":{"line":21,"column":24},"line":21,"code":"  it('should show dialog', async () => {\n    let dialog = new Dialog(nvim, { content: '' })\n    await dialog.show({})\n    let winid = await dialog.winid\n    let win = nvim.createWindow(winid)\n    let width = await win.width\n    expect(width).toBe(4)\n    await nvim.call('coc#float#close', [winid])\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke callback with index -1","suites":["Dialog module"],"updatePoint":{"line":31,"column":42},"line":31,"code":"  it('should invoke callback with index -1', async () => {\n    let callback = jest.fn()\n    let dialog = new Dialog(nvim, { content: '', callback })\n    await dialog.show({})\n    let winid = await dialog.winid\n    await nvim.call('coc#float#close', [winid])\n    await helper.wait(50)\n    expect(callback).toHaveBeenCalledWith(-1)\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke callback on click","suites":["Dialog module"],"updatePoint":{"line":41,"column":37},"line":41,"code":"  it('should invoke callback on click', async () => {\n    let callback = jest.fn()\n    let buttons: DialogButton[] = [{\n      index: 0,\n      text: 'yes'\n    }, {\n      index: 1,\n      text: 'no'\n    }]\n    let dialog = new Dialog(nvim, { content: '', buttons, callback })\n    await dialog.show({})\n    let winid = await dialog.winid\n    let btnwin = await nvim.call('coc#float#get_related', [winid, 'buttons'])\n    await nvim.call('win_gotoid', [btnwin])\n    await nvim.call('cursor', [2, 1])\n    await nvim.call('coc#float#nvim_float_click', [])\n    await helper.wait(50)\n    expect(callback).toHaveBeenCalledWith(0)\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff changed lines","suites":["diff lines"],"updatePoint":{"line":11,"column":31},"line":11,"code":"  it('should diff changed lines', () => {\n    let res = diff('a\\n', 'b\\n')\n    expect(res).toEqual({ start: 0, end: 1, replacement: ['b'] })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff added lines","suites":["diff lines"],"updatePoint":{"line":16,"column":29},"line":16,"code":"  it('should diff added lines', () => {\n    let res = diff('a\\n', 'a\\nb\\n')\n    expect(res).toEqual({\n      start: 1,\n      end: 1,\n      replacement: ['b']\n    })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff remove lines","suites":["diff lines"],"updatePoint":{"line":25,"column":30},"line":25,"code":"  it('should diff remove lines', () => {\n    let res = diff('a\\n\\n', 'a\\n')\n    expect(res).toEqual({\n      start: 1,\n      end: 2,\n      replacement: []\n    })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff remove multiple lines","suites":["diff lines"],"updatePoint":{"line":34,"column":39},"line":34,"code":"  it('should diff remove multiple lines', () => {\n    let res = diff('a\\n\\n\\n', 'a\\n')\n    expect(res).toEqual({\n      start: 1,\n      end: 3,\n      replacement: []\n    })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff removed line","suites":["diff lines"],"updatePoint":{"line":43,"column":30},"line":43,"code":"  it('should diff removed line', () => {\n    let res = diff('a\\n\\n\\nb', 'a\\n\\nb')\n    expect(res).toEqual({\n      start: 2,\n      end: 3,\n      replacement: []\n    })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reduce changed lines","suites":["diff lines"],"updatePoint":{"line":52,"column":33},"line":52,"code":"  it('should reduce changed lines', async () => {\n    let res = diffLines(['a', 'b', 'c'], ['a', 'b', 'c', 'd'], 0)\n    expect(res).toEqual({\n      start: 3,\n      end: 3,\n      replacement: ['d']\n    })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should patch line","suites":["patch line"],"updatePoint":{"line":63,"column":23},"line":63,"code":"  it('should patch line', () => {\n    let res = patchLine('foo', 'bar foo bar')\n    expect(res.length).toBe(7)\n    expect(res).toBe('    foo')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for comments ","suites":["should get text edits"],"updatePoint":{"line":85,"column":35},"line":85,"code":"  it('should get diff for comments ', async () => {\n    let oldStr = '/*\\n *\\n * \\n'\n    let newStr = '/*\\n *\\n *\\n * \\n'\n    let doc = TextDocument.create('untitled://1', 'markdown', 0, oldStr)\n    let change = getChange(doc.getText(), newStr, 1)\n    let start = doc.positionAt(change.start)\n    let end = doc.positionAt(change.end)\n    let edit: TextEdit = {\n      range: { start, end },\n      newText: change.newText\n    }\n    let res = TextDocument.applyEdits(doc, [edit])\n    expect(res).toBe(newStr)\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null for same content","suites":["should get text edits"],"updatePoint":{"line":100,"column":41},"line":100,"code":"  it('should return null for same content', () => {\n    let change = getChange('', '')\n    expect(change).toBeNull()\n    change = getChange('abc', 'abc')\n    expect(change).toBeNull()\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added","suites":["should get text edits"],"updatePoint":{"line":107,"column":31},"line":107,"code":"  it('should get diff for added', () => {\n    applyEdits('1\\n2', '1\\n2\\n3\\n4')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #0","suites":["should get text edits"],"updatePoint":{"line":111,"column":34},"line":111,"code":"  it('should get diff for added #0', () => {\n    applyEdits('\\n\\n', '\\n\\n\\n')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #1","suites":["should get text edits"],"updatePoint":{"line":115,"column":34},"line":115,"code":"  it('should get diff for added #1', () => {\n    applyEdits('1\\n2\\n3', '5\\n1\\n2\\n3')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #2","suites":["should get text edits"],"updatePoint":{"line":119,"column":34},"line":119,"code":"  it('should get diff for added #2', () => {\n    applyEdits('1\\n2\\n3', '1\\n2\\n4\\n3')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #3","suites":["should get text edits"],"updatePoint":{"line":123,"column":34},"line":123,"code":"  it('should get diff for added #3', () => {\n    applyEdits('1\\n2\\n3', '4\\n1\\n2\\n3\\n5')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #4","suites":["should get text edits"],"updatePoint":{"line":127,"column":34},"line":127,"code":"  it('should get diff for added #4', () => {\n    applyEdits(' ', '   ')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for replace","suites":["should get text edits"],"updatePoint":{"line":131,"column":33},"line":131,"code":"  it('should get diff for replace', () => {\n    applyEdits('1\\n2\\n3\\n4\\n5', '1\\n5\\n3\\n6\\n7')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for replace #1","suites":["should get text edits"],"updatePoint":{"line":135,"column":36},"line":135,"code":"  it('should get diff for replace #1', () => {\n    applyEdits('1\\n2\\n3\\n4\\n5', '1\\n5\\n3\\n6\\n7')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #0","suites":["should get text edits"],"updatePoint":{"line":139,"column":35},"line":139,"code":"  it('should get diff for remove #0', () => {\n    applyEdits('1\\n2\\n3\\n4', '1\\n4')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #1","suites":["should get text edits"],"updatePoint":{"line":143,"column":35},"line":143,"code":"  it('should get diff for remove #1', () => {\n    applyEdits('1\\n2\\n3\\n4', '1')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #2","suites":["should get text edits"],"updatePoint":{"line":147,"column":35},"line":147,"code":"  it('should get diff for remove #2', () => {\n    applyEdits('  ', ' ')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer cursor position for change","suites":["should get text edits"],"updatePoint":{"line":151,"column":46},"line":151,"code":"  it('should prefer cursor position for change', async () => {\n    let res = getChange(' int n', ' n', 0)\n    expect(res).toEqual({ start: 1, end: 5, newText: '' })\n    res = getChange(' int n', ' n')\n    expect(res).toEqual({ start: 0, end: 4, newText: '' })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer next line for change","suites":["should get text edits"],"updatePoint":{"line":158,"column":40},"line":158,"code":"  it('should prefer next line for change', async () => {\n    let res = getChange('a\\nb', 'a\\nc\\nb')\n    expect(res).toEqual({ start: 2, end: 2, newText: 'c\\n' })\n    applyEdits('a\\nb', 'a\\nc\\nb')\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer previous line for change","suites":["should get text edits"],"updatePoint":{"line":164,"column":44},"line":164,"code":"  it('should prefer previous line for change', async () => {\n    let res = getChange('\\n\\na', '\\na')\n    expect(res).toEqual({ start: 0, end: 1, newText: '' })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider cursor","suites":["should get text edits"],"updatePoint":{"line":169,"column":28},"line":169,"code":"  it('should consider cursor', () => {\n    let res = getChange('\\n\\n\\n', '\\n\\n\\n\\n', 1)\n    expect(res).toEqual({ start: 2, end: 2, newText: '\\n' })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get minimal diff","suites":["should get text edits"],"updatePoint":{"line":174,"column":29},"line":174,"code":"  it('should get minimal diff', () => {\n    let res = getChange('foo\\nbar', 'fab\\nbar', 2)\n    expect(res).toEqual({ start: 1, end: 3, newText: 'ab' })\n  })","file":"modules/diff.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse iskeyword","suites":["properties"],"updatePoint":{"line":30,"column":28},"line":30,"code":"  it('should parse iskeyword', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('foo bar')\n    doc.forceSync()\n    let words = doc.words\n    expect(words).toEqual(['foo', 'bar'])\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits","suites":["properties"],"updatePoint":{"line":38,"column":23},"line":38,"code":"  it('should applyEdits', async () => {\n    let doc = await helper.createDocument()\n    let edits: TextEdit[] = []\n    edits.push({\n      range: Range.create(0, 0, 0, 0),\n      newText: 'a\\n'\n    })\n    edits.push({\n      range: Range.create(0, 0, 0, 0),\n      newText: 'b\\n'\n    })\n    await doc.applyEdits(edits)\n    let content = doc.getDocumentContent()\n    expect(content).toBe('a\\nb\\n\\n')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with changed lines","suites":["properties"],"updatePoint":{"line":54,"column":42},"line":54,"code":"  it('should applyEdits with changed lines', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('a')\n    await doc.patchChange()\n    let edits: TextEdit[] = []\n    edits.push({\n      range: Range.create(0, 1, 0, 1),\n      newText: `\\n\\nd`\n    })\n    await doc.applyEdits(edits)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['a', '', 'd'])\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse iskeyword of character range","suites":["properties"],"updatePoint":{"line":68,"column":47},"line":68,"code":"  it('should parse iskeyword of character range', async () => {\n    await nvim.setOption('iskeyword', 'a-z,A-Z,48-57,_')\n    let doc = await helper.createDocument()\n    let opt = await nvim.getOption('iskeyword')\n    expect(opt).toBe('a-z,A-Z,48-57,_')\n    await nvim.setLine('foo bar')\n    doc.forceSync()\n    await helper.wait(100)\n    let words = doc.words\n    expect(words).toEqual(['foo', 'bar'])\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get word range","suites":["properties"],"updatePoint":{"line":80,"column":27},"line":80,"code":"  it('should get word range', async () => {\n    await helper.createDocument()\n    await nvim.setLine('foo bar')\n    await helper.wait(30)\n    let doc = await workspace.document\n    let range = doc.getWordRangeAtPosition({ line: 0, character: 0 })\n    expect(range).toEqual(Range.create(0, 0, 0, 3))\n    range = doc.getWordRangeAtPosition({ line: 0, character: 3 })\n    expect(range).toBeNull()\n    range = doc.getWordRangeAtPosition({ line: 0, character: 4 })\n    expect(range).toEqual(Range.create(0, 4, 0, 7))\n    range = doc.getWordRangeAtPosition({ line: 0, character: 7 })\n    expect(range).toBeNull()\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get symbol ranges","suites":["properties"],"updatePoint":{"line":95,"column":30},"line":95,"code":"  it('should get symbol ranges', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('foo bar foo')\n    let ranges = doc.getSymbolRanges('foo')\n    expect(ranges.length).toBe(2)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get localify bonus","suites":["properties"],"updatePoint":{"line":102,"column":31},"line":102,"code":"  it('should get localify bonus', async () => {\n    let doc = await helper.createDocument()\n    let { buffer } = doc\n    await buffer.setLines(['context content clearTimeout', '', 'product confirm'],\n      { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(100)\n    let pos: Position = { line: 1, character: 0 }\n    let res = doc.getLocalifyBonus(pos, pos)\n    expect(res.has('confirm')).toBe(true)\n    expect(res.has('clearTimeout')).toBe(true)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current line","suites":["properties"],"updatePoint":{"line":114,"column":29},"line":114,"code":"  it('should get current line', async () => {\n    let doc = await helper.createDocument()\n    let { buffer } = doc\n    await buffer.setLines(['first line', 'second line'],\n      { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    let line = doc.getline(1, true)\n    expect(line).toBe('second line')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get cached line","suites":["properties"],"updatePoint":{"line":124,"column":28},"line":124,"code":"  it('should get cached line', async () => {\n    let doc = await helper.createDocument()\n    let { buffer } = doc\n    await buffer.setLines(['first line', 'second line'],\n      { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    doc.forceSync()\n    let line = doc.getline(0, false)\n    expect(line).toBe('first line')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get variable form buffer","suites":["properties"],"updatePoint":{"line":135,"column":37},"line":135,"code":"  it('should get variable form buffer', async () => {\n    await nvim.command('autocmd BufNewFile,BufRead * let b:coc_enabled = 1')\n    let doc = await helper.createDocument()\n    let val = doc.getVar<number>('enabled')\n    expect(val).toBe(1)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach change events","suites":["properties"],"updatePoint":{"line":142,"column":33},"line":142,"code":"  it('should attach change events', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('abc')\n    await helper.wait(50)\n    let content = doc.getDocumentContent()\n    expect(content.indexOf('abc')).toBe(0)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not attach change events when b:coc_enabled is false","suites":["properties"],"updatePoint":{"line":150,"column":65},"line":150,"code":"  it('should not attach change events when b:coc_enabled is false', async () => {\n    await nvim.command('autocmd BufNewFile,BufRead *.dis let b:coc_enabled = 0')\n    let doc = await helper.createDocument('a.dis')\n    let val = doc.getVar<number>('enabled', 0)\n    expect(val).toBe(0)\n    await nvim.setLine('abc')\n    await helper.wait(50)\n    let content = doc.getDocumentContent()\n    expect(content.indexOf('abc')).toBe(-1)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get lineCount, previewwindow, winid","suites":["properties"],"updatePoint":{"line":161,"column":48},"line":161,"code":"  it('should get lineCount, previewwindow, winid', async () => {\n    let doc = await helper.createDocument()\n    let { lineCount, winid, previewwindow } = doc\n    expect(lineCount).toBe(1)\n    expect(winid != -1).toBe(true)\n    expect(previewwindow).toBe(false)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set filetype","suites":["properties"],"updatePoint":{"line":169,"column":25},"line":169,"code":"  it('should set filetype', async () => {\n    let doc = await helper.createDocument()\n    doc.setFiletype('javascript.jsx')\n    expect(doc.filetype).toBe('javascriptreact')\n    doc.setFiletype('typescript.jsx')\n    expect(doc.filetype).toBe('typescriptreact')\n    doc.setFiletype('typescript.tsx')\n    expect(doc.filetype).toBe('typescriptreact')\n    doc.setFiletype('tex')\n    expect(doc.filetype).toBe('latex')\n    doc.setFiletype('foo')\n    expect(doc.filetype).toBe('foo')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize on lines change","suites":["synchronize"],"updatePoint":{"line":185,"column":40},"line":185,"code":"  it('should synchronize on lines change', async () => {\n    let document = await helper.createDocument()\n    let doc = TextDocument.create('untitled:1', 'txt', 1, document.getDocumentContent())\n    let disposables = []\n    document.onDocumentChange(e => {\n      TextDocument.update(doc, e.contentChanges, 2)\n    }, null, disposables)\n    // document.on\n    await nvim.setLine('abc')\n    document.forceSync()\n    expect(doc.getText()).toBe('abc\\n')\n    disposeAll(disposables)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize changes after applyEdits","suites":["synchronize"],"updatePoint":{"line":199,"column":49},"line":199,"code":"  it('should synchronize changes after applyEdits', async () => {\n    let document = await helper.createDocument()\n    let doc = TextDocument.create('untitled:1', 'txt', 1, document.getDocumentContent())\n    let disposables = []\n    document.onDocumentChange(e => {\n      TextDocument.update(doc, e.contentChanges, e.textDocument.version)\n    }, null, disposables)\n    await nvim.setLine('abc')\n    await document.patchChange()\n    await document.applyEdits([TextEdit.insert({ line: 0, character: 0 }, 'd')])\n    expect(doc.getText()).toBe('dabc\\n')\n    disposeAll(disposables)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after make changes","suites":["recreate"],"updatePoint":{"line":245,"column":43},"line":245,"code":"  it('should synchronize after make changes', async () => {\n    await assertDocument(async () => {\n      await nvim.call('setline', [1, 'a'])\n      await nvim.call('setline', [2, 'b'])\n    })\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after edit","suites":["recreate"],"updatePoint":{"line":252,"column":35},"line":252,"code":"  it('should synchronize after edit', async () => {\n    await assertDocument(async doc => {\n      let fsPath = URI.parse(doc.uri).fsPath\n      fs.writeFileSync(fsPath, '{\\n}\\n', 'utf8')\n      await nvim.command('edit')\n      await helper.wait(50)\n      await nvim.call('deletebufline', [doc.bufnr, 1])\n      doc = await workspace.document\n      let content = doc.getDocumentContent()\n      expect(content).toBe('}\\n')\n    })\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after force edit","suites":["recreate"],"updatePoint":{"line":265,"column":41},"line":265,"code":"  it('should synchronize after force edit', async () => {\n    await assertDocument(async doc => {\n      let fsPath = URI.parse(doc.uri).fsPath\n      fs.writeFileSync(fsPath, '{\\n}\\n', 'utf8')\n      await nvim.command('edit')\n      await helper.wait(50)\n      await nvim.call('deletebufline', [doc.bufnr, 1])\n      doc = await workspace.document\n      let content = doc.getDocumentContent()\n      expect(content).toBe('}\\n')\n    })\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #1","suites":["getEndOffset"],"updatePoint":{"line":280,"column":28},"line":280,"code":"  it('should getEndOffset #1', async () => {\n    let doc = await helper.createDocument()\n    await doc.buffer.setLines(['', ''], { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    let end = doc.getEndOffset(1, 1, false)\n    expect(end).toBe(2)\n    end = doc.getEndOffset(2, 1, false)\n    expect(end).toBe(1)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #2","suites":["getEndOffset"],"updatePoint":{"line":290,"column":28},"line":290,"code":"  it('should getEndOffset #2', async () => {\n    let doc = await helper.createDocument()\n    await doc.buffer.setLines(['a', ''], { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    let end = doc.getEndOffset(1, 1, false)\n    expect(end).toBe(2)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #3","suites":["getEndOffset"],"updatePoint":{"line":298,"column":28},"line":298,"code":"  it('should getEndOffset #3', async () => {\n    let doc = await helper.createDocument()\n    await doc.buffer.setLines(['a'], { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    let end = doc.getEndOffset(1, 2, false)\n    expect(end).toBe(1)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #4","suites":["getEndOffset"],"updatePoint":{"line":306,"column":28},"line":306,"code":"  it('should getEndOffset #4', async () => {\n    let doc = await helper.createDocument()\n    await doc.buffer.setLines(['', ''], { start: 0, end: -1, strictIndexing: false })\n    await helper.wait(30)\n    let end = doc.getEndOffset(1, 1, false)\n    expect(end).toBe(3)\n    end = doc.getEndOffset(1, 1, true)\n    expect(end).toBe(4)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize content added","suites":["applyEdits"],"updatePoint":{"line":318,"column":38},"line":318,"code":"  it('should synchronize content added', async () => {\n    let doc = await helper.createDocument()\n    let buffer = doc.buffer\n    await doc.buffer.setLines(['foo f'], { start: 0, end: -1, strictIndexing: false })\n    await doc.synchronize()\n    await nvim.command('normal! gg^2l')\n    await nvim.input('a')\n    await buffer.detach()\n    await nvim.input('r')\n    await doc.applyEdits([{\n      range: Range.create(0, 0, 0, 5),\n      newText: 'foo foo'\n    }])\n    await helper.wait(100)\n    let line = await nvim.line\n    expect(line).toBe('foor foo')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize content delete","suites":["applyEdits"],"updatePoint":{"line":336,"column":39},"line":336,"code":"  it('should synchronize content delete', async () => {\n    let doc = await helper.createDocument()\n    let buffer = doc.buffer\n    await doc.buffer.setLines(['foo f'], { start: 0, end: -1, strictIndexing: false })\n    await doc.synchronize()\n    await nvim.command('normal! gg^2l')\n    await nvim.input('a')\n    await buffer.detach()\n    await nvim.input('<backspace>')\n    await doc.applyEdits([{\n      range: Range.create(0, 0, 0, 5),\n      newText: 'foo foo'\n    }])\n    await helper.wait(100)\n    let line = await nvim.line\n    expect(line).toBe('fo foo')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlights to document","suites":["highlights"],"updatePoint":{"line":356,"column":39},"line":356,"code":"  it('should add highlights to document', async () => {\n    await helper.createDocument()\n    let buf = await nvim.buffer\n    await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n    let ranges = [\n      Range.create(0, 0, 0, 2),\n      Range.create(1, 0, 1, 3)\n    ]\n    let ns = await nvim.createNamespace('coc-highlight')\n    nvim.pauseNotification()\n    buf.highlightRanges('highlight', 'Search', ranges)\n    await nvim.resumeNotification()\n    let markers = await helper.getMarkers(buf.id, ns)\n    expect(markers.length).toBe(2)\n    nvim.pauseNotification()\n    buf.clearNamespace('highlight')\n    await nvim.resumeNotification()\n    markers = await helper.getMarkers(buf.id, ns)\n    expect(markers.length).toBe(0)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add/clear highlights of current window","suites":["highlights"],"updatePoint":{"line":377,"column":51},"line":377,"code":"  it('should add/clear highlights of current window', async () => {\n    await helper.createDocument()\n    let buf = await nvim.buffer\n    await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n    let win = await nvim.window\n    let ranges = [\n      Range.create(0, 0, 0, 2),\n      Range.create(1, 0, 1, 3)\n    ]\n    let res = await win.highlightRanges('Search', ranges)\n    expect(res.length).toBe(2)\n    let matches = await nvim.call('getmatches', [win.id])\n    expect(matches.length).toBe(2)\n    nvim.pauseNotification()\n    win.clearMatchGroup('Search')\n    await nvim.resumeNotification()\n    matches = await nvim.call('getmatches', [win.id])\n    expect(matches.length).toBe(0)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear matches by ids","suites":["highlights"],"updatePoint":{"line":397,"column":33},"line":397,"code":"  it('should clear matches by ids', async () => {\n    await helper.createDocument()\n    let buf = await nvim.buffer\n    await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n    let win = await nvim.window\n    let ranges = [\n      Range.create(0, 0, 0, 2),\n      Range.create(1, 0, 1, 3)\n    ]\n    let ids = await win.highlightRanges('Search', ranges)\n    nvim.pauseNotification()\n    win.clearMatches(ids)\n    await nvim.resumeNotification()\n    let matches = await nvim.call('getmatches', [win.id])\n    expect(matches.length).toBe(0)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register single handler","suites":["register handler"],"updatePoint":{"line":24,"column":36},"line":24,"code":"  it('should register single handler', async () => {\n    let fn = jest.fn()\n    let obj = {}\n    let disposable = events.on('BufEnter', fn, obj)\n    disposables.push(disposable)\n    await events.fire('BufEnter', ['a', 'b'])\n    expect(fn).toBeCalledWith('a', 'b')\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register multiple events","suites":["register handler"],"updatePoint":{"line":33,"column":37},"line":33,"code":"  it('should register multiple events', async () => {\n    let fn = jest.fn()\n    let disposable = events.on(['TaskExit', 'TaskStderr'], fn)\n    disposables.push(disposable)\n    await events.fire('TaskExit', [])\n    await events.fire('TaskStderr', [])\n    expect(fn).toBeCalledTimes(2)\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve after timeout","suites":["register handler"],"updatePoint":{"line":42,"column":34},"line":42,"code":"  it('should resolve after timeout', async () => {\n    let fn = (): Promise<void> => new Promise(resolve => {\n      setTimeout(() => {\n        resolve()\n      }, 100)\n    })\n    let disposable = events.on('FocusGained', fn, {})\n    disposables.push(disposable)\n    let ts = Date.now()\n    await events.fire('FocusGained', [])\n    expect(Date.now() - ts >= 100).toBe(true)\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit TextInsert after TextChangedI","suites":["register handler"],"updatePoint":{"line":55,"column":47},"line":55,"code":"  it('should emit TextInsert after TextChangedI', async () => {\n    let arr: string[] = []\n    events.on('TextInsert', () => {\n      arr.push('insert')\n    }, null, disposables)\n    events.on('TextChangedI', () => {\n      arr.push('change')\n    }, null, disposables)\n    await nvim.input('ia')\n    await helper.wait(300)\n    expect(arr).toEqual(['change', 'insert'])\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load global extensions","suites":["extensions"],"updatePoint":{"line":23,"column":35},"line":23,"code":"  it('should load global extensions', async () => {\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter global extensions","suites":["extensions"],"updatePoint":{"line":28,"column":37},"line":28,"code":"  it('should filter global extensions', async () => {\n    let res = extensions.filterGlobalExtensions(['test', 'foo'])\n    expect(res).toEqual(['foo'])\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load local extensions from &rtp","suites":["extensions"],"updatePoint":{"line":33,"column":44},"line":33,"code":"  it('should load local extensions from &rtp', async () => {\n    let folder = path.resolve(__dirname, '../extensions/vim/local')\n    await nvim.command(`set runtimepath^=${folder}`)\n    await helper.wait(300)\n    let stat = extensions.getExtensionState('local')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall npm extension","suites":["extensions"],"updatePoint":{"line":41,"column":44},"line":41,"code":"  it('should install/uninstall npm extension', async () => {\n    await extensions.installExtensions(['coc-omni'])\n    let folder = path.join(__dirname, '../extensions/coc-omni')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await helper.wait(200)\n    await extensions.uninstallExtension(['coc-omni'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall extension by url","suites":["extensions"],"updatePoint":{"line":52,"column":47},"line":52,"code":"  it('should install/uninstall extension by url', async () => {\n    await extensions.installExtensions(['https://github.com/hollowtree/vscode-vue-snippets'])\n    let folder = path.join(__dirname, '../extensions/vue-snippets')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await extensions.uninstallExtension(['vue-snippets'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall extension by url with branch","suites":["extensions"],"updatePoint":{"line":62,"column":59},"line":62,"code":"  it('should install/uninstall extension by url with branch', async () => {\n    await extensions.installExtensions(['https://github.com/sdras/vue-vscode-snippets@main'])\n    let folder = path.join(__dirname, '../extensions/vue-vscode-snippets')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await extensions.uninstallExtension(['vue-vscode-snippets'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse extension info","suites":["extensions"],"updatePoint":{"line":72,"column":33},"line":72,"code":"  it('should parse extension info', () => {\n    const installer = extensions.installer\n    const scoped = installer('@yaegassy/coc-intelephense').info\n    expect(scoped.name).toBe('@yaegassy/coc-intelephense')\n\n    const scopedVer = installer('@yaegassy/coc-intelephense@0.2.1').info\n    expect(scopedVer.name).toBe('@yaegassy/coc-intelephense')\n    expect(scopedVer.version).toBe('0.2.1')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all extensions","suites":["extensions"],"updatePoint":{"line":82,"column":31},"line":82,"code":"  it('should get all extensions', () => {\n    let list = extensions.all\n    expect(Array.isArray(list)).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extensions stat","suites":["extensions"],"updatePoint":{"line":87,"column":32},"line":87,"code":"  it('should get extensions stat', async () => {\n    let stats = await extensions.getExtensionStates()\n    expect(stats.length).toBeGreaterThan(0)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle extension","suites":["extensions"],"updatePoint":{"line":92,"column":29},"line":92,"code":"  it('should toggle extension', async () => {\n    await extensions.toggleExtension('test')\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('disabled')\n    await extensions.toggleExtension('test')\n    stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload extension","suites":["extensions"],"updatePoint":{"line":101,"column":29},"line":101,"code":"  it('should reload extension', async () => {\n    await extensions.reloadExtension('test')\n    await helper.wait(100)\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should has extension","suites":["extensions"],"updatePoint":{"line":108,"column":26},"line":108,"code":"  it('should has extension', () => {\n    let res = extensions.has('test')\n    expect(res).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be activated","suites":["extensions"],"updatePoint":{"line":113,"column":25},"line":113,"code":"  it('should be activated', async () => {\n    let res = extensions.has('test')\n    expect(res).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate & deactivate extension","suites":["extensions"],"updatePoint":{"line":118,"column":44},"line":118,"code":"  it('should activate & deactivate extension', async () => {\n    await extensions.deactivate('test')\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('loaded')\n    await extensions.activate('test')\n    stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call extension API","suites":["extensions"],"updatePoint":{"line":127,"column":31},"line":127,"code":"  it('should call extension API', async () => {\n    let res = await extensions.call('test', 'echo', ['5'])\n    expect(res).toBe('5')\n    let p: string = await extensions.call('test', 'asAbsolutePath', ['..'])\n    expect(p.endsWith('extensions')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extension API","suites":["extensions"],"updatePoint":{"line":134,"column":30},"line":134,"code":"  it('should get extension API', () => {\n    let res = extensions.getExtensionApi('test') as any\n    expect(typeof res.echo).toBe('function')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load single file extension","suites":["extensions"],"updatePoint":{"line":139,"column":39},"line":139,"code":"  it('should load single file extension', async () => {\n    let filepath = path.join(__dirname, '../extensions/root.js')\n    await extensions.loadExtensionFile(filepath)\n    expect(extensions.has('single-root')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on language","suites":["extensions active events"],"updatePoint":{"line":173,"column":33},"line":173,"code":"  it('should activate on language', async () => {\n    let ext = createExtension('onLanguage:javascript')\n    expect(ext.isActive).toBe(false)\n    await nvim.command('edit /tmp/a.js')\n    await helper.wait(300)\n    expect(ext.isActive).toBe(true)\n    ext = createExtension('onLanguage:javascript')\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on command","suites":["extensions active events"],"updatePoint":{"line":183,"column":32},"line":183,"code":"  it('should activate on command', async () => {\n    let ext = createExtension('onCommand:test.echo')\n    await events.fire('Command', ['test.echo'])\n    await helper.wait(30)\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on workspace contains","suites":["extensions active events"],"updatePoint":{"line":190,"column":43},"line":190,"code":"  it('should activate on workspace contains', async () => {\n    let ext = createExtension('workspaceContains:package.json')\n    let root = path.resolve(__dirname, '../../..')\n    await nvim.command(`edit ${path.join(root, 'file.js')}`)\n    await helper.wait(100)\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on file system","suites":["extensions active events"],"updatePoint":{"line":198,"column":36},"line":198,"code":"  it('should activate on file system', async () => {\n    let ext = createExtension('onFileSystem:zip')\n    await nvim.command('edit zip:///a')\n    await helper.wait(30)\n    expect(ext.isActive).toBe(true)\n    ext = createExtension('onFileSystem:zip')\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extensionPath","suites":["extension properties"],"updatePoint":{"line":209,"column":30},"line":209,"code":"  it('should get extensionPath', () => {\n    let ext = extensions.getExtension('test')\n    let p = ext.extension.extensionPath\n    expect(p.endsWith('test')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate","suites":["extension properties"],"updatePoint":{"line":215,"column":23},"line":215,"code":"  it('should deactivate', async () => {\n    let ext = extensions.getExtension('test')\n    await ext.deactivate()\n    expect(ext.extension.isActive).toBe(false)\n    await extensions.activate('test')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fetch json","suites":["fetch"],"updatePoint":{"line":24,"column":23},"line":24,"code":"  it('should fetch json', async () => {\n    let res = await fetch('https://nodejs.org/dist/index.json')\n    expect(Array.isArray(res)).toBe(true)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fetch buffer","suites":["fetch"],"updatePoint":{"line":29,"column":25},"line":29,"code":"  it('should fetch buffer', async () => {\n    let res = await fetch('https://www.npmjs.com/', { buffer: true })\n    expect(Buffer.isBuffer(res)).toBe(true)\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw on request error","suites":["fetch"],"updatePoint":{"line":34,"column":35},"line":34,"code":"  it('should throw on request error', async () => {\n    let err\n    try {\n      await fetch('http://not_exists_org')\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report valid proxy","suites":["fetch"],"updatePoint":{"line":44,"column":31},"line":44,"code":"  it('should report valid proxy', async () => {\n    let agent = getAgent(parse('http://google.com'), { proxyUrl: 'domain.com:1234' })\n    expect(agent).toBe(null)\n\n    agent = getAgent(parse('http://google.com'), { proxyUrl: 'https://domain.com:1234' })\n    let proxy = (agent as any).proxy\n    expect(proxy.host).toBe('domain.com')\n    expect(proxy.port).toBe(1234)\n\n    agent = getAgent(parse('http://google.com'), { proxyUrl: 'http://user:pass@domain.com:1234' })\n    proxy = (agent as any).proxy\n    expect(proxy.host).toBe('domain.com')\n    expect(proxy.port).toBe(1234)\n    expect(proxy.auth).toBe('user:pass')\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should download binary file","suites":["download"],"updatePoint":{"line":62,"column":33},"line":62,"code":"  it('should download binary file', async () => {\n    let url = 'https://registry.npmjs.org/coc-pairs/-/coc-pairs-1.2.13.tgz'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    let res = await download(url, { dest: tmpFolder })\n    expect(fs.existsSync(res)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should download tgz","suites":["download"],"updatePoint":{"line":70,"column":25},"line":70,"code":"  it('should download tgz', async () => {\n    let url = 'https://registry.npmjs.org/coc-pairs/-/coc-pairs-1.2.13.tgz'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    await download(url, { dest: tmpFolder, extract: 'untar' })\n    let file = path.join(tmpFolder, 'package.json')\n    expect(fs.existsSync(file)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extract zip file","suites":["download"],"updatePoint":{"line":79,"column":29},"line":79,"code":"  it('should extract zip file', async () => {\n    let url = 'https://codeload.github.com/chemzqm/vimrc/zip/master'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    await download(url, { dest: tmpFolder, extract: 'unzip' })\n    let folder = path.join(tmpFolder, 'vimrc-master')\n    expect(fs.existsSync(folder)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 30000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show window","suites":["FloatFactory","show()"],"updatePoint":{"line":27,"column":26},"line":27,"code":"    it('should show window', async () => {\n      expect(floatFactory.window).toBe(null)\n      expect(floatFactory.buffer).toBe(null)\n      expect(floatFactory.bufnr).toBe(0)\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.show(docs)\n      expect(floatFactory.window).toBeDefined()\n      expect(floatFactory.buffer).toBeDefined()\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(1)\n      await floatFactory.show([{ filetype: 'txt', content: '' }])\n      expect(floatFactory.window).toBe(null)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create window","suites":["FloatFactory","show()"],"updatePoint":{"line":44,"column":28},"line":44,"code":"    it('should create window', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.create(docs)\n      expect(floatFactory.window).toBeDefined()\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should catch error on create","suites":["FloatFactory","show()"],"updatePoint":{"line":53,"column":36},"line":53,"code":"    it('should catch error on create', async () => {\n      let fn = floatFactory.unbind\n      floatFactory.unbind = () => {\n        throw new Error('bad')\n      }\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.show(docs)\n      floatFactory.unbind = fn\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('bad')\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show only one window","suites":["FloatFactory","show()"],"updatePoint":{"line":68,"column":35},"line":68,"code":"    it('should show only one window', async () => {\n      await helper.edit()\n      await nvim.setLine('foo')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await Promise.all([\n        floatFactory.show(docs),\n        floatFactory.show(docs)\n      ])\n      let count = 0\n      let wins = await nvim.windows\n      for (let win of wins) {\n        let isFloat = await win.getVar('float')\n        if (isFloat) count++\n      }\n      expect(count).toBe(1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close window when close called after create","suites":["FloatFactory","show()"],"updatePoint":{"line":88,"column":58},"line":88,"code":"    it('should close window when close called after create', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      let p = floatFactory.show(docs)\n      await helper.wait(1)\n      floatFactory.close()\n      await p\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(false)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create on visual mode","suites":["FloatFactory","show()"],"updatePoint":{"line":101,"column":40},"line":101,"code":"    it('should not create on visual mode', async () => {\n      await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await nvim.setLine('foo')\n      await nvim.command('normal! v$')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      await floatFactory.show(docs)\n      expect(floatFactory.window).toBe(null)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check retrigger","suites":["FloatFactory","checkRetrigger"],"updatePoint":{"line":116,"column":30},"line":116,"code":"    it('should check retrigger', async () => {\n      expect(floatFactory.checkRetrigger(99)).toBe(false)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      await floatFactory.show(docs)\n      expect(floatFactory.checkRetrigger(99)).toBe(false)\n      expect(floatFactory.checkRetrigger(bufnr)).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should config maxHeight and maxWidth","suites":["FloatFactory","options"],"updatePoint":{"line":130,"column":44},"line":130,"code":"    it('should config maxHeight and maxWidth', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(80) + '\\nbar',\n      }]\n      await floatFactory.show(docs, {\n        maxWidth: 20,\n        maxHeight: 1\n      })\n      let win = floatFactory.window\n      expect(win).toBeDefined()\n      let width = await win.width\n      let height = await win.height\n      expect(width).toBe(19)\n      expect(height).toBe(1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set border, title, highlight, borderhighlight, cursorline","suites":["FloatFactory","options"],"updatePoint":{"line":147,"column":72},"line":147,"code":"    it('should set border, title, highlight, borderhighlight, cursorline', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo\\nbar'\n      }]\n      await floatFactory.show(docs, {\n        border: [1, 1, 1, 1],\n        title: 'title',\n        highlight: 'Pmenu',\n        borderhighlight: 'MoreMsg',\n        cursorline: true\n      })\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect prefer top","suites":["FloatFactory","options"],"updatePoint":{"line":163,"column":33},"line":163,"code":"    it('should respect prefer top', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo\\nbar'\n      }]\n      await nvim.call('append', [1, ['', '', '']])\n      await nvim.command('exe 4')\n      await floatFactory.show(docs, { preferTop: true })\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let pos = await nvim.call('nvim_win_get_position', [win.id])\n      expect(pos).toEqual([1, 0])\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide on BufEnter","suites":["FloatFactory","events"],"updatePoint":{"line":179,"column":31},"line":179,"code":"    it('should hide on BufEnter', async () => {\n      await helper.edit()\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      await nvim.command(`edit foo`)\n      await helper.wait(50)\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(0)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide on CursorMoved","suites":["FloatFactory","events"],"updatePoint":{"line":192,"column":34},"line":192,"code":"    it('should hide on CursorMoved', async () => {\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(1)\n      await helper.wait(30)\n      await nvim.input('$')\n      await helper.wait(200)\n      hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(0)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not hide when cursor position not changed","suites":["FloatFactory","events"],"updatePoint":{"line":209,"column":56},"line":209,"code":"    it('should not hide when cursor position not changed', async () => {\n      await helper.edit()\n      await nvim.setLine('foo')\n      let cursor = await nvim.eval(\"[line('.'), col('.')]\")\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      await nvim.call('cursor', [1, 2])\n      await helper.wait(10)\n      await nvim.call('cursor', cursor)\n      await helper.wait(200)\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preserve float when autohide disable and not overlap with pum","suites":["FloatFactory","events"],"updatePoint":{"line":226,"column":76},"line":226,"code":"    it('should preserve float when autohide disable and not overlap with pum', async () => {\n      await helper.createDocument()\n      let buf = await nvim.buffer\n      await buf.setLines(['foo', '', '', '', 'f'], { start: 0, end: -1, strictIndexing: false })\n      await nvim.call('cursor', [5, 2])\n      await nvim.input('A')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs, {\n        preferTop: true,\n        autoHide: false\n      })\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(true)\n      await nvim.input('<C-n>')\n      await helper.wait(100)\n      let pumvisible = await helper.pumvisible()\n      expect(pumvisible).toBe(true)\n      activated = await floatFactory.activated()\n      expect(activated).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should allow select mode","suites":["FloatFactory","events"],"updatePoint":{"line":251,"column":30},"line":251,"code":"  it('should allow select mode', async () => {\n    await helper.createDocument()\n    await snippetManager.insertSnippet('${1:foo}')\n    let docs: Documentation[] = [{\n      filetype: 'markdown',\n      content: 'foo'\n    }]\n    await floatFactory.show(docs)\n    let { mode } = await nvim.mode\n    expect(mode).toBe('s')\n  })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get active state of window","suites":["FloatFactory","events"],"updatePoint":{"line":263,"column":39},"line":263,"code":"  it('should get active state of window', async () => {\n    let docs: Documentation[] = [{\n      filetype: 'markdown',\n      content: 'f'.repeat(81)\n    }]\n    await floatFactory.show(docs)\n    let res = await floatFactory.activated()\n    expect(res).toBe(true)\n    await nvim.call('coc#float#close_all')\n    res = await floatFactory.activated()\n    expect(res).toBe(false)\n  })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should udpate and get","suites":["Memos"],"updatePoint":{"line":19,"column":27},"line":19,"code":"  it('should udpate and get', async () => {\n    let memo = memos.createMemento('x')\n    await memo.update('foo.bar', 'memo')\n    let res = memo.get<string>('foo.bar')\n    expect(res).toBe('memo')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get value for key not exists","suites":["Memos"],"updatePoint":{"line":26,"column":41},"line":26,"code":"  it('should get value for key not exists', async () => {\n    let memo = memos.createMemento('y')\n    let res = memo.get<any>('xyz')\n    expect(res).toBeUndefined()\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use defaultValue when not exists","suites":["Memos"],"updatePoint":{"line":32,"column":45},"line":32,"code":"  it('should use defaultValue when not exists', async () => {\n    let memo = memos.createMemento('y')\n    let res = memo.get<any>('f.o.o', 'default')\n    expect(res).toBe('default')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update multiple values","suites":["Memos"],"updatePoint":{"line":38,"column":35},"line":38,"code":"  it('should update multiple values', async () => {\n    let memo = memos.createMemento('x')\n    await memo.update('foo', 'x')\n    await memo.update('bar', 'y')\n    expect(memo.get<string>('foo')).toBe('x')\n    expect(memo.get<string>('bar')).toBe('y')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["Menu"],"updatePoint":{"line":23,"column":28},"line":23,"code":"  it('should cancel by <esc>', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('<esc>')\n    let res = await p\n    expect(res).toBe(-1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by CR","suites":["Menu"],"updatePoint":{"line":37,"column":25},"line":37,"code":"  it('should select by CR', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('j')\n    await helper.wait(30)\n    await nvim.input('<cr>')\n    let res = await p\n    expect(res).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore invalid index","suites":["Menu"],"updatePoint":{"line":53,"column":33},"line":53,"code":"  it('should ignore invalid index', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('0')\n    await helper.wait(30)\n    let exists = await nvim.call('coc#float#has_float', [])\n    expect(exists).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by index number","suites":["Menu"],"updatePoint":{"line":63,"column":35},"line":63,"code":"  it('should select by index number', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('1')\n    let res = await p\n    expect(res).toBe(0)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should navigate by j, k, g & G","suites":["Menu"],"updatePoint":{"line":77,"column":36},"line":77,"code":"  it('should navigate by j, k, g & G', async () => {\n    menu = new Menu(nvim, { items: ['one', 'two', 'three'] })\n    await menu.show()\n    await helper.wait(50)\n    let id = await nvim.call('coc#float#get_float_win')\n    expect(id).toBeGreaterThan(0)\n    let win = nvim.createWindow(id)\n    await nvim.input('j')\n    await helper.wait(50)\n    let cursor = await win.cursor\n    expect(cursor[0]).toBe(2)\n    await nvim.input('k')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(1)\n    await nvim.input('G')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(3)\n    await nvim.input('g')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by numbers","suites":["Menu"],"updatePoint":{"line":102,"column":30},"line":102,"code":"  it('should select by numbers', async () => {\n    let selected: number\n    menu = new Menu(nvim, { items: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] })\n    await menu.show()\n    let promise = new Promise(resolve => {\n      menu.onDidClose(n => {\n        selected = n\n        resolve(undefined)\n      })\n    })\n    await helper.wait(50)\n    await nvim.input('1')\n    await helper.wait(50)\n    await nvim.input('0')\n    await promise\n    expect(selected).toBe(9)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load items","suites":["Mru"],"updatePoint":{"line":9,"column":23},"line":9,"code":"  it('should load items', async () => {\n    let mru = new Mru('test', root)\n    await mru.clean()\n    let res = await mru.load()\n    expect(res.length).toBe(0)\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add items","suites":["Mru"],"updatePoint":{"line":16,"column":22},"line":16,"code":"  it('should add items', async () => {\n    let mru = new Mru('test', root)\n    await mru.add('a')\n    await mru.add('b')\n    let res = await mru.load()\n    expect(res.length).toBe(2)\n    await mru.clean()\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove item","suites":["Mru"],"updatePoint":{"line":25,"column":24},"line":25,"code":"  it('should remove item', async () => {\n    let mru = new Mru('test', root)\n    await mru.add('a')\n    await mru.remove('a')\n    let res = await mru.load()\n    expect(res.length).toBe(0)\n    await mru.clean()\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.show(true)","suites":["OutputChannel"],"updatePoint":{"line":21,"column":32},"line":21,"code":"  test('outputChannel.show(true)', async () => {\n    await nvim.setLine('foo')\n    let c = new OutputChannel('0', nvim)\n    let bufnr = (await nvim.buffer).id\n    c.show(true)\n    await wait(100)\n    let nr = (await nvim.buffer).id\n    expect(bufnr).toBe(nr)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.show(false)","suites":["OutputChannel"],"updatePoint":{"line":31,"column":33},"line":31,"code":"  test('outputChannel.show(false)', async () => {\n    let c = new OutputChannel('1', nvim)\n    let bufnr = (await nvim.buffer).id\n    c.show()\n    await wait(100)\n    let nr = (await nvim.buffer).id\n    expect(bufnr).toBeLessThan(nr)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.appendLine()","suites":["OutputChannel"],"updatePoint":{"line":40,"column":34},"line":40,"code":"  test('outputChannel.appendLine()', async () => {\n    let c = new OutputChannel('2', nvim)\n    c.show()\n    await wait(100)\n    let buf = await nvim.buffer\n    c.appendLine('foo')\n    await wait(500)\n    let lines = await buf.lines\n    expect(lines).toContain('foo')\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.append()","suites":["OutputChannel"],"updatePoint":{"line":51,"column":30},"line":51,"code":"  test('outputChannel.append()', async () => {\n    let c = new OutputChannel('3', nvim)\n    c.show(false)\n    await wait(60)\n    c.append('foo')\n    c.append('bar')\n    await wait(500)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines.join('\\n')).toMatch('foo')\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.clear()","suites":["OutputChannel"],"updatePoint":{"line":63,"column":29},"line":63,"code":"  test('outputChannel.clear()', async () => {\n    let c = new OutputChannel('4', nvim)\n    c.show(false)\n    await wait(30)\n    let buf = await nvim.buffer\n    c.appendLine('foo')\n    c.appendLine('bar')\n    await wait(30)\n    c.clear()\n    await wait(30)\n    let lines = await buf.lines\n    let content = lines.join('')\n    expect(content).toBe('')\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog with buttons","suites":["Picker create"],"updatePoint":{"line":27,"column":37},"line":27,"code":"  it('should show dialog with buttons', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let id = await nvim.call('coc#float#get_related', [winid, 'buttons'])\n    expect(id).toBeGreaterThan(0)\n    let res = await nvim.call('sign_getplaced', [picker.buffer.id, { lnum: 1 }])\n    expect(res[0].signs).toBeDefined()\n    expect(res[0].signs[0].name).toBe('CocCurrentLine')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel dialog when cancellation token requested","suites":["Picker create"],"updatePoint":{"line":38,"column":60},"line":38,"code":"  it('should cancel dialog when cancellation token requested', async () => {\n    let tokenSource = new CancellationTokenSource()\n    picker = new Picker(nvim, { title: 'title', items }, tokenSource.token)\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    tokenSource.cancel()\n    await helper.wait(50)\n    let res = await nvim.call('coc#float#valid', [winid])\n    expect(res).toBe(0)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection mouse click bracket","suites":["Picker key mappings"],"updatePoint":{"line":51,"column":49},"line":51,"code":"  it('should toggle selection mouse click bracket', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show()\n    await nvim.setVar('mouse_position', [winid, 1, 1])\n    await nvim.input('<LeftRelease>')\n    await helper.wait(50)\n    let buf = picker.buffer\n    let lines = await buf.getLines({ start: 0, end: 1, strictIndexing: false })\n    expect(lines[0]).toMatch(/^\\[x\\]/)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change current line on mouse click label","suites":["Picker key mappings"],"updatePoint":{"line":62,"column":53},"line":62,"code":"  it('should change current line on mouse click label', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show()\n    await nvim.setVar('mouse_position', [winid, 2, 4])\n    await nvim.input('<LeftRelease>')\n    await helper.wait(50)\n    let buf = picker.buffer\n    let res = await nvim.call('sign_getplaced', [buf.id, { lnum: 2 }])\n    expect(res[0].signs).toBeDefined()\n    expect(res[0].signs[0].name).toBe('CocCurrentLine')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["Picker key mappings"],"updatePoint":{"line":74,"column":28},"line":74,"code":"  it('should cancel by <esc>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.eval(`feedkeys(\"\\\\<Esc>\", 'in')`)\n    await helper.wait(200)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should confirm by <CR>","suites":["Picker key mappings"],"updatePoint":{"line":86,"column":28},"line":86,"code":"  it('should confirm by <CR>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.input('<space>')\n    await helper.wait(100)\n    await nvim.input('<cr>')\n    await nvim.command('redraw')\n    await helper.wait(200)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by j, k, g & G","suites":["Picker key mappings"],"updatePoint":{"line":101,"column":39},"line":101,"code":"  it('should move cursor by j, k, g & G', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    await nvim.input('j')\n    await helper.wait(100)\n    let res = await nvim.call('sign_getplaced', [picker.buffer.id])\n    expect(res[0].signs[0].lnum).toBe(2)\n    await nvim.input('k')\n    await helper.wait(100)\n    res = await nvim.call('sign_getplaced', [picker.buffer.id])\n    expect(res[0].signs[0].lnum).toBe(1)\n    await nvim.input('G')\n    await helper.wait(100)\n    res = await nvim.call('sign_getplaced', [picker.buffer.id])\n    expect(res[0].signs[0].lnum).toBe(2)\n    await nvim.input('g')\n    await helper.wait(100)\n    res = await nvim.call('sign_getplaced', [picker.buffer.id])\n    expect(res[0].signs[0].lnum).toBe(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection by <space>","suites":["Picker key mappings"],"updatePoint":{"line":124,"column":40},"line":124,"code":"  it('should toggle selection by <space>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.input('<space>')\n    await helper.wait(200)\n    await nvim.command('redraw')\n    let lines = await nvim.call('getbufline', [picker.buffer.id, 1])\n    expect(lines[0]).toMatch('[x]')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll forward & backward","suites":["Picker key mappings"],"updatePoint":{"line":138,"column":38},"line":138,"code":"  it('should scroll forward & backward', async () => {\n    await helper.createDocument()\n    let items = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'].map(s => {\n      return { label: s }\n    })\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ maxHeight: 3 })\n    expect(winid).toBeDefined()\n    await nvim.input('<C-f>')\n    await helper.wait(100)\n    let info = await nvim.call('getwininfo', [winid])\n    expect(info[0]).toBeDefined()\n    expect(info[0].topline).toBeGreaterThan(1)\n    await nvim.input('<C-b>')\n    await helper.wait(100)\n    info = await nvim.call('getwininfo', [winid])\n    expect(info[0]).toBeDefined()\n    expect(info[0].topline).toBe(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should generate help tags","suites":["help tags"],"updatePoint":{"line":22,"column":31},"line":22,"code":"  it('should generate help tags', async () => {\n    let root = workspace.pluginRoot\n    let dir = await nvim.call('fnameescape', path.join(root, 'doc'))\n    let res = await nvim.call('execute', `helptags ${dir}`) as string\n    expect(res.length).toBe(0)\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return jumpable","suites":["help tags"],"updatePoint":{"line":29,"column":28},"line":29,"code":"  it('should return jumpable', async () => {\n    let jumpable = await helper.plugin.cocAction('snippetCheck', false, true)\n    expect(jumpable).toBe(false)\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show CocInfo","suites":["help tags"],"updatePoint":{"line":34,"column":25},"line":34,"code":"  it('should show CocInfo', async () => {\n    await nvim.call('CocActionAsync', ['showInfo'])\n    await helper.wait(300)\n    let line = await nvim.line\n    expect(line).toMatch('versions')\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ensure current document created","suites":["help tags"],"updatePoint":{"line":41,"column":44},"line":41,"code":"  it('should ensure current document created', async () => {\n    await nvim.command('tabe tmp.js')\n    let res = await helper.plugin.cocAction('ensureDocument')\n    expect(res).toBe(true)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let doc = workspace.getDocument(bufnr)\n    expect(doc).toBeDefined()\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"rangeInRange","suites":["Position"],"updatePoint":{"line":9,"column":20},"line":9,"code":"  test('rangeInRange', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(rangeInRange(r, r)).toBe(true)\n    expect(rangeInRange(r, Range.create(addPosition(pos, 1, 0), pos))).toBe(false)\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"rangeOverlap","suites":["Position"],"updatePoint":{"line":16,"column":20},"line":16,"code":"  test('rangeOverlap', () => {\n    let r = Range.create(0, 0, 0, 0)\n    expect(rangeOverlap(r, Range.create(0, 0, 0, 0))).toBe(false)\n    expect(rangeOverlap(Range.create(0, 0, 0, 10), Range.create(0, 1, 0, 2))).toBe(true)\n    expect(rangeOverlap(Range.create(0, 0, 0, 1), Range.create(0, 1, 0, 2))).toBe(false)\n    expect(rangeOverlap(Range.create(0, 1, 0, 2), Range.create(0, 0, 0, 1))).toBe(false)\n    expect(rangeOverlap(Range.create(0, 0, 0, 1), Range.create(0, 2, 0, 3))).toBe(false)\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"positionInRange","suites":["Position"],"updatePoint":{"line":25,"column":23},"line":25,"code":"  test('positionInRange', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(positionInRange(pos, r)).toBe(0)\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"comparePosition","suites":["Position"],"updatePoint":{"line":31,"column":23},"line":31,"code":"  test('comparePosition', () => {\n    let pos = Position.create(0, 0)\n    expect(comparePosition(pos, pos)).toBe(0)\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"isSingleLine","suites":["Position"],"updatePoint":{"line":36,"column":20},"line":36,"code":"  test('isSingleLine', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(isSingleLine(r)).toBe(true)\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getChangedPosition #1","suites":["Position"],"updatePoint":{"line":42,"column":29},"line":42,"code":"  test('getChangedPosition #1', () => {\n    let pos = Position.create(0, 0)\n    let edit = TextEdit.insert(pos, 'abc')\n    let res = getChangedPosition(pos, edit)\n    expect(res).toEqual({ line: 0, character: 3 })\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getChangedPosition #2","suites":["Position"],"updatePoint":{"line":49,"column":29},"line":49,"code":"  test('getChangedPosition #2', () => {\n    let pos = Position.create(0, 0)\n    let edit = TextEdit.insert(pos, 'a\\nb\\nc')\n    let res = getChangedPosition(pos, edit)\n    expect(res).toEqual({ line: 2, character: 1 })\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getChangedPosition #3","suites":["Position"],"updatePoint":{"line":56,"column":29},"line":56,"code":"  test('getChangedPosition #3', () => {\n    let pos = Position.create(0, 1)\n    let r = Range.create(addPosition(pos, 0, -1), pos)\n    let edit = TextEdit.replace(r, 'a\\nb\\n')\n    let res = getChangedPosition(pos, edit)\n    expect(res).toEqual({ line: 2, character: -1 })\n  })","file":"modules/position.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #1","suites":["match result"],"updatePoint":{"line":5,"column":32},"line":5,"code":"  it('should respect filename #1', () => {\n    let res = getMatchResult('/coc.nvim/coc.txt', 'coc', 'coc.txt')\n    expect(res).toEqual({ score: 4, matches: [10, 11, 12] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #2","suites":["match result"],"updatePoint":{"line":10,"column":32},"line":10,"code":"  it('should respect filename #2', () => {\n    let res = getMatchResult('/coc.nvim/Coc.txt', 'coc', 'Coc.txt')\n    expect(res).toEqual({ score: 3.5, matches: [10, 11, 12] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #3","suites":["match result"],"updatePoint":{"line":15,"column":32},"line":15,"code":"  it('should respect filename #3', () => {\n    let res = getMatchResult('/coc.nvim/cdoxc.txt', 'coc', 'cdoxc.txt')\n    expect(res).toEqual({ score: 3, matches: [10, 12, 14] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect path start","suites":["match result"],"updatePoint":{"line":20,"column":31},"line":20,"code":"  it('should respect path start', () => {\n    let res = getMatchResult('/foob/baxr/xyz', 'fbx')\n    expect(res).toEqual({ score: 3, matches: [1, 6, 11] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find fuzzy result","suites":["match result"],"updatePoint":{"line":25,"column":30},"line":25,"code":"  it('should find fuzzy result', () => {\n    let res = getMatchResult('foobarzyx', 'fbx')\n    expect(res).toEqual({ score: 2, matches: [0, 3, 8] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find fuzzy result #1","suites":["match result"],"updatePoint":{"line":30,"column":33},"line":30,"code":"  it('should find fuzzy result #1', () => {\n    let res = getMatchResult('LICENSES/preferred/MIT', 'lsit')\n    expect(res).toEqual({ score: 1.4, matches: [0, 5, 20, 21] })\n  })","file":"modules/score.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do document enter","suites":["sources"],"updatePoint":{"line":27,"column":30},"line":27,"code":"  it('should do document enter', async () => {\n    let fn = jest.fn()\n    let source: ISource = {\n      name: 'enter',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] }),\n      onEnter: fn\n    }\n    disposables.push(sources.addSource(source))\n    let buffer = await nvim.buffer\n    await events.fire('BufEnter', [buffer.id])\n    expect(fn).toBeCalled()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sources by split filetypes","suites":["sources"],"updatePoint":{"line":44,"column":43},"line":44,"code":"  it('should get sources by split filetypes', async () => {\n    disposables.push(sources.addSource({\n      name: 'foo',\n      filetypes: ['foo'],\n      enable: true,\n      doComplete: () => Promise.resolve({ items: [] }),\n    }))\n    disposables.push(sources.addSource({\n      name: 'bar',\n      filetypes: ['bar'],\n      enable: true,\n      doComplete: () => Promise.resolve({ items: [] }),\n    }))\n    let arr = sources.getNormalSources('foo.bar', 'file:///a')\n    let names = arr.map(s => s.name)\n    expect(names.includes('foo')).toBe(true)\n    expect(names.includes('bar')).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return source states","suites":["sources"],"updatePoint":{"line":63,"column":33},"line":63,"code":"  it('should return source states', () => {\n    let stats = sources.sourceStats()\n    expect(stats.length > 1).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle source state","suites":["sources"],"updatePoint":{"line":68,"column":32},"line":68,"code":"  it('should toggle source state', () => {\n    sources.toggleSource('around')\n    let s = sources.getSource('around')\n    expect(s.enable).toBe(false)\n    sources.toggleSource('around')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should has source","suites":["sources#has"],"updatePoint":{"line":78,"column":23},"line":78,"code":"  it('should has source', () => {\n    expect(sources.has('around')).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not has source","suites":["sources#has"],"updatePoint":{"line":82,"column":27},"line":82,"code":"  it('should not has source', () => {\n    expect(sources.has('NotExists')).toBe(false)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh if possible","suites":["sources#refresh"],"updatePoint":{"line":88,"column":32},"line":88,"code":"  it('should refresh if possible', async () => {\n    let fn = jest.fn()\n    let source: ISource = {\n      name: 'refresh',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] }),\n      refresh: fn\n    }\n    disposables.push(sources.addSource(source))\n    await sources.refresh('refresh')\n    expect(fn).toBeCalled()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work if refresh not defined","suites":["sources#refresh"],"updatePoint":{"line":104,"column":40},"line":104,"code":"  it('should work if refresh not defined', async () => {\n    let source: ISource = {\n      name: 'refresh',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    await sources.refresh('refresh')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create source","suites":["sources#createSource"],"updatePoint":{"line":119,"column":26},"line":119,"code":"  it('should create source', async () => {\n    disposables.push(sources.createSource({\n      name: 'custom',\n      doComplete: () => Promise.resolve({\n        items: [{\n          word: 'custom'\n        }]\n      })\n    }))\n    await helper.createDocument()\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('c')\n    let visible = await helper.visible('custom', 'custom')\n    expect(visible).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create vim source","suites":["sources#createSource"],"updatePoint":{"line":136,"column":30},"line":136,"code":"  it('should create vim source', async () => {\n    let folder = path.resolve(__dirname, '..')\n    await nvim.command(`set runtimepath+=${folder}`)\n    disposables.push({\n      dispose: () => {\n        nvim.command(`set runtimepath-=${folder}`, true)\n        sources.removeSource('email')\n      }\n    })\n    await helper.wait(100)\n    let exists = sources.has('email')\n    expect(exists).toBe(true)\n    await helper.createDocument()\n    await nvim.input('i')\n    await helper.wait(10)\n    await nvim.input('@')\n    await helper.visible('foo@gmail.com')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by filetypes","suites":["sources#getTriggerSources()"],"updatePoint":{"line":157,"column":32},"line":157,"code":"  it('should filter by filetypes', async () => {\n    let source: ISource = {\n      name: 'test',\n      enable: true,\n      priority: 0,\n      filetypes: ['javascript'],\n      sourceType: SourceType.Service,\n      triggerCharacters: ['#'],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    let res = sources.getTriggerSources('#', 'javascript', 'file:///tmp.js')\n    expect(res.find(o => o.name == 'test')).toBeDefined()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by documentSelector","suites":["sources#getTriggerSources()"],"updatePoint":{"line":172,"column":39},"line":172,"code":"  it('should filter by documentSelector', async () => {\n    let source: ISource = {\n      name: 'test',\n      enable: true,\n      priority: 0,\n      documentSelector: [{ language: 'javascript' }],\n      sourceType: SourceType.Service,\n      triggerCharacters: ['#'],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    let res = sources.getTriggerSources('#', 'javascript', 'file:///tmp.js')\n    expect(res.find(o => o.name == 'test')).toBeDefined()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter disabled sources","suites":["sources#getTriggerSources()"],"updatePoint":{"line":187,"column":36},"line":187,"code":"  it('should filter disabled sources', async () => {\n    await helper.edit()\n    await nvim.setLine('foo bar ')\n    let buf = await nvim.buffer\n    await buf.setVar('coc_disabled_sources', ['around', 'buffer', 'file'])\n    await helper.wait(30)\n    await nvim.input('Af')\n    await helper.wait(100)\n    let visible = await nvim.call('pumvisible')\n    if (visible) {\n      let items = await helper.getItems()\n      console.log(items)\n    }\n    expect(visible).toBe(0)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start task","suites":["task test"],"updatePoint":{"line":16,"column":23},"line":16,"code":"  it('should start task', async () => {\n    let task = workspace.createTask('sleep')\n    let started = await task.start({ cmd: 'sleep', args: ['50'] })\n    expect(started).toBe(true)\n    task.dispose()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop task","suites":["task test"],"updatePoint":{"line":23,"column":22},"line":23,"code":"  it('should stop task', async () => {\n    let task = workspace.createTask('sleep')\n    await task.start({ cmd: 'sleep', args: ['50'] })\n    await helper.wait(10)\n    await task.stop()\n    let running = await task.running\n    expect(running).toBe(false)\n    task.dispose()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit exit event","suites":["task test"],"updatePoint":{"line":33,"column":28},"line":33,"code":"  it('should emit exit event', async () => {\n    let fn = jest.fn()\n    let task = workspace.createTask('sleep')\n    task.onExit(fn)\n    await task.start({ cmd: 'sleep', args: ['50'] })\n    await helper.wait(10)\n    await task.stop()\n    task.dispose()\n    expect(fn).toBeCalled()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit stdout event","suites":["task test"],"updatePoint":{"line":44,"column":30},"line":44,"code":"  it('should emit stdout event', async () => {\n    let file = await createTmpFile('echo foo')\n    let fn = jest.fn()\n    let task = workspace.createTask('echo')\n    let called = false\n    task.onStdout(lines => {\n      if (!called) expect(lines).toEqual(['foo'])\n      called = true\n      fn()\n    })\n    await task.start({ cmd: '/bin/sh', args: [file] })\n    await helper.wait(300)\n    task.dispose()\n    expect(fn).toBeCalled()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change environment variables","suites":["task test"],"updatePoint":{"line":60,"column":41},"line":60,"code":"  it('should change environment variables', async () => {\n    let file = await createTmpFile('echo $NODE_ENV\\necho $COC_NVIM_TEST\\nsleep 1')\n    let task = workspace.createTask('ENV')\n    let lines: string[] = []\n    task.onStdout(arr => {\n      lines.push(...arr)\n    })\n    await task.start({\n      cmd: '/bin/sh',\n      args: [file],\n      env: {\n        NODE_ENV: 'production',\n        COC_NVIM_TEST: 'yes'\n      }\n    })\n    await helper.wait(300)\n    expect(lines).toEqual(['production', 'yes'])\n    let res = await nvim.call('getenv', 'COC_NVIM_TEST')\n    expect(res).toBeNull()\n    task.dispose()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should receive stdout lines as expected","suites":["task test"],"updatePoint":{"line":82,"column":45},"line":82,"code":"  it('should receive stdout lines as expected', async () => {\n    let file = await createTmpFile('echo 3\\necho \"\"\\necho 4')\n    let task = workspace.createTask('ENV')\n    let lines: string[] = []\n    task.onStdout(arr => {\n      lines.push(...arr)\n    })\n    await task.start({\n      cmd: '/bin/sh',\n      args: [file]\n    })\n    await helper.wait(300)\n    expect(lines).toEqual(['3', '', '4'])\n    task.dispose()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit stderr event","suites":["task test"],"updatePoint":{"line":98,"column":30},"line":98,"code":"  it('should emit stderr event', async () => {\n    let file = await createTmpFile('console.error(\"start\\\\n\\\\nend\");')\n    let fn = jest.fn()\n    let task = workspace.createTask('error')\n    let lines: string[] = []\n    task.onStderr(arr => {\n      lines.push(...arr)\n      fn()\n    })\n    await task.start({ cmd: 'node', args: [file] })\n    await helper.wait(300)\n    expect(lines).toEqual(['start', '', 'end'])\n    task.dispose()\n    expect(fn).toBeCalled()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get name","suites":["terminal properties"],"updatePoint":{"line":20,"column":21},"line":20,"code":"  it('should get name', () => {\n    let name = terminal.name\n    expect(name).toBe('sh')\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have correct cwd and env","suites":["terminal properties"],"updatePoint":{"line":25,"column":37},"line":25,"code":"  it('should have correct cwd and env', async () => {\n    let bufnr = terminal.bufnr\n    terminal.sendText('echo $PWD')\n    await helper.wait(300)\n    let lines = await nvim.call('getbufline', [bufnr, 1, '$']) as string[]\n    expect(lines[0].trim().length).toBeGreaterThan(0)\n    terminal.sendText('echo $COC_TERMINAL')\n    await helper.wait(300)\n    lines = await nvim.call('getbufline', [bufnr, 1, '$']) as string[]\n    expect(lines.includes(`option '-term'`)).toBe(true)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get pid","suites":["terminal properties"],"updatePoint":{"line":37,"column":20},"line":37,"code":"  it('should get pid', async () => {\n    let pid = await terminal.processId\n    expect(typeof pid).toBe('number')\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide terminal window","suites":["terminal properties"],"updatePoint":{"line":42,"column":33},"line":42,"code":"  it('should hide terminal window', async () => {\n    await terminal.hide()\n    let winnr = await nvim.call('bufwinnr', terminal.bufnr)\n    expect(winnr).toBe(-1)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show terminal window","suites":["terminal properties"],"updatePoint":{"line":48,"column":33},"line":48,"code":"  it('should show terminal window', async () => {\n    await terminal.show()\n    let winnr = await nvim.call('bufwinnr', terminal.bufnr)\n    expect(winnr != -1).toBe(true)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get line count and content","suites":["LinesTextDocument"],"updatePoint":{"line":9,"column":39},"line":9,"code":"  it('should get line count and content', async () => {\n    let doc = createTextDocument(['a', 'b'])\n    expect(doc.lineCount).toBe(3)\n    let content = doc.getText()\n    expect(content).toBe('a\\nb\\n')\n  })","file":"modules/textdocument.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get position","suites":["LinesTextDocument"],"updatePoint":{"line":16,"column":25},"line":16,"code":"  it('should get position', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let pos = doc.positionAt(4)\n    expect(pos).toEqual({ line: 1, character: 0 })\n  })","file":"modules/textdocument.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get content by range","suites":["LinesTextDocument"],"updatePoint":{"line":22,"column":33},"line":22,"code":"  it('should get content by range', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let content = doc.getText(Range.create(0, 0, 0, 3))\n    expect(content).toBe('foo')\n  })","file":"modules/textdocument.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get offset","suites":["LinesTextDocument"],"updatePoint":{"line":28,"column":23},"line":28,"code":"  it('should get offset', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let offset = doc.offsetAt(Position.create(0, 4))\n    expect(offset).toBe(4)\n    offset = doc.offsetAt(Position.create(2, 1))\n    expect(offset).toBe(8)\n  })","file":"modules/textdocument.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get parts","suites":["rangeParts"],"updatePoint":{"line":21,"column":22},"line":21,"code":"  it('should get parts', async () => {\n    let res = rangeParts('foo bar', Range.create(0, 0, 0, 4))\n    expect(res).toEqual(['', 'bar'])\n    res = rangeParts('foo\\nbar', Range.create(0, 1, 1, 1))\n    expect(res).toEqual(['f', 'ar'])\n    res = rangeParts('x\\nfoo\\nbar\\ny', Range.create(0, 1, 2, 3))\n    expect(res).toEqual(['x', '\\ny'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch file","suites":["watchFile"],"updatePoint":{"line":32,"column":23},"line":32,"code":"  it('should watch file', async () => {\n    let filepath = await createTmpFile('my file')\n    let fn = jest.fn()\n    let disposable = watchFile(filepath, () => {\n      fn()\n    })\n    await wait(30)\n    fs.writeFileSync(filepath, 'new file', 'utf8')\n    await wait(200)\n    expect(fn).toBeCalled()\n    disposable.dispose()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match schema","suites":["score test"],"updatePoint":{"line":47,"column":25},"line":47,"code":"  it('should match schema', () => {\n    let uri = URI.file('/foo').toString()\n    let s = matchScore([{ language: '*', scheme: 'file' }], uri, 'typescript')\n    expect(s).toBe(5)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#score","suites":["score test"],"updatePoint":{"line":53,"column":15},"line":53,"code":"  it('fzy#score', async () => {\n    let a = score(\"amuser\", \"app/models/user.rb\")\n    let b = score(\"amuser\", \"app/models/customer.rb\")\n    expect(a).toBeGreaterThan(b)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#positions","suites":["score test"],"updatePoint":{"line":59,"column":19},"line":59,"code":"  it('fzy#positions', async () => {\n    let arr = positions(\"amuser\", \"app/models/user.rb\")\n    expect(arr).toEqual([0, 4, 11, 12, 13, 14])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#groupPositions","suites":["score test"],"updatePoint":{"line":64,"column":24},"line":64,"code":"  it('fzy#groupPositions', async () => {\n    let arr = groupPositions([1, 2, 3, 6, 7, 10])\n    expect(arr).toEqual([[1, 4], [6, 8], [10, 11]])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"get parentDirs","suites":["parentDirs"],"updatePoint":{"line":71,"column":20},"line":71,"code":"  it('get parentDirs', () => {\n    let dirs = parentDirs('/a/b/c')\n    expect(dirs).toEqual(['/', '/a', '/a/b'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"check parent folder","suites":["isParentFolder"],"updatePoint":{"line":78,"column":25},"line":78,"code":"  it('check parent folder', () => {\n    expect(isParentFolder('/a', '/a/b')).toBe(true)\n    expect(isParentFolder('/a/b', '/a/b/')).toBe(false)\n    expect(isParentFolder('/a/b', '/a/b')).toBe(false)\n    expect(isParentFolder('/a/b', '/a/b', true)).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find index","suites":["string test"],"updatePoint":{"line":87,"column":23},"line":87,"code":"  it('should find index', () => {\n    expect(indexOf('a,b,c', ',', 2)).toBe(3)\n    expect(indexOf('a,b,c', ',', 1)).toBe(1)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run concurrent","suites":["concurrent"],"updatePoint":{"line":94,"column":27},"line":94,"code":"  it('should run concurrent', async () => {\n    let res: number[] = []\n    let fn = (n: number): Promise<void> => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          res.push(n)\n          resolve()\n        }, n * 100)\n      })\n    }\n    let arr = [5, 4, 3, 6, 8]\n    let ts = Date.now()\n    await concurrent(arr, fn, 3)\n    let dt = Date.now() - ts\n    expect(dt).toBeLessThanOrEqual(1300)\n    expect(dt).toBeGreaterThanOrEqual(1200)\n    expect(res).toEqual([3, 4, 5, 6, 8])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be fuzzy match","suites":["fuzzy match test"],"updatePoint":{"line":115,"column":27},"line":115,"code":"  it('should be fuzzy match', () => {\n    let needle = 'aBc'\n    let codes = getCharCodes(needle)\n    expect(fuzzyMatch(codes, 'abc')).toBeFalsy\n    expect(fuzzyMatch(codes, 'ab')).toBeFalsy\n    expect(fuzzyMatch(codes, 'addbdd')).toBeFalsy\n    expect(fuzzyMatch(codes, 'abbbBc')).toBeTruthy\n    expect(fuzzyMatch(codes, 'daBc')).toBeTruthy\n    expect(fuzzyMatch(codes, 'ABCz')).toBeTruthy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be fuzzy for character","suites":["fuzzy match test"],"updatePoint":{"line":126,"column":35},"line":126,"code":"  it('should be fuzzy for character', () => {\n    expect(fuzzyChar('a', 'a')).toBeTruthy\n    expect(fuzzyChar('a', 'A')).toBeTruthy\n    expect(fuzzyChar('z', 'z')).toBeTruthy\n    expect(fuzzyChar('z', 'Z')).toBeTruthy\n    expect(fuzzyChar('A', 'a')).toBeFalsy\n    expect(fuzzyChar('A', 'A')).toBeTruthy\n    expect(fuzzyChar('Z', 'z')).toBeFalsy\n    expect(fuzzyChar('Z', 'Z')).toBeTruthy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fs statAsync","suites":["fs test"],"updatePoint":{"line":139,"column":18},"line":139,"code":"  it('fs statAsync', async () => {\n    let res = await statAsync(__filename)\n    expect(res).toBeDefined\n    expect(res.isFile()).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fs statAsync #1","suites":["fs test"],"updatePoint":{"line":145,"column":21},"line":145,"code":"  it('fs statAsync #1', async () => {\n    let res = await statAsync(path.join(__dirname, 'file_not_exist'))\n    expect(res).toBeNull\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be not ignored","suites":["fs test"],"updatePoint":{"line":150,"column":27},"line":150,"code":"  it('should be not ignored', async () => {\n    let res = await isGitIgnored(__filename)\n    expect(res).toBeFalsy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be ignored","suites":["fs test"],"updatePoint":{"line":155,"column":23},"line":155,"code":"  it('should be ignored', async () => {\n    let res = await isGitIgnored(path.resolve(__dirname, '../lib/index.js.map'))\n    expect(res).toBeTruthy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mixin should recursive","suites":["object test"],"updatePoint":{"line":162,"column":28},"line":162,"code":"  it('mixin should recursive', () => {\n    let res = mixin({ a: { b: 1 } }, { a: { c: 2 }, d: 3 })\n    expect(res.a.b).toBe(1)\n    expect(res.a.c).toBe(2)\n    expect(res.d).toBe(3)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"resolve root consider root path","suites":["resolveRoot"],"updatePoint":{"line":171,"column":37},"line":171,"code":"  it('resolve root consider root path', () => {\n    let res = resolveRoot(__dirname, ['.git'])\n    expect(res).toMatch('coc.nvim')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve from parent folders","suites":["resolveRoot"],"updatePoint":{"line":176,"column":40},"line":176,"code":"  it('should resolve from parent folders', () => {\n    let root = path.resolve(__dirname, '../extensions/snippet-sample')\n    let res = resolveRoot(root, ['package.json'])\n    expect(res.endsWith('coc.nvim')).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve from parent folders with bottom-up method","suites":["resolveRoot"],"updatePoint":{"line":182,"column":62},"line":182,"code":"  it('should resolve from parent folders with bottom-up method', () => {\n    let root = path.resolve(__dirname, '../extensions/snippet-sample')\n    let res = resolveRoot(root, ['package.json'], null, true)\n    expect(res.endsWith('extensions')).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve to cwd","suites":["resolveRoot"],"updatePoint":{"line":188,"column":27},"line":188,"code":"  it('should resolve to cwd', () => {\n    let root = path.resolve(__dirname, '../extensions/test/')\n    let res = resolveRoot(root, ['package.json'], root, false, true)\n    expect(res).toBe(root)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve to root","suites":["resolveRoot"],"updatePoint":{"line":194,"column":28},"line":194,"code":"  it('should resolve to root', () => {\n    let root = path.resolve(__dirname, '../extensions/test/')\n    let res = resolveRoot(root, ['package.json'], root, false, false)\n    expect(res).toBe(path.resolve(__dirname, '../../../'))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve to home","suites":["resolveRoot"],"updatePoint":{"line":200,"column":32},"line":200,"code":"  it('should not resolve to home', () => {\n    let res = resolveRoot(__dirname, ['.config'])\n    expect(res != os.homedir()).toBeTruthy()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"findUp by filename","suites":["findUp"],"updatePoint":{"line":207,"column":24},"line":207,"code":"  it('findUp by filename', () => {\n    let filepath = findUp('package.json', __dirname)\n    expect(filepath).toMatch('coc.nvim')\n    filepath = findUp('not_exists', __dirname)\n    expect(filepath).toBeNull()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"findUp by filenames","suites":["findUp"],"updatePoint":{"line":214,"column":25},"line":214,"code":"  it('findUp by filenames', async () => {\n    let filepath = findUp(['src'], __dirname)\n    expect(filepath).toMatch('coc.nvim')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #1","suites":["ansiparse"],"updatePoint":{"line":221,"column":18},"line":221,"code":"  it('ansiparse #1', () => {\n    let str = '\\u001b[33mText\\u001b[mnormal'\n    let res = ansiparse(str)\n    expect(res).toEqual([{\n      foreground: 'yellow', text: 'Text'\n    }, {\n      text: 'normal'\n    }])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #2","suites":["ansiparse"],"updatePoint":{"line":231,"column":18},"line":231,"code":"  it('ansiparse #2', () => {\n    let str = '\\u001b[33m\\u001b[mText'\n    let res = ansiparse(str)\n    expect(res).toEqual([\n      { foreground: 'yellow', text: '' },\n      { text: 'Text' }])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #3","suites":["ansiparse"],"updatePoint":{"line":239,"column":18},"line":239,"code":"  it('ansiparse #3', () => {\n    let str = 'this.\\u001b[0m\\u001b[31m\\u001b[1mhistory\\u001b[0m.add()'\n    let res = ansiparse(str)\n    expect(res[1]).toEqual({\n      foreground: 'red',\n      bold: true, text: 'history'\n    })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutex run in serial","suites":["Mutex"],"updatePoint":{"line":250,"column":25},"line":250,"code":"  it('mutex run in serial', async () => {\n    let lastTs: number\n    let fn = () => new Promise<void>(resolve => {\n      if (lastTs) {\n        let dt = Date.now() - lastTs\n        expect(dt).toBeGreaterThanOrEqual(298)\n      }\n      lastTs = Date.now()\n      setTimeout(() => {\n        resolve()\n      }, 300)\n    })\n    let mutex = new Mutex()\n    await Promise.all([\n      mutex.use(fn),\n      mutex.use(fn),\n      mutex.use(fn)\n    ])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutex run after job finish","suites":["Mutex"],"updatePoint":{"line":270,"column":32},"line":270,"code":"  it('mutex run after job finish', async () => {\n    let count = 0\n    let fn = () => new Promise<void>(resolve => {\n      count = count + 1\n      setTimeout(() => {\n        resolve()\n      }, 100)\n    })\n    let mutex = new Mutex()\n    await mutex.use(fn)\n    await helper.wait(10)\n    await mutex.use(fn)\n    expect(count).toBe(2)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should terminate process","suites":["terminate"],"updatePoint":{"line":287,"column":30},"line":287,"code":"  it('should terminate process', async () => {\n    let cwd = process.cwd()\n    let child = spawn('sleep', ['10'], { cwd, detached: true })\n    let res = terminate(child, cwd)\n    await helper.wait(60)\n    expect(res).toBe(true)\n    expect(child.connected).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should checkCapability","suites":["watchman"],"updatePoint":{"line":102,"column":28},"line":102,"code":"  it('should checkCapability', async () => {\n    let client = new Watchman(null)\n    let res = await client.checkCapability()\n    expect(res).toBe(true)\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watchProject","suites":["watchman"],"updatePoint":{"line":109,"column":25},"line":109,"code":"  it('should watchProject', async () => {\n    let client = new Watchman(null)\n    let res = await client.watchProject(__dirname)\n    expect(res).toBe(true)\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should subscribe","suites":["watchman"],"updatePoint":{"line":116,"column":22},"line":116,"code":"  it('should subscribe', async () => {\n    let client = new Watchman(null, new BufferChannel('watchman', nvim))\n    let cwd = process.cwd()\n    await client.watchProject(cwd)\n    let fn = jest.fn()\n    let disposable = await client.subscribe(`${cwd}/*`, fn)\n    let changes: FileChangeItem[] = [createFileChange(`${cwd}/a`)]\n    sendSubscription((global as any).subscribe, cwd, changes)\n    await wait(100)\n    expect(fn).toBeCalled()\n    let call = fn.mock.calls[0][0]\n    disposable.dispose()\n    expect(call.root).toBe(cwd)\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should unsubscribe","suites":["watchman"],"updatePoint":{"line":132,"column":24},"line":132,"code":"  it('should unsubscribe', async () => {\n    let client = new Watchman(null)\n    await client.watchProject(process.cwd())\n    let fn = jest.fn()\n    let disposable = await client.subscribe(`${process.cwd()}/*`, fn)\n    disposable.dispose()\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create client","suites":["Watchman#createClient"],"updatePoint":{"line":143,"column":26},"line":143,"code":"  it('should create client', async () => {\n    let client = await Watchman.createClient(null, process.cwd())\n    expect(client).toBeDefined()\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resue client for same root","suites":["Watchman#createClient"],"updatePoint":{"line":149,"column":39},"line":149,"code":"  it('should resue client for same root', async () => {\n    let client = await Watchman.createClient(null, process.cwd())\n    expect(client).toBeDefined()\n    let other = await Watchman.createClient(null, process.cwd())\n    expect(client).toBe(other)\n    client.dispose()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create client for root","suites":["Watchman#createClient"],"updatePoint":{"line":157,"column":39},"line":157,"code":"  it('should not create client for root', async () => {\n    let client = await Watchman.createClient(null, '/')\n    expect(client).toBeNull()\n  })","file":"modules/watchman.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get offset","suites":["window functions"],"updatePoint":{"line":37,"column":23},"line":37,"code":"  it('should get offset', async () => {\n    let doc = await helper.createDocument()\n    await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'foo\\nbar' }])\n    let buf = await nvim.buffer\n    await buf.setLines(['foo', 'bar'], { start: 0, end: -1 })\n    await helper.wait(100)\n    await nvim.call('cursor', [2, 2])\n    let n = await window.getOffset()\n    expect(n).toBe(5)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo lines","suites":["window functions"],"updatePoint":{"line":48,"column":23},"line":48,"code":"  it('should echo lines', async () => {\n    await window.echoLines(['a', 'b'])\n    let ch = await nvim.call('screenchar', [79, 1])\n    let s = String.fromCharCode(ch)\n    expect(s).toBe('a')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo multiple lines with truncate","suites":["window functions"],"updatePoint":{"line":55,"column":46},"line":55,"code":"  it('should echo multiple lines with truncate', async () => {\n    await window.echoLines(['a', 'b', 'd', 'e'], true)\n    let ch = await nvim.call('screenchar', [79, 1])\n    let s = String.fromCharCode(ch)\n    expect(s).toBe('a')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run terminal command","suites":["window functions"],"updatePoint":{"line":62,"column":33},"line":62,"code":"  it('should run terminal command', async () => {\n    let res = await window.runTerminalCommand('ls', __dirname)\n    expect(res.success).toBe(true)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open temimal buffer","suites":["window functions"],"updatePoint":{"line":67,"column":32},"line":67,"code":"  it('should open temimal buffer', async () => {\n    let bufnr = await window.openTerminal('ls', { autoclose: false, keepfocus: false })\n    let curr = await nvim.eval('bufnr(\"%\")')\n    expect(curr).toBe(bufnr)\n    let buftype = await nvim.eval('&buftype')\n    expect(buftype).toBe('terminal')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show mesages","suites":["window functions"],"updatePoint":{"line":75,"column":25},"line":75,"code":"  it('should show mesages', async () => {\n    await helper.edit()\n    window.showMessage('error', 'error')\n    await helper.wait(100)\n    let str = await helper.getCmdline()\n    expect(str).toMatch('error')\n    window.showMessage('warning', 'warning')\n    await helper.wait(100)\n    str = await helper.getCmdline()\n    expect(str).toMatch('warning')\n    window.showMessage('moremsg')\n    await helper.wait(100)\n    str = await helper.getCmdline()\n    expect(str).toMatch('moremsg')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create outputChannel","suites":["window functions"],"updatePoint":{"line":91,"column":33},"line":91,"code":"  it('should create outputChannel', () => {\n    let channel = window.createOutputChannel('channel')\n    expect(channel.name).toBe('channel')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create TreeView instance","suites":["window functions"],"updatePoint":{"line":96,"column":37},"line":96,"code":"  it('should create TreeView instance', async () => {\n    let emitter = new Emitter<FileNode | undefined>()\n    let removed = false\n    let treeView = window.createTreeView('files', {\n      treeDataProvider: {\n        onDidChangeTreeData: emitter.event,\n        getChildren: root => {\n          if (root) return undefined\n          if (removed) return [{ filepath: '/foo/a', isFolder: true }]\n          return [{ filepath: '/foo/a', isFolder: true }, { filepath: '/foo/b.js' }]\n        },\n        getTreeItem: (node: FileNode) => {\n          let { filepath, isFolder } = node\n          return new TreeItem(URI.file(filepath), isFolder ? TreeItemCollapsibleState.Collapsed : TreeItemCollapsibleState.None)\n        },\n      }\n    })\n    disposables.push(emitter)\n    disposables.push(treeView)\n    await treeView.show()\n    await helper.wait(50)\n    await nvim.command('exe 2')\n    await nvim.input('t')\n    await helper.wait(50)\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['files', '- a', '  b.js'])\n    removed = true\n    emitter.fire(undefined)\n    await helper.wait(50)\n    lines = await nvim.call('getline', [1, '$'])\n    expect(lines).toEqual(['files', '- a'])\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show outputChannel","suites":["window functions"],"updatePoint":{"line":129,"column":31},"line":129,"code":"  it('should show outputChannel', async () => {\n    window.createOutputChannel('channel')\n    window.showOutputChannel('channel')\n    await helper.wait(50)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('channel')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show none exists channel","suites":["window functions"],"updatePoint":{"line":138,"column":41},"line":138,"code":"  it('should not show none exists channel', async () => {\n    let buf = await nvim.buffer\n    let bufnr = buf.id\n    window.showOutputChannel('NONE')\n    await helper.wait(10)\n    buf = await nvim.buffer\n    expect(buf.id).toBe(bufnr)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get cursor position","suites":["window functions"],"updatePoint":{"line":147,"column":32},"line":147,"code":"  it('should get cursor position', async () => {\n    await helper.createDocument()\n    await nvim.setLine('       ')\n    await nvim.call('cursor', [1, 3])\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({\n      line: 0,\n      character: 2\n    })\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should moveTo position in insert mode","suites":["window functions"],"updatePoint":{"line":158,"column":43},"line":158,"code":"  it('should moveTo position in insert mode', async () => {\n    await helper.edit()\n    await nvim.setLine('foo')\n    await nvim.input('i')\n    await window.moveTo({ line: 0, character: 3 })\n    let col = await nvim.call('col', '.')\n    expect(col).toBe(4)\n    let virtualedit = await nvim.getOption('virtualedit')\n    expect(virtualedit).toBe('')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should choose quickpick","suites":["window functions"],"updatePoint":{"line":169,"column":29},"line":169,"code":"  it('should choose quickpick', async () => {\n    let p = window.showQuickpick(['a', 'b'])\n    await helper.wait(100)\n    await nvim.input('1')\n    await nvim.input('<CR>')\n    let res = await p\n    expect(res).toBe(0)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel quickpick","suites":["window functions"],"updatePoint":{"line":178,"column":29},"line":178,"code":"  it('should cancel quickpick', async () => {\n    let p = window.showQuickpick(['a', 'b'])\n    await helper.wait(100)\n    await nvim.input('<esc>')\n    let res = await p\n    expect(res).toBe(-1)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show prompt","suites":["window functions"],"updatePoint":{"line":186,"column":24},"line":186,"code":"  it('should show prompt', async () => {\n    let p = window.showPrompt('prompt')\n    await helper.wait(100)\n    await nvim.input('y')\n    let res = await p\n    expect(res).toBe(true)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog","suites":["window functions"],"updatePoint":{"line":194,"column":24},"line":194,"code":"  it('should show dialog', async () => {\n    let dialog = await window.showDialog({ content: 'foo' })\n    let winid = await dialog.winid\n    expect(winid).toBeDefined()\n    expect(winid).toBeGreaterThan(1000)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show menu","suites":["window functions"],"updatePoint":{"line":201,"column":22},"line":201,"code":"  it('should show menu', async () => {\n    let p = window.showMenuPicker(['a', 'b', 'c'], 'choose item')\n    await helper.wait(100)\n    let exists = await nvim.call('coc#float#has_float', [])\n    expect(exists).toBe(1)\n    await nvim.input('2')\n    let res = await p\n    expect(res).toBe(1)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should request input","suites":["window functions"],"updatePoint":{"line":211,"column":26},"line":211,"code":"  it('should request input', async () => {\n    let winid = await nvim.call('win_getid')\n    let p = window.requestInput('Name')\n    await helper.wait(100)\n    await nvim.input('bar<enter>')\n    let res = await p\n    let curr = await nvim.call('win_getid')\n    expect(curr).toBe(winid)\n    expect(res).toBe('bar')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when input empty","suites":["window functions"],"updatePoint":{"line":222,"column":41},"line":222,"code":"  it('should return null when input empty', async () => {\n    let p = window.requestInput('Name')\n    await helper.wait(30)\n    await nvim.input('<enter>')\n    let res = await p\n    expect(res).toBeNull()\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return select items for picker","suites":["window functions"],"updatePoint":{"line":230,"column":43},"line":230,"code":"  it('should return select items for picker', async () => {\n    let curr = await nvim.call('win_getid')\n    let p = window.showPickerDialog(['foo', 'bar'], 'select')\n    await helper.wait(100)\n    await nvim.input(' ')\n    await helper.wait(30)\n    await nvim.input('<cr>')\n    let res = await p\n    let winid = await nvim.call('win_getid')\n    expect(winid).toBe(curr)\n    expect(res).toEqual(['foo'])\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show information message","suites":["window functions"],"updatePoint":{"line":253,"column":37},"line":253,"code":"  it('should show information message', async () => {\n    let p = window.showInformationMessage('information message', 'first', 'second')\n    await helper.wait(50)\n    await ensureNotification(0)\n    let res = await p\n    expect(res).toBe('first')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning message","suites":["window functions"],"updatePoint":{"line":261,"column":33},"line":261,"code":"  it('should show warning message', async () => {\n    let p = window.showWarningMessage('warning message', 'first', 'second')\n    await helper.wait(50)\n    await ensureNotification(1)\n    let res = await p\n    expect(res).toBe('second')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error message","suites":["window functions"],"updatePoint":{"line":269,"column":31},"line":269,"code":"  it('should show error message', async () => {\n    let p = window.showErrorMessage('error message', 'first', 'second')\n    await helper.wait(50)\n    await ensureNotification(0)\n    let res = await p\n    expect(res).toBe('first')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show notification with options","suites":["window notifications"],"updatePoint":{"line":279,"column":43},"line":279,"code":"  it('should show notification with options', async () => {\n    let res = await window.showNotification({\n      content: 'my notification',\n      close: true,\n      title: 'title',\n      timeout: 500\n    })\n    expect(res).toBe(true)\n    let ids = await nvim.call('coc#float#get_float_win_list')\n    expect(ids.length).toBe(1)\n    let win = nvim.createWindow(ids[0])\n    let kind = await win.getVar('kind')\n    expect(kind).toBe('notification')\n    let winid = await nvim.call('coc#float#get_related', [win.id, 'border'])\n    let bufnr = await nvim.call('winbufnr', [winid])\n    let buf = nvim.createBuffer(bufnr)\n    let lines = await buf.lines\n    expect(lines[0].includes('title')).toBe(true)\n    await helper.wait(600)\n    let valid = await nvim.call('coc#float#valid', [win.id])\n    expect(valid).toBeFalsy()\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show progress notification","suites":["window notifications"],"updatePoint":{"line":302,"column":39},"line":302,"code":"  it('should show progress notification', async () => {\n    let called = 0\n    let res = await window.withProgress({ title: 'Downloading', cancellable: true }, (progress, token) => {\n      let n = 0\n      return new Promise(resolve => {\n        let interval = setInterval(() => {\n          progress.report({ message: 'progress', increment: 1 })\n          n = n + 10\n          called = called + 1\n          if (n == 100) {\n            clearInterval(interval)\n            resolve('done')\n          }\n        }, 100)\n        token.onCancellationRequested(() => {\n          clearInterval(interval)\n          resolve(undefined)\n        })\n      })\n    })\n    expect(called).toBe(10)\n    expect(res).toBe('done')\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel progress notification on window close","suites":["window notifications"],"updatePoint":{"line":326,"column":57},"line":326,"code":"  it('should cancel progress notification on window close', async () => {\n    let called = 0\n    let p = window.withProgress({ title: 'Downloading', cancellable: true }, (progress, token) => {\n      let n = 0\n      return new Promise(resolve => {\n        let interval = setInterval(() => {\n          progress.report({ message: 'progress', increment: 1 })\n          n = n + 10\n          called = called + 1\n          if (n == 100) {\n            clearInterval(interval)\n            resolve('done')\n          }\n        }, 100)\n        token.onCancellationRequested(() => {\n          clearInterval(interval)\n          resolve(undefined)\n        })\n      })\n    })\n    await helper.wait(300)\n    await nvim.call('coc#float#close_all', [])\n    let res = await p\n    expect(called).toBeLessThan(10)\n    expect(res).toBe(undefined)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel progress when window not shown","suites":["window notifications"],"updatePoint":{"line":353,"column":50},"line":353,"code":"  it('should cancel progress when window not shown', async () => {\n    let called = 0\n    let p = window.withProgress({ title: 'Process' }, () => {\n      called = called + 1\n      return Promise.resolve()\n    })\n    await p\n    await helper.wait(120)\n    let floats = await helper.getFloats()\n    expect(called).toBe(1)\n    expect(floats.length).toBe(0)\n  })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have initialized","suites":["workspace properties"],"updatePoint":{"line":38,"column":29},"line":38,"code":"  it('should have initialized', () => {\n    let { nvim, rootPath, cwd, documents, initialized, textDocuments } = workspace\n    expect(nvim).toBeTruthy()\n    expect(initialized).toBe(true)\n    expect(documents.length).toBe(1)\n    expect(textDocuments.length).toBe(1)\n    expect(rootPath).toBe(process.cwd())\n    expect(cwd).toBe(process.cwd())\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add workspaceFolder","suites":["workspace properties"],"updatePoint":{"line":48,"column":32},"line":48,"code":"  it('should add workspaceFolder', async () => {\n    await helper.edit()\n    let { workspaceFolders, workspaceFolder } = workspace\n    expect(workspaceFolders.length).toBe(1)\n    expect(workspaceFolders[0].name).toBe('coc.nvim')\n    expect(workspaceFolder.name).toBe('coc.nvim')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check isVim and isNvim","suites":["workspace properties"],"updatePoint":{"line":56,"column":35},"line":56,"code":"  it('should check isVim and isNvim', async () => {\n    let { isVim, isNvim } = workspace\n    expect(isVim).toBe(false)\n    expect(isNvim).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return plugin root","suites":["workspace properties"],"updatePoint":{"line":62,"column":31},"line":62,"code":"  it('should return plugin root', () => {\n    let { pluginRoot } = workspace\n    expect(typeof pluginRoot).toBe('string')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ready","suites":["workspace properties"],"updatePoint":{"line":67,"column":18},"line":67,"code":"  it('should ready', async () => {\n    (workspace as any)._initialized = false\n    let p = workspace.ready\n      ; (workspace as any)._initialized = true\n      ; (workspace as any)._onDidWorkspaceInitialized.fire(void 0)\n    await p\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get filetyps","suites":["workspace properties"],"updatePoint":{"line":75,"column":25},"line":75,"code":"  it('should get filetyps', async () => {\n    await helper.edit('f.js')\n    let filetypes = workspace.filetypes\n    expect(filetypes.has('javascript')).toBe(true)\n    let languageIds = workspace.languageIds\n    expect(languageIds.has('javascript')).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply TextEdit of documentChanges","suites":["workspace applyEdits"],"updatePoint":{"line":85,"column":46},"line":85,"code":"  it('should apply TextEdit of documentChanges', async () => {\n    let doc = await helper.createDocument()\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, doc.version)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not apply TextEdit if version miss match","suites":["workspace applyEdits"],"updatePoint":{"line":99,"column":53},"line":99,"code":"  it('should not apply TextEdit if version miss match', async () => {\n    let doc = await helper.createDocument()\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, 10)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits with changes to buffer","suites":["workspace applyEdits"],"updatePoint":{"line":111,"column":47},"line":111,"code":"  it('should apply edits with changes to buffer', async () => {\n    let doc = await helper.createDocument()\n    let changes = {\n      [doc.uri]: [TextEdit.insert(Position.create(0, 0), 'bar')]\n    }\n    let workspaceEdit: WorkspaceEdit = { changes }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits with changes to file not in buffer list","suites":["workspace applyEdits"],"updatePoint":{"line":123,"column":64},"line":123,"code":"  it('should apply edits with changes to file not in buffer list', async () => {\n    let filepath = await createTmpFile('bar')\n    let uri = URI.file(filepath).toString()\n    let changes = {\n      [uri]: [TextEdit.insert(Position.create(0, 0), 'foo')]\n    }\n    let res = await workspace.applyEdit({ changes })\n    expect(res).toBe(true)\n    let doc = workspace.getDocument(uri)\n    let content = doc.getDocumentContent()\n    expect(content).toMatch(/^foobar/)\n    await nvim.command('silent! %bwipeout!')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits when file not exists","suites":["workspace applyEdits"],"updatePoint":{"line":137,"column":45},"line":137,"code":"  it('should apply edits when file not exists', async () => {\n    let filepath = path.join(__dirname, 'not_exists')\n    let uri = URI.file(filepath).toString()\n    let changes = {\n      [uri]: [TextEdit.insert(Position.create(0, 0), 'foo')]\n    }\n    let res = await workspace.applyEdit({ changes })\n    expect(res).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor position after applyEdits","suites":["workspace applyEdits"],"updatePoint":{"line":147,"column":52},"line":147,"code":"  it('should adjust cursor position after applyEdits', async () => {\n    let doc = await helper.createDocument()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 0 })\n    let edit = TextEdit.insert(Position.create(0, 0), 'foo\\n')\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, null)\n    let documentChanges = [TextDocumentEdit.create(versioned, [edit])]\n    let res = await workspace.applyEdit({ documentChanges })\n    expect(res).toBe(true)\n    pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 1, character: 0 })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support null version of documentChanges","suites":["workspace applyEdits"],"updatePoint":{"line":160,"column":52},"line":160,"code":"  it('should support null version of documentChanges', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let uri = URI.file(file).toString()\n    let versioned = VersionedTextDocumentIdentifier.create(uri, null)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await nvim.command('wa')\n    let content = await readFile(file, 'utf8')\n    expect(content).toMatch(/^bar/)\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support CreateFile edit","suites":["workspace applyEdits"],"updatePoint":{"line":178,"column":36},"line":178,"code":"  it('should support CreateFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [CreateFile.create(uri, { overwrite: true })]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support DeleteFile edit","suites":["workspace applyEdits"],"updatePoint":{"line":189,"column":36},"line":189,"code":"  it('should support DeleteFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [DeleteFile.create(uri)]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check uri for CreateFile edit","suites":["workspace applyEdits"],"updatePoint":{"line":200,"column":42},"line":200,"code":"  it('should check uri for CreateFile edit', async () => {\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [CreateFile.create('term://.', { overwrite: true })]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support RenameFile edit","suites":["workspace applyEdits"],"updatePoint":{"line":208,"column":36},"line":208,"code":"  it('should support RenameFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let newFile = path.join(__dirname, 'bar')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [RenameFile.create(uri, URI.file(newFile).toString())]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await workspace.deleteFile(newFile, { ignoreIfNotExists: true })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support changes with edit and rename","suites":["workspace applyEdits"],"updatePoint":{"line":221,"column":49},"line":221,"code":"  it('should support changes with edit and rename', async () => {\n    let file = await createTmpFile('test')\n    let doc = await helper.createDocument(file)\n    let newFile = path.join(os.tmpdir(), `coc-${process.pid}/new-${uuid()}`)\n    let newUri = URI.file(newFile).toString()\n    let edit: WorkspaceEdit = {\n      documentChanges: [\n        {\n          textDocument: {\n            version: null,\n            uri: doc.uri,\n          },\n          edits: [\n            {\n              range: {\n                start: {\n                  line: 0,\n                  character: 0\n                },\n                end: {\n                  line: 0,\n                  character: 4\n                }\n              },\n              newText: 'bar'\n            }\n          ]\n        },\n        {\n          oldUri: doc.uri,\n          newUri,\n          kind: 'rename'\n        }\n      ]\n    }\n    let res = await workspace.applyEdit(edit)\n    expect(res).toBe(true)\n    let curr = await workspace.document\n    expect(curr.uri).toBe(newUri)\n    expect(curr.getline(0)).toBe('bar')\n    let line = await nvim.line\n    expect(line).toBe('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support edit new file with CreateFile","suites":["workspace applyEdits"],"updatePoint":{"line":265,"column":50},"line":265,"code":"  it('should support edit new file with CreateFile', async () => {\n    let file = path.join(os.tmpdir(), 'foo')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [\n        CreateFile.create(uri, { overwrite: true }),\n        TextDocumentEdit.create({ uri, version: 0 }, [\n          TextEdit.insert(Position.create(0, 0), 'foo bar')\n        ])\n      ]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let doc = workspace.getDocument(uri)\n    expect(doc).toBeDefined()\n    let line = doc.getline(0)\n    expect(line).toBe('foo bar')\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should selected range","suites":["workspace methods"],"updatePoint":{"line":287,"column":27},"line":287,"code":"  it('should selected range', async () => {\n    let buf = await helper.edit()\n    await nvim.setLine('foobar')\n    await nvim.command('normal! viw')\n    await nvim.eval(`feedkeys(\"\\\\<Esc>\", 'in')`)\n    let doc = workspace.getDocument(buf.id)\n    let range = await workspace.getSelectedRange('v', doc)\n    expect(range).toEqual({ start: { line: 0, character: 0 }, end: { line: 0, character: 6 } })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get the document","suites":["workspace methods"],"updatePoint":{"line":297,"column":29},"line":297,"code":"  it('should get the document', async () => {\n    let buf = await helper.edit()\n    let doc = workspace.getDocument(buf.id)\n    expect(doc.buffer.equals(buf)).toBeTruthy()\n    doc = workspace.getDocument(doc.uri)\n    expect(doc.buffer.equals(buf)).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options","suites":["workspace methods"],"updatePoint":{"line":305,"column":31},"line":305,"code":"  it('should get format options', async () => {\n    let opts = await workspace.getFormatOptions()\n    expect(opts.insertSpaces).toBe(true)\n    expect(opts.tabSize).toBe(2)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options of current buffer","suites":["workspace methods"],"updatePoint":{"line":311,"column":49},"line":311,"code":"  it('should get format options of current buffer', async () => {\n    let buf = await helper.edit()\n    await buf.setOption('shiftwidth', 8)\n    await buf.setOption('expandtab', false)\n    let doc = workspace.getDocument(buf.id)\n    let opts = await workspace.getFormatOptions(doc.uri)\n    expect(opts.insertSpaces).toBe(false)\n    expect(opts.tabSize).toBe(8)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options when uri not exists","suites":["workspace methods"],"updatePoint":{"line":321,"column":51},"line":321,"code":"  it('should get format options when uri not exists', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    let opts = await workspace.getFormatOptions(uri)\n    expect(opts.insertSpaces).toBe(true)\n    expect(opts.tabSize).toBe(2)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get config files","suites":["workspace methods"],"updatePoint":{"line":328,"column":29},"line":328,"code":"  it('should get config files', async () => {\n    let file = workspace.getConfigFile(ConfigurationTarget.Global)\n    expect(file).toBeFalsy()\n    file = workspace.getConfigFile(ConfigurationTarget.User)\n    expect(file).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file watcher","suites":["workspace methods"],"updatePoint":{"line":335,"column":32},"line":335,"code":"  it('should create file watcher', async () => {\n    let watcher = workspace.createFileSystemWatcher('**/*.ts')\n    expect(watcher).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get quickfix item from Location","suites":["workspace methods"],"updatePoint":{"line":340,"column":44},"line":340,"code":"  it('should get quickfix item from Location', async () => {\n    let filepath = await createTmpFile('quickfix')\n    let uri = URI.file(filepath).toString()\n    let p = Position.create(0, 0)\n    let loc = Location.create(uri, Range.create(p, p))\n    let item = await workspace.getQuickfixItem(loc)\n    expect(item.filename).toBe(filepath)\n    expect(item.text).toBe('quickfix')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get quickfix list from Locations","suites":["workspace methods"],"updatePoint":{"line":350,"column":45},"line":350,"code":"  it('should get quickfix list from Locations', async () => {\n    let filepathA = await createTmpFile('fileA:1\\nfileA:2\\nfileA:3')\n    let uriA = URI.file(filepathA).toString()\n    let filepathB = await createTmpFile('fileB:1\\nfileB:2\\nfileB:3')\n    let uriB = URI.file(filepathB).toString()\n    let p1 = Position.create(0, 0)\n    let p2 = Position.create(1, 0)\n    let locations: Location[] = []\n    locations.push(Location.create(uriA, Range.create(p1, p1)))\n    locations.push(Location.create(uriA, Range.create(p2, p2)))\n    locations.push(Location.create(uriB, Range.create(p1, p1)))\n    locations.push(Location.create(uriB, Range.create(p2, p2)))\n    let items = await workspace.getQuickfixList(locations)\n    expect(items[0].filename).toBe(filepathA)\n    expect(items[0].text).toBe('fileA:1')\n    expect(items[1].filename).toBe(filepathA)\n    expect(items[1].text).toBe('fileA:2')\n    expect(items[2].filename).toBe(filepathB)\n    expect(items[2].text).toBe('fileB:1')\n    expect(items[3].filename).toBe(filepathB)\n    expect(items[3].text).toBe('fileB:2')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get line of document","suites":["workspace methods"],"updatePoint":{"line":373,"column":33},"line":373,"code":"  it('should get line of document', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('abc')\n    let line = await workspace.getLine(doc.uri, 0)\n    expect(line).toBe('abc')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get line of file","suites":["workspace methods"],"updatePoint":{"line":380,"column":29},"line":380,"code":"  it('should get line of file', async () => {\n    let filepath = await createTmpFile('quickfix')\n    let uri = URI.file(filepath).toString()\n    let line = await workspace.getLine(uri, 0)\n    expect(line).toBe('quickfix')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read content from buffer","suites":["workspace methods"],"updatePoint":{"line":387,"column":37},"line":387,"code":"  it('should read content from buffer', async () => {\n    let doc = await helper.createDocument()\n    await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'foo' }])\n    let line = await workspace.readFile(doc.uri)\n    expect(line).toBe('foo\\n')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read content from file","suites":["workspace methods"],"updatePoint":{"line":394,"column":35},"line":394,"code":"  it('should read content from file', async () => {\n    let filepath = await createTmpFile('content')\n    let content = await workspace.readFile(URI.file(filepath).toString())\n    expect(content).toBe(content)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current document","suites":["workspace methods"],"updatePoint":{"line":400,"column":33},"line":400,"code":"  it('should get current document', async () => {\n    let buf = await helper.edit('foo')\n    let doc = await workspace.document\n    expect(doc.bufnr).toBe(buf.id)\n    buf = await helper.edit('tmp')\n    doc = await workspace.document\n    expect(doc.bufnr).toBe(buf.id)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand filepath","suites":["workspace methods"],"updatePoint":{"line":409,"column":28},"line":409,"code":"  it('should expand filepath', async () => {\n    let home = os.homedir()\n    let res = workspace.expand('~/$NODE_ENV/')\n    expect(res.startsWith(home)).toBeTruthy()\n    expect(res).toContain(process.env.NODE_ENV)\n\n    res = workspace.expand('$HOME/$NODE_ENV/')\n    expect(res.startsWith(home)).toBeTruthy()\n    expect(res).toContain(process.env.NODE_ENV)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand variables","suites":["workspace methods"],"updatePoint":{"line":420,"column":29},"line":420,"code":"  it('should expand variables', async () => {\n    expect(workspace.expand('${workspace}/foo')).toBe(`${workspace.root}/foo`)\n    expect(workspace.expand('${env:NODE_ENV}')).toBe(process.env.NODE_ENV)\n    expect(workspace.expand('${cwd}')).toBe(workspace.cwd)\n    let folder = path.dirname(workspace.root)\n    expect(workspace.expand('${workspaceFolderBasename}')).toBe(folder)\n    await helper.edit('bar.ts')\n    expect(workspace.expand('${file}')).toContain('bar')\n    expect(workspace.expand('${fileDirname}')).toBe(path.dirname(__dirname))\n    expect(workspace.expand('${fileExtname}')).toBe('.ts')\n    expect(workspace.expand('${fileBasename}')).toBe('bar.ts')\n    expect(workspace.expand('${fileBasenameNoExtension}')).toBe('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run command","suites":["workspace methods"],"updatePoint":{"line":434,"column":24},"line":434,"code":"  it('should run command', async () => {\n    let res = await workspace.runCommand('ls', __dirname, 1)\n    expect(res).toMatch('workspace')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve module path if exists","suites":["workspace methods"],"updatePoint":{"line":439,"column":42},"line":439,"code":"  it('should resolve module path if exists', async () => {\n    let res = await workspace.resolveModule('typescript')\n    expect(res).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve module if not exists","suites":["workspace methods"],"updatePoint":{"line":444,"column":45},"line":444,"code":"  it('should not resolve module if not exists', async () => {\n    let res = await workspace.resolveModule('foo')\n    expect(res).toBeFalsy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return match score for document","suites":["workspace methods"],"updatePoint":{"line":449,"column":44},"line":449,"code":"  it('should return match score for document', async () => {\n    let doc = await helper.createDocument('tmp.xml')\n    expect(workspace.match(['xml'], doc.textDocument)).toBe(10)\n    expect(workspace.match(['wxml'], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ language: 'xml' }], doc.textDocument)).toBe(10)\n    expect(workspace.match([{ language: 'wxml' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ pattern: '**/*.xml' }], doc.textDocument)).toBe(5)\n    expect(workspace.match([{ pattern: '**/*.html' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ scheme: 'file' }], doc.textDocument)).toBe(5)\n    expect(workspace.match([{ scheme: 'term' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ language: 'xml' }, { scheme: 'file' }], doc.textDocument)).toBe(10)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create terminal","suites":["workspace methods"],"updatePoint":{"line":462,"column":28},"line":462,"code":"  it('should create terminal', async () => {\n    let terminal = await workspace.createTerminal({ name: 'test' })\n    let pid = await terminal.processId\n    expect(typeof pid == 'number').toBe(true)\n    terminal.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename buffer","suites":["workspace methods"],"updatePoint":{"line":469,"column":26},"line":469,"code":"  it('should rename buffer', async () => {\n    await helper.createDocument('a')\n    let p = workspace.renameCurrent()\n    await helper.wait(30)\n    await nvim.input('<backspace>b<cr>')\n    await p\n    let name = await nvim.eval('bufname(\"%\")') as string\n    expect(name.endsWith('b')).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename file","suites":["workspace methods"],"updatePoint":{"line":479,"column":24},"line":479,"code":"  it('should rename file', async () => {\n    let cwd = await nvim.call('getcwd')\n    let file = path.join(cwd, 'a')\n    fs.writeFileSync(file, 'foo', 'utf8')\n    await helper.createDocument('a')\n    let p = workspace.renameCurrent()\n    await helper.wait(30)\n    await nvim.input('<backspace>b<cr>')\n    await p\n    let name = await nvim.eval('bufname(\"%\")') as string\n    expect(name.endsWith('b')).toBe(true)\n    expect(fs.existsSync(path.join(cwd, 'b'))).toBe(true)\n    fs.unlinkSync(path.join(cwd, 'b'))\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support float","suites":["workspace utility"],"updatePoint":{"line":497,"column":26},"line":497,"code":"  it('should support float', async () => {\n    let floatSupported = workspace.floatSupported\n    expect(floatSupported).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should loadFile","suites":["workspace utility"],"updatePoint":{"line":502,"column":21},"line":502,"code":"  it('should loadFile', async () => {\n    let doc = await helper.createDocument()\n    let newFile = URI.file(path.join(__dirname, 'abc')).toString()\n    let document = await workspace.loadFile(newFile)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(document.uri.endsWith('abc')).toBe(true)\n    expect(bufnr).toBe(doc.bufnr)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should loadFiles","suites":["workspace utility"],"updatePoint":{"line":511,"column":22},"line":511,"code":"  it('should loadFiles', async () => {\n    let files = ['a', 'b', 'c'].map(key => URI.file(path.join(__dirname, key)).toString())\n    await workspace.loadFiles(files)\n    for (let file of files) {\n      let uri = URI.file(file).toString()\n      let doc = workspace.getDocument(uri)\n      expect(doc).toBeDefined()\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create file if document exists","suites":["workspace utility"],"updatePoint":{"line":521,"column":47},"line":521,"code":"  it('should not create file if document exists', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    await workspace.createFile(filepath, { ignoreIfExists: false })\n    let exists = fs.existsSync(filepath)\n    expect(exists).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file if parent folder not exists","suites":["workspace utility"],"updatePoint":{"line":529,"column":52},"line":529,"code":"  it('should create file if parent folder not exists', async () => {\n    const folder = path.join(__dirname, 'foo')\n    const filepath = path.join(folder, 'bar')\n    await workspace.createFile(filepath)\n    const exists = fs.existsSync(filepath)\n    expect(exists).toBe(true)\n    fs.unlinkSync(filepath)\n    fs.rmdirSync(folder)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create file if file exists with ignoreIfExists","suites":["workspace utility"],"updatePoint":{"line":539,"column":63},"line":539,"code":"  it('should not create file if file exists with ignoreIfExists', async () => {\n    let file = await createTmpFile('foo')\n    await workspace.createFile(file, { ignoreIfExists: true })\n    let content = fs.readFileSync(file, 'utf8')\n    expect(content).toBe('foo')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file if not exists","suites":["workspace utility"],"updatePoint":{"line":546,"column":38},"line":546,"code":"  it('should create file if not exists', async () => {\n    await helper.edit()\n    let filepath = path.join(__dirname, 'foo')\n    await workspace.createFile(filepath, { ignoreIfExists: true })\n    let exists = fs.existsSync(filepath)\n    expect(exists).toBe(true)\n    fs.unlinkSync(filepath)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create folder if not exists","suites":["workspace utility"],"updatePoint":{"line":555,"column":40},"line":555,"code":"  it('should create folder if not exists', async () => {\n    let filepath = path.join(__dirname, 'bar/')\n    await workspace.createFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(true)\n    fs.rmdirSync(filepath)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on folder create if overwrite is true","suites":["workspace utility"],"updatePoint":{"line":562,"column":60},"line":562,"code":"  it('should not throw on folder create if overwrite is true', async () => {\n    let filepath = path.join(__dirname, 'bar/')\n    await workspace.createFile(filepath)\n    await workspace.createFile(filepath, { overwrite: true })\n    expect(fs.existsSync(filepath)).toBe(true)\n    fs.rmdirSync(filepath)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename if file not exists","suites":["workspace utility"],"updatePoint":{"line":570,"column":38},"line":570,"code":"  it('should rename if file not exists', async () => {\n    let filepath = path.join(__dirname, 'foo')\n    let newPath = path.join(__dirname, 'bar')\n    await workspace.createFile(filepath)\n    await workspace.renameFile(filepath, newPath)\n    expect(fs.existsSync(newPath)).toBe(true)\n    expect(fs.existsSync(filepath)).toBe(false)\n    fs.unlinkSync(newPath)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename current buffer with another buffer","suites":["workspace utility"],"updatePoint":{"line":580,"column":54},"line":580,"code":"  it('should rename current buffer with another buffer', async () => {\n    let file = await createTmpFile('test')\n    let doc = await helper.createDocument(file)\n    await nvim.setLine('bar')\n    await helper.wait(50)\n    let newFile = path.join(os.tmpdir(), `coc-${process.pid}/new-${uuid()}`)\n    await workspace.renameFile(file, newFile)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBeGreaterThan(doc.bufnr)\n    let line = await nvim.line\n    expect(line).toBe('bar')\n    let exists = fs.existsSync(newFile)\n    expect(exists).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should overwrite if file exists","suites":["workspace utility"],"updatePoint":{"line":595,"column":37},"line":595,"code":"  it('should overwrite if file exists', async () => {\n    let filepath = path.join(os.tmpdir(), uuid())\n    let newPath = path.join(os.tmpdir(), uuid())\n    await workspace.createFile(filepath)\n    await workspace.createFile(newPath)\n    await workspace.renameFile(filepath, newPath, { overwrite: true })\n    expect(fs.existsSync(newPath)).toBe(true)\n    expect(fs.existsSync(filepath)).toBe(false)\n    fs.unlinkSync(newPath)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete file if exists","suites":["workspace utility"],"updatePoint":{"line":606,"column":34},"line":606,"code":"  it('should delete file if exists', async () => {\n    let filepath = path.join(__dirname, 'foo')\n    await workspace.createFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(true)\n    await workspace.deleteFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete folder if exists","suites":["workspace utility"],"updatePoint":{"line":614,"column":36},"line":614,"code":"  it('should delete folder if exists', async () => {\n    let filepath = path.join(__dirname, 'foo/')\n    await workspace.createFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(true)\n    await workspace.deleteFile(filepath, { recursive: true })\n    expect(fs.existsSync(filepath)).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open resource","suites":["workspace utility"],"updatePoint":{"line":622,"column":26},"line":622,"code":"  it('should open resource', async () => {\n    let uri = URI.file(path.join(os.tmpdir(), 'bar')).toString()\n    await workspace.openResource(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open none file uri","suites":["workspace utility"],"updatePoint":{"line":630,"column":31},"line":630,"code":"  it('should open none file uri', async () => {\n    let uri = 'jdi://abc'\n    await workspace.openResource(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe('jdi://abc')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open opened buffer","suites":["workspace utility"],"updatePoint":{"line":638,"column":31},"line":638,"code":"  it('should open opened buffer', async () => {\n    let buf = await helper.edit()\n    let doc = workspace.getDocument(buf.id)\n    await workspace.openResource(doc.uri)\n    await helper.wait(30)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(bufnr).toBe(buf.id)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open url","suites":["workspace utility"],"updatePoint":{"line":647,"column":21},"line":647,"code":"  it('should open url', async () => {\n    await helper.mockFunction('coc#util#open_url', 0)\n    let buf = await helper.edit()\n    let uri = 'http://example.com'\n    await workspace.openResource(uri)\n    await helper.wait(30)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(bufnr).toBe(buf.id)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create database","suites":["workspace utility"],"updatePoint":{"line":657,"column":28},"line":657,"code":"  it('should create database', async () => {\n    let db = workspace.createDatabase('test')\n    let res = db.exists('xyz')\n    expect(res).toBe(false)\n    db.destroy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current state","suites":["workspace utility"],"updatePoint":{"line":664,"column":30},"line":664,"code":"  it('should get current state', async () => {\n    let buf = await helper.edit()\n    await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    await nvim.call('cursor', [2, 2])\n    let doc = workspace.getDocument(buf.id)\n    let state = await workspace.getCurrentState()\n    expect(doc.uri).toBe(state.document.uri)\n    expect(state.position).toEqual({ line: 1, character: 1 })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo position","suites":["workspace utility"],"updatePoint":{"line":674,"column":28},"line":674,"code":"  it('should jumpTo position', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    await nvim.command('setl buftype=nofile')\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('/foo')\n    await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    let pos = await nvim.call('getcurpos')\n    expect(pos.slice(1, 3)).toEqual([2, 2])\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo uri without normalize","suites":["workspace utility"],"updatePoint":{"line":687,"column":41},"line":687,"code":"  it('should jumpTo uri without normalize', async () => {\n    let uri = 'zipfile:///tmp/clojure-1.9.0.jar::clojure/core.clj'\n    await workspace.jumpTo(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe(uri)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump without position","suites":["workspace utility"],"updatePoint":{"line":695,"column":34},"line":695,"code":"  it('should jump without position', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    await workspace.jumpTo(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('/foo')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo custom uri scheme","suites":["workspace utility"],"updatePoint":{"line":703,"column":37},"line":703,"code":"  it('should jumpTo custom uri scheme', async () => {\n    let uri = 'jdt://foo'\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe(uri)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should findUp to tsconfig.json from current file","suites":["workspace utility"],"updatePoint":{"line":711,"column":54},"line":711,"code":"  it('should findUp to tsconfig.json from current file', async () => {\n    await helper.edit(path.join(__dirname, 'edit'))\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toMatch('tsconfig.json')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should findUp from current file ","suites":["workspace utility"],"updatePoint":{"line":717,"column":38},"line":717,"code":"  it('should findUp from current file ', async () => {\n    await helper.edit('foo')\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toMatch('tsconfig.json')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not findUp from file in other directory","suites":["workspace utility"],"updatePoint":{"line":723,"column":52},"line":723,"code":"  it('should not findUp from file in other directory', async () => {\n    await nvim.command(`edit ${path.join(os.tmpdir(), 'foo')}`)\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toBeNull()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolveRootPath","suites":["workspace utility"],"updatePoint":{"line":729,"column":28},"line":729,"code":"  it('should resolveRootPath', async () => {\n    let file = path.join(__dirname, 'foo')\n    let uri = URI.file(file)\n    let res = await workspace.resolveRootFolder(uri, ['.git'])\n    expect(res).toMatch('coc.nvim')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register autocmd","suites":["workspace utility"],"updatePoint":{"line":736,"column":29},"line":736,"code":"  it('should register autocmd', async () => {\n    let event: any\n    let eventCount = 0\n    let disposables = []\n    disposables.push(workspace.registerAutocmd({\n      event: 'TextYankPost',\n      arglist: ['v:event'],\n      callback: ev => {\n        eventCount += 1\n        event = ev\n      }\n    }))\n    disposables.push(workspace.registerAutocmd({\n      event: ['InsertEnter', 'CursorMoved'],\n      callback: () => {\n        eventCount += 1\n      }\n    }))\n    await nvim.setLine('foo')\n    await helper.wait(30)\n    await nvim.command('normal! yy')\n    await helper.wait(30)\n    await nvim.command('normal! Abar')\n    await helper.wait(30)\n    expect(event.regtype).toBe('V')\n    expect(event.operator).toBe('y')\n    expect(event.regcontents).toEqual(['foo'])\n    expect(eventCount).toBeGreaterThan(2)\n    disposables.forEach(d => d.dispose())\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist keymap","suites":["workspace utility"],"updatePoint":{"line":767,"column":26},"line":767,"code":"  it('should regist keymap', async () => {\n    let fn = jest.fn()\n    await nvim.command('nmap go <Plug>(coc-echo)')\n    let disposable = workspace.registerKeymap(['n', 'v'], 'echo', fn, { sync: true })\n    await helper.wait(30)\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.call('feedkeys', ['go', 'i'])\n    await helper.wait(10)\n    expect(fn).toBeCalledTimes(1)\n    disposable.dispose()\n    await nvim.call('feedkeys', ['go', 'i'])\n    await helper.wait(10)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist expr keymap","suites":["workspace utility"],"updatePoint":{"line":783,"column":31},"line":783,"code":"  it('should regist expr keymap', async () => {\n    let called = false\n    let fn = () => {\n      called = true\n      return '\"\"'\n    }\n    await nvim.input('i')\n    let { mode } = await nvim.mode\n    expect(mode).toBe('i')\n    let disposable = workspace.registerExprKeymap('i', '\"', fn)\n    await helper.wait(30)\n    await nvim.call('feedkeys', ['\"', 't'])\n    await helper.wait(30)\n    expect(called).toBe(true)\n    let line = await nvim.line\n    expect(line).toBe('\"\"')\n    disposable.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist buffer expr keymap","suites":["workspace utility"],"updatePoint":{"line":802,"column":38},"line":802,"code":"  it('should regist buffer expr keymap', async () => {\n    let fn = () => '\"\"'\n    await nvim.input('i')\n    let disposable = workspace.registerExprKeymap('i', '\"', fn, true)\n    await helper.wait(30)\n    await nvim.call('feedkeys', ['\"', 't'])\n    await helper.wait(30)\n    let line = await nvim.line\n    expect(line).toBe('\"\"')\n    disposable.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch options","suites":["workspace utility"],"updatePoint":{"line":814,"column":26},"line":814,"code":"  it('should watch options', async () => {\n    let fn = jest.fn()\n    workspace.watchOption('showmode', fn, disposables)\n    await helper.wait(30)\n    await nvim.command('set showmode')\n    await helper.wait(30)\n    expect(fn).toBeCalled()\n    await nvim.command('noa set noshowmode')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch global","suites":["workspace utility"],"updatePoint":{"line":824,"column":25},"line":824,"code":"  it('should watch global', async () => {\n    let fn = jest.fn()\n    workspace.watchGlobal('x', fn, disposables)\n    await nvim.command('let g:x = 1')\n    await helper.wait(30)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check nvim version","suites":["workspace utility"],"updatePoint":{"line":831,"column":31},"line":831,"code":"  it('should check nvim version', async () => {\n    expect(workspace.has('patch-7.4.248')).toBe(false)\n    expect(workspace.has('nvim-0.5.0')).toBe(true)\n    expect(workspace.has('nvim-0.9.0')).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should listen to fileType change","suites":["workspace events"],"updatePoint":{"line":840,"column":38},"line":840,"code":"  it('should listen to fileType change', async () => {\n    let buf = await helper.edit()\n    await nvim.command('setf xml')\n    await helper.wait(40)\n    let doc = workspace.getDocument(buf.id)\n    expect(doc.filetype).toBe('xml')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should listen optionSet","suites":["workspace events"],"updatePoint":{"line":848,"column":29},"line":848,"code":"  it('should listen optionSet', async () => {\n    let opt = workspace.completeOpt\n    expect(opt).toMatch('menuone')\n    await nvim.command('set completeopt=menu,preview')\n    await helper.wait(50)\n    opt = workspace.completeOpt\n    expect(opt).toBe('menu,preview')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidOpenTextDocument","suites":["workspace events"],"updatePoint":{"line":857,"column":39},"line":857,"code":"  it('should fire onDidOpenTextDocument', async () => {\n    let fn = jest.fn()\n    workspace.onDidOpenTextDocument(fn, null, disposables)\n    await helper.edit()\n    await helper.wait(30)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidChangeTextDocument","suites":["workspace events"],"updatePoint":{"line":865,"column":41},"line":865,"code":"  it('should fire onDidChangeTextDocument', async () => {\n    let fn = jest.fn()\n    await helper.edit()\n    workspace.onDidChangeTextDocument(fn, null, disposables)\n    await nvim.setLine('foo')\n    let doc = await workspace.document\n    doc.forceSync()\n    await helper.wait(20)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidChangeConfiguration","suites":["workspace events"],"updatePoint":{"line":876,"column":42},"line":876,"code":"  it('should fire onDidChangeConfiguration', async () => {\n    await helper.createDocument()\n    let fn = jest.fn()\n    let disposable = workspace.onDidChangeConfiguration(e => {\n      disposable.dispose()\n      expect(e.affectsConfiguration('tsserver')).toBe(true)\n      expect(e.affectsConfiguration('tslint')).toBe(false)\n      fn()\n    })\n    let config = workspace.getConfiguration('tsserver')\n    config.update('enable', false)\n    await helper.wait(100)\n    expect(fn).toHaveBeenCalledTimes(1)\n    config.update('enable', undefined)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty configuration for none exists section","suites":["workspace events"],"updatePoint":{"line":892,"column":60},"line":892,"code":"  it('should get empty configuration for none exists section', () => {\n    let config = workspace.getConfiguration('notexists')\n    let keys = Object.keys(config)\n    expect(keys.length).toBe(0)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onWillSaveUntil","suites":["workspace events"],"updatePoint":{"line":898,"column":33},"line":898,"code":"  it('should fire onWillSaveUntil', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    let fn = jest.fn()\n    let disposable = workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        fn()\n        let edit: TextEdit = {\n          newText: 'foo',\n          range: Range.create(0, 0, 0, 0)\n        }\n        resolve([edit])\n      })\n      event.waitUntil(promise)\n    })\n    await helper.wait(100)\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await events.fire('BufWritePre', [doc.bufnr])\n    await helper.wait(30)\n    let content = doc.getDocumentContent()\n    expect(content.startsWith('foobar')).toBe(true)\n    disposable.dispose()\n    expect(fn).toBeCalledTimes(1)\n    if (fs.existsSync(filepath)) {\n      fs.unlinkSync(filepath)\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not work for async waitUntil","suites":["workspace events"],"updatePoint":{"line":927,"column":41},"line":927,"code":"  it('should not work for async waitUntil', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    let disposable = workspace.onWillSaveTextDocument(event => {\n      setTimeout(() => {\n        let edit: TextEdit = {\n          newText: 'foo',\n          range: Range.create(0, 0, 0, 0)\n        }\n        event.waitUntil(Promise.resolve([edit]))\n      }, 30)\n    })\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await nvim.command('wa')\n    let content = doc.getDocumentContent()\n    expect(content).toMatch('bar')\n    disposable.dispose()\n    if (fs.existsSync(filepath)) {\n      fs.unlinkSync(filepath)\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only use first returned textEdits","suites":["workspace events"],"updatePoint":{"line":950,"column":46},"line":950,"code":"  it('should only use first returned textEdits', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    let disposables: Disposable[] = []\n    workspace.onWillSaveTextDocument(event => {\n      event.waitUntil(Promise.resolve(undefined))\n    }, null, disposables)\n    workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        setTimeout(() => {\n          let edit: TextEdit = {\n            newText: 'foo',\n            range: Range.create(0, 0, 0, 0)\n          }\n          resolve([edit])\n        }, 10)\n      })\n      event.waitUntil(promise)\n    }, null, disposables)\n    workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        setTimeout(() => {\n          let edit: TextEdit = {\n            newText: 'bar',\n            range: Range.create(0, 0, 0, 0)\n          }\n          resolve([edit])\n        }, 30)\n      })\n      event.waitUntil(promise)\n    }, null, disposables)\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await nvim.command('wa')\n    let content = doc.getDocumentContent()\n    expect(content).toMatch('foo')\n    disposeAll(disposables)\n    if (fs.existsSync(filepath)) {\n      fs.unlinkSync(filepath)\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach & detach","suites":["workspace events"],"updatePoint":{"line":992,"column":28},"line":992,"code":"  it('should attach & detach', async () => {\n    let buf = await helper.edit()\n    await nvim.command('CocDisable')\n    await helper.wait(100)\n    let doc = workspace.getDocument(buf.id)\n    expect(doc).toBeUndefined()\n    await nvim.command('CocEnable')\n    await helper.wait(100)\n    doc = workspace.getDocument(buf.id)\n    expect(doc.bufnr).toBe(buf.id)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create document with same bufnr","suites":["workspace events"],"updatePoint":{"line":1004,"column":44},"line":1004,"code":"  it('should create document with same bufnr', async () => {\n    await nvim.command('tabe')\n    let buf = await helper.edit()\n    await helper.wait(100)\n    let doc = workspace.getDocument(buf.id)\n    expect(doc).toBeDefined()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist document content provider","suites":["workspace textDocument content provider"],"updatePoint":{"line":1015,"column":45},"line":1015,"code":"  it('should regist document content provider', async () => {\n    let provider: TextDocumentContentProvider = {\n      provideTextDocumentContent: (_uri, _token): string => 'sample text'\n    }\n    workspace.registerTextDocumentContentProvider('test', provider)\n    await helper.wait(100)\n    await nvim.command('edit test://1')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['sample text'])\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should react onChagne event of document content provider","suites":["workspace textDocument content provider"],"updatePoint":{"line":1027,"column":62},"line":1027,"code":"  it('should react onChagne event of document content provider', async () => {\n    let text = 'foo'\n    let emitter = new Emitter<URI>()\n    let event = emitter.event\n    let provider: TextDocumentContentProvider = {\n      onDidChange: event,\n      provideTextDocumentContent: (_uri, _token): string => text\n    }\n    workspace.registerTextDocumentContentProvider('jdk', provider)\n    await helper.wait(80)\n    await nvim.command('edit jdk://1')\n    await helper.wait(100)\n    text = 'bar'\n    emitter.fire(URI.parse('jdk://1'))\n    await helper.wait(200)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['bar'])\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist","suites":["workspace registerBufferSync"],"updatePoint":{"line":1049,"column":19},"line":1049,"code":"  it('should regist', async () => {\n    await helper.createDocument()\n    let created = 0\n    let deleted = 0\n    let changed = 0\n    let disposable = workspace.registerBufferSync(() => {\n      created = created + 1\n      return {\n        dispose: () => {\n          deleted += 1\n        },\n        onChange: () => {\n          changed += 1\n        }\n      }\n    })\n    disposables.push(disposable)\n    let doc = await helper.createDocument()\n    expect(created).toBe(2)\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    expect(changed).toBe(1)\n    await nvim.command('bd!')\n    await helper.wait(50)\n    expect(deleted).toBe(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not active when insert plain snippet","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":32,"column":51},"line":32,"code":"    it('should not active when insert plain snippet', async () => {\n      await snippetManager.insertSnippet('foo')\n      let line = await nvim.line\n      expect(line).toBe('foo')\n      expect(snippetManager.session).toBe(null)\n      expect(snippetManager.getSession(doc.bufnr)).toBeUndefined()\n      expect(snippetManager.isActived(doc.bufnr)).toBe(false)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve variables","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":41,"column":32},"line":41,"code":"    it('should resolve variables', async () => {\n      await snippetManager.insertSnippet('${foo:abcdef} ${bar}')\n      let line = await nvim.line\n      expect(line).toBe('abcdef bar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start new session if session exists","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":47,"column":50},"line":47,"code":"    it('should start new session if session exists', async () => {\n      await nvim.setLine('bar')\n      await snippetManager.insertSnippet('${1:foo} ')\n      await helper.wait(100)\n      await nvim.input('<esc>')\n      await nvim.command('stopinsert')\n      await nvim.input('A')\n      await helper.wait(100)\n      let active = await snippetManager.insertSnippet('${2:bar}')\n      expect(active).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('foo barbar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start nest session","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":61,"column":33},"line":61,"code":"    it('should start nest session', async () => {\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      await nvim.input('<backspace>')\n      await helper.wait(100)\n      let active = await snippetManager.insertSnippet('${1:x} $1')\n      expect(active).toBe(true)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not consider plaintext as placeholder","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":69,"column":52},"line":69,"code":"    it('should not consider plaintext as placeholder', async () => {\n      await snippetManager.insertSnippet('${1} ${2:bar}')\n      await nvim.input('$foo;')\n      await helper.wait(100)\n      await snippetManager.insertSnippet('${1:x}', false, Range.create(0, 5, 0, 6))\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toBe('$foo;xbar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert nest plain snippet","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":79,"column":40},"line":79,"code":"    it('should insert nest plain snippet', async () => {\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      await nvim.input('<backspace>')\n      await helper.wait(100)\n      let active = await snippetManager.insertSnippet('bar')\n      expect(active).toBe(true)\n      let cursor = await nvim.call('coc#cursor#position')\n      expect(cursor).toEqual([0, 3])\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with nest snippet","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":89,"column":37},"line":89,"code":"    it('should work with nest snippet', async () => {\n      let buf = await helper.edit()\n      let snip = '<a ${1:http://www.${2:example.com}}>\\n$0\\n</a>'\n      await snippetManager.insertSnippet(snip)\n      await helper.wait(30)\n      await nvim.input('abcde')\n      await helper.wait(100)\n      let lines = await buf.lines\n      expect(lines).toEqual(['<a abcde>', '', '</a>'])\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert snippetString","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":100,"column":35},"line":100,"code":"    it('should insert snippetString', async () => {\n      let snippetString = new SnippetString()\n        .appendTabstop(1)\n        .appendText(' ')\n        .appendPlaceholder('bar', 2)\n      await snippetManager.insertSnippet(snippetString)\n      await nvim.input('$foo;')\n      await helper.wait(100)\n      snippetString = new SnippetString()\n        .appendVariable('foo', 'x')\n      await snippetManager.insertSnippet(snippetString, false, Range.create(0, 5, 0, 6))\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toBe('$foo;xbar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next placeholder","suites":["snippet provider","nextPlaceholder()"],"updatePoint":{"line":118,"column":36},"line":118,"code":"    it('should goto next placeholder', async () => {\n      await snippetManager.insertSnippet('${1:a} ${2:b}')\n      await snippetManager.nextPlaceholder()\n      await helper.wait(30)\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(3)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove keymap on nextPlaceholder when session not exits","suites":["snippet provider","nextPlaceholder()"],"updatePoint":{"line":126,"column":70},"line":126,"code":"    it('should remove keymap on nextPlaceholder when session not exits', async () => {\n      await nvim.call('coc#snippet#enable')\n      await snippetManager.nextPlaceholder()\n      await helper.wait(60)\n      let val = await doc.buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto previous placeholder","suites":["snippet provider","previousPlaceholder()"],"updatePoint":{"line":136,"column":40},"line":136,"code":"    it('should goto previous placeholder', async () => {\n      await snippetManager.insertSnippet('${1:a} ${2:b}')\n      await snippetManager.nextPlaceholder()\n      await snippetManager.previousPlaceholder()\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(1)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove keymap on previousPlaceholder when session not exits","suites":["snippet provider","previousPlaceholder()"],"updatePoint":{"line":144,"column":74},"line":144,"code":"    it('should remove keymap on previousPlaceholder when session not exits', async () => {\n      await nvim.call('coc#snippet#enable')\n      await snippetManager.previousPlaceholder()\n      await helper.wait(60)\n      let val = await doc.buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check position on InsertEnter","suites":["snippet provider","Events"],"updatePoint":{"line":154,"column":44},"line":154,"code":"    it('should check position on InsertEnter', async () => {\n      await nvim.input('ibar<left><left><left>')\n      await snippetManager.insertSnippet('${1:foo} $1 ')\n      await helper.wait(60)\n      await nvim.input('<esc>A')\n      await helper.wait(60)\n      expect(snippetManager.session).toBeNull()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel snippet session","suites":["snippet provider","cancel()"],"updatePoint":{"line":166,"column":37},"line":166,"code":"    it('should cancel snippet session', async () => {\n      let buffer = doc.buffer\n      await nvim.call('coc#snippet#enable')\n      snippetManager.cancel()\n      await helper.wait(60)\n      let val = await buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n      let active = await snippetManager.insertSnippet('${1:foo}')\n      expect(active).toBe(true)\n      snippetManager.cancel()\n      expect(snippetManager.session).toBeNull()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect preferCompleteThanJumpPlaceholder","suites":["snippet provider","configuration"],"updatePoint":{"line":181,"column":56},"line":181,"code":"    it('should respect preferCompleteThanJumpPlaceholder', async () => {\n      let config = workspace.getConfiguration('suggest')\n      config.update('preferCompleteThanJumpPlaceholder', true)\n      await nvim.setLine('foo')\n      await nvim.input('o')\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      await helper.wait(10)\n      await nvim.input('f')\n      await helper.waitPopup()\n      await nvim.input('<C-j>')\n      await helper.wait(200)\n      let line = await nvim.getLine()\n      expect(line).toBe('foo bar')\n      config.update('preferCompleteThanJumpPlaceholder', false)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check jumpable","suites":["snippet provider","jumpable()"],"updatePoint":{"line":199,"column":29},"line":199,"code":"    it('should check jumpable', async () => {\n      await nvim.input('i')\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      let jumpable = snippetManager.jumpable()\n      expect(jumpable).toBe(true)\n      await snippetManager.nextPlaceholder()\n      await helper.wait(30)\n      await snippetManager.nextPlaceholder()\n      await helper.wait(30)\n      jumpable = snippetManager.jumpable()\n      expect(jumpable).toBe(false)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update placeholder on placeholder update","suites":["snippet provider","synchronize text"],"updatePoint":{"line":214,"column":55},"line":214,"code":"    it('should update placeholder on placeholder update', async () => {\n      await snippetManager.insertSnippet('$1\\n${1/,/,\\\\n/g}')\n      await nvim.input('a,b')\n      await helper.wait(50)\n      doc.forceSync()\n      await helper.wait(200)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['a,b', 'a,', 'b'])\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor position on update","suites":["snippet provider","synchronize text"],"updatePoint":{"line":224,"column":47},"line":224,"code":"    it('should adjust cursor position on update', async () => {\n      await nvim.input('i')\n      await snippetManager.insertSnippet('${1/..*/ -> /}$1')\n      let line = await nvim.line\n      expect(line).toBe('')\n      await helper.wait(60)\n      await nvim.input('x')\n      await helper.wait(400)\n      line = await nvim.line\n      expect(line).toBe(' -> x')\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(6)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize text on change final placeholder","suites":["snippet provider","synchronize text"],"updatePoint":{"line":238,"column":59},"line":238,"code":"    it('should synchronize text on change final placeholder', async () => {\n      await nvim.command('startinsert')\n      let res = await snippetManager.insertSnippet('$0empty$0')\n      expect(res).toBe(true)\n      await nvim.input('abc')\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      await doc.patchChange()\n      let line = await nvim.line\n      expect(line).toBe('abcemptyabc')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix edit to current placeholder","suites":["snippet provider","synchronize text"],"updatePoint":{"line":250,"column":46},"line":250,"code":"    it('should fix edit to current placeholder', async () => {\n      await nvim.command('startinsert')\n      let res = await snippetManager.insertSnippet('()$1$0', true)\n      expect(res).toBe(true)\n      await nvim.input('(')\n      await nvim.input(')')\n      await nvim.input('<Left>')\n      await helper.wait(50)\n      await doc.patchChange()\n      await helper.wait(200)\n      expect(snippetManager.session).toBeDefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve snippet","suites":["snippet provider","resolveSnippet"],"updatePoint":{"line":265,"column":30},"line":265,"code":"    it('should resolve snippet', async () => {\n      let fsPath = URI.parse(doc.uri).fsPath\n      let res = await snippetManager.resolveSnippet(`$TM_FILENAME`)\n      expect(res.toString()).toBe(path.basename(fsPath))\n      res = await snippetManager.resolveSnippet(`$TM_FILENAME_BASE`)\n      expect(res.toString()).toBe(path.basename(fsPath, path.extname(fsPath)))\n      res = await snippetManager.resolveSnippet(`$TM_DIRECTORY`)\n      expect(res.toString()).toBe(path.dirname(fsPath))\n      res = await snippetManager.resolveSnippet(`$TM_FILEPATH`)\n      expect(res.toString()).toBe(fsPath)\n      await nvim.call('setreg', ['\"\"', 'foo'])\n      res = await snippetManager.resolveSnippet(`$YANK`)\n      expect(res.toString()).toBe('foo')\n      res = await snippetManager.resolveSnippet(`$TM_LINE_INDEX`)\n      expect(res.toString()).toBe('0')\n      res = await snippetManager.resolveSnippet(`$TM_LINE_NUMBER`)\n      expect(res.toString()).toBe('1')\n      await nvim.setLine('foo')\n      res = await snippetManager.resolveSnippet(`$TM_CURRENT_LINE`)\n      expect(res.toString()).toBe('foo')\n      res = await snippetManager.resolveSnippet(`$TM_CURRENT_WORD`)\n      expect(res.toString()).toBe('foo')\n      await nvim.call('setreg', ['*', 'foo'])\n      res = await snippetManager.resolveSnippet(`$CLIPBOARD`)\n      expect(res.toString()).toBe('foo')\n      let d = new Date()\n      res = await snippetManager.resolveSnippet(`$CURRENT_YEAR`)\n      expect(res.toString()).toBe(d.getFullYear().toString())\n      res = await snippetManager.resolveSnippet(`$NOT_EXISTS`)\n      expect(res.toString()).toBe('NOT_EXISTS')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose","suites":["snippet provider","dispose()"],"updatePoint":{"line":299,"column":22},"line":299,"code":"    it('should dispose', async () => {\n      let active = await snippetManager.insertSnippet('${1:foo}')\n      expect(active).toBe(true)\n      snippetManager.dispose()\n      expect(snippetManager.session).toBe(null)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Scanner","suites":["SnippetParser"],"updatePoint":{"line":12,"column":15},"line":12,"code":"  test('Scanner', () => {\n\n    const scanner = new Scanner()\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('{{abc}}')\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc() ')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Format)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc 123')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Format)\n    assert.equal(scanner.next().type, TokenType.Int)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo_bar')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo-bar')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Dash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('${foo}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('${1223:foo}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.Int)\n    assert.equal(scanner.next().type, TokenType.Colon)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('\\\\${}')\n    assert.equal(scanner.next().type, TokenType.Backslash)\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n\n    scanner.text('${foo/regex/format/option}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, escaped","suites":["SnippetParser"],"updatePoint":{"line":128,"column":23},"line":128,"code":"  test('Parser, escaped', function() {\n    assertEscaped('foo$0', 'foo\\\\$0')\n    assertEscaped('foo\\\\$0', 'foo\\\\\\\\\\\\$0')\n    assertEscaped('f$1oo$0', 'f\\\\$1oo\\\\$0')\n    assertEscaped('${1:foo}$0', '\\\\${1:foo\\\\}\\\\$0')\n    assertEscaped('$', '\\\\$')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, text","suites":["SnippetParser"],"updatePoint":{"line":136,"column":20},"line":136,"code":"  test('Parser, text', () => {\n    assertText('$', '$')\n    assertText('\\\\\\\\$', '\\\\$')\n    assertText('{', '{')\n    assertText('\\\\}', '}')\n    assertText('\\\\abc', '\\\\abc')\n    assertText('foo${f:\\\\}}bar', 'foo}bar')\n    assertText('\\\\{', '\\\\{')\n    assertText('I need \\\\\\\\\\\\$', 'I need \\\\$')\n    assertText('\\\\', '\\\\')\n    assertText('\\\\{{', '\\\\{{')\n    assertText('{{', '{{')\n    assertText('{{dd', '{{dd')\n    assertText('}}', '}}')\n    assertText('ff}}', 'ff}}')\n\n    assertText('farboo', 'farboo')\n    assertText('far{{}}boo', 'far{{}}boo')\n    assertText('far{{123}}boo', 'far{{123}}boo')\n    assertText('far\\\\{{123}}boo', 'far\\\\{{123}}boo')\n    assertText('far{{id:bern}}boo', 'far{{id:bern}}boo')\n    assertText('far{{id:bern {{basel}}}}boo', 'far{{id:bern {{basel}}}}boo')\n    assertText('far{{id:bern {{id:basel}}}}boo', 'far{{id:bern {{id:basel}}}}boo')\n    assertText('far{{id:bern {{id2:basel}}}}boo', 'far{{id:bern {{id2:basel}}}}boo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, TM text","suites":["SnippetParser"],"updatePoint":{"line":163,"column":23},"line":163,"code":"  test('Parser, TM text', () => {\n    assertTextAndMarker('foo${1:bar}}', 'foobar}', Text, Placeholder, Text)\n    assertTextAndMarker('foo${1:bar}${2:foo}}', 'foobarfoo}', Text, Placeholder, Placeholder, Text)\n\n    assertTextAndMarker('foo${1:bar\\\\}${2:foo}}', 'foobar}foo', Text, Placeholder)\n\n    let [, placeholder] = new SnippetParser().parse('foo${1:bar\\\\}${2:foo}}').children\n    let { children } = (<Placeholder>placeholder)\n\n    assert.equal((<Placeholder>placeholder).index, '1')\n    assert.ok(children[0] instanceof Text)\n    assert.equal(children[0].toString(), 'bar}')\n    assert.ok(children[1] instanceof Placeholder)\n    assert.equal(children[1].toString(), 'foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder","suites":["SnippetParser"],"updatePoint":{"line":179,"column":27},"line":179,"code":"  test('Parser, placeholder', () => {\n    assertTextAndMarker('farboo', 'farboo', Text)\n    assertTextAndMarker('far{{}}boo', 'far{{}}boo', Text)\n    assertTextAndMarker('far{{123}}boo', 'far{{123}}boo', Text)\n    assertTextAndMarker('far\\\\{{123}}boo', 'far\\\\{{123}}boo', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, literal code","suites":["SnippetParser"],"updatePoint":{"line":186,"column":28},"line":186,"code":"  test('Parser, literal code', () => {\n    assertTextAndMarker('far`123`boo', 'far`123`boo', Text)\n    assertTextAndMarker('far\\\\`123\\\\`boo', 'far\\\\`123\\\\`boo', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variables/tabstop","suites":["SnippetParser"],"updatePoint":{"line":191,"column":33},"line":191,"code":"  test('Parser, variables/tabstop', () => {\n    assertTextAndMarker('$far-boo', '-boo', Variable, Text)\n    assertTextAndMarker('\\\\$far-boo', '$far-boo', Text)\n    assertTextAndMarker('far$farboo', 'far', Text, Variable)\n    assertTextAndMarker('far${farboo}', 'far', Text, Variable)\n    assertTextAndMarker('$123', '', Placeholder)\n    assertTextAndMarker('$farboo', '', Variable)\n    assertTextAndMarker('$far12boo', '', Variable)\n    assertTextAndMarker('000_${far}_000', '000__000', Text, Variable, Text)\n    assertTextAndMarker('FFF_${TM_SELECTED_TEXT}_FFF$0', 'FFF__FFF', Text, Variable, Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variables/placeholder with defaults","suites":["SnippetParser"],"updatePoint":{"line":203,"column":51},"line":203,"code":"  test('Parser, variables/placeholder with defaults', () => {\n    assertTextAndMarker('${name:value}', 'value', Variable)\n    assertTextAndMarker('${1:value}', 'value', Placeholder)\n    assertTextAndMarker('${1:bar${2:foo}bar}', 'barfoobar', Placeholder)\n\n    assertTextAndMarker('${name:value', '${name:value', Text)\n    assertTextAndMarker('${1:bar${2:foobar}', '${1:barfoobar', Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variable transforms","suites":["SnippetParser"],"updatePoint":{"line":212,"column":35},"line":212,"code":"  test('Parser, variable transforms', function() {\n    assertTextAndMarker('${foo///}', '', Variable)\n    assertTextAndMarker('${foo/regex/format/gmi}', '', Variable)\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/}', '', Variable)\n\n    // invalid regex\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/GMI}', '${foo/([A-Z][a-z])/format/GMI}', Text)\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/funky}', '${foo/([A-Z][a-z])/format/funky}', Text)\n    assertTextAndMarker('${foo/([A-Z][a-z]/format/}', '${foo/([A-Z][a-z]/format/}', Text)\n\n    // tricky regex\n    assertTextAndMarker('${foo/m\\\\/atch/$1/i}', '', Variable)\n    assertMarker('${foo/regex\\/format/options}', Text)\n\n    // incomplete\n    assertTextAndMarker('${foo///', '${foo///', Text)\n    assertTextAndMarker('${foo/regex/format/options', '${foo/regex/format/options', Text)\n\n    // format string\n    assertMarker('${foo/.*/${0:fooo}/i}', Variable)\n    assertMarker('${foo/.*/${1}/i}', Variable)\n    assertMarker('${foo/.*/$1/i}', Variable)\n    assertMarker('${foo/.*/This-$1-encloses/i}', Variable)\n    assertMarker('${foo/.*/complex${1:else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:-else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:+if}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:?if:else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:/upcase}/i}', Variable)\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with transform","suites":["SnippetParser"],"updatePoint":{"line":243,"column":42},"line":243,"code":"  test('Parser, placeholder with transform', () => {\n    const p = new SnippetParser()\n    const snippet = p.parse('${1:type}${1/(.+)/ /}')\n    let s = snippet.toString()\n    assert.equal(s.length, 5)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder transforms","suites":["SnippetParser"],"updatePoint":{"line":250,"column":38},"line":250,"code":"  test('Parser, placeholder transforms', function() {\n    assertTextAndMarker('${1///}', '', Placeholder)\n    assertTextAndMarker('${1/regex/format/gmi}', '', Placeholder)\n    assertTextAndMarker('${1/([A-Z][a-z])/format/}', '', Placeholder)\n    assertTextAndMarker('${1///}', '', Placeholder)\n\n    // tricky regex\n    assertTextAndMarker('${1/m\\\\/atch/$1/i}', '', Placeholder)\n    assertMarker('${1/regex\\/format/options}', Text)\n\n    // incomplete\n    assertTextAndMarker('${1///', '${1///', Text)\n    assertTextAndMarker('${1/regex/format/options', '${1/regex/format/options', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"No way to escape forward slash in snippet regex #36715","suites":["SnippetParser"],"updatePoint":{"line":265,"column":62},"line":265,"code":"  test('No way to escape forward slash in snippet regex #36715', function() {\n    assertMarker('${TM_DIRECTORY/src\\\\//$1/}', Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"No way to escape forward slash in snippet format section #37562","suites":["SnippetParser"],"updatePoint":{"line":269,"column":71},"line":269,"code":"  test('No way to escape forward slash in snippet format section #37562', function() {\n    assertMarker('${TM_SELECTED_TEXT/a/\\\\/$1/g}', Variable)\n    assertMarker('${TM_SELECTED_TEXT/a/in\\\\/$1ner/g}', Variable)\n    assertMarker('${TM_SELECTED_TEXT/a/end\\\\//g}', Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with choice","suites":["SnippetParser"],"updatePoint":{"line":275,"column":39},"line":275,"code":"  test('Parser, placeholder with choice', () => {\n\n    assertTextAndMarker('${1|one,two,three|}', 'one', Placeholder)\n    assertTextAndMarker('${1|one|}', 'one', Placeholder)\n    assertTextAndMarker('${1|one1,two2|}', 'one1', Placeholder)\n    assertTextAndMarker('${1|one1\\\\,two2|}', 'one1,two2', Placeholder)\n    assertTextAndMarker('${1|one1\\\\|two2|}', 'one1|two2', Placeholder)\n    assertTextAndMarker('${1|one1\\\\atwo2|}', 'one1\\\\atwo2', Placeholder)\n    assertTextAndMarker('${1|one,two,three,|}', '${1|one,two,three,|}', Text)\n    assertTextAndMarker('${1|one,', '${1|one,', Text)\n\n    const p = new SnippetParser()\n    const snippet = p.parse('${1|one,two,three|}')\n    assertMarker(snippet, Placeholder)\n    const expected = [Placeholder, Text, Text, Text]\n    snippet.walk(marker => {\n      assert.equal(marker, expected.shift())\n      return true\n    })\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet choices: unable to escape comma and pipe, #31521","suites":["SnippetParser"],"updatePoint":{"line":296,"column":64},"line":296,"code":"  test('Snippet choices: unable to escape comma and pipe, #31521', function() {\n    assertTextAndMarker('console.log(${1|not\\\\, not, five, 5, 1   23|});', 'console.log(not, not);', Text, Placeholder, Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Marker, toTextmateString()","suites":["SnippetParser"],"updatePoint":{"line":300,"column":34},"line":300,"code":"  test('Marker, toTextmateString()', function() {\n\n    function assertTextsnippetString(input: string, expected: string): void {\n      const snippet = new SnippetParser().parse(input)\n      const actual = snippet.toTextmateString()\n      assert.equal(actual, expected)\n    }\n\n    assertTextsnippetString('$1', '$1')\n    assertTextsnippetString('\\\\$1', '\\\\$1')\n    assertTextsnippetString('console.log(${1|not\\\\, not, five, 5, 1   23|});', 'console.log(${1|not\\\\, not, five, 5, 1   23|});')\n    assertTextsnippetString('console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});', 'console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});')\n    assertTextsnippetString('this is text', 'this is text')\n    assertTextsnippetString('this ${1:is ${2:nested with $var}}', 'this ${1:is ${2:nested with ${var}}}')\n    assertTextsnippetString('this ${1:is ${2:nested with $var}}}', 'this ${1:is ${2:nested with ${var}}}\\\\}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Marker, toTextmateString() <-> identity","suites":["SnippetParser"],"updatePoint":{"line":317,"column":47},"line":317,"code":"  test('Marker, toTextmateString() <-> identity', function() {\n\n    function assertIdent(input: string): void {\n      // full loop: (1) parse input, (2) generate textmate string, (3) parse, (4) ensure both trees are equal\n      const snippet = new SnippetParser().parse(input)\n      const input2 = snippet.toTextmateString()\n      const snippet2 = new SnippetParser().parse(input2)\n\n      function checkCheckChildren(marker1: Marker, marker2: Marker) {\n        assert.ok(marker1 instanceof Object.getPrototypeOf(marker2).constructor)\n        assert.ok(marker2 instanceof Object.getPrototypeOf(marker1).constructor)\n\n        assert.equal(marker1.children.length, marker2.children.length)\n        assert.equal(marker1.toString(), marker2.toString())\n\n        for (let i = 0; i < marker1.children.length; i++) {\n          checkCheckChildren(marker1.children[i], marker2.children[i])\n        }\n      }\n\n      checkCheckChildren(snippet, snippet2)\n    }\n\n    assertIdent('$1')\n    assertIdent('\\\\$1')\n    assertIdent('console.log(${1|not\\\\, not, five, 5, 1   23|});')\n    assertIdent('console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});')\n    assertIdent('this is text')\n    assertIdent('this ${1:is ${2:nested with $var}}')\n    assertIdent('this ${1:is ${2:nested with $var}}}')\n    assertIdent('this ${1:is ${2:nested with $var}} and repeating $1')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, choise marker","suites":["SnippetParser"],"updatePoint":{"line":350,"column":29},"line":350,"code":"  test('Parser, choise marker', () => {\n    const { placeholders } = new SnippetParser().parse('${1|one,two,three|}')\n\n    assert.equal(placeholders.length, 1)\n    assert.ok(placeholders[0].choice instanceof Choice)\n    assert.ok(placeholders[0].children[0] instanceof Choice)\n    assert.equal((<Choice>placeholders[0].children[0]).options.length, 3)\n\n    assertText('${1|one,two,three|}', 'one')\n    assertText('\\\\${1|one,two,three|}', '${1|one,two,three|}')\n    assertText('${1\\\\|one,two,three|}', '${1\\\\|one,two,three|}')\n    assertText('${1||}', '${1||}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Backslash character escape in choice tabstop doesn't work #58494","suites":["SnippetParser"],"updatePoint":{"line":364,"column":73},"line":364,"code":"  test('Backslash character escape in choice tabstop doesn\\'t work #58494', function() {\n\n    const { placeholders } = new SnippetParser().parse('${1|\\\\,,},$,\\\\|,\\\\\\\\|}')\n    assert.equal(placeholders.length, 1)\n    assert.ok(placeholders[0].choice instanceof Choice)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, only textmate","suites":["SnippetParser"],"updatePoint":{"line":371,"column":29},"line":371,"code":"  test('Parser, only textmate', () => {\n    const p = new SnippetParser()\n    assertMarker(p.parse('far{{}}boo'), Text)\n    assertMarker(p.parse('far{{123}}boo'), Text)\n    assertMarker(p.parse('far\\\\{{123}}boo'), Text)\n\n    assertMarker(p.parse('far$0boo'), Text, Placeholder, Text)\n    assertMarker(p.parse('far${123}boo'), Text, Placeholder, Text)\n    assertMarker(p.parse('far\\\\${123}boo'), Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, real world","suites":["SnippetParser"],"updatePoint":{"line":382,"column":26},"line":382,"code":"  test('Parser, real world', () => {\n    let marker = new SnippetParser().parse('console.warn(${1: $TM_SELECTED_TEXT })').children\n\n    assert.equal(marker[0].toString(), 'console.warn(')\n    assert.ok(marker[1] instanceof Placeholder)\n    assert.equal(marker[2].toString(), ')')\n\n    const placeholder = <Placeholder>marker[1]\n    assert.equal(placeholder, false)\n    assert.equal(placeholder.index, '1')\n    assert.equal(placeholder.children.length, 3)\n    assert.ok(placeholder.children[0] instanceof Text)\n    assert.ok(placeholder.children[1] instanceof Variable)\n    assert.ok(placeholder.children[2] instanceof Text)\n    assert.equal(placeholder.children[0].toString(), ' ')\n    assert.equal(placeholder.children[1].toString(), '')\n    assert.equal(placeholder.children[2].toString(), ' ')\n\n    const nestedVariable = <Variable>placeholder.children[1]\n    assert.equal(nestedVariable.name, 'TM_SELECTED_TEXT')\n    assert.equal(nestedVariable.children.length, 0)\n\n    marker = new SnippetParser().parse('$TM_SELECTED_TEXT').children\n    assert.equal(marker.length, 1)\n    assert.ok(marker[0] instanceof Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform example","suites":["SnippetParser"],"updatePoint":{"line":409,"column":33},"line":409,"code":"  test('Parser, transform example', () => {\n    let { children } = new SnippetParser().parse('${1:name} : ${2:type}${3/\\\\s:=(.*)/${1:+ :=}${1}/};\\n$0')\n\n    //${1:name}\n    assert.ok(children[0] instanceof Placeholder)\n    assert.equal(children[0].children.length, 1)\n    assert.equal(children[0].children[0].toString(), 'name')\n    assert.equal((<Placeholder>children[0]).transform, undefined)\n\n    // :\n    assert.ok(children[1] instanceof Text)\n    assert.equal(children[1].toString(), ' : ')\n\n    //${2:type}\n    assert.ok(children[2] instanceof Placeholder)\n    assert.equal(children[2].children.length, 1)\n    assert.equal(children[2].children[0].toString(), 'type')\n\n    //${3/\\\\s:=(.*)/${1:+ :=}${1}/}\n    assert.ok(children[3] instanceof Placeholder)\n    assert.equal(children[3].children.length, 0)\n    assert.notEqual((<Placeholder>children[3]).transform, undefined)\n    let transform = (<Placeholder>children[3]).transform\n    assert.equal(transform.regexp, '/\\\\s:=(.*)/')\n    assert.equal(transform.children.length, 2)\n    assert.ok(transform.children[0] instanceof FormatString)\n    assert.equal((<FormatString>transform.children[0]).index, 1)\n    assert.equal((<FormatString>transform.children[0]).ifValue, ' :=')\n    assert.ok(transform.children[1] instanceof FormatString)\n    assert.equal((<FormatString>transform.children[1]).index, 1)\n    assert.ok(children[4] instanceof Text)\n    assert.equal(children[4].toString(), ';\\n')\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, default placeholder values","suites":["SnippetParser"],"updatePoint":{"line":444,"column":42},"line":444,"code":"  test('Parser, default placeholder values', () => {\n\n    assertMarker('errorContext: `${1:err}`, error: $1', Text, Placeholder, Text, Placeholder)\n\n    const [, p1, , p2] = new SnippetParser().parse('errorContext: `${1:err}`, error:$1').children\n\n    assert.equal((<Placeholder>p1).index, '1')\n    assert.equal((<Placeholder>p1).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p1).children[0]), 'err')\n\n    assert.equal((<Placeholder>p2).index, '1')\n    assert.equal((<Placeholder>p2).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p2).children[0]), 'err')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, default placeholder values and one transform","suites":["SnippetParser"],"updatePoint":{"line":459,"column":60},"line":459,"code":"  test('Parser, default placeholder values and one transform', () => {\n\n    assertMarker('errorContext: `${1:err}`, error: ${1/err/ok/}', Text, Placeholder, Text, Placeholder)\n\n    const [, p3, , p4] = new SnippetParser().parse('errorContext: `${1:err}`, error:${1/err/ok/}').children\n\n    assert.equal((<Placeholder>p3).index, '1')\n    assert.equal((<Placeholder>p3).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p3).children[0]), 'err')\n    assert.equal((<Placeholder>p3).transform, undefined)\n\n    assert.equal((<Placeholder>p4).index, '1')\n    assert.equal((<Placeholder>p4).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p4).children[0]), 'ok')\n    assert.notEqual((<Placeholder>p4).transform, undefined)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Repeated snippet placeholder should always inherit, #31040","suites":["SnippetParser"],"updatePoint":{"line":476,"column":66},"line":476,"code":"  test('Repeated snippet placeholder should always inherit, #31040', function() {\n    assertText('${1:foo}-abc-$1', 'foo-abc-foo')\n    assertText('${1:foo}-abc-${1}', 'foo-abc-foo')\n    assertText('${1:foo}-abc-${1:bar}', 'foo-abc-foo')\n    assertText('${1}-abc-${1:foo}', 'foo-abc-foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"backspace esapce in TM only, #16212","suites":["SnippetParser"],"updatePoint":{"line":483,"column":43},"line":483,"code":"  test('backspace esapce in TM only, #16212', () => {\n    const actual = new SnippetParser().text('Foo \\\\\\\\${abc}bar')\n    assert.equal(actual, 'Foo \\\\bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"colon as variable/placeholder value, #16717","suites":["SnippetParser"],"updatePoint":{"line":488,"column":51},"line":488,"code":"  test('colon as variable/placeholder value, #16717', () => {\n    let actual = new SnippetParser().text('${TM_SELECTED_TEXT:foo:bar}')\n    assert.equal(actual, 'foo:bar')\n\n    actual = new SnippetParser().text('${1:foo:bar}')\n    assert.equal(actual, 'foo:bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"incomplete placeholder","suites":["SnippetParser"],"updatePoint":{"line":496,"column":30},"line":496,"code":"  test('incomplete placeholder', () => {\n    assertTextAndMarker('${1:}', '', Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"marker#len","suites":["SnippetParser"],"updatePoint":{"line":500,"column":18},"line":500,"code":"  test('marker#len', () => {\n\n    function assertLen(template: string, ...lengths: number[]): void {\n      const snippet = new SnippetParser().parse(template, true)\n      snippet.walk(m => {\n        const expected = lengths.shift()\n        assert.equal(m.len(), expected)\n        return true\n      })\n      assert.equal(lengths.length, 0)\n    }\n\n    assertLen('text$0', 4, 0)\n    assertLen('$1text$0', 0, 4, 0)\n    assertLen('te$1xt$0', 2, 0, 2, 0)\n    assertLen('errorContext: `${1:err}`, error: $0', 15, 0, 3, 10, 0)\n    assertLen('errorContext: `${1:err}`, error: $1$0', 15, 0, 3, 10, 0, 3, 0)\n    assertLen('$TM_SELECTED_TEXT$0', 0, 0)\n    assertLen('${TM_SELECTED_TEXT:def}$0', 0, 3, 0)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"parser, parent node","suites":["SnippetParser"],"updatePoint":{"line":521,"column":27},"line":521,"code":"  test('parser, parent node', function() {\n    let snippet = new SnippetParser().parse('This ${1:is ${2:nested}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    let [first, second] = snippet.placeholders\n    assert.equal(first.index, '1')\n    assert.equal(second.index, '2')\n    assert.ok(second.parent === first)\n    assert.ok(first.parent === snippet)\n\n    snippet = new SnippetParser().parse('${VAR:default${1:value}}$0', true)\n    assert.equal(snippet.placeholders.length, 2)\n      ;[first] = snippet.placeholders\n    assert.equal(first.index, '1')\n\n    assert.ok(snippet.children[0] instanceof Variable)\n    assert.ok(first.parent === snippet.children[0])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#enclosingPlaceholders","suites":["SnippetParser"],"updatePoint":{"line":540,"column":45},"line":540,"code":"  test('TextmateSnippet#enclosingPlaceholders', () => {\n    let snippet = new SnippetParser().parse('This ${1:is ${2:nested}}$0', true)\n    let [first, second] = snippet.placeholders\n\n    assert.deepEqual(snippet.enclosingPlaceholders(first), [])\n    assert.deepEqual(snippet.enclosingPlaceholders(second), [first])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#offset","suites":["SnippetParser"],"updatePoint":{"line":548,"column":30},"line":548,"code":"  test('TextmateSnippet#offset', () => {\n    let snippet = new SnippetParser().parse('te$1xt', true)\n    assert.equal(snippet.offset(snippet.children[0]), 0)\n    assert.equal(snippet.offset(snippet.children[1]), 2)\n    assert.equal(snippet.offset(snippet.children[2]), 2)\n\n    snippet = new SnippetParser().parse('${TM_SELECTED_TEXT:def}', true)\n    assert.equal(snippet.offset(snippet.children[0]), 0)\n    assert.equal(snippet.offset((<Variable>snippet.children[0]).children[0]), 0)\n\n    // forgein marker\n    assert.equal(snippet.offset(new Text('foo')), -1)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#placeholder","suites":["SnippetParser"],"updatePoint":{"line":562,"column":35},"line":562,"code":"  test('TextmateSnippet#placeholder', () => {\n    let snippet = new SnippetParser().parse('te$1xt$0', true)\n    let placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 2)\n\n    snippet = new SnippetParser().parse('te$1xt$1$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n\n\n    snippet = new SnippetParser().parse('te$1xt$2$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n\n    snippet = new SnippetParser().parse('${1:bar${2:foo}bar}$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#replace 1/2","suites":["SnippetParser"],"updatePoint":{"line":581,"column":35},"line":581,"code":"  test('TextmateSnippet#replace 1/2', function() {\n    let snippet = new SnippetParser().parse('aaa${1:bbb${2:ccc}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    const [, second] = snippet.placeholders\n    assert.equal(second.index, '2')\n\n    const enclosing = snippet.enclosingPlaceholders(second)\n    assert.equal(enclosing.length, 1)\n    assert.equal(enclosing[0].index, '1')\n\n    let nested = new SnippetParser().parse('ddd$1eee$0', true)\n    snippet.replace(second, nested.children)\n\n    assert.equal(snippet.toString(), 'aaabbbdddeee')\n    assert.equal(snippet.placeholders.length, 4)\n    assert.equal(snippet.placeholders[0].index, '1')\n    assert.equal(snippet.placeholders[1].index, '1')\n    assert.equal(snippet.placeholders[2].index, '0')\n    assert.equal(snippet.placeholders[3].index, '0')\n\n    const newEnclosing = snippet.enclosingPlaceholders(snippet.placeholders[1])\n    assert.ok(newEnclosing[0] === snippet.placeholders[0])\n    assert.equal(newEnclosing.length, 1)\n    assert.equal(newEnclosing[0].index, '1')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#replace 2/2","suites":["SnippetParser"],"updatePoint":{"line":608,"column":35},"line":608,"code":"  test('TextmateSnippet#replace 2/2', function() {\n    let snippet = new SnippetParser().parse('aaa${1:bbb${2:ccc}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    const [, second] = snippet.placeholders\n    assert.equal(second.index, '2')\n\n    let nested = new SnippetParser().parse('dddeee$0', true)\n    snippet.replace(second, nested.children)\n\n    assert.equal(snippet.toString(), 'aaabbbdddeee')\n    assert.equal(snippet.placeholders.length, 3)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#insertSnippet","suites":["SnippetParser"],"updatePoint":{"line":622,"column":37},"line":622,"code":"  test('TextmateSnippet#insertSnippet', function() {\n    let snippet = new SnippetParser().parse('${1:aaa} ${1:aaa} bbb ${2:ccc}}$0', true)\n    snippet.insertSnippet('|${1:dd} ${2:ff}|', 1, Range.create(0, 0, 0, 0))\n    const [one, two, three] = snippet.placeholders\n    assert.equal(one.index, 1)\n    assert.equal(one.toString(), 'aaa')\n    assert.equal(two.index, 2)\n    assert.equal(two.toString(), 'dd')\n    assert.equal(three.index, 3)\n    assert.equal(three.toString(), 'ff')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#updatePlaceholder","suites":["SnippetParser"],"updatePoint":{"line":634,"column":41},"line":634,"code":"  test('TextmateSnippet#updatePlaceholder', function() {\n    let snippet = new SnippetParser().parse('aaa${1:bbb} ${1:bbb}', true)\n    snippet.updatePlaceholder(0, 'ccc')\n    let p = snippet.placeholders[0]\n    assert.equal(p.toString(), 'ccc')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet order for placeholders, #28185","suites":["SnippetParser"],"updatePoint":{"line":641,"column":46},"line":641,"code":"  test('Snippet order for placeholders, #28185', function() {\n\n    const _10 = new Placeholder(10)\n    const _2 = new Placeholder(2)\n\n    assert.equal(Placeholder.compareByIndex(_10, _2), 1)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Maximum call stack size exceeded, #28983","suites":["SnippetParser"],"updatePoint":{"line":649,"column":48},"line":649,"code":"  test('Maximum call stack size exceeded, #28983', function() {\n    new SnippetParser().parse('${1:${foo:${1}}}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet can freeze the editor, #30407","suites":["SnippetParser"],"updatePoint":{"line":653,"column":45},"line":653,"code":"  test('Snippet can freeze the editor, #30407', function() {\n\n    const seen = new Set<Marker>()\n\n    seen.clear()\n    new SnippetParser().parse('class ${1:${TM_FILENAME/(?:\\\\A|_)([A-Za-z0-9]+)(?:\\\\.rb)?/(?2::\\\\u$1)/g}} < ${2:Application}Controller\\n  $3\\nend').walk(marker => {\n      assert.ok(!seen.has(marker))\n      seen.add(marker)\n      return true\n    })\n\n    seen.clear()\n    new SnippetParser().parse('${1:${FOO:abc$1def}}').walk(marker => {\n      assert.ok(!seen.has(marker))\n      seen.add(marker)\n      return true\n    })\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippets: make parser ignore `${0|choice|}`, #31599","suites":["SnippetParser"],"updatePoint":{"line":672,"column":59},"line":672,"code":"  test('Snippets: make parser ignore `${0|choice|}`, #31599', function() {\n    assertTextAndMarker('${0|foo,bar|}', '${0|foo,bar|}', Text)\n    assertTextAndMarker('${1|foo,bar|}', 'foo', Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Transform -> FormatString#resolve","suites":["SnippetParser"],"updatePoint":{"line":678,"column":41},"line":678,"code":"  test('Transform -> FormatString#resolve', function() {\n\n    // shorthand functions\n    assert.equal(new FormatString(1, 'upcase').resolve('foo'), 'FOO')\n    assert.equal(new FormatString(1, 'downcase').resolve('FOO'), 'foo')\n    assert.equal(new FormatString(1, 'capitalize').resolve('bar'), 'Bar')\n    assert.equal(new FormatString(1, 'capitalize').resolve('bar no repeat'), 'Bar no repeat')\n    assert.equal(new FormatString(1, 'pascalcase').resolve('bar-foo'), 'BarFoo')\n    assert.equal(new FormatString(1, 'notKnown').resolve('input'), 'input')\n\n    // if\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve(undefined), '')\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve(''), '')\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve('bar'), 'foo')\n\n    // else\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve(undefined), 'foo')\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve(''), 'foo')\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve('bar'), 'bar')\n\n    // if-else\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve(undefined), 'foo')\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve(''), 'foo')\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve('baz'), 'bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet variable transformation doesn't work if regex is complicated and snippet body contains '$$' #55627","suites":["SnippetParser"],"updatePoint":{"line":704,"column":117},"line":704,"code":"  test('Snippet variable transformation doesn\\'t work if regex is complicated and snippet body contains \\'$$\\' #55627', function() {\n    const snippet = new SnippetParser().parse('const fileName = \"${TM_FILENAME/(.*)\\\\..+$/$1/}\"')\n    assert.equal(snippet.toTextmateString(), 'const fileName = \"${TM_FILENAME/(.*)\\\\..+$/${1}/}\"')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"[BUG] HTML attribute suggestions: Snippet session does not have end-position set, #33147","suites":["SnippetParser"],"updatePoint":{"line":709,"column":96},"line":709,"code":"  test('[BUG] HTML attribute suggestions: Snippet session does not have end-position set, #33147', function() {\n\n    const { placeholders } = new SnippetParser().parse('src=\"$1\"', true)\n    const [first, second] = placeholders\n\n    assert.equal(placeholders.length, 2)\n    assert.equal(first.index, 1)\n    assert.equal(second.index, 0)\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet optional transforms are not applied correctly when reusing the same variable, #37702","suites":["SnippetParser"],"updatePoint":{"line":720,"column":100},"line":720,"code":"  test('Snippet optional transforms are not applied correctly when reusing the same variable, #37702', function() {\n\n    const transform = new Transform()\n    transform.appendChild(new FormatString(1, 'upcase'))\n    transform.appendChild(new FormatString(2, 'upcase'))\n    transform.regexp = /^(.)|-(.)/g\n\n    assert.equal(transform.resolve('my-file-name'), 'MyFileName')\n\n    const clone = transform.clone()\n    assert.equal(clone.resolve('my-file-name'), 'MyFileName')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"problem with snippets regex #40570","suites":["SnippetParser"],"updatePoint":{"line":733,"column":42},"line":733,"code":"  test('problem with snippets regex #40570', function() {\n\n    const snippet = new SnippetParser().parse('${TM_DIRECTORY/.*src[\\\\/](.*)/$1/}')\n    assertMarker(snippet, Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Variable transformation doesn't work if undefined variables are used in the same snippet #51769","suites":["SnippetParser"],"updatePoint":{"line":739,"column":104},"line":739,"code":"  test('Variable transformation doesn\\'t work if undefined variables are used in the same snippet #51769', function() {\n    let transform = new Transform()\n    transform.appendChild(new Text('bar'))\n    transform.regexp = new RegExp('foo', 'gi')\n    assert.equal(transform.toTextmateString(), '/foo/bar/ig')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet parser freeze #53144","suites":["SnippetParser"],"updatePoint":{"line":746,"column":36},"line":746,"code":"  test('Snippet parser freeze #53144', function() {\n    let snippet = new SnippetParser().parse('${1/(void$)|(.+)/${1:?-\\treturn nil;}/}')\n    assertMarker(snippet, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"snippets variable not resolved in JSON proposal #52931","suites":["SnippetParser"],"updatePoint":{"line":751,"column":62},"line":751,"code":"  test('snippets variable not resolved in JSON proposal #52931', function() {\n    assertTextAndMarker('FOO${1:/bin/bash}', 'FOO/bin/bash', Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Mirroring sequence of nested placeholders not selected properly on backjumping #58736","suites":["SnippetParser"],"updatePoint":{"line":755,"column":93},"line":755,"code":"  test('Mirroring sequence of nested placeholders not selected properly on backjumping #58736', function() {\n    let snippet = new SnippetParser().parse('${3:nest1 ${1:nest2 ${2:nest3}}} $3')\n    assert.equal(snippet.children.length, 3)\n    assert.ok(snippet.children[0] instanceof Placeholder)\n    assert.ok(snippet.children[1] instanceof Text)\n    assert.ok(snippet.children[2] instanceof Placeholder)\n\n    function assertParent(marker: Marker) {\n      marker.children.forEach(assertParent)\n      if (!(marker instanceof Placeholder)) {\n        return\n      }\n      let found = false\n      let m: Marker = marker\n      while (m && !found) {\n        if (m.parent === snippet) {\n          found = true\n        }\n        m = m.parent\n      }\n      assert.ok(found)\n    }\n    let [, , clone] = snippet.children\n    assertParent(clone)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with plain snippet","suites":["SnippetSession#start"],"updatePoint":{"line":24,"column":37},"line":24,"code":"  it('should start with plain snippet', async () => {\n    let buf = await helper.edit()\n    await helper.wait(30)\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('bar$0')\n    expect(res).toBe(false)\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 3 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with range replaced","suites":["SnippetSession#start"],"updatePoint":{"line":35,"column":38},"line":35,"code":"  it('should start with range replaced', async () => {\n    let buf = await helper.edit()\n    await helper.wait(30)\n    await nvim.setLine('foo')\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('bar$0', true, Range.create(0, 0, 0, 3))\n    expect(res).toBe(false)\n    let line = await nvim.line\n    expect(line).toBe('bar')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert placeholder with default value","suites":["SnippetSession#start"],"updatePoint":{"line":47,"column":50},"line":47,"code":"  it('should insert placeholder with default value', async () => {\n    let buf = await helper.edit()\n    await helper.wait(30)\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('a${TM_SELECTED_TEXT:return}b')\n    expect(res).toBe(false)\n    let line = await nvim.line\n    expect(line).toBe('areturnb')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix indent of next line when necessary","suites":["SnippetSession#start"],"updatePoint":{"line":58,"column":51},"line":58,"code":"  it('should fix indent of next line when necessary', async () => {\n    let buf = await helper.edit()\n    await nvim.setLine('  ab')\n    await nvim.input('i<right><right><right>')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('x\\n')\n    expect(res).toBe(false)\n    let lines = await buf.lines\n    expect(lines).toEqual(['  ax', '  b'])\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with final position for plain snippet","suites":["SnippetSession#start"],"updatePoint":{"line":69,"column":56},"line":69,"code":"  it('should start with final position for plain snippet', async () => {\n    let buf = await helper.edit()\n    await nvim.command('startinsert')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('bar$0')\n    expect(res).toBe(false)\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 3 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert indent for snippet endsWith line break","suites":["SnippetSession#start"],"updatePoint":{"line":79,"column":58},"line":79,"code":"  it('should insert indent for snippet endsWith line break', async () => {\n    let buf = await helper.edit()\n    await nvim.setLine('  bar')\n    await helper.wait(10)\n    await nvim.command('startinsert')\n    await nvim.call('cursor', [1, 3])\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('foo\\n')\n    expect(res).toBe(false)\n    let lines = await buf.lines\n    expect(lines).toEqual(['  foo', '  bar'])\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert resolved variable","suites":["SnippetSession#start"],"updatePoint":{"line":92,"column":37},"line":92,"code":"  it('should insert resolved variable', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${TM_LINE_NUMBER}')\n    expect(res).toBe(false)\n    let line = await nvim.line\n    expect(line).toBe('1')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use default value of unresolved variable","suites":["SnippetSession#start"],"updatePoint":{"line":101,"column":53},"line":101,"code":"  it('should use default value of unresolved variable', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${TM_SELECTION:abc}')\n    expect(res).toBe(false)\n    let line = await nvim.line\n    expect(line).toBe('abc')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with snippet insert","suites":["SnippetSession#start"],"updatePoint":{"line":110,"column":38},"line":110,"code":"  it('should start with snippet insert', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start(' ${1:aa} bb $1')\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe(' aa bb aa')\n    let { mode } = await nvim.mode\n    expect(mode).toBe('s')\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 2 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start without select placeholder","suites":["SnippetSession#start"],"updatePoint":{"line":123,"column":45},"line":123,"code":"  it('should start without select placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start(' ${1:aa} ', false)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe(' aa ')\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await session.selectCurrentPlaceholder()\n    await helper.wait(100)\n    let m = await nvim.mode\n    expect(m.mode).toBe('s')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with variable selected","suites":["SnippetSession#start"],"updatePoint":{"line":138,"column":41},"line":138,"code":"  it('should start with variable selected', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${foo:bar}', false)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe('bar')\n    await session.selectCurrentPlaceholder()\n    await helper.wait(100)\n    let m = await nvim.mode\n    expect(m.mode).toBe('s')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with nest snippet","suites":["SnippetSession#start"],"updatePoint":{"line":151,"column":36},"line":151,"code":"  it('should start with nest snippet', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:a} ${2:b}', false)\n    let line = await nvim.getLine()\n    expect(line).toBe('a b')\n    expect(res).toBe(true)\n    let { placeholder } = session\n    expect(placeholder.index).toBe(1)\n    res = await session.start('${1:foo} ${2:bar}')\n    expect(res).toBe(true)\n    placeholder = session.placeholder\n    let { snippet } = session\n    expect(placeholder.index).toBe(2)\n    line = await nvim.getLine()\n    expect(line).toBe('foo bara b')\n    expect(snippet.toString()).toBe('foo bara b')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to nested snippet placeholder","suites":["SnippetSession#start"],"updatePoint":{"line":170,"column":47},"line":170,"code":"  it('should jump to nested snippet placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1} ${2:b}', false)\n    await session.start('${1:foo} ${2:bar}')\n    await session.nextPlaceholder()\n    await session.nextPlaceholder()\n    await session.nextPlaceholder()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 8 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to variable placeholder","suites":["SnippetSession#start"],"updatePoint":{"line":182,"column":41},"line":182,"code":"  it('should jump to variable placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${foo} ${bar}', false)\n    await session.selectCurrentPlaceholder()\n    await helper.wait(100)\n    await session.nextPlaceholder()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 6 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to variable placeholder after number placeholder","suites":["SnippetSession#start"],"updatePoint":{"line":193,"column":66},"line":193,"code":"  it('should jump to variable placeholder after number placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${foo} ${1:bar}', false)\n    await session.selectCurrentPlaceholder()\n    await session.nextPlaceholder()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 2 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to variable placeholder with same name only once","suites":["SnippetSession#start"],"updatePoint":{"line":203,"column":66},"line":203,"code":"  it('should jump to variable placeholder with same name only once', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${foo} ${foo} ${2:bar}', false)\n    await session.selectCurrentPlaceholder()\n    await session.nextPlaceholder()\n    await session.nextPlaceholder()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 11 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start nest snippet without select","suites":["SnippetSession#start"],"updatePoint":{"line":214,"column":46},"line":214,"code":"  it('should start nest snippet without select', async () => {\n    let buf = await helper.edit()\n    await nvim.command('startinsert')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:a} ${2:b}')\n    await helper.wait(30)\n    await nvim.input('<backspace>')\n    res = await session.start('${1:foo} ${2:bar}', false)\n    await helper.wait(30)\n    expect(res).toBe(true)\n    let line = await nvim.line\n    expect(line).toBe('foo bar b')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select none transform placeholder","suites":["SnippetSession#start"],"updatePoint":{"line":228,"column":46},"line":228,"code":"  it('should select none transform placeholder', async () => {\n    let buf = await helper.edit()\n    await nvim.command('startinsert')\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1/..*/ -> /}xy$1')\n    await helper.wait(30)\n    let col = await nvim.call('col', '.')\n    expect(col).toBe(3)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent multiple lines variable text","suites":["SnippetSession#start"],"updatePoint":{"line":238,"column":48},"line":238,"code":"  it('should indent multiple lines variable text', async () => {\n    let text = 'abc\\n  def'\n    await nvim.setVar('coc_selected_text', text)\n    let buf = await helper.edit()\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('fun\\n  ${0:${TM_SELECTED_TEXT:return}}\\nend')\n    await helper.wait(30)\n    let lines = await buf.lines\n    expect(lines.length).toBe(4)\n    expect(lines).toEqual([\n      'fun', '  abc', '    def', 'end'\n    ])\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on invalid change","suites":["SnippetSession#deactivate"],"updatePoint":{"line":256,"column":41},"line":256,"code":"  it('should deactivate on invalid change', async () => {\n    let doc = await helper.createDocument()\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, doc.bufnr)\n    let res = await session.start('${1:a}bc')\n    expect(res).toBe(true)\n    let edit = {\n      range: Range.create(0, 0, 0, 2),\n      newText: ''\n    }\n    await doc.applyEdits([edit])\n    await session.synchronizeUpdatedPlaceholders({ range: edit.range, text: edit.newText })\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on cursor outside","suites":["SnippetSession#deactivate"],"updatePoint":{"line":271,"column":41},"line":271,"code":"  it('should deactivate on cursor outside', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('a${1:a}b')\n    expect(res).toBe(true)\n    await buf.append(['foo', 'bar'])\n    await nvim.call('cursor', [2, 1])\n    await session.checkPosition()\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel keymap on jump final placeholder","suites":["SnippetSession#deactivate"],"updatePoint":{"line":282,"column":52},"line":282,"code":"  it('should cancel keymap on jump final placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await nvim.input('i')\n    await session.start('$0x${1:a}b$0')\n    let line = await nvim.line\n    expect(line).toBe('xab')\n    let map = await nvim.call('maparg', ['<C-j>', 'i']) as string\n    expect(map).toMatch('snippetNext')\n    await session.nextPlaceholder()\n    map = await nvim.call('maparg', ['<C-j>', 'i']) as string\n    expect(map).toBe('')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next placeholder","suites":["SnippetSession#nextPlaceholder"],"updatePoint":{"line":299,"column":34},"line":299,"code":"  it('should goto next placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:a} ${2:b} c')\n    expect(res).toBe(true)\n    await session.nextPlaceholder()\n    let { placeholder } = session\n    expect(placeholder.index).toBe(2)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to none transform placeholder","suites":["SnippetSession#nextPlaceholder"],"updatePoint":{"line":309,"column":47},"line":309,"code":"  it('should jump to none transform placeholder', async () => {\n    let buf = await helper.edit()\n    await helper.wait(60)\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1} ${2/^_(.*)/$2/}bar$2')\n    expect(res).toBe(true)\n    let line = await nvim.line\n    expect(line).toBe(' bar')\n    await session.nextPlaceholder()\n    await helper.wait(60)\n    let col = await nvim.call('col', '.')\n    expect(col).toBe(5)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto previous placeholder","suites":["SnippetSession#previousPlaceholder"],"updatePoint":{"line":326,"column":38},"line":326,"code":"  it('should goto previous placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:foo} ${2:bar}')\n    expect(res).toBe(true)\n    await session.nextPlaceholder()\n    await helper.wait(60)\n    expect(session.placeholder.index).toBe(2)\n    await session.previousPlaceholder()\n    await helper.wait(60)\n    expect(session.placeholder.index).toBe(1)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust with line changed before start position","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":342,"column":59},"line":342,"code":"  it('should adjust with line changed before start position', async () => {\n    let buf = await helper.edit()\n    await nvim.setLine('abd')\n    await nvim.input('o')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:foo}')\n    await helper.wait(30)\n    expect(res).toBe(true)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 0, 0, 3),\n      text: 'def'\n    })\n    expect(session.isActive).toBe(true)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust for variable placeholders","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":357,"column":45},"line":357,"code":"  it('should adjust for variable placeholders', async () => {\n    let buf = await helper.edit()\n    await nvim.input('i')\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${foo} ${foo}')\n    expect(res).toBe(true)\n    await session.selectCurrentPlaceholder()\n    await helper.wait(100)\n    await nvim.input('bar')\n    await helper.wait(100)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 0, 0, 3),\n      text: 'bar'\n    })\n    let line = await nvim.getLine()\n    expect(line).toBe('bar bar')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust with previous line change","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":375,"column":45},"line":375,"code":"  it('should adjust with previous line change', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:foo}')\n    await nvim.input('Obar')\n    await helper.wait(30)\n    expect(res).toBe(true)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 0, 0, 0),\n      text: 'bar\\n'\n    })\n    expect(session.isActive).toBe(true)\n    let { start } = session.snippet.range\n    expect(start).toEqual({ line: 1, character: 0 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust with previous character change","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":391,"column":50},"line":391,"code":"  it('should adjust with previous character change', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('foo ${1:foo}')\n    await nvim.input('Ibar')\n    await helper.wait(30)\n    expect(res).toBe(true)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 0, 0, 0),\n      text: 'bar'\n    })\n    expect(session.isActive).toBe(true)\n    let { start } = session.snippet.range\n    expect(start).toEqual({ line: 0, character: 3 })\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate when content add after snippet","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":407,"column":54},"line":407,"code":"  it('should deactivate when content add after snippet', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:foo} $0 ')\n    await nvim.input('Abar')\n    await helper.wait(100)\n    expect(res).toBe(true)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 5, 0, 5),\n      text: 'bar'\n    })\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not deactivate when content remove after snippet","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":421,"column":61},"line":421,"code":"  it('should not deactivate when content remove after snippet', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    let res = await session.start('${1:foo}')\n    expect(res).toBe(true)\n    await nvim.input('Abar')\n    await helper.wait(30)\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 5, 0, 6),\n      text: ''\n    })\n    await helper.wait(30)\n    expect(session.isActive).toBe(true)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate when change outside placeholder","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":436,"column":55},"line":436,"code":"  it('should deactivate when change outside placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('a${1:b}c')\n    let doc = await workspace.document\n    await doc.applyEdits([{\n      range: Range.create(0, 0, 0, 1),\n      newText: ''\n    }])\n    await session.synchronizeUpdatedPlaceholders({\n      range: Range.create(0, 0, 0, 1),\n      text: ''\n    })\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate when jump to single final placeholder","suites":["SnippetSession#synchronizeUpdatedPlaceholders"],"updatePoint":{"line":452,"column":61},"line":452,"code":"  it('should deactivate when jump to single final placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start(' $0 ${1:a}')\n    await session.nextPlaceholder()\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel snippet if position out of range","suites":["SnippetSession#checkPosition"],"updatePoint":{"line":463,"column":52},"line":463,"code":"  it('should cancel snippet if position out of range', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await nvim.setLine('bar')\n    await session.start('${1:foo}')\n    await nvim.call('cursor', [1, 5])\n    await session.checkPosition()\n    expect(session.isActive).toBe(false)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not cancel snippet if position in range","suites":["SnippetSession#checkPosition"],"updatePoint":{"line":473,"column":52},"line":473,"code":"  it('should not cancel snippet if position in range', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1:foo}')\n    await nvim.call('cursor', [1, 3])\n    await session.checkPosition()\n    expect(session.isActive).toBe(true)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find current placeholder if possible","suites":["SnippetSession#findPlaceholder"],"updatePoint":{"line":485,"column":49},"line":485,"code":"  it('should find current placeholder if possible', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1:abc}${2:def}')\n    let placeholder = session.findPlaceholder(Range.create(0, 3, 0, 3))\n    expect(placeholder.index).toBe(1)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null if placeholder not found","suites":["SnippetSession#findPlaceholder"],"updatePoint":{"line":493,"column":49},"line":493,"code":"  it('should return null if placeholder not found', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1:abc}xyz${2:def}')\n    let placeholder = session.findPlaceholder(Range.create(0, 4, 0, 4))\n    expect(placeholder).toBeNull()\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select range placeholder","suites":["SnippetSession#selectPlaceholder"],"updatePoint":{"line":504,"column":37},"line":504,"code":"  it('should select range placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('${1:abc}')\n    let mode = await nvim.mode\n    expect(mode.mode).toBe('s')\n    await nvim.input('<backspace>')\n    let line = await nvim.line\n    expect(line).toBe('')\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select empty placeholder","suites":["SnippetSession#selectPlaceholder"],"updatePoint":{"line":515,"column":37},"line":515,"code":"  it('should select empty placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await session.start('a ${1} ${2}')\n    let mode = await nvim.mode\n    expect(mode.mode).toBe('i')\n    let col = await nvim.call('col', '.')\n    expect(col).toBe(3)\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select choice placeholder","suites":["SnippetSession#selectPlaceholder"],"updatePoint":{"line":525,"column":38},"line":525,"code":"  it('should select choice placeholder', async () => {\n    let buf = await helper.edit()\n    let session = new SnippetSession(nvim, buf.id)\n    await nvim.input('i')\n    await session.start('${1|one,two,three|}')\n    await helper.wait(60)\n    let line = await nvim.line\n    expect(line).toBe('one')\n    let val = await nvim.eval('g:coc#_context') as any\n    expect(val.start).toBe(0)\n    expect(val.candidates).toEqual(['one', 'two', 'three'])\n  })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append plain snippets","suites":["SnippetString","Append"],"updatePoint":{"line":5,"column":36},"line":5,"code":"    it('should append plain snippets', () => {\n      let snippetString = new SnippetString('foo')\n      expect(snippetString.value).toBe('foo')\n\n      snippetString = new SnippetString().appendText('foo')\n      expect(snippetString.value).toBe('foo')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append tabstop","suites":["SnippetString","Append"],"updatePoint":{"line":13,"column":29},"line":13,"code":"    it('should append tabstop', () => {\n      let snippetString = new SnippetString()\n        .appendTabstop()\n        .appendText(' ')\n        .appendTabstop()\n        .appendText(' ')\n        .appendTabstop(4)\n        .appendText(' ')\n        .appendTabstop(3)\n\n      expect(snippetString.value).toBe('$1 $2 $4 $3')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append placeholder","suites":["SnippetString","Append"],"updatePoint":{"line":26,"column":33},"line":26,"code":"    it('should append placeholder', () => {\n      let snippetString = new SnippetString()\n        .appendPlaceholder('abcdef')\n        .appendText(' ')\n        .appendPlaceholder('foo')\n        .appendText(' ')\n        .appendPlaceholder('bar', 4)\n        .appendText(' ')\n        .appendPlaceholder('a', 3)\n        .appendText(' ')\n        .appendPlaceholder(s => {\n          s.appendText('plain')\n        }, 5)\n\n      expect(snippetString.value).toBe('${1:abcdef} ${2:foo} ${4:bar} ${3:a} ${5:plain}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append choice","suites":["SnippetString","Append"],"updatePoint":{"line":43,"column":28},"line":43,"code":"    it('should append choice', () => {\n      let snippetString = new SnippetString()\n        .appendChoice(['foo', 'bar'])\n        .appendText(' ')\n        .appendChoice(['foo3', 'bar3'], 3)\n        .appendText(' ')\n        .appendChoice(['foo2', 'bar2'], 2)\n\n      expect(snippetString.value).toBe('${1|foo,bar|} ${3|foo3,bar3|} ${2|foo2,bar2|}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append variables","suites":["SnippetString","Append"],"updatePoint":{"line":54,"column":31},"line":54,"code":"    it('should append variables', () => {\n      let snippetString = new SnippetString()\n        .appendVariable('foo', 'abcdef')\n        .appendText(' ')\n        .appendVariable('bar')\n\n      expect(snippetString.value).toBe('${foo:abcdef} ${bar}')\n\n      snippetString = new SnippetString()\n        .appendVariable('foo', s => s.appendText('abcdef'))\n        .appendText(' ')\n        .appendVariable('bar')\n\n      expect(snippetString.value).toBe('${foo:abcdef} ${bar}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get children from root","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":77,"column":37},"line":77,"code":"    it('should get children from root', async () => {\n      let nodes = createNodes(defaultDef)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      expect(res.length).toBe(3)\n      expect(res.map(o => o.label)).toEqual(['a', 'b', 'g'])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get children from child node","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":90,"column":43},"line":90,"code":"    it('should get children from child node', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let nodes = await provider.getChildren(res[0])\n      expect(nodes.length).toBe(2)\n      expect(nodes.map(o => o.label)).toEqual(['c', 'd'])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provideData throws","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":103,"column":44},"line":103,"code":"    it('should throw when provideData throws', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          throw new Error('my error')\n        }\n      })\n      disposables.push(provider)\n      let err\n      try {\n        await provider.getChildren()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get tree item from node","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":121,"column":38},"line":121,"code":"    it('should get tree item from node', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.Collapsed)\n      item = provider.getTreeItem(res[2])\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.None)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect expandLevel option","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":136,"column":41},"line":136,"code":"    it('should respect expandLevel option', async () => {\n      let provider = new BasicDataProvider({\n        expandLevel: 1,\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.Expanded)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should include highlights","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":150,"column":33},"line":150,"code":"    it('should include highlights', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [createNode('a', [], undefined, 'tip')]\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.tooltip).toBe('tip')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use icon from node","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":163,"column":33},"line":163,"code":"    it('should use icon from node', async () => {\n      let node = createNode('a', [], undefined, 'tip')\n      node.icon = {\n        text: 'i',\n        hlGroup: 'Function'\n      }\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.icon).toBeDefined()\n      expect(item.icon).toEqual({\n        text: 'i',\n        hlGroup: 'Function'\n      })\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve icon","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":185,"column":27},"line":185,"code":"    it('should resolve icon', async () => {\n      let provider = new BasicDataProvider<CustomNode>({\n        provideData: () => {\n          let node = createNode('a', [], undefined, 'tip')\n          node.kind = 'function'\n          return [node]\n        },\n        resolveIcon: item => {\n          if (item.kind === 'function') {\n            return {\n              text: 'f',\n              hlGroup: 'Function'\n            }\n          }\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.icon).toEqual({\n        text: 'f',\n        hlGroup: 'Function'\n      })\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined when data not exists","suites":["BasicDataProvider","getParent()"],"updatePoint":{"line":213,"column":49},"line":213,"code":"    it('should get undefined when data not exists', async () => {\n      let node = createNode('a')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        }\n      })\n      disposables.push(provider)\n      let res = provider.getParent(node)\n      expect(res).toBeUndefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get parent node","suites":["BasicDataProvider","getParent()"],"updatePoint":{"line":225,"column":30},"line":225,"code":"    it('should get parent node', async () => {\n      let node = createNode('g')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [\n            createNode('a', [createNode('c', [node]), createNode('d')]),\n            createNode('b', [createNode('e'), createNode('f')]),\n            createNode('g')\n          ]\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let res = provider.getParent(node)\n      expect(res).toBeDefined()\n      expect(res.label).toBe('c')\n      // console.log(provider.labels.join('\\n'))\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve tooltip and command","suites":["BasicDataProvider","resolveTreeItem()"],"updatePoint":{"line":246,"column":42},"line":246,"code":"    it('should resolve tooltip and command', async () => {\n      let node = createNode('a')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        },\n        resolveItem: item => {\n          item.tooltip = 'tip'\n          item.command = {\n            command: 'test command',\n            title: 'test'\n          }\n          return item\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let source = new CancellationTokenSource()\n      let item = provider.getTreeItem(node)\n      let resolved = await provider.resolveTreeItem(item, node, source.token)\n      expect(resolved.tooltip).toBe('tip')\n      expect(resolved.command.command).toBe('test command')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register command invoke click","suites":["BasicDataProvider","resolveTreeItem()"],"updatePoint":{"line":270,"column":44},"line":270,"code":"    it('should register command invoke click', async () => {\n      let node = createNode('a')\n      let called: TreeNode\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        },\n        handleClick: item => {\n          called = item\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let source = new CancellationTokenSource()\n      let item = provider.getTreeItem(node)\n      let resolved = await provider.resolveTreeItem(item, node, source.token)\n      expect(resolved.command).toBeDefined()\n      expect(resolved.command.command).toMatch('invoke')\n      await commandsManager.execute(resolved.command)\n      expect(called).toBeDefined()\n      expect(called).toBe(node)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add children with event","suites":["BasicDataProvider","update()"],"updatePoint":{"line":295,"column":38},"line":295,"code":"    it('should add children with event', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b']]],\n        ['b', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let b = nodes[0].children[0]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = false\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBe(b)\n        called = true\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['b', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', 'b', ' f'\n      ])\n      expect(called).toBe(true)\n      expect(b.children).toBeDefined()\n      expect(b.children.length).toBe(2)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove children with event","suites":["BasicDataProvider","update()"],"updatePoint":{"line":328,"column":41},"line":328,"code":"    it('should remove children with event', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let b = nodes[0].children[0]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = false\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBe(b)\n        called = true\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b']]],\n        ['e', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', 'e', ' f'\n      ])\n      expect(called).toBe(true)\n      expect(b.children).toBeUndefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not fire event for children when parent have changed","suites":["BasicDataProvider","update()"],"updatePoint":{"line":360,"column":67},"line":360,"code":"    it('should not fire event for children when parent have changed', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = 0\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBeUndefined()\n        called += 1\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d'], ['g']]]]],\n        ['e', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      expect(called).toBe(1)\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', '  g', 'e', ' f'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire events for independent node change","suites":["BasicDataProvider","update()"],"updatePoint":{"line":389,"column":54},"line":389,"code":"    it('should fire events for independent node change', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c']]]]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = []\n      provider.onDidChangeTreeData(node => {\n        called.push(node)\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['e', [['f', [['g']]]]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      expect(called.length).toBe(2)\n      expect(called[0].label).toBe('b')\n      expect(called[1].label).toBe('f')\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', 'e', ' f', '  g'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply new properties","suites":["BasicDataProvider","update()"],"updatePoint":{"line":420,"column":35},"line":420,"code":"    it('should apply new properties', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b']]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider<CustomNode>({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = createNodes([\n        ['a', [['b', [['c']]]]],\n        ['e', [['f', [['g']]]]]\n      ])\n      let b = newNodes[0].children[0]\n      Object.assign(b, { x: 1, y: 2 })\n      let curr = provider.update(newNodes)\n      let node = curr[0].children[0]\n      expect(node).toBeDefined()\n      expect(node.x).toBe(1)\n      expect(node.y).toBe(2)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep references and have new data sequence","suites":["BasicDataProvider","update()"],"updatePoint":{"line":446,"column":57},"line":446,"code":"    it('should keep references and have new data sequence', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b'], ['c']]],\n        ['e', [['f']]],\n        ['g']\n      ]\n      let nodes = createNodes(defs)\n      let keeps = [\n        findNode('a', nodes),\n        findNode('b', nodes),\n        findNode('c', nodes),\n        findNode('e', nodes),\n        findNode('f', nodes),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = createNodes([\n        ['a', [['c', [['d'], ['h']]], ['b']]],\n        ['e', [['f', [['j']]], ['i']]]\n      ])\n      let curr = provider.update(newNodes)\n      expect(curr).toBe(nodes)\n      expect(keeps[0]).toBe(findNode('a', curr))\n      expect(keeps[1]).toBe(findNode('b', curr))\n      expect(keeps[2]).toBe(findNode('c', curr))\n      expect(keeps[3]).toBe(findNode('e', curr))\n      expect(keeps[4]).toBe(findNode('f', curr))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' c', '  d', '  h', ' b', 'e', ' f', '  j', ' i'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use key for nodes","suites":["BasicDataProvider","update()"],"updatePoint":{"line":484,"column":32},"line":484,"code":"    it('should use key for nodes', async () => {\n      let nodes = [\n        createNode('a', [], 'x'),\n        createNode('a', [], 'y'),\n        createNode('a', [], 'z'),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = [\n        createNode('a', [], 'x'),\n        createNode('a', [], 'z'),\n      ]\n      let curr = provider.update(newNodes)\n      expect(curr.length).toBe(2)\n      expect(curr[0].key).toBe('x')\n      expect(curr[1].key).toBe('z')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset data","suites":["BasicDataProvider","update()"],"updatePoint":{"line":507,"column":25},"line":507,"code":"    it('should reset data', async () => {\n      let nodes = [\n        createNode('a', [], 'x'),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = [\n        createNode('a', [], 'x'),\n      ]\n      let curr = provider.update(newNodes, true)\n      expect(curr === nodes).toBe(false)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke onDispose from opts","suites":["BasicDataProvider","dispose"],"updatePoint":{"line":527,"column":41},"line":527,"code":"    it('should invoke onDispose from opts', async () => {\n      let called = false\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return []\n        },\n        onDispose: () => {\n          called = true\n        }\n      })\n      provider.dispose()\n      expect(called).toBe(true)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create TreeItem from resourceUri","suites":["TreeView","TreeItem()"],"updatePoint":{"line":94,"column":47},"line":94,"code":"    it('should create TreeItem from resourceUri', async () => {\n      let item = new TreeItem(URI.file('/foo/bar.ts'))\n      expect(item.resourceUri).toBeDefined()\n      expect(item.label).toBe('bar.ts')\n      expect(item.label).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show with title","suites":["TreeView","show()"],"updatePoint":{"line":103,"column":30},"line":103,"code":"    it('should show with title', async () => {\n      createTreeView(defaultDef)\n      expect(treeView).toBeDefined()\n      await treeView.show()\n      let visible = treeView.visible\n      expect(visible).toBe(true)\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show when visible","suites":["TreeView","show()"],"updatePoint":{"line":113,"column":36},"line":113,"code":"    it('should not show when visible', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      let windowId = treeView.windowId\n      await treeView.show()\n      expect(treeView.windowId).toBe(windowId)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reuse window","suites":["TreeView","show()"],"updatePoint":{"line":121,"column":27},"line":121,"code":"    it('should reuse window', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      let windowId = treeView.windowId\n      await helper.wait(50)\n      provider.dispose()\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      expect(treeView.windowId).toBe(windowId)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render item icon","suites":["TreeView","show()"],"updatePoint":{"line":133,"column":31},"line":133,"code":"    it('should render item icon', async () => {\n      createTreeView(defaultDef)\n      nodes[0].icon = { text: 'i', hlGroup: 'Title' }\n      nodes[1].icon = { text: 'i', hlGroup: 'Title' }\n      nodes[2].icon = { text: 'i', hlGroup: 'Title' }\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['test', '+ i a', '+ i b', '  i g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change open close icon","suites":["TreeView","configuration"],"updatePoint":{"line":153,"column":37},"line":153,"code":"    it('should change open close icon', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let { configurations } = workspace\n      configurations.updateUserConfig({\n        'tree.openedIcon': '',\n        'tree.closedIcon': '',\n      })\n      await helper.wait(50)\n      await checkLines(['test', ' a', ' b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change title","suites":["TreeView","public properties"],"updatePoint":{"line":168,"column":27},"line":168,"code":"    it('should change title', async () => {\n      createTreeView(defaultDef)\n      treeView.title = 'foo'\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['foo', '+ a', '+ b', '  g'])\n      treeView.title = 'bar'\n      await helper.wait(50)\n      await checkLines(['bar', '+ a', '+ b', '  g'])\n      treeView.title = undefined\n      await helper.wait(50)\n      await checkLines(['+ a', '+ b', '  g'])\n      makeUpdateUIThrowError()\n      treeView.title = 'xyz'\n      await helper.wait(50)\n      await checkLines(['+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change description","suites":["TreeView","public properties"],"updatePoint":{"line":186,"column":33},"line":186,"code":"    it('should change description', async () => {\n      createTreeView(defaultDef)\n      treeView.description = 'desc'\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['test desc', '+ a', '+ b', '  g'])\n      treeView.description = 'foo bar'\n      await helper.wait(50)\n      await checkLines(['test foo bar', '+ a', '+ b', '  g'])\n      treeView.description = ''\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n      makeUpdateUIThrowError()\n      treeView.description = 'desc'\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change message","suites":["TreeView","public properties"],"updatePoint":{"line":204,"column":29},"line":204,"code":"    it('should change message', async () => {\n      createTreeView(defaultDef)\n      treeView.message = 'hello'\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['hello', '', 'test', '+ a', '+ b', '  g'])\n      treeView.message = 'foo'\n      await helper.wait(50)\n      await checkLines(['foo', '', 'test', '+ a', '+ b', '  g'])\n      treeView.message = undefined\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n      makeUpdateUIThrowError()\n      treeView.message = 'bar'\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable winfixwidth","suites":["TreeView","options"],"updatePoint":{"line":224,"column":34},"line":224,"code":"    it('should disable winfixwidth', async () => {\n      createTreeView(defaultDef, { winfixwidth: false })\n      await treeView.show()\n      let res = await nvim.eval('&winfixwidth')\n      expect(res).toBe(0)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable leaf indent","suites":["TreeView","options"],"updatePoint":{"line":231,"column":34},"line":231,"code":"    it('should disable leaf indent', async () => {\n      createTreeView(defaultDef, { disableLeafIndent: true })\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', 'g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support many selection","suites":["TreeView","options"],"updatePoint":{"line":238,"column":37},"line":238,"code":"    it('should support many selection', async () => {\n      createTreeView(defaultDef, { canSelectMany: true })\n      await treeView.show()\n      await helper.wait(50)\n      let selection: TreeNode[]\n      treeView.onDidChangeSelection(e => {\n        selection = e.selection\n      })\n      await nvim.command('exe 1')\n      await nvim.input('<space>')\n      await helper.wait(10)\n      await nvim.command('exe 2')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(2)\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      let signs = res[0].signs\n      expect(treeView.selection.length).toBe(1)\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 2,\n        id: 3001,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back by <C-o>","suites":["TreeView","key-mappings"],"updatePoint":{"line":276,"column":33},"line":276,"code":"    it('should jump back by <C-o>', async () => {\n      let winid = await nvim.call('win_getid')\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.input('<C-o>')\n      await helper.wait(50)\n      let win = await nvim.window\n      expect(win.id).toBe(winid)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection by <space>","suites":["TreeView","key-mappings"],"updatePoint":{"line":287,"column":42},"line":287,"code":"    it('should toggle selection by <space>', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let selection: TreeNode[]\n      treeView.onDidChangeSelection(e => {\n        selection = e.selection\n      })\n      await nvim.command('exe 1')\n      await nvim.input('<space>')\n      await helper.wait(10)\n      await nvim.command('exe 2')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      let signs = res[0].signs\n      expect(treeView.selection.length).toBe(1)\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 3,\n        id: 3002,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n      await nvim.input('<space>')\n      await helper.wait(50)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      signs = res[0].signs\n      expect(signs.length).toBe(0)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset signs after expand & collapse","suites":["TreeView","key-mappings"],"updatePoint":{"line":324,"column":50},"line":324,"code":"    it('should reset signs after expand & collapse', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(1)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(0)\n      await nvim.input('t')\n      await helper.wait(100)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close tree view by <esc>","suites":["TreeView","key-mappings"],"updatePoint":{"line":356,"column":39},"line":356,"code":"    it('should close tree view by <esc>', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      expect(treeView.visible).toBe(true)\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      expect(treeView.visible).toBe(false)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command by <cr>","suites":["TreeView","key-mappings"],"updatePoint":{"line":366,"column":37},"line":366,"code":"    it('should invoke command by <cr>', async () => {\n      let node: TreeNode\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node).toBeUndefined()\n      await nvim.command('exe 2')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node.label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when resolve command cancelled","suites":["TreeView","key-mappings"],"updatePoint":{"line":384,"column":55},"line":384,"code":"    it('should not throw when resolve command cancelled', async () => {\n      let node: TreeNode\n      let cancelled = false\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        },\n        resolveItem: (item, _node, token) => {\n          return new Promise(resolve => {\n            let timer = setTimeout(() => {\n              item.command = {\n                title: 'not exists',\n                command: 'test'\n              }\n              resolve(item)\n            }, 5000)\n            token.onCancellationRequested(() => {\n              cancelled = true\n              clearTimeout(timer)\n              resolve(item)\n            })\n          })\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await nvim.command('exe 1')\n      await helper.wait(50)\n      expect(cancelled).toBe(true)\n      expect(node).toBeUndefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle expand by t","suites":["TreeView","key-mappings"],"updatePoint":{"line":419,"column":33},"line":419,"code":"    it('should toggle expand by t', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 1')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test', '- a', '  + c', '    d', '- b', '    e', '    f', '  g'\n      ])\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test', '+ a', '- b', '    e', '    f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should collapse parent node by t","suites":["TreeView","key-mappings"],"updatePoint":{"line":445,"column":47},"line":445,"code":"    it('should should collapse parent node by t', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should collapse all nodes by M","suites":["TreeView","key-mappings"],"updatePoint":{"line":471,"column":38},"line":471,"code":"    it('should collapse all nodes by M', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 6')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '- b',\n        '    e',\n        '    f',\n        '  g',\n      ])\n      await nvim.input('M')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle expand on open/close icon click ","suites":["TreeView","key-mappings"],"updatePoint":{"line":509,"column":54},"line":509,"code":"    it('should toggle expand on open/close icon click ', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [1, 1])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 1])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command on node click","suites":["TreeView","key-mappings"],"updatePoint":{"line":539,"column":43},"line":539,"code":"    it('should invoke command on node click', async () => {\n      let node: TreeNode\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      expect(node).toBeDefined()\n      expect(node.label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when resolveActions not exists","suites":["TreeView","invokeActions"],"updatePoint":{"line":557,"column":58},"line":557,"code":"    it('should show warning when resolveActions not exists', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch('No actions')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when resolveActions is empty","suites":["TreeView","invokeActions"],"updatePoint":{"line":568,"column":56},"line":568,"code":"    it('should show warning when resolveActions is empty', async () => {\n      createTreeView(defaultDef, {}, {\n        resolveActions: () => {\n          return []\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch('No actions')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke selected action","suites":["TreeView","invokeActions"],"updatePoint":{"line":583,"column":37},"line":583,"code":"    it('should invoke selected action', async () => {\n      let args: any[]\n      let called = false\n      createTreeView(defaultDef, {}, {\n        resolveActions: (item, element) => {\n          args = [item, element]\n          return [{\n            title: 'one',\n            handler: () => {\n              called = true\n            }\n          }]\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(called).toBe(true)\n      expect(args[0].label).toBe('a')\n      expect(args[1].label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit visibility change on buffer unload","suites":["TreeView","events"],"updatePoint":{"line":611,"column":54},"line":611,"code":"    it('should emit visibility change on buffer unload', async () => {\n      createTreeView(defaultDef)\n      let visible\n      treeView.onDidChangeVisibility(e => {\n        visible = e.visible\n      })\n      await treeView.show()\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      nvim.command(`bd! ${buf.id}`, true)\n      await helper.wait(50)\n      expect(visible).toBe(false)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show tooltip on CursorHold","suites":["TreeView","events"],"updatePoint":{"line":625,"column":41},"line":625,"code":"    it('should show tooltip on CursorHold', async () => {\n      createTreeView(defaultDef, {}, {\n        resolveItem: (item, node) => {\n          if (node.label == 'a') {\n            item.tooltip = 'first'\n          }\n          if (node.label == 'b') {\n            item.tooltip = { kind: 'markdown', value: '#title' }\n          }\n          return item\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      let bufnr = await nvim.eval(`bufnr('%')`) as number\n      await events.fire('CursorHold', [bufnr])\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines).toEqual(['first'])\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [bufnr])\n      lines = await buf.lines\n      expect(lines).toEqual(['#title'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore hidden node change","suites":["TreeView","data change"],"updatePoint":{"line":656,"column":40},"line":656,"code":"    it('should ignore hidden node change', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let tick = await nvim.eval('b:changedtick')\n      updateData([\n        ['a', [['c', [['h']]], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g']\n      ])\n      await helper.wait(50)\n      let curr = await nvim.eval('b:changedtick')\n      expect(curr).toBe(tick)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render all nodes on root change","suites":["TreeView","data change"],"updatePoint":{"line":671,"column":46},"line":671,"code":"    it('should render all nodes on root change', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      updateData([\n        ['g'],\n        ['h'],\n        ['b', [['e'], ['f']]],\n        ['a', [['c'], ['d']]]\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  g',\n        '  h',\n        '+ b',\n        '+ a',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep node open state","suites":["TreeView","data change"],"updatePoint":{"line":693,"column":35},"line":693,"code":"    it('should keep node open state', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 6')\n      await nvim.input('t')\n      await helper.wait(50)\n      updateData([\n        ['h'],\n        ['g', [['i']]],\n        ['b', [['f']]],\n        ['a', [['c'], ['j']]]\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  h',\n        '+ g',\n        '- b',\n        '    f',\n        '- a',\n        '    c',\n        '    j',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render changed nodes","suites":["TreeView","data change"],"updatePoint":{"line":729,"column":35},"line":729,"code":"    it('should render changed nodes', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      updateData([\n        ['a', [['h', [['i']]], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g'],\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '  + h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should error message on error","suites":["TreeView","data change"],"updatePoint":{"line":754,"column":37},"line":754,"code":"    it('should error message on error', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      let msg = 'Unable to fetch children'\n      provider.getChildren = () => {\n        throw new Error(msg)\n      }\n      updateData([['a']])\n      await helper.wait(50)\n      let line = await nvim.call('getline', [1])\n      expect(line).toMatch(msg)\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error message on refresh error","suites":["TreeView","data change"],"updatePoint":{"line":773,"column":50},"line":773,"code":"    it('should show error message on refresh error', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      makeUpdateUIThrowError()\n      updateData([\n        ['a', [['h'], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g'],\n      ])\n      await helper.wait(50)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('Error on updateUI')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render deprecated node with deprecated highlight","suites":["TreeView","data change"],"updatePoint":{"line":788,"column":63},"line":788,"code":"    it('should render deprecated node with deprecated highlight', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let defs: NodeDef[] = [\n        ['a'],\n        ['b']\n      ]\n      let nodes = createNodes(defs)\n      nodes[0].deprecated = true\n      provider.update(nodes)\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  a',\n        '  b',\n      ])\n      let ns = await nvim.call('coc#highlight#create_namespace', ['tree'])\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], { details: true }]) as any[]\n      expect(markers.length > 0).toBe(true)\n      expect(markers[0][3]['hl_group']).toBe('CocDeprecatedHighlight')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when node not rendered","suites":["TreeView","focusItem()"],"updatePoint":{"line":814,"column":47},"line":814,"code":"    it('should not throw when node not rendered', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let c = nodes[0].children[0]\n      treeView.focusItem(c)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should focus rendered node","suites":["TreeView","focusItem()"],"updatePoint":{"line":822,"column":34},"line":822,"code":"    it('should focus rendered node', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      treeView.focusItem(nodes[1])\n      await helper.wait(50)\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toBe('+ b')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when getParent not exists","suites":["TreeView","reveal()"],"updatePoint":{"line":834,"column":52},"line":834,"code":"    it('should throw error when getParent not exists', async () => {\n      createTreeView(defaultDef)\n      provider.getParent = undefined\n      await treeView.show()\n      await helper.wait(50)\n      let err\n      try {\n        await treeView.reveal(nodes[0].children[0])\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select item","suites":["TreeView","reveal()"],"updatePoint":{"line":848,"column":26},"line":848,"code":"    it('should select item', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      let h = createNode('h')\n      c.children = [h]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(h)\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      let selection = treeView.selection\n      expect(selection.length).toBe(1)\n      expect(selection[0].label).toBe('h')\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('h')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not select item","suites":["TreeView","reveal()"],"updatePoint":{"line":872,"column":30},"line":872,"code":"    it('should not select item', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[1], { select: false })\n      let lnum = await nvim.call('line', ['.'])\n      expect(lnum).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should focus item","suites":["TreeView","reveal()"],"updatePoint":{"line":881,"column":25},"line":881,"code":"    it('should focus item', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[1], { focus: true })\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('b')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand item whih single level","suites":["TreeView","reveal()"],"updatePoint":{"line":890,"column":44},"line":890,"code":"    it('should expand item whih single level', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[0], { expand: true })\n      await checkLines([\n        'test',\n        '- a',\n        '  + c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand item whih 2 level","suites":["TreeView","reveal()"],"updatePoint":{"line":907,"column":39},"line":907,"code":"    it('should expand item whih 2 level', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[0], { expand: 2 })\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start filter by input","suites":["TreeView","filter"],"updatePoint":{"line":935,"column":36},"line":935,"code":"    it('should start filter by input', async () => {\n      await createFilterTreeView()\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n      await nvim.input('a')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  a',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw error on filter","suites":["TreeView","filter"],"updatePoint":{"line":949,"column":40},"line":949,"code":"    it('should not throw error on filter', async () => {\n      await createFilterTreeView()\n        ; (treeView as any).getRenderedLine = () => {\n          throw new Error('Error on updateUI')\n        }\n      await nvim.input('a')\n      await helper.wait(100)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add & remove Cursor highlight on window change","suites":["TreeView","filter"],"updatePoint":{"line":958,"column":61},"line":958,"code":"    it('should add & remove Cursor highlight on window change', async () => {\n      let winid = await nvim.call('win_getid')\n      let ns = await nvim.call('coc#highlight#create_namespace', ['tree'])\n      await createFilterTreeView()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers[0]).toBeDefined()\n      await nvim.call('win_gotoid', [winid])\n      await helper.wait(50)\n      markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers.length).toBe(0)\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers.length).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter new nodes on data change","suites":["TreeView","filter"],"updatePoint":{"line":975,"column":46},"line":975,"code":"    it('should filter new nodes on data change', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      updateData([\n        ['ab'],\n        ['e'],\n        ['fa']\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  ab',\n        '  fa',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change selected item by <up> and <down>","suites":["TreeView","filter"],"updatePoint":{"line":993,"column":54},"line":993,"code":"    it('should change selected item by <up> and <down>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      updateData([\n        ['ab'],\n        ['fa']\n      ])\n      await helper.wait(50)\n      await nvim.input('<down>')\n      await helper.wait(50)\n      let curr = treeView.selection[0]\n      expect(curr.label).toBe('fa')\n      await nvim.input('<down>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('ab')\n      await nvim.input('<up>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('fa')\n      await nvim.input('<up>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('ab')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw with empty nodes","suites":["TreeView","filter"],"updatePoint":{"line":1020,"column":41},"line":1020,"code":"    it('should not throw with empty nodes', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<up>')\n      await helper.wait(50)\n      await nvim.input('<down>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await checkLines(['test', 'ab '])\n      let curr = treeView.selection[0]\n      expect(curr).toBeUndefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command by <cr>","suites":["TreeView","filter"],"updatePoint":{"line":1035,"column":37},"line":1035,"code":"    it('should invoke command by <cr>', async () => {\n      let node\n      await createFilterTreeView({\n        handleClick: n => {\n          node = n\n        }\n      })\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node).toBeDefined()\n      let curr = treeView.selection[0]\n      expect(curr).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep state when press <cr> with empty selection ","suites":["TreeView","filter"],"updatePoint":{"line":1049,"column":63},"line":1049,"code":"    it('should keep state when press <cr> with empty selection ', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await checkLines(['test', 'ab '])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete last filter character by <bs>","suites":["TreeView","filter"],"updatePoint":{"line":1058,"column":51},"line":1058,"code":"    it('should delete last filter character by <bs>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      await nvim.input('<bs>')\n      await helper.wait(50)\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clean filter character by <C-u>","suites":["TreeView","filter"],"updatePoint":{"line":1069,"column":46},"line":1069,"code":"    it('should clean filter character by <C-u>', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(50)\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel filter by <esc> and <C-o>","suites":["TreeView","filter"],"updatePoint":{"line":1080,"column":47},"line":1080,"code":"    it('should cancel filter by <esc> and <C-o>', async () => {\n      await createFilterTreeView()\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      await nvim.input('f')\n      await helper.wait(50)\n      await nvim.input('<C-o>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should navigate input history by <C-n> and <C-p>","suites":["TreeView","filter"],"updatePoint":{"line":1102,"column":56},"line":1102,"code":"    it('should navigate input history by <C-n> and <C-p>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(20)\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      await nvim.input('f')\n      await helper.wait(50)\n      await nvim.input('b')\n      await helper.wait(20)\n      await nvim.input('<C-o>')\n      await helper.wait(50)\n      await nvim.input('f')\n      await helper.wait(50)\n      await nvim.input('<C-n>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  a',\n      ])\n      await nvim.input('<C-n>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'b ',\n        '  b',\n      ])\n      await nvim.input('<C-p>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  a',\n      ])\n      await nvim.input('<C-p>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'b ',\n        '  b',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"}]}