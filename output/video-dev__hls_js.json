{"repo":"video-dev/hls.js","url":"https://github.com/video-dev/hls.js","branch":"master","configs":[{"package":"hls.js","lang":"js","dir":"tests","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should receive video loadeddata event for ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":507,"column":71,"index":18382},"line":507,"code":"    it(`should receive video loadeddata event for ${stream.description}`, testLoadedData.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"seek back to start and play for ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":509,"column":63,"index":18537},"line":509,"code":"      it(`seek back to start and play for ${stream.description}`, testSeekBackToStart.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should \"smooth switch\" to highest level and still play after 2s for ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":512,"column":99,"index":18733},"line":512,"code":"      it(`should \"smooth switch\" to highest level and still play after 2s for ${stream.description}`, testSmoothSwitch.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should seek near the end and receive video seeked event for ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":515,"column":91,"index":18899},"line":515,"code":"      it(`should seek near the end and receive video seeked event for ${stream.description}`, testSeekOnLive.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should buffer up to maxBufferLength or video.duration for ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":517,"column":89,"index":19067},"line":517,"code":"      it(`should buffer up to maxBufferLength or video.duration for ${stream.description}`, testIdleBufferLength.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should play ","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":518,"column":43,"index":19160},"line":518,"code":"      it(`should play ${stream.description}`, testIsPlayingVOD.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should seek 3s from end and receive video ended event for  with 2 or less buffered ranges","suites":["testing hls.js playback in the browser on \"\""],"updatePoint":{"line":519,"column":120,"index":19326},"line":519,"code":"      it(`should seek 3s from end and receive video ended event for ${stream.description} with 2 or less buffered ranges`, testSeekOnVOD.bind(null, url, config));","file":"functional/auto/setup.js","skipped":false,"dir":"tests"},{"name":"should return correct next auto level","suites":["AbrController"],"updatePoint":{"line":5,"column":43,"index":270},"line":5,"code":"  it('should return correct next auto level', function () {\n    const hls = new Hls({\n      maxStarvationDelay: 4\n    });\n    hls.levelController._levels = [{\n      bitrate: 105000,\n      name: '144',\n      details: {\n        totalduration: 4,\n        fragments: [{}]\n      }\n    }, {\n      bitrate: 246440,\n      name: '240',\n      details: {\n        totalduration: 10,\n        fragments: [{}]\n      }\n    }, {\n      bitrate: 460560,\n      name: '380',\n      details: {\n        totalduration: 10,\n        fragments: [{}]\n      }\n    }, {\n      bitrate: 836280,\n      name: '480',\n      details: {\n        totalduration: 10,\n        fragments: [{}]\n      }\n    }, {\n      bitrate: 2149280,\n      name: '720',\n      details: {\n        totalduration: 10,\n        fragments: [{}]\n      }\n    }, {\n      bitrate: 6221600,\n      name: '1080',\n      details: {\n        totalduration: 10,\n        fragments: [{}]\n      }\n    }];\n    const abrController = new AbrController(hls);\n    abrController.bwEstimator = new EwmaBandWidthEstimator(hls, 15, 4, 5e5);\n    expect(abrController.nextAutoLevel).to.equal(0);\n  });","file":"unit/controller/abr-controller.js","skipped":false,"dir":"tests"},{"name":"should update the level details from the event data","suites":["AudioStreamController","onAudioTrackLoaded"],"updatePoint":{"line":50,"column":59,"index":1207},"line":50,"code":"    it('should update the level details from the event data', function () {\n      const details = {\n        live: false,\n        fragments: [{}],\n        targetduration: 100\n      };\n      audioStreamController.levels = tracks;\n      audioStreamController.mainDetails = details;\n      audioStreamController.tick = () => {};\n      audioStreamController.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, {\n        id: 0,\n        details\n      });\n      expect(audioStreamController.levels[0].details).to.equal(details);\n    });","file":"unit/controller/audio-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should reset the tracks list and current trackId","suites":["AudioTrackController","onManifestLoading"],"updatePoint":{"line":98,"column":56,"index":2181},"line":98,"code":"    it('should reset the tracks list and current trackId', function () {\n      audioTrackController.tracks = tracks;\n      audioTrackController.onManifestLoading();\n      expect(audioTrackController.tracks).to.be.empty;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should set the audioTracks contained in the event data and trigger AUDIO_TRACKS_UPDATED","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":105,"column":95,"index":2497},"line":105,"code":"    it('should set the audioTracks contained in the event data and trigger AUDIO_TRACKS_UPDATED', function () {\n      const audioTracksUpdatedCallback = sinon.spy();\n      hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, audioTracksUpdatedCallback);\n      audioTrackController.onManifestParsed(Events.MANIFEST_PARSED, {\n        audioTracks: tracks\n      });\n      audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n        level: 0\n      });\n      expect(audioTrackController.tracks).to.equal(tracks);\n      expect(audioTracksUpdatedCallback).to.be.calledOnce;\n      expect(audioTracksUpdatedCallback).to.be.calledWith(Events.AUDIO_TRACKS_UPDATED, {\n        audioTracks: tracks.slice(3, 6)\n      });\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should select audioGroupId and trigger AUDIO_TRACK_SWITCHING","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":121,"column":66,"index":3182},"line":121,"code":"  it('should select audioGroupId and trigger AUDIO_TRACK_SWITCHING', function (done) {\n    hls.on(Hls.Events.AUDIO_TRACK_SWITCHING, (event, data) => {\n      done();\n    });\n    const newLevelInfo = levels[0];\n    const newGroupId = newLevelInfo.audioGroupIds[newLevelInfo.urlId];\n    audioTrackController.tracks = tracks;\n    // Update the level to set audioGroupId\n    audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n      level: 0\n    });\n    audioTrackController.audioTrack = 2;\n\n    // current track name\n    const audioTrackName = tracks[audioTrackController.audioTrack].name;\n    audioTrackController.onManifestParsed(Events.MANIFEST_PARSED, {\n      audioTracks: tracks\n    });\n\n    // group has switched\n    expect(audioTrackController.groupId).to.equal(newGroupId);\n    // name is still the same\n    expect(tracks[audioTrackController.audioTrack].name).to.equal(audioTrackName);\n  });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should always switch tracks when audioTrack is set to a valid index","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":145,"column":73,"index":4094},"line":145,"code":"  it('should always switch tracks when audioTrack is set to a valid index', function () {\n    const audioTracksUpdatedCallback = sinon.spy();\n    const audioTrackSwitchingCallback = sinon.spy();\n    hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, audioTracksUpdatedCallback);\n    hls.on(Hls.Events.AUDIO_TRACK_SWITCHING, audioTrackSwitchingCallback);\n    audioTrackController.onManifestParsed(Events.MANIFEST_PARSED, {\n      audioTracks: tracks\n    });\n    audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n      level: 0\n    });\n    expect(audioTracksUpdatedCallback, 'AUDIO_TRACKS_UPDATED').to.have.been.calledOnce;\n    expect(audioTrackSwitchingCallback, 'AUDIO_TRACK_SWITCHING to initial track 0').to.have.been.calledOnce;\n    audioTrackController.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, {\n      details: new LevelDetails(''),\n      id: 0,\n      groupId: '1',\n      networkDetails: null,\n      stats: {\n        loading: {}\n      },\n      deliveryDirectives: null\n    });\n    expect(audioTrackController.tracksInGroup[0], 'tracksInGroup[0]').to.have.property('details').which.is.an('object');\n    audioTrackController.audioTrack = 1;\n    expect(audioTrackSwitchingCallback, 'AUDIO_TRACK_SWITCHING to track 1').to.have.been.calledTwice;\n    audioTrackController.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, {\n      details: new LevelDetails(''),\n      id: 1,\n      groupId: '1',\n      networkDetails: null,\n      stats: {\n        loading: {}\n      },\n      deliveryDirectives: null\n    });\n    expect(audioTrackController.tracksInGroup[1], 'tracksInGroup[1]').to.have.property('details').which.is.an('object');\n    audioTrackController.audioTrack = 0;\n    expect(audioTrackSwitchingCallback, 'AUDIO_TRACK_SWITCHING back to track 0').to.have.been.calledThrice;\n  });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should not need loading because the audioTrack is embedded in the main playlist","suites":["AudioTrackController","shouldLoadTrack"],"updatePoint":{"line":186,"column":87,"index":5929},"line":186,"code":"    it('should not need loading because the audioTrack is embedded in the main playlist', function () {\n      audioTrackController.canLoad = true;\n      expect(audioTrackController.shouldLoadTrack({\n        details: {\n          live: true\n        }\n      })).to.be.false;\n      expect(audioTrackController.shouldLoadTrack({\n        details: undefined\n      })).to.be.false;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should need loading because the track has not been loaded yet","suites":["AudioTrackController","shouldLoadTrack"],"updatePoint":{"line":197,"column":69,"index":6293},"line":197,"code":"    it('should need loading because the track has not been loaded yet', function () {\n      audioTrackController.canLoad = true;\n      expect(audioTrackController.shouldLoadTrack({\n        details: {\n          live: true\n        },\n        url: 'http://example.com/manifest.m3u8'\n      }), 'track 1').to.be.true;\n      expect(audioTrackController.shouldLoadTrack({\n        details: null,\n        url: 'http://example.com/manifest.m3u8'\n      }), 'track 2').to.be.true;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should reselect the current track and trigger AUDIO_TRACK_SWITCHING eventually","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":212,"column":86,"index":6836},"line":212,"code":"    it('should reselect the current track and trigger AUDIO_TRACK_SWITCHING eventually', function (done) {\n      hls.on(Hls.Events.AUDIO_TRACK_SWITCHING, (event, data) => {\n        done();\n      });\n      const levelLoadedEvent = {\n        level: 0\n      };\n      const newLevelInfo = levels[levelLoadedEvent.level];\n      const newGroupId = newLevelInfo.audioGroupIds[newLevelInfo.urlId];\n      audioTrackController.tracks = tracks;\n      audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n        level: 0\n      });\n      audioTrackController.audioTrack = 2;\n\n      // current track name\n      const audioTrackName = tracks[audioTrackController.audioTrack].name;\n      audioTrackController.onLevelLoading(Events.LEVEL_LOADING, levelLoadedEvent);\n\n      // group has switched\n      expect(audioTrackController.groupId).to.equal(newGroupId);\n      // name is still the same\n      expect(tracks[audioTrackController.audioTrack].name).to.equal(audioTrackName);\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should load audio tracks with a url","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":236,"column":43,"index":7769},"line":236,"code":"    it('should load audio tracks with a url', function () {\n      const shouldLoadTrack = sinon.spy(audioTrackController, 'shouldLoadTrack');\n      const audioTrackLoadingCallback = sinon.spy();\n      const trackWithUrl = {\n        groupId: '1',\n        id: 0,\n        name: 'A',\n        default: true,\n        url: './trackA.m3u8'\n      };\n      hls.on(Hls.Events.AUDIO_TRACK_LOADING, audioTrackLoadingCallback);\n      hls.levelController = {\n        levels: [{\n          urlId: 0,\n          audioGroupIds: ['1']\n        }]\n      };\n      audioTrackController.tracks = [trackWithUrl];\n      audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n        level: 0\n      });\n      audioTrackController.startLoad();\n      expect(shouldLoadTrack).to.have.been.calledTwice;\n      expect(shouldLoadTrack).to.have.been.calledWith(trackWithUrl);\n      expect(shouldLoadTrack.firstCall.returnValue, 'expected shouldLoadTrack to return false before startLoad() is called').to.be.false;\n      expect(shouldLoadTrack.secondCall.returnValue, 'expected shouldLoadTrack to return true after startLoad() is called').to.be.true;\n      expect(audioTrackLoadingCallback).to.have.been.calledOnce;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should not attempt to load audio tracks without a url","suites":["AudioTrackController","onLevelLoading"],"updatePoint":{"line":264,"column":61,"index":8978},"line":264,"code":"    it('should not attempt to load audio tracks without a url', function () {\n      const shouldLoadTrack = sinon.spy(audioTrackController, 'shouldLoadTrack');\n      const audioTrackLoadingCallback = sinon.spy();\n      const trackWithOutUrl = tracks[0];\n      hls.on(Hls.Events.AUDIO_TRACK_LOADING, audioTrackLoadingCallback);\n      hls.levelController = {\n        levels: [{\n          urlId: 0,\n          audioGroupIds: ['1']\n        }]\n      };\n      audioTrackController.tracks = tracks;\n      audioTrackController.onLevelLoading(Events.LEVEL_LOADING, {\n        level: 0\n      });\n      audioTrackController.startLoad(0);\n      expect(shouldLoadTrack).to.have.been.calledTwice;\n      expect(shouldLoadTrack).to.have.been.calledWith(trackWithOutUrl);\n      expect(shouldLoadTrack.firstCall.returnValue).to.be.false;\n      expect(shouldLoadTrack.secondCall.returnValue).to.be.false;\n      expect(audioTrackLoadingCallback).to.not.have.been.called;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should clear interval (only) on fatal network errors","suites":["AudioTrackController","onError"],"updatePoint":{"line":288,"column":60,"index":9976},"line":288,"code":"    it('should clear interval (only) on fatal network errors', function () {\n      audioTrackController.timer = 1000;\n      audioTrackController.onError(Events.ERROR, {\n        type: Hls.ErrorTypes.MEDIA_ERROR\n      });\n      expect(audioTrackController.timer).to.equal(1000);\n      audioTrackController.onError(Events.ERROR, {\n        type: Hls.ErrorTypes.MEDIA_ERROR,\n        fatal: true\n      });\n      expect(audioTrackController.timer).to.equal(1000);\n      audioTrackController.onError(Events.ERROR, {\n        type: Hls.ErrorTypes.NETWORK_ERROR,\n        fatal: false\n      });\n      expect(audioTrackController.timer).to.equal(1000);\n      audioTrackController.onError(Events.ERROR, {\n        type: Hls.ErrorTypes.NETWORK_ERROR,\n        fatal: true\n      });\n      expect(audioTrackController.timer).to.equal(-1);\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"should retry track loading if track has not changed","suites":["AudioTrackController","onError"],"updatePoint":{"line":310,"column":59,"index":10803},"line":310,"code":"    it('should retry track loading if track has not changed', function () {\n      const retryLoadingOrFail = sinon.spy(audioTrackController, 'retryLoadingOrFail');\n      const currentTrackId = 4;\n      const currentGroupId = 'aac';\n      audioTrackController.trackId = currentTrackId;\n      audioTrackController.groupId = currentGroupId;\n      audioTrackController.tracks = tracks;\n      audioTrackController.onError(Events.ERROR, {\n        type: Hls.ErrorTypes.NETWORK_ERROR,\n        details: Hls.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n        fatal: false,\n        context: {\n          type: PlaylistContextType.AUDIO_TRACK,\n          id: currentTrackId,\n          groupId: currentGroupId\n        }\n      });\n      expect(audioTrackController.audioTrack, 'track index/id is not changed as there is no redundant track to choose from').to.equal(4);\n      expect(retryLoadingOrFail).to.have.been.calledOnce;\n    });","file":"unit/controller/audio-track-controller.ts","skipped":false,"dir":"tests"},{"name":"returns false if the stream is live","suites":["BaseStreamController","_streamEnded"],"updatePoint":{"line":46,"column":43,"index":1151},"line":46,"code":"    it('returns false if the stream is live', function () {\n      levelDetails.live = true;\n      expect(baseStreamController._streamEnded(bufferInfo, levelDetails)).to.be.false;\n    });","file":"unit/controller/base-stream-controller.js","skipped":false,"dir":"tests"},{"name":"returns false if there is subsequently buffered range","suites":["BaseStreamController","_streamEnded"],"updatePoint":{"line":50,"column":61,"index":1356},"line":50,"code":"    it('returns false if there is subsequently buffered range', function () {\n      levelDetails.endSN = 10;\n      bufferInfo.nextStart = 100;\n      expect(baseStreamController._streamEnded(bufferInfo, levelDetails)).to.be.false;\n    });","file":"unit/controller/base-stream-controller.js","skipped":false,"dir":"tests"},{"name":"returns true if parts are buffered for low latency content","suites":["BaseStreamController","_streamEnded"],"updatePoint":{"line":55,"column":66,"index":1599},"line":55,"code":"    it('returns true if parts are buffered for low latency content', function () {\n      media.buffered = new TimeRangesMock([0, 1]);\n      levelDetails.endSN = 10;\n      levelDetails.partList = [{\n        start: 0,\n        duration: 1\n      }];\n      expect(baseStreamController._streamEnded(bufferInfo, levelDetails)).to.be.true;\n    });","file":"unit/controller/base-stream-controller.js","skipped":false,"dir":"tests"},{"name":"depends on fragment-tracker to determine if last fragment is buffered","suites":["BaseStreamController","_streamEnded"],"updatePoint":{"line":64,"column":77,"index":1950},"line":64,"code":"    it('depends on fragment-tracker to determine if last fragment is buffered', function () {\n      media.buffered = new TimeRangesMock([0, 1]);\n      levelDetails.endSN = 10;\n      expect(baseStreamController._streamEnded(bufferInfo, levelDetails)).to.be.true;\n      fragmentTracker.isEndListAppended = () => false;\n      expect(baseStreamController._streamEnded(bufferInfo, levelDetails)).to.be.false;\n    });","file":"unit/controller/base-stream-controller.js","skipped":false,"dir":"tests"},{"name":"flushes a specific type when provided a type","suites":["BufferController tests","onBufferFlushing"],"updatePoint":{"line":21,"column":52,"index":720},"line":21,"code":"    it('flushes a specific type when provided a type', function () {\n      const spy = sandbox.spy(bufferController.operationQueue, 'append');\n      bufferController.onBufferFlushing(Events.BUFFER_FLUSHING, {\n        startOffset: 0,\n        endOffset: 10,\n        type: 'video'\n      });\n      expect(spy).to.have.been.calledOnce;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"flushes all source buffers when buffer flush event type is undefined","suites":["BufferController tests","onBufferFlushing"],"updatePoint":{"line":30,"column":76,"index":1083},"line":30,"code":"    it('flushes all source buffers when buffer flush event type is undefined', function () {\n      const spy = sandbox.spy(bufferController.operationQueue, 'append');\n      bufferController.onBufferFlushing(Events.BUFFER_FLUSHING, {\n        startOffset: 0,\n        endOffset: 10\n      });\n      expect(spy).to.have.been.calledTwice;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"initializes with zero expected BUFFER_CODEC events","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":144,"column":58,"index":5131},"line":144,"code":"    it('initializes with zero expected BUFFER_CODEC events', function () {\n      expect(bufferController.bufferCodecEventsExpected).to.equal(0);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"should throw if no media element has been attached","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":147,"column":58,"index":5284},"line":147,"code":"    it('should throw if no media element has been attached', function () {\n      bufferController.createSourceBuffers.restore();\n      bufferController.pendingTracks = {\n        video: {}\n      };\n      expect(bufferController.checkPendingTracks).to.throw();\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"exposes tracks from buffer controller through BUFFER_CREATED event","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":154,"column":74,"index":5567},"line":154,"code":"    it('exposes tracks from buffer controller through BUFFER_CREATED event', function (done) {\n      bufferController.createSourceBuffers.restore();\n      let video = document.createElement('video');\n      bufferController.onMediaAttaching(Events.MEDIA_ATTACHING, {\n        media: video\n      });\n      sandbox.stub(bufferController.mediaSource, 'addSourceBuffer');\n      hls.on(Hls.Events.BUFFER_CREATED, (event, data) => {\n        const tracks = data.tracks;\n        expect(bufferController.pendingTracks).to.not.equal(tracks);\n        expect(bufferController.tracks).to.equal(tracks);\n        done();\n      });\n      hls.once(Hls.Events.ERROR, (event, data) => {\n        // Async timeout prevents assertion from throwing in event handler\n        self.setTimeout(() => {\n          expect(data.error.message).to.equal(null);\n          done();\n        });\n      });\n      bufferController.pendingTracks = {\n        video: {\n          container: 'video/mp4',\n          codec: 'avc1.42e01e'\n        }\n      };\n      bufferController.checkPendingTracks();\n      video = null;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"expects one bufferCodec event by default","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":183,"column":48,"index":6622},"line":183,"code":"    it('expects one bufferCodec event by default', function () {\n      bufferController.onManifestParsed(Events.MANIFEST_PARSED, {});\n      expect(bufferController.bufferCodecEventsExpected).to.equal(1);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"expects two bufferCodec events if altAudio is signaled","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":187,"column":62,"index":6848},"line":187,"code":"    it('expects two bufferCodec events if altAudio is signaled', function () {\n      bufferController.onManifestParsed(Events.MANIFEST_PARSED, {\n        altAudio: true\n      });\n      expect(bufferController.bufferCodecEventsExpected).to.equal(2);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"expects one bufferCodec event if altAudio is signaled with audio only","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":193,"column":77,"index":7119},"line":193,"code":"    it('expects one bufferCodec event if altAudio is signaled with audio only', function () {\n      bufferController.onManifestParsed(Events.MANIFEST_PARSED, {\n        altAudio: true,\n        audio: true,\n        video: false\n      });\n      expect(bufferController.bufferCodecEventsExpected).to.equal(1);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"creates sourceBuffers when no more BUFFER_CODEC events are expected","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":201,"column":75,"index":7431},"line":201,"code":"    it('creates sourceBuffers when no more BUFFER_CODEC events are expected', function () {\n      bufferController.pendingTracks = {\n        video: {}\n      };\n      bufferController.checkPendingTracks();\n      expect(createSbStub).to.have.been.calledOnce;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"creates sourceBuffers on the first even if two tracks are received","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":208,"column":74,"index":7695},"line":208,"code":"    it('creates sourceBuffers on the first even if two tracks are received', function () {\n      bufferController.pendingTracks = {\n        audio: {},\n        video: {}\n      };\n      bufferController.bufferCodecEventsExpected = 2;\n      bufferController.checkPendingTracks();\n      expect(createSbStub).to.have.been.calledOnce;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"does not create sourceBuffers when BUFFER_CODEC events are expected","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":217,"column":75,"index":8033},"line":217,"code":"    it('does not create sourceBuffers when BUFFER_CODEC events are expected', function () {\n      bufferController.pendingTracks = {\n        video: {}\n      };\n      bufferController.bufferCodecEventsExpected = 1;\n      bufferController.checkPendingTracks();\n      expect(createSbStub).to.not.have.been.called;\n      expect(bufferController.bufferCodecEventsExpected).to.equal(1);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"checks pending tracks in onMediaSourceOpen","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":226,"column":50,"index":8397},"line":226,"code":"    it('checks pending tracks in onMediaSourceOpen', function () {\n      bufferController._onMediaSourceOpen();\n      expect(checkPendingTracksSpy).to.have.been.calledOnce;\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"checks pending tracks even when more events are expected","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":230,"column":64,"index":8592},"line":230,"code":"    it('checks pending tracks even when more events are expected', function () {\n      bufferController.sourceBuffer = {};\n      bufferController.mediaSource = {\n        readyState: 'open'\n      };\n      bufferController.bufferCodecEventsExpected = 2;\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {});\n      expect(checkPendingTracksSpy).to.have.been.calledOnce;\n      expect(bufferController.bufferCodecEventsExpected).to.equal(1);\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {});\n      expect(checkPendingTracksSpy).to.have.been.calledTwice;\n      expect(bufferController.bufferCodecEventsExpected).to.equal(0);\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"creates the expected amount of sourceBuffers given the standard event flow","suites":["BufferController tests","sourcebuffer creation"],"updatePoint":{"line":243,"column":82,"index":9263},"line":243,"code":"    it('creates the expected amount of sourceBuffers given the standard event flow', function () {\n      bufferController.sourceBuffer = {};\n      bufferController.mediaSource = {\n        readyState: 'open',\n        removeEventListener: sandbox.stub()\n      };\n      bufferController.onManifestParsed(Events.MANIFEST_PARSED, {\n        altAudio: true\n      });\n      bufferController._onMediaSourceOpen();\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {\n        audio: {}\n      });\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {\n        video: {}\n      });\n      expect(createSbStub).to.have.been.calledOnce;\n      expect(createSbStub).to.have.been.calledWith({\n        audio: {},\n        video: {}\n      });\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"calls changeType if needed and stores current track info","suites":["BufferController tests","onBufferCodecs"],"updatePoint":{"line":267,"column":64,"index":10039},"line":267,"code":"    it('calls changeType if needed and stores current track info', function () {\n      const getSourceBufferTypes = sandbox.stub(bufferController, 'getSourceBufferTypes').returns(['audio', 'video']);\n      /* eslint-disable-next-line no-unused-vars */\n      const appendChangeType = sandbox.stub(bufferController, 'appendChangeType');\n      const buffer = {\n        changeType: sandbox.stub()\n      };\n      const originalAudioTrack = {\n        id: 'main',\n        codec: 'mp4a.40.2',\n        levelCodec: undefined,\n        container: 'audio/mp4',\n        metadata: {\n          channelCount: 1\n        }\n      };\n      const newAudioTrack = {\n        id: 'main',\n        codec: 'mp4a.40.5',\n        levelCodec: undefined,\n        container: 'audio/mp4',\n        metadata: {\n          channelCount: 1\n        }\n      };\n      bufferController.tracks = {\n        audio: {\n          ...originalAudioTrack,\n          buffer\n        }\n      };\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {\n        audio: newAudioTrack\n      });\n      expect(getSourceBufferTypes).to.have.been.calledOnce;\n      expect(bufferController.appendChangeType).to.have.been.calledOnce;\n      expect(bufferController.appendChangeType).to.have.been.calledWith('audio', 'audio/mp4;codecs=mp4a.40.5');\n      expect(bufferController.tracks.audio).to.deep.equal({\n        buffer,\n        ...newAudioTrack\n      });\n      bufferController.onBufferCodecs(Events.BUFFER_CODECS, {\n        audio: originalAudioTrack\n      });\n      expect(getSourceBufferTypes).to.have.been.calledTwice;\n      expect(bufferController.appendChangeType).to.have.been.calledTwice;\n      expect(bufferController.appendChangeType).to.have.been.calledWith('audio', 'audio/mp4;codecs=mp4a.40.2');\n      expect(bufferController.tracks.audio).to.deep.equal({\n        buffer,\n        ...originalAudioTrack\n      });\n    });","file":"unit/controller/buffer-controller.js","skipped":false,"dir":"tests"},{"name":"Should choose the level whose dimensions are >= the media dimensions","suites":["CapLevelController","getMaxLevelByMediaSize"],"updatePoint":{"line":24,"column":76,"index":586},"line":24,"code":"    it('Should choose the level whose dimensions are >= the media dimensions', function () {\n      const expected = 0;\n      const actual = CapLevelController.getMaxLevelByMediaSize(levels, 300, 300);\n      expect(expected).to.equal(actual);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"Should choose the level whose bandwidth is greater if level dimensions are equal","suites":["CapLevelController","getMaxLevelByMediaSize"],"updatePoint":{"line":29,"column":88,"index":848},"line":29,"code":"    it('Should choose the level whose bandwidth is greater if level dimensions are equal', function () {\n      const expected = 2;\n      const actual = CapLevelController.getMaxLevelByMediaSize(levels, 500, 500);\n      expect(expected).to.equal(actual);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"Should choose the highest level if the media is greater than every level","suites":["CapLevelController","getMaxLevelByMediaSize"],"updatePoint":{"line":34,"column":80,"index":1102},"line":34,"code":"    it('Should choose the highest level if the media is greater than every level', function () {\n      const expected = 3;\n      const actual = CapLevelController.getMaxLevelByMediaSize(levels, 5000, 5000);\n      expect(expected).to.equal(actual);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"Should return -1 if there levels is empty","suites":["CapLevelController","getMaxLevelByMediaSize"],"updatePoint":{"line":39,"column":49,"index":1327},"line":39,"code":"    it('Should return -1 if there levels is empty', function () {\n      const expected = -1;\n      const actual = CapLevelController.getMaxLevelByMediaSize([], 5000, 5000);\n      expect(expected).to.equal(actual);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"Should return -1 if there levels is undefined","suites":["CapLevelController","getMaxLevelByMediaSize"],"updatePoint":{"line":44,"column":53,"index":1553},"line":44,"code":"    it('Should return -1 if there levels is undefined', function () {\n      const expected = -1;\n      const actual = CapLevelController.getMaxLevelByMediaSize(undefined, 5000, 5000);\n      expect(expected).to.equal(actual);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"gets 0 for width and height when the media element is not in the DOM","suites":["CapLevelController","getDimensions"],"updatePoint":{"line":76,"column":76,"index":2628},"line":76,"code":"    it('gets 0 for width and height when the media element is not in the DOM', function () {\n      const bounds = capLevelController.getDimensions();\n      expect(bounds.width).to.equal(0);\n      expect(bounds.height).to.equal(0);\n      expect(capLevelController.mediaWidth).to.equal(0);\n      expect(capLevelController.mediaHeight).to.equal(0);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"gets width and height attributes when the media element is not in the DOM","suites":["CapLevelController","getDimensions"],"updatePoint":{"line":83,"column":81,"index":2987},"line":83,"code":"    it('gets width and height attributes when the media element is not in the DOM', function () {\n      media.setAttribute('width', 320);\n      media.setAttribute('height', 240);\n      const pixelRatio = capLevelController.contentScaleFactor;\n      const bounds = capLevelController.getDimensions();\n      expect(bounds.width).to.equal(320);\n      expect(bounds.height).to.equal(240);\n      expect(capLevelController.mediaWidth).to.equal(320 * pixelRatio);\n      expect(capLevelController.mediaHeight).to.equal(240 * pixelRatio);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"gets client bounds width and height when media element is in the DOM","suites":["CapLevelController","getDimensions"],"updatePoint":{"line":93,"column":76,"index":3520},"line":93,"code":"    it('gets client bounds width and height when media element is in the DOM', function () {\n      media.style.width = '1280px';\n      media.style.height = '720px';\n      document.querySelector('#test-fixture').appendChild(media);\n      const pixelRatio = capLevelController.contentScaleFactor;\n      const bounds = capLevelController.getDimensions();\n      expect(bounds.width).to.equal(1280);\n      expect(bounds.height).to.equal(720);\n      expect(capLevelController.mediaWidth).to.equal(1280 * pixelRatio);\n      expect(capLevelController.mediaHeight).to.equal(720 * pixelRatio);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"gets valid width and height when the media element is attached after onManifestParsed","suites":["CapLevelController","getDimensions"],"updatePoint":{"line":104,"column":93,"index":4129},"line":104,"code":"    it('gets valid width and height when the media element is attached after onManifestParsed', function () {\n      hls = new Hls({\n        capLevelToPlayerSize: true\n      });\n      capLevelController = new CapLevelController(hls);\n      capLevelController.onManifestParsed(Events.MANIFEST_PARSED, {\n        levels\n      });\n      let bounds = capLevelController.getDimensions();\n      expect(bounds.width).to.equal(0);\n      expect(bounds.height).to.equal(0);\n      expect(capLevelController.mediaWidth).to.equal(0);\n      expect(capLevelController.mediaHeight).to.equal(0);\n      media.style.width = '1280px';\n      media.style.height = '720px';\n      document.querySelector('#test-fixture').appendChild(media);\n      capLevelController.onMediaAttaching(Events.MEDIA_ATTACHING, {\n        media\n      });\n      const pixelRatio = capLevelController.contentScaleFactor;\n      bounds = capLevelController.getDimensions();\n      expect(bounds.width).to.equal(1280);\n      expect(bounds.height).to.equal(720);\n      expect(capLevelController.mediaWidth).to.equal(1280 * pixelRatio);\n      expect(capLevelController.mediaHeight).to.equal(720 * pixelRatio);\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"immediately caps and sets a timer for monitoring size size","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":147,"column":68,"index":5834},"line":147,"code":"      it('immediately caps and sets a timer for monitoring size size', function () {\n        const detectPlayerSizeSpy = sinon.spy(capLevelController, 'detectPlayerSize');\n        capLevelController.startCapping();\n        expect(capLevelController.timer).to.exist;\n        expect(firstLevelSpy.set.calledOnce).to.be.true;\n        expect(detectPlayerSizeSpy.calledOnce).to.be.true;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"stops the capping timer and resets capping","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":154,"column":52,"index":6210},"line":154,"code":"      it('stops the capping timer and resets capping', function () {\n        capLevelController.autoLevelCapping = 4;\n        capLevelController.timer = 1;\n        capLevelController.stopCapping();\n        expect(capLevelController.autoLevelCapping).to.equal(Number.POSITIVE_INFINITY);\n        expect(capLevelController.restrictedLevels).to.be.empty;\n        expect(capLevelController.firstLevel).to.equal(-1);\n        expect(capLevelController.timer).to.not.exist;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"constructs with no restrictions","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":164,"column":39,"index":6681},"line":164,"code":"    it('constructs with no restrictions', function () {\n      expect(capLevelController.restrictedLevels).to.be.empty;\n      expect(capLevelController.timer).to.not.exist;\n      expect(capLevelController.autoLevelCapping).to.equal(Number.POSITIVE_INFINITY);\n      expect(firstLevelSpy.set.notCalled).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"starts capping on BUFFER_CODECS only if video is found","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":170,"column":62,"index":7024},"line":170,"code":"    it('starts capping on BUFFER_CODECS only if video is found', function () {\n      capLevelController.onBufferCodecs(Events.BUFFER_CODECS, {\n        video: {}\n      });\n      expect(startCappingSpy.calledOnce).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"does not start capping on BUFFER_CODECS if video is not found","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":176,"column":69,"index":7263},"line":176,"code":"    it('does not start capping on BUFFER_CODECS if video is not found', function () {\n      capLevelController.onBufferCodecs(Events.BUFFER_CODECS, {\n        audio: {}\n      });\n      expect(startCappingSpy.notCalled).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"starts capping if the video codec was found after the audio codec","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":182,"column":73,"index":7505},"line":182,"code":"    it('starts capping if the video codec was found after the audio codec', function () {\n      capLevelController.onBufferCodecs(Events.BUFFER_CODECS, {\n        audio: {}\n      });\n      expect(startCappingSpy.notCalled).to.be.true;\n      capLevelController.onBufferCodecs(Events.BUFFER_CODECS, {\n        video: {}\n      });\n      expect(startCappingSpy.calledOnce).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"receives level information from the MANIFEST_PARSED event","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":192,"column":65,"index":7884},"line":192,"code":"    it('receives level information from the MANIFEST_PARSED event', function () {\n      capLevelController.restrictedLevels = [1];\n      const data = {\n        levels: [{\n          foo: 'bar'\n        }],\n        firstLevel: 0\n      };\n      capLevelController.onManifestParsed(Events.MANIFEST_PARSED, data);\n      expect(capLevelController.firstLevel).to.equal(data.firstLevel);\n      expect(capLevelController.restrictedLevels).to.be.empty;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"should start capping in MANIFEST_PARSED if a video codec was signaled in the manifest","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":204,"column":93,"index":8362},"line":204,"code":"    it('should start capping in MANIFEST_PARSED if a video codec was signaled in the manifest', function () {\n      capLevelController.onManifestParsed(Events.MANIFEST_PARSED, {\n        video: {}\n      });\n      expect(startCappingSpy.calledOnce).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"does not start capping on MANIFEST_PARSED if no video codec was signaled in the manifest","suites":["CapLevelController","initialization","start and stop"],"updatePoint":{"line":210,"column":96,"index":8632},"line":210,"code":"    it('does not start capping on MANIFEST_PARSED if no video codec was signaled in the manifest', function () {\n      capLevelController.onManifestParsed(Events.MANIFEST_PARSED, {\n        levels: [{}],\n        altAudio: true\n      });\n      expect(startCappingSpy.notCalled).to.be.true;\n    });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"continues capping without second timer","suites":["CapLevelController","initialization","capLevelToPlayerSize"],"updatePoint":{"line":230,"column":48,"index":9442},"line":230,"code":"      it('continues capping without second timer', function () {\n        hls.capLevelToPlayerSize = true;\n        expect(startCappingSpy.calledOnce).to.be.true;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"stops the capping timer and resets capping","suites":["CapLevelController","initialization","capLevelToPlayerSize"],"updatePoint":{"line":234,"column":52,"index":9617},"line":234,"code":"      it('stops the capping timer and resets capping', function () {\n        hls.capLevelToPlayerSize = false;\n        expect(stopCappingSpy.calledOnce).to.be.true;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"calls for nextLevelSwitch when stopped capping","suites":["CapLevelController","initialization","capLevelToPlayerSize"],"updatePoint":{"line":238,"column":56,"index":9796},"line":238,"code":"      it('calls for nextLevelSwitch when stopped capping', function () {\n        hls.capLevelToPlayerSize = false;\n        expect(nextLevelSwitchSpy.calledOnce).to.be.true;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"updates config state of capping on change","suites":["CapLevelController","initialization","capLevelToPlayerSize"],"updatePoint":{"line":242,"column":51,"index":9974},"line":242,"code":"      it('updates config state of capping on change', function () {\n        hls.capLevelToPlayerSize = false;\n        expect(hls.config.capLevelToPlayerSize).to.be.false;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"stops capping when destroyed","suites":["CapLevelController","initialization","capLevelToPlayerSize"],"updatePoint":{"line":246,"column":38,"index":10142},"line":246,"code":"      it('stops capping when destroyed', function () {\n        capLevelController.destroy();\n        expect(stopCappingSpy.calledOnce).to.be.true;\n      });","file":"unit/controller/cap-level-controller.js","skipped":false,"dir":"tests"},{"name":"produces correctly serialized data","suites":["CMCDController","Query serialization"],"updatePoint":{"line":32,"column":42,"index":895},"line":32,"code":"    it('produces correctly serialized data', function () {\n      const query = CMCDController.toQuery(data);\n      const result = 'CMCD=br%3D52317%2Cbs%2Ccid%3D%22xyz%22%2C' + 'com.test-exists%2Ccom.test-hello%3D%22world%22%2C' + 'com.test-testing%3D1234%2C' + 'd%3D6067%2Cmtp%3D10000%2C' + 'nor%3D%22..%252Ftesting%252F3.m4v%22%2C' + 'nrr%3D%220-99%22%2C' + 'sid%3D%22c936730c-031e-4a73-976f-92bc34039c60%22';\n      expect(query).to.equal(result);\n    });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"appends with ?","suites":["CMCDController","Query serialization"],"updatePoint":{"line":37,"column":22,"index":1332},"line":37,"code":"    it('appends with ?', function () {\n      const result = CMCDController.appendQueryToUri('http://test.com', 'CMCD=d%3D6067');\n      expect(result).to.equal('http://test.com?CMCD=d%3D6067');\n    });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"appends with &","suites":["CMCDController","Query serialization"],"updatePoint":{"line":41,"column":22,"index":1533},"line":41,"code":"    it('appends with &', function () {\n      const result = CMCDController.appendQueryToUri('http://test.com?testing=123', 'CMCD=d%3D6067');\n      expect(result).to.equal('http://test.com?testing=123&CMCD=d%3D6067');\n    });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"produces all header shards","suites":["CMCDController","Header serialization"],"updatePoint":{"line":47,"column":34,"index":1825},"line":47,"code":"    it('produces all header shards', function () {\n      const header = CMCDController.toHeaders(data);\n      expect(header).to.deep.equal({\n        'CMCD-Object': 'br=52317,d=6067',\n        'CMCD-Request': 'com.test-exists,com.test-hello=\"world\",' + 'com.test-testing=1234,mtp=10000,' + 'nor=\"..%2Ftesting%2F3.m4v\",nrr=\"0-99\"',\n        'CMCD-Session': 'cid=\"xyz\",sid=\"c936730c-031e-4a73-976f-92bc34039c60\"',\n        'CMCD-Status': 'bs'\n      });\n    });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"ignores empty shards","suites":["CMCDController","Header serialization"],"updatePoint":{"line":56,"column":28,"index":2274},"line":56,"code":"    it('ignores empty shards', function () {\n      expect(CMCDController.toHeaders({\n        br: 200\n      })).to.deep.equal({\n        'CMCD-Object': 'br=200'\n      });\n    });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"does not modify requests when disabled","suites":["CMCDController","cmcdController instance","configuration"],"updatePoint":{"line":69,"column":48,"index":2641},"line":69,"code":"      it('does not modify requests when disabled', function () {\n        setupEach();\n        const {\n          config\n        } = cmcdController.hls;\n        expect(config.pLoader).to.equal(undefined);\n        expect(config.fLoader).to.equal(undefined);\n      });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"generates a session id if not provided","suites":["CMCDController","cmcdController instance","configuration"],"updatePoint":{"line":77,"column":48,"index":2906},"line":77,"code":"      it('generates a session id if not provided', function () {\n        setupEach({});\n        const c = Object.assign({\n          frag: {}\n        }, context);\n        cmcdController.applyPlaylistData(c);\n        const regex = new RegExp(`sid%3D%22${uuidRegex}%22`, 'i');\n        expect(regex.test(c.url)).to.equal(true);\n      });","file":"unit/controller/cmcd-controller.ts","skipped":false,"dir":"tests"},{"name":"returns default estimate if bw estimator not available yet","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":7,"column":64,"index":316},"line":7,"code":"  it('returns default estimate if bw estimator not available yet', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(0, 0, defaultEstimate);\n    expect(bwEstimator.getEstimate()).to.equal(5e5);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"returns last bitrate is fast=slow=0","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":12,"column":41,"index":541},"line":12,"code":"  it('returns last bitrate is fast=slow=0', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(0, 0, defaultEstimate);\n    bwEstimator.sample(8000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(1000000);\n    bwEstimator.sample(4000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(2000000);\n    bwEstimator.sample(1000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(8000000);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"returns correct value bitrate is slow=15,fast=4","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":22,"column":53,"index":1013},"line":22,"code":"  it('returns correct value bitrate is slow=15,fast=4', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(15, 4, defaultEstimate);\n    bwEstimator.sample(8000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(1000000);\n    bwEstimator.sample(4000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(1396480.1544736226, 0.000000001);\n    bwEstimator.sample(1000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(2056826.9489827948, 0.000000001);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"returns correct value bitrate is slow=9,fast=5","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":32,"column":52,"index":1537},"line":32,"code":"  it('returns correct value bitrate is slow=9,fast=5', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(9, 5, defaultEstimate);\n    bwEstimator.sample(8000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(1000000);\n    bwEstimator.sample(4000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(1439580.319105247, 0.000000001);\n    bwEstimator.sample(1000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(2208342.324322311, 0.000000001);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"returns correct value after updating slow and fast","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":42,"column":56,"index":2062},"line":42,"code":"  it('returns correct value after updating slow and fast', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(9, 3, defaultEstimate);\n    expect(bwEstimator.getEstimate()).to.equal(defaultEstimate);\n    bwEstimator.sample(8000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(1000000);\n    bwEstimator.sample(4000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(1439580.319105247, 0.000000001);\n    bwEstimator.update(15, 4);\n    expect(bwEstimator.getEstimate()).to.closeTo(1878125.393685882, 0.000000001);\n    bwEstimator.sample(1000, 1000000);\n    expect(bwEstimator.getEstimate()).to.closeTo(2966543.443461984, 0.000000001);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"returns correct value when updating before a sample","suites":["EwmaBandWidthEstimator"],"updatePoint":{"line":55,"column":57,"index":2766},"line":55,"code":"  it('returns correct value when updating before a sample', function () {\n    const defaultEstimate = 5e5;\n    const bwEstimator = new EwmaBandWidthEstimator(9, 3, defaultEstimate);\n    bwEstimator.update(15, 4);\n    expect(bwEstimator.getEstimate()).to.equal(defaultEstimate);\n    bwEstimator.sample(8000, 1000000);\n    expect(bwEstimator.getEstimate()).to.equal(1000000);\n  });","file":"unit/controller/ewma-bandwidth-estimator.ts","skipped":false,"dir":"tests"},{"name":"finds a fragment with SN sequential to the previous fragment","suites":["Fragment finders","findFragmentByPTS"],"updatePoint":{"line":26,"column":68,"index":1010},"line":26,"code":"    it('finds a fragment with SN sequential to the previous fragment', function () {\n      const actual = findFragmentByPTS(fragPrevious, mockFragments, bufferEnd, tolerance);\n      const resultSN = actual ? actual.sn : -1;\n      expect(actual).to.equal(mockFragments[3], 'Expected sn 3, found sn segment ' + resultSN);\n      expect(binarySearchSpy).to.have.not.been.called;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"chooses the fragment with the next SN if its contiguous with the end of the buffer","suites":["Fragment finders","findFragmentByPTS"],"updatePoint":{"line":32,"column":90,"index":1415},"line":32,"code":"    it('chooses the fragment with the next SN if its contiguous with the end of the buffer', function () {\n      const actual = findFragmentByPTS(mockFragments[0], mockFragments, mockFragments[0].duration, tolerance);\n      expect(actual).to.equal(mockFragments[1], `expected sn ${mockFragments[1].sn}, but got sn ${actual ? actual.sn : null}`);\n      expect(binarySearchSpy).to.have.not.been.called;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"chooses the fragment with the next SN if its contiguous with the end of previous fragment","suites":["Fragment finders","findFragmentByPTS"],"updatePoint":{"line":37,"column":97,"index":1831},"line":37,"code":"    it('chooses the fragment with the next SN if its contiguous with the end of previous fragment', function () {\n      // See https://github.com/video-dev/hls.js/issues/2776\n      const bufferEnd = 60.139636;\n      const fragments = [{\n        deltaPTS: 0.012346258503441732,\n        cc: 2,\n        duration: 5.017346258503444,\n        start: 55.21705215419478,\n        sn: 11,\n        level: 0\n      }, {\n        deltaPTS: 0,\n        cc: 2,\n        duration: 0.033,\n        start: 60.234398412698226,\n        sn: 12,\n        level: 0\n      }];\n      const fragPrevious = fragments[0];\n      const actual = findFragmentByPTS(fragPrevious, fragments, bufferEnd, tolerance);\n      expect(actual).to.equal(fragments[1], `expected sn ${fragments[1].sn}, but got sn ${actual ? actual.sn : null}`);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"uses BinarySearch to find a fragment if the subsequent one is not within tolerance","suites":["Fragment finders","findFragmentByPTS"],"updatePoint":{"line":59,"column":90,"index":2626},"line":59,"code":"    it('uses BinarySearch to find a fragment if the subsequent one is not within tolerance', function () {\n      const fragments = [mockFragments[0], mockFragments[mockFragments.length - 1]];\n      findFragmentByPTS(fragments[0], fragments, bufferEnd, tolerance);\n      expect(binarySearchSpy).to.have.been.calledOnce;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns null when there is a gap in sn and start-end time","suites":["Fragment finders","findFragmentByPTS"],"updatePoint":{"line":64,"column":65,"index":2928},"line":64,"code":"    it('returns null when there is a gap in sn and start-end time', function () {\n      const bufferEnd = 49;\n      const fragments = [{\n        deltaPTS: 0,\n        cc: 0,\n        duration: 5,\n        start: 54,\n        sn: 5,\n        level: 0\n      }, {\n        deltaPTS: 0,\n        cc: 0,\n        duration: 5,\n        start: 59,\n        sn: 5,\n        level: 0\n      }, {\n        deltaPTS: 0,\n        cc: 0,\n        duration: 5,\n        start: 64,\n        sn: 5,\n        level: 0\n      }];\n      // sn is not contiguous, and there is a gap between start and end\n      const fragPrevious = {\n        deltaPTS: 0,\n        cc: 0,\n        duration: 5,\n        start: 44,\n        sn: 1,\n        level: 0\n      };\n      const actual = findFragmentByPTS(fragPrevious, fragments, bufferEnd, tolerance);\n      expect(actual).to.equal(null);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns 0 if the fragment range is equal to the end of the buffer","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":103,"column":73,"index":3869},"line":103,"code":"    it('returns 0 if the fragment range is equal to the end of the buffer', function () {\n      const frag = {\n        start: 5,\n        duration: 5 - tolerance\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns 0 if the fragment range is greater than end of the buffer","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":111,"column":73,"index":4151},"line":111,"code":"    it('returns 0 if the fragment range is greater than end of the buffer', function () {\n      const frag = {\n        start: 5,\n        duration: 5\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns 1 if the fragment range is less than the end of the buffer","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":119,"column":74,"index":4422},"line":119,"code":"    it('returns 1 if the fragment range is less than the end of the buffer', function () {\n      const frag = {\n        start: 0,\n        duration: 5\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(1);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns -1 if the fragment range is greater than the end of the buffer","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":127,"column":78,"index":4697},"line":127,"code":"    it('returns -1 if the fragment range is greater than the end of the buffer', function () {\n      const frag = {\n        start: 6,\n        duration: 5\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(-1);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"does not skip very small fragments at the start","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":135,"column":55,"index":4950},"line":135,"code":"    it('does not skip very small fragments at the start', function () {\n      const frag = {\n        start: 0.2,\n        duration: 0.1,\n        deltaPTS: 0.1\n      };\n      const actual = fragmentWithinToleranceTest(0, tolerance, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"does not skip very small fragments","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":144,"column":42,"index":5216},"line":144,"code":"    it('does not skip very small fragments', function () {\n      const frag = {\n        start: 5,\n        duration: 0.1,\n        deltaPTS: 0.1\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"does not skip very small fragments without deltaPTS","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":153,"column":59,"index":5497},"line":153,"code":"    it('does not skip very small fragments without deltaPTS', function () {\n      const frag = {\n        start: 5,\n        duration: 0.1\n      };\n      const actual = fragmentWithinToleranceTest(5, tolerance, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"does not skip fragments when searching near boundaries","suites":["Fragment finders","fragmentWithinToleranceTest"],"updatePoint":{"line":161,"column":62,"index":5758},"line":161,"code":"    it('does not skip fragments when searching near boundaries', function () {\n      const frag = {\n        start: 19.96916,\n        duration: 9.98458\n      };\n      const actual = fragmentWithinToleranceTest(29, 0.25, frag);\n      expect(actual).to.equal(0);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"finds a fragment with endProgramDateTime greater than the reference PDT","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":171,"column":79,"index":6095},"line":171,"code":"    it('finds a fragment with endProgramDateTime greater than the reference PDT', function () {\n      const foundFragment = findFragmentByPDT(mockFragments, fragPrevious.endProgramDateTime + 1);\n      expect(foundFragment).to.equal(mockFragments[2]);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns null when the reference pdt is outside of the pdt range of the fragment array","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":175,"column":93,"index":6368},"line":175,"code":"    it('returns null when the reference pdt is outside of the pdt range of the fragment array', function () {\n      let foundFragment = findFragmentByPDT(mockFragments, mockFragments[0].programDateTime - 1);\n      expect(foundFragment).to.not.exist;\n      foundFragment = findFragmentByPDT(mockFragments, mockFragments[mockFragments.length - 1].endProgramDateTime + 1);\n      expect(foundFragment).to.not.exist;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"is able to find the first fragment","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":181,"column":42,"index":6737},"line":181,"code":"    it('is able to find the first fragment', function () {\n      const foundFragment = findFragmentByPDT(mockFragments, mockFragments[0].programDateTime);\n      const resultSN = foundFragment ? foundFragment.sn : -1;\n      expect(foundFragment).to.equal(mockFragments[0], 'Expected sn 0, found sn segment ' + resultSN);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"is able to find the last fragment","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":186,"column":41,"index":7064},"line":186,"code":"    it('is able to find the last fragment', function () {\n      const foundFragment = findFragmentByPDT(mockFragments, mockFragments[mockFragments.length - 1].programDateTime);\n      const resultSN = foundFragment ? foundFragment.sn : -1;\n      expect(foundFragment).to.equal(mockFragments[4], 'Expected sn 4, found sn segment ' + resultSN);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"is able to find a fragment if the PDT value is 0","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":191,"column":56,"index":7429},"line":191,"code":"    it('is able to find a fragment if the PDT value is 0', function () {\n      const fragments = [{\n        programDateTime: 0,\n        endProgramDateTime: 1,\n        duration: 0.001\n      }, {\n        programDateTime: 1,\n        endProgramDateTime: 2,\n        duration: 0.001\n      }];\n      const actual = findFragmentByPDT(fragments, 0);\n      expect(actual).to.equal(fragments[0]);\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns null when passed undefined arguments","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":204,"column":52,"index":7819},"line":204,"code":"    it('returns null when passed undefined arguments', function () {\n      expect(findFragmentByPDT(mockFragments)).to.not.exist;\n      expect(findFragmentByPDT(undefined, 9001)).to.not.exist;\n      expect(findFragmentByPDT()).to.not.exist;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns null when passed an empty frag array","suites":["Fragment finders","findFragmentByPDT"],"updatePoint":{"line":209,"column":52,"index":8068},"line":209,"code":"    it('returns null when passed an empty frag array', function () {\n      expect(findFragmentByPDT([], 9001)).to.not.exist;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns true if the fragment range is equal to the end of the buffer","suites":["Fragment finders","pdtWithinToleranceTest"],"updatePoint":{"line":216,"column":76,"index":8411},"line":216,"code":"    it('returns true if the fragment range is equal to the end of the buffer', function () {\n      const frag = {\n        programDateTime: pdtBufferEnd,\n        endProgramDateTime: pdtBufferEnd + 5000 - tolerance * 1000,\n        duration: 5\n      };\n      const actual = pdtWithinToleranceTest(pdtBufferEnd, tolerance, frag);\n      expect(actual).to.be.true;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"returns false if the fragment range is less than the end of the buffer","suites":["Fragment finders","pdtWithinToleranceTest"],"updatePoint":{"line":225,"column":78,"index":8780},"line":225,"code":"    it('returns false if the fragment range is less than the end of the buffer', function () {\n      const frag = {\n        programDateTime: pdtBufferEnd - 10000,\n        endProgramDateTime: pdtBufferEnd - 5000,\n        duration: 5\n      };\n      const actual = pdtWithinToleranceTest(pdtBufferEnd, tolerance, frag);\n      expect(actual).to.be.false;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"does not skip very small fragments","suites":["Fragment finders","pdtWithinToleranceTest"],"updatePoint":{"line":234,"column":42,"index":9103},"line":234,"code":"    it('does not skip very small fragments', function () {\n      const frag = {\n        programDateTime: pdtBufferEnd + 200,\n        endProgramDateTime: pdtBufferEnd + 300,\n        duration: 0.1,\n        deltaPTS: 0.1\n      };\n      const actual = pdtWithinToleranceTest(pdtBufferEnd, tolerance, frag);\n      expect(actual).to.be.true;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"accounts for tolerance when checking the endProgramDateTime of the fragment","suites":["Fragment finders","pdtWithinToleranceTest"],"updatePoint":{"line":244,"column":83,"index":9488},"line":244,"code":"    it('accounts for tolerance when checking the endProgramDateTime of the fragment', function () {\n      const frag = {\n        programDateTime: pdtBufferEnd,\n        endProgramDateTime: pdtBufferEnd + tolerance * 1000,\n        duration: 5\n      };\n      const actual = pdtWithinToleranceTest(pdtBufferEnd, tolerance, frag);\n      expect(actual).to.be.false;\n    });","file":"unit/controller/fragment-finders.js","skipped":false,"dir":"tests"},{"name":"detects fragments that partially loaded","suites":["FragmentTracker","getPartialFragment"],"updatePoint":{"line":29,"column":47,"index":1221},"line":29,"code":"    it('detects fragments that partially loaded', function () {\n      // Get the partial fragment at a time\n      const partialFragment1 = fragmentTracker.getPartialFragment(0);\n      expect(partialFragment1).to.equal(fragment);\n      const partialFragment2 = fragmentTracker.getPartialFragment(0.5);\n      expect(partialFragment2).to.equal(fragment);\n      const partialFragment3 = fragmentTracker.getPartialFragment(1);\n      expect(partialFragment3).to.equal(fragment);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"returns null when time is not inside partial fragment","suites":["FragmentTracker","getPartialFragment"],"updatePoint":{"line":38,"column":61,"index":1716},"line":38,"code":"    it('returns null when time is not inside partial fragment', function () {\n      const partialFragment = fragmentTracker.getPartialFragment(1.5);\n      expect(partialFragment).to.not.exist;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"detects fragments that never loaded","suites":["FragmentTracker","getState"],"updatePoint":{"line":57,"column":43,"index":2357},"line":57,"code":"    it('detects fragments that never loaded', function () {\n      const fragment = addFragment();\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.APPENDING);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"detects fragments that loaded properly","suites":["FragmentTracker","getState"],"updatePoint":{"line":61,"column":46,"index":2550},"line":61,"code":"    it('detects fragments that loaded properly', function () {\n      const fragment = addFragment();\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0,\n        endPTS: 1\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.OK);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"detects partial fragments","suites":["FragmentTracker","getState"],"updatePoint":{"line":70,"column":33,"index":2925},"line":70,"code":"    it('detects partial fragments', function () {\n      const fragment = addFragment();\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0.5,\n        endPTS: 2\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.PARTIAL);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"removes evicted partial fragments","suites":["FragmentTracker","getState"],"updatePoint":{"line":79,"column":41,"index":3315},"line":79,"code":"    it('removes evicted partial fragments', function () {\n      const fragment = addFragment();\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0.5,\n        endPTS: 2\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.PARTIAL);\n\n      // Trim the buffer\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0.75,\n        endPTS: 2\n      }]));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.NOT_LOADED);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should return buffered fragment if found it","suites":["FragmentTracker","getBufferedFrag"],"updatePoint":{"line":104,"column":51,"index":4185},"line":104,"code":"    it('should return buffered fragment if found it', function () {\n      const fragments = [\n      // 0-1\n      createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 1-2\n      createMockFragment({\n        startPTS: 1,\n        endPTS: 2,\n        sn: 2,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 2-3\n      createMockFragment({\n        startPTS: 2,\n        endPTS: 3,\n        sn: 3,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO])];\n      // load fragments to buffered\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0,\n        endPTS: 3\n      }]));\n      fragments.forEach(fragment => {\n        triggerFragLoadedAndFragBuffered(hls, fragment);\n      });\n      expect(fragmentTracker.getBufferedFrag(0.0, PlaylistLevelType.MAIN)).to.equal(fragments[0]);\n      expect(fragmentTracker.getBufferedFrag(0.1, PlaylistLevelType.MAIN)).to.equal(fragments[0]);\n      expect(fragmentTracker.getBufferedFrag(1.0, PlaylistLevelType.MAIN)).to.equal(fragments[1]);\n      expect(fragmentTracker.getBufferedFrag(1.1, PlaylistLevelType.MAIN)).to.equal(fragments[1]);\n      expect(fragmentTracker.getBufferedFrag(2.0, PlaylistLevelType.MAIN)).to.equal(fragments[2]);\n      expect(fragmentTracker.getBufferedFrag(2.1, PlaylistLevelType.MAIN)).to.equal(fragments[2]);\n      expect(fragmentTracker.getBufferedFrag(2.9, PlaylistLevelType.MAIN)).to.equal(fragments[2]);\n      expect(fragmentTracker.getBufferedFrag(3.0, PlaylistLevelType.MAIN)).to.equal(fragments[2]);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should return null if found it, but it is not buffered","suites":["FragmentTracker","getBufferedFrag"],"updatePoint":{"line":147,"column":62,"index":6013},"line":147,"code":"    it('should return null if found it, but it is not buffered', function () {\n      const fragments = [\n      // 0-1\n      createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 1-2\n      createMockFragment({\n        startPTS: 1,\n        endPTS: 2,\n        sn: 2,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 2-3\n      createMockFragment({\n        startPTS: 2,\n        endPTS: 3,\n        sn: 3,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO])];\n      // load fragments, but it is not buffered\n      fragments.forEach(fragment => {\n        triggerFragLoaded(hls, fragment);\n      });\n      expect(fragmentTracker.getBufferedFrag(0, PlaylistLevelType.MAIN)).to.not.exist;\n      expect(fragmentTracker.getBufferedFrag(1, PlaylistLevelType.MAIN)).to.not.exist;\n      expect(fragmentTracker.getBufferedFrag(2, PlaylistLevelType.MAIN)).to.not.exist;\n      expect(fragmentTracker.getBufferedFrag(3, PlaylistLevelType.MAIN)).to.not.exist;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should return null if anyone does not match the position","suites":["FragmentTracker","getBufferedFrag"],"updatePoint":{"line":182,"column":64,"index":7275},"line":182,"code":"    it('should return null if anyone does not match the position', function () {\n      triggerFragLoadedAndFragBuffered(hls, createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]));\n      // not found\n      expect(fragmentTracker.getBufferedFrag(1.1, PlaylistLevelType.MAIN)).to.not.exist;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should return null if fragmentTracker not have any fragments","suites":["FragmentTracker","getBufferedFrag"],"updatePoint":{"line":193,"column":68,"index":7722},"line":193,"code":"    it('should return null if fragmentTracker not have any fragments', function () {\n      expect(fragmentTracker.getBufferedFrag(0, PlaylistLevelType.MAIN)).to.not.exist;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should return null if not found match levelType","suites":["FragmentTracker","getBufferedFrag"],"updatePoint":{"line":196,"column":55,"index":7889},"line":196,"code":"    it('should return null if not found match levelType', function () {\n      triggerFragLoadedAndFragBuffered(hls, createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.AUDIO // <= level type is not \"main\"\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]));\n      expect(fragmentTracker.getBufferedFrag(0, PlaylistLevelType.MAIN)).to.not.exist;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"supports audio buffer","suites":["FragmentTracker","onFragBuffered"],"updatePoint":{"line":211,"column":29,"index":8458},"line":211,"code":"    it('supports audio buffer', function () {\n      fragment = createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]);\n      triggerFragLoaded(hls, fragment);\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0,\n        endPTS: 2\n      }], [{\n        startPTS: 0.5,\n        endPTS: 2\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.PARTIAL);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"supports video buffer","suites":["FragmentTracker","onFragBuffered"],"updatePoint":{"line":230,"column":29,"index":9108},"line":230,"code":"    it('supports video buffer', function () {\n      fragment = createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]);\n      triggerFragLoaded(hls, fragment);\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0.5,\n        endPTS: 2\n      }], [{\n        startPTS: 0,\n        endPTS: 2\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.PARTIAL);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"supports audio only buffer","suites":["FragmentTracker","onFragBuffered"],"updatePoint":{"line":249,"column":34,"index":9763},"line":249,"code":"    it('supports audio only buffer', function () {\n      fragment = createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.AUDIO\n      }, [ElementaryStreamTypes.AUDIO]);\n      triggerFragLoaded(hls, fragment);\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0.5,\n        endPTS: 2\n      }], [{\n        startPTS: 0,\n        endPTS: 2\n      }]));\n      hls.trigger(Events.FRAG_BUFFERED, createFragBufferedData(fragment, true));\n      expect(fragmentTracker.getState(fragment)).to.equal(FragmentState.OK);\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should remove fragment","suites":["FragmentTracker","removeFragment"],"updatePoint":{"line":278,"column":30,"index":10638},"line":278,"code":"    it('should remove fragment', function () {\n      const fragment = createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]);\n      // load fragments to buffered\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0,\n        endPTS: 1\n      }]));\n      triggerFragLoadedAndFragBuffered(hls, fragment);\n      expect(fragmentTracker.hasFragment(fragment)).to.be.true;\n      // Remove the fragment\n      fragmentTracker.removeFragment(fragment);\n      // Check\n      expect(fragmentTracker.hasFragment(fragment)).to.be.false;\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should remove all fragments","suites":["FragmentTracker","removeAllFragments"],"updatePoint":{"line":308,"column":35,"index":11616},"line":308,"code":"    it('should remove all fragments', function () {\n      const fragments = [\n      // 0-1\n      createMockFragment({\n        startPTS: 0,\n        endPTS: 1,\n        sn: 1,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 1-2\n      createMockFragment({\n        startPTS: 1,\n        endPTS: 2,\n        sn: 2,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO]),\n      // 2-3\n      createMockFragment({\n        startPTS: 2,\n        endPTS: 3,\n        sn: 3,\n        level: 1,\n        type: PlaylistLevelType.MAIN\n      }, [ElementaryStreamTypes.AUDIO, ElementaryStreamTypes.VIDEO])];\n      // load fragments to buffered\n      hls.trigger(Events.BUFFER_APPENDED, createBufferAppendedData([{\n        startPTS: 0,\n        endPTS: 3\n      }]));\n      fragments.forEach(fragment => {\n        triggerFragLoadedAndFragBuffered(hls, fragment);\n      });\n      // before\n      fragments.forEach(fragment => {\n        expect(fragmentTracker.hasFragment(fragment), 'has fragments before removing').to.be.true;\n      });\n      // Remove all fragments\n      fragmentTracker.removeAllFragments();\n      // after\n      fragments.forEach(fragment => {\n        expect(fragmentTracker.hasFragment(fragment), 'has not fragments after removing').to.be.false;\n      });\n    });","file":"unit/controller/fragment-tracker.ts","skipped":false,"dir":"tests"},{"name":"should increment the currentTime by a multiple of nudgeRetry and the configured nudge amount","suites":["GapController","_tryNudgeBuffer"],"updatePoint":{"line":25,"column":100,"index":924},"line":25,"code":"    it('should increment the currentTime by a multiple of nudgeRetry and the configured nudge amount', function () {\n      for (let i = 0; i < config.nudgeMaxRetry; i++) {\n        triggerSpy.resetHistory();\n        const expected = media.currentTime + (i + 1) * config.nudgeOffset;\n        gapController._tryNudgeBuffer();\n        expect(media.currentTime).to.equal(expected);\n        expect(triggerSpy).to.have.been.calledWith(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n          fatal: false\n        });\n      }\n      triggerSpy.resetHistory();\n      gapController._tryNudgeBuffer();\n      expect(triggerSpy).not.to.have.been.calledWith(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        fatal: false\n      });\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not increment the currentTime if the max amount of nudges has been attempted","suites":["GapController","_tryNudgeBuffer"],"updatePoint":{"line":45,"column":91,"index":1768},"line":45,"code":"    it('should not increment the currentTime if the max amount of nudges has been attempted', function () {\n      config.nudgeMaxRetry = 0;\n      gapController._tryNudgeBuffer();\n      expect(media.currentTime).to.equal(0);\n      expect(triggerSpy).to.have.been.calledWith(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: true\n      });\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should report a stall with the current buffer length if it has not already been reported","suites":["GapController","_reportStall"],"updatePoint":{"line":57,"column":96,"index":2237},"line":57,"code":"    it('should report a stall with the current buffer length if it has not already been reported', function () {\n      gapController._reportStall({\n        len: 42\n      });\n      expect(triggerSpy).to.have.been.calledWith(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        buffer: 42\n      });\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not report a stall if it was already reported","suites":["GapController","_reportStall"],"updatePoint":{"line":68,"column":60,"index":2589},"line":68,"code":"    it('should not report a stall if it was already reported', function () {\n      gapController.stallReported = true;\n      gapController._reportStall({\n        len: 42\n      });\n      expect(triggerSpy).to.not.have.been.called;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should nudge when stalling close to the buffer end","suites":["GapController","_tryFixBufferStall"],"updatePoint":{"line":77,"column":58,"index":2878},"line":77,"code":"    it('should nudge when stalling close to the buffer end', function () {\n      const mockBufferInfo = {\n        len: 1\n      };\n      const mockStallDuration = (config.highBufferWatchdogPeriod + 1) * 1000;\n      const nudgeStub = sandbox.stub(gapController, '_tryNudgeBuffer');\n      gapController._tryFixBufferStall(mockBufferInfo, mockStallDuration);\n      expect(nudgeStub).to.have.been.calledOnce;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not nudge when briefly stalling close to the buffer end","suites":["GapController","_tryFixBufferStall"],"updatePoint":{"line":86,"column":70,"index":3302},"line":86,"code":"    it('should not nudge when briefly stalling close to the buffer end', function () {\n      const mockBufferInfo = {\n        len: 1\n      };\n      const mockStallDuration = config.highBufferWatchdogPeriod / 2 * 1000;\n      const nudgeStub = sandbox.stub(gapController, '_tryNudgeBuffer');\n      gapController._tryFixBufferStall(mockBufferInfo, mockStallDuration);\n      expect(nudgeStub).to.have.not.been.called;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not nudge when too far from the buffer end","suites":["GapController","_tryFixBufferStall"],"updatePoint":{"line":95,"column":57,"index":3711},"line":95,"code":"    it('should not nudge when too far from the buffer end', function () {\n      const mockBufferInfo = {\n        len: 0.09\n      };\n      const mockStallDuration = (config.highBufferWatchdogPeriod + 1) * 1000;\n      const nudgeStub = sandbox.stub(gapController, '_tryNudgeBuffer');\n      gapController._tryFixBufferStall(mockBufferInfo, mockStallDuration);\n      expect(nudgeStub).to.have.not.been.called;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should try to jump partial fragments when detected","suites":["GapController","_tryFixBufferStall"],"updatePoint":{"line":104,"column":58,"index":4126},"line":104,"code":"    it('should try to jump partial fragments when detected', function () {\n      sandbox.stub(gapController.fragmentTracker, 'getPartialFragment').returns({});\n      const skipHoleStub = sandbox.stub(gapController, '_trySkipBufferHole');\n      gapController._tryFixBufferStall({\n        len: 0\n      });\n      expect(skipHoleStub).to.have.been.calledOnce;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not try to jump partial fragments when none are detected","suites":["GapController","_tryFixBufferStall"],"updatePoint":{"line":112,"column":71,"index":4503},"line":112,"code":"    it('should not try to jump partial fragments when none are detected', function () {\n      sandbox.stub(gapController.fragmentTracker, 'getPartialFragment').returns(null);\n      const skipHoleStub = sandbox.stub(gapController, '_trySkipBufferHole');\n      gapController._tryFixBufferStall({\n        len: 0\n      });\n      expect(skipHoleStub).to.have.not.been.called;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should try to fix a stall if expected to be playing","suites":["GapController","media clock polling"],"updatePoint":{"line":191,"column":59,"index":6994},"line":191,"code":"    it('should try to fix a stall if expected to be playing', function () {\n      const fixStallStub = sandbox.stub(gapController, '_tryFixBufferStall');\n      setStalling();\n      gapController.poll(lastCurrentTime);\n\n      // The first poll call made while stalling just sets stall flags\n      expect(gapController.stalled).to.be.a('number');\n      expect(gapController.stallReported).to.be.false;\n      gapController.poll(lastCurrentTime);\n      expect(fixStallStub).to.have.been.calledOnce;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should reset stall flags when no longer stalling","suites":["GapController","media clock polling"],"updatePoint":{"line":202,"column":56,"index":7494},"line":202,"code":"    it('should reset stall flags when no longer stalling', function () {\n      setNotStalling();\n      gapController.stallReported = true;\n      gapController.nudgeRetry = 1;\n      gapController.stalled = 4200;\n      const fixStallStub = sandbox.stub(gapController, '_tryFixBufferStall');\n      gapController.poll(lastCurrentTime);\n      expect(gapController.stalled).to.not.exist;\n      expect(gapController.nudgeRetry).to.equal(0);\n      expect(gapController.stallReported).to.be.false;\n      expect(fixStallStub).to.not.have.been.called;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not detect stalls when ended, unbuffered or seeking","suites":["GapController","media clock polling"],"updatePoint":{"line":214,"column":66,"index":8053},"line":214,"code":"    it('should not detect stalls when ended, unbuffered or seeking', function () {\n      wallClock.tick(TIMER_STEP_MS);\n\n      // we need to play a bit to get past the moved check\n      tickMediaClock();\n      isStalling = true;\n      mockMedia.ended = true;\n      tickMediaClock();\n      expect(gapController.stalled).to.equal(null, 'ended');\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n      mockMedia.ended = false;\n      mockTimeRangesData.length = 0;\n      tickMediaClock();\n      expect(gapController.stalled).to.equal(null, 'empty buffer');\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n      mockTimeRangesData = [[0.1, 0.2], [0.4, 0.5]];\n      mockMedia.seeking = true;\n\n      // tickMediaClock(100)\n      expect(gapController.stalled).to.equal(null, 'seeking');\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not detect stalls when loading an earlier fragment while seeking","suites":["GapController","media clock polling"],"updatePoint":{"line":236,"column":79,"index":8930},"line":236,"code":"    it('should not detect stalls when loading an earlier fragment while seeking', function () {\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n      mockMedia.currentTime += 0.1;\n      gapController.poll(0);\n      expect(gapController.stalled).to.equal(null, 'buffered start');\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n      mockMedia.currentTime += 5;\n      mockMedia.seeking = true;\n      mockTimeRangesData.length = 1;\n      mockTimeRangesData[0] = [5.5, 10];\n      gapController.poll(mockMedia.currentTime - 5);\n      expect(gapController.stalled).to.equal(null, 'new seek position');\n      wallClock.tick(2 * STALL_HANDLING_RETRY_PERIOD_MS);\n      gapController.poll(mockMedia.currentTime, {\n        start: 5\n      });\n      expect(gapController.stalled).to.equal(null, 'seeking while loading fragment');\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should trigger reportStall when stalling for 250ms or longer","suites":["GapController","media clock polling"],"updatePoint":{"line":254,"column":68,"index":9765},"line":254,"code":"    it('should trigger reportStall when stalling for 250ms or longer', function () {\n      setStalling();\n      wallClock.tick(250);\n      gapController.stalled = 1;\n      gapController.poll(lastCurrentTime);\n      expect(reportStallSpy).to.not.have.been.called;\n      wallClock.tick(251);\n      gapController.poll(lastCurrentTime);\n      expect(reportStallSpy).to.have.been.calledOnce;\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should not handle a stall (clock not advancing) when media has played before and is now paused","suites":["GapController","media clock polling"],"updatePoint":{"line":264,"column":102,"index":10194},"line":264,"code":"    it('should not handle a stall (clock not advancing) when media has played before and is now paused', function () {\n      wallClock.tick(TIMER_STEP_MS);\n      tickMediaClock();\n      expect(gapController.moved).to.equal(true);\n      expect(gapController.stalled).to.equal(null);\n      mockMedia.paused = true;\n      isStalling = true;\n      tickMediaClock();\n      expect(gapController.stalled).to.equal(null);\n      mockMedia.paused = false;\n      tickMediaClock();\n      expect(gapController.stalled).to.equal(TIMER_STEP_MS);\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should skip any initial gap before playing on the second poll (so that Chrome can jump the gap first)","suites":["GapController","media clock polling"],"updatePoint":{"line":277,"column":109,"index":10740},"line":277,"code":"    it('should skip any initial gap before playing on the second poll (so that Chrome can jump the gap first)', function () {\n      wallClock.tick(TIMER_STEP_MS);\n      mockMedia.currentTime = 0;\n      isStalling = true;\n      tickMediaClock();\n      expect(gapController.moved).to.equal(false);\n      expect(gapController.stalled).to.equal(1234);\n      expect(mockMedia.currentTime).to.equal(0);\n      tickMediaClock();\n      expect(gapController.moved).to.equal(true);\n      expect(gapController.stalled).to.equal(null);\n      expect(mockMedia.currentTime).to.equal(0.1 + SKIP_BUFFER_RANGE_START);\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"should skip any initial gap when not having played yet on second poll","suites":["GapController","media clock polling"],"updatePoint":{"line":290,"column":77,"index":11316},"line":290,"code":"    it('should skip any initial gap when not having played yet on second poll', function () {\n      mockMedia.currentTime = 0;\n      mockTimeRangesData = [[0.9, 10]];\n      gapController.poll(0);\n      gapController.poll(0);\n      expect(mockMedia.currentTime).to.equal(0.9 + SKIP_BUFFER_RANGE_START);\n    });","file":"unit/controller/gap-controller.js","skipped":false,"dir":"tests"},{"name":"returns 0 when unknown / detached / prior to timeupdate","suites":["LatencyController","latency"],"updatePoint":{"line":69,"column":63,"index":2204},"line":69,"code":"    it('returns 0 when unknown / detached / prior to timeupdate', function () {\n      expect(latencyController.latency).to.equal(0);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"is the distance between currentTime and the live edge plus playlist age","suites":["LatencyController","latency"],"updatePoint":{"line":72,"column":79,"index":2361},"line":72,"code":"    it('is the distance between currentTime and the live edge plus playlist age', function () {\n      levelDetails.edge = 25;\n      expect(latencyController.latency).to.equal(25);\n      media.currentTime = 15;\n      expect(latencyController.latency).to.equal(10);\n      media.currentTime = 20;\n      expect(latencyController.latency).to.equal(5);\n      levelDetails.age = 1;\n      expect(latencyController.latency).to.equal(6);\n      levelDetails.edge = 30;\n      levelDetails.age = 0;\n      expect(latencyController.latency).to.equal(10);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns liveMaxLatencyDuration when set","suites":["LatencyController","maxLatency"],"updatePoint":{"line":87,"column":47,"index":2922},"line":87,"code":"    it('returns liveMaxLatencyDuration when set', function () {\n      latencyController['config'].liveMaxLatencyDuration = 30;\n      expect(latencyController.maxLatency).to.equal(30);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns liveMaxLatencyDurationCount * targetduration after level update","suites":["LatencyController","maxLatency"],"updatePoint":{"line":91,"column":79,"index":3146},"line":91,"code":"    it('returns liveMaxLatencyDurationCount * targetduration after level update', function () {\n      latencyController['config'].liveMaxLatencyDurationCount = 3;\n      expect(latencyController.maxLatency).to.equal(0);\n      levelDetails.age = 0;\n      expect(latencyController.maxLatency).to.equal(15);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns null before level update","suites":["LatencyController","targetLatency"],"updatePoint":{"line":99,"column":40,"index":3467},"line":99,"code":"    it('returns null before level update', function () {\n      expect(latencyController.targetLatency).to.equal(null);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns liveSyncDuration if set after level update","suites":["LatencyController","targetLatency"],"updatePoint":{"line":102,"column":58,"index":3612},"line":102,"code":"    it('returns liveSyncDuration if set after level update', function () {\n      latencyController['config'].liveSyncDuration = 12;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(12);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns targetduration * liveSyncDurationCount if set after level update","suites":["LatencyController","targetLatency"],"updatePoint":{"line":107,"column":80,"index":3862},"line":107,"code":"    it('returns targetduration * liveSyncDurationCount if set after level update', function () {\n      latencyController['config'].liveSyncDurationCount = 2;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(10);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns holdBack when set in playlist after level update","suites":["LatencyController","targetLatency"],"updatePoint":{"line":112,"column":64,"index":4100},"line":112,"code":"    it('returns holdBack when set in playlist after level update', function () {\n      levelDetails.holdBack = 8;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(8);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns partHoldBack in lowLatencyMode when set in playlist after level update","suites":["LatencyController","targetLatency"],"updatePoint":{"line":117,"column":86,"index":4331},"line":117,"code":"    it('returns partHoldBack in lowLatencyMode when set in playlist after level update', function () {\n      levelDetails.holdBack = 8;\n      levelDetails.partHoldBack = 3;\n      levelDetails.age = 0;\n      latencyController['config'].lowLatencyMode = false;\n      expect(latencyController.targetLatency).to.equal(8);\n      latencyController['config'].lowLatencyMode = true;\n      expect(latencyController.targetLatency).to.equal(3);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"liveSyncDuration overrides holdBack when set by user","suites":["LatencyController","targetLatency"],"updatePoint":{"line":126,"column":60,"index":4747},"line":126,"code":"    it('liveSyncDuration overrides holdBack when set by user', function () {\n      hls.userConfig.liveSyncDuration = 12;\n      latencyController['config'].liveSyncDuration = 12;\n      levelDetails.holdBack = 8;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(12);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"liveSyncDurationCount overrides holdBack when set by user","suites":["LatencyController","targetLatency"],"updatePoint":{"line":133,"column":65,"index":5059},"line":133,"code":"    it('liveSyncDurationCount overrides holdBack when set by user', function () {\n      hls.userConfig.liveSyncDurationCount = 2;\n      latencyController['config'].liveSyncDurationCount = 2;\n      levelDetails.holdBack = 8;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(10);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"adds a second of latency for each stall up to targetduration","suites":["LatencyController","targetLatency"],"updatePoint":{"line":140,"column":68,"index":5382},"line":140,"code":"    it('adds a second of latency for each stall up to targetduration', function () {\n      latencyController['config'].lowLatencyMode = true;\n      levelDetails.targetduration = 3.5;\n      levelDetails.partHoldBack = 3;\n      levelDetails.age = 0;\n      expect(latencyController.targetLatency).to.equal(3);\n      latencyController['stallCount'] = 1;\n      expect(latencyController.targetLatency).to.equal(4);\n      latencyController['stallCount'] += 1;\n      expect(latencyController.targetLatency).to.equal(5);\n      latencyController['stallCount'] += 1;\n      expect(latencyController.targetLatency).to.equal(6);\n      latencyController['stallCount'] += 1;\n      expect(latencyController.targetLatency).to.equal(6.5);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns null before level update","suites":["LatencyController","liveSyncPosition"],"updatePoint":{"line":157,"column":40,"index":6133},"line":157,"code":"    it('returns null before level update', function () {\n      expect(latencyController.liveSyncPosition).to.equal(null);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns target currentTime based on edge and targetLatency","suites":["LatencyController","liveSyncPosition"],"updatePoint":{"line":160,"column":66,"index":6289},"line":160,"code":"    it('returns target currentTime based on edge and targetLatency', function () {\n      latencyController['config'].liveSyncDuration = 12;\n      levelDetails.edge = 60;\n      expect(latencyController.liveSyncPosition).to.equal(48);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"accounts for level update age up to 3 target durations","suites":["LatencyController","liveSyncPosition"],"updatePoint":{"line":165,"column":62,"index":6526},"line":165,"code":"    it('accounts for level update age up to 3 target durations', function () {\n      levelDetails.targetduration = 5;\n      levelDetails.holdBack = 15;\n      levelDetails.edge = 60;\n      expect(latencyController.liveSyncPosition).to.equal(45);\n      levelDetails.age = 5;\n      expect(latencyController.liveSyncPosition).to.equal(50);\n      levelDetails.age = 10;\n      expect(latencyController.liveSyncPosition).to.equal(55);\n      levelDetails.age = 20;\n      expect(latencyController.liveSyncPosition).to.equal(55);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"accounts for level update age up to 3 part targets in low latency mode","suites":["LatencyController","liveSyncPosition"],"updatePoint":{"line":177,"column":78,"index":7070},"line":177,"code":"    it('accounts for level update age up to 3 part targets in low latency mode', function () {\n      latencyController['config'].lowLatencyMode = true;\n      levelDetails.partTarget = 1;\n      levelDetails.partHoldBack = 3;\n      levelDetails.edge = 60;\n      expect(latencyController.liveSyncPosition).to.equal(57);\n      levelDetails.age = 1;\n      expect(latencyController.liveSyncPosition).to.equal(58);\n      levelDetails.age = 2;\n      expect(latencyController.liveSyncPosition).to.equal(59);\n      levelDetails.age = 5;\n      expect(latencyController.liveSyncPosition).to.equal(59);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns 0 before level update","suites":["LatencyController","edgeStalled"],"updatePoint":{"line":192,"column":37,"index":7673},"line":192,"code":"    it('returns 0 before level update', function () {\n      expect(latencyController.edgeStalled).to.equal(0);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns the age seconds past 3 target durations","suites":["LatencyController","edgeStalled"],"updatePoint":{"line":195,"column":55,"index":7810},"line":195,"code":"    it('returns the age seconds past 3 target durations', function () {\n      levelDetails.targetduration = 5;\n      levelDetails.holdBack = 15;\n      levelDetails.age = 0;\n      expect(latencyController.edgeStalled).to.equal(0);\n      levelDetails.age = 1;\n      expect(latencyController.edgeStalled).to.equal(0);\n      levelDetails.age = 20;\n      expect(latencyController.edgeStalled).to.equal(5);\n      levelDetails.age = 25;\n      expect(latencyController.edgeStalled).to.equal(10);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"returns the age seconds past 3 part targets in low latency mode","suites":["LatencyController","edgeStalled"],"updatePoint":{"line":207,"column":71,"index":8322},"line":207,"code":"    it('returns the age seconds past 3 part targets in low latency mode', function () {\n      latencyController['config'].lowLatencyMode = true;\n      levelDetails.partTarget = 1;\n      levelDetails.partHoldBack = 3;\n      levelDetails.age = 0;\n      expect(latencyController.edgeStalled).to.equal(0);\n      levelDetails.age = 1;\n      expect(latencyController.edgeStalled).to.equal(0);\n      levelDetails.age = 5;\n      expect(latencyController.edgeStalled).to.equal(2);\n      levelDetails.age = 6;\n      expect(latencyController.edgeStalled).to.equal(3);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"increases playbackRate when latency is greater than target latency on timeupdate","suites":["LatencyController","when maxLiveSyncPlaybackRate is set"],"updatePoint":{"line":225,"column":88,"index":9074},"line":225,"code":"    it('increases playbackRate when latency is greater than target latency on timeupdate', function () {\n      levelDetails.edge = 12;\n      mockTimeRanges = [[0, 12]];\n      levelDetails.holdBack = 6;\n      media.currentTime = 6;\n      expect(media.playbackRate).to.equal(1);\n      media.currentTime = 5;\n      expect(media.playbackRate).to.be.within(1.3, 1.4);\n      media.currentTime = 4;\n      expect(media.playbackRate).to.be.within(1.6, 1.7);\n      media.currentTime = 1;\n      expect(media.playbackRate).to.be.within(1.9, 2);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"resets latency estimates when a new manifest is loading","suites":["LatencyController","when maxLiveSyncPlaybackRate is set"],"updatePoint":{"line":238,"column":63,"index":9590},"line":238,"code":"    it('resets latency estimates when a new manifest is loading', function () {\n      expect(latencyController.latency).to.equal(0);\n      levelDetails.edge = 25;\n      expect(latencyController.latency).to.equal(25);\n      latencyController['onManifestLoading']();\n      expect(latencyController.latency).to.equal(0);\n    });","file":"unit/controller/latency-controller.ts","skipped":false,"dir":"tests"},{"name":"should update tracks list","suites":["SubtitleStreamController","onSubtitleTracksUpdate"],"updatePoint":{"line":46,"column":33,"index":1359},"line":46,"code":"    it('should update tracks list', function () {\n      expect(subtitleStreamController.levels).to.have.lengthOf(2);\n      expect(subtitleStreamController.levels[0]).to.deep.include(tracksMock[0]);\n      expect(subtitleStreamController.levels[1]).to.deep.include(tracksMock[1]);\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should call setInterval if details available","suites":["SubtitleStreamController","onSubtitleTrackSwitch"],"updatePoint":{"line":61,"column":52,"index":2002},"line":61,"code":"    it('should call setInterval if details available', function () {\n      expect(subtitleStreamController.setInterval).to.have.been.calledOnce;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should call clearInterval if no tracks present","suites":["SubtitleStreamController","onSubtitleTrackSwitch"],"updatePoint":{"line":64,"column":54,"index":2157},"line":64,"code":"    it('should call clearInterval if no tracks present', function () {\n      subtitleStreamController.levels = [];\n      hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: 0\n      });\n      expect(subtitleStreamController.clearInterval).to.have.been.calledOnce;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should call clearInterval if new track id === -1","suites":["SubtitleStreamController","onSubtitleTrackSwitch"],"updatePoint":{"line":71,"column":56,"index":2434},"line":71,"code":"    it('should call clearInterval if new track id === -1', function () {\n      hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: -1\n      });\n      expect(subtitleStreamController.clearInterval).to.have.been.calledOnce;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should handle the event if the data matches the current track","suites":["SubtitleStreamController","onSubtitleTrackLoaded"],"updatePoint":{"line":85,"column":69,"index":2967},"line":85,"code":"    it('should handle the event if the data matches the current track', function () {\n      const details = {\n        foo: 'bar'\n      };\n      subtitleStreamController.currentTrackId = 1;\n      hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n        id: 1,\n        details: details\n      });\n      expect(subtitleStreamController.levels[1].details).to.equal(details);\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should ignore the event if the data does not match the current track","suites":["SubtitleStreamController","onSubtitleTrackLoaded"],"updatePoint":{"line":96,"column":76,"index":3347},"line":96,"code":"    it('should ignore the event if the data does not match the current track', function () {\n      const details = {\n        foo: 'bar'\n      };\n      subtitleStreamController.currentTrackId = 0;\n      hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n        id: 1,\n        details\n      });\n      expect(subtitleStreamController.levels[0].details).to.not.equal(details);\n      expect(subtitleStreamController.setInterval).to.not.have.been.called;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should ignore the event if there are no tracks, or the id is not within the tracks array","suites":["SubtitleStreamController","onSubtitleTrackLoaded"],"updatePoint":{"line":108,"column":96,"index":3818},"line":108,"code":"    it('should ignore the event if there are no tracks, or the id is not within the tracks array', function () {\n      subtitleStreamController.levels = [];\n      subtitleStreamController.trackId = 0;\n      const details = {\n        foo: 'bar'\n      };\n      hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n        id: 0,\n        details\n      });\n      expect(subtitleStreamController.levels[0]).to.not.exist;\n      expect(subtitleStreamController.setInterval).to.not.have.been.called;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"nulls fragPrevious when seeking away from fragCurrent","suites":["SubtitleStreamController","onMediaSeeking"],"updatePoint":{"line":123,"column":61,"index":4323},"line":123,"code":"    it('nulls fragPrevious when seeking away from fragCurrent', function () {\n      subtitleStreamController.fragCurrent = {\n        start: 1000,\n        duration: 10,\n        loader: {\n          abort: () => {\n            this.state.aborted = true;\n          },\n          stats: {\n            aborted: false\n          }\n        }\n      };\n      subtitleStreamController.fragPrevious = {};\n      subtitleStreamController.onMediaSeeking();\n      expect(subtitleStreamController.fragPrevious).to.not.exist;\n    });","file":"unit/controller/subtitle-stream-controller.js","skipped":false,"dir":"tests"},{"name":"should set subtitleTrack to -1 if disabled","suites":["SubtitleTrackController","onTextTrackChanged"],"updatePoint":{"line":59,"column":50,"index":1868},"line":59,"code":"    it('should set subtitleTrack to -1 if disabled', function () {\n      expect(subtitleTrackController.subtitleTrack).to.equal(-1);\n      videoElement.textTracks[0].mode = 'disabled';\n      subtitleTrackController.onTextTracksChanged();\n      expect(subtitleTrackController.subtitleTrack).to.equal(-1);\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should set subtitleTrack to 0 if hidden","suites":["SubtitleTrackController","onTextTrackChanged"],"updatePoint":{"line":65,"column":47,"index":2177},"line":65,"code":"    it('should set subtitleTrack to 0 if hidden', function () {\n      expect(subtitleTrackController.subtitleTrack).to.equal(-1);\n      videoElement.textTracks[0].mode = 'hidden';\n      subtitleTrackController.onTextTracksChanged();\n      expect(subtitleTrackController.subtitleTrack).to.equal(0);\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should set subtitleTrack to 0 if showing","suites":["SubtitleTrackController","onTextTrackChanged"],"updatePoint":{"line":71,"column":48,"index":2484},"line":71,"code":"    it('should set subtitleTrack to 0 if showing', function () {\n      expect(subtitleTrackController.subtitleTrack).to.equal(-1);\n      videoElement.textTracks[0].mode = 'showing';\n      subtitleTrackController.onTextTracksChanged();\n      expect(subtitleTrackController.subtitleTrack).to.equal(0);\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should set active text track mode to showing","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":79,"column":52,"index":2848},"line":79,"code":"    it('should set active text track mode to showing', function () {\n      videoElement.textTracks[0].mode = 'disabled';\n      subtitleTrackController.subtitleDisplay = true;\n      subtitleTrackController.subtitleTrack = 0;\n      expect(videoElement.textTracks[0].mode).to.equal('showing');\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should set active text track mode to hidden","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":85,"column":51,"index":3146},"line":85,"code":"    it('should set active text track mode to hidden', function () {\n      videoElement.textTracks[0].mode = 'disabled';\n      subtitleTrackController.subtitleDisplay = false;\n      subtitleTrackController.subtitleTrack = 0;\n      expect(videoElement.textTracks[0].mode).to.equal('hidden');\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should disable previous track","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":91,"column":37,"index":3430},"line":91,"code":"    it('should disable previous track', function () {\n      // Change active track without triggering setSubtitleTrackInternal\n      subtitleTrackController.trackId = 0;\n      // Change active track and trigger setSubtitleTrackInternal\n      subtitleTrackController.subtitleTrack = 1;\n      expect(videoElement.textTracks[0].mode).to.equal('disabled');\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should trigger SUBTITLE_TRACK_SWITCH","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":98,"column":44,"index":3798},"line":98,"code":"    it('should trigger SUBTITLE_TRACK_SWITCH', function () {\n      const triggerSpy = sandbox.spy(subtitleTrackController.hls, 'trigger');\n      subtitleTrackController.canLoad = true;\n      subtitleTrackController.trackId = 0;\n      subtitleTrackController.subtitleTrack = 1;\n      expect(triggerSpy).to.have.been.calledTwice;\n      expect(triggerSpy.firstCall).to.have.been.calledWith('hlsSubtitleTrackSwitch', {\n        id: 1,\n        groupId: 'default-text-group',\n        name: 'English',\n        type: 'SUBTITLES',\n        url: 'bar'\n      });\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should trigger SUBTITLE_TRACK_LOADING if the track has no details","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":112,"column":73,"index":4385},"line":112,"code":"    it('should trigger SUBTITLE_TRACK_LOADING if the track has no details', function () {\n      const triggerSpy = sandbox.spy(subtitleTrackController.hls, 'trigger');\n      subtitleTrackController.canLoad = true;\n      subtitleTrackController.trackId = 0;\n      subtitleTrackController.subtitleTrack = 1;\n      expect(triggerSpy).to.have.been.calledTwice;\n      expect(triggerSpy.secondCall).to.have.been.calledWith('hlsSubtitleTrackLoading', {\n        url: 'bar',\n        id: 1,\n        groupId: 'default-text-group',\n        deliveryDirectives: null\n      });\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should not trigger SUBTITLE_TRACK_LOADING if the track has details and is not live","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":125,"column":90,"index":4973},"line":125,"code":"    it('should not trigger SUBTITLE_TRACK_LOADING if the track has details and is not live', function () {\n      const triggerSpy = sandbox.spy(subtitleTrackController.hls, 'trigger');\n      subtitleTrackController.trackId = 1;\n      subtitleTrackController.subtitleTrack = 0;\n      expect(triggerSpy).to.have.been.calledOnce;\n      expect(triggerSpy.firstCall).to.have.been.calledWith('hlsSubtitleTrackSwitch', {\n        id: 0,\n        groupId: 'default-text-group',\n        name: 'English',\n        type: 'SUBTITLES',\n        url: 'baz'\n      });\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should trigger SUBTITLE_TRACK_SWITCH if passed -1","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":138,"column":57,"index":5497},"line":138,"code":"    it('should trigger SUBTITLE_TRACK_SWITCH if passed -1', function () {\n      const triggerSpy = sandbox.spy(subtitleTrackController.hls, 'trigger');\n      subtitleTrackController.trackId = 0;\n      subtitleTrackController.subtitleTrack = -1;\n      expect(triggerSpy.firstCall).to.have.been.calledWith('hlsSubtitleTrackSwitch', {\n        id: -1\n      });\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should trigger SUBTITLE_TRACK_LOADING if the track is live, even if it has details","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":146,"column":90,"index":5895},"line":146,"code":"    it('should trigger SUBTITLE_TRACK_LOADING if the track is live, even if it has details', function () {\n      const triggerSpy = sandbox.spy(subtitleTrackController.hls, 'trigger');\n      subtitleTrackController.canLoad = true;\n      subtitleTrackController.trackId = 0;\n      subtitleTrackController.subtitleTrack = 2;\n      expect(triggerSpy).to.have.been.calledTwice;\n      expect(triggerSpy.secondCall).to.have.been.calledWith('hlsSubtitleTrackLoading', {\n        url: 'foo',\n        id: 2,\n        groupId: 'default-text-group',\n        deliveryDirectives: null\n      });\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should do nothing if called with out of bound indices","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":159,"column":61,"index":6454},"line":159,"code":"    it('should do nothing if called with out of bound indices', function () {\n      const clearReloadSpy = sandbox.spy(subtitleTrackController, 'clearTimer');\n      subtitleTrackController.subtitleTrack = 5;\n      subtitleTrackController.subtitleTrack = -2;\n      expect(clearReloadSpy).to.have.not.been.called;\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should do nothing if called with a non-number","suites":["SubtitleTrackController","set subtitleTrack"],"updatePoint":{"line":165,"column":53,"index":6766},"line":165,"code":"    it('should do nothing if called with a non-number', function () {\n      subtitleTrackController.subtitleTrack = undefined;\n      subtitleTrackController.subtitleTrack = null;\n    });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should not throw an exception if trackId is out of the mediaElement text track bounds","suites":["SubtitleTrackController","set subtitleTrack","toggleTrackModes"],"updatePoint":{"line":171,"column":95,"index":7146},"line":171,"code":"      it('should not throw an exception if trackId is out of the mediaElement text track bounds', function () {\n        subtitleTrackController.trackId = 3;\n        subtitleTrackController.toggleTrackModes(1);\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should disable all textTracks if called with -1","suites":["SubtitleTrackController","set subtitleTrack","toggleTrackModes"],"updatePoint":{"line":175,"column":57,"index":7328},"line":175,"code":"      it('should disable all textTracks if called with -1', function () {\n        [].slice.call(videoElement.textTracks).forEach(t => {\n          t.mode = 'showing';\n        });\n        subtitleTrackController.toggleTrackModes(-1);\n        [].slice.call(videoElement.textTracks).forEach(t => {\n          expect(t.mode).to.equal('disabled');\n        });\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"should not throw an exception if the mediaElement does not exist","suites":["SubtitleTrackController","set subtitleTrack","toggleTrackModes"],"updatePoint":{"line":184,"column":74,"index":7708},"line":184,"code":"      it('should not throw an exception if the mediaElement does not exist', function () {\n        subtitleTrackController.media = null;\n        subtitleTrackController.toggleTrackModes(1);\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"exits early if the loaded track does not match the requested track","suites":["SubtitleTrackController","set subtitleTrack","onSubtitleTrackLoaded"],"updatePoint":{"line":190,"column":76,"index":7970},"line":190,"code":"      it('exits early if the loaded track does not match the requested track', function () {\n        const playlistLoadedSpy = sandbox.spy(subtitleTrackController, 'playlistLoaded');\n        subtitleTrackController.canLoad = true;\n        subtitleTrackController.trackId = 1;\n        const mockLoadedEvent = {\n          id: 999,\n          details: {\n            foo: 'bar'\n          },\n          stats: new LoadStats()\n        };\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, mockLoadedEvent);\n        expect(subtitleTrackController.timer).to.equal(-1);\n        expect(playlistLoadedSpy).to.have.not.been.called;\n        mockLoadedEvent.id = 0;\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, mockLoadedEvent);\n        expect(subtitleTrackController.timer).to.equal(-1);\n        expect(playlistLoadedSpy).to.have.not.been.called;\n        mockLoadedEvent.id = 1;\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, mockLoadedEvent);\n        expect(subtitleTrackController.timer).to.equal(-1);\n        expect(playlistLoadedSpy).to.have.been.calledOnce;\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"does not set the reload timer if the canLoad flag is set to false","suites":["SubtitleTrackController","set subtitleTrack","onSubtitleTrackLoaded"],"updatePoint":{"line":213,"column":75,"index":9136},"line":213,"code":"      it('does not set the reload timer if the canLoad flag is set to false', function () {\n        const details = new LevelDetails('');\n        subtitleTrackController.canLoad = false;\n        subtitleTrackController.trackId = 1;\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, {\n          id: 1,\n          details,\n          stats: new LoadStats()\n        });\n        expect(subtitleTrackController.timer).to.equal(-1);\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"sets the live reload timer if the level is live","suites":["SubtitleTrackController","set subtitleTrack","onSubtitleTrackLoaded"],"updatePoint":{"line":224,"column":57,"index":9587},"line":224,"code":"      it('sets the live reload timer if the level is live', function () {\n        const details = new LevelDetails('');\n        subtitleTrackController.canLoad = true;\n        subtitleTrackController.trackId = 1;\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, {\n          id: 1,\n          details,\n          stats: new LoadStats()\n        });\n        expect(subtitleTrackController.timer).to.exist;\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"stops the live reload timer if the level is not live","suites":["SubtitleTrackController","set subtitleTrack","onSubtitleTrackLoaded"],"updatePoint":{"line":235,"column":62,"index":10038},"line":235,"code":"      it('stops the live reload timer if the level is not live', function () {\n        const details = new LevelDetails('');\n        details.live = false;\n        subtitleTrackController.trackId = 1;\n        subtitleTrackController.timer = self.setTimeout(() => {}, 0);\n        subtitleTrackController.onSubtitleTrackLoaded(Events.SUBTITLE_TRACK_LOADED, {\n          id: 1,\n          details,\n          stats: new LoadStats()\n        });\n        expect(subtitleTrackController.timer).to.equal(-1);\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"stops loading","suites":["SubtitleTrackController","set subtitleTrack","stopLoad"],"updatePoint":{"line":249,"column":23,"index":10553},"line":249,"code":"      it('stops loading', function () {\n        const clearReloadSpy = sandbox.spy(subtitleTrackController, 'clearTimer');\n        subtitleTrackController.stopLoad();\n        expect(subtitleTrackController.canLoad).to.be.false;\n        expect(clearReloadSpy).to.have.been.calledOnce;\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"starts loading","suites":["SubtitleTrackController","set subtitleTrack","startLoad"],"updatePoint":{"line":257,"column":24,"index":10896},"line":257,"code":"      it('starts loading', function () {\n        const loadCurrentTrackSpy = sandbox.spy(subtitleTrackController, 'loadPlaylist');\n        subtitleTrackController.startLoad();\n        expect(subtitleTrackController.canLoad).to.be.true;\n        expect(loadCurrentTrackSpy).to.have.been.calledOnce;\n      });","file":"unit/controller/subtitle-track-controller.js","skipped":false,"dir":"tests"},{"name":"has the createNonNativeTrack method","suites":["Non-Native TimelineController functions"],"updatePoint":{"line":14,"column":41,"index":552},"line":14,"code":"  it('has the createNonNativeTrack method', function () {\n    expect(timelineController.createNonNativeTrack).to.be.a('function');\n  });","file":"unit/controller/timeline-controller-nonnative.js","skipped":false,"dir":"tests"},{"name":"has the createNativeTrack method","suites":["Non-Native TimelineController functions"],"updatePoint":{"line":17,"column":38,"index":686},"line":17,"code":"  it('has the createNativeTrack method', function () {\n    expect(timelineController.createNativeTrack).to.be.a('function');\n  });","file":"unit/controller/timeline-controller-nonnative.js","skipped":false,"dir":"tests"},{"name":"calls createNonNativeTrack when renderTextTracksNatively is false","suites":["Non-Native TimelineController functions"],"updatePoint":{"line":20,"column":71,"index":850},"line":20,"code":"  it('calls createNonNativeTrack when renderTextTracksNatively is false', function () {\n    const nonNativeSpy = sinon.spy();\n    timelineController.createNonNativeTrack = nonNativeSpy;\n    timelineController.createCaptionsTrack('foo');\n    expect(nonNativeSpy).to.have.been.calledOnce;\n  });","file":"unit/controller/timeline-controller-nonnative.js","skipped":false,"dir":"tests"},{"name":"fires the NON_NATIVE_TEXT_TRACKS_FOUND event","suites":["Non-Native TimelineController functions"],"updatePoint":{"line":26,"column":50,"index":1122},"line":26,"code":"  it('fires the NON_NATIVE_TEXT_TRACKS_FOUND event', function (done) {\n    hls.on(Hls.Events.NON_NATIVE_TEXT_TRACKS_FOUND, (event, data) => {\n      const track = data.tracks[0];\n      expect(track.kind).to.equal('captions');\n      expect(track.default).to.equal(false);\n      expect(track.label).to.equal(timelineController.captionsProperties.textTrack1.label);\n      expect(timelineController.nonNativeCaptionsTracks.textTrack1).to.equal(track);\n      done();\n    });\n    timelineController.createNonNativeTrack('textTrack1');\n  });","file":"unit/controller/timeline-controller-nonnative.js","skipped":false,"dir":"tests"},{"name":"does not create a non native track if the track does not have any defined properties","suites":["Non-Native TimelineController functions"],"updatePoint":{"line":37,"column":90,"index":1696},"line":37,"code":"  it('does not create a non native track if the track does not have any defined properties', function () {\n    const triggerSpy = sinon.spy(hls, 'trigger');\n    timelineController.createNonNativeTrack('foo');\n    expect(triggerSpy).to.have.not.been.called;\n  });","file":"unit/controller/timeline-controller-nonnative.js","skipped":false,"dir":"tests"},{"name":"should reuse text track when track order is same between manifests","suites":["TimelineController","reuse text track"],"updatePoint":{"line":15,"column":74,"index":612},"line":15,"code":"    it('should reuse text track when track order is same between manifests', function () {\n      hls.subtitleTrackController = {\n        subtitleDisplay: false\n      };\n      timelineController.onSubtitleTracksUpdated(Events.SUBTITLE_TRACKS_UPDATED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en'\n        }, {\n          id: 1,\n          name: 'ru'\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order as in manifest\n      expect(timelineController.textTracks[0].label).to.equal('en');\n      expect(timelineController.textTracks[1].label).to.equal('ru');\n      expect(timelineController.textTracks.length).to.equal(2);\n      // text tracks of the media contain the newly added text tracks\n      expect(timelineController.media.textTracks[0].label).to.equal('en');\n      expect(timelineController.media.textTracks[1].label).to.equal('ru');\n      expect(timelineController.media.textTracks.length).to.equal(2);\n      timelineController.onSubtitleTracksUpdated(Events.SUBTITLE_TRACKS_UPDATED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en'\n        }, {\n          id: 1,\n          name: 'ru'\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order\n      expect(timelineController.textTracks[0].label).to.equal('en');\n      expect(timelineController.textTracks[1].label).to.equal('ru');\n      expect(timelineController.textTracks.length).to.equal(2);\n      // text tracks of the media contain the previously added text tracks, in same order as the manifest order\n      expect(timelineController.media.textTracks[0].label).to.equal('en');\n      expect(timelineController.media.textTracks[1].label).to.equal('ru');\n      expect(timelineController.media.textTracks.length).to.equal(2);\n    });","file":"unit/controller/timeline-controller.js","skipped":false,"dir":"tests"},{"name":"should reuse text track when track order is not same between manifests","suites":["TimelineController","reuse text track"],"updatePoint":{"line":56,"column":78,"index":2442},"line":56,"code":"    it('should reuse text track when track order is not same between manifests', function () {\n      hls.subtitleTrackController = {\n        subtitleDisplay: false\n      };\n      timelineController.onSubtitleTracksUpdated(Events.MANIFEST_LOADED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en'\n        }, {\n          id: 1,\n          name: 'ru'\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order as in manifest\n      expect(timelineController.textTracks[0].label).to.equal('en');\n      expect(timelineController.textTracks[1].label).to.equal('ru');\n      expect(timelineController.textTracks.length).to.equal(2);\n      // text tracks of the media contain the newly added text tracks\n      expect(timelineController.media.textTracks[0].label).to.equal('en');\n      expect(timelineController.media.textTracks[1].label).to.equal('ru');\n      expect(timelineController.media.textTracks.length).to.equal(2);\n      timelineController.onSubtitleTracksUpdated(Events.MANIFEST_LOADED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'ru'\n        }, {\n          id: 1,\n          name: 'en'\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order\n      expect(timelineController.textTracks[0].label).to.equal('ru');\n      expect(timelineController.textTracks[1].label).to.equal('en');\n      expect(timelineController.textTracks.length).to.equal(2);\n      // text tracks of the media contain the previously added text tracks).to.equal(in opposite order to the manifest order\n      expect(timelineController.media.textTracks[0].label).to.equal('en');\n      expect(timelineController.media.textTracks[1].label).to.equal('ru');\n      expect(timelineController.media.textTracks.length).to.equal(2);\n    });","file":"unit/controller/timeline-controller.js","skipped":false,"dir":"tests"},{"name":"should be kind captions when there is both transcribes-spoken-dialog and describes-music-and-sound","suites":["TimelineController","text track kind"],"updatePoint":{"line":99,"column":106,"index":4347},"line":99,"code":"    it('should be kind captions when there is both transcribes-spoken-dialog and describes-music-and-sound', function () {\n      hls.subtitleTrackController = {\n        subtitleDisplay: false\n      };\n      timelineController.onSubtitleTracksUpdated(Events.MANIFEST_LOADED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en',\n          attrs: {\n            CHARACTERISTICS: 'public.accessibility.transcribes-spoken-dialog,public.accessibility.describes-music-and-sound'\n          }\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order as in manifest\n      expect(timelineController.textTracks[0].kind).to.equal('captions');\n      // text tracks of the media contain the newly added text tracks\n      expect(timelineController.media.textTracks[0].kind).to.equal('captions');\n    });","file":"unit/controller/timeline-controller.js","skipped":false,"dir":"tests"},{"name":"should be kind subtitles when there is no describes-music-and-sound","suites":["TimelineController","text track kind"],"updatePoint":{"line":118,"column":75,"index":5166},"line":118,"code":"    it('should be kind subtitles when there is no describes-music-and-sound', function () {\n      hls.subtitleTrackController = {\n        subtitleDisplay: false\n      };\n      timelineController.onSubtitleTracksUpdated(Events.MANIFEST_LOADED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en',\n          attrs: {\n            CHARACTERISTICS: 'public.accessibility.transcribes-spoken-dialog'\n          }\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order as in manifest\n      expect(timelineController.textTracks[0].kind).to.equal('subtitles');\n      // text tracks of the media contain the newly added text tracks\n      expect(timelineController.media.textTracks[0].kind).to.equal('subtitles');\n    });","file":"unit/controller/timeline-controller.js","skipped":false,"dir":"tests"},{"name":"should be kind subtitles when there is no CHARACTERISTICS","suites":["TimelineController","text track kind"],"updatePoint":{"line":137,"column":65,"index":5930},"line":137,"code":"    it('should be kind subtitles when there is no CHARACTERISTICS', function () {\n      hls.subtitleTrackController = {\n        subtitleDisplay: false\n      };\n      timelineController.onSubtitleTracksUpdated(Events.MANIFEST_LOADED, {\n        subtitleTracks: [{\n          id: 0,\n          name: 'en'\n        }]\n      });\n\n      // text tracks model contain only newly added manifest tracks, in same order as in manifest\n      expect(timelineController.textTracks[0].kind).to.equal('subtitles');\n      // text tracks of the media contain the newly added text tracks\n      expect(timelineController.media.textTracks[0].kind).to.equal('subtitles');\n    });","file":"unit/controller/timeline-controller.js","skipped":false,"dir":"tests"},{"name":"should parse fractional seconds correctly regardless of length","suites":["VTTParser","parseTimeStamp"],"updatePoint":{"line":11,"column":70,"index":487},"line":11,"code":"    it('should parse fractional seconds correctly regardless of length', function () {\n      assertTimeStampValue('00:00:01.5', 1.5);\n      assertTimeStampValue('00:00:01.05', 1.05);\n      assertTimeStampValue('00:00:01.005', 1.005);\n      assertTimeStampValue('00:00:01.', 1);\n    });","file":"unit/controller/vttparser.ts","skipped":false,"dir":"tests"},{"name":"should parse h:m:s","suites":["VTTParser","parseTimeStamp"],"updatePoint":{"line":17,"column":26,"index":729},"line":17,"code":"    it('should parse h:m:s', function () {\n      assertTimeStampValue('01:01:01', 3661);\n    });","file":"unit/controller/vttparser.ts","skipped":false,"dir":"tests"},{"name":"should parse h>59:m and h>59:m.ms","suites":["VTTParser","parseTimeStamp"],"updatePoint":{"line":20,"column":41,"index":841},"line":20,"code":"    it('should parse h>59:m and h>59:m.ms', function () {\n      assertTimeStampValue('60:01', 216060);\n      assertTimeStampValue('60:01.55', 216060.55);\n    });","file":"unit/controller/vttparser.ts","skipped":false,"dir":"tests"},{"name":"should parse m:s and m:s.ms","suites":["VTTParser","parseTimeStamp"],"updatePoint":{"line":24,"column":35,"index":997},"line":24,"code":"    it('should parse m:s and m:s.ms', function () {\n      assertTimeStampValue('01:01', 61);\n      assertTimeStampValue('01:01.09', 61.09);\n    });","file":"unit/controller/vttparser.ts","skipped":false,"dir":"tests"},{"name":"is a no-op when the last byte is 0","suites":["AESDecryptor","removePadding()"],"updatePoint":{"line":5,"column":42,"index":244},"line":5,"code":"    it('is a no-op when the last byte is 0', function () {\n      const arr = new Uint8Array([1, 2, 3, 0]);\n      expect(removePadding(arr)).to.equal(arr);\n    });","file":"unit/crypt/aes-decryptor.js","skipped":false,"dir":"tests"},{"name":"removes 1 byte when the last byte is 1","suites":["AESDecryptor","removePadding()"],"updatePoint":{"line":9,"column":46,"index":411},"line":9,"code":"    it('removes 1 byte when the last byte is 1', function () {\n      const arr = new Uint8Array([1, 2, 3, 1]);\n      expect(Array.from(new Uint8Array(removePadding(arr)))).to.deep.equal([1, 2, 3]);\n    });","file":"unit/crypt/aes-decryptor.js","skipped":false,"dir":"tests"},{"name":"removes 3 bytes when the last byte is 3","suites":["AESDecryptor","removePadding()"],"updatePoint":{"line":13,"column":47,"index":618},"line":13,"code":"    it('removes 3 bytes when the last byte is 3', function () {\n      const arr = new Uint8Array([1, 2, 3, 3]);\n      expect(Array.from(new Uint8Array(removePadding(arr)))).to.deep.equal([1]);\n    });","file":"unit/crypt/aes-decryptor.js","skipped":false,"dir":"tests"},{"name":"removes 4 bytes when the last byte is 4","suites":["AESDecryptor","removePadding()"],"updatePoint":{"line":17,"column":47,"index":819},"line":17,"code":"    it('removes 4 bytes when the last byte is 4', function () {\n      const arr = new Uint8Array([1, 2, 3, 4]);\n      expect(Array.from(new Uint8Array(removePadding(arr)))).to.deep.equal([]);\n    });","file":"unit/crypt/aes-decryptor.js","skipped":false,"dir":"tests"},{"name":"should trigger a MEDIA_ERROR event if sample index is invalid","suites":["getAudioConfig"],"updatePoint":{"line":5,"column":67,"index":386},"line":5,"code":"  it('should trigger a MEDIA_ERROR event if sample index is invalid', function () {\n    const observer = {\n      trigger: sinon.spy()\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x34; // sampling_frequency_index = 14, which is a reserved value\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.29')).to.not.exist;\n    expect(observer.trigger).to.have.been.calledOnce;\n    expect(observer.trigger.args[0][1].type).to.equal(ErrorTypes.MEDIA_ERROR);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for firefox if the specified sampling frequency > 24kHz","suites":["getAudioConfig"],"updatePoint":{"line":18,"column":88,"index":989},"line":18,"code":"  it('should return audio config for firefox if the specified sampling frequency > 24kHz', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'firefox')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x00; // sampling_frequency_index = 0\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.29')).to.deep.equal({\n      config: [16, 0],\n      samplerate: 96000,\n      channelCount: 0,\n      codec: 'mp4a.40.2',\n      manifestCodec: 'mp4a.40.29'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config with a different extension sampling index for Firefox if sampling freq is low","suites":["getAudioConfig"],"updatePoint":{"line":35,"column":110,"index":1638},"line":35,"code":"  it('should return audio config with a different extension sampling index for Firefox if sampling freq is low', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Firefox')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.29')).to.deep.equal({\n      config: [45, 3, 136, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: 'mp4a.40.29'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Android","suites":["getAudioConfig"],"updatePoint":{"line":52,"column":44,"index":2230},"line":52,"code":"  it('should return audio config for Android', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Android')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.29')).to.deep.equal({\n      config: [21, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.2',\n      manifestCodec: 'mp4a.40.29'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Chrome","suites":["getAudioConfig"],"updatePoint":{"line":69,"column":43,"index":2813},"line":69,"code":"  it('should return audio config for Chrome', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Chrome')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.29')).to.deep.equal({\n      config: [45, 3, 136, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: 'mp4a.40.29'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Chrome if there is no audio codec","suites":["getAudioConfig"],"updatePoint":{"line":86,"column":70,"index":3430},"line":86,"code":"  it('should return audio config for Chrome if there is no audio codec', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Chrome')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    expect(getAudioConfig(observer, data, 0)).to.deep.equal({\n      config: [45, 3, 136, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: undefined\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Chrome if there is no audio codec and freq is high enough","suites":["getAudioConfig"],"updatePoint":{"line":103,"column":94,"index":4054},"line":103,"code":"  it('should return audio config for Chrome if there is no audio codec and freq is high enough', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Chrome')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x08; // sampling_frequency_index = 2\n\n    expect(getAudioConfig(observer, data, 0)).to.deep.equal({\n      config: [41, 1, 8, 0],\n      samplerate: 64000,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: undefined\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Chrome if audio codec is \"mp4a.40.5\"","suites":["getAudioConfig"],"updatePoint":{"line":120,"column":73,"index":4654},"line":120,"code":"  it('should return audio config for Chrome if audio codec is \"mp4a.40.5\"', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Chrome')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.5')).to.deep.equal({\n      config: [45, 3, 136, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: 'mp4a.40.5'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Chrome if audio codec is \"mp4a.40.2\"","suites":["getAudioConfig"],"updatePoint":{"line":137,"column":73,"index":5272},"line":137,"code":"  it('should return audio config for Chrome if audio codec is \"mp4a.40.2\"', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Chrome')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n    data[3] = 0x40; // channel = 1\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.2')).to.deep.equal({\n      config: [21, 8],\n      samplerate: 11025,\n      channelCount: 1,\n      codec: 'mp4a.40.2',\n      manifestCodec: 'mp4a.40.2'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return audio config for Vivaldi","suites":["getAudioConfig"],"updatePoint":{"line":155,"column":44,"index":5888},"line":155,"code":"  it('should return audio config for Vivaldi', function () {\n    const observer = {\n      trigger: sinon.stub(navigator, 'userAgent').get(() => 'Vivaldi')\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x08; // sampling_frequency_index = 2\n\n    expect(getAudioConfig(observer, data, 0, 'mp4a.40.2')).to.deep.equal({\n      config: [17, 0],\n      samplerate: 64000,\n      channelCount: 0,\n      codec: 'mp4a.40.2',\n      manifestCodec: 'mp4a.40.2'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return true if the specified data slot is of header pattern","suites":["isHeaderPattern"],"updatePoint":{"line":174,"column":72,"index":6543},"line":174,"code":"  it('should return true if the specified data slot is of header pattern', function () {\n    const data = new Uint8Array(new ArrayBuffer(16));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[14] = 0xff;\n    data[15] = 0xf9; // ID = 1 (MPEG-2), layer = 00, protection_absent = 1\n    expect(isHeaderPattern(data, 0)).to.be.true;\n    expect(isHeaderPattern(data, 14)).to.be.true;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if the specific data is not of header pattern","suites":["isHeaderPattern"],"updatePoint":{"line":183,"column":71,"index":6980},"line":183,"code":"  it('should return false if the specific data is not of header pattern', function () {\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[1] = 0xff;\n    data[2] = 0xff;\n    expect(isHeaderPattern(data, 0)).to.be.false;\n    expect(isHeaderPattern(data, 2)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return 7 if there is no CRC","suites":["getHeaderLength"],"updatePoint":{"line":192,"column":40,"index":7282},"line":192,"code":"  it('should return 7 if there is no CRC', function () {\n    const data = new Uint8Array(new ArrayBuffer(2));\n    data[0] = 0xff;\n    data[1] = 0xf9; // ID = 1 (MPEG-2), layer = 00, protection_absent = 1\n    expect(getHeaderLength(data, 0)).to.equal(7);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return 9 if there is CRC","suites":["getHeaderLength"],"updatePoint":{"line":198,"column":37,"index":7539},"line":198,"code":"  it('should return 9 if there is CRC', function () {\n    const data = new Uint8Array(new ArrayBuffer(2));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    expect(getHeaderLength(data, 0)).to.equal(9);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should extract frame_length field and return its value","suites":["getFullFrameLength"],"updatePoint":{"line":206,"column":60,"index":7868},"line":206,"code":"  it('should extract frame_length field and return its value', function () {\n    const data = new Uint8Array(new ArrayBuffer(8));\n    data[0] = 0xff;\n    data[1] = 0xf9;\n    data[2] = 0x00;\n    data[3] = 0x02; // the last 2 bits belong to frame_length\n    data[4] = 0x00; // all 8 bits belong to frame_length\n    data[5] = 0xe0; // the first 3 bits belong to frame_length\n    expect(getFullFrameLength(data, 0)).to.equal(4103);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return true if there are enough data and it is of header pattern","suites":["isHeader"],"updatePoint":{"line":218,"column":77,"index":8358},"line":218,"code":"  it('should return true if there are enough data and it is of header pattern', function () {\n    const data = new Uint8Array(new ArrayBuffer(8));\n    data[0] = 0xff;\n    data[1] = 0xf9;\n    expect(isHeader(data, 0)).to.be.true;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if there are not enough data","suites":["isHeader"],"updatePoint":{"line":224,"column":54,"index":8570},"line":224,"code":"  it('should return false if there are not enough data', function () {\n    const data = new Uint8Array(new ArrayBuffer(1));\n    expect(isHeader(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if it is not of header pattern","suites":["isHeader"],"updatePoint":{"line":228,"column":56,"index":8745},"line":228,"code":"  it('should return false if it is not of header pattern', function () {\n    const data = new Uint8Array(new ArrayBuffer(8));\n    expect(isHeader(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if `isHeader` fails","suites":["probe"],"updatePoint":{"line":234,"column":45,"index":8945},"line":234,"code":"  it('should return false if `isHeader` fails', function () {\n    const data = new Uint8Array(new ArrayBuffer(8));\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return true if it contains the entire ADTS frame","suites":["probe"],"updatePoint":{"line":238,"column":61,"index":9122},"line":238,"code":"  it('should return true if it contains the entire ADTS frame', function () {\n    const data = new Uint8Array(new ArrayBuffer(16));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n    expect(probe(data, 0)).to.be.true;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return true if it contains an valid following frame header","suites":["probe"],"updatePoint":{"line":245,"column":71,"index":9416},"line":245,"code":"  it('should return true if it contains an valid following frame header', function () {\n    const data = new Uint8Array(new ArrayBuffer(18));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n    data[16] = 0xff;\n    data[17] = 0xf0;\n    expect(probe(data, 0)).to.be.true;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if it contains the entire ADTS frame with an incomplete following header","suites":["probe"],"updatePoint":{"line":254,"column":98,"index":9779},"line":254,"code":"  it('should return false if it contains the entire ADTS frame with an incomplete following header', function () {\n    const data = new Uint8Array(new ArrayBuffer(17));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if it contains the entire ADTS frame with an invalid following frame header","suites":["probe"],"updatePoint":{"line":261,"column":101,"index":10104},"line":261,"code":"  it('should return false if it contains the entire ADTS frame with an invalid following frame header', function () {\n    const data = new Uint8Array(new ArrayBuffer(18));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if it does not contain the entire header","suites":["probe"],"updatePoint":{"line":268,"column":66,"index":10394},"line":268,"code":"  it('should return false if it does not contain the entire header', function () {\n    const data = new Uint8Array(new ArrayBuffer(2));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if the header is broken","suites":["probe"],"updatePoint":{"line":274,"column":49,"index":10624},"line":274,"code":"  it('should return false if the header is broken', function () {\n    const data = new Uint8Array(new ArrayBuffer(9));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x00; // frame_length is 0\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return false if it does not contain the entire header (2)","suites":["probe"],"updatePoint":{"line":281,"column":70,"index":10916},"line":281,"code":"  it('should return false if it does not contain the entire header (2)', function () {\n    const data = new Uint8Array(new ArrayBuffer(8));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x00; // frame_length is 6\n    data[5] = 0xc0;\n    data[6] = 0xff;\n    data[7] = 0xf0;\n    expect(probe(data, 0)).to.be.false;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should do nothing with track if track.samplerate is defined","suites":["initTrackConfig"],"updatePoint":{"line":293,"column":65,"index":11309},"line":293,"code":"  it('should do nothing with track if track.samplerate is defined', function () {\n    const track = {\n      samplerate: 64000\n    };\n    initTrackConfig(track);\n    expect(track).to.deep.equal({\n      samplerate: 64000\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should call `getAudioConfig` and change track if track.samplerate is undefined","suites":["initTrackConfig"],"updatePoint":{"line":302,"column":84,"index":11561},"line":302,"code":"  it('should call `getAudioConfig` and change track if track.samplerate is undefined', function () {\n    const track = {};\n    const observer = {\n      trigger: sinon.spy()\n    };\n    const data = new Uint8Array(new ArrayBuffer(4));\n    data[0] = 0xff;\n    data[1] = 0xf0; // ID = 0 (MPEG-4), layer = 00, protection_absent = 0\n    data[2] = 0x28; // sampling_frequency_index = 10\n\n    initTrackConfig(track, observer, data, 0, 'mp4a.40.29');\n    expect(track).to.deep.equal({\n      config: [45, 3, 136, 0],\n      samplerate: 11025,\n      channelCount: 0,\n      codec: 'mp4a.40.5',\n      manifestCodec: 'mp4a.40.29'\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should compute frame duration from sample rate","suites":["getFrameDuration"],"updatePoint":{"line":323,"column":52,"index":12205},"line":323,"code":"  it('should compute frame duration from sample rate', function () {\n    expect(getFrameDuration(64000)).to.equal(1440);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return parsed result if data contains the entire frame","suites":["parseFrameHeader"],"updatePoint":{"line":328,"column":67,"index":12394},"line":328,"code":"  it('should return parsed result if data contains the entire frame', function () {\n    const data = new Uint8Array(new ArrayBuffer(16));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n    expect(parseFrameHeader(data, 0)).to.deep.equal({\n      headerLength: 9,\n      frameLength: 7\n    });\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return undefined if frame length is 0","suites":["parseFrameHeader"],"updatePoint":{"line":338,"column":50,"index":12734},"line":338,"code":"  it('should return undefined if frame length is 0', function () {\n    const data = new Uint8Array(new ArrayBuffer(12));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x00; // frame_length is 0\n    expect(parseFrameHeader(data, 0)).to.be.undefined;\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should append the found sample to track and return frame information","suites":["appendFrame"],"updatePoint":{"line":347,"column":74,"index":13088},"line":347,"code":"  it('should append the found sample to track and return frame information', function () {\n    const track = {\n      samplerate: 64000,\n      samples: [],\n      len: 0\n    };\n    const data = new Uint8Array(new ArrayBuffer(16));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x02; // frame_length is 16\n\n    const frame = appendFrame(track, data, 0, 0, 0);\n    expect(frame, JSON.stringify(frame)).to.deep.equal({\n      sample: {\n        unit: data.subarray(9, 16),\n        pts: 0\n      },\n      length: 16,\n      missing: 0\n    });\n    expect(track.samples.length).to.equal(1);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return an incomplete frame without appending when data is incomplete (aac overflow or progressive streaming)","suites":["appendFrame"],"updatePoint":{"line":369,"column":121,"index":13753},"line":369,"code":"  it('should return an incomplete frame without appending when data is incomplete (aac overflow or progressive streaming)', function () {\n    const track = {\n      samplerate: 64000,\n      samples: [],\n      len: 0\n    };\n    const data = new Uint8Array(new ArrayBuffer(20));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n    data[4] = 0x03; // frame_length is 24\n\n    const frame = appendFrame(track, data, 0, 0, 0);\n    const unit = new Uint8Array(15);\n    unit.set(data.subarray(9, 20), 0);\n    expect(frame, JSON.stringify(frame)).to.deep.equal({\n      sample: {\n        unit,\n        pts: 0\n      },\n      length: 24,\n      missing: 4\n    });\n    expect(track.samples.length).to.equal(0);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should return an incomplete frame without appending when header is incomplete (aac overflow or progressive streaming)","suites":["appendFrame"],"updatePoint":{"line":393,"column":123,"index":14474},"line":393,"code":"  it('should return an incomplete frame without appending when header is incomplete (aac overflow or progressive streaming)', function () {\n    const track = {\n      samplerate: 64000,\n      samples: [],\n      len: 0\n    };\n    const data = new Uint8Array(new ArrayBuffer(2));\n    data[0] = 0xff;\n    data[1] = 0xf0; // protection_absent = 0\n\n    const frame = appendFrame(track, data, 0, 0, 0);\n    const unit = new Uint8Array(2);\n    unit.set(data.subarray(0, 2), 0);\n    expect(frame, JSON.stringify(frame)).to.deep.equal({\n      sample: {\n        unit,\n        pts: 0\n      },\n      length: 2,\n      missing: -1\n    });\n    expect(track.samples.length).to.equal(0);\n  });","file":"unit/demuxer/adts.js","skipped":false,"dir":"tests"},{"name":"should use the timestamp if it is valid","suites":["BaseAudioDemuxer","initPTSFn"],"updatePoint":{"line":5,"column":47,"index":227},"line":5,"code":"    it('should use the timestamp if it is valid', function () {\n      expect(initPTSFn(1, 1, 0)).to.be.eq(90);\n      expect(initPTSFn(5, 1, 0)).to.be.eq(450);\n      expect(initPTSFn(0, 1, 0)).to.be.eq(0);\n    });","file":"unit/demuxer/base-audio-demuxer.ts","skipped":false,"dir":"tests"},{"name":"should use the timeOffset if timestamp is undefined or not finite","suites":["BaseAudioDemuxer","initPTSFn"],"updatePoint":{"line":10,"column":73,"index":466},"line":10,"code":"    it('should use the timeOffset if timestamp is undefined or not finite', function () {\n      expect(initPTSFn(undefined, 1, 0)).to.be.eq(90000);\n      expect(initPTSFn(NaN, 1, 0)).to.be.eq(90000);\n      expect(initPTSFn(Infinity, 1, 0)).to.be.eq(90000);\n    });","file":"unit/demuxer/base-audio-demuxer.ts","skipped":false,"dir":"tests"},{"name":"should add initPTS to timeOffset when timestamp is undefined or not finite","suites":["BaseAudioDemuxer","initPTSFn"],"updatePoint":{"line":15,"column":82,"index":740},"line":15,"code":"    it('should add initPTS to timeOffset when timestamp is undefined or not finite', function () {\n      expect(initPTSFn(undefined, 1, 42)).to.be.eq(90042);\n      expect(initPTSFn(NaN, 1, 42)).to.be.eq(90042);\n    });","file":"unit/demuxer/base-audio-demuxer.ts","skipped":false,"dir":"tests"},{"name":"should return a bandwidth estimate","suites":["Hls","bandwidthEstimate"],"updatePoint":{"line":6,"column":42,"index":236},"line":6,"code":"    it('should return a bandwidth estimate', function () {\n      const MOCKED_ESTIMATE = 2000;\n      const hls = new Hls();\n      hls.abrController = {\n        bwEstimator: {\n          getEstimate: () => MOCKED_ESTIMATE\n        }\n      };\n      expect(hls.bandwidthEstimate).to.equal(MOCKED_ESTIMATE);\n    });","file":"unit/hls.js","skipped":false,"dir":"tests"},{"name":"should return a default bandwidth estimate","suites":["Hls","bandwidthEstimate"],"updatePoint":{"line":16,"column":50,"index":554},"line":16,"code":"    it('should return a default bandwidth estimate', function () {\n      const hls = new Hls();\n      expect(hls.bandwidthEstimate).to.equal(hlsDefaultConfig.abrEwmaDefaultEstimate);\n    });","file":"unit/hls.js","skipped":false,"dir":"tests"},{"name":"should not crash on stopLoad() after destroy()","suites":["Hls","destroy"],"updatePoint":{"line":22,"column":54,"index":791},"line":22,"code":"    it('should not crash on stopLoad() after destroy()', function () {\n      const hls = new Hls();\n      hls.destroy();\n      expect(() => hls.stopLoad()).to.not.throw();\n    });","file":"unit/hls.js","skipped":false,"dir":"tests"},{"name":"should not crash on startLoad() after destroy()","suites":["Hls","destroy"],"updatePoint":{"line":27,"column":55,"index":972},"line":27,"code":"    it('should not crash on startLoad() after destroy()', function () {\n      const hls = new Hls();\n      hls.destroy();\n      expect(() => hls.startLoad()).to.not.throw();\n    });","file":"unit/hls.js","skipped":false,"dir":"tests"},{"name":"parses id, class, date, duration, and end-on-next attributes","suites":["DateRange class"],"updatePoint":{"line":18,"column":66,"index":1677},"line":18,"code":"  it('parses id, class, date, duration, and end-on-next attributes', function () {\n    const dateRangeDuration = new DateRange(startDateAndDuration);\n    expect(dateRangeDuration.id).to.equal('ad1');\n    expect(dateRangeDuration.class).to.equal('com.apple.hls.interstitial');\n    expect(dateRangeDuration.startDate.toISOString()).to.equal('2020-01-02T21:55:44.000Z');\n    expect(dateRangeDuration.duration).to.equal(15);\n    const dateRangeEndDate = new DateRange(startDateAndEndDate);\n    expect(dateRangeEndDate.id).to.equal('ad2');\n    expect(dateRangeEndDate.class).to.equal('com.apple.hls.interstitial');\n    expect(dateRangeEndDate.startDate.toISOString()).to.equal('2020-01-02T21:55:44.000Z');\n    expect(dateRangeEndDate.endDate?.toISOString()).to.equal('2020-01-02T21:56:44.001Z');\n    const dateRangeEndOnNext = new DateRange(startDateAndEndOnNext);\n    expect(dateRangeEndOnNext.id).to.equal('ad3');\n    expect(dateRangeEndOnNext.class).to.equal('com.apple.hls.interstitial');\n    expect(dateRangeEndOnNext.startDate.toISOString()).to.equal('2022-01-01T00:00:00.100Z');\n    expect(dateRangeEndOnNext.endOnNext).to.equal(true);\n    const dateRangePlannedDuration = new DateRange(sctePlanned);\n    expect(dateRangePlannedDuration.id).to.equal('s1');\n    expect(dateRangePlannedDuration.startDate.toISOString()).to.equal('2014-03-05T11:15:00.000Z');\n    expect(dateRangePlannedDuration.plannedDuration).to.equal(59.993);\n  });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"calculates end-date based on duration","suites":["DateRange class"],"updatePoint":{"line":39,"column":43,"index":3089},"line":39,"code":"  it('calculates end-date based on duration', function () {\n    const dateRangeDuration = new DateRange(startDateAndDuration);\n    expect(dateRangeDuration.endDate?.toISOString()).to.equal('2020-01-02T21:55:59.000Z');\n  });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"calculates duration based on end-date","suites":["DateRange class"],"updatePoint":{"line":43,"column":43,"index":3313},"line":43,"code":"  it('calculates duration based on end-date', function () {\n    const dateRangeEndDate = new DateRange(startDateAndEndDate);\n    expect(dateRangeEndDate.duration).to.equal(60.001);\n  });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has required attributes","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":61,"column":31,"index":4306},"line":61,"code":"    it('has required attributes', function () {\n      validateDateRange(startDateAndDuration, true);\n      validateDateRange(startDateAndEndDate, true);\n      validateDateRange(startDateAndEndOnNext, true);\n      validateDateRange(sctePlanned, true);\n      validateDateRange(missingId, false);\n      validateDateRange(missingStartDate, false);\n      validateDateRange(scteDurationUpdate, false);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has a valid START-DATE date/time value","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":70,"column":46,"index":4725},"line":70,"code":"    it('has a valid START-DATE date/time value', function () {\n      validateDateRange(invalidStartDate, false);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has an optional DURATION is not negative","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":73,"column":48,"index":4848},"line":73,"code":"    it('has an optional DURATION is not negative', function () {\n      validateDateRange(negativeDuration, false);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has an optional END-DATE that is equal to or later than the value of START-DATE","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":76,"column":87,"index":5010},"line":76,"code":"    it('has an optional END-DATE that is equal to or later than the value of START-DATE', function () {\n      validateDateRange(endDateEarlierThanStartDate, false);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has a CLASS attribute when END-ON-NEXT=YES","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":79,"column":50,"index":5146},"line":79,"code":"    it('has a CLASS attribute when END-ON-NEXT=YES', function () {\n      validateDateRange(endOnNextWithNoClass, false);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"has another DateRange tag with the same ID attribute value, and attributes that appear in both tags have the same value","suites":["DateRange class","isValid indicates that DATERANGE tag:"],"updatePoint":{"line":82,"column":127,"index":5352},"line":82,"code":"    it('has another DateRange tag with the same ID attribute value, and attributes that appear in both tags have the same value', function () {\n      const scteOut = new DateRange(sctePlanned);\n      const scteIn = new DateRange(scteInvalidChange, scteOut);\n      expect(scteIn.isValid).to.equal(false, `Expected DateRange with same ID to be invalid because of conflicting attribute values\\n${JSON.stringify(scteOut)}\\n${JSON.stringify(scteIn)}`);\n    });","file":"unit/loader/date-range.ts","skipped":false,"dir":"tests"},{"name":"returns true if an EXT-X-KEY is associated with the fragment","suites":["Fragment class tests","encrypted"],"updatePoint":{"line":17,"column":68,"index":584},"line":17,"code":"    it('returns true if an EXT-X-KEY is associated with the fragment', function () {\n      // From https://docs.microsoft.com/en-us/azure/media-services/previous/media-services-protect-with-aes128\n\n      const key = new LevelKey('AES-128', 'https://wamsbayclus001kd-hs.cloudapp.net/HlsHandler.ashx?kid=da3813af-55e6-48e7-aa9f-a4d6031f7b4d', 'identity');\n      frag.levelkeys = {\n        identity: key\n      };\n      expect(frag.encrypted).to.equal(true);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"returns true for fairplay manifest signalled encryption","suites":["Fragment class tests","encrypted"],"updatePoint":{"line":26,"column":63,"index":1042},"line":26,"code":"    it('returns true for fairplay manifest signalled encryption', function () {\n      const key = new LevelKey('SAMPLE-AES', 'skd://one', 'com.apple.streamingkeydelivery', [1]);\n      frag.levelkeys = {\n        'com.apple.streamingkeydelivery': key\n      };\n      expect(frag.encrypted).to.equal(true);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"returns true for widevine v2 manifest signalled encryption","suites":["Fragment class tests","encrypted"],"updatePoint":{"line":33,"column":66,"index":1356},"line":33,"code":"    it('returns true for widevine v2 manifest signalled encryption', function () {\n      // #EXT-X-KEY:METHOD=SAMPLE-AES,URI=data:text/plain;base64,AAAAPXBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAAB0aDXdpZGV2aW5lX3Rlc3QiDHRlc3QgY29udGVudA==,KEYID=0x112233445566778899001122334455,KEYFORMAT=urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed,KEYFORMATVERSION=1\n      // From https://www.academia.edu/36030972/Widevine_DRM_for_HLS\n\n      const key = new LevelKey('SAMPLE-AES', 'data:text/plain;base64,AAAAPXBzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAAB0aDXdpZGV2aW5lX3Rlc3QiDHRlc3QgY29udGVudA==', 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed', [1]);\n      frag.levelkeys = {\n        'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': key\n      };\n      expect(frag.encrypted).to.equal(true);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"returns true for a playready manifest signalled encryption","suites":["Fragment class tests","encrypted"],"updatePoint":{"line":43,"column":66,"index":2138},"line":43,"code":"    it('returns true for a playready manifest signalled encryption', function () {\n      // #EXT-X-KEY:METHOD=SAMPLE-AES,KEYFORMAT=\"com.microsoft.playready\",KEYFORMATVERSIONS=\"1\",URI=\"data:text/plain;charset=UTF-16;base64,xAEAAAEAAQC6ATwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AdgBHAFYAagBOAEsAZwBZAE0ARQBxAHAATwBMAGgAMQBWAGQAUgBUADAAQQA9AD0APAAvAEsASQBEAD4APAAvAEQAQQBUAEEAPgA8AC8AVwBSAE0ASABFAEEARABFAFIAPgA=\"\n      // From https://docs.microsoft.com/en-us/playready/packaging/mp4-based-formats-supported-by-playready-clients?tabs=case4\n\n      const key = new LevelKey('SAMPLE-AES', 'data:text/plain;charset=UTF-16;base64,xAEAAAEAAQC6ATwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AdgBHAFYAagBOAEsAZwBZAE0ARQBxAHAATwBMAGgAMQBWAGQAUgBUADAAQQA9AD0APAAvAEsASQBEAD4APAAvAEQAQQBUAEEAPgA8AC8AVwBSAE0ASABFAEEARABFAFIAPgA=', 'com.microsoft.playready', [1]);\n      frag.levelkeys = {\n        'com.microsoft.playready': key\n      };\n      expect(frag.encrypted).to.equal(true);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"returns false when key method is NONE","suites":["Fragment class tests","encrypted"],"updatePoint":{"line":53,"column":45,"index":3923},"line":53,"code":"    it('returns false when key method is NONE', function () {\n      const key = new LevelKey('NONE', 'plain-text', 'org.w3.clearkey', [1]);\n      frag.levelkeys = {\n        NONE: key\n      };\n      expect(frag.encrypted).to.equal(false);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"set byte range with length@offset","suites":["Fragment class tests","setByteRange"],"updatePoint":{"line":62,"column":41,"index":4212},"line":62,"code":"    it('set byte range with length@offset', function () {\n      frag.setByteRange('1000@10000');\n      expect(frag.byteRangeStartOffset).to.equal(10000);\n      expect(frag.byteRangeEndOffset).to.equal(11000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"set byte range with no offset and uses 0 as offset","suites":["Fragment class tests","setByteRange"],"updatePoint":{"line":67,"column":58,"index":4446},"line":67,"code":"    it('set byte range with no offset and uses 0 as offset', function () {\n      frag.setByteRange('5000');\n      expect(frag.byteRangeStartOffset).to.equal(0);\n      expect(frag.byteRangeEndOffset).to.equal(5000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"set byte range with no offset and uses 0 as offset","suites":["Fragment class tests","setByteRange"],"updatePoint":{"line":72,"column":58,"index":4669},"line":72,"code":"    it('set byte range with no offset and uses 0 as offset', function () {\n      const prevFrag = new Fragment(PlaylistLevelType.MAIN, '');\n      prevFrag.setByteRange('1000@10000');\n      frag.setByteRange('5000', prevFrag);\n      expect(frag.byteRangeStartOffset).to.equal(11000);\n      expect(frag.byteRangeEndOffset).to.equal(16000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"computes endPdt when pdt and duration are valid","suites":["Fragment class tests","endProgramDateTime getter"],"updatePoint":{"line":81,"column":55,"index":5072},"line":81,"code":"    it('computes endPdt when pdt and duration are valid', function () {\n      frag.programDateTime = 1000;\n      frag.duration = 1;\n      expect(frag.endProgramDateTime).to.equal(2000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"considers 0 a valid pdt","suites":["Fragment class tests","endProgramDateTime getter"],"updatePoint":{"line":86,"column":31,"index":5242},"line":86,"code":"    it('considers 0 a valid pdt', function () {\n      frag.programDateTime = 0;\n      frag.duration = 1;\n      expect(frag.endProgramDateTime).to.equal(1000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"returns null if pdt is NaN","suites":["Fragment class tests","endProgramDateTime getter"],"updatePoint":{"line":91,"column":34,"index":5412},"line":91,"code":"    it('returns null if pdt is NaN', function () {\n      frag.programDateTime = NaN;\n      frag.duration = 1;\n      expect(frag.endProgramDateTime).to.equal(null);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"defaults duration to 0 if duration is NaN","suites":["Fragment class tests","endProgramDateTime getter"],"updatePoint":{"line":96,"column":49,"index":5599},"line":96,"code":"    it('defaults duration to 0 if duration is NaN', function () {\n      frag.programDateTime = 1000;\n      frag.duration = NaN;\n      expect(frag.endProgramDateTime).to.equal(1000);\n    });","file":"unit/loader/fragment.ts","skipped":false,"dir":"tests"},{"name":"sets programDateTime to true when the first fragment has valid pdt","suites":["Level Class tests"],"updatePoint":{"line":3,"column":72,"index":183},"line":3,"code":"  it('sets programDateTime to true when the first fragment has valid pdt', function () {\n    const level = new LevelDetails();\n    level.fragments = [{\n      programDateTime: 1\n    }];\n    expect(level.hasProgramDateTime).to.be.true;\n  });","file":"unit/loader/level.js","skipped":false,"dir":"tests"},{"name":"sets programDateTime to false when no fragments is empty","suites":["Level Class tests"],"updatePoint":{"line":10,"column":62,"index":413},"line":10,"code":"  it('sets programDateTime to false when no fragments is empty', function () {\n    const level = new LevelDetails();\n    expect(level.hasProgramDateTime).to.be.false;\n  });","file":"unit/loader/level.js","skipped":false,"dir":"tests"},{"name":"sets programDateTime to false when the first fragment has an invalid pdt","suites":["Level Class tests"],"updatePoint":{"line":14,"column":78,"index":602},"line":14,"code":"  it('sets programDateTime to false when the first fragment has an invalid pdt', function () {\n    const level = new LevelDetails();\n    level.fragments = [{\n      programDateTime: 'foo'\n    }];\n    expect(level.hasProgramDateTime).to.be.false;\n  });","file":"unit/loader/level.js","skipped":false,"dir":"tests"},{"name":"constructor() supports empty arguments","suites":["AttrList"],"updatePoint":{"line":3,"column":44,"index":137},"line":3,"code":"  it('constructor() supports empty arguments', function () {\n    expect(Object.keys(new AttrList())).to.deep.equal([]);\n    expect(Object.keys(new AttrList({}))).to.deep.equal([]);\n    expect(Object.keys(new AttrList(undefined))).to.deep.equal([]);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"constructor() supports object argument","suites":["AttrList"],"updatePoint":{"line":8,"column":44,"index":392},"line":8,"code":"  it('constructor() supports object argument', function () {\n    const obj = {\n      VALUE: '42'\n    };\n    const list = new AttrList(obj);\n    expect(list.decimalInteger('VALUE')).to.equal(42);\n    expect(Object.keys(list).length).to.equal(1);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid decimalInteger attribute","suites":["AttrList"],"updatePoint":{"line":16,"column":43,"index":642},"line":16,"code":"  it('parses valid decimalInteger attribute', function () {\n    expect(new AttrList('INT=42').decimalInteger('INT')).to.equal(42);\n    expect(new AttrList('INT=0').decimalInteger('INT')).to.equal(0);\n    expect(new AttrList('INT=\"42\"').decimalInteger('INT')).to.equal(42);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses attribute with leading space","suites":["AttrList"],"updatePoint":{"line":21,"column":41,"index":919},"line":21,"code":"  it('parses attribute with leading space', function () {\n    expect(new AttrList(' INT=42').decimalInteger('INT')).to.equal(42);\n    expect(new AttrList(' INT=0').decimalInteger('INT')).to.equal(0);\n    expect(new AttrList(' INT=\"42\"').decimalInteger('INT')).to.equal(42);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses attribute with trailing space","suites":["AttrList"],"updatePoint":{"line":26,"column":42,"index":1200},"line":26,"code":"  it('parses attribute with trailing space', function () {\n    expect(new AttrList('INT =42').decimalInteger('INT')).to.equal(42);\n    expect(new AttrList('INT =0').decimalInteger('INT')).to.equal(0);\n    expect(new AttrList('INT =\"42\"').decimalInteger('INT')).to.equal(42);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid hexadecimalInteger attribute","suites":["AttrList"],"updatePoint":{"line":31,"column":47,"index":1486},"line":31,"code":"  it('parses valid hexadecimalInteger attribute', function () {\n    expect(new AttrList('HEX=0x42').hexadecimalIntegerAsNumber('HEX')).to.equal(0x42);\n    expect(new AttrList('HEX=0X42').hexadecimalIntegerAsNumber('HEX')).to.equal(0x42);\n    expect(new AttrList('HEX=0x0').hexadecimalIntegerAsNumber('HEX')).to.equal(0);\n    expect(new AttrList('HEX=\"0x42\"').hexadecimalIntegerAsNumber('HEX')).to.equal(0x42);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid decimalFloatingPoint attribute","suites":["AttrList"],"updatePoint":{"line":37,"column":49,"index":1904},"line":37,"code":"  it('parses valid decimalFloatingPoint attribute', function () {\n    expect(new AttrList('FLOAT=0.42').decimalFloatingPoint('FLOAT')).to.equal(0.42);\n    expect(new AttrList('FLOAT=-0.42').decimalFloatingPoint('FLOAT')).to.equal(-0.42);\n    expect(new AttrList('FLOAT=0').decimalFloatingPoint('FLOAT')).to.equal(0);\n    expect(new AttrList('FLOAT=\"0.42\"').decimalFloatingPoint('FLOAT')).to.equal(0.42);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid quotedString attribute","suites":["AttrList"],"updatePoint":{"line":43,"column":41,"index":2306},"line":43,"code":"  it('parses valid quotedString attribute', function () {\n    expect(new AttrList('STRING=\"hi\"').STRING).to.equal('hi');\n    expect(new AttrList('STRING=\"\"').STRING).to.equal('');\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses exotic quotedString attribute","suites":["AttrList"],"updatePoint":{"line":47,"column":42,"index":2493},"line":47,"code":"  it('parses exotic quotedString attribute', function () {\n    const list = new AttrList('STRING=\"hi,ENUM=OK,RES=4x2\"');\n    expect(list.STRING).to.equal('hi,ENUM=OK,RES=4x2');\n    expect(Object.keys(list).length).to.equal(1);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid enumeratedString attribute","suites":["AttrList"],"updatePoint":{"line":52,"column":45,"index":2729},"line":52,"code":"  it('parses valid enumeratedString attribute', function () {\n    expect(new AttrList('ENUM=OK').enumeratedString('ENUM')).to.equal('OK');\n    expect(new AttrList('ENUM=\"OK\"').enumeratedString('ENUM')).to.equal('OK');\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses exotic enumeratedString attribute","suites":["AttrList"],"updatePoint":{"line":56,"column":46,"index":2954},"line":56,"code":"  it('parses exotic enumeratedString attribute', function () {\n    expect(new AttrList('ENUM=1').enumeratedString('ENUM')).to.equal('1');\n    expect(new AttrList('ENUM=A=B').enumeratedString('ENUM')).to.equal('A=B');\n    expect(new AttrList('ENUM=A=B=C').enumeratedString('ENUM')).to.equal('A=B=C');\n    const list = new AttrList('ENUM1=A=B=C,ENUM2=42');\n    expect(list.enumeratedString('ENUM1')).to.equal('A=B=C');\n    expect(list.enumeratedString('ENUM2')).to.equal('42');\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses valid decimalResolution attribute","suites":["AttrList"],"updatePoint":{"line":64,"column":46,"index":3436},"line":64,"code":"  it('parses valid decimalResolution attribute', function () {\n    expect(new AttrList('RES=400x200').decimalResolution('RES')).to.deep.equal({\n      width: 400,\n      height: 200\n    });\n    expect(new AttrList('RES=0x0').decimalResolution('RES')).to.deep.equal({\n      width: 0,\n      height: 0\n    });\n    expect(new AttrList('RES=\"400x200\"').decimalResolution('RES')).to.deep.equal({\n      width: 400,\n      height: 200\n    });\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"handles invalid decimalResolution attribute","suites":["AttrList"],"updatePoint":{"line":78,"column":49,"index":3877},"line":78,"code":"  it('handles invalid decimalResolution attribute', function () {\n    expect(new AttrList('RES=400x-200').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=400.5x200').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=400x200.5').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=400').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=400x').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=x200').decimalResolution('RES')).to.not.exist;\n    expect(new AttrList('RES=x').decimalResolution('RES')).to.not.exist;\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses multiple attributes","suites":["AttrList"],"updatePoint":{"line":87,"column":32,"index":4474},"line":87,"code":"  it('parses multiple attributes', function () {\n    const list = new AttrList('INT=42,HEX=0x42,FLOAT=0.42,STRING=\"hi\",ENUM=OK,RES=4x2');\n    expect(list.decimalInteger('INT')).to.equal(42);\n    expect(list.hexadecimalIntegerAsNumber('HEX')).to.equal(0x42);\n    expect(list.decimalFloatingPoint('FLOAT')).to.equal(0.42);\n    expect(list.STRING).to.equal('hi');\n    expect(list.enumeratedString('ENUM')).to.equal('OK');\n    expect(list.decimalResolution('RES')).to.deep.equal({\n      width: 4,\n      height: 2\n    });\n    expect(Object.keys(list).length).to.equal(6);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"handles missing attributes","suites":["AttrList"],"updatePoint":{"line":100,"column":32,"index":5047},"line":100,"code":"  it('handles missing attributes', function () {\n    const list = new AttrList();\n    expect(list.decimalInteger('INT')).to.be.NaN;\n    expect(list.hexadecimalIntegerAsNumber('HEX')).to.be.NaN;\n    expect(list.decimalFloatingPoint('FLOAT')).to.be.NaN;\n    expect(list.STRING).to.not.exist;\n    expect(list.enumeratedString('ENUM')).to.not.exist;\n    expect(list.decimalResolution('RES')).to.not.exist;\n    expect(Object.keys(list)).to.have.lengthOf(0);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"parses dashed attribute names","suites":["AttrList"],"updatePoint":{"line":110,"column":35,"index":5509},"line":110,"code":"  it('parses dashed attribute names', function () {\n    const list = new AttrList('INT-VALUE=42,H-E-X=0x42,-FLOAT=0.42,STRING-=\"hi\",ENUM=OK');\n    expect(list.decimalInteger('INT-VALUE')).to.equal(42);\n    expect(list.hexadecimalIntegerAsNumber('H-E-X')).to.equal(0x42);\n    expect(list.decimalFloatingPoint('-FLOAT')).to.equal(0.42);\n    expect(list['STRING-']).to.equal('hi');\n    expect(list.enumeratedString('ENUM')).to.equal('OK');\n    expect(Object.keys(list).length).to.equal(5);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"handles hexadecimalInteger conversions","suites":["AttrList"],"updatePoint":{"line":119,"column":44,"index":6011},"line":119,"code":"  it('handles hexadecimalInteger conversions', function () {\n    const list = new AttrList('HEX1=0x0123456789abcdef0123456789abcdef,HEX2=0x123,HEX3=0x0');\n    expect(list.hexadecimalInteger('HEX1').buffer).to.deep.equal(new Uint8Array([0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]).buffer);\n    expect(list.hexadecimalInteger('HEX2').buffer).to.deep.equal(new Uint8Array([0x01, 0x23]).buffer);\n    expect(list.hexadecimalInteger('HEX3').buffer).to.deep.equal(new Uint8Array([0x0]).buffer);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"returns infinity on large number conversions","suites":["AttrList"],"updatePoint":{"line":125,"column":50,"index":6564},"line":125,"code":"  it('returns infinity on large number conversions', function () {\n    const list = new AttrList('VAL=12345678901234567890,HEX=0x0123456789abcdef0123456789abcdef');\n    expect(list.decimalInteger('VAL')).to.equal(Infinity);\n    expect(list.hexadecimalIntegerAsNumber('HEX')).to.equal(Infinity);\n  });","file":"unit/utils/attr-list.js","skipped":false,"dir":"tests"},{"name":"finds the element if it is present","suites":["binary search util","search helper"],"updatePoint":{"line":18,"column":42,"index":565},"line":18,"code":"    it('finds the element if it is present', function () {\n      for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        const foundItem = BinarySearch.search(list, buildComparisonFunction(item));\n        expect(foundItem).to.equal(item);\n      }\n    });","file":"unit/utils/binary-search.js","skipped":false,"dir":"tests"},{"name":"does not find the element if it is not present","suites":["binary search util","search helper"],"updatePoint":{"line":25,"column":54,"index":854},"line":25,"code":"    it('does not find the element if it is not present', function () {\n      const item = 1000;\n      const foundItem = BinarySearch.search(list, buildComparisonFunction(item));\n      expect(foundItem).to.not.exist;\n    });","file":"unit/utils/binary-search.js","skipped":false,"dir":"tests"},{"name":"should return true if some media.buffered includes the position","suites":["BufferHelper","isBuffered"],"updatePoint":{"line":24,"column":71,"index":724},"line":24,"code":"    it('should return true if some media.buffered includes the position', function () {\n      expect(BufferHelper.isBuffered(media, 0)).to.be.true;\n      expect(BufferHelper.isBuffered(media, 0.1)).to.be.true;\n      expect(BufferHelper.isBuffered(media, 0.5)).to.be.true;\n      expect(BufferHelper.isBuffered(media, 1)).to.be.true;\n      expect(BufferHelper.isBuffered(media, 2)).to.be.true;\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return false if any media.buffered does not includes the position","suites":["BufferHelper","isBuffered"],"updatePoint":{"line":31,"column":80,"index":1133},"line":31,"code":"    it('should return false if any media.buffered does not includes the position', function () {\n      expect(BufferHelper.isBuffered(media, -0.1)).to.be.false;\n      expect(BufferHelper.isBuffered(media, 0.51)).to.be.false;\n      expect(BufferHelper.isBuffered(media, 0.9)).to.be.false;\n      expect(BufferHelper.isBuffered(media, 2.1)).to.be.false;\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return false if media.buffered throws error","suites":["BufferHelper","isBuffered"],"updatePoint":{"line":37,"column":58,"index":1470},"line":37,"code":"    it('should return false if media.buffered throws error', function () {\n      const invalidMedia = {\n        get buffered() {\n          throw new Error('InvalidStateError');\n        }\n      };\n      expect(BufferHelper.isBuffered(invalidMedia, 0)).to.be.false;\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return false if media does not exist","suites":["BufferHelper","isBuffered"],"updatePoint":{"line":45,"column":51,"index":1735},"line":45,"code":"    it('should return false if media does not exist', function () {\n      expect(BufferHelper.isBuffered(null, 0)).to.be.false;\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return found buffer info if some media.buffered includes pos with allowed error","suites":["BufferHelper","bufferInfo"],"updatePoint":{"line":50,"column":94,"index":1959},"line":50,"code":"    it('should return found buffer info if some media.buffered includes pos with allowed error', function () {\n      // |////////|________|////////////////|\n      // 0       0.5       1                2\n      const media = {\n        get buffered() {\n          return createMockBuffer([{\n            startPTS: 0,\n            endPTS: 0.5\n          }, {\n            startPTS: 1,\n            endPTS: 2\n          }]);\n        }\n      };\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferInfo(media, 0, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 0,\n        end: 0.5,\n        nextStart: 1\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return empty buffer info if media does not exist","suites":["BufferHelper","bufferInfo"],"updatePoint":{"line":72,"column":63,"index":2567},"line":72,"code":"    it('should return empty buffer info if media does not exist', function () {\n      const invalidMedia = {\n        get buffered() {\n          throw new Error('InvalidStateError');\n        }\n      };\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferInfo(invalidMedia, 0, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 0,\n        end: 0,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return empty buffer info if media does not exist","suites":["BufferHelper","bufferInfo"],"updatePoint":{"line":86,"column":63,"index":2986},"line":86,"code":"    it('should return empty buffer info if media does not exist', function () {\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferInfo(null, 0, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 0,\n        end: 0,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return found buffer info when maxHoleDuration is 0","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":97,"column":65,"index":3325},"line":97,"code":"    it('should return found buffer info when maxHoleDuration is 0', function () {\n      // |////////|________|////////////////|\n      // 0       0.5       1                2\n      const buffered = [{\n        start: 0,\n        end: 0.5\n      }, {\n        start: 1,\n        end: 2\n      }];\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferedInfo(buffered, 0, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 0,\n        end: 0.5,\n        nextStart: 1\n      });\n      expect(BufferHelper.bufferedInfo(buffered, 0.5, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 0.5,\n        end: 0.5,\n        nextStart: 1\n      });\n      expect(BufferHelper.bufferedInfo(buffered, 1, maxHoleDuration)).to.deep.equal({\n        len: 1,\n        start: 1,\n        end: 2,\n        nextStart: undefined\n      });\n      expect(BufferHelper.bufferedInfo(buffered, 1.5, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 1,\n        end: 2,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return found buffer info when maxHoleDuration is 0.5","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":133,"column":67,"index":4355},"line":133,"code":"    it('should return found buffer info when maxHoleDuration is 0.5', function () {\n      // |////////|________|////////////////|\n      // 0       0.5       1                2\n      const buffered = [{\n        start: 0,\n        end: 0.5\n      }, {\n        start: 1,\n        end: 2\n      }];\n      const maxHoleDuration = 0.5;\n      expect(BufferHelper.bufferedInfo(buffered, 0, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 0,\n        end: 0.5,\n        nextStart: 1\n      });\n      // M: maxHoleDuration: 0.5\n      // |////////|________|////////////////|\n      // 0       0.5 - M - 1                2\n      expect(BufferHelper.bufferedInfo(buffered, 0.5, maxHoleDuration)).to.deep.equal({\n        len: 1.5,\n        start: 1,\n        end: 2,\n        nextStart: undefined\n      });\n      expect(BufferHelper.bufferedInfo(buffered, 1, maxHoleDuration)).to.deep.equal({\n        len: 1,\n        start: 1,\n        end: 2,\n        nextStart: undefined\n      });\n      expect(BufferHelper.bufferedInfo(buffered, 2, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 2,\n        end: 2,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should be able to handle unordered buffered","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":172,"column":51,"index":5498},"line":172,"code":"    it('should be able to handle unordered buffered', function () {\n      // |////////|________|////////////////|\n      // 0       0.5      1.0              2.0\n      const buffered = [{\n        start: 1,\n        end: 2\n      }, {\n        start: 0,\n        end: 0.5\n      }];\n      const maxHoleDuration = 0.5;\n      expect(BufferHelper.bufferedInfo(buffered, 0, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 0,\n        end: 0.5,\n        nextStart: 1\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should be able to merge adjacent time ranges with a small hole","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":190,"column":70,"index":6007},"line":190,"code":"    it('should be able to merge adjacent time ranges with a small hole', function () {\n      // |////////|________|////////////////|\n      // 0       0.5       1                2\n      const buffered = [{\n        start: 0,\n        end: 0.5\n      }, {\n        start: 1,\n        end: 2\n      }];\n      const maxHoleDuration = 1;\n      expect(BufferHelper.bufferedInfo(buffered, 0.8, maxHoleDuration)).to.deep.equal({\n        len: 1.2,\n        start: 0,\n        end: 2,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should be able to merge overlapping time ranges","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":208,"column":55,"index":6506},"line":208,"code":"    it('should be able to merge overlapping time ranges', function () {\n      // |////////|________|\n      // |////////|////////|\n      // 0       0.5       1\n      const buffered = [{\n        start: 0,\n        end: 0.5\n      }, {\n        start: 0,\n        end: 1\n      }];\n      const maxHoleDuration = 0.5;\n      expect(BufferHelper.bufferedInfo(buffered, 0.5, maxHoleDuration)).to.deep.equal({\n        len: 0.5,\n        start: 0,\n        end: 1,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return empty buffered if pos is out of range","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":227,"column":59,"index":7006},"line":227,"code":"    it('should return empty buffered if pos is out of range', function () {\n      const buffered = [{\n        start: 0,\n        end: 0.5\n      }, {\n        start: 0,\n        end: 1\n      }];\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferedInfo(buffered, 5, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 5,\n        end: 5,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return empty buffered if buffered is empty","suites":["BufferHelper","bufferedInfo"],"updatePoint":{"line":243,"column":57,"index":7411},"line":243,"code":"    it('should return empty buffered if buffered is empty', function () {\n      const buffered = [];\n      const maxHoleDuration = 0;\n      expect(BufferHelper.bufferedInfo(buffered, 5, maxHoleDuration)).to.deep.equal({\n        len: 0,\n        start: 5,\n        end: 5,\n        nextStart: undefined\n      });\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return buffered if no error is thrown","suites":["BufferHelper","getBuffered"],"updatePoint":{"line":255,"column":52,"index":7769},"line":255,"code":"    it('should return buffered if no error is thrown', function () {\n      const media = {\n        buffered: {\n          length: 10,\n          start() {},\n          end() {}\n        }\n      };\n      expect(BufferHelper.getBuffered(media)).to.eql(media.buffered);\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"should return return noop value if error is thrown","suites":["BufferHelper","getBuffered"],"updatePoint":{"line":265,"column":58,"index":8046},"line":265,"code":"    it('should return return noop value if error is thrown', function () {\n      const media = {\n        get buffered() {\n          throw new Error();\n        }\n      };\n      expect(BufferHelper.getBuffered(media).length).to.eql(0);\n    });","file":"unit/utils/buffer-helper.js","skipped":false,"dir":"tests"},{"name":"adjusts level fragments with overlapping CC range using a reference fragment","suites":["level-helper"],"updatePoint":{"line":29,"column":82,"index":614},"line":29,"code":"  it('adjusts level fragments with overlapping CC range using a reference fragment', function () {\n    const details = {\n      fragments: mockFrags.slice(0),\n      PTSKnown: false,\n      alignedSliding: false\n    };\n    const expected = [{\n      start: 20,\n      startPTS: 20,\n      endPTS: 24,\n      duration: 4,\n      cc: 0\n    }, {\n      start: 24,\n      startPTS: 24,\n      endPTS: 28,\n      duration: 4,\n      cc: 1\n    }, {\n      start: 28,\n      startPTS: 28,\n      endPTS: 36,\n      duration: 8,\n      cc: 1\n    }];\n    adjustSlidingStart(mockReferenceFrag.start, details);\n    expect(expected).to.deep.equal(details.fragments);\n    expect(details.alignedSliding).to.be.true;\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"aligns level fragments times based on PDT and start time of reference level details","suites":["level-helper"],"updatePoint":{"line":58,"column":89,"index":1311},"line":58,"code":"  it('aligns level fragments times based on PDT and start time of reference level details', function () {\n    const lastLevel = {\n      details: {\n        PTSKnown: false,\n        alignedSliding: false,\n        hasProgramDateTime: true,\n        fragments: [{\n          start: 18,\n          startPTS: undefined,\n          endPTS: undefined,\n          duration: 2,\n          programDateTime: 1629821766107\n        }, {\n          start: 20,\n          startPTS: undefined,\n          endPTS: 22,\n          duration: 2,\n          programDateTime: 1629821768107\n        }, {\n          start: 22,\n          startPTS: 22,\n          endPTS: 30,\n          duration: 8,\n          programDateTime: 1629821770107\n        }],\n        fragmentHint: {\n          start: 30,\n          startPTS: 30,\n          endPTS: 32,\n          duration: 2,\n          programDateTime: 1629821778107\n        }\n      }\n    };\n    const refDetails = {\n      fragments: [{\n        start: 18,\n        startPTS: undefined,\n        endPTS: undefined,\n        duration: 2,\n        programDateTime: 1629821768107\n      }],\n      PTSKnown: false,\n      alignedSliding: false,\n      hasProgramDateTime: true\n    };\n    const detailsExpected = {\n      fragments: [{\n        start: 16,\n        startPTS: 16,\n        endPTS: 18,\n        duration: 2,\n        programDateTime: 1629821766107\n      }, {\n        start: 18,\n        startPTS: 18,\n        endPTS: 20,\n        duration: 2,\n        programDateTime: 1629821768107\n      }, {\n        start: 20,\n        startPTS: 20,\n        endPTS: 28,\n        duration: 8,\n        programDateTime: 1629821770107\n      }],\n      fragmentHint: {\n        start: 28,\n        startPTS: 28,\n        endPTS: 30,\n        duration: 2,\n        programDateTime: 1629821778107\n      },\n      PTSKnown: false,\n      alignedSliding: true,\n      hasProgramDateTime: true\n    };\n    alignMediaPlaylistByPDT(lastLevel.details, refDetails);\n    expect(lastLevel.details, `actual:\\n\\n${JSON.stringify(lastLevel.details, null, 2)}\\n\\nexpected\\n\\n${JSON.stringify(detailsExpected, null, 2)}`).to.deep.equal(detailsExpected);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"adjusts level fragments without overlapping CC range but with programDateTime info","suites":["level-helper"],"updatePoint":{"line":138,"column":88,"index":3414},"line":138,"code":"  it('adjusts level fragments without overlapping CC range but with programDateTime info', function () {\n    const lastLevel = {\n      details: {\n        PTSKnown: true,\n        alignedSliding: false,\n        hasProgramDateTime: true,\n        fragments: [{\n          start: 20,\n          startPTS: 20,\n          endPTS: 24,\n          duration: 4,\n          cc: 0,\n          programDateTime: 1503892800000\n        }, {\n          start: 24,\n          startPTS: 24,\n          endPTS: 28,\n          duration: 4,\n          cc: 1\n        }, {\n          start: 28,\n          startPTS: 28,\n          endPTS: 36,\n          duration: 8,\n          cc: 1\n        }]\n      }\n    };\n    const details = {\n      fragments: [{\n        start: 0,\n        startPTS: 0,\n        endPTS: 4,\n        duration: 4,\n        cc: 2,\n        programDateTime: 1503892850000\n      }, {\n        start: 4,\n        startPTS: 4,\n        endPTS: 8,\n        duration: 4,\n        cc: 2\n      }, {\n        start: 8,\n        startPTS: 8,\n        endPTS: 16,\n        duration: 8,\n        cc: 3\n      }],\n      PTSKnown: false,\n      alignedSliding: false,\n      startCC: 2,\n      endCC: 3,\n      hasProgramDateTime: true\n    };\n    const detailsExpected = {\n      fragments: [{\n        start: 70,\n        startPTS: 70,\n        endPTS: 74,\n        duration: 4,\n        cc: 2,\n        programDateTime: 1503892850000\n      }, {\n        start: 74,\n        startPTS: 74,\n        endPTS: 78,\n        duration: 4,\n        cc: 2\n      }, {\n        start: 78,\n        startPTS: 78,\n        endPTS: 86,\n        duration: 8,\n        cc: 3\n      }],\n      PTSKnown: false,\n      alignedSliding: true,\n      startCC: 2,\n      endCC: 3,\n      hasProgramDateTime: true\n    };\n    alignPDT(details, lastLevel.details);\n    expect(detailsExpected).to.deep.equal(details);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"finds the first fragment in an array which matches the CC of the first fragment in another array","suites":["level-helper"],"updatePoint":{"line":223,"column":102,"index":5248},"line":223,"code":"  it('finds the first fragment in an array which matches the CC of the first fragment in another array', function () {\n    const prevDetails = {\n      fragments: [mockReferenceFrag, {\n        cc: 1\n      }]\n    };\n    const curDetails = {\n      fragments: mockFrags\n    };\n    const expected = mockReferenceFrag;\n    const actual = findDiscontinuousReferenceFrag(prevDetails, curDetails);\n    expect(actual).to.equal(expected);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"returns undefined if there are no frags in the previous level","suites":["level-helper"],"updatePoint":{"line":236,"column":67,"index":5647},"line":236,"code":"  it('returns undefined if there are no frags in the previous level', function () {\n    const expected = undefined;\n    const actual = findDiscontinuousReferenceFrag({\n      fragments: []\n    }, {\n      fragments: mockFrags\n    });\n    expect(actual).to.equal(expected);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"returns undefined if there are no matching frags in the previous level","suites":["level-helper"],"updatePoint":{"line":245,"column":76,"index":5933},"line":245,"code":"  it('returns undefined if there are no matching frags in the previous level', function () {\n    const expected = undefined;\n    const actual = findDiscontinuousReferenceFrag({\n      fragments: [{\n        cc: 10\n      }]\n    }, {\n      fragments: mockFrags\n    });\n    expect(actual).to.equal(expected);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"returns undefined if there are no frags in the current level","suites":["level-helper"],"updatePoint":{"line":256,"column":66,"index":6233},"line":256,"code":"  it('returns undefined if there are no frags in the current level', function () {\n    const expected = undefined;\n    const actual = findDiscontinuousReferenceFrag({\n      fragments: [{\n        cc: 0\n      }]\n    }, {\n      fragments: []\n    });\n    expect(actual).to.equal(expected);\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"should align current level when CC increases within the level","suites":["level-helper"],"updatePoint":{"line":267,"column":67,"index":6526},"line":267,"code":"  it('should align current level when CC increases within the level', function () {\n    const lastLevel = {\n      details: {}\n    };\n    const curDetails = {\n      startCC: 0,\n      endCC: 1\n    };\n    const actual = shouldAlignOnDiscontinuities(null, lastLevel, curDetails);\n    expect(actual).to.be.true;\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"should align current level when CC increases from last frag to current level","suites":["level-helper"],"updatePoint":{"line":278,"column":82,"index":6854},"line":278,"code":"  it('should align current level when CC increases from last frag to current level', function () {\n    const lastLevel = {\n      details: {}\n    };\n    const lastFrag = {\n      cc: 0\n    };\n    const curDetails = {\n      startCC: 1,\n      endCC: 1\n    };\n    const actual = shouldAlignOnDiscontinuities(lastFrag, lastLevel, curDetails);\n    expect(actual).to.be.true;\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"should not align when there is no CC increase","suites":["level-helper"],"updatePoint":{"line":292,"column":51,"index":7197},"line":292,"code":"  it('should not align when there is no CC increase', function () {\n    const lastLevel = {\n      details: {}\n    };\n    const curDetails = {\n      startCC: 1,\n      endCC: 1\n    };\n    const lastFrag = {\n      cc: 1\n    };\n    const actual = shouldAlignOnDiscontinuities(lastFrag, lastLevel, curDetails);\n    expect(actual).to.be.false;\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"should not align when there are no previous level details","suites":["level-helper"],"updatePoint":{"line":306,"column":63,"index":7553},"line":306,"code":"  it('should not align when there are no previous level details', function () {\n    const lastLevel = {};\n    const curDetails = {\n      startCC: 1,\n      endCC: 1\n    };\n    const lastFrag = {\n      cc: 1\n    };\n    const actual = shouldAlignOnDiscontinuities(lastFrag, lastLevel, curDetails);\n    expect(actual).to.be.false;\n  });","file":"unit/utils/discontinuities.js","skipped":false,"dir":"tests"},{"name":"should return 29 (0b 1110 1)","suites":["Exp-Golomb reader"],"updatePoint":{"line":6,"column":34,"index":548},"line":6,"code":"  it('should return 29 (0b 1110 1)', function () {\n    reader.skipBits(5);\n    expect(reader.readBits(5)).to.equal(0b11101);\n  });","file":"unit/utils/exp-golomb.ts","skipped":false,"dir":"tests"},{"name":"should return 7099 (0b 1101 1101 1101 1)","suites":["Exp-Golomb reader"],"updatePoint":{"line":10,"column":46,"index":691},"line":10,"code":"  it('should return 7099 (0b 1101 1101 1101 1)', function () {\n    reader.skipBits(6 + 56 + 4);\n    expect(reader.readBits(13)).to.equal(0b1101110111011);\n  });","file":"unit/utils/exp-golomb.ts","skipped":false,"dir":"tests"},{"name":"should return UINT_MAX(4294967295) twice","suites":["Exp-Golomb reader"],"updatePoint":{"line":14,"column":46,"index":852},"line":14,"code":"  it('should return UINT_MAX(4294967295) twice', function () {\n    reader.skipBits(39);\n    expect(reader.readBits(32)).to.equal(4294967295); //0b 11111111 11111111 11111111 11111111\n    expect(reader.readBits(32)).to.equal(4294967295); //0b 11111111 11111111 11111111 11111111\n  });","file":"unit/utils/exp-golomb.ts","skipped":false,"dir":"tests"},{"name":"should throw error if can no longer buffer be skip","suites":["Exp-Golomb reader"],"updatePoint":{"line":20,"column":56,"index":1147},"line":20,"code":"  it('should throw error if can no longer buffer be skip', function () {\n    expect(reader.readBits(4)).to.equal(0b1010);\n    expect(function () {\n      reader.skipBits(16);\n    }).to.throw('no bytes available');\n  });","file":"unit/utils/exp-golomb.ts","skipped":false,"dir":"tests"},{"name":"should throw error if can no longer buffer be read","suites":["Exp-Golomb reader"],"updatePoint":{"line":26,"column":56,"index":1366},"line":26,"code":"  it('should throw error if can no longer buffer be read', function () {\n    expect(function () {\n      reader.readBits(16);\n    }).to.throw('no bits available');\n  });","file":"unit/utils/exp-golomb.ts","skipped":false,"dir":"tests"},{"name":"handles new cue without dispatching","suites":["OutputFilter"],"updatePoint":{"line":15,"column":41,"index":522},"line":15,"code":"  it('handles new cue without dispatching', function () {\n    outputFilter.newCue(0, 1, {});\n    expect(timelineController.addCues).to.not.have.been.called;\n    expect(timelineController.createCaptionsTrack).to.have.been.called;\n  });","file":"unit/utils/output-filter.js","skipped":false,"dir":"tests"},{"name":"handles single cue and dispatch","suites":["OutputFilter"],"updatePoint":{"line":20,"column":37,"index":753},"line":20,"code":"  it('handles single cue and dispatch', function () {\n    const lastScreen = {};\n    outputFilter.newCue(0, 1, lastScreen);\n    outputFilter.dispatchCue();\n    expect(timelineController.addCues).to.have.been.calledOnce;\n    expect(timelineController.addCues).to.have.been.calledWith(1, 0, 1, lastScreen);\n  });","file":"unit/utils/output-filter.js","skipped":false,"dir":"tests"},{"name":"handles multiple cues and dispatch","suites":["OutputFilter"],"updatePoint":{"line":27,"column":40,"index":1067},"line":27,"code":"  it('handles multiple cues and dispatch', function () {\n    outputFilter.newCue(0, 1, {});\n    outputFilter.newCue(1, 2, {});\n    const lastScreen = {};\n    outputFilter.newCue(3, 4, lastScreen);\n    outputFilter.dispatchCue();\n    expect(timelineController.addCues).to.have.been.calledOnce;\n    expect(timelineController.addCues).to.have.been.calledWith(1, 0, 4, lastScreen);\n  });","file":"unit/utils/output-filter.js","skipped":false,"dir":"tests"},{"name":"does not dispatch empty cues","suites":["OutputFilter"],"updatePoint":{"line":36,"column":34,"index":1445},"line":36,"code":"  it('does not dispatch empty cues', function () {\n    outputFilter.newCue(0, 1, {});\n    expect(timelineController.addCues).to.not.have.been.called;\n    outputFilter.dispatchCue();\n    expect(timelineController.addCues).to.have.been.calledOnce;\n    outputFilter.dispatchCue();\n    expect(timelineController.addCues).to.have.been.calledOnce;\n  });","file":"unit/utils/output-filter.js","skipped":false,"dir":"tests"},{"name":"should have the provided track as data","suites":["text track utils","synthetic addtrack event"],"updatePoint":{"line":23,"column":46,"index":636},"line":23,"code":"    it('should have the provided track as data', function (done) {\n      const dispatchSpy = sinon.spy(video, 'dispatchEvent');\n      video.addEventListener('addtrack', function (e) {\n        expect(e.track).to.equal(track);\n        done();\n      });\n      sendAddTrackEvent(track, video);\n      expect(dispatchSpy.calledOnce).to.be.true;\n    });","file":"unit/utils/texttrack-utils.js","skipped":false,"dir":"tests"},{"name":"should fallback to document.createEvent if window.Event constructor throws","suites":["text track utils","synthetic addtrack event"],"updatePoint":{"line":32,"column":82,"index":1019},"line":32,"code":"    it('should fallback to document.createEvent if window.Event constructor throws', function (done) {\n      const stub = sinon.stub(self, 'Event');\n      stub.throws();\n      const spy = sinon.spy(document, 'createEvent');\n      video.addEventListener('addtrack', function (e) {\n        expect(e.track).to.equal(track);\n        done();\n      });\n      sendAddTrackEvent(track, video);\n      expect(spy.calledOnce).to.be.true;\n    });","file":"unit/utils/texttrack-utils.js","skipped":false,"dir":"tests"},{"name":"should not fail with empty cue list","suites":["text track utils","clear current cues"],"updatePoint":{"line":45,"column":43,"index":1468},"line":45,"code":"    it('should not fail with empty cue list', function () {\n      const emptyTrack = video.addTextTrack('subtitles', 'empty');\n      expect(clearCurrentCues(emptyTrack)).to.not.throw;\n    });","file":"unit/utils/texttrack-utils.js","skipped":false,"dir":"tests"},{"name":"should clear the cues from track","suites":["text track utils","clear current cues"],"updatePoint":{"line":49,"column":40,"index":1657},"line":49,"code":"    it('should clear the cues from track', function () {\n      clearCurrentCues(track);\n      expect(track.cues.length).to.equal(0);\n    });","file":"unit/utils/texttrack-utils.js","skipped":false,"dir":"tests"}]}