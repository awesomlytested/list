{"repo":"socketio/socket.io","url":"https://github.com/socketio/socket.io","branch":"master","configs":[{"package":"basic-crud-server","lang":"js","dir":"examples/basic-crud-application/server/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"socket.io","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should be able to close sio sending a srv","suites":["close"],"updatePoint":{"line":16,"column":47},"line":16,"code":"  it(\"should be able to close sio sending a srv\", (done) => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer);\n    const port = getPort(io);\n    const net = require(\"net\");\n    const server = net.createServer();\n\n    const clientSocket = createClient(io, \"/\", { reconnection: false });\n\n    clientSocket.on(\"disconnect\", () => {\n      expect(io.sockets.sockets.size).to.equal(0);\n      server.listen(port);\n    });\n\n    clientSocket.on(\"connect\", () => {\n      expect(io.sockets.sockets.size).to.equal(1);\n      io.close();\n    });\n\n    server.once(\"listening\", () => {\n      // PORT should be free\n      server.close((error) => {\n        expect(error).to.be(undefined);\n        done();\n      });\n    });\n  });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should be able to close sio sending a srv","suites":["close"],"updatePoint":{"line":44,"column":47},"line":44,"code":"  it(\"should be able to close sio sending a srv\", (done) => {\n    const io = new Server(0);\n    const port = getPort(io);\n    const net = require(\"net\");\n    const server = net.createServer();\n\n    const clientSocket = ioc(\"ws://0.0.0.0:\" + port, {\n      reconnection: false,\n    });\n\n    clientSocket.on(\"disconnect\", () => {\n      expect(io.sockets.sockets.size).to.equal(0);\n      server.listen(port);\n    });\n\n    clientSocket.on(\"connect\", () => {\n      expect(io.sockets.sockets.size).to.equal(1);\n      io.close();\n    });\n\n    server.once(\"listening\", () => {\n      // PORT should be free\n      server.close((error) => {\n        expect(error).to.be(undefined);\n        done();\n      });\n    });\n  });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should stop socket and timers","suites":["close","graceful close"],"updatePoint":{"line":84,"column":37},"line":84,"code":"    it(\"should stop socket and timers\", (done) => {\n      exec(fixture(\"server-close.ts\"), done);\n    });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should close the connection when receiving several CONNECT packets","suites":["close","protocol violations"],"updatePoint":{"line":90,"column":74},"line":90,"code":"    it(\"should close the connection when receiving several CONNECT packets\", async () => {\n      const httpServer = createServer();\n      const io = new Server(httpServer);\n\n      httpServer.listen(0);\n\n      const sid = await eioHandshake(httpServer);\n      // send a first CONNECT packet\n      await eioPush(httpServer, sid, \"40\");\n      // send another CONNECT packet\n      await eioPush(httpServer, sid, \"40\");\n      // session is cleanly closed (not discarded, see 'client.close()')\n      // first, we receive the Socket.IO handshake response\n      await eioPoll(httpServer, sid);\n      // then a close packet\n      const body = await eioPoll(httpServer, sid);\n      expect(body).to.be(\"6\\u001e1\");\n\n      io.close();\n    });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should close the connection when receiving an EVENT packet while not connected","suites":["close","protocol violations"],"updatePoint":{"line":111,"column":86},"line":111,"code":"    it(\"should close the connection when receiving an EVENT packet while not connected\", async () => {\n      const httpServer = createServer();\n      const io = new Server(httpServer);\n\n      httpServer.listen(0);\n\n      const sid = await eioHandshake(httpServer);\n      // send an EVENT packet\n      await eioPush(httpServer, sid, '42[\"some event\"]');\n      // session is cleanly closed, we receive a close packet\n      const body = await eioPoll(httpServer, sid);\n      expect(body).to.be(\"6\\u001e1\");\n\n      io.close();\n    });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should close the connection when receiving an invalid packet","suites":["close","protocol violations"],"updatePoint":{"line":127,"column":68},"line":127,"code":"    it(\"should close the connection when receiving an invalid packet\", async () => {\n      const httpServer = createServer();\n      const io = new Server(httpServer);\n\n      httpServer.listen(0);\n\n      const sid = await eioHandshake(httpServer);\n      // send a CONNECT packet\n      await eioPush(httpServer, sid, \"40\");\n      // send an invalid packet\n      await eioPush(httpServer, sid, \"4abc\");\n      // session is cleanly closed (not discarded, see 'client.close()')\n      // first, we receive the Socket.IO handshake response\n      await eioPoll(httpServer, sid);\n      // then a close packet\n      const body = await eioPoll(httpServer, sid);\n      expect(body).to.be(\"6\\u001e1\");\n\n      io.close();\n    });","file":"close.ts","skipped":false,"dir":"test"},{"name":"should restore session and missed packets","suites":["connection state recovery"],"updatePoint":{"line":39,"column":47},"line":39,"code":"  it(\"should restore session and missed packets\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer, {\n      connectionStateRecovery: {},\n    });\n\n    let serverSocket;\n\n    io.once(\"connection\", (socket) => {\n      socket.join(\"room1\");\n      serverSocket = socket;\n    });\n\n    const [sid, pid, offset] = await init(httpServer, io);\n\n    io.emit(\"hello1\"); // broadcast\n    io.to(\"room1\").emit(\"hello2\"); // broadcast to room\n    serverSocket.emit(\"hello3\"); // direct message\n\n    const newSid = await eioHandshake(httpServer);\n    await eioPush(\n      httpServer,\n      newSid,\n      `40{\"pid\":\"${pid}\",\"offset\":\"${offset}\"}`\n    );\n\n    const payload = await eioPoll(httpServer, newSid);\n    const packets = payload.split(\"\\x1e\");\n\n    expect(packets.length).to.eql(4);\n\n    // note: EVENT packets are received before the CONNECT packet, which is a bit weird\n    // see also: https://github.com/socketio/socket.io-deno/commit/518f534e1c205b746b1cb21fe76b187dabc96f34\n    expect(packets[0].startsWith('42[\"hello1\"')).to.be(true);\n    expect(packets[1].startsWith('42[\"hello2\"')).to.be(true);\n    expect(packets[2].startsWith('42[\"hello3\"')).to.be(true);\n    expect(packets[3]).to.eql(`40{\"sid\":\"${sid}\",\"pid\":\"${pid}\"}`);\n\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should restore rooms and data attributes","suites":["connection state recovery"],"updatePoint":{"line":80,"column":46},"line":80,"code":"  it(\"should restore rooms and data attributes\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer, {\n      connectionStateRecovery: {},\n    });\n\n    io.once(\"connection\", (socket) => {\n      expect(socket.recovered).to.eql(false);\n\n      socket.join(\"room1\");\n      socket.join(\"room2\");\n      socket.data.foo = \"bar\";\n    });\n\n    const [sid, pid, offset] = await init(httpServer, io);\n\n    const newSid = await eioHandshake(httpServer);\n\n    const [socket] = await Promise.all([\n      waitFor<Socket>(io, \"connection\"),\n      eioPush(httpServer, newSid, `40{\"pid\":\"${pid}\",\"offset\":\"${offset}\"}`),\n    ]);\n\n    expect(socket.id).to.eql(sid);\n    expect(socket.recovered).to.eql(true);\n\n    expect(socket.rooms.has(socket.id)).to.eql(true);\n    expect(socket.rooms.has(\"room1\")).to.eql(true);\n    expect(socket.rooms.has(\"room2\")).to.eql(true);\n\n    expect(socket.data.foo).to.eql(\"bar\");\n\n    await eioPoll(httpServer, newSid); // drain buffer\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should not run middlewares upon recovery by default","suites":["connection state recovery"],"updatePoint":{"line":116,"column":57},"line":116,"code":"  it(\"should not run middlewares upon recovery by default\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer, {\n      connectionStateRecovery: {},\n    });\n\n    const [_, pid, offset] = await init(httpServer, io);\n\n    io.use((socket, next) => {\n      socket.data.middlewareWasCalled = true;\n\n      next();\n    });\n\n    const newSid = await eioHandshake(httpServer);\n\n    const [socket] = await Promise.all([\n      waitFor<Socket>(io, \"connection\"),\n      eioPush(httpServer, newSid, `40{\"pid\":\"${pid}\",\"offset\":\"${offset}\"}`),\n    ]);\n\n    expect(socket.recovered).to.be(true);\n    expect(socket.data.middlewareWasCalled).to.be(undefined);\n\n    await eioPoll(httpServer, newSid); // drain buffer\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should run middlewares even upon recovery","suites":["connection state recovery"],"updatePoint":{"line":144,"column":47},"line":144,"code":"  it(\"should run middlewares even upon recovery\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer, {\n      connectionStateRecovery: {\n        skipMiddlewares: false,\n      },\n    });\n\n    const [_, pid, offset] = await init(httpServer, io);\n\n    io.use((socket, next) => {\n      socket.data.middlewareWasCalled = true;\n\n      next();\n    });\n\n    const newSid = await eioHandshake(httpServer);\n\n    const [socket] = await Promise.all([\n      waitFor<Socket>(io, \"connection\"),\n      eioPush(httpServer, newSid, `40{\"pid\":\"${pid}\",\"offset\":\"${offset}\"}`),\n    ]);\n\n    expect(socket.recovered).to.be(true);\n    expect(socket.data.middlewareWasCalled).to.be(true);\n\n    await eioPoll(httpServer, newSid); // drain buffer\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should fail to restore an unknown session","suites":["connection state recovery"],"updatePoint":{"line":174,"column":47},"line":174,"code":"  it(\"should fail to restore an unknown session\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer, {\n      connectionStateRecovery: {},\n    });\n\n    // Engine.IO handshake\n    const sid = await eioHandshake(httpServer);\n\n    // Socket.IO handshake\n    await eioPush(httpServer, sid, '40{\"pid\":\"foo\",\"offset\":\"bar\"}');\n\n    const handshakeBody = await eioPoll(httpServer, sid);\n\n    expect(handshakeBody.startsWith(\"40\")).to.be(true);\n\n    const handshake = JSON.parse(handshakeBody.substring(2));\n\n    expect(handshake.sid).to.not.eql(\"foo\");\n    expect(handshake.pid).to.not.eql(\"bar\");\n\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should be disabled by default","suites":["connection state recovery"],"updatePoint":{"line":198,"column":35},"line":198,"code":"  it(\"should be disabled by default\", async () => {\n    const httpServer = createServer().listen(0);\n    const io = new Server(httpServer);\n\n    // Engine.IO handshake\n    const sid = await eioHandshake(httpServer);\n\n    // Socket.IO handshake\n    await eioPush(httpServer, sid, \"40\");\n\n    const handshakeBody = await eioPoll(httpServer, sid);\n\n    expect(handshakeBody.startsWith(\"40\")).to.be(true);\n\n    const handshake = JSON.parse(handshakeBody.substring(2));\n\n    expect(handshake.sid).to.not.be(undefined);\n    expect(handshake.pid).to.be(undefined);\n\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should not call adapter#persistSession or adapter#restoreSession if disabled","suites":["connection state recovery"],"updatePoint":{"line":220,"column":82},"line":220,"code":"  it(\"should not call adapter#persistSession or adapter#restoreSession if disabled\", async () => {\n    const httpServer = createServer().listen(0);\n\n    class DummyAdapter extends Adapter {\n      override persistSession(session) {\n        expect.fail();\n      }\n\n      override restoreSession(pid, offset) {\n        expect.fail();\n        return Promise.reject(\"should not happen\");\n      }\n    }\n\n    const io = new Server(httpServer, {\n      adapter: DummyAdapter,\n    });\n\n    // Engine.IO handshake\n    const sid = await eioHandshake(httpServer);\n\n    await eioPush(httpServer, sid, '40{\"pid\":\"foo\",\"offset\":\"bar\"}');\n    await eioPoll(httpServer, sid);\n    await eioPush(httpServer, sid, \"1\");\n\n    io.close();\n  });","file":"connection-state-recovery.ts","skipped":false,"dir":"test"},{"name":"should send the Access-Control-Allow-xxx headers on OPTIONS request","suites":["handshake"],"updatePoint":{"line":8,"column":73},"line":8,"code":"  it(\"should send the Access-Control-Allow-xxx headers on OPTIONS request\", (done) => {\n    const io = new Server(0, {\n      cors: {\n        origin: \"http://localhost:54023\",\n        methods: [\"GET\", \"POST\"],\n        allowedHeaders: [\"content-type\"],\n        credentials: true,\n      },\n    });\n    request\n      .options(`http://localhost:${getPort(io)}/socket.io/default/`)\n      .query({ transport: \"polling\", EIO: 4 })\n      .set(\"Origin\", \"http://localhost:54023\")\n      .end((err, res) => {\n        expect(res.status).to.be(204);\n\n        expect(res.headers[\"access-control-allow-origin\"]).to.be(\n          \"http://localhost:54023\"\n        );\n        expect(res.headers[\"access-control-allow-methods\"]).to.be(\"GET,POST\");\n        expect(res.headers[\"access-control-allow-headers\"]).to.be(\n          \"content-type\"\n        );\n        expect(res.headers[\"access-control-allow-credentials\"]).to.be(\"true\");\n        success(done, io);\n      });\n  });","file":"handshake.ts","skipped":false,"dir":"test"},{"name":"should send the Access-Control-Allow-xxx headers on GET request","suites":["handshake"],"updatePoint":{"line":36,"column":69},"line":36,"code":"  it(\"should send the Access-Control-Allow-xxx headers on GET request\", (done) => {\n    const io = new Server(0, {\n      cors: {\n        origin: \"http://localhost:54024\",\n        methods: [\"GET\", \"POST\"],\n        allowedHeaders: [\"content-type\"],\n        credentials: true,\n      },\n    });\n    request\n      .get(`http://localhost:${getPort(io)}/socket.io/default/`)\n      .query({ transport: \"polling\", EIO: 4 })\n      .set(\"Origin\", \"http://localhost:54024\")\n      .end((err, res) => {\n        expect(res.status).to.be(200);\n\n        expect(res.headers[\"access-control-allow-origin\"]).to.be(\n          \"http://localhost:54024\"\n        );\n        expect(res.headers[\"access-control-allow-credentials\"]).to.be(\"true\");\n        success(done, io);\n      });\n  });","file":"handshake.ts","skipped":false,"dir":"test"},{"name":"should allow request if custom function in opts.allowRequest returns true","suites":["handshake"],"updatePoint":{"line":60,"column":79},"line":60,"code":"  it(\"should allow request if custom function in opts.allowRequest returns true\", (done) => {\n    const io = new Server(0, {\n      allowRequest: (req, callback) => callback(null, true),\n    });\n\n    request\n      .get(`http://localhost:${getPort(io)}/socket.io/default/`)\n      .query({ transport: \"polling\", EIO: 4 })\n      .end((err, res) => {\n        expect(res.status).to.be(200);\n        success(done, io);\n      });\n  });","file":"handshake.ts","skipped":false,"dir":"test"},{"name":"should disallow request if custom function in opts.allowRequest returns false","suites":["handshake"],"updatePoint":{"line":74,"column":83},"line":74,"code":"  it(\"should disallow request if custom function in opts.allowRequest returns false\", (done) => {\n    const io = new Server(0, {\n      allowRequest: (req, callback) => callback(null, false),\n    });\n    request\n      .get(`http://localhost:${getPort(io)}/socket.io/default/`)\n      .set(\"origin\", \"http://foo.example\")\n      .query({ transport: \"polling\", EIO: 4 })\n      .end((err, res) => {\n        expect(res.status).to.be(403);\n        success(done, io);\n      });\n  });","file":"handshake.ts","skipped":false,"dir":"test"},{"name":"should be the same version as client","suites":["socket.io"],"updatePoint":{"line":6,"column":42},"line":6,"code":"  it(\"should be the same version as client\", () => {\n    const version = require(\"../package\").version;\n    expect(version).to.be(require(\"socket.io-client/package.json\").version);\n  });","file":"index.ts","skipped":false,"dir":"test"},{"name":"emits to a namespace","suites":["messaging many"],"updatePoint":{"line":12,"column":26},"line":12,"code":"  it(\"emits to a namespace\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/test\");\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2, socket3)\n    );\n\n    socket1.on(\"a\", (a) => {\n      expect(a).to.be(\"b\");\n      partialDone();\n    });\n    socket2.on(\"a\", (a) => {\n      expect(a).to.be(\"b\");\n      partialDone();\n    });\n    socket3.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n\n    let sockets = 3;\n    io.on(\"connection\", () => {\n      --sockets || emit();\n    });\n    io.of(\"/test\", () => {\n      --sockets || emit();\n    });\n\n    function emit() {\n      io.emit(\"a\", \"b\");\n    }\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"emits binary data to a namespace","suites":["messaging many"],"updatePoint":{"line":48,"column":38},"line":48,"code":"  it(\"emits binary data to a namespace\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/test\");\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2, socket3)\n    );\n\n    socket1.on(\"bin\", (a) => {\n      expect(Buffer.isBuffer(a)).to.be(true);\n      partialDone();\n    });\n    socket2.on(\"bin\", (a) => {\n      expect(Buffer.isBuffer(a)).to.be(true);\n      partialDone();\n    });\n    socket3.on(\"bin\", () => {\n      done(new Error(\"not\"));\n    });\n\n    let sockets = 3;\n    io.on(\"connection\", () => {\n      --sockets || emit();\n    });\n    io.of(\"/test\", () => {\n      --sockets || emit();\n    });\n\n    function emit() {\n      io.emit(\"bin\", Buffer.alloc(10));\n    }\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"emits to the rest","suites":["messaging many"],"updatePoint":{"line":84,"column":23},"line":84,"code":"  it(\"emits to the rest\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/test\");\n\n    socket1.on(\"a\", (a) => {\n      expect(a).to.be(\"b\");\n      socket1.emit(\"finish\");\n    });\n    socket2.emit(\"broadcast\");\n    socket2.on(\"a\", () => {\n      done(new Error(\"done\"));\n    });\n    socket3.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"broadcast\", () => {\n        socket.broadcast.emit(\"a\", \"b\");\n      });\n      socket.on(\"finish\", () => {\n        success(done, io, socket1, socket2, socket3);\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"emits to rooms","suites":["messaging many"],"updatePoint":{"line":112,"column":20},"line":112,"code":"  it(\"emits to rooms\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket1.on(\"a\", () => {\n      success(done, io, socket1, socket2);\n    });\n    socket1.emit(\"join\", \"woot\");\n    socket1.emit(\"emit\", \"woot\");\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"join\", (room, fn) => {\n        socket.join(room);\n        fn && fn();\n      });\n\n      socket.on(\"emit\", (room) => {\n        io.in(room).emit(\"a\");\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"emits to rooms avoiding dupes","suites":["messaging many"],"updatePoint":{"line":138,"column":35},"line":138,"code":"  it(\"emits to rooms avoiding dupes\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2)\n    );\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket1.on(\"a\", partialDone);\n    socket2.on(\"b\", partialDone);\n\n    socket1.emit(\"join\", \"woot\");\n    socket1.emit(\"join\", \"test\");\n    socket2.emit(\"join\", \"third\", () => {\n      socket2.emit(\"emit\");\n    });\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"join\", (room, fn) => {\n        socket.join(room);\n        fn && fn();\n      });\n\n      socket.on(\"emit\", () => {\n        io.in(\"woot\").in(\"test\").emit(\"a\");\n        io.in(\"third\").emit(\"b\");\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"broadcasts to rooms","suites":["messaging many"],"updatePoint":{"line":173,"column":25},"line":173,"code":"  it(\"broadcasts to rooms\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2, socket3)\n    );\n\n    socket1.emit(\"join\", \"woot\");\n    socket2.emit(\"join\", \"test\");\n    socket3.emit(\"join\", \"test\", () => {\n      socket3.emit(\"broadcast\");\n    });\n\n    socket1.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket2.on(\"a\", () => {\n      partialDone();\n    });\n    socket3.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket3.on(\"b\", () => {\n      partialDone();\n    });\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"join\", (room, fn) => {\n        socket.join(room);\n        fn && fn();\n      });\n\n      socket.on(\"broadcast\", () => {\n        socket.broadcast.to(\"test\").emit(\"a\");\n        socket.emit(\"b\");\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"broadcasts binary data to rooms","suites":["messaging many"],"updatePoint":{"line":216,"column":37},"line":216,"code":"  it(\"broadcasts binary data to rooms\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2, socket3)\n    );\n\n    socket1.emit(\"join\", \"woot\");\n    socket2.emit(\"join\", \"test\");\n    socket3.emit(\"join\", \"test\", () => {\n      socket3.emit(\"broadcast\");\n    });\n\n    socket1.on(\"bin\", (data) => {\n      throw new Error(\"got bin in socket1\");\n    });\n    socket2.on(\"bin\", (data) => {\n      expect(Buffer.isBuffer(data)).to.be(true);\n      partialDone();\n    });\n    socket2.on(\"bin2\", (data) => {\n      throw new Error(\"socket2 got bin2\");\n    });\n    socket3.on(\"bin\", (data) => {\n      throw new Error(\"socket3 got bin\");\n    });\n    socket3.on(\"bin2\", (data) => {\n      expect(Buffer.isBuffer(data)).to.be(true);\n      partialDone();\n    });\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"join\", (room, fn) => {\n        socket.join(room);\n        fn && fn();\n      });\n      socket.on(\"broadcast\", () => {\n        socket.broadcast.to(\"test\").emit(\"bin\", Buffer.alloc(5));\n        socket.emit(\"bin2\", Buffer.alloc(5));\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"keeps track of rooms","suites":["messaging many"],"updatePoint":{"line":263,"column":26},"line":263,"code":"  it(\"keeps track of rooms\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.join(\"a\");\n      expect(s.rooms).to.contain(s.id, \"a\");\n      s.join(\"b\");\n      expect(s.rooms).to.contain(s.id, \"a\", \"b\");\n      s.join(\"c\");\n      expect(s.rooms).to.contain(s.id, \"a\", \"b\", \"c\");\n      s.leave(\"b\");\n      expect(s.rooms).to.contain(s.id, \"a\", \"c\");\n      (s as any).leaveAll();\n      expect(s.rooms.size).to.eql(0);\n\n      success(done, io, socket);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"deletes empty rooms","suites":["messaging many"],"updatePoint":{"line":283,"column":25},"line":283,"code":"  it(\"deletes empty rooms\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.join(\"a\");\n      expect(s.nsp.adapter.rooms).to.contain(\"a\");\n      s.leave(\"a\");\n      expect(s.nsp.adapter.rooms).to.not.contain(\"a\");\n\n      success(done, io, socket);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should properly cleanup left rooms","suites":["messaging many"],"updatePoint":{"line":297,"column":40},"line":297,"code":"  it(\"should properly cleanup left rooms\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.join(\"a\");\n      expect(s.rooms).to.contain(s.id, \"a\");\n      s.join(\"b\");\n      expect(s.rooms).to.contain(s.id, \"a\", \"b\");\n      s.leave(\"unknown\");\n      expect(s.rooms).to.contain(s.id, \"a\", \"b\");\n      (s as any).leaveAll();\n      expect(s.rooms.size).to.eql(0);\n\n      success(done, io, socket);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"allows to join several rooms at once","suites":["messaging many"],"updatePoint":{"line":315,"column":42},"line":315,"code":"  it(\"allows to join several rooms at once\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.join([\"a\", \"b\", \"c\"]);\n      expect(s.rooms).to.contain(s.id, \"a\", \"b\", \"c\");\n      success(done, io, socket);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should exclude specific sockets when broadcasting","suites":["messaging many"],"updatePoint":{"line":326,"column":55},"line":326,"code":"  it(\"should exclude specific sockets when broadcasting\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket3.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket1.on(\"a\", successFn(done, io, socket1, socket2, socket3));\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"exclude\", (id) => {\n        socket.broadcast.except(id).emit(\"a\");\n      });\n    });\n\n    socket2.on(\"connect\", () => {\n      socket3.emit(\"exclude\", socket2.id);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should exclude a specific room when broadcasting","suites":["messaging many"],"updatePoint":{"line":351,"column":54},"line":351,"code":"  it(\"should exclude a specific room when broadcasting\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket3.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket1.on(\"a\", successFn(done, io, socket1, socket2, socket3));\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"join\", (room, cb) => {\n        socket.join(room);\n        cb();\n      });\n      socket.on(\"broadcast\", () => {\n        socket.broadcast.except(\"room1\").emit(\"a\");\n      });\n    });\n\n    socket2.emit(\"join\", \"room1\", () => {\n      socket3.emit(\"broadcast\");\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should return an immutable broadcast operator","suites":["messaging many"],"updatePoint":{"line":380,"column":51},"line":380,"code":"  it(\"should return an immutable broadcast operator\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io);\n\n    io.on(\"connection\", (socket) => {\n      const operator = socket.local\n        .compress(false)\n        .to([\"room1\", \"room2\"])\n        .except(\"room3\");\n      operator.compress(true).emit(\"hello\");\n      operator.volatile.emit(\"hello\");\n      operator.to(\"room4\").emit(\"hello\");\n      operator.except(\"room5\").emit(\"hello\");\n      socket.emit(\"hello\");\n      socket.to(\"room6\").emit(\"hello\");\n      // @ts-ignore\n      expect(operator.rooms).to.contain(\"room1\", \"room2\");\n      // @ts-ignore\n      expect(operator.rooms).to.not.contain(\"room4\", \"room5\", \"room6\");\n      // @ts-ignore\n      expect(operator.exceptRooms).to.contain(\"room3\");\n      // @ts-ignore\n      expect(operator.flags).to.eql({ local: true, compress: false });\n\n      success(done, io, clientSocket);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should broadcast and expect multiple acknowledgements","suites":["messaging many"],"updatePoint":{"line":408,"column":59},"line":408,"code":"  it(\"should broadcast and expect multiple acknowledgements\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket1.on(\"some event\", (cb) => {\n      cb(1);\n    });\n\n    socket2.on(\"some event\", (cb) => {\n      cb(2);\n    });\n\n    socket3.on(\"some event\", (cb) => {\n      cb(3);\n    });\n\n    Promise.all([\n      waitFor(socket1, \"connect\"),\n      waitFor(socket2, \"connect\"),\n      waitFor(socket3, \"connect\"),\n    ]).then(() => {\n      io.timeout(2000).emit(\"some event\", (err, responses) => {\n        expect(err).to.be(null);\n        expect(responses).to.have.length(3);\n        expect(responses).to.contain(1, 2, 3);\n\n        success(done, io, socket1, socket2, socket3);\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should fail when a client does not acknowledge the event in the given delay","suites":["messaging many"],"updatePoint":{"line":441,"column":81},"line":441,"code":"  it(\"should fail when a client does not acknowledge the event in the given delay\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket1.on(\"some event\", (cb) => {\n      cb(1);\n    });\n\n    socket2.on(\"some event\", (cb) => {\n      cb(2);\n    });\n\n    socket3.on(\"some event\", () => {\n      // timeout\n    });\n\n    Promise.all([\n      waitFor(socket1, \"connect\"),\n      waitFor(socket2, \"connect\"),\n      waitFor(socket3, \"connect\"),\n    ]).then(() => {\n      io.timeout(200).emit(\"some event\", (err, responses) => {\n        expect(err).to.be.an(Error);\n        expect(responses).to.have.length(2);\n        expect(responses).to.contain(1, 2);\n\n        success(done, io, socket1, socket2, socket3);\n      });\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should broadcast and expect multiple acknowledgements (promise)","suites":["messaging many"],"updatePoint":{"line":474,"column":69},"line":474,"code":"  it(\"should broadcast and expect multiple acknowledgements (promise)\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket1.on(\"some event\", (cb) => {\n      cb(1);\n    });\n\n    socket2.on(\"some event\", (cb) => {\n      cb(2);\n    });\n\n    socket3.on(\"some event\", (cb) => {\n      cb(3);\n    });\n\n    Promise.all([\n      waitFor(socket1, \"connect\"),\n      waitFor(socket2, \"connect\"),\n      waitFor(socket3, \"connect\"),\n    ]).then(async () => {\n      const responses = await io.timeout(2000).emitWithAck(\"some event\");\n      expect(responses).to.contain(1, 2, 3);\n\n      success(done, io, socket1, socket2, socket3);\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should fail when a client does not acknowledge the event in the given delay (promise)","suites":["messaging many"],"updatePoint":{"line":504,"column":91},"line":504,"code":"  it(\"should fail when a client does not acknowledge the event in the given delay (promise)\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket1.on(\"some event\", (cb) => {\n      cb(1);\n    });\n\n    socket2.on(\"some event\", (cb) => {\n      cb(2);\n    });\n\n    socket3.on(\"some event\", () => {\n      // timeout\n    });\n\n    Promise.all([\n      waitFor(socket1, \"connect\"),\n      waitFor(socket2, \"connect\"),\n      waitFor(socket3, \"connect\"),\n    ]).then(async () => {\n      try {\n        await io.timeout(200).emitWithAck(\"some event\");\n        expect.fail();\n      } catch (err) {\n        expect(err).to.be.an(Error);\n        // @ts-ignore\n        expect(err.responses).to.have.length(2);\n        // @ts-ignore\n        expect(err.responses).to.contain(1, 2);\n\n        success(done, io, socket1, socket2, socket3);\n      }\n    });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should broadcast and return if the packet is sent to 0 client","suites":["messaging many"],"updatePoint":{"line":542,"column":67},"line":542,"code":"  it(\"should broadcast and return if the packet is sent to 0 client\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\", { multiplex: false });\n    const socket2 = createClient(io, \"/\", { multiplex: false });\n    const socket3 = createClient(io, \"/\", { multiplex: false });\n\n    socket1.on(\"some event\", () => {\n      done(new Error(\"should not happen\"));\n    });\n\n    socket2.on(\"some event\", () => {\n      done(new Error(\"should not happen\"));\n    });\n\n    socket3.on(\"some event\", () => {\n      done(new Error(\"should not happen\"));\n    });\n\n    io.to(\"room123\")\n      .timeout(200)\n      .emit(\"some event\", (err, responses) => {\n        expect(err).to.be(null);\n        expect(responses).to.have.length(0);\n\n        success(done, io, socket1, socket2, socket3);\n      });\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should precompute the WebSocket frame when broadcasting","suites":["messaging many"],"updatePoint":{"line":570,"column":61},"line":570,"code":"  it(\"should precompute the WebSocket frame when broadcasting\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/chat\", {\n      transports: [\"websocket\"],\n    });\n    const partialDone = createPartialDone(2, successFn(done, io, socket));\n\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      s.conn.once(\"packetCreate\", (packet) => {\n        expect(packet.options.wsPreEncodedFrame).to.be.an(Array);\n        partialDone();\n      });\n      io.of(\"/chat\").compress(false).emit(\"woot\", \"hi\");\n    });\n\n    socket.on(\"woot\", partialDone);\n  });","file":"messaging-many.ts","skipped":false,"dir":"test"},{"name":"should call functions","suites":["middleware"],"updatePoint":{"line":11,"column":27},"line":11,"code":"  it(\"should call functions\", (done) => {\n    const io = new Server(0);\n\n    let run = 0;\n    io.use((socket, next) => {\n      expect(socket).to.be.a(Socket);\n      run++;\n      next();\n    });\n    io.use((socket, next) => {\n      expect(socket).to.be.a(Socket);\n      run++;\n      next();\n    });\n\n    const socket = createClient(io);\n    socket.on(\"connect\", () => {\n      expect(run).to.be(2);\n\n      success(done, io, socket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should pass errors","suites":["middleware"],"updatePoint":{"line":34,"column":24},"line":34,"code":"  it(\"should pass errors\", (done) => {\n    const io = new Server(0);\n\n    io.use((socket, next) => {\n      next(new Error(\"Authentication error\"));\n    });\n    io.use((socket, next) => {\n      done(new Error(\"nope\"));\n    });\n\n    const socket = createClient(io);\n    socket.on(\"connect\", () => {\n      done(new Error(\"nope\"));\n    });\n    socket.on(\"connect_error\", (err) => {\n      expect(err.message).to.be(\"Authentication error\");\n\n      success(done, io, socket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should pass an object","suites":["middleware"],"updatePoint":{"line":55,"column":27},"line":55,"code":"  it(\"should pass an object\", (done) => {\n    const io = new Server(0);\n\n    io.use((socket, next) => {\n      const err = new Error(\"Authentication error\");\n      // @ts-ignore\n      err.data = { a: \"b\", c: 3 };\n      next(err);\n    });\n\n    const socket = createClient(io);\n    socket.on(\"connect\", () => {\n      done(new Error(\"nope\"));\n    });\n    socket.on(\"connect_error\", (err) => {\n      expect(err).to.be.an(Error);\n      expect(err.message).to.eql(\"Authentication error\");\n      // @ts-ignore\n      expect(err.data).to.eql({ a: \"b\", c: 3 });\n\n      success(done, io, socket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should only call connection after fns","suites":["middleware"],"updatePoint":{"line":79,"column":43},"line":79,"code":"  it(\"should only call connection after fns\", (done) => {\n    const io = new Server(0);\n\n    io.use((socket: any, next) => {\n      socket.name = \"guillermo\";\n      next();\n    });\n\n    const clientSocket = createClient(io);\n    io.on(\"connection\", (socket) => {\n      expect((socket as any).name).to.be(\"guillermo\");\n\n      success(done, io, clientSocket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should only call connection after (lengthy) fns","suites":["middleware"],"updatePoint":{"line":95,"column":53},"line":95,"code":"  it(\"should only call connection after (lengthy) fns\", (done) => {\n    const io = new Server(0);\n\n    let authenticated = false;\n\n    io.use((socket, next) => {\n      setTimeout(() => {\n        authenticated = true;\n        next();\n      }, 300);\n    });\n\n    const socket = createClient(io);\n    socket.on(\"connect\", () => {\n      expect(authenticated).to.be(true);\n\n      success(done, io, socket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should be ignored if socket gets closed","suites":["middleware"],"updatePoint":{"line":115,"column":45},"line":115,"code":"  it(\"should be ignored if socket gets closed\", (done) => {\n    const io = new Server(0);\n\n    let socket;\n    io.use((s, next) => {\n      socket.io.engine.close();\n      s.client.conn.on(\"close\", () => {\n        process.nextTick(next);\n        setTimeout(() => {\n          success(done, io, socket);\n        }, 50);\n      });\n    });\n\n    socket = createClient(io);\n    io.on(\"connection\", (socket) => {\n      done(new Error(\"should not fire\"));\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should call functions in expected order","suites":["middleware"],"updatePoint":{"line":135,"column":45},"line":135,"code":"  it(\"should call functions in expected order\", (done) => {\n    const io = new Server(0);\n\n    const result: number[] = [];\n\n    io.use(() => {\n      done(new Error(\"should not fire\"));\n    });\n    io.of(\"/chat\").use((socket, next) => {\n      result.push(1);\n      setTimeout(next, 50);\n    });\n    io.of(\"/chat\").use((socket, next) => {\n      result.push(2);\n      setTimeout(next, 50);\n    });\n    io.of(\"/chat\").use((socket, next) => {\n      result.push(3);\n      setTimeout(next, 50);\n    });\n\n    const chat = createClient(io, \"/chat\");\n    chat.on(\"connect\", () => {\n      expect(result).to.eql([1, 2, 3]);\n\n      success(done, io, chat);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should disable the merge of handshake packets","suites":["middleware"],"updatePoint":{"line":164,"column":51},"line":164,"code":"  it(\"should disable the merge of handshake packets\", (done) => {\n    const io = new Server(0);\n\n    io.use((socket, next) => {\n      next();\n    });\n\n    const socket = createClient(io);\n    socket.on(\"connect\", successFn(done, io, socket));\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should work with a custom namespace","suites":["middleware"],"updatePoint":{"line":175,"column":41},"line":175,"code":"  it(\"should work with a custom namespace\", (done) => {\n    const io = new Server(0);\n    const socket1 = createClient(io, \"/\");\n    const socket2 = createClient(io, \"/chat\");\n\n    const partialDone = createPartialDone(\n      2,\n      successFn(done, io, socket1, socket2)\n    );\n\n    io.of(\"/chat\").use((socket, next) => {\n      next();\n    });\n\n    socket1.on(\"connect\", partialDone);\n    socket2.on(\"connect\", partialDone);\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should only set `connected` to true after the middleware execution","suites":["middleware"],"updatePoint":{"line":193,"column":72},"line":193,"code":"  it(\"should only set `connected` to true after the middleware execution\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io, \"/\");\n\n    io.use((socket, next) => {\n      expect(socket.connected).to.be(false);\n      expect(socket.disconnected).to.be(true);\n      next();\n    });\n\n    io.on(\"connection\", (socket) => {\n      expect(socket.connected).to.be(true);\n      expect(socket.disconnected).to.be(false);\n\n      success(done, io, clientSocket);\n    });\n  });","file":"middleware.ts","skipped":false,"dir":"test"},{"name":"should be accessible through .sockets","suites":["namespaces"],"updatePoint":{"line":12,"column":43},"line":12,"code":"  it(\"should be accessible through .sockets\", () => {\n    const io = new Server();\n    expect(io.sockets).to.be.a(Namespace);\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should be aliased","suites":["namespaces"],"updatePoint":{"line":17,"column":23},"line":17,"code":"  it(\"should be aliased\", () => {\n    const io = new Server();\n    expect(io.use).to.be.a(\"function\");\n    expect(io.to).to.be.a(\"function\");\n    expect(io[\"in\"]).to.be.a(\"function\");\n    expect(io.emit).to.be.a(\"function\");\n    expect(io.send).to.be.a(\"function\");\n    expect(io.write).to.be.a(\"function\");\n    expect(io.allSockets).to.be.a(\"function\");\n    expect(io.compress).to.be.a(\"function\");\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should return an immutable broadcast operator","suites":["namespaces"],"updatePoint":{"line":29,"column":51},"line":29,"code":"  it(\"should return an immutable broadcast operator\", () => {\n    const io = new Server();\n    const operator = io.local.to([\"room1\", \"room2\"]).except(\"room3\");\n    operator.compress(true).emit(\"hello\");\n    operator.volatile.emit(\"hello\");\n    operator.to(\"room4\").emit(\"hello\");\n    operator.except(\"room5\").emit(\"hello\");\n    io.to(\"room6\").emit(\"hello\");\n    // @ts-ignore\n    expect(operator.rooms).to.contain(\"room1\", \"room2\");\n    // @ts-ignore\n    expect(operator.exceptRooms).to.contain(\"room3\");\n    // @ts-ignore\n    expect(operator.flags).to.eql({ local: true });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should automatically connect","suites":["namespaces"],"updatePoint":{"line":45,"column":34},"line":45,"code":"  it(\"should automatically connect\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n    socket.on(\"connect\", successFn(done, io, socket));\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should fire a `connection` event","suites":["namespaces"],"updatePoint":{"line":51,"column":38},"line":51,"code":"  it(\"should fire a `connection` event\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io);\n\n    io.on(\"connection\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      success(done, io, clientSocket);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should fire a `connect` event","suites":["namespaces"],"updatePoint":{"line":61,"column":35},"line":61,"code":"  it(\"should fire a `connect` event\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io);\n\n    io.on(\"connect\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      success(done, io, clientSocket);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should work with many sockets","suites":["namespaces"],"updatePoint":{"line":71,"column":35},"line":71,"code":"  it(\"should work with many sockets\", (done) => {\n    const io = new Server(0);\n    io.of(\"/chat\");\n    io.of(\"/news\");\n    const chat = createClient(io, \"/chat\");\n    const news = createClient(io, \"/news\");\n\n    let total = 2;\n    chat.on(\"connect\", () => {\n      --total || success(done, io, chat, news);\n    });\n    news.on(\"connect\", () => {\n      --total || success(done, io, chat, news);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should be able to equivalently start with \"\" or \"/\" on server","suites":["namespaces"],"updatePoint":{"line":87,"column":67},"line":87,"code":"  it('should be able to equivalently start with \"\" or \"/\" on server', (done) => {\n    const io = new Server(0);\n    const c1 = createClient(io, \"/\");\n    const c2 = createClient(io, \"/abc\");\n\n    let total = 2;\n    io.of(\"\").on(\"connection\", () => {\n      --total || success(done, io, c1, c2);\n    });\n    io.of(\"abc\").on(\"connection\", () => {\n      --total || success(done, io, c1, c2);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should be equivalent for \"\" and \"/\" on client","suites":["namespaces"],"updatePoint":{"line":101,"column":51},"line":101,"code":"  it('should be equivalent for \"\" and \"/\" on client', (done) => {\n    const io = new Server(0);\n    const c1 = createClient(io, \"\");\n\n    io.of(\"/\").on(\"connection\", successFn(done, io, c1));\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should work with `of` and many sockets","suites":["namespaces"],"updatePoint":{"line":108,"column":44},"line":108,"code":"  it(\"should work with `of` and many sockets\", (done) => {\n    const io = new Server(0);\n    const chat = createClient(io, \"/chat\");\n    const news = createClient(io, \"/news\");\n\n    let total = 2;\n    io.of(\"/news\").on(\"connection\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      --total || success(done, io, chat, news);\n    });\n    io.of(\"/news\").on(\"connection\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      --total || success(done, io, chat, news);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should work with `of` second param","suites":["namespaces"],"updatePoint":{"line":124,"column":40},"line":124,"code":"  it(\"should work with `of` second param\", (done) => {\n    const io = new Server(0);\n    const chat = createClient(io, \"/chat\");\n    const news = createClient(io, \"/news\");\n\n    let total = 2;\n    io.of(\"/news\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      --total || success(done, io, chat, news);\n    });\n    io.of(\"/news\", (socket) => {\n      expect(socket).to.be.a(Socket);\n      --total || success(done, io, chat, news);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should disconnect upon transport disconnection","suites":["namespaces"],"updatePoint":{"line":140,"column":52},"line":140,"code":"  it(\"should disconnect upon transport disconnection\", (done) => {\n    const io = new Server(0);\n    const chat = createClient(io, \"/chat\");\n    const news = createClient(io, \"/news\");\n\n    let total = 2;\n    let totald = 2;\n    let s;\n    io.of(\"/news\", (socket) => {\n      socket.on(\"disconnect\", (reason) => {\n        --totald || success(done, io, chat, news);\n      });\n      --total || close();\n    });\n    io.of(\"/chat\", (socket) => {\n      s = socket;\n      socket.on(\"disconnect\", (reason) => {\n        --totald || success(done, io, chat, news);\n      });\n      --total || close();\n    });\n    function close() {\n      s.disconnect(true);\n    }\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should fire a `disconnecting` event just before leaving all rooms","suites":["namespaces"],"updatePoint":{"line":166,"column":71},"line":166,"code":"  it(\"should fire a `disconnecting` event just before leaving all rooms\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.join(\"a\");\n      // FIXME not sure why process.nextTick() is needed here\n      process.nextTick(() => s.disconnect());\n\n      let total = 2;\n      s.on(\"disconnecting\", (reason) => {\n        expect(s.rooms).to.contain(s.id, \"a\");\n        total--;\n      });\n\n      s.on(\"disconnect\", (reason) => {\n        expect(s.rooms.size).to.eql(0);\n        --total || success(done, io, socket);\n      });\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should return error connecting to non-existent namespace","suites":["namespaces"],"updatePoint":{"line":188,"column":62},"line":188,"code":"  it(\"should return error connecting to non-existent namespace\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/doesnotexist\");\n\n    socket.on(\"connect_error\", (err) => {\n      expect(err.message).to.be(\"Invalid namespace\");\n      success(done, io);\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should not reuse same-namespace connections","suites":["namespaces"],"updatePoint":{"line":198,"column":49},"line":198,"code":"  it(\"should not reuse same-namespace connections\", (done) => {\n    const io = new Server(0);\n    const clientSocket1 = createClient(io);\n    const clientSocket2 = createClient(io);\n\n    let connections = 0;\n    io.on(\"connection\", () => {\n      connections++;\n      if (connections === 2) {\n        success(done, io, clientSocket1, clientSocket2);\n      }\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should find all clients in a namespace","suites":["namespaces"],"updatePoint":{"line":212,"column":44},"line":212,"code":"  it(\"should find all clients in a namespace\", (done) => {\n    const io = new Server(0);\n    const chatSids: string[] = [];\n    let otherSid: SocketId | null = null;\n\n    const c1 = createClient(io, \"/chat\");\n    const c2 = createClient(io, \"/chat\", { forceNew: true });\n    const c3 = createClient(io, \"/other\", { forceNew: true });\n\n    let total = 3;\n    io.of(\"/chat\").on(\"connection\", (socket) => {\n      chatSids.push(socket.id);\n      --total || getSockets();\n    });\n    io.of(\"/other\").on(\"connection\", (socket) => {\n      otherSid = socket.id;\n      --total || getSockets();\n    });\n\n    async function getSockets() {\n      const sids = await io.of(\"/chat\").allSockets();\n\n      expect(sids).to.contain(chatSids[0], chatSids[1]);\n      expect(sids).to.not.contain(otherSid);\n      success(done, io, c1, c2, c3);\n    }\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should find all clients in a namespace room","suites":["namespaces"],"updatePoint":{"line":240,"column":49},"line":240,"code":"  it(\"should find all clients in a namespace room\", (done) => {\n    const io = new Server(0);\n    let chatFooSid: SocketId | null = null;\n    let chatBarSid: SocketId | null = null;\n    let otherSid: SocketId | null = null;\n\n    const c1 = createClient(io, \"/chat\");\n    const c2 = createClient(io, \"/chat\", { forceNew: true });\n    const c3 = createClient(io, \"/other\", { forceNew: true });\n\n    let chatIndex = 0;\n    let total = 3;\n    io.of(\"/chat\").on(\"connection\", (socket) => {\n      if (chatIndex++) {\n        socket.join(\"foo\");\n        chatFooSid = socket.id;\n        --total || getSockets();\n      } else {\n        socket.join(\"bar\");\n        chatBarSid = socket.id;\n        --total || getSockets();\n      }\n    });\n    io.of(\"/other\").on(\"connection\", (socket) => {\n      socket.join(\"foo\");\n      otherSid = socket.id;\n      --total || getSockets();\n    });\n\n    async function getSockets() {\n      const sids = await io.of(\"/chat\").in(\"foo\").allSockets();\n\n      expect(sids).to.contain(chatFooSid);\n      expect(sids).to.not.contain(chatBarSid);\n      expect(sids).to.not.contain(otherSid);\n      success(done, io, c1, c2, c3);\n    }\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should find all clients across namespace rooms","suites":["namespaces"],"updatePoint":{"line":279,"column":52},"line":279,"code":"  it(\"should find all clients across namespace rooms\", (done) => {\n    const io = new Server(0);\n    let chatFooSid: SocketId | null = null;\n    let chatBarSid: SocketId | null = null;\n    let otherSid: SocketId | null = null;\n\n    const c1 = createClient(io, \"/chat\");\n    const c2 = createClient(io, \"/chat\", { forceNew: true });\n    const c3 = createClient(io, \"/other\", { forceNew: true });\n\n    let chatIndex = 0;\n    let total = 3;\n    io.of(\"/chat\").on(\"connection\", (socket) => {\n      if (chatIndex++) {\n        socket.join(\"foo\");\n        chatFooSid = socket.id;\n        --total || getSockets();\n      } else {\n        socket.join(\"bar\");\n        chatBarSid = socket.id;\n        --total || getSockets();\n      }\n    });\n    io.of(\"/other\").on(\"connection\", (socket) => {\n      socket.join(\"foo\");\n      otherSid = socket.id;\n      --total || getSockets();\n    });\n\n    async function getSockets() {\n      const sids = await io.of(\"/chat\").allSockets();\n      expect(sids).to.contain(chatFooSid, chatBarSid);\n      expect(sids).to.not.contain(otherSid);\n      success(done, io, c1, c2, c3);\n    }\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should not emit volatile event after regular event","suites":["namespaces"],"updatePoint":{"line":316,"column":56},"line":316,"code":"  it(\"should not emit volatile event after regular event\", (done) => {\n    const io = new Server(0);\n\n    let counter = 0;\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        io.of(\"/chat\").emit(\"ev\", \"data\");\n        io.of(\"/chat\").volatile.emit(\"ev\", \"data\");\n      }, 50);\n    });\n\n    const socket = createClient(io, \"/chat\");\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 500);\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should emit volatile event","suites":["namespaces"],"updatePoint":{"line":339,"column":32},"line":339,"code":"  it(\"should emit volatile event\", (done) => {\n    const io = new Server(0);\n\n    let counter = 0;\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        io.of(\"/chat\").volatile.emit(\"ev\", \"data\");\n      }, 100);\n    });\n\n    const socket = createClient(io, \"/chat\");\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 500);\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should enable compression by default","suites":["namespaces"],"updatePoint":{"line":361,"column":42},"line":361,"code":"  it(\"should enable compression by default\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/chat\");\n\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      s.conn.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(true);\n        success(done, io, socket);\n      });\n      io.of(\"/chat\").emit(\"woot\", \"hi\");\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should disable compression","suites":["namespaces"],"updatePoint":{"line":374,"column":32},"line":374,"code":"  it(\"should disable compression\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/chat\");\n\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      s.conn.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(false);\n        success(done, io, socket);\n      });\n      io.of(\"/chat\").compress(false).emit(\"woot\", \"hi\");\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should throw on reserved event","suites":["namespaces"],"updatePoint":{"line":387,"column":36},"line":387,"code":"  it(\"should throw on reserved event\", () => {\n    const io = new Server();\n\n    expect(() => io.emit(\"connect\")).to.throwException(\n      /\"connect\" is a reserved event name/\n    );\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should close a client without namespace","suites":["namespaces"],"updatePoint":{"line":395,"column":45},"line":395,"code":"  it(\"should close a client without namespace\", (done) => {\n    const io = new Server(0, {\n      connectTimeout: 10,\n    });\n\n    const socket = createClient(io);\n\n    // @ts-ignore\n    socket.io.engine.write = () => {}; // prevent the client from sending a CONNECT packet\n\n    socket.on(\"disconnect\", successFn(done, io, socket));\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should exclude a specific socket when emitting","suites":["namespaces"],"updatePoint":{"line":408,"column":52},"line":408,"code":"  it(\"should exclude a specific socket when emitting\", (done) => {\n    const io = new Server(0);\n\n    const socket1 = createClient(io, \"/\");\n    const socket2 = createClient(io, \"/\");\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"should not happen\"));\n    });\n    socket1.on(\"a\", successFn(done, io, socket1, socket2));\n\n    socket2.on(\"connect\", () => {\n      io.except(socket2.id).emit(\"a\");\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should exclude a specific socket when emitting (in a namespace)","suites":["namespaces"],"updatePoint":{"line":424,"column":69},"line":424,"code":"  it(\"should exclude a specific socket when emitting (in a namespace)\", (done) => {\n    const io = new Server(0);\n\n    const nsp = io.of(\"/nsp\");\n\n    const socket1 = createClient(io, \"/nsp\");\n    const socket2 = createClient(io, \"/nsp\");\n\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n    socket1.on(\"a\", successFn(done, io, socket1, socket2));\n\n    socket2.on(\"connect\", () => {\n      nsp.except(socket2.id).emit(\"a\");\n    });\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should exclude a specific room when emitting","suites":["namespaces"],"updatePoint":{"line":442,"column":50},"line":442,"code":"  it(\"should exclude a specific room when emitting\", (done) => {\n    const io = new Server(0);\n\n    const nsp = io.of(\"/nsp\");\n\n    const socket1 = createClient(io, \"/nsp\");\n    const socket2 = createClient(io, \"/nsp\");\n\n    socket1.on(\"a\", successFn(done, io, socket1, socket2));\n    socket2.on(\"a\", () => {\n      done(new Error(\"not\"));\n    });\n\n    nsp.on(\"connection\", (socket) => {\n      socket.on(\"broadcast\", () => {\n        socket.join(\"room1\");\n        nsp.except(\"room1\").emit(\"a\");\n      });\n    });\n\n    socket2.emit(\"broadcast\");\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should emit an 'new_namespace' event","suites":["namespaces"],"updatePoint":{"line":465,"column":42},"line":465,"code":"  it(\"should emit an 'new_namespace' event\", (done) => {\n    const io = new Server();\n\n    io.on(\"new_namespace\", (namespace) => {\n      expect(namespace.name).to.eql(\"/nsp\");\n      done();\n    });\n\n    io.of(\"/nsp\");\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should not clean up a non-dynamic namespace","suites":["namespaces"],"updatePoint":{"line":476,"column":49},"line":476,"code":"  it(\"should not clean up a non-dynamic namespace\", (done) => {\n    const io = new Server(0, { cleanupEmptyChildNamespaces: true });\n    const c1 = createClient(io, \"/chat\");\n\n    c1.on(\"connect\", () => {\n      c1.disconnect();\n\n      // Give it some time to disconnect the client\n      setTimeout(() => {\n        expect(io._nsps.has(\"/chat\")).to.be(true);\n        expect(io._nsps.get(\"/chat\")!.sockets.size).to.be(0);\n        success(done, io);\n      }, 100);\n    });\n\n    io.of(\"/chat\");\n  });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should allow connections to dynamic namespaces with a regex","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":495,"column":67},"line":495,"code":"    it(\"should allow connections to dynamic namespaces with a regex\", (done) => {\n      const io = new Server(0);\n      const socket = createClient(io, \"/dynamic-101\");\n      const partialDone = createPartialDone(4, successFn(done, io, socket));\n\n      let dynamicNsp = io\n        .of(/^\\/dynamic-\\d+$/)\n        .on(\"connect\", (socket) => {\n          expect(socket.nsp.name).to.be(\"/dynamic-101\");\n          dynamicNsp.emit(\"hello\", 1, \"2\", { 3: \"4\" });\n          partialDone();\n        })\n        .use((socket, next) => {\n          next();\n          partialDone();\n        });\n      socket.on(\"connect_error\", (err) => {\n        expect().fail();\n      });\n      socket.on(\"connect\", () => {\n        partialDone();\n      });\n      socket.on(\"hello\", (a, b, c) => {\n        expect(a).to.eql(1);\n        expect(b).to.eql(\"2\");\n        expect(c).to.eql({ 3: \"4\" });\n        partialDone();\n      });\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should allow connections to dynamic namespaces with a function","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":525,"column":70},"line":525,"code":"    it(\"should allow connections to dynamic namespaces with a function\", (done) => {\n      const io = new Server(0);\n      const socket = createClient(io, \"/dynamic-101\");\n\n      io.of((name, query, next) => next(null, \"/dynamic-101\" === name));\n      socket.on(\"connect\", successFn(done, io, socket));\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should disallow connections when no dynamic namespace matches","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":533,"column":69},"line":533,"code":"    it(\"should disallow connections when no dynamic namespace matches\", (done) => {\n      const io = new Server(0);\n      const socket = createClient(io, \"/abc\");\n      io.of(/^\\/dynamic-\\d+$/);\n      io.of((name, query, next) => next(null, \"/dynamic-101\" === name));\n\n      socket.on(\"connect_error\", (err) => {\n        expect(err.message).to.be(\"Invalid namespace\");\n        success(done, io, socket);\n      });\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should emit an 'new_namespace' event for a dynamic namespace","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":545,"column":68},"line":545,"code":"    it(\"should emit an 'new_namespace' event for a dynamic namespace\", (done) => {\n      const io = new Server(0);\n      io.of(/^\\/dynamic-\\d+$/);\n      const socket = createClient(io, \"/dynamic-101\");\n\n      io.on(\"new_namespace\", (namespace) => {\n        expect(namespace.name).to.be(\"/dynamic-101\");\n\n        success(done, io, socket);\n      });\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should handle race conditions with dynamic namespaces (#4136)","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":557,"column":69},"line":557,"code":"    it(\"should handle race conditions with dynamic namespaces (#4136)\", (done) => {\n      const io = new Server(0);\n      const counters = {\n        connected: 0,\n        created: 0,\n        events: 0,\n      };\n      const buffer: Function[] = [];\n      io.on(\"new_namespace\", (namespace) => {\n        counters.created++;\n      });\n\n      const handler = () => {\n        if (++counters.events === 2) {\n          expect(counters.created).to.equal(1);\n          success(done, io, one, two);\n        }\n      };\n\n      io.of((name, query, next) => {\n        buffer.push(next);\n        if (buffer.length === 2) {\n          buffer.forEach((next) => next(null, true));\n        }\n      }).on(\"connection\", (socket) => {\n        if (++counters.connected === 2) {\n          io.of(\"/dynamic-101\").emit(\"message\");\n        }\n      });\n\n      let one = createClient(io, \"/dynamic-101\");\n      let two = createClient(io, \"/dynamic-101\");\n      one.on(\"message\", handler);\n      two.on(\"message\", handler);\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should clean up namespace when cleanupEmptyChildNamespaces is on and there are no more sockets in a namespace","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":593,"column":117},"line":593,"code":"    it(\"should clean up namespace when cleanupEmptyChildNamespaces is on and there are no more sockets in a namespace\", (done) => {\n      const io = new Server(0, { cleanupEmptyChildNamespaces: true });\n      const c1 = createClient(io, \"/dynamic-101\");\n\n      c1.on(\"connect\", () => {\n        c1.disconnect();\n\n        // Give it some time to disconnect and clean up the namespace\n        setTimeout(() => {\n          expect(io._nsps.has(\"/dynamic-101\")).to.be(false);\n          success(done, io);\n        }, 100);\n      });\n\n      io.of(/^\\/dynamic-\\d+$/);\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should allow a client to connect to a cleaned up namespace","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":610,"column":66},"line":610,"code":"    it(\"should allow a client to connect to a cleaned up namespace\", (done) => {\n      const io = new Server(0, { cleanupEmptyChildNamespaces: true });\n      const c1 = createClient(io, \"/dynamic-101\");\n\n      c1.on(\"connect\", () => {\n        c1.disconnect();\n\n        // Give it some time to disconnect and clean up the namespace\n        setTimeout(() => {\n          expect(io._nsps.has(\"/dynamic-101\")).to.be(false);\n\n          const c2 = createClient(io, \"/dynamic-101\");\n\n          c2.on(\"connect\", () => {\n            success(done, io, c2);\n          });\n\n          c2.on(\"connect_error\", () => {\n            done(\n              new Error(\"Client got error when connecting to dynamic namespace\")\n            );\n          });\n        }, 100);\n      });\n\n      io.of(/^\\/dynamic-\\d+$/);\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should not clean up namespace when cleanupEmptyChildNamespaces is off and there are no more sockets in a namespace","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":638,"column":122},"line":638,"code":"    it(\"should not clean up namespace when cleanupEmptyChildNamespaces is off and there are no more sockets in a namespace\", (done) => {\n      const io = new Server(0);\n      const c1 = createClient(io, \"/dynamic-101\");\n\n      c1.on(\"connect\", () => {\n        c1.disconnect();\n\n        // Give it some time to disconnect and clean up the namespace\n        setTimeout(() => {\n          expect(io._nsps.has(\"/dynamic-101\")).to.be(true);\n          expect(io._nsps.get(\"/dynamic-101\")!.sockets.size).to.be(0);\n          success(done, io);\n        }, 100);\n      });\n\n      io.of(/^\\/dynamic-\\d+$/);\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should attach a child namespace to its parent upon manual creation","suites":["namespaces","dynamic namespaces"],"updatePoint":{"line":656,"column":74},"line":656,"code":"    it(\"should attach a child namespace to its parent upon manual creation\", () => {\n      const io = new Server(0);\n      const parentNamespace = io.of(/^\\/dynamic-\\d+$/);\n      const childNamespace = io.of(\"/dynamic-101\");\n\n      // @ts-ignore\n      expect(parentNamespace.children.has(childNamespace)).to.be(true);\n\n      io.close();\n    });","file":"namespaces.ts","skipped":false,"dir":"test"},{"name":"should serve client","suites":["server attachment","http.Server"],"updatePoint":{"line":48,"column":27},"line":48,"code":"    it(\"should serve client\", testSource(\"socket.io.js\"));","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve client with query string","suites":["server attachment","http.Server"],"updatePoint":{"line":50,"column":44},"line":49,"code":"    it(\n      \"should serve client with query string\",\n      testSource(\"socket.io.js?buster=\" + Date.now())\n    );","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve source map","suites":["server attachment","http.Server"],"updatePoint":{"line":53,"column":31},"line":53,"code":"    it(\"should serve source map\", testSourceMap(\"socket.io.js.map\"));","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve client (min)","suites":["server attachment","http.Server"],"updatePoint":{"line":54,"column":33},"line":54,"code":"    it(\"should serve client (min)\", testSource(\"socket.io.min.js\"));","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve source map (min)","suites":["server attachment","http.Server"],"updatePoint":{"line":56,"column":37},"line":56,"code":"    it(\"should serve source map (min)\", testSourceMap(\"socket.io.min.js.map\"));","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve client (gzip)","suites":["server attachment","http.Server"],"updatePoint":{"line":58,"column":34},"line":58,"code":"    it(\"should serve client (gzip)\", (done) => {\n      const srv = createServer();\n      new Server(srv);\n      request(srv)\n        .get(\"/socket.io/socket.io.js\")\n        .set(\"accept-encoding\", \"gzip,br,deflate\")\n        .buffer(true)\n        .end((err, res) => {\n          if (err) return done(err);\n          expect(res.headers[\"content-encoding\"]).to.be(\"gzip\");\n          expect(res.status).to.be(200);\n          done();\n        });\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve client with necessary CORS headers","suites":["server attachment","http.Server"],"updatePoint":{"line":73,"column":55},"line":73,"code":"    it(\"should serve client with necessary CORS headers\", (done) => {\n      const srv = createServer();\n      new Server(srv, {\n        cors: {\n          origin: \"https://good-origin.com\",\n        },\n      });\n      request(srv)\n        .get(\"/socket.io/socket.io.js\")\n        .set(\"origin\", \"https://good-origin.com\")\n        .buffer(true)\n        .end((err, res) => {\n          if (err) return done(err);\n          expect(res.headers[\"access-control-allow-origin\"]).to.be(\n            \"https://good-origin.com\"\n          );\n          expect(res.status).to.be(200);\n          done();\n        });\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve bundle with msgpack parser","suites":["server attachment","http.Server"],"updatePoint":{"line":95,"column":46},"line":94,"code":"    it(\n      \"should serve bundle with msgpack parser\",\n      testSource(\"socket.io.msgpack.min.js\")\n    );","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve source map for bundle with msgpack parser","suites":["server attachment","http.Server"],"updatePoint":{"line":100,"column":61},"line":99,"code":"    it(\n      \"should serve source map for bundle with msgpack parser\",\n      testSourceMap(\"socket.io.msgpack.min.js.map\")\n    );","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve the ESM bundle","suites":["server attachment","http.Server"],"updatePoint":{"line":104,"column":35},"line":104,"code":"    it(\"should serve the ESM bundle\", testSource(\"socket.io.esm.min.js\"));","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should serve the source map for the ESM bundle","suites":["server attachment","http.Server"],"updatePoint":{"line":107,"column":53},"line":106,"code":"    it(\n      \"should serve the source map for the ESM bundle\",\n      testSourceMap(\"socket.io.esm.min.js.map\")\n    );","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should handle 304","suites":["server attachment","http.Server"],"updatePoint":{"line":111,"column":25},"line":111,"code":"    it(\"should handle 304\", (done) => {\n      const srv = createServer();\n      new Server(srv);\n      request(srv)\n        .get(\"/socket.io/socket.io.js\")\n        .set(\"If-None-Match\", '\"' + clientVersion + '\"')\n        .end((err, res) => {\n          if (err) return done(err);\n          expect(res.statusCode).to.be(304);\n          done();\n        });\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should handle 304","suites":["server attachment","http.Server"],"updatePoint":{"line":124,"column":25},"line":124,"code":"    it(\"should handle 304\", (done) => {\n      const srv = createServer();\n      new Server(srv);\n      request(srv)\n        .get(\"/socket.io/socket.io.js\")\n        .set(\"If-None-Match\", 'W/\"' + clientVersion + '\"')\n        .end((err, res) => {\n          if (err) return done(err);\n          expect(res.statusCode).to.be(304);\n          done();\n        });\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should not serve static files","suites":["server attachment","http.Server"],"updatePoint":{"line":137,"column":37},"line":137,"code":"    it(\"should not serve static files\", (done) => {\n      const srv = createServer();\n      new Server(srv, { serveClient: false });\n      request(srv).get(\"/socket.io/socket.io.js\").expect(400, done);\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should work with #attach","suites":["server attachment","http.Server"],"updatePoint":{"line":143,"column":32},"line":143,"code":"    it(\"should work with #attach\", (done) => {\n      const srv = createServer((req, res) => {\n        res.writeHead(404);\n        res.end();\n      });\n      const sockets = new Server();\n      sockets.attach(srv);\n      request(srv)\n        .get(\"/socket.io/socket.io.js\")\n        .end((err, res) => {\n          if (err) return done(err);\n          expect(res.status).to.be(200);\n          done();\n        });\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should work with #attach (and merge options)","suites":["server attachment","http.Server"],"updatePoint":{"line":159,"column":52},"line":159,"code":"    it(\"should work with #attach (and merge options)\", () => {\n      const srv = createServer((req, res) => {\n        res.writeHead(404);\n        res.end();\n      });\n      const server = new Server({\n        pingTimeout: 6000,\n      });\n      server.attach(srv, {\n        pingInterval: 24000,\n      });\n      // @ts-ignore\n      expect(server.eio.opts.pingTimeout).to.eql(6000);\n      // @ts-ignore\n      expect(server.eio.opts.pingInterval).to.eql(24000);\n      server.close();\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should be bound","suites":["server attachment","port"],"updatePoint":{"line":179,"column":23},"line":179,"code":"    it(\"should be bound\", (done) => {\n      const io = new Server(0);\n\n      request(`http://localhost:${getPort(io)}`)\n        .get(\"/socket.io/socket.io.js\")\n        .expect(200, successFn(done, io));\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"with listen","suites":["server attachment","port"],"updatePoint":{"line":187,"column":19},"line":187,"code":"    it(\"with listen\", (done) => {\n      const io = new Server().listen(0);\n\n      request(`http://localhost:${getPort(io)}`)\n        .get(\"/socket.io/socket.io.js\")\n        .expect(200, successFn(done, io));\n    });","file":"server-attachment.ts","skipped":false,"dir":"test"},{"name":"should call functions","suites":["socket middleware"],"updatePoint":{"line":6,"column":27},"line":6,"code":"  it(\"should call functions\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n    clientSocket.emit(\"join\", \"woot\");\n\n    let run = 0;\n\n    io.on(\"connection\", (socket) => {\n      socket.use((event, next) => {\n        expect(event).to.eql([\"join\", \"woot\"]);\n        event.unshift(\"wrap\");\n        run++;\n        next();\n      });\n      socket.use((event, next) => {\n        expect(event).to.eql([\"wrap\", \"join\", \"woot\"]);\n        run++;\n        next();\n      });\n      socket.on(\"wrap\", (data1, data2) => {\n        expect(data1).to.be(\"join\");\n        expect(data2).to.be(\"woot\");\n        expect(run).to.be(2);\n\n        success(done, io, clientSocket);\n      });\n    });\n  });","file":"socket-middleware.ts","skipped":false,"dir":"test"},{"name":"should pass errors","suites":["socket middleware"],"updatePoint":{"line":36,"column":24},"line":36,"code":"  it(\"should pass errors\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n    clientSocket.emit(\"join\", \"woot\");\n\n    io.on(\"connection\", (socket) => {\n      socket.use((event, next) => {\n        next(new Error(\"Authentication error\"));\n      });\n      socket.use((event, next) => {\n        done(new Error(\"should not happen\"));\n      });\n      socket.on(\"join\", () => {\n        done(new Error(\"should not happen\"));\n      });\n      socket.on(\"error\", (err) => {\n        expect(err).to.be.an(Error);\n        expect(err.message).to.eql(\"Authentication error\");\n\n        success(done, io, clientSocket);\n      });\n    });\n  });","file":"socket-middleware.ts","skipped":false,"dir":"test"},{"name":"should timeout if the client does not acknowledge the event","suites":["timeout"],"updatePoint":{"line":6,"column":65},"line":6,"code":"  it(\"should timeout if the client does not acknowledge the event\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    io.on(\"connection\", (socket) => {\n      socket.timeout(50).emit(\"unknown\", (err) => {\n        expect(err).to.be.an(Error);\n        success(done, io, client);\n      });\n    });\n  });","file":"socket-timeout.ts","skipped":false,"dir":"test"},{"name":"should timeout if the client does not acknowledge the event in time","suites":["timeout"],"updatePoint":{"line":18,"column":73},"line":18,"code":"  it(\"should timeout if the client does not acknowledge the event in time\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    client.on(\"echo\", (arg, cb) => {\n      cb(arg);\n    });\n\n    let count = 0;\n\n    io.on(\"connection\", (socket) => {\n      socket.timeout(0).emit(\"echo\", 42, (err) => {\n        expect(err).to.be.an(Error);\n        count++;\n      });\n    });\n\n    setTimeout(() => {\n      expect(count).to.eql(1);\n      success(done, io, client);\n    }, 200);\n  });","file":"socket-timeout.ts","skipped":false,"dir":"test"},{"name":"should not timeout if the client does acknowledge the event","suites":["timeout"],"updatePoint":{"line":41,"column":65},"line":41,"code":"  it(\"should not timeout if the client does acknowledge the event\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    client.on(\"echo\", (arg, cb) => {\n      cb(arg);\n    });\n\n    io.on(\"connection\", (socket) => {\n      socket.timeout(50).emit(\"echo\", 42, (err, value) => {\n        expect(err).to.be(null);\n        expect(value).to.be(42);\n        success(done, io, client);\n      });\n    });\n  });","file":"socket-timeout.ts","skipped":false,"dir":"test"},{"name":"should timeout if the client does not acknowledge the event (promise)","suites":["timeout"],"updatePoint":{"line":58,"column":75},"line":58,"code":"  it(\"should timeout if the client does not acknowledge the event (promise)\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    io.on(\"connection\", async (socket) => {\n      try {\n        await socket.timeout(50).emitWithAck(\"unknown\");\n        expect.fail();\n      } catch (err) {\n        expect(err).to.be.an(Error);\n        success(done, io, client);\n      }\n    });\n  });","file":"socket-timeout.ts","skipped":false,"dir":"test"},{"name":"should not timeout if the client does acknowledge the event (promise)","suites":["timeout"],"updatePoint":{"line":73,"column":75},"line":73,"code":"  it(\"should not timeout if the client does acknowledge the event (promise)\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    client.on(\"echo\", (arg, cb) => {\n      cb(arg);\n    });\n\n    io.on(\"connection\", async (socket) => {\n      const value = await socket.timeout(50).emitWithAck(\"echo\", 42);\n      expect(value).to.be(42);\n      success(done, io, client);\n    });\n  });","file":"socket-timeout.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters of reserved events","suites":["server","no event map","on"],"updatePoint":{"line":14,"column":73},"line":14,"code":"      it(\"infers correct types for listener parameters of reserved events\", (done) => {\n        const srv = createServer();\n        const sio = new Server(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            expectType<Socket<DefaultEventsMap, DefaultEventsMap>>(s);\n            s.on(\"disconnect\", (reason) => {\n              expectType<DisconnectReason>(reason);\n            });\n            s.on(\"disconnecting\", (reason) => {\n              expectType<DisconnectReason>(reason);\n            });\n          });\n          sio.on(\"connect\", (s) => {\n            expectType<Socket<DefaultEventsMap, DefaultEventsMap>>(s);\n          });\n          done();\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events","suites":["server","no event map","on"],"updatePoint":{"line":34,"column":62},"line":34,"code":"      it(\"infers 'any' for listener parameters of other events\", (done) => {\n        const srv = createServer();\n        const sio = new Server(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            s.on(\"random\", (a, b, c) => {\n              expectType<any>(a);\n              expectType<any>(b);\n              expectType<any>(c);\n              done();\n            });\n            s.emit(\"random\", 1, \"2\", [3]);\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events using enums","suites":["server","no event map","on"],"updatePoint":{"line":50,"column":74},"line":50,"code":"      it(\"infers 'any' for listener parameters of other events using enums\", () => {\n        const srv = createServer();\n        const sio = new Server(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (socket) => {\n            expectType<Socket<DefaultEventsMap, DefaultEventsMap>>(socket);\n          });\n\n          enum Events {\n            CONNECTION = \"connection\",\n            TEST = \"test\",\n          }\n\n          sio.on(Events.CONNECTION, (socket) => {\n            // TODO(#3833): Make this expect `Socket<DefaultEventsMap, DefaultEventsMap>`\n            expectType<any>(socket);\n\n            socket.on(\"test\", (a, b, c) => {\n              expectType<any>(a);\n              expectType<any>(b);\n              expectType<any>(c);\n            });\n\n            socket.on(Events.TEST, (a, b, c) => {\n              expectType<any>(a);\n              expectType<any>(b);\n              expectType<any>(c);\n            });\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts any parameters","suites":["server","no event map","emit"],"updatePoint":{"line":84,"column":32},"line":84,"code":"      it(\"accepts any parameters\", () => {\n        const srv = createServer();\n        const sio = new Server(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            s.emit(\"random\", 1, \"2\", [3]);\n            s.emit(\"no parameters\");\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts any parameters","suites":["server","no event map","emitWithAck"],"updatePoint":{"line":97,"column":32},"line":97,"code":"      it(\"accepts any parameters\", () => {\n        const srv = createServer();\n        const sio = new Server(srv);\n        srv.listen(async () => {\n          const value = await sio\n            .timeout(1000)\n            .emitWithAck(\"ackFromServerSingleArg\", true, \"123\");\n          expectType<any>(value);\n\n          sio.on(\"connection\", async (s) => {\n            const value1 = await s.emitWithAck(\n              \"ackFromServerSingleArg\",\n              true,\n              \"123\"\n            );\n            expectType<any>(value1);\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["server","single event map","on"],"updatePoint":{"line":125,"column":54},"line":125,"code":"      it(\"infers correct types for listener parameters\", (done) => {\n        const srv = createServer();\n        const sio = new Server<BidirectionalEvents>(srv);\n        expectType<Server<BidirectionalEvents, BidirectionalEvents>>(sio);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            expectType<Socket<BidirectionalEvents, BidirectionalEvents>>(s);\n            s.on(\"random\", (a, b, c) => {\n              expectType<number>(a);\n              expectType<string>(b);\n              expectType<number[]>(c);\n              done();\n            });\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["server","single event map","on"],"updatePoint":{"line":142,"column":50},"line":142,"code":"      it(\"does not accept arguments of wrong types\", (done) => {\n        const srv = createServer();\n        const sio = new Server<BidirectionalEvents, BidirectionalEvents, {}>(\n          srv\n        );\n        expectError(sio.on(\"random\", (a, b, c) => {}));\n        srv.listen(() => {\n          expectError(sio.on(\"wrong name\", (s) => {}));\n          sio.on(\"connection\", (s) => {\n            s.on(\"random\", (a, b, c) => {});\n            expectError(s.on(\"random\"));\n            expectError(s.on(\"random\", (a, b, c, d) => {}));\n            expectError(s.on(2, 3));\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["server","single event map","emit"],"updatePoint":{"line":161,"column":48},"line":161,"code":"      it(\"accepts arguments of the correct types\", () => {\n        const srv = createServer();\n        const sio = new Server<BidirectionalEvents>(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            s.emit(\"random\", 1, \"2\", [3]);\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of the wrong types","suites":["server","single event map","emit"],"updatePoint":{"line":171,"column":54},"line":171,"code":"      it(\"does not accept arguments of the wrong types\", () => {\n        const srv = createServer();\n        const sio = new Server<BidirectionalEvents>(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            expectError(s.emit(\"noParameter\", 2));\n            expectError(s.emit(\"oneParameter\"));\n            expectError(s.emit(\"random\"));\n            expectError(s.emit(\"oneParameter\", 2, 3));\n            expectError(s.emit(\"random\", (a, b, c) => {}));\n            expectError(s.emit(\"wrong name\", () => {}));\n            expectError(s.emit(\"complicated name with spaces\", 2));\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["server","listen and emit event maps","on"],"updatePoint":{"line":221,"column":54},"line":221,"code":"      it(\"infers correct types for listener parameters\", (done) => {\n        const srv = createServer();\n        const sio = new Server<ClientToServerEvents, ServerToClientEvents>(srv);\n        expectType<Server<ClientToServerEvents, ServerToClientEvents>>(sio);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            expectType<Socket<ClientToServerEvents, ServerToClientEvents>>(s);\n            s.on(\"helloFromClient\", (message) => {\n              expectType<string>(message);\n              done();\n            });\n\n            s.on(\"ackFromClient\", (a, b, cb) => {\n              expectType<string>(a);\n              expectType<number>(b);\n              expectType<(c: string, d: number) => void>(cb);\n              cb(\"123\", 456);\n            });\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept emit events","suites":["server","listen and emit event maps","on"],"updatePoint":{"line":243,"column":37},"line":243,"code":"      it(\"does not accept emit events\", (done) => {\n        const srv = createServer();\n        const sio = new Server<ClientToServerEvents, ServerToClientEvents>(srv);\n        srv.listen(() => {\n          sio.on(\"connection\", (s) => {\n            expectError(\n              s.on(\"helloFromServer\", (message, number) => {\n                done();\n              })\n            );\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["server","listen and emit event maps","emit"],"updatePoint":{"line":259,"column":48},"line":259,"code":"      it(\"accepts arguments of the correct types\", (done) => {\n        const srv = createServer();\n        const sio = new Server<ClientToServerEvents, ServerToClientEvents>(srv);\n        srv.listen(() => {\n          sio.emit(\"helloFromServer\", \"hi\", 1);\n          sio.to(\"room\").emit(\"helloFromServer\", \"hi\", 1);\n          sio.timeout(1000).emit(\"helloFromServer\", \"hi\", 1);\n\n          sio\n            .timeout(1000)\n            .emit(\"multipleAckFromServer\", true, \"123\", (err, c) => {\n              expectType<Error>(err);\n              expectType<string[]>(c);\n            });\n\n          sio.on(\"connection\", (s) => {\n            s.emit(\"helloFromServer\", \"hi\", 10);\n\n            s.emit(\"ackFromServer\", true, \"123\", (c, d) => {\n              expectType<boolean>(c);\n              expectType<string>(d);\n            });\n\n            s.timeout(1000).emit(\"ackFromServer\", true, \"123\", (err, c, d) => {\n              expectType<Error>(err);\n              expectType<boolean>(c);\n              expectType<string>(d);\n            });\n\n            s.timeout(1000)\n              .to(\"room\")\n              .emit(\"multipleAckFromServer\", true, \"123\", (err, c) => {\n                expectType<Error>(err);\n                expectType<string[]>(c);\n              });\n\n            s.to(\"room\")\n              .timeout(1000)\n              .emit(\"multipleAckFromServer\", true, \"123\", (err, c) => {\n                expectType<Error>(err);\n                expectType<string[]>(c);\n              });\n\n            done();\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["server","listen and emit event maps","emit"],"updatePoint":{"line":307,"column":50},"line":307,"code":"      it(\"does not accept arguments of wrong types\", (done) => {\n        const srv = createServer();\n        const sio = new Server<ClientToServerEvents, ServerToClientEvents>(srv);\n        srv.listen(() => {\n          expectError(sio.emit(\"helloFromClient\"));\n          expectError(sio.to(\"room\").emit(\"helloFromClient\"));\n          expectError(sio.timeout(1000).to(\"room\").emit(\"helloFromClient\"));\n\n          sio.on(\"connection\", (s) => {\n            expectError(s.emit(\"helloFromClient\", \"hi\"));\n            expectError(s.emit(\"helloFromServer\", \"hi\", 10, \"10\"));\n            expectError(s.emit(\"helloFromServer\", \"hi\", \"10\"));\n            expectError(s.emit(\"helloFromServer\", 0, 0));\n            expectError(s.emit(\"wrong name\", 10));\n            expectError(s.emit(\"wrong name\"));\n            done();\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["server","listen and emit event maps","emitWithAck"],"updatePoint":{"line":329,"column":48},"line":329,"code":"      it(\"accepts arguments of the correct types\", (done) => {\n        const srv = createServer();\n        const sio = new Server<ClientToServerEvents, ServerToClientEvents>(srv);\n        srv.listen(async () => {\n          const value = await sio\n            .timeout(1000)\n            .emitWithAck(\"multipleAckFromServer\", true, \"123\");\n          expectType<string[]>(value);\n\n          sio.on(\"connection\", async (s) => {\n            const value1 = await s\n              .timeout(1000)\n              .to(\"room\")\n              .emitWithAck(\"multipleAckFromServer\", true, \"123\");\n            expectType<string[]>(value1);\n\n            const value2 = await s\n              .to(\"room\")\n              .timeout(1000)\n              .emitWithAck(\"multipleAckFromServer\", true, \"123\");\n            expectType<string[]>(value2);\n\n            const value3 = await s.emitWithAck(\n              \"ackFromServerSingleArg\",\n              true,\n              \"123\"\n            );\n            expectType<string>(value3);\n\n            done();\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["server","listen and emit event maps for the serverSideEmit method","on"],"updatePoint":{"line":380,"column":54},"line":380,"code":"      it(\"infers correct types for listener parameters\", () => {\n        const srv = createServer();\n        const sio = new Server<\n          ClientToServerEvents,\n          ServerToClientEvents,\n          InterServerEvents\n        >(srv);\n\n        expectType<\n          Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents>\n        >(sio);\n        srv.listen(async () => {\n          sio.serverSideEmit(\"helloFromServerToServer\", \"hello\", 10);\n          sio\n            .of(\"/test\")\n            .serverSideEmit(\"helloFromServerToServer\", \"hello\", 10);\n\n          sio.on(\"helloFromServerToServer\", (message, x) => {\n            expectType<string>(message);\n            expectType<number>(x);\n          });\n          sio.of(\"/test\").on(\"helloFromServerToServer\", (message, x) => {\n            expectType<string>(message);\n            expectType<number>(x);\n          });\n\n          sio.serverSideEmit(\"ackFromServerToServer\", \"foo\", (err, bar) => {\n            expectType<Error>(err);\n            expectType<number[]>(bar);\n          });\n\n          const value = await sio.serverSideEmitWithAck(\n            \"ackFromServerToServer\",\n            \"foo\"\n          );\n          expectType<number[]>(value);\n\n          sio.on(\"ackFromServerToServer\", (foo, cb) => {\n            expectType<string>(foo);\n            expectType<(bar: number) => void>(cb);\n          });\n        });\n      });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["server","adapter"],"updatePoint":{"line":427,"column":46},"line":427,"code":"    it(\"accepts arguments of the correct types\", () => {\n      const io = new Server({\n        adapter: (nsp) => new Adapter(nsp),\n      });\n      io.adapter(Adapter);\n\n      class MyCustomAdapter extends Adapter {\n        constructor(nsp, readonly opts) {\n          super(nsp);\n        }\n      }\n      io.adapter((nsp) => new MyCustomAdapter(nsp, { test: \"123\" }));\n    });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["server","adapter"],"updatePoint":{"line":441,"column":48},"line":441,"code":"    it(\"does not accept arguments of wrong types\", () => {\n      const io = new Server();\n      expectError(io.adapter((nsp) => \"nope\"));\n    });","file":"socket.io.test-d.ts","skipped":false,"dir":"test"},{"name":"should not fire events more than once after manually reconnecting","suites":["socket"],"updatePoint":{"line":14,"column":71},"line":14,"code":"  it(\"should not fire events more than once after manually reconnecting\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io, \"/\", { reconnection: false });\n\n    clientSocket.on(\"connect\", function init() {\n      clientSocket.off(\"connect\", init);\n      clientSocket.io.engine.close();\n\n      process.nextTick(() => {\n        clientSocket.connect();\n      });\n      clientSocket.on(\"connect\", successFn(done, io, clientSocket));\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not fire reconnect_failed event more than once when server closed","suites":["socket"],"updatePoint":{"line":29,"column":78},"line":29,"code":"  it(\"should not fire reconnect_failed event more than once when server closed\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io, \"/\", {\n      reconnectionAttempts: 3,\n      reconnectionDelay: 100,\n    });\n\n    clientSocket.on(\"connect\", () => {\n      io.close();\n    });\n\n    clientSocket.io.on(\"reconnect_failed\", () => {\n      success(done, io, clientSocket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events","suites":["socket"],"updatePoint":{"line":45,"column":27},"line":45,"code":"  it(\"should receive events\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"random\", (a, b, c) => {\n        expect(a).to.be(1);\n        expect(b).to.be(\"2\");\n        expect(c).to.eql([3]);\n\n        success(done, io, socket);\n      });\n      socket.emit(\"random\", 1, \"2\", [3]);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive message events through `send`","suites":["socket"],"updatePoint":{"line":61,"column":50},"line":61,"code":"  it(\"should receive message events through `send`\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"message\", (a) => {\n        expect(a).to.be(1337);\n\n        success(done, io, socket);\n      });\n      socket.send(1337);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should error with null messages","suites":["socket"],"updatePoint":{"line":75,"column":37},"line":75,"code":"  it(\"should error with null messages\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"message\", (a) => {\n        expect(a).to.be(null);\n        success(done, io, socket);\n      });\n      socket.send(null);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should handle transport null messages","suites":["socket"],"updatePoint":{"line":88,"column":43},"line":88,"code":"  it(\"should handle transport null messages\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { reconnection: false });\n\n    io.on(\"connection\", (s) => {\n      s.on(\"error\", (err) => {\n        expect(err).to.be.an(Error);\n        s.on(\"disconnect\", (reason) => {\n          expect(reason).to.be(\"forced close\");\n\n          success(done, io, socket);\n        });\n      });\n      (s as any).client.ondata(null);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events","suites":["socket"],"updatePoint":{"line":105,"column":24},"line":105,"code":"  it(\"should emit events\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    socket.on(\"woot\", (a) => {\n      expect(a).to.be(\"tobi\");\n      success(done, io, socket);\n    });\n    io.on(\"connection\", (s) => {\n      s.emit(\"woot\", \"tobi\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with utf8 multibyte character","suites":["socket"],"updatePoint":{"line":118,"column":54},"line":118,"code":"  it(\"should emit events with utf8 multibyte character\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n    let i = 0;\n\n    socket.on(\"hoot\", (a) => {\n      expect(a).to.be(\"utf8 — string\");\n      i++;\n\n      if (3 == i) {\n        success(done, io, socket);\n      }\n    });\n    io.on(\"connection\", (s) => {\n      s.emit(\"hoot\", \"utf8 — string\");\n      s.emit(\"hoot\", \"utf8 — string\");\n      s.emit(\"hoot\", \"utf8 — string\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with binary data","suites":["socket"],"updatePoint":{"line":138,"column":41},"line":138,"code":"  it(\"should emit events with binary data\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    let imageData;\n    socket.on(\"doge\", (a) => {\n      expect(Buffer.isBuffer(a)).to.be(true);\n      expect(imageData.length).to.equal(a.length);\n      expect(imageData[0]).to.equal(a[0]);\n      expect(imageData[imageData.length - 1]).to.equal(a[a.length - 1]);\n\n      success(done, io, socket);\n    });\n    io.on(\"connection\", (s) => {\n      fs.readFile(join(__dirname, \"support\", \"doge.jpg\"), (err, data) => {\n        if (err) return done(err);\n        imageData = data;\n        s.emit(\"doge\", data);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with several types of data (including binary)","suites":["socket"],"updatePoint":{"line":160,"column":70},"line":160,"code":"  it(\"should emit events with several types of data (including binary)\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    socket.on(\"multiple\", (a, b, c, d, e, f) => {\n      expect(a).to.be(1);\n      expect(Buffer.isBuffer(b)).to.be(true);\n      expect(c).to.be(\"3\");\n      expect(d).to.eql([4]);\n      expect(Buffer.isBuffer(e)).to.be(true);\n      expect(Buffer.isBuffer(f[0])).to.be(true);\n      expect(f[1]).to.be(\"swag\");\n      expect(Buffer.isBuffer(f[2])).to.be(true);\n\n      success(done, io, socket);\n    });\n    io.on(\"connection\", (s) => {\n      fs.readFile(join(__dirname, \"support\", \"doge.jpg\"), (err, data) => {\n        if (err) return done(err);\n        const buf = Buffer.from(\"asdfasdf\", \"utf8\");\n        s.emit(\"multiple\", 1, data, \"3\", [4], buf, [data, \"swag\", buf]);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events with binary data","suites":["socket"],"updatePoint":{"line":185,"column":44},"line":185,"code":"  it(\"should receive events with binary data\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"buff\", (a) => {\n        expect(Buffer.isBuffer(a)).to.be(true);\n\n        success(done, io, socket);\n      });\n      const buf = Buffer.from(\"abcdefg\", \"utf8\");\n      socket.emit(\"buff\", buf);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events with several types of data (including binary)","suites":["socket"],"updatePoint":{"line":200,"column":73},"line":200,"code":"  it(\"should receive events with several types of data (including binary)\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"multiple\", (a, b, c, d, e, f) => {\n        expect(a).to.be(1);\n        expect(Buffer.isBuffer(b)).to.be(true);\n        expect(c).to.be(\"3\");\n        expect(d).to.eql([4]);\n        expect(Buffer.isBuffer(e)).to.be(true);\n        expect(Buffer.isBuffer(f[0])).to.be(true);\n        expect(f[1]).to.be(\"swag\");\n        expect(Buffer.isBuffer(f[2])).to.be(true);\n\n        success(done, io, socket);\n      });\n      fs.readFile(join(__dirname, \"support\", \"doge.jpg\"), (err, data) => {\n        if (err) return done(err);\n        const buf = Buffer.from(\"asdfasdf\", \"utf8\");\n        socket.emit(\"multiple\", 1, data, \"3\", [4], buf, [data, \"swag\", buf]);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not emit volatile event after regular event (polling)","suites":["socket"],"updatePoint":{"line":225,"column":66},"line":225,"code":"  it(\"should not emit volatile event after regular event (polling)\", (done) => {\n    const io = new Server(0, { transports: [\"polling\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      s.emit(\"ev\", \"data\");\n      s.volatile.emit(\"ev\", \"data\");\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"polling\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not emit volatile event after regular event (ws)","suites":["socket"],"updatePoint":{"line":245,"column":61},"line":245,"code":"  it(\"should not emit volatile event after regular event (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      s.emit(\"ev\", \"data\");\n      s.volatile.emit(\"ev\", \"data\");\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit volatile event (polling)","suites":["socket"],"updatePoint":{"line":265,"column":42},"line":265,"code":"  it(\"should emit volatile event (polling)\", (done) => {\n    const io = new Server(0, { transports: [\"polling\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.volatile.emit(\"ev\", \"data\");\n      }, 100);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"polling\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 500);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit volatile event (ws)","suites":["socket"],"updatePoint":{"line":287,"column":37},"line":287,"code":"  it(\"should emit volatile event (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.volatile.emit(\"ev\", \"data\");\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit only one consecutive volatile event (polling)","suites":["socket"],"updatePoint":{"line":309,"column":63},"line":309,"code":"  it(\"should emit only one consecutive volatile event (polling)\", (done) => {\n    const io = new Server(0, { transports: [\"polling\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.volatile.emit(\"ev\", \"data\");\n        s.volatile.emit(\"ev\", \"data\");\n      }, 100);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"polling\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 500);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit only one consecutive volatile event (ws)","suites":["socket"],"updatePoint":{"line":332,"column":58},"line":332,"code":"  it(\"should emit only one consecutive volatile event (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.volatile.emit(\"ev\", \"data\");\n        s.volatile.emit(\"ev\", \"data\");\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit only one consecutive volatile event with binary (ws)","suites":["socket"],"updatePoint":{"line":355,"column":70},"line":355,"code":"  it(\"should emit only one consecutive volatile event with binary (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.volatile.emit(\"ev\", Buffer.from([1, 2, 3]));\n        s.volatile.emit(\"ev\", Buffer.from([4, 5, 6]));\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should broadcast only one consecutive volatile event with binary (ws)","suites":["socket"],"updatePoint":{"line":378,"column":75},"line":378,"code":"  it(\"should broadcast only one consecutive volatile event with binary (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        io.volatile.emit(\"ev\", Buffer.from([1, 2, 3]));\n        io.volatile.emit(\"ev\", Buffer.from([4, 5, 6]));\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(1);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit regular events after trying a failed volatile event (polling)","suites":["socket"],"updatePoint":{"line":401,"column":79},"line":401,"code":"  it(\"should emit regular events after trying a failed volatile event (polling)\", (done) => {\n    const io = new Server(0, { transports: [\"polling\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.emit(\"ev\", \"data\");\n        s.volatile.emit(\"ev\", \"data\");\n        s.emit(\"ev\", \"data\");\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"polling\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(2);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit regular events after trying a failed volatile event (ws)","suites":["socket"],"updatePoint":{"line":425,"column":74},"line":425,"code":"  it(\"should emit regular events after trying a failed volatile event (ws)\", (done) => {\n    const io = new Server(0, { transports: [\"websocket\"] });\n\n    let counter = 0;\n    io.on(\"connection\", (s) => {\n      // Wait to make sure there are no packets being sent for opening the connection\n      setTimeout(() => {\n        s.emit(\"ev\", \"data\");\n        s.volatile.emit(\"ev\", \"data\");\n        s.emit(\"ev\", \"data\");\n      }, 20);\n    });\n\n    const socket = createClient(io, \"/\", { transports: [\"websocket\"] });\n    socket.on(\"ev\", () => {\n      counter++;\n    });\n\n    setTimeout(() => {\n      expect(counter).to.be(2);\n      success(done, io, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit message events through `send`","suites":["socket"],"updatePoint":{"line":449,"column":47},"line":449,"code":"  it(\"should emit message events through `send`\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    socket.on(\"message\", (a) => {\n      expect(a).to.be(\"a\");\n      success(done, io, socket);\n    });\n    io.on(\"connection\", (s) => {\n      s.send(\"a\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive event with callbacks","suites":["socket"],"updatePoint":{"line":462,"column":41},"line":462,"code":"  it(\"should receive event with callbacks\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"woot\", (fn) => {\n        fn(1, 2);\n      });\n      socket.emit(\"woot\", (a, b) => {\n        expect(a).to.be(1);\n        expect(b).to.be(2);\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive all events emitted from namespaced client immediately and in order","suites":["socket"],"updatePoint":{"line":478,"column":87},"line":478,"code":"  it(\"should receive all events emitted from namespaced client immediately and in order\", (done) => {\n    const io = new Server(0);\n    let total = 0;\n\n    io.of(\"/chat\", (s) => {\n      s.on(\"hi\", (letter) => {\n        total++;\n        if (total == 2 && letter == \"b\") {\n          success(done, io, chat);\n        } else if (total == 1 && letter != \"a\") {\n          throw new Error(\"events out of order\");\n        }\n      });\n    });\n\n    const chat = createClient(io, \"/chat\");\n    chat.emit(\"hi\", \"a\");\n    setTimeout(() => {\n      chat.emit(\"hi\", \"b\");\n    }, 50);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with callbacks","suites":["socket"],"updatePoint":{"line":500,"column":39},"line":500,"code":"  it(\"should emit events with callbacks\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      socket.on(\"hi\", (fn) => {\n        fn();\n      });\n      s.emit(\"hi\", () => {\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events with args and callback","suites":["socket"],"updatePoint":{"line":514,"column":50},"line":514,"code":"  it(\"should receive events with args and callback\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"woot\", (a, b, fn) => {\n        expect(a).to.be(1);\n        expect(b).to.be(2);\n        fn();\n      });\n      socket.emit(\"woot\", 1, 2, () => {\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with args and callback","suites":["socket"],"updatePoint":{"line":530,"column":47},"line":530,"code":"  it(\"should emit events with args and callback\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      socket.on(\"hi\", (a, b, fn) => {\n        expect(a).to.be(1);\n        expect(b).to.be(2);\n        fn();\n      });\n      s.emit(\"hi\", 1, 2, () => {\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events with binary args and callbacks","suites":["socket"],"updatePoint":{"line":546,"column":58},"line":546,"code":"  it(\"should receive events with binary args and callbacks\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"woot\", (buf, fn) => {\n        expect(Buffer.isBuffer(buf)).to.be(true);\n        fn(1, 2);\n      });\n      socket.emit(\"woot\", Buffer.alloc(3), (a, b) => {\n        expect(a).to.be(1);\n        expect(b).to.be(2);\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events with binary args and callback","suites":["socket"],"updatePoint":{"line":563,"column":54},"line":563,"code":"  it(\"should emit events with binary args and callback\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      socket.on(\"hi\", (a, fn) => {\n        expect(Buffer.isBuffer(a)).to.be(true);\n        fn();\n      });\n      s.emit(\"hi\", Buffer.alloc(4), () => {\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events and receive binary data in a callback","suites":["socket"],"updatePoint":{"line":578,"column":62},"line":578,"code":"  it(\"should emit events and receive binary data in a callback\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      socket.on(\"hi\", (fn) => {\n        fn(Buffer.alloc(1));\n      });\n      s.emit(\"hi\", (a) => {\n        expect(Buffer.isBuffer(a)).to.be(true);\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should receive events and pass binary data in a callback","suites":["socket"],"updatePoint":{"line":593,"column":62},"line":593,"code":"  it(\"should receive events and pass binary data in a callback\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      s.on(\"woot\", (fn) => {\n        fn(Buffer.alloc(2));\n      });\n      socket.emit(\"woot\", (a) => {\n        expect(Buffer.isBuffer(a)).to.be(true);\n        success(done, io, socket);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit an event and wait for the acknowledgement","suites":["socket"],"updatePoint":{"line":608,"column":59},"line":608,"code":"  it(\"should emit an event and wait for the acknowledgement\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", async (s) => {\n      socket.on(\"hi\", (a, b, fn) => {\n        expect(a).to.be(1);\n        expect(b).to.be(2);\n        fn(3);\n      });\n\n      const val = await s.emitWithAck(\"hi\", 1, 2);\n      expect(val).to.be(3);\n\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should have access to the client","suites":["socket"],"updatePoint":{"line":626,"column":38},"line":626,"code":"  it(\"should have access to the client\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      expect(s.client).to.be.an(\"object\");\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should have access to the connection","suites":["socket"],"updatePoint":{"line":636,"column":42},"line":636,"code":"  it(\"should have access to the connection\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      expect(s.client.conn).to.be.an(\"object\");\n      expect(s.conn).to.be.an(\"object\");\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should have access to the request","suites":["socket"],"updatePoint":{"line":647,"column":39},"line":647,"code":"  it(\"should have access to the request\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", (s) => {\n      expect(s.client.request.headers).to.be.an(\"object\");\n      expect(s.request.headers).to.be.an(\"object\");\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should see query parameters in the request","suites":["socket"],"updatePoint":{"line":658,"column":48},"line":658,"code":"  it(\"should see query parameters in the request\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { query: { key1: 1, key2: 2 } });\n\n    io.on(\"connection\", (s) => {\n      const parsed = require(\"url\").parse(s.request.url);\n      const query = require(\"querystring\").parse(parsed.query);\n      expect(query.key1).to.be(\"1\");\n      expect(query.key2).to.be(\"2\");\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should see query parameters sent from secondary namespace connections in handshake object","suites":["socket"],"updatePoint":{"line":671,"column":95},"line":671,"code":"  it(\"should see query parameters sent from secondary namespace connections in handshake object\", (done) => {\n    const io = new Server(0);\n    const client1 = createClient(io);\n    const client2 = createClient(io, \"/connection2\", {\n      auth: { key1: \"aa\", key2: \"&=bb\" },\n    });\n    io.on(\"connection\", (s) => {});\n    io.of(\"/connection2\").on(\"connection\", (s) => {\n      expect(s.handshake.query.key1).to.be(undefined);\n      expect(s.handshake.query.EIO).to.be(\"4\");\n      expect(s.handshake.auth.key1).to.be(\"aa\");\n      expect(s.handshake.auth.key2).to.be(\"&=bb\");\n      success(done, io, client1, client2);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should handle very large json","suites":["socket"],"updatePoint":{"line":687,"column":35},"line":687,"code":"  it(\"should handle very large json\", function (done) {\n    this.timeout(30000);\n    const io = new Server(0, { perMessageDeflate: false });\n    let received = 0;\n\n    const socket = createClient(io);\n    socket.on(\"big\", (a) => {\n      expect(Buffer.isBuffer(a.json)).to.be(false);\n      if (++received == 3) success(done, io, socket);\n      else socket.emit(\"big\", a);\n    });\n    io.on(\"connection\", (s) => {\n      fs.readFile(join(__dirname, \"fixtures\", \"big.json\"), (err, data: any) => {\n        if (err) return done(err);\n        data = JSON.parse(data);\n        s.emit(\"big\", { hello: \"friend\", json: data });\n      });\n      s.on(\"big\", (a) => {\n        s.emit(\"big\", a);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should handle very large binary data","suites":["socket"],"updatePoint":{"line":710,"column":42},"line":710,"code":"  it(\"should handle very large binary data\", function (done) {\n    this.timeout(30000);\n    const io = new Server(0, { perMessageDeflate: false });\n    let received = 0;\n\n    const socket = createClient(io);\n    socket.on(\"big\", (a) => {\n      expect(Buffer.isBuffer(a.image)).to.be(true);\n      if (++received == 3) success(done, io, socket);\n      else socket.emit(\"big\", a);\n    });\n    io.on(\"connection\", (s) => {\n      fs.readFile(join(__dirname, \"fixtures\", \"big.jpg\"), (err, data) => {\n        if (err) return done(err);\n        s.emit(\"big\", { hello: \"friend\", image: data });\n      });\n      s.on(\"big\", (a) => {\n        expect(Buffer.isBuffer(a.image)).to.be(true);\n        s.emit(\"big\", a);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should be able to emit after server close and restart","suites":["socket"],"updatePoint":{"line":733,"column":59},"line":733,"code":"  it(\"should be able to emit after server close and restart\", (done) => {\n    const io = new Server(0);\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"ev\", (data) => {\n        expect(data).to.be(\"payload\");\n        success(done, io, clientSocket);\n      });\n    });\n\n    const port = getPort(io);\n    const clientSocket = createClient(io, \"/\", {\n      reconnectionAttempts: 10,\n      reconnectionDelay: 100,\n    });\n    clientSocket.once(\"connect\", () => {\n      io.close(() => {\n        clientSocket.io.on(\"reconnect\", () => {\n          clientSocket.emit(\"ev\", \"payload\");\n        });\n        io.listen(port);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should enable compression by default","suites":["socket"],"updatePoint":{"line":758,"column":42},"line":758,"code":"  it(\"should enable compression by default\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/chat\");\n\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      s.conn.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(true);\n        success(done, io, socket);\n      });\n      s.emit(\"woot\", \"hi\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should disable compression","suites":["socket"],"updatePoint":{"line":771,"column":32},"line":771,"code":"  it(\"should disable compression\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/chat\");\n\n    io.of(\"/chat\").on(\"connection\", (s) => {\n      s.conn.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(false);\n        success(done, io, socket);\n      });\n      s.compress(false).emit(\"woot\", \"hi\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should error with raw binary and warn","suites":["socket"],"updatePoint":{"line":784,"column":43},"line":784,"code":"  it(\"should error with raw binary and warn\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { reconnection: false });\n\n    io.on(\"connection\", (s) => {\n      s.conn.on(\"upgrade\", () => {\n        console.log(\n          \"\\u001b[96mNote: warning expected and normal in test.\\u001b[39m\"\n        );\n        // @ts-ignore\n        socket.io.engine.write(\"5woooot\");\n        setTimeout(() => {\n          success(done, io, socket);\n        }, 100);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not crash when receiving an error packet without handler","suites":["socket"],"updatePoint":{"line":802,"column":69},"line":802,"code":"  it(\"should not crash when receiving an error packet without handler\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { reconnection: false });\n\n    io.on(\"connection\", (s) => {\n      s.conn.on(\"upgrade\", () => {\n        console.log(\n          \"\\u001b[96mNote: warning expected and normal in test.\\u001b[39m\"\n        );\n        // @ts-ignore\n        socket.io.engine.write('44[\"handle me please\"]');\n        setTimeout(() => {\n          success(done, io, socket);\n        }, 100);\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not crash with raw binary","suites":["socket"],"updatePoint":{"line":820,"column":38},"line":820,"code":"  it(\"should not crash with raw binary\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { reconnection: false });\n\n    io.on(\"connection\", (s) => {\n      s.once(\"error\", (err) => {\n        expect(err.message).to.match(/Illegal attachments/);\n        success(done, io, socket);\n      });\n      s.conn.on(\"upgrade\", () => {\n        // @ts-ignore\n        socket.io.engine.write(\"5woooot\");\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should handle empty binary packet","suites":["socket"],"updatePoint":{"line":836,"column":39},"line":836,"code":"  it(\"should handle empty binary packet\", (done) => {\n    const io = new Server(0);\n    const socket = createClient(io, \"/\", { reconnection: false });\n\n    io.on(\"connection\", (s) => {\n      s.once(\"error\", (err) => {\n        expect(err.message).to.match(/Illegal attachments/);\n        success(done, io, socket);\n      });\n      s.conn.on(\"upgrade\", () => {\n        // @ts-ignore\n        socket.io.engine.write(\"5\");\n      });\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not crash when messing with Object prototype (and other globals)","suites":["socket"],"updatePoint":{"line":852,"column":77},"line":852,"code":"  it(\"should not crash when messing with Object prototype (and other globals)\", (done) => {\n    // @ts-ignore\n    Object.prototype.foo = \"bar\";\n    const io = new Server(0);\n    const socket = createClient(io);\n\n    io.on(\"connection\", successFn(done, io, socket));\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should throw on reserved event","suites":["socket"],"updatePoint":{"line":861,"column":36},"line":861,"code":"  it(\"should throw on reserved event\", (done) => {\n    const io = new Server(0);\n\n    const socket = createClient(io);\n    io.on(\"connection\", (s) => {\n      expect(() => s.emit(\"connect_error\")).to.throwException(\n        /\"connect_error\" is a reserved event name/\n      );\n      socket.close();\n      success(done, io, socket);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should ignore a packet received after disconnection","suites":["socket"],"updatePoint":{"line":874,"column":57},"line":874,"code":"  it(\"should ignore a packet received after disconnection\", (done) => {\n    const io = new Server(0);\n    const clientSocket = createClient(io);\n\n    io.on(\"connection\", (socket) => {\n      socket.on(\"test\", () => {\n        done(new Error(\"should not happen\"));\n      });\n      socket.on(\"disconnect\", successFn(done, io, clientSocket));\n    });\n\n    clientSocket.on(\"connect\", () => {\n      clientSocket.emit(\"test\", Buffer.alloc(10));\n      clientSocket.disconnect();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should leave all rooms joined after a middleware failure","suites":["socket"],"updatePoint":{"line":891,"column":62},"line":891,"code":"  it(\"should leave all rooms joined after a middleware failure\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    io.use((socket, next) => {\n      socket.join(\"room1\");\n      next(new Error(\"nope\"));\n    });\n\n    client.on(\"connect_error\", () => {\n      expect(io.of(\"/\").adapter.rooms.size).to.eql(0);\n\n      io.close();\n      success(done, io, client);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not join rooms after disconnection","suites":["socket"],"updatePoint":{"line":908,"column":47},"line":908,"code":"  it(\"should not join rooms after disconnection\", (done) => {\n    const io = new Server(0);\n    const client = createClient(io, \"/\");\n\n    io.on(\"connection\", (socket) => {\n      socket.disconnect();\n      socket.join(\"room1\");\n    });\n\n    client.on(\"disconnect\", () => {\n      expect(io.of(\"/\").adapter.rooms.size).to.eql(0);\n\n      io.close();\n      success(done, io, client);\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener","suites":["socket","onAny"],"updatePoint":{"line":926,"column":28},"line":926,"code":"    it(\"should call listener\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      clientSocket.emit(\"my-event\", \"123\");\n\n      io.on(\"connection\", (socket) => {\n        socket.onAny((event, arg1) => {\n          expect(event).to.be(\"my-event\");\n          expect(arg1).to.be(\"123\");\n          success(done, io, clientSocket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should prepend listener","suites":["socket","onAny"],"updatePoint":{"line":941,"column":31},"line":941,"code":"    it(\"should prepend listener\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      clientSocket.emit(\"my-event\", \"123\");\n\n      io.on(\"connection\", (socket) => {\n        let count = 0;\n\n        socket.onAny((event, arg1) => {\n          expect(count).to.be(2);\n          success(done, io, clientSocket);\n        });\n\n        socket.prependAny(() => {\n          expect(count++).to.be(1);\n        });\n\n        socket.prependAny(() => {\n          expect(count++).to.be(0);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should remove listener","suites":["socket","onAny"],"updatePoint":{"line":965,"column":30},"line":965,"code":"    it(\"should remove listener\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      clientSocket.emit(\"my-event\", \"123\");\n\n      io.on(\"connection\", (socket) => {\n        const fail = () => done(new Error(\"fail\"));\n\n        socket.onAny(fail);\n        socket.offAny(fail);\n        expect(socket.listenersAny.length).to.be(0);\n\n        socket.onAny(() => {\n          success(done, io, clientSocket);\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":986,"column":28},"line":986,"code":"    it(\"should call listener\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      io.on(\"connection\", (socket) => {\n        socket.onAnyOutgoing((event, arg1) => {\n          expect(event).to.be(\"my-event\");\n          expect(arg1).to.be(\"123\");\n\n          success(done, io, clientSocket);\n        });\n\n        socket.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener when broadcasting","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":1002,"column":46},"line":1002,"code":"    it(\"should call listener when broadcasting\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      io.on(\"connection\", (socket) => {\n        socket.onAnyOutgoing((event, arg1) => {\n          expect(event).to.be(\"my-event\");\n          expect(arg1).to.be(\"123\");\n\n          success(done, io, clientSocket);\n        });\n\n        io.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener when broadcasting binary data","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":1018,"column":58},"line":1018,"code":"    it(\"should call listener when broadcasting binary data\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      io.on(\"connection\", (socket) => {\n        socket.onAnyOutgoing((event, arg1) => {\n          expect(event).to.be(\"my-event\");\n          expect(arg1).to.be.an(Uint8Array);\n\n          success(done, io, clientSocket);\n        });\n\n        io.emit(\"my-event\", Uint8Array.of(1, 2, 3));\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should prepend listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":1034,"column":31},"line":1034,"code":"    it(\"should prepend listener\", (done) => {\n      const io = new Server(0);\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      io.on(\"connection\", (socket) => {\n        let count = 0;\n\n        socket.onAnyOutgoing((event, arg1) => {\n          expect(count).to.be(2);\n\n          success(done, io, clientSocket);\n        });\n\n        socket.prependAnyOutgoing(() => {\n          expect(count++).to.be(1);\n        });\n\n        socket.prependAnyOutgoing(() => {\n          expect(count++).to.be(0);\n        });\n\n        socket.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should remove listener","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":1059,"column":30},"line":1059,"code":"    it(\"should remove listener\", (done) => {\n      const io = new Server(0);\n\n      const clientSocket = createClient(io, \"/\", { multiplex: false });\n\n      io.on(\"connection\", (socket) => {\n        const fail = () => done(new Error(\"fail\"));\n\n        socket.onAnyOutgoing(fail);\n        socket.offAnyOutgoing(fail);\n        expect(socket.listenersAnyOutgoing.length).to.be(0);\n\n        socket.onAnyOutgoing(() => {\n          success(done, io, clientSocket);\n        });\n\n        socket.emit(\"my-event\", \"123\");\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should disconnect all namespaces when calling disconnect(true)","suites":["socket","onAnyOutgoing"],"updatePoint":{"line":1079,"column":70},"line":1079,"code":"    it(\"should disconnect all namespaces when calling disconnect(true)\", (done) => {\n      const io = new Server(0);\n      io.of(\"/foo\");\n      io.of(\"/bar\");\n\n      const socket1 = createClient(io, \"/\", {\n        transports: [\"websocket\"],\n      });\n      const socket2 = createClient(io, \"/foo\");\n      const socket3 = createClient(io, \"/bar\");\n\n      io.of(\"/bar\").on(\"connection\", (socket) => {\n        socket.disconnect(true);\n      });\n\n      const partialDone = createPartialDone(\n        3,\n        successFn(done, io, socket1, socket2, socket3)\n      );\n\n      socket1.on(\"disconnect\", partialDone);\n      socket2.on(\"disconnect\", partialDone);\n      socket3.on(\"disconnect\", partialDone);\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"returns all socket instances","suites":["utility methods","fetchSockets"],"updatePoint":{"line":70,"column":36},"line":70,"code":"    it(\"returns all socket instances\", async () => {\n      const sockets = await io.fetchSockets();\n      expect(sockets.length).to.eql(3);\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"returns all socket instances in the given room","suites":["utility methods","fetchSockets"],"updatePoint":{"line":75,"column":54},"line":75,"code":"    it(\"returns all socket instances in the given room\", async () => {\n      serverSockets[0].join([\"room1\", \"room2\"]);\n      serverSockets[1].join(\"room1\");\n      serverSockets[2].join(\"room2\");\n      const sockets = await io.in(\"room1\").fetchSockets();\n      expect(sockets.length).to.eql(2);\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"works with a custom adapter","suites":["utility methods","fetchSockets"],"updatePoint":{"line":83,"column":35},"line":83,"code":"    it(\"works with a custom adapter\", async () => {\n      io.adapter(DummyAdapter);\n      const sockets = await io.fetchSockets();\n      expect(sockets.length).to.eql(1);\n      const remoteSocket = sockets[0];\n      expect(remoteSocket.id).to.eql(\"42\");\n      expect(remoteSocket.rooms).to.contain(\"42\", \"room1\");\n      expect(remoteSocket.data).to.eql({ username: \"john\" });\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances join the given room","suites":["utility methods","socketsJoin"],"updatePoint":{"line":95,"column":54},"line":95,"code":"    it(\"makes all socket instances join the given room\", () => {\n      io.socketsJoin(\"room1\");\n      serverSockets.forEach((socket) => {\n        expect(socket.rooms).to.contain(\"room1\");\n      });\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances in a room join the given room","suites":["utility methods","socketsJoin"],"updatePoint":{"line":102,"column":64},"line":102,"code":"    it(\"makes all socket instances in a room join the given room\", () => {\n      serverSockets[0].join([\"room1\", \"room2\"]);\n      serverSockets[1].join(\"room1\");\n      serverSockets[2].join(\"room2\");\n      io.in(\"room1\").socketsJoin(\"room3\");\n      expect(serverSockets[0].rooms).to.contain(\"room3\");\n      expect(serverSockets[1].rooms).to.contain(\"room3\");\n      expect(serverSockets[2].rooms).to.not.contain(\"room3\");\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances leave the given room","suites":["utility methods","socketsLeave"],"updatePoint":{"line":114,"column":55},"line":114,"code":"    it(\"makes all socket instances leave the given room\", () => {\n      serverSockets[0].join([\"room1\", \"room2\"]);\n      serverSockets[1].join(\"room1\");\n      serverSockets[2].join(\"room2\");\n      io.socketsLeave(\"room1\");\n      expect(serverSockets[0].rooms).to.contain(\"room2\");\n      expect(serverSockets[0].rooms).to.not.contain(\"room1\");\n      expect(serverSockets[1].rooms).to.not.contain(\"room1\");\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances in a room leave the given room","suites":["utility methods","socketsLeave"],"updatePoint":{"line":124,"column":65},"line":124,"code":"    it(\"makes all socket instances in a room leave the given room\", () => {\n      serverSockets[0].join([\"room1\", \"room2\"]);\n      serverSockets[1].join(\"room1\");\n      serverSockets[2].join(\"room2\");\n      io.in(\"room2\").socketsLeave(\"room1\");\n      expect(serverSockets[0].rooms).to.contain(\"room2\");\n      expect(serverSockets[0].rooms).to.not.contain(\"room1\");\n      expect(serverSockets[1].rooms).to.contain(\"room1\");\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances disconnect","suites":["utility methods","disconnectSockets"],"updatePoint":{"line":136,"column":45},"line":136,"code":"    it(\"makes all socket instances disconnect\", (done) => {\n      io.disconnectSockets(true);\n\n      const partialDone = createPartialDone(3, done);\n\n      clientSockets[0].on(\"disconnect\", partialDone);\n      clientSockets[1].on(\"disconnect\", partialDone);\n      clientSockets[2].on(\"disconnect\", partialDone);\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"makes all socket instances in a room disconnect","suites":["utility methods","disconnectSockets"],"updatePoint":{"line":146,"column":55},"line":146,"code":"    it(\"makes all socket instances in a room disconnect\", (done) => {\n      serverSockets[0].join([\"room1\", \"room2\"]);\n      serverSockets[1].join(\"room1\");\n      serverSockets[2].join(\"room2\");\n      io.in(\"room2\").disconnectSockets(true);\n\n      const partialDone = createPartialDone(2, () => {\n        clientSockets[1].off(\"disconnect\");\n        done();\n      });\n\n      clientSockets[0].on(\"disconnect\", partialDone);\n      clientSockets[1].on(\"disconnect\", () => {\n        done(new Error(\"should not happen\"));\n      });\n      clientSockets[2].on(\"disconnect\", partialDone);\n    });","file":"utility-methods.ts","skipped":false,"dir":"test"},{"name":"should broadcast","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":71,"column":22},"line":71,"code":"  it(\"should broadcast\", (done) => {\n    const partialDone = createPartialDone(done, 3);\n\n    client.on(\"hello\", partialDone);\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast in a namespace","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":82,"column":37},"line":82,"code":"  it(\"should broadcast in a namespace\", (done) => {\n    client.on(\"hello\", shouldNotHappen(done));\n    clientWSOnly.on(\"hello\", shouldNotHappen(done));\n    clientPollingOnly.on(\"hello\", shouldNotHappen(done));\n    clientCustomNamespace.on(\"hello\", done);\n\n    io.of(\"/custom\").emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast in a dynamic namespace","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":91,"column":45},"line":91,"code":"  it(\"should broadcast in a dynamic namespace\", (done) => {\n    const dynamicNamespace = io.of(/\\/dynamic-\\d+/);\n    const dynamicClient = clientWSOnly.io.socket(\"/dynamic-101\");\n\n    dynamicClient.on(\"connect\", () => {\n      dynamicNamespace.emit(\"hello\");\n    });\n\n    dynamicClient.on(\"hello\", () => {\n      dynamicClient.disconnect();\n      done();\n    });\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast binary content","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":105,"column":37},"line":105,"code":"  it(\"should broadcast binary content\", (done) => {\n    const partialDone = createPartialDone(done, 3);\n\n    client.on(\"hello\", partialDone);\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.emit(\"hello\", Buffer.from([1, 2, 3]));\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast volatile packet with binary content","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":116,"column":58},"line":116,"code":"  it(\"should broadcast volatile packet with binary content\", (done) => {\n    const partialDone = createPartialDone(done, 3);\n\n    client.on(\"hello\", partialDone);\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    // wait to make sure there are no packets being sent for opening the connection\n    setTimeout(() => {\n      io.volatile.emit(\"hello\", Buffer.from([1, 2, 3]));\n    }, 20);\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast in a room","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":130,"column":32},"line":130,"code":"  it(\"should broadcast in a room\", (done) => {\n    const partialDone = createPartialDone(done, 2);\n\n    client.on(\"hello\", shouldNotHappen(done));\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.of(\"/\").sockets.get(clientWSOnly.id)!.join(\"room1\");\n    io.of(\"/\").sockets.get(clientPollingOnly.id)!.join(\"room1\");\n\n    io.to(\"room1\").emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast in multiple rooms","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":144,"column":40},"line":144,"code":"  it(\"should broadcast in multiple rooms\", (done) => {\n    const partialDone = createPartialDone(done, 2);\n\n    client.on(\"hello\", shouldNotHappen(done));\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.of(\"/\").sockets.get(clientWSOnly.id)!.join(\"room1\");\n    io.of(\"/\").sockets.get(clientPollingOnly.id)!.join(\"room2\");\n\n    io.to([\"room1\", \"room2\"]).emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should broadcast in all but a given room","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":158,"column":46},"line":158,"code":"  it(\"should broadcast in all but a given room\", (done) => {\n    const partialDone = createPartialDone(done, 2);\n\n    client.on(\"hello\", partialDone);\n    clientWSOnly.on(\"hello\", partialDone);\n    clientPollingOnly.on(\"hello\", shouldNotHappen(done));\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.of(\"/\").sockets.get(clientWSOnly.id)!.join(\"room1\");\n    io.of(\"/\").sockets.get(clientPollingOnly.id)!.join(\"room2\");\n\n    io.except(\"room2\").emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should work even after leaving room","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":172,"column":41},"line":172,"code":"  it(\"should work even after leaving room\", (done) => {\n    const partialDone = createPartialDone(done, 2);\n\n    client.on(\"hello\", partialDone);\n    clientWSOnly.on(\"hello\", shouldNotHappen(done));\n    clientPollingOnly.on(\"hello\", partialDone);\n    clientCustomNamespace.on(\"hello\", shouldNotHappen(done));\n\n    io.of(\"/\").sockets.get(client.id)!.join(\"room1\");\n    io.of(\"/\").sockets.get(clientPollingOnly.id)!.join(\"room1\");\n\n    io.of(\"/\").sockets.get(clientWSOnly.id)!.join(\"room1\");\n    io.of(\"/\").sockets.get(clientWSOnly.id)!.leave(\"room1\");\n\n    io.to(\"room1\").emit(\"hello\");\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should not crash when socket is disconnected before the upgrade","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":189,"column":69},"line":189,"code":"  it(\"should not crash when socket is disconnected before the upgrade\", (done) => {\n    client.on(\"disconnect\", () => done());\n\n    io.of(\"/\").sockets.get(client.id)!.disconnect();\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should serve static files","suites":["socket.io with uWebSocket.js-based engine"],"updatePoint":{"line":195,"column":31},"line":195,"code":"  it(\"should serve static files\", (done) => {\n    const clientVersion = require(\"socket.io-client/package.json\").version;\n\n    request(`http://localhost:${port}`)\n      .get(\"/socket.io/socket.io.js\")\n      .buffer(true)\n      .end((err, res) => {\n        if (err) return done(err);\n        expect(res.headers[\"content-type\"]).to.be(\n          \"application/javascript; charset=utf-8\"\n        );\n        expect(res.headers.etag).to.be('\"' + clientVersion + '\"');\n        expect(res.headers[\"x-sourcemap\"]).to.be(undefined);\n        expect(res.text).to.match(/engine\\.io/);\n        expect(res.status).to.be(200);\n        done();\n      });\n  });","file":"uws.ts","skipped":false,"dir":"test"},{"name":"should connect if `allowEIO3` is true","suites":["v2 compatibility"],"updatePoint":{"line":7,"column":43},"line":7,"code":"  it(\"should connect if `allowEIO3` is true\", (done) => {\n    const io = new Server(0, {\n      allowEIO3: true,\n    });\n\n    const clientSocket = io_v2.connect(`http://localhost:${getPort(io)}`, {\n      multiplex: false,\n    });\n\n    Promise.all([\n      waitFor(io, \"connection\"),\n      waitFor(clientSocket, \"connect\"),\n    ]).then(([socket]) => {\n      expect((socket as Socket).id).to.eql(clientSocket.id);\n\n      success(done, io, clientSocket);\n    });\n  });","file":"v2-compatibility.ts","skipped":false,"dir":"test"},{"name":"should be able to connect to a namespace with a query","suites":["v2 compatibility"],"updatePoint":{"line":26,"column":59},"line":26,"code":"  it(\"should be able to connect to a namespace with a query\", (done) => {\n    const io = new Server(0, {\n      allowEIO3: true,\n    });\n\n    const clientSocket = io_v2.connect(\n      `http://localhost:${getPort(io)}/the-namespace`,\n      {\n        multiplex: false,\n      }\n    );\n    clientSocket.query = { test: \"123\" };\n\n    Promise.all([\n      waitFor(io.of(\"/the-namespace\"), \"connection\"),\n      waitFor(clientSocket, \"connect\"),\n    ]).then(([socket]) => {\n      expect((socket as Socket).handshake.auth).to.eql({ test: \"123\" });\n\n      success(done, io, clientSocket);\n    });\n  });","file":"v2-compatibility.ts","skipped":false,"dir":"test"},{"name":"should not connect if `allowEIO3` is false (default)","suites":["v2 compatibility"],"updatePoint":{"line":49,"column":58},"line":49,"code":"  it(\"should not connect if `allowEIO3` is false (default)\", (done) => {\n    const io = new Server(0);\n\n    const clientSocket = io_v2.connect(`http://localhost:${getPort(io)}`, {\n      multiplex: false,\n    });\n\n    clientSocket.on(\"connect\", () => {\n      done(new Error(\"should not happen\"));\n    });\n\n    clientSocket.on(\"connect_error\", () => {\n      success(done, io, clientSocket);\n    });\n  });","file":"v2-compatibility.ts","skipped":false,"dir":"test"}]}