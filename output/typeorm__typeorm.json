{"repo":"typeorm/typeorm","url":"https://github.com/typeorm/typeorm","branch":"master","configs":[{"package":"typeorm","lang":"js","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"test if DataSource calls `useDataSource` of the provided entities","suites":["base entity"],"updatePoint":{"line":7,"column":71,"index":315},"line":7,"code":"  it(\"test if DataSource calls `useDataSource` of the provided entities\", async () => {\n    const dataSourceOptions = setupTestingConnections({\n      entities: [User],\n      enabledDrivers: [\"sqlite\"]\n    });\n    if (!dataSourceOptions.length) return;\n    const dataSource = new DataSource(dataSourceOptions[0]);\n    await dataSource.initialize();\n    await dataSource.synchronize(true);\n    await User.save({\n      name: \"Timber Saw\"\n    });\n    const timber = await User.findOneByOrFail({\n      name: \"Timber Saw\"\n    });\n    expect(timber).to.be.eql({\n      id: 1,\n      name: \"Timber Saw\"\n    });\n  });","file":"functional/base-entity/base-entity.test.ts","skipped":false,"dir":"test"},{"name":"withRepository must work properly in transactions","suites":["custom repository"],"updatePoint":{"line":13,"column":55,"index":580},"line":13,"code":"  it(\"withRepository must work properly in transactions\", () => Promise.all(dataSources.map(async dataSource => {\n    const CustomRepository = dataSource.getRepository(User).extend({\n      findOneByName(name) {\n        return this.findOneBy({\n          name\n        });\n      }\n\n    }); // check if custom repository function works\n\n    await CustomRepository.save({\n      name: \"Timber Saw\"\n    });\n    const user = await CustomRepository.findOneByName(\"Timber Saw\");\n    expect(user).to.be.eql({\n      id: 1,\n      name: \"Timber Saw\"\n    }); // now check it in the transaction\n\n    await dataSource.manager.transaction(async transactionalManager => {\n      const transactionalCustomRepository = await transactionalManager.withRepository(CustomRepository);\n      await CustomRepository.save({\n        name: \"Natures Prophet\"\n      });\n      const user = await transactionalCustomRepository.findOneByName(\"Natures Prophet\");\n      expect(user).to.be.eql({\n        id: 2,\n        name: \"Natures Prophet\"\n      });\n    });\n  })));","file":"functional/custom-repository/custom-repository.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in regular arrays","suites":["find options > find operators > ArrayContainedBy"],"updatePoint":{"line":34,"column":43,"index":1290},"line":34,"code":"  it(\"should find entries in regular arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayContainedBy([\"dmitry\", \"olimjon\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }, {\n      id: 3,\n      title: \"Post #3\",\n      authors: [],\n      statuses: []\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayContainedBy([\"olimjon\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }, {\n      id: 3,\n      title: \"Post #3\",\n      authors: [],\n      statuses: []\n    }]);\n  })));","file":"functional/find-options/array-contained-by-operator/array-contained-by-operator.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in enum arrays","suites":["find options > find operators > ArrayContainedBy"],"updatePoint":{"line":80,"column":40,"index":2415},"line":80,"code":"  it(\"should find entries in enum arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayContainedBy([PostStatus.draft, PostStatus.published])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }, {\n      id: 3,\n      title: \"Post #3\",\n      authors: [],\n      statuses: []\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayContainedBy([PostStatus.published])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }, {\n      id: 3,\n      title: \"Post #3\",\n      authors: [],\n      statuses: []\n    }]);\n  })));","file":"functional/find-options/array-contained-by-operator/array-contained-by-operator.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in regular arrays","suites":["find options > find operators > ArrayContains"],"updatePoint":{"line":34,"column":43,"index":1281},"line":34,"code":"  it(\"should find entries in regular arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayContains([\"dmitry\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayContains([\"olimjon\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }]);\n  })));","file":"functional/find-options/array-contains-operator/array-contains-operator.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in enum arrays","suites":["find options > find operators > ArrayContains"],"updatePoint":{"line":70,"column":40,"index":2249},"line":70,"code":"  it(\"should find entries in enum arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayContains([PostStatus.draft])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayContains([PostStatus.published])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }]);\n  })));","file":"functional/find-options/array-contains-operator/array-contains-operator.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in regular arrays","suites":["find options > find operators > ArrayOverlap"],"updatePoint":{"line":34,"column":43,"index":1278},"line":34,"code":"  it(\"should find entries in regular arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayOverlap([\"dmitry\", \"umed\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        authors: ArrayOverlap([\"olimjon\", \"umed\"])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }]);\n  })));","file":"functional/find-options/array-overlap/array-overlap-operator.test.ts","skipped":false,"dir":"test"},{"name":"should find entries in enum arrays","suites":["find options > find operators > ArrayOverlap"],"updatePoint":{"line":70,"column":40,"index":2260},"line":70,"code":"  it(\"should find entries in enum arrays\", () => Promise.all(connections.map(async connection => {\n    await prepareData(connection.manager);\n    const loadedPost1 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayOverlap([PostStatus.draft, PostStatus.unknown])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }]);\n    const loadedPost2 = await connection.manager.find(Post, {\n      where: {\n        statuses: ArrayOverlap([PostStatus.published, PostStatus.unknown])\n      },\n      order: {\n        id: \"asc\"\n      }\n    });\n    loadedPost2.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"dmitry\", \"olimjon\"],\n      statuses: [PostStatus.draft, PostStatus.published]\n    }, {\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"olimjon\"],\n      statuses: [PostStatus.published]\n    }]);\n  })));","file":"functional/find-options/array-overlap/array-overlap-operator.test.ts","skipped":false,"dir":"test"},{"name":"should work without errors","suites":["indices > basic unique index test","unique index"],"updatePoint":{"line":13,"column":34,"index":644},"line":13,"code":"    it(\"should work without errors\", () => Promise.all(connections.map(async connection => {\n      const customer = new Customer();\n      customer.nameEnglish = \"Umed\";\n      customer.nameHebrew = \"Uma\";\n      await connection.manager.save(customer);\n    })));","file":"functional/indices/basic-unique-index-test/basic-unique-index-test.ts","skipped":false,"dir":"test"},{"name":"should work without errors","suites":["indices > embeds index test","embeddeds index"],"updatePoint":{"line":14,"column":34,"index":685},"line":14,"code":"    it(\"should work without errors\", () => Promise.all(connections.map(async connection => {\n      const customer = new Customer();\n      customer.nameEnglish = \"Umed\";\n      customer.nameHebrew = \"Uma\";\n      customer.profile = new Profile();\n      customer.profile.job = \"Developer\";\n      customer.profile.address = \"Anywhere\";\n      await connection.manager.save(customer);\n    })));","file":"functional/indices/embeddeds-index-test/embeddeds-unique-index-test.ts","skipped":false,"dir":"test"},{"name":"should insert default values properly","suites":["json > defaults"],"updatePoint":{"line":15,"column":43,"index":646},"line":15,"code":"  it(\"should insert default values properly\", () => Promise.all(connections.map(async connection => {\n    const post1 = new Post();\n    post1.title = \"Post #1\";\n    await connection.manager.save(post1);\n    const loadedPost1 = await connection.manager.findBy(Post, {\n      title: \"Post #1\"\n    });\n    loadedPost1.should.be.eql([{\n      id: 1,\n      title: \"Post #1\",\n      authors: [\"Dmitry\", \"Olimjon\"],\n      category: {\n        name: \"TypeScript\"\n      },\n      categories: [{\n        name: \"TypeScript\"\n      }]\n    }]);\n    const post2 = new Post();\n    post2.title = \"Post #2\";\n    post2.authors = [`Umed`, `Dmitry`];\n    post2.category = {\n      name: \"JavaScript\"\n    };\n    post2.categories = [{\n      name: \"JavaScript\"\n    }, {\n      name: \"ECMAScript\"\n    }];\n    await connection.manager.save(post2);\n    const loadedPost2 = await connection.manager.findBy(Post, {\n      title: \"Post #2\"\n    });\n    loadedPost2.should.be.eql([{\n      id: 2,\n      title: \"Post #2\",\n      authors: [\"Umed\", \"Dmitry\"],\n      category: {\n        name: \"JavaScript\"\n      },\n      categories: [{\n        name: \"JavaScript\"\n      }, {\n        name: \"ECMAScript\"\n      }]\n    }]);\n  })));","file":"functional/json/jsonb-defaults/jsonb-defaults.test.ts","skipped":false,"dir":"test"}]}