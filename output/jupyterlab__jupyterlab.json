{
    "repo": "jupyterlab/jupyterlab",
    "url": "https://github.com/jupyterlab/jupyterlab",
    "branch": "master",
    "configs": [
        {
            "package": "@jupyterlab/galata",
            "lang": "js",
            "dir": "galata/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/application",
            "lang": "ts",
            "dir": "packages/application/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/apputils",
            "lang": "ts",
            "dir": "packages/apputils/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/cells",
            "lang": "ts",
            "dir": "packages/cells/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/codeeditor",
            "lang": "ts",
            "dir": "packages/codeeditor/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/codemirror",
            "lang": "ts",
            "dir": "packages/codemirror/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/completer",
            "lang": "ts",
            "dir": "packages/completer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/console",
            "lang": "ts",
            "dir": "packages/console/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/coreutils",
            "lang": "ts",
            "dir": "packages/coreutils/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/csvviewer",
            "lang": "ts",
            "dir": "packages/csvviewer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/debugger",
            "lang": "ts",
            "dir": "packages/debugger/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/docmanager",
            "lang": "ts",
            "dir": "packages/docmanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/docprovider",
            "lang": "ts",
            "dir": "packages/docprovider/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/docregistry",
            "lang": "ts",
            "dir": "packages/docregistry/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/documentsearch",
            "lang": "ts",
            "dir": "packages/documentsearch/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/filebrowser",
            "lang": "ts",
            "dir": "packages/filebrowser/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/fileeditor",
            "lang": "ts",
            "dir": "packages/fileeditor/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/imageviewer",
            "lang": "ts",
            "dir": "packages/imageviewer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/inspector",
            "lang": "ts",
            "dir": "packages/inspector/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/logconsole",
            "lang": "ts",
            "dir": "packages/logconsole/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/mainmenu",
            "lang": "ts",
            "dir": "packages/mainmenu/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/nbformat",
            "lang": "ts",
            "dir": "packages/nbformat/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/notebook",
            "lang": "ts",
            "dir": "packages/notebook/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/observables",
            "lang": "ts",
            "dir": "packages/observables/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/outputarea",
            "lang": "ts",
            "dir": "packages/outputarea/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/rendermime",
            "lang": "ts",
            "dir": "packages/rendermime/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/services",
            "lang": "ts",
            "dir": "packages/services/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/settingregistry",
            "lang": "ts",
            "dir": "packages/settingregistry/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/shared-models",
            "lang": "ts",
            "dir": "packages/shared-models/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/statedb",
            "lang": "ts",
            "dir": "packages/statedb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/statusbar",
            "lang": "ts",
            "dir": "packages/statusbar/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/terminal",
            "lang": "ts",
            "dir": "packages/terminal/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/toc",
            "lang": "ts",
            "dir": "packages/toc/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/translation",
            "lang": "ts",
            "dir": "packages/translation/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/ui-components",
            "lang": "ts",
            "dir": "packages/ui-components/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/user",
            "lang": "ts",
            "dir": "packages/user/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jupyterlab/testutils",
            "lang": "ts",
            "dir": "testutils/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "measure  - ",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 41,
                "index": 3557
            },
            "line": 48,
            "code": "    test(`measure ${file} - ${sample + 1}`, async ({\n      baseURL,\n      browserName,\n      page\n    }, testInfo) => {\n      const attachmentCommon = {\n        nSamples: benchmark.nSamples,\n        browser: browserName,\n        file: path.basename(file, '.ipynb'),\n        project: testInfo.project.name\n      };\n      const perf = galata.newPerformanceHelper(page);\n      await page.goto(baseURL + '?reset');\n      await page.click('#filebrowser >> .jp-BreadCrumbs-home');\n      await page.dblclick(`#filebrowser >> text=${tmpPath}`);\n      const openTime = await perf.measure(async () => {\n        // Open the notebook and wait for the spinner\n        await Promise.all([page.waitForSelector('[role=\"main\"] >> .jp-SpinnerContent'), page.dblclick(`#filebrowser >> text=${file}`)]);\n\n        // Wait for spinner to be hidden\n        await page.waitForSelector('[role=\"main\"] >> .jp-SpinnerContent', {\n          state: 'hidden'\n        });\n      });\n\n      // Check the notebook is correctly opened\n      let panel = await page.$('[role=\"main\"] >> .jp-NotebookPanel');\n      // Get only the document node to avoid noise from kernel and debugger in the toolbar\n      let document = await panel.$('.jp-Notebook');\n      expect(await document.screenshot()).toMatchSnapshot(`${file.replace('.', '-')}.png`);\n      testInfo.attachments.push(benchmark.addAttachment({\n        ...attachmentCommon,\n        test: 'open',\n        time: openTime\n      }));\n\n      // Shutdown the kernel to be sure it does not get in our way (especially for the close action)\n      await page.click('li[role=\"menuitem\"]:has-text(\"Kernel\")');\n      await page.click('.lm-Menu ul[role=\"menu\"] >> text=Shut Down All Kernels…');\n      await page.click('button:has-text(\"Shut Down All\") >> nth=-1'); // Click on the last matched button.\n\n      // Open text file\n      const fromTime = await perf.measure(async () => {\n        await page.dblclick(`#filebrowser >> text=${textFile}`);\n        await page.waitForSelector(`div[role=\"main\"] >> .lm-DockPanel-tabBar >> text=${path.basename(textFile)}`);\n      });\n      let editorPanel = page.locator('div[role=\"tabpanel\"]:has-text(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin mole\")');\n      await expect(editorPanel).toBeVisible();\n      testInfo.attachments.push(benchmark.addAttachment({\n        ...attachmentCommon,\n        test: 'switch-from',\n        time: fromTime\n      }));\n\n      // Switch back\n      const toTime = await perf.measure(async () => {\n        await page.click(`div[role=\"main\"] >> .lm-DockPanel-tabBar >> text=${file}`);\n      });\n\n      // Check the notebook is correctly opened\n      panel = await page.$('[role=\"main\"] >> .jp-NotebookPanel');\n      // Get only the document node to avoid noise from kernel and debugger in the toolbar\n      document = await panel.$('.jp-Notebook');\n      expect(await document.screenshot()).toMatchSnapshot(`${file.replace('.', '-')}.png`);\n      testInfo.attachments.push(benchmark.addAttachment({\n        ...attachmentCommon,\n        test: 'switch-to',\n        time: toTime\n      }));\n\n      // Close notebook\n      await page.click('li[role=\"menuitem\"]:has-text(\"File\")');\n      const closeTime = await perf.measure(async () => {\n        await page.click('.lm-Menu ul[role=\"menu\"] >> text=Close Tab');\n        // Revert changes so we don't measure saving\n        const dimissButton = page.locator('button:has-text(\"Discard\")');\n        if (await dimissButton.isVisible({\n          timeout: 50\n        })) {\n          await dimissButton.click();\n        }\n      });\n      editorPanel = page.locator('div[role=\"tabpanel\"]:has-text(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin mole\")');\n      await expect(editorPanel).toBeVisible();\n      testInfo.attachments.push(benchmark.addAttachment({\n        ...attachmentCommon,\n        test: 'close',\n        time: closeTime\n      }));\n    });",
            "file": "benchmark/notebook.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "All commands must have a default label",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 44,
                "index": 267
            },
            "line": 7,
            "code": "test('All commands must have a default label', async ({\n  page\n}, testInfo) => {\n  const commands = await page.evaluate(async () => {\n    const registry = window.jupyterapp.commands;\n    const shortcuts = registry.keyBindings;\n    const commandIds = registry.listCommands();\n\n    // Get more information about the commands\n    const commands = commandIds.filter(id => !id.startsWith('_') && !id.startsWith('@jupyter-widgets')).sort().map(id => {\n      try {\n        return {\n          id,\n          label: registry.label(id),\n          caption: registry.caption(id),\n          shortcuts: [...(shortcuts.find(shortcut => shortcut.command === id)?.keys ?? [])]\n        };\n      } catch (reason) {\n        console.error(reason);\n        return {\n          id,\n          label: '',\n          caption: '',\n          shortcuts: [...(shortcuts.find(shortcut => shortcut.command === id)?.keys ?? [])]\n        };\n      }\n    });\n    return Promise.resolve(commands);\n  });\n  if (!(await fs.pathExists(testInfo.snapshotDir))) {\n    await fs.mkdir(testInfo.snapshotDir);\n  }\n  await fs.writeJSON(testInfo.snapshotPath('commandsList.json'), commands, {\n    encoding: 'utf-8',\n    spaces: 2\n  });\n\n  // All commands must at least define a label\n  const missingLabel = commands.filter(command => !command.label);\n  expect(missingLabel).toEqual([]);\n});",
            "file": "documentation/commands.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use default layout",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 33,
                "index": 407
            },
            "line": 15,
            "code": "  test('should use default layout', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.menu.clickMenuItem('File>New>Terminal');\n    await page.waitForSelector('.jp-Terminal');\n    expect(await page.screenshot()).toMatchSnapshot('default-terminal-position-single.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use default toolbars",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 35,
                "index": 905
            },
            "line": 30,
            "code": "  test('should use default toolbars', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.waitForSelector('div[role=\"main\"] >> text=Lorenz.ipynb');\n\n    // Wait for kernel to settle on idle\n    await page.locator('.jp-DebuggerBugButton[aria-disabled=\"false\"]').waitFor();\n    await page.locator('.jp-Notebook-ExecutionIndicator[data-status=\"idle\"]').waitFor();\n    expect(await page.locator('div[role=\"main\"] >> .jp-NotebookPanel-toolbar').screenshot()).toMatchSnapshot('default-notebook-toolbar.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use default menu bar",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 35,
                "index": 1707
            },
            "line": 49,
            "code": "  test('should use default menu bar', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.click('text=Tabs');\n    await page.waitForSelector('#jp-mainmenu-tabs');\n    expect(await page.screenshot({\n      clip: {\n        x: 0,\n        y: 0,\n        width: 800,\n        height: 200\n      }\n    })).toMatchSnapshot('default-menu-bar.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use default context menu",
            "suites": [],
            "updatePoint": {
                "line": 71,
                "column": 39,
                "index": 2274
            },
            "line": 71,
            "code": "  test('should use default context menu', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.click('text=Lorenz.ipynb', {\n      button: 'right'\n    });\n    await page.hover('ul[role=\"menu\"] >> text=New File');\n    expect(await page.screenshot({\n      clip: {\n        x: 0,\n        y: 0,\n        width: 500,\n        height: 500\n      }\n    })).toMatchSnapshot('default-context-menu.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use customized layout",
            "suites": [],
            "updatePoint": {
                "line": 181,
                "column": 36,
                "index": 5240
            },
            "line": 181,
            "code": "  test('should use customized layout', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.menu.clickMenuItem('File>New>Terminal');\n    await page.waitForSelector('.jp-Terminal');\n    await setSidebarWidth(page, 271, 'right');\n    expect(await page.screenshot()).toMatchSnapshot('customized-terminal-position-single.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use customized toolbars",
            "suites": [],
            "updatePoint": {
                "line": 197,
                "column": 38,
                "index": 5791
            },
            "line": 197,
            "code": "  test('should use customized toolbars', async ({\n    page\n  }) => {\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.waitForSelector('div[role=\"main\"] >> text=Lorenz.ipynb');\n    await page.waitForSelector('text=Python 3 (ipykernel) | Idle');\n    expect(await page.locator('div[role=\"main\"] >> .jp-NotebookPanel-toolbar').screenshot()).toMatchSnapshot('customized-notebook-toolbar.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use customized menu bar",
            "suites": [],
            "updatePoint": {
                "line": 213,
                "column": 38,
                "index": 6454
            },
            "line": 213,
            "code": "  test('should use customized menu bar', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.click('text=Tabs');\n    await page.waitForSelector('#jp-mainmenu-tabs');\n    expect(await page.screenshot({\n      clip: {\n        x: 0,\n        y: 0,\n        width: 800,\n        height: 200\n      }\n    })).toMatchSnapshot('customized-menu-bar.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should use customized context menu",
            "suites": [],
            "updatePoint": {
                "line": 235,
                "column": 42,
                "index": 7027
            },
            "line": 235,
            "code": "  test('should use customized context menu', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n    await setSidebarWidth(page);\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.click('text=Lorenz.ipynb', {\n      button: 'right'\n    });\n    await page.hover('ul[role=\"menu\"] >> text=New File');\n    expect(await page.screenshot({\n      clip: {\n        x: 0,\n        y: 0,\n        width: 500,\n        height: 500\n      }\n    })).toMatchSnapshot('customized-context-menu.png');\n  });",
            "file": "documentation/customization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Kernel capability",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 25,
                "index": 443
            },
            "line": 15,
            "code": "  test('Kernel capability', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n\n    // Wait for kernel to settle on idle\n    await page.locator('.jp-DebuggerBugButton[aria-disabled=\"false\"]').waitFor();\n    await page.locator('.jp-Notebook-ExecutionIndicator[data-status=\"idle\"]').waitFor();\n    expect(await page.screenshot({\n      clip: {\n        x: 1030,\n        y: 62,\n        width: 210,\n        height: 28\n      }\n    })).toMatchSnapshot('debugger_kernel.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Activate",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 16,
                "index": 970
            },
            "line": 34,
            "code": "  test('Activate', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    expect(await page.screenshot({\n      clip: {\n        y: 62,\n        x: 780,\n        width: 210,\n        height: 28\n      }\n    })).toMatchSnapshot('debugger_activate.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Set breakpoint",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 22,
                "index": 1437
            },
            "line": 52,
            "code": "  test('Set breakpoint', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Wait for breakpoint to finish appearing\n    await page.waitForTimeout(150);\n    expect(await page.screenshot({\n      clip: {\n        y: 100,\n        x: 300,\n        width: 300,\n        height: 80\n      }\n    })).toMatchSnapshot('debugger_breakpoint.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight run cell button",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 33,
                "index": 2033
            },
            "line": 74,
            "code": "  test('Highlight run cell button', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    const runButton = await page.waitForSelector('.jp-Toolbar-item >> [data-command=\"runmenu:run\"]');\n\n    // Inject mouse pointer\n    await page.evaluate(([mouse]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse);\n    }, [await positionMouseOver(runButton)]);\n    await runButton.focus();\n    await runButton.hover();\n    expect(await page.screenshot({\n      clip: {\n        y: 62,\n        x: 400,\n        width: 190,\n        height: 60\n      }\n    })).toMatchSnapshot('debugger_run.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Stop on breakpoint",
            "suites": [],
            "updatePoint": {
                "line": 97,
                "column": 26,
                "index": 2687
            },
            "line": 97,
            "code": "  test('Stop on breakpoint', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Don't wait as it will be blocked\n    void page.notebook.runCell(1);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    expect(await page.screenshot({\n      clip: {\n        y: 100,\n        x: 300,\n        width: 300,\n        height: 80\n      }\n    })).toMatchSnapshot('debugger_stop_on_breakpoint.png');\n    await page.click('button[title^=Continue]');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Breakpoints on exception",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 32,
                "index": 3420
            },
            "line": 123,
            "code": "  test('Breakpoints on exception', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await expect(page.locator('button.jp-PauseOnExceptions')).not.toHaveClass(/lm-mod-toggled/);\n    await page.locator('button.jp-PauseOnExceptions').click();\n    const menu = page.locator('.jp-PauseOnExceptions-menu');\n    await expect(menu).toBeVisible();\n    await expect(menu.locator('li.lm-Menu-item')).toHaveCount(3);\n    await expect(menu.locator('li.lm-Menu-item.lm-mod-toggled')).toHaveCount(0);\n    await menu.locator('li div.lm-Menu-itemLabel:text(\"userUnhandled\")').click();\n    await expect(page.locator('button.jp-PauseOnExceptions')).toHaveClass(/lm-mod-toggled/);\n    await page.notebook.enterCellEditingMode(0);\n    const keyboard = page.keyboard;\n    await keyboard.press('Control+A');\n    await keyboard.type('try:\\n1/0\\n', {\n      delay: 100\n    });\n    await keyboard.press('Backspace');\n    await keyboard.type('except:\\n2/0\\n', {\n      delay: 100\n    });\n    void page.notebook.runCell(0);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    expect(await page.screenshot({\n      clip: {\n        y: 110,\n        x: 300,\n        width: 300,\n        height: 80\n      }\n    })).toMatchSnapshot('debugger_stop_on_unhandled_exception.png');\n    await page.click('button[title^=Continue]');\n    await page.notebook.waitForRun(0);\n    await page.locator('button.jp-PauseOnExceptions').click();\n    await expect(menu.locator('li.lm-Menu-item.lm-mod-toggled')).toHaveCount(1);\n    await expect(menu.locator('li:has(div.lm-Menu-itemLabel:text(\"userUnhandled\"))')).toHaveClass(/lm-mod-toggled/);\n    await menu.locator('li div.lm-Menu-itemLabel:text(\"raised\")').click();\n    void page.notebook.runCell(0);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    expect(await page.screenshot({\n      clip: {\n        y: 110,\n        x: 300,\n        width: 300,\n        height: 80\n      }\n    })).toMatchSnapshot('debugger_stop_on_raised_exception.png');\n    await page.click('button[title^=Continue]');\n    await page.click('button[title^=Continue]');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Debugger sidebar",
            "suites": [],
            "updatePoint": {
                "line": 183,
                "column": 24,
                "index": 5752
            },
            "line": 183,
            "code": "  test('Debugger sidebar', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    const sidebar = await page.waitForSelector('[data-id=\"jp-debugger-sidebar\"]');\n    await sidebar.click();\n    await setSidebarWidth(page, 251, 'right');\n\n    // Inject mouse pointer\n    await page.evaluate(([mouse]) => {\n      document.body.insertAdjacentHTML('beforeend', mouse);\n    }, [await positionMouseOver(sidebar, {\n      left: 0.25\n    })]);\n    expect(await page.screenshot({\n      clip: {\n        y: 22,\n        x: 1200,\n        width: 85,\n        height: 160\n      }\n    })).toMatchSnapshot('debugger_sidebar.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Variables panel",
            "suites": [],
            "updatePoint": {
                "line": 208,
                "column": 23,
                "index": 6429
            },
            "line": 208,
            "code": "  test('Variables panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Don't wait as it will be blocked\n    void page.notebook.runCell(1);\n\n    // Wait to be stopped on the breakpoint and the local variables to be displayed\n    await page.debugger.waitForCallStack();\n    await expect(page.locator('select[aria-label=\"Scope\"]')).toHaveValue('Locals');\n    expect(await page.screenshot({\n      clip: {\n        y: 58,\n        x: 998,\n        width: 280,\n        height: 138\n      }\n    })).toMatchSnapshot('debugger_variables.png');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Call Stack panel",
            "suites": [],
            "updatePoint": {
                "line": 234,
                "column": 24,
                "index": 7220
            },
            "line": 234,
            "code": "  test('Call Stack panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Don't wait as it will be blocked\n    void page.notebook.runCell(1);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    await expect(page.locator('[aria-label=\"side panel content\"] >> text=add').first()).toBeVisible();\n\n    // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n    await page.screenshot({\n      clip: {\n        y: 196,\n        x: 998,\n        width: 280,\n        height: 138\n      },\n      path: 'test/documentation/screenshots/debugger-callstack.png'\n    });\n    await page.click('button[title^=Continue]');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Breakpoints panel",
            "suites": [],
            "updatePoint": {
                "line": 265,
                "column": 25,
                "index": 8155
            },
            "line": 265,
            "code": "  test('Breakpoints panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Don't wait as it will be blocked\n    void page.notebook.runCell(1);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    const breakpointsPanel = await page.debugger.getBreakPointsPanel();\n    expect(await breakpointsPanel.innerText()).toMatch(/ipykernel.*\\/\\d+.py/);\n\n    // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n    await page.screenshot({\n      clip: {\n        y: 334,\n        x: 998,\n        width: 280,\n        height: 138\n      },\n      path: 'test/documentation/screenshots/debugger-breakpoints.png'\n    });\n    await page.click('button[title^=Continue]');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Source panel",
            "suites": [],
            "updatePoint": {
                "line": 297,
                "column": 20,
                "index": 9135
            },
            "line": 297,
            "code": "  test('Source panel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.goto(`tree/${tmpPath}`);\n    await createNotebook(page);\n    await page.debugger.switchOn();\n    await page.waitForCondition(() => page.debugger.isOpen());\n    await setSidebarWidth(page, 251, 'right');\n    await setBreakpoint(page);\n\n    // Don't wait as it will be blocked\n    void page.notebook.runCell(1);\n\n    // Wait to be stopped on the breakpoint\n    await page.debugger.waitForCallStack();\n    await expect(page.locator('[aria-label=\"side panel content\"] >> text=Source/tmp/ipykernel_')).toBeVisible();\n\n    // Don't compare screenshot as the kernel id varies\n    // Need to set precisely the path\n    await page.screenshot({\n      clip: {\n        y: 478,\n        x: 998,\n        width: 280,\n        height: 138\n      },\n      path: 'test/documentation/screenshots/debugger-source.png'\n    });\n    await page.click('button[title^=Continue]');\n  });",
            "file": "documentation/debugger.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Export Menu",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 19,
                "index": 401
            },
            "line": 15,
            "code": "  test('Export Menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await setSidebarWidth(page);\n    await page.dblclick('[aria-label=\"File Browser Section\"] >> text=notebooks');\n    await page.dblclick('text=Lorenz.ipynb');\n    await page.waitForSelector('text=Python 3 (ipykernel) | Idle');\n    await page.click('text=File');\n    await page.click('.lm-Menu ul[role=\"menu\"] >> text=Save and Export Notebook As');\n\n    // Wait for Latex renderer\n    // note: requires the a11y/assistive-mml MathJax extension\n    await page.waitForSelector('text=(σ, β, ρ)');\n    expect(await page.screenshot({\n      clip: {\n        y: 5,\n        x: 0,\n        width: 700,\n        height: 700\n      }\n    })).toMatchSnapshot('exporting_menu.png');\n  });",
            "file": "documentation/export_notebook.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Slides",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 14,
                "index": 1142
            },
            "line": 38,
            "code": "  test('Slides', async ({\n    page\n  }) => {\n    await page.goto();\n    await setSidebarWidth(page);\n    await page.locator('[aria-label=\"File Browser Section\"]').getByText('notebooks').dblclick();\n    await page.getByText('Lorenz.ipynb').dblclick();\n    await page.getByText('Python 3 (ipykernel) | Idle').waitFor();\n    await page.getByTitle('Property Inspector').click();\n    await page.locator('.jp-PropertyInspector').getByText('Common Tools').click();\n    await page.locator('.jp-ActiveCellTool').getByText(/# The Lorenz/).waitFor();\n    await page.locator('#jp-MetadataForm-\\\\@jupyterlab\\\\/notebook-extension\\\\:tools_\\\\/slideshow\\\\/slide_type').selectOption({\n      label: 'Slide'\n    });\n    // Wait for Latex renderer\n    await page.getByText('(σ, β, ρ)').waitFor();\n    expect(await page.screenshot({\n      clip: {\n        y: 5,\n        x: 283,\n        width: 997,\n        height: 400\n      }\n    })).toMatchSnapshot('exporting_slide_type.png');\n  });",
            "file": "documentation/export_notebook.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Menu",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 12,
                "index": 399
            },
            "line": 15,
            "code": "  test('Menu', async ({\n    page\n  }) => {\n    await page.goto();\n    await setSidebarWidth(page);\n    await page.click('text=Settings');\n    await page.click('.lm-Menu ul[role=\"menu\"] >> text=Language');\n    expect(await page.screenshot({\n      clip: {\n        y: 5,\n        x: 250,\n        width: 800,\n        height: 600\n      }\n    })).toMatchSnapshot('language_settings.png');\n  });",
            "file": "documentation/internationalization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Confirm language",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 24,
                "index": 799
            },
            "line": 31,
            "code": "  test('Confirm language', async ({\n    page\n  }) => {\n    await page.goto();\n    await setSidebarWidth(page);\n    await page.click('text=Settings');\n    await page.click('.lm-Menu ul[role=\"menu\"] >> text=Language');\n    await page.click('#jp-mainmenu-settings-language >> text=Chinese');\n    expect(await page.screenshot({\n      clip: {\n        y: 200,\n        x: 350,\n        width: 600,\n        height: 300\n      }\n    })).toMatchSnapshot('language_change.png');\n  });",
            "file": "documentation/internationalization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "UI in Chinese",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 21,
                "index": 1268
            },
            "line": 48,
            "code": "  test('UI in Chinese', async ({\n    page\n  }) => {\n    await galata.Mock.freezeContentLastModified(page);\n    await page.goto();\n    await page.click('text=Settings');\n    await page.click('.lm-Menu ul[role=\"menu\"] >> text=Language');\n    await page.click('#jp-mainmenu-settings-language >> text=Chinese');\n    await Promise.all([page.waitForNavigation(), page.waitForSelector('#jupyterlab-splash'), page.click('button:has-text(\"Change and reload\")')]);\n    await page.waitForSelector('#jupyterlab-splash', {\n      state: 'detached'\n    });\n    await page.addStyleTag({\n      content: `.jp-LabShell.jp-mod-devMode {\n        border-top: none;\n      }`\n    });\n\n    // Wait for the launcher to be loaded\n    await page.waitForSelector('text=README.md');\n    await setSidebarWidth(page);\n    expect(await page.screenshot()).toMatchSnapshot('language_chinese.png');\n  });",
            "file": "documentation/internationalization.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Upload directory to server",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 34,
                "index": 303
            },
            "line": 8,
            "code": "  test('Upload directory to server', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadDirectory(path.resolve(__dirname, './upload'), tmpPath);\n\n    // Upload removed existing tmpPath, so we need to get inside\n    await page.dblclick(`text=${tmpPath}`);\n    expect(await page.waitForSelector('text=sub_folder')).toBeTruthy();\n    expect(await page.waitForSelector('text=upload_image.png')).toBeTruthy();\n    expect(await page.waitForSelector('text=upload_notebook.ipynb')).toBeTruthy();\n  });",
            "file": "galata/contents.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "File operations",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 23,
                "index": 806
            },
            "line": 20,
            "code": "  test('File operations', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadFile(path.resolve(__dirname, './upload/upload_image.png'), `${tmpPath}/upload_image.png`);\n    await page.contents.renameFile(`${tmpPath}/upload_image.png`, `${tmpPath}/renamed_image.png`);\n    expect(await page.contents.fileExists(`${tmpPath}/renamed_image.png`)).toEqual(true);\n    await page.filebrowser.openDirectory(tmpPath);\n    expect(await page.filebrowser.getCurrentDirectory()).toEqual(tmpPath);\n    expect(await page.contents.deleteFile(`${tmpPath}/renamed_image.png`)).toEqual(true);\n  });",
            "file": "galata/contents.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Go to home directory",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 28,
                "index": 1410
            },
            "line": 31,
            "code": "  test('Go to home directory', async ({\n    page\n  }) => {\n    expect(await page.filebrowser.openHomeDirectory()).toEqual(true);\n  });",
            "file": "galata/contents.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "File Explorer visibility",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 32,
                "index": 1549
            },
            "line": 36,
            "code": "  test('File Explorer visibility', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadDirectory(path.resolve(__dirname, './upload'), tmpPath);\n    await page.contents.deleteFile(`${tmpPath}/upload_image.png`);\n    expect(await page.filebrowser.isFileListedInBrowser('upload_image.png')).toEqual(false);\n    await page.filebrowser.revealFileInBrowser(`${tmpPath}/sub_folder/upload_image.png`);\n    expect(await page.filebrowser.isFileListedInBrowser('upload_image.png')).toEqual(true);\n  });",
            "file": "galata/contents.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Delete uploads",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 22,
                "index": 2050
            },
            "line": 46,
            "code": "  test('Delete uploads', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.contents.uploadFile(path.resolve(__dirname, './upload/upload_notebook.ipynb'), `${tmpPath}/sub_dir/notebook.ipynb`);\n    expect(await page.contents.deleteFile(`${tmpPath}/sub_dir/notebook.ipynb`)).toEqual(true);\n    expect(await page.contents.deleteDirectory(`${tmpPath}/sub_dir`)).toEqual(true);\n  });",
            "file": "galata/contents.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should have non-default appPath",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 39,
                "index": 378
            },
            "line": 12,
            "code": "  test('should have non-default appPath', async ({\n    page\n  }) => {\n    expect(page.appPath).toEqual(APP_PATH);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should goto the application page and load hook",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 52,
                "index": 515
            },
            "line": 18,
            "code": "test('should goto the application page and load hook', async ({\n  page\n}) => {\n  expect(await page.evaluate(() => typeof window.galata === 'object')).toEqual(true);\n});",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should test if the application is in simple mode",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 54,
                "index": 686
            },
            "line": 23,
            "code": "test('should test if the application is in simple mode', async ({\n  page\n}) => {\n  expect(await page.isInSimpleMode()).toEqual(false);\n});",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should reload the application page and load hook",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 54,
                "index": 825
            },
            "line": 28,
            "code": "test('should reload the application page and load hook', async ({\n  page\n}) => {\n  await page.reload();\n  expect(await page.evaluate(() => typeof window.galata === 'object')).toEqual(true);\n});",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should reset the UI",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 25,
                "index": 990
            },
            "line": 34,
            "code": "test('should reset the UI', async ({\n  page\n}) => {\n  await page.resetUI();\n  expect(await page.menu.isAnyOpen()).toEqual(false);\n  expect(await page.waitForSelector(page.launcherSelector)).toBeTruthy();\n  expect(await page.kernel.isAnyRunning()).toEqual(false);\n  expect(await page.statusbar.isVisible()).toEqual(true);\n  expect(await page.sidebar.isTabOpen('filebrowser')).toEqual(true);\n});",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should toggle simple mode",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 31,
                "index": 1390
            },
            "line": 44,
            "code": "test('should toggle simple mode', async ({\n  page\n}) => {\n  expect(await page.setSimpleMode(true)).toEqual(true);\n  expect(await page.isInSimpleMode()).toEqual(true);\n});",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should listen to JupyterLab dialog",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 42,
                "index": 1915
            },
            "line": 60,
            "code": "  test('should listen to JupyterLab dialog', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      window.galata.on('dialog', d => {\n        // We need to slightly wait before rejecting otherwise\n        // the `locator('.jp-Dialog').waitFor()` is not resolved.\n        setTimeout(() => d?.reject(), 100);\n      });\n    });\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    await Promise.all([page.locator('.jp-Dialog').waitFor(), page.menu.clickMenuItem('File>Save Text As…')]);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(0);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should stop listening to JupyterLab dialog",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 50,
                "index": 2566
            },
            "line": 75,
            "code": "  test('should stop listening to JupyterLab dialog', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      const callback = d => {\n        // We need to slightly wait before rejecting otherwise\n        // the `locator('.jp-Dialog').waitFor()` is not resolved.\n        setTimeout(() => d?.reject(), 100);\n        window.galata.off('dialog', callback);\n      };\n      window.galata.on('dialog', callback);\n    });\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    await Promise.all([page.locator('.jp-Dialog').waitFor(), page.menu.clickMenuItem('File>Save Text As…')]);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(0);\n    await Promise.all([page.locator('.jp-Dialog').waitFor(), page.menu.clickMenuItem('File>Save Text As…')]);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(1);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should listen only once to JupyterLab dialog",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 52,
                "index": 3470
            },
            "line": 94,
            "code": "  test('should listen only once to JupyterLab dialog', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      const callback = d => {\n        // We need to slightly wait before rejecting otherwise\n        // the `locator('.jp-Dialog').waitFor()` is not resolved.\n        setTimeout(() => d?.reject(), 100);\n      };\n      window.galata.once('dialog', callback);\n    });\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    await Promise.all([page.locator('.jp-Dialog').waitFor(), page.menu.clickMenuItem('File>Save Text As…')]);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(0);\n    await Promise.all([page.locator('.jp-Dialog').waitFor(), page.menu.clickMenuItem('File>Save Text As…')]);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(1);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should listen to JupyterLab notification",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 48,
                "index": 4325
            },
            "line": 112,
            "code": "  test('should listen to JupyterLab notification', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      window.galata.on('notification', n => {\n        // We need to slightly wait before dismissing otherwise\n        // the toast is not yet displayed and won't be removed when the notification\n        // is dismissed.\n        setTimeout(() => {\n          void window.jupyterapp.commands.execute('apputils:dismiss-notification', {\n            id: n.id\n          });\n        }, 100);\n      });\n    });\n    await Promise.all([page.locator('.Toastify__toast').waitFor(), page.evaluate(() => {\n      void window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false\n        }\n      });\n    })]);\n    await expect(page.locator('.Toastify__toast')).toHaveCount(0);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should stop listening to JupyterLab notification",
            "suites": [],
            "updatePoint": {
                "line": 137,
                "column": 56,
                "index": 5194
            },
            "line": 137,
            "code": "  test('should stop listening to JupyterLab notification', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      const callback = n => {\n        // We need to slightly wait before dismissing otherwise\n        // the toast is not yet displayed and won't be removed when the notification\n        // is dismissed.\n        setTimeout(() => {\n          void window.jupyterapp.commands.execute('apputils:dismiss-notification', {\n            id: n.id\n          });\n        }, 100);\n        window.galata.off('notification', callback);\n      };\n      window.galata.on('notification', callback);\n    });\n    await Promise.all([page.locator('.Toastify__toast').waitFor(), page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false\n        }\n      });\n    })]);\n    await expect(page.locator('.Toastify__toast')).toHaveCount(0);\n    await Promise.all([page.locator('.Toastify__toast').waitFor(), page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false\n        }\n      });\n    })]);\n    await expect(page.locator('.Toastify__toast')).toHaveCount(1);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should listen only once to JupyterLab notification",
            "suites": [],
            "updatePoint": {
                "line": 173,
                "column": 58,
                "index": 6497
            },
            "line": 173,
            "code": "  test('should listen only once to JupyterLab notification', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      const callback = n => {\n        // We need to slightly wait before dismissing otherwise\n        // the toast is not yet displayed and won't be removed when the notification\n        // is dismissed.\n        setTimeout(() => {\n          void window.jupyterapp.commands.execute('apputils:dismiss-notification', {\n            id: n.id\n          });\n        }, 100);\n      };\n      window.galata.once('notification', callback);\n    });\n    await Promise.all([page.locator('.Toastify__toast').waitFor(), page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false\n        }\n      });\n    })]);\n    await expect(page.locator('.Toastify__toast')).toHaveCount(0);\n    await Promise.all([page.locator('.Toastify__toast').waitFor(), page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false\n        }\n      });\n    })]);\n    await expect(page.locator('.Toastify__toast')).toHaveCount(1);\n  });",
            "file": "galata/jupyterlabpage.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display the launcher",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 33,
                "index": 228
            },
            "line": 6,
            "code": "test('should display the launcher', async ({\n  page\n}) => {\n  expect(await page.waitForSelector(page.launcherSelector)).toBeTruthy();\n});",
            "file": "galata/test.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Announcements requires user agreement",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 43,
                "index": 359
            },
            "line": 13,
            "code": "test('Announcements requires user agreement', async ({\n  page\n}) => {\n  const notifications = await page.notifications;\n  expect(notifications).toHaveLength(1);\n  expect(notifications[0].message).toEqual('Would you like to receive official Jupyter news?\\nPlease read the privacy policy.');\n  expect(notifications[0].options.actions).toHaveLength(3);\n  expect(notifications[0].options.actions[0].label).toEqual('Open privacy policy');\n});",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should check",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 20,
                "index": 1776
            },
            "line": 59,
            "code": "  test('Should check', async ({\n    page\n  }) => {\n    const config = {};\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        fetchNews: 'true'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    const updates = notifications.filter(n => n.options?.data?.tags?.includes('update'));\n    expect(updates).toHaveLength(1);\n    expect(updates[0].message).toEqual(message);\n    expect(updates[0].options.actions[1].label).toEqual(actionLabel);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not check",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 24,
                "index": 2438
            },
            "line": 78,
            "code": "  test('Should not check', async ({\n    page\n  }) => {\n    const config = {};\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        checkForUpdates: false,\n        fetchNews: 'true'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    expect(notifications.filter(n => n.options?.data?.tags?.includes('update'))).toHaveLength(0);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not display notice",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 33,
                "index": 2993
            },
            "line": 95,
            "code": "  test('Should not display notice', async ({\n    page\n  }) => {\n    const config = {\n      jupyterlabapputilsextensionannouncements: {}\n    };\n    config['jupyterlabapputilsextensionannouncements'][id] = {\n      seen: true,\n      dismissed: true\n    };\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        fetchNews: 'true'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    expect(notifications.filter(n => n.options?.data?.tags?.includes('update'))).toHaveLength(0);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should fetch",
            "suites": [],
            "updatePoint": {
                "line": 166,
                "column": 20,
                "index": 4997
            },
            "line": 166,
            "code": "  test('Should fetch', async ({\n    page\n  }) => {\n    const config = {};\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        fetchNews: 'true'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    const news = notifications.filter(n => n.options?.data?.tags?.includes('news'));\n    expect(news).toHaveLength(2);\n    expect(news.filter(n => n.options.data.id === id)[0].message).toEqual(message);\n    expect(news.filter(n => n.options.data.id === id)[0].options.actions[1].label).toEqual(actionLabel);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not fetch",
            "suites": [],
            "updatePoint": {
                "line": 185,
                "column": 24,
                "index": 5721
            },
            "line": 185,
            "code": "  test('Should not fetch', async ({\n    page\n  }) => {\n    const config = {};\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        fetchNews: 'false'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    const news = notifications.filter(n => n.options?.data?.tags?.includes('news'));\n    expect(news).toHaveLength(0);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not display some news",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 36,
                "index": 6269
            },
            "line": 202,
            "code": "  test('Should not display some news', async ({\n    page\n  }) => {\n    const config = {\n      jupyterlabapputilsextensionannouncements: {}\n    };\n    config['jupyterlabapputilsextensionannouncements'][id] = {\n      seen: true,\n      dismissed: true\n    };\n    await galata.Mock.mockConfig(page, config);\n    const settings = [];\n    await galata.Mock.mockSettings(page, settings, {\n      ...galata.DEFAULT_SETTINGS,\n      '@jupyterlab/apputils-extension:notification': {\n        fetchNews: 'true'\n      }\n    });\n    await page.goto();\n    const notifications = await page.notifications;\n    const news = notifications.filter(n => n.options?.data?.tags?.includes('news'));\n    expect(news).toHaveLength(1);\n    expect(news[0].id).not.toEqual(id);\n  });",
            "file": "jupyterlab/announcements.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move down a cell",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 22,
                "index": 744
            },
            "line": 21,
            "code": "test('Move down a cell', async ({\n  page\n}) => {\n  const content = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=2 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Control+Shift+ArrowDown');\n  await expect(page.locator(`${cellSelector} >> nth=3`)).toHaveClass(/jp-mod-active/);\n  expect(await page.locator(`${cellSelector} >> nth=3`).allTextContents()).toEqual(content);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move up a cell",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 20,
                "index": 1197
            },
            "line": 30,
            "code": "test('Move up a cell', async ({\n  page\n}) => {\n  const content = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=2 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Control+Shift+ArrowUp');\n  await expect(page.locator(`${cellSelector} >> nth=1`)).toHaveClass(/jp-mod-active/);\n  expect(await page.locator(`${cellSelector} >> nth=1`).allTextContents()).toEqual(content);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move down two cells with first active",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 43,
                "index": 1671
            },
            "line": 39,
            "code": "test('Move down two cells with first active', async ({\n  page\n}) => {\n  const content1 = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  const content2 = await page.locator(`${cellSelector} >> nth=3`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=3 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Shift+ArrowUp');\n  await page.keyboard.press('Control+Shift+ArrowDown');\n  await expect(page.locator(`${cellSelector} >> nth=3`)).toHaveClass(/jp-mod-active/);\n  await expect(page.locator(`${cellSelector} >> nth=4`)).toHaveClass(/jp-mod-selected/);\n  expect(await page.locator(`${cellSelector} >> nth=3`).allTextContents()).toEqual(content1);\n  expect(await page.locator(`${cellSelector} >> nth=4`).allTextContents()).toEqual(content2);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move up two cells with first active",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 41,
                "index": 2461
            },
            "line": 52,
            "code": "test('Move up two cells with first active', async ({\n  page\n}) => {\n  const content1 = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  const content2 = await page.locator(`${cellSelector} >> nth=3`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=3 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Shift+ArrowUp');\n  await page.keyboard.press('Control+Shift+ArrowUp');\n  await expect(page.locator(`${cellSelector} >> nth=1`)).toHaveClass(/jp-mod-active/);\n  await expect(page.locator(`${cellSelector} >> nth=2`)).toHaveClass(/jp-mod-selected/);\n  expect(await page.locator(`${cellSelector} >> nth=1`).allTextContents()).toEqual(content1);\n  expect(await page.locator(`${cellSelector} >> nth=2`).allTextContents()).toEqual(content2);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move down two cells with last active",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 42,
                "index": 3250
            },
            "line": 65,
            "code": "test('Move down two cells with last active', async ({\n  page\n}) => {\n  const content1 = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  const content2 = await page.locator(`${cellSelector} >> nth=3`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=2 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Shift+ArrowDown');\n  await page.keyboard.press('Control+Shift+ArrowDown');\n  await expect(page.locator(`${cellSelector} >> nth=3`)).toHaveClass(/jp-mod-selected/);\n  await expect(page.locator(`${cellSelector} >> nth=4`)).toHaveClass(/jp-mod-active/);\n  expect(await page.locator(`${cellSelector} >> nth=3`).allTextContents()).toEqual(content1);\n  expect(await page.locator(`${cellSelector} >> nth=4`).allTextContents()).toEqual(content2);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move up two cells with last active",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 40,
                "index": 4041
            },
            "line": 78,
            "code": "test('Move up two cells with last active', async ({\n  page\n}) => {\n  const content1 = await page.locator(`${cellSelector} >> nth=2`).allTextContents();\n  const content2 = await page.locator(`${cellSelector} >> nth=3`).allTextContents();\n  await page.locator(`${cellSelector} >> nth=2 >> .jp-InputArea-prompt`).click();\n  await page.keyboard.press('Shift+ArrowDown');\n  await page.keyboard.press('Control+Shift+ArrowDown');\n  await expect(page.locator(`${cellSelector} >> nth=3`)).toHaveClass(/jp-mod-selected/);\n  await expect(page.locator(`${cellSelector} >> nth=4`)).toHaveClass(/jp-mod-active/);\n  expect(await page.locator(`${cellSelector} >> nth=3`).allTextContents()).toEqual(content1);\n  expect(await page.locator(`${cellSelector} >> nth=4`).allTextContents()).toEqual(content2);\n});",
            "file": "jupyterlab/cells-motion.spec.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Show Collapser Unselected; showHCB",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 42,
                "index": 795
            },
            "line": 23,
            "code": "  test('Show Collapser Unselected; showHCB', async ({\n    page\n  }) => {\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('showHCB_heading_unselected.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Show Collapser Selected; showHCB",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 40,
                "index": 987
            },
            "line": 28,
            "code": "  test('Show Collapser Selected; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('showHCB_heading_selected.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Collapse Heading; showHCB",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 33,
                "index": 1210
            },
            "line": 34,
            "code": "  test('Collapse Heading; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('showHCB_collapse_heading.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Expand Heading via Collapser Button; showHCB",
            "suites": [],
            "updatePoint": {
                "line": 41,
                "column": 52,
                "index": 1524
            },
            "line": 41,
            "code": "  test('Expand Heading via Collapser Button; showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('showHCB_expand_heading_via_collapser.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Show Collapser Unselected; no_showHCB",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 45,
                "index": 2475
            },
            "line": 69,
            "code": "  test('Show Collapser Unselected; no_showHCB', async ({\n    page\n  }) => {\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('no_showHCB_heading_unselected.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Show Collapser Selected; no_showHCB",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 43,
                "index": 2673
            },
            "line": 74,
            "code": "  test('Show Collapser Selected; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getCell(0)).screenshot()).toMatchSnapshot('no_showHCB_heading_selected.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Collapse Heading; no_showHCB",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 36,
                "index": 2902
            },
            "line": 80,
            "code": "  test('Collapse Heading; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('no_showHCB_collapse_heading.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Expand Heading via Collapser Button; no_showHCB",
            "suites": [],
            "updatePoint": {
                "line": 87,
                "column": 55,
                "index": 3222
            },
            "line": 87,
            "code": "  test('Expand Heading via Collapser Button; no_showHCB', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    await page.click('text=# Heading 1Heading 1¶ >> button');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('no_showHCB_expand_heading_via_collapser.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Jump to Previous Header",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 31,
                "index": 4277
            },
            "line": 114,
            "code": "  test('Jump to Previous Header', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('jump_previous_header.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Collapse Previous Header",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 32,
                "index": 4549
            },
            "line": 121,
            "code": "  test('Collapse Previous Header', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('collapse_previous_header.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Collapse Previous Headers",
            "suites": [],
            "updatePoint": {
                "line": 129,
                "column": 33,
                "index": 4870
            },
            "line": 129,
            "code": "  test('Collapse Previous Headers', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('collapse_previous_headers.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "ReExpand Headers 01",
            "suites": [],
            "updatePoint": {
                "line": 139,
                "column": 27,
                "index": 5274
            },
            "line": 139,
            "code": "  test('ReExpand Headers 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('a');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_01.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "ReExpand Headers 02",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 27,
                "index": 5887
            },
            "line": 154,
            "code": "  test('ReExpand Headers 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('ArrowRight');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_02.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "ReExpand Headers 03",
            "suites": [],
            "updatePoint": {
                "line": 166,
                "column": 27,
                "index": 6374
            },
            "line": 166,
            "code": "  test('ReExpand Headers 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowUp');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_03a.png');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    await page.keyboard.press('ArrowRight');\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('reexpand_headers_03b.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Below 01",
            "suites": [],
            "updatePoint": {
                "line": 183,
                "column": 27,
                "index": 7157
            },
            "line": 183,
            "code": "  test('Add Header Below 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 3');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(2);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_01.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Below 02",
            "suites": [],
            "updatePoint": {
                "line": 198,
                "column": 27,
                "index": 7753
            },
            "line": 198,
            "code": "  test('Add Header Below 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 3');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(0);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_02.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Below 03",
            "suites": [],
            "updatePoint": {
                "line": 213,
                "column": 27,
                "index": 8358
            },
            "line": 213,
            "code": "  test('Add Header Below 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('ArrowUp');\n    await page.keyboard.press('ArrowLeft');\n    await page.keyboard.press('Shift+B');\n    await page.waitForTimeout(200);\n    await page.keyboard.type('Heading 1.2');\n    await page.keyboard.press('Shift+Enter');\n    await page.notebook.selectCells(2);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_below_03.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Above 01",
            "suites": [],
            "updatePoint": {
                "line": 230,
                "column": 27,
                "index": 9044
            },
            "line": 230,
            "code": "  test('Add Header Above 01', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(6);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_01.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Above 02",
            "suites": [],
            "updatePoint": {
                "line": 240,
                "column": 27,
                "index": 9425
            },
            "line": 240,
            "code": "  test('Add Header Above 02', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(4);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_02.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Add Header Above 03",
            "suites": [],
            "updatePoint": {
                "line": 250,
                "column": 27,
                "index": 9806
            },
            "line": 250,
            "code": "  test('Add Header Above 03', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(3);\n    await page.keyboard.press('Shift+A');\n    await page.waitForTimeout(200);\n    expect(await (await page.notebook.getNotebookInPanel()).screenshot()).toMatchSnapshot('add_header_above_03.png');\n  });",
            "file": "jupyterlab/collapsible-headings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open completer on notebook",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 36,
                "index": 487
            },
            "line": 15,
            "code": "    test('Open completer on notebook', async ({\n      page\n    }) => {\n      await page.notebook.setCell(0, 'code', 'option_1 = 1\\n' + 'option_2 = lambda x: x\\n' + 'option_3 = int');\n      await page.notebook.runCell(0, true);\n      await page.notebook.addCell('code', 'option');\n      await page.notebook.enterCellEditingMode(1);\n\n      // we need to wait until the completer gets bound to the cell after entering it\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      const imageName = 'completer.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Show documentation panel",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 34,
                "index": 1438
            },
            "line": 37,
            "code": "    test('Show documentation panel', async ({\n      page,\n      tmpPath\n    }) => {\n      const scriptName = 'completer_panel.py';\n      await page.contents.uploadFile(path.resolve(__dirname, `./notebooks/${scriptName}`), `${tmpPath}/${scriptName}`);\n      await galata.Mock.mockSettings(page, [], {\n        ...galata.DEFAULT_SETTINGS,\n        '@jupyterlab/completer-extension:manager': {\n          showDocumentationPanel: true\n        }\n      });\n      await page.notebook.save();\n      await page.goto();\n      await page.notebook.openByPath(fileName);\n      await page.notebook.setCell(0, 'code', 'from completer_panel import option_1, option_2');\n      await page.notebook.runCell(0, true);\n      await page.notebook.addCell('code', 'option');\n      await page.notebook.enterCellEditingMode(1);\n\n      // we need to wait until the completer gets bound to the cell after entering it\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.waitForSelector('.jp-Completer-loading-bar');\n      await page.waitForSelector('.jp-Completer-loading-bar', {\n        state: 'detached'\n      });\n      const imageName = 'completer-with-doc-panel.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Token completions show up without running the cell when in the same cell",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 82,
                "index": 3085
            },
            "line": 75,
            "code": "    test('Token completions show up without running the cell when in the same cell', async ({\n      page\n    }) => {\n      await page.notebook.setCell(0, 'code', 'option_1 = 1\\n' + 'option_2 = lambda x: x\\n' + 'option_3 = int\\n' + 'option');\n      await page.notebook.enterCellEditingMode(0);\n      // move to the end of cell\n      await page.keyboard.press('PageDown');\n      await page.keyboard.press('End');\n\n      // we need to wait until the completer gets bound to the cell after entering it\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      const imageName = 'token-completer.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Filter notebook completer suggestions by typing",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 57,
                "index": 4099
            },
            "line": 98,
            "code": "    test('Filter notebook completer suggestions by typing', async ({\n      page\n    }) => {\n      // test against https://github.com/jupyterlab/jupyterlab/issues/11377\n\n      // `getopt` did not change much in many years, it should be stable\n      await page.notebook.setCell(0, 'code', 'import getopt');\n      await page.notebook.runCell(0, true);\n      await page.notebook.addCell('code', 'getopt.');\n      await page.notebook.enterCellEditingMode(1);\n\n      // we need to wait until the completer gets bound to the cell after entering it\n      await page.waitForTimeout(50);\n      await page.keyboard.press('Tab');\n      let completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.press('Escape');\n      await page.waitForTimeout(50);\n      await expect(completer).toBeHidden();\n      await page.keyboard.press('Tab');\n      completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.type('g', {\n        delay: 50\n      });\n      const imageName = 'completer-filter.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open completer on console",
            "suites": [],
            "updatePoint": {
                "line": 140,
                "column": 35,
                "index": 5777
            },
            "line": 140,
            "code": "    test('Open completer on console', async ({\n      page\n    }) => {\n      const completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      const imageName = 'completer-console.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Filter console completer suggestions by typing",
            "suites": [],
            "updatePoint": {
                "line": 148,
                "column": 56,
                "index": 6087
            },
            "line": 148,
            "code": "    test('Filter console completer suggestions by typing', async ({\n      page\n    }) => {\n      const completer = page.locator(COMPLETER_SELECTOR);\n      await completer.waitFor();\n      await page.keyboard.type('g', {\n        delay: 10\n      });\n      const imageName = 'completer-console-filter.png';\n      expect(await completer.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/completer.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open file browser context menu on folder",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 48,
                "index": 1421
            },
            "line": 46,
            "code": "  test('Open file browser context menu on folder', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.filebrowser.refresh();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFolderName}\")`, {\n      button: 'right'\n    });\n    // Context menu should be available\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = 'folder.png';\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open file browser context menu on file",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 46,
                "index": 2010
            },
            "line": 61,
            "code": "  test('Open file browser context menu on file', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFileName}\")`, {\n      button: 'right'\n    });\n    // Context menu should be available\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = 'file.png';\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open file browser context menu on notebook with kernel",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 62,
                "index": 2573
            },
            "line": 75,
            "code": "  test('Open file browser context menu on notebook with kernel', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${testNotebook}`);\n    // Wait for kernel to be idle\n    expect(await page.waitForSelector(`#jp-main-statusbar >> text=Idle`)).toBeTruthy();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testNotebook}\")`, {\n      button: 'right'\n    });\n    // Context menu should be available\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = 'running-notebook.png';\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open file browser context submenu open with",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 51,
                "index": 3221
            },
            "line": 91,
            "code": "  test('Open file browser context submenu open with', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.click(`.jp-DirListing-item span:has-text(\"${testFileName}\")`, {\n      button: 'right'\n    });\n    // Context menu should be available\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    await page.hover('text=Open With');\n    await page.waitForSelector('.lm-Menu li[role=\"menuitem\"]:has-text(\"Editor\")');\n    const imageName = `file-openwith.png`;\n    // Get the last menu -> will be submenu\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open tab context menu",
            "suites": [],
            "updatePoint": {
                "line": 108,
                "column": 29,
                "index": 3927
            },
            "line": 108,
            "code": "  test('Open tab context menu', async ({\n    page\n  }) => {\n    await page.click('div[role=\"main\"] >> text=Launcher', {\n      button: 'right'\n    });\n    // Context menu should be available\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = `tab-launcher.png`;\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open notebook tab context menu",
            "suites": [],
            "updatePoint": {
                "line": 132,
                "column": 40,
                "index": 4635
            },
            "line": 132,
            "code": "    test('Open notebook tab context menu', async ({\n      page\n    }) => {\n      await page.click('div[role=\"main\"] >> text=simple_notebook.ipynb', {\n        button: 'right'\n      });\n      // Context menu should be available\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `tab-notebook.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open context on markdown cell",
            "suites": [],
            "updatePoint": {
                "line": 144,
                "column": 39,
                "index": 5082
            },
            "line": 144,
            "code": "    test('Open context on markdown cell', async ({\n      page\n    }) => {\n      await page.click('text=Test Notebook¶', {\n        button: 'right'\n      });\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `notebook-md.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open context on code cell",
            "suites": [],
            "updatePoint": {
                "line": 155,
                "column": 35,
                "index": 5455
            },
            "line": 155,
            "code": "    test('Open context on code cell', async ({\n      page\n    }) => {\n      await page.click('text=from IPython.display import Image', {\n        button: 'right'\n      });\n      expect(await page.menu.isAnyOpen()).toBe(true);\n      const imageName = `notebook-code.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName);\n    });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open file editor context menu",
            "suites": [],
            "updatePoint": {
                "line": 167,
                "column": 37,
                "index": 5857
            },
            "line": 167,
            "code": "  test('Open file editor context menu', async ({\n    page\n  }) => {\n    await page.sidebar.openTab(filebrowserId);\n    expect(await page.sidebar.isTabOpen(filebrowserId)).toBeTruthy();\n    await page.dblclick(`span:has-text(\"${testFileName}\")`);\n    await page.click('text=# Title', {\n      button: 'right'\n    });\n    expect(await page.menu.isAnyOpen()).toBe(true);\n    const imageName = `fileeditor.png`;\n    const menu = await page.menu.getOpenMenu();\n    expect(await menu.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/contextmenu.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Launch Screen",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 21,
                "index": 216
            },
            "line": 6,
            "code": "  test('Launch Screen', async ({\n    page\n  }) => {\n    const imageName = 'launch.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });",
            "file": "jupyterlab/general.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Enter Simple Mode",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 25,
                "index": 392
            },
            "line": 12,
            "code": "  test('Enter Simple Mode', async ({\n    page\n  }) => {\n    await page.setSimpleMode(true);\n    expect(await page.isInSimpleMode()).toEqual(true);\n    const imageName = 'simple-mode.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/general.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Leave Simple Mode",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 25,
                "index": 650
            },
            "line": 20,
            "code": "  test('Leave Simple Mode', async ({\n    page\n  }) => {\n    await page.goto(page.url().replace('/lab', '/doc'));\n    await page.setSimpleMode(false);\n    expect(await page.isInSimpleMode()).toEqual(false);\n  });",
            "file": "jupyterlab/general.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Toggle Dark theme",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 25,
                "index": 862
            },
            "line": 27,
            "code": "  test('Toggle Dark theme', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    const imageName = 'dark-theme.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });",
            "file": "jupyterlab/general.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Toggle Light theme",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 26,
                "index": 1080
            },
            "line": 34,
            "code": "  test('Toggle Light theme', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    await page.theme.setLightTheme();\n    expect(await page.theme.getTheme()).toEqual('JupyterLab Light');\n  });",
            "file": "jupyterlab/general.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Switch back and forth to reference page",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 45,
                "index": 208
            },
            "line": 7,
            "code": "test('Switch back and forth to reference page', async ({\n  page\n}) => {\n  // The goal is to test switching back and forth with a tab containing an iframe\n  const notebookFilename = 'test-switch-doc-notebook';\n  const cellContent = '# First cell';\n  await page.notebook.createNew(notebookFilename);\n  await page.notebook.setCell(0, 'markdown', cellContent);\n  await page.menu.clickMenuItem('Help>Jupyter Reference');\n  await expect(page.frameLocator('iframe[src=\"https://jupyter.org/documentation\"]').locator('h1').first()).toHaveText('Jupyter Project Documentation#');\n  await page.activity.activateTab(notebookFilename);\n  await page.locator('.jp-MarkdownCell .jp-InputArea-editor').waitFor();\n  await expect(page.locator('.jp-MarkdownCell .jp-InputArea-editor')).toHaveText(cellContent);\n});",
            "file": "jupyterlab/help.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not ask kernel when creating notebook from launcher",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 68,
                "index": 292
            },
            "line": 7,
            "code": "    test('Should not ask kernel when creating notebook from launcher', async ({\n      page\n    }) => {\n      await Promise.all([page.getByRole('tabpanel', {\n        name: 'Launcher'\n      }).waitFor({\n        state: 'detached'\n      }), page.getByTitle('Python 3 (ipykernel)').nth(1).click()]);\n      await expect.soft(page.locator('.jp-Dialog')).toHaveCount(0);\n      await expect(page.getByTitle('Switch kernel')).toHaveText('Python 3 (ipykernel)');\n    });",
            "file": "jupyterlab/kernel.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should remember kernel auto start for notebook",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 56,
                "index": 740
            },
            "line": 18,
            "code": "    test('Should remember kernel auto start for notebook', async ({\n      page\n    }) => {\n      await page.menu.clickMenuItem('File>New>Notebook');\n\n      // Open a notebook without selecting a kernel\n      await page.locator('.jp-Dialog').getByRole('button', {\n        name: 'No Kernel'\n      }).click();\n      await expect.soft(page.getByTitle('Switch kernel')).toHaveText('No Kernel');\n      await Promise.all([page.getByRole('tab', {\n        name: 'Untitled.ipynb'\n      }).waitFor({\n        state: 'detached'\n      }), page.menu.clickMenuItem('File>Close Tab')]);\n\n      // Open the same notebook selecting and turning on auto start\n      await page.filebrowser.open('Untitled.ipynb');\n      await page.locator('.jp-Dialog').getByText('Always start the preferred kernel').click();\n      await page.locator('.jp-Dialog').getByRole('button', {\n        name: 'Select'\n      }).click();\n      await expect.soft(page.getByTitle('Switch kernel')).toHaveText('Python 3 (ipykernel)');\n      await page.menu.clickMenuItem('File>Close and Shut Down Notebook');\n      await Promise.all([page.getByRole('tab', {\n        name: 'Untitled.ipynb'\n      }).waitFor({\n        state: 'detached'\n      }), page.locator('.jp-Dialog').getByRole('button', {\n        name: 'Ok'\n      }).click()]);\n\n      // Open the same notebook and check it turns on the kernel\n      await page.filebrowser.open('Untitled.ipynb');\n      await expect(page.getByTitle('Switch kernel')).toHaveText('Python 3 (ipykernel)');\n    });",
            "file": "jupyterlab/kernel.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should request kernel selection when executing a cell for notebook without kernel",
            "suites": [],
            "updatePoint": {
                "line": 54,
                "column": 91,
                "index": 2271
            },
            "line": 54,
            "code": "    test('Should request kernel selection when executing a cell for notebook without kernel', async ({\n      page\n    }) => {\n      await page.menu.clickMenuItem('File>New>Notebook');\n\n      // Open a notebook without selecting a kernel\n      await page.locator('.jp-Dialog').getByRole('button', {\n        name: 'No Kernel'\n      }).click();\n      await expect.soft(page.getByTitle('Switch kernel')).toHaveText('No Kernel');\n\n      // Request cell execution\n      await page.menu.clickMenuItem('Run>Run Selected Cell');\n      await page.locator('.jp-Dialog').getByRole('button', {\n        name: 'Select Kernel',\n        exact: true\n      }).click();\n      await expect(page.getByTitle('Switch kernel')).toHaveText('Python 3 (ipykernel)');\n    });",
            "file": "jupyterlab/kernel.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not ask kernel when creating console from launcher",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 67,
                "index": 3035
            },
            "line": 75,
            "code": "    test('Should not ask kernel when creating console from launcher', async ({\n      page\n    }) => {\n      await Promise.all([page.getByRole('tabpanel', {\n        name: 'Launcher'\n      }).waitFor({\n        state: 'detached'\n      }), page.getByTitle('Python 3 (ipykernel)').nth(2).click()]);\n      await expect.soft(page.locator('.jp-Dialog')).toHaveCount(0);\n      await expect(page.getByTitle('Change kernel for Console 1')).toHaveText('Python 3 (ipykernel) | Idle');\n    });",
            "file": "jupyterlab/kernel.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should ask for kernel when creating console from menu",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 63,
                "index": 3511
            },
            "line": 86,
            "code": "    test('Should ask for kernel when creating console from menu', async ({\n      page\n    }) => {\n      await page.menu.clickMenuItem('File>New>Console');\n      await page.locator('.jp-Dialog').getByRole('button', {\n        name: 'Select Kernel',\n        exact: true\n      }).click();\n      await expect(page.getByTitle('Change kernel for Console 1')).toHaveText('Python 3 (ipykernel) | Idle');\n    });",
            "file": "jupyterlab/kernel.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display the form",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 31,
                "index": 3509
            },
            "line": 121,
            "code": "  test('should display the form', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Activate the property inspector.\n    await activatePropertyInspector(page);\n\n    // Retrieves the form from its header's text, it should be collapsed.\n    const form = page.locator('.jp-NotebookTools .jp-Collapse', {\n      hasText: 'Extension metadata'\n    });\n    expect(await form.screenshot()).toMatchSnapshot('metadata-collapsed-form.png');\n    await expect(form.locator('.jp-Collapse-contents.lm-mod-hidden')).toHaveCount(1);\n\n    // Expand the form.\n    await form.click();\n    await expect(form.locator('.jp-Collapse-contents.lm-mod-hidden')).toHaveCount(0);\n\n    // Get the formGroup (form content).\n    const formGroup = form.locator('.jp-Collapse-contents .jp-MetadataForm fieldset > .form-group');\n\n    // There should be only one field in formGroup, with correct title and description.\n    await expect(formGroup).toHaveCount(1);\n    await expect(formGroup.locator('.jp-FormGroup-compactTitle > .jp-FormGroup-fieldLabel')).toHaveText('Basic metadata');\n    await expect(formGroup.locator('.jp-FormGroup-compactTitle > .jp-FormGroup-description')).toHaveText('Basic metadata description');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should fill metadata and display errors",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 47,
                "index": 4844
            },
            "line": 152,
            "code": "  test('should fill metadata and display errors', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      form,\n      formGroup\n    } = await getFormGroup(page);\n\n    // Error should be displayed as required field is empty.\n    await expect(formGroup.locator('.validationErrors')).not.toBeEmpty();\n    expect(await form.screenshot()).toMatchSnapshot('metadata-required-missing.png');\n\n    // Relevant metadata should be empty.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['basic-metadata']).toBeUndefined();\n\n    // Filling the form.\n    await formGroup.locator('input').fill('abc');\n\n    // Metadata should be filled, and error not displayed anymore.\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['basic-metadata']).toBe('abc');\n    await expect(formGroup.locator('.validationErrors')).toBeEmpty();\n    expect(await form.screenshot()).toMatchSnapshot('metadata-required-filled.png');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should fill nested metadata and remove the all tree if empty value",
            "suites": [],
            "updatePoint": {
                "line": 209,
                "column": 74,
                "index": 6630
            },
            "line": 209,
            "code": "  test('should fill nested metadata and remove the all tree if empty value', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      formGroup\n    } = await getFormGroup(page);\n\n    // Metadata should be empty.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']).toBeUndefined();\n\n    // Replace the default value by 0, should write in metadata.\n    await formGroup.locator('input').last().fill('0');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']['level2']['nested']).toBe(0);\n\n    // Empty the field, should remove the metadata tree.\n    await formGroup.locator('input').last().fill('');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']).toBeUndefined();\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should remove only the empty metadata",
            "suites": [],
            "updatePoint": {
                "line": 237,
                "column": 45,
                "index": 7543
            },
            "line": 237,
            "code": "  test('should remove only the empty metadata', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      formGroup\n    } = await getFormGroup(page);\n\n    // Metadata should be empty.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']).toBeUndefined();\n\n    // Set the first level nested metadata.\n    await formGroup.locator('input').first().fill('1');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']['nested']).toBe(1);\n    expect(cellMetadata['level1']['level2']).toBeUndefined();\n\n    // Set the second level nested metadata.\n    await formGroup.locator('input').last().fill('1');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']['level2']['nested']).toBe(1);\n\n    // If the value of level2 is deleted, only the level2 metadata should be removed.\n    await formGroup.locator('input').last().fill('');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['level1']['nested']).toBe(1);\n    expect(cellMetadata['level1']['level2']).toBeUndefined();\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should not fill metadata with \"writeDefault\" flag to false",
            "suites": [],
            "updatePoint": {
                "line": 304,
                "column": 66,
                "index": 9670
            },
            "line": 304,
            "code": "  test('should not fill metadata with \"writeDefault\" flag to false', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      formGroup\n    } = await getFormGroup(page);\n\n    // Metadata should contains written default value.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-written']).toBe(1);\n\n    // Empty value should remove the metadata.\n    await formGroup.locator('input').first().fill('');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-written']).toBeUndefined();\n\n    // Fill the first one with default should be written in metadata.\n    await formGroup.locator('input').first().fill('1');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-written']).toBe(1);\n\n    // Fill the second one with non default value should write metadata.\n    await formGroup.locator('input').last().fill('0');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-not-written']).toBe(0);\n\n    // Fill the second one with default value should remove the metadata.\n    await formGroup.locator('input').last().fill('1');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-not-written']).toBeUndefined();\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should not display the modified field",
            "suites": [],
            "updatePoint": {
                "line": 342,
                "column": 45,
                "index": 11084
            },
            "line": 342,
            "code": "  test('should not display the modified field', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      formGroup\n    } = await getFormGroup(page);\n\n    // Metadata should contains written default value.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-written']).toBe(1);\n\n    // Fill the first one with default should be written in metadata.\n    await formGroup.locator('input').first().fill('2');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['default-written']).toBe(2);\n    await expect(formGroup.locator('.jp-FormGroup-default')).toHaveCount(0);\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display the modified field",
            "suites": [],
            "updatePoint": {
                "line": 389,
                "column": 41,
                "index": 12467
            },
            "line": 389,
            "code": "  test('should display the modified field', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      formGroup\n    } = await getFormGroup(page);\n\n    // Metadata should contains the default value.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['value-with-default']).toBe(1);\n\n    // Fill the field with non default value should display that value is different from default.\n    await formGroup.locator('input').first().fill('2');\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['value-with-default']).toBe(2);\n    await expect(formGroup.locator('.jp-FormGroup-default')).toHaveCount(1);\n    await expect(formGroup.locator('.jp-FormGroup-default')).toContainText('1');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should manage cell and notebook metadata in the same form",
            "suites": [],
            "updatePoint": {
                "line": 447,
                "column": 65,
                "index": 14263
            },
            "line": 447,
            "code": "  test('should manage cell and notebook metadata in the same form', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM\n    const {\n      form,\n      formGroup\n    } = await getFormGroup(page);\n\n    // There should be 2 fields displayed.\n    await expect(formGroup).toHaveCount(2);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-level.png');\n\n    // Metadata should be empty.\n    let cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['cell-metadata']).toBeUndefined();\n    let nbMetadata = await getNotebookMetadata(page);\n    expect(nbMetadata['nb-nested']).toBeUndefined();\n\n    // Fill the first level nested metadata.\n    await formGroup.locator('input').first().fill('Cell input');\n    await formGroup.locator('input').last().fill('Notebook input');\n\n    // Metadata should be filled at their correct level.\n    cellMetadata = await getCellMetadata(page, 0);\n    expect(cellMetadata['cell-metadata']).toBe('Cell input');\n    expect(cellMetadata['nb-nested']).toBeUndefined();\n    nbMetadata = await getNotebookMetadata(page);\n    expect(nbMetadata['nb-nested']['nb-metadata']).toBe('Notebook input');\n    expect(nbMetadata['cell-metadata']).toBeUndefined();\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should not display field for non relevant cell type",
            "suites": [],
            "updatePoint": {
                "line": 484,
                "column": 59,
                "index": 15614
            },
            "line": 484,
            "code": "  test('should not display field for non relevant cell type', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    let form, formGroup;\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Create a Markdown cell and select it.\n    await page.notebook.addCell('markdown', 'Markdown cell');\n    await page.notebook.selectCells((await page.notebook.getCellCount()) - 1);\n    ({\n      form,\n      formGroup\n    } = await getFormGroup(page));\n    await expect(formGroup).toHaveCount(1);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-wrong-cell-type.png');\n\n    // Create a raw cell and select it.\n    await page.notebook.addCell('raw', 'Raw cell');\n    await page.notebook.selectCells((await page.notebook.getCellCount()) - 1);\n    ({\n      form,\n      formGroup\n    } = await getFormGroup(page));\n    await expect(formGroup).toHaveCount(1);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-wrong-cell-type.png');\n\n    // Select the code cell again to retrieve full form.\n    await page.notebook.selectCells(0);\n    ({\n      form,\n      formGroup\n    } = await getFormGroup(page));\n    await expect(formGroup).toHaveCount(2);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-correct-cell-type.png');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "display conditional field",
            "suites": [],
            "updatePoint": {
                "line": 562,
                "column": 33,
                "index": 17901
            },
            "line": 562,
            "code": "  test('display conditional field', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM\n    const {\n      form,\n      formGroup\n    } = await getFormGroup(page);\n\n    // There should be 1 field displayed as condition is not met.\n    await formGroup.locator('select').first().selectOption('not met');\n    await expect(formGroup).toHaveCount(1);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-condition-not-met.png');\n\n    // Met the condition, then the second field should be displayed too.\n    await formGroup.locator('select').first().selectOption('met');\n    await expect(formGroup).toHaveCount(2);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-condition-met.png');\n\n    // If the condition is not met, only one field should be displayed.\n    await formGroup.locator('select').first().selectOption('not met');\n    await expect(formGroup).toHaveCount(1);\n    expect(await form.screenshot()).toMatchSnapshot('metadata-condition-not-met.png');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should respect the order of the fields",
            "suites": [],
            "updatePoint": {
                "line": 622,
                "column": 46,
                "index": 19786
            },
            "line": 622,
            "code": "  test('should respect the order of the fields', async ({\n    page,\n    baseURL,\n    tmpPath\n  }) => {\n    // Open the Notebook.\n    await page.goto(baseURL);\n    await page.notebook.openByPath(`${tmpPath}/${nbFile}`);\n\n    // Open and get the form DOM.\n    const {\n      form,\n      formGroup\n    } = await getFormGroup(page);\n\n    // The order of the fields should be respected.\n    expect(await form.screenshot()).toMatchSnapshot('metadata-ui-schema.png');\n    await expect(formGroup.locator('.jp-FormGroup-compactTitle > .jp-FormGroup-fieldLabel').first()).toHaveText('Metadata 2');\n    await expect(formGroup.locator('input').first()).toHaveAttribute('type', 'number');\n\n    // Should display the title and description from uiSchema.\n    await expect(formGroup.locator('.jp-FormGroup-compactTitle > .jp-FormGroup-fieldLabel').last()).toHaveText('Metadata 1 title');\n    await expect(formGroup.locator('input').last()).toHaveAttribute('type', 'text');\n  });",
            "file": "jupyterlab/metadataform.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Create a Raw cell",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 25,
                "index": 787
            },
            "line": 19,
            "code": "  test('Create a Raw cell', async ({\n    page\n  }) => {\n    await page.notebook.setCell(0, 'raw', 'Just a raw cell');\n    expect(await page.notebook.getCellCount()).toBe(1);\n    expect(await page.notebook.getCellType(0)).toBe('raw');\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Create a Markdown cell",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 30,
                "index": 1097
            },
            "line": 27,
            "code": "  test('Create a Markdown cell', async ({\n    page\n  }) => {\n    await page.notebook.addCell('markdown', '## This is **bold** and *italic* [link to jupyter.org!](http://jupyter.org)');\n    await page.notebook.runCell(1, true);\n    expect(await page.notebook.getCellCount()).toBe(2);\n    expect(await page.notebook.getCellType(1)).toBe('markdown');\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Create a Code cell",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 26,
                "index": 1512
            },
            "line": 36,
            "code": "  test('Create a Code cell', async ({\n    page\n  }) => {\n    await page.notebook.addCell('code', '2 ** 3');\n    expect(await page.notebook.getCellCount()).toBe(2);\n    expect(await page.notebook.getCellType(1)).toBe('code');\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Save Notebook",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 21,
                "index": 1803
            },
            "line": 44,
            "code": "  test('Save Notebook', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await expect(page.notebook.save()).resolves.not.toThrow();\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open menu item ",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 36,
                "index": 2007
            },
            "line": 51,
            "code": "    test(`Open menu item ${menuPath}`, async ({\n      page,\n      sessions\n    }) => {\n      // Wait for kernel to be idle as some menu depend of kernel information\n      expect(await page.waitForSelector(`#jp-main-statusbar >> text=Idle`)).toBeTruthy();\n      await page.menu.open(menuPath);\n      expect(await page.menu.isOpen(menuPath)).toBeTruthy();\n      const imageName = `opened-menu-${menuPath.replace(/>/g, '-')}.png`;\n      const menu = await page.menu.getOpenMenu();\n      expect(await menu.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n    });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Run cells",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 17,
                "index": 2560
            },
            "line": 64,
            "code": "  test('Run cells', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await page.notebook.run();\n    await page.notebook.save();\n    const imageName = 'run-cells.png';\n    expect((await page.notebook.getCellTextOutput(2))[0]).toBe('8');\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Toggle Dark theme",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 25,
                "index": 3021
            },
            "line": 76,
            "code": "  test('Toggle Dark theme', async ({\n    page\n  }) => {\n    await populateNotebook(page);\n    await page.notebook.run();\n    await page.theme.setDarkTheme();\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    const imageName = 'dark-theme.png';\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-create.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight LaTeX syntax",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 30,
                "index": 1285
            },
            "line": 29,
            "code": "  test('Highlight LaTeX syntax', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'highlight-latex.png';\n    await page.notebook.enterCellEditingMode(0);\n    const cell = await page.notebook.getCell(0);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-markdown.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Do not highlight TeX in code blocks",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 43,
                "index": 1671
            },
            "line": 39,
            "code": "  test('Do not highlight TeX in code blocks', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'do-not-highlight-not-latex.png';\n    await enterEditingModeForScreenshot(page, 1);\n    const cell = await page.notebook.getCell(1);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-markdown.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Do not enter math mode for standalone dollar",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 52,
                "index": 2078
            },
            "line": 49,
            "code": "  test('Do not enter math mode for standalone dollar', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    const imageName = 'do-not-highlight-standalone-dollar.png';\n    await enterEditingModeForScreenshot(page, 2);\n    const cell = await page.notebook.getCell(2);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-markdown.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Limit cell outputs",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 24,
                "index": 446
            },
            "line": 15,
            "code": "test('Limit cell outputs', async ({\n  page\n}) => {\n  await page.notebook.createNew();\n  await page.locator('.jp-Cell-inputArea >> .cm-editor >> .cm-content[contenteditable=\"true\"]').type(`from IPython.display import display, Markdown\n\nfor i in range(10):\n    display(Markdown('_Markdown_ **text**'))\n`);\n  await page.notebook.run();\n  await expect(page.locator('.jp-RenderedMarkdown')).toHaveCount(MAX_OUTPUTS);\n  await expect(page.locator('.jp-TrimmedOutputs')).toHaveText('Show more outputs');\n});",
            "file": "jupyterlab/notebook-max-outputs.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Don't limit cell outputs if input is requested",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 52,
                "index": 974
            },
            "line": 28,
            "code": "test(\"Don't limit cell outputs if input is requested\", async ({\n  page\n}) => {\n  await page.notebook.createNew();\n  await page.locator('.jp-Cell-inputArea >> .cm-editor >> .cm-content[contenteditable=\"true\"]').type(`from IPython.display import display, Markdown\n\nfor i in range(10):\n    display(Markdown('_Markdown_ **text**'))\n\ninput('Your age:')\n`);\n  await page.menu.clickMenuItem('Run>Run All Cells');\n  await page.waitForSelector('.jp-Stdin >> text=Your age:');\n  expect(await page.locator('.jp-RenderedMarkdown').count()).toBeGreaterThan(MAX_OUTPUTS);\n  await page.keyboard.press('Enter');\n});",
            "file": "jupyterlab/notebook-max-outputs.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Display input value",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 25,
                "index": 1547
            },
            "line": 44,
            "code": "test('Display input value', async ({\n  page\n}) => {\n  await page.notebook.createNew();\n  await page.locator('.jp-Cell-inputArea >> .cm-editor >> .cm-content[contenteditable=\"true\"]').type(`from IPython.display import display, Markdown\n\nfor i in range(10):\n    display(Markdown('_Markdown_ **text**'))\n\ninput('Your age:')\n\nfor i in range(10):\n    display(Markdown('_Markdown_ **text**'))\n`);\n  await page.menu.clickMenuItem('Run>Run All Cells');\n  await page.waitForSelector('.jp-Stdin >> text=Your age:');\n  await page.keyboard.type('42');\n  await page.keyboard.press('Enter');\n  expect(await page.locator('.jp-RenderedMarkdown').count()).toBeGreaterThan(MAX_OUTPUTS);\n  await expect(page.locator('.jp-RenderedText').first()).toHaveText('Your age: 42');\n});",
            "file": "jupyterlab/notebook-max-outputs.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Execute code cell",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 25,
                "index": 429
            },
            "line": 18,
            "code": "  test('Execute code cell', async ({\n    page\n  }) => {\n    await page.sidebar.close('left');\n    await page.notebook.setCell(0, 'code', 'print(\"hello\")');\n    await page.notebook.addCell('code', '2 * 3');\n    await page.notebook.runCellByCell();\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    const imageName = 'mobile-layout.png';\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-mobile.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Replace in cell",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 23,
                "index": 729
            },
            "line": 23,
            "code": "  test('Replace in cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'egg');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=1/20');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('replace-in-cell.png');\n  });",
            "file": "jupyterlab/notebook-replace.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Substitute groups of regular expressions",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 48,
                "index": 1328
            },
            "line": 37,
            "code": "  test('Substitute groups of regular expressions', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.click('button[title=\"Use Regular Expression\"]');\n    await page.fill('[placeholder=\"Find\"]', 'text/(\\\\w+)');\n    await page.waitForSelector('text=1/3');\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'script/$1');\n    const cell = await page.notebook.getCell(2);\n    await expect(page.locator('body')).not.toContainText('script/plain');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=1/2');\n    await cell.waitForSelector('text=script/plain');\n    await expect(page.locator('body')).toContainText('script/plain');\n  });",
            "file": "jupyterlab/notebook-replace.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Replace on markdown rendered cell",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 41,
                "index": 2077
            },
            "line": 53,
            "code": "  test('Replace on markdown rendered cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n\n    // Click next button\n    await page.click('button[title=\"Next Match\"]', {\n      clickCount: 4\n    });\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'egg');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=5/20');\n    const cell = await page.notebook.getCell(1);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot('replace-in-markdown-rendered-cell.png');\n  });",
            "file": "jupyterlab/notebook-replace.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Replace all",
            "suites": [],
            "updatePoint": {
                "line": 72,
                "column": 19,
                "index": 2780
            },
            "line": 72,
            "code": "  test('Replace all', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'egg');\n    await page.click('button:has-text(\"Replace All\")');\n    await page.waitForSelector('text=-/-');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('replace-all.png');\n  });",
            "file": "jupyterlab/notebook-replace.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Replace step-by-step across cell boundaries",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 51,
                "index": 3381
            },
            "line": 86,
            "code": "  test('Replace step-by-step across cell boundaries', async ({\n    page\n  }) => {\n    // Create a small test notebook\n    await page.notebook.createNew();\n    await page.notebook.setCell(0, 'code', 'test\\ntest');\n    await page.notebook.addCell('code', 'test\\ntest');\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'test');\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'egg');\n\n    // TODO: Next Match press count should be one less\n    // (the -/4 state should not be necessary).\n    await page.waitForSelector('text=-/4');\n    await page.click('button[title=\"Next Match\"]', {\n      clickCount: 3\n    });\n    await page.waitForSelector('text=1/4');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=1/3');\n    await page.click('button:has-text(\"Replace\")');\n\n    // At this point we should be in the second cell\n    await page.waitForSelector('text=1/2');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=1/1');\n    await page.click('button:has-text(\"Replace\")');\n    await page.waitForSelector('text=-/-');\n  });",
            "file": "jupyterlab/notebook-replace.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Run notebook with Vega cell in default theme",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 52,
                "index": 902
            },
            "line": 31,
            "code": "  test('Run notebook with Vega cell in default theme', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    await page.notebook.activate(fileName);\n    const imageName = 'run-cells-vega.png';\n    await page.notebook.run();\n    await page.waitForSelector('.vega-embed');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-run-vega.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Run notebook with Vega cell in dark theme",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 49,
                "index": 1358
            },
            "line": 43,
            "code": "  test('Run notebook with Vega cell in dark theme', async ({\n    page,\n    tmpPath\n  }) => {\n    await page.notebook.openByPath(`${tmpPath}/${fileName}`);\n    await page.notebook.activate(fileName);\n    await page.theme.setDarkTheme();\n    const imageName = 'run-cells-dark-vega.png';\n    await page.notebook.run();\n    await page.waitForSelector('.vega-embed');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-run-vega.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Scroll to ",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 27,
                "index": 1273
            },
            "line": 39,
            "code": "    test(`Scroll to ${link}`, async ({\n      page\n    }) => {\n      const firstCell = await page.notebook.getCell(0);\n      await firstCell.scrollIntoViewIfNeeded();\n      expect(await firstCell.boundingBox()).toBeTruthy();\n      await page.click(`a:has-text(\"${link}\")`);\n      await firstCell.waitForElementState('hidden');\n      expect(await firstCell.boundingBox()).toBeFalsy();\n      const lastCell = await page.notebook.getCell(cellIdx);\n      await lastCell.waitForElementState('visible');\n      expect(await lastCell.boundingBox()).toBeTruthy();\n    });",
            "file": "jupyterlab/notebook-scroll.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 14,
                "index": 832
            },
            "line": 29,
            "code": "  test('Search', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Typing in search box",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 28,
                "index": 1194
            },
            "line": 39,
            "code": "  test('Typing in search box', async ({\n    page\n  }) => {\n    // Check against React being too eager with controling state of input box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', '14');\n    await page.press('[placeholder=\"Find\"]', 'ArrowLeft');\n    await page.type('[placeholder=\"Find\"]', '2');\n    await page.type('[placeholder=\"Find\"]', '3');\n    await expect(page.locator('[placeholder=\"Find\"]')).toHaveValue('1234');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "RegExp parsing failure",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 30,
                "index": 1669
            },
            "line": 50,
            "code": "  test('RegExp parsing failure', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'test\\\\');\n    await page.click('button[title=\"Use Regular Expression\"]');\n    await expect(page.locator('.jp-DocumentSearch-regex-error')).toBeVisible();\n    const overlay = page.locator('.jp-DocumentSearch-overlay');\n    expect(await overlay.screenshot()).toMatchSnapshot('regexp-parsing-failure.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Multi-line search",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 25,
                "index": 2124
            },
            "line": 60,
            "code": "  test('Multi-line search', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'one notebook withr\\n\\n\\nThis is a multi');\n    await page.waitForSelector('text=1/1');\n\n    // Show replace buttons to check for visual regressions\n    await page.click('button[title=\"Toggle Replace\"]');\n    await page.fill('[placeholder=\"Replace\"]', 'line1\\nline2');\n    const overlay = page.locator('.jp-DocumentSearch-overlay');\n    expect(await overlay.screenshot()).toMatchSnapshot('multi-line-search.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Populate search box with selected text",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 46,
                "index": 2709
            },
            "line": 73,
            "code": "  test('Populate search box with selected text', async ({\n    page\n  }) => {\n    // Enter first cell\n    await page.notebook.enterCellEditingMode(0);\n\n    // Go to first line\n    await page.keyboard.press('PageUp');\n    // Select first line\n    await page.keyboard.press('Shift+End');\n    // Open search box\n    await page.keyboard.press('Control+f');\n\n    // Expect it to be populated with the first line\n    const inputWithFirstLine = page.locator('[placeholder=\"Find\"] >> text=\"Test with one notebook withr\"');\n    await expect(inputWithFirstLine).toBeVisible();\n    await expect(inputWithFirstLine).toBeFocused();\n    // Expect the newly set text to be selected\n    expect(await inputWithFirstLine.evaluate(getSelectionRange)).toStrictEqual({\n      start: 0,\n      end: 28\n    });\n\n    // Expect the first match to be highlighted\n    await page.waitForSelector('text=1/2');\n\n    // Enter first cell again\n    await page.notebook.enterCellEditingMode(0);\n    // Go to last line\n    await page.keyboard.press('PageDown');\n    // Select last line\n    await page.keyboard.press('Shift+Home');\n    // Update search box\n    await page.keyboard.press('Control+f');\n\n    // Expect it to be populated with the last line\n    const inputWithLastLine = page.locator('[placeholder=\"Find\"] >> text=\"This is a multi line with hits with\"');\n    await expect(inputWithLastLine).toBeVisible();\n    await expect(inputWithLastLine).toBeFocused();\n    // Expect the newly set text to be selected\n    expect(await inputWithLastLine.evaluate(getSelectionRange)).toStrictEqual({\n      start: 0,\n      end: 35\n    });\n    await expect(page.locator('.jp-DocumentSearch-overlay')).toBeVisible();\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Restore previous search query if there is no selection",
            "suites": [],
            "updatePoint": {
                "line": 119,
                "column": 62,
                "index": 4404
            },
            "line": 119,
            "code": "  test('Restore previous search query if there is no selection', async ({\n    page\n  }) => {\n    const inputWithTestLocator = page.locator('[placeholder=\"Find\"] >> text=\"test\"');\n    const overlayLocator = page.locator('.jp-DocumentSearch-overlay');\n\n    // Search for \"test\"\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'test');\n    await page.waitForSelector('text=1/2');\n\n    // Close search box\n    await page.keyboard.press('Escape');\n    await expect(overlayLocator).toBeHidden();\n\n    // Open search box again\n    await page.keyboard.press('Control+f');\n    await expect(overlayLocator).toBeVisible();\n    // Expect the text to be set in the input field\n    await expect(inputWithTestLocator).toBeVisible();\n    // Expect the search to be active again\n    await page.waitForSelector('text=1/2');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Close with Escape",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 25,
                "index": 5219
            },
            "line": 142,
            "code": "  test('Close with Escape', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await expect(page.locator('.jp-DocumentSearch-overlay')).toBeVisible();\n\n    // Close search box\n    await page.keyboard.press('Escape');\n    await expect(page.locator('.jp-DocumentSearch-overlay')).toBeHidden();\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Close with Escape from Notebook",
            "suites": [],
            "updatePoint": {
                "line": 153,
                "column": 39,
                "index": 5579
            },
            "line": 153,
            "code": "  test('Close with Escape from Notebook', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await expect(page.locator('.jp-DocumentSearch-overlay')).toBeVisible();\n\n    // Enter first cell\n    await page.notebook.enterCellEditingMode(0);\n\n    // First escape should NOT close the search box (but leave the editing mode)\n    await page.keyboard.press('Escape');\n    await page.waitForTimeout(250);\n    expect(await page.notebook.isCellInEditingMode(0)).toBeFalsy();\n    expect(await page.isVisible('.jp-DocumentSearch-overlay')).toBeTruthy();\n\n    // Second escape should close the search box (even if it is not focused)\n    await page.keyboard.press('Escape');\n    await expect(page.locator('.jp-DocumentSearch-overlay')).toBeHidden();\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search within outputs",
            "suites": [],
            "updatePoint": {
                "line": 173,
                "column": 29,
                "index": 6360
            },
            "line": 173,
            "code": "  test('Search within outputs', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search Cell Outputs');\n    await page.waitForSelector('text=1/29');\n    const cell = await page.notebook.getCell(5);\n    await cell.scrollIntoViewIfNeeded();\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-within-outputs.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search in a single selected cell",
            "suites": [],
            "updatePoint": {
                "line": 187,
                "column": 40,
                "index": 6950
            },
            "line": 187,
            "code": "  test('Search in a single selected cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search in 1 Selected Cell');\n    await page.waitForSelector('text=1/4');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-in-selected-cells.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search in multiple selected cells",
            "suites": [],
            "updatePoint": {
                "line": 199,
                "column": 41,
                "index": 7459
            },
            "line": 199,
            "code": "  test('Search in multiple selected cells', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search in 1 Selected Cell');\n\n    // Bring focus to first cell without switching away from command mode\n    let cell = await page.notebook.getCell(0);\n    await (await cell.$('.jp-InputPrompt')).click();\n\n    // Select two cells below\n    await page.keyboard.press('Shift+ArrowDown');\n    await page.keyboard.press('Shift+ArrowDown');\n\n    // Expect the filter text to be updated\n    await page.waitForSelector('text=Search in 3 Selected Cells');\n\n    // Reset selection, switch to third cell, preserving command mode\n    cell = await page.notebook.getCell(2);\n    await (await cell.$('.jp-InputPrompt')).click();\n    await page.waitForSelector('text=Search in 1 Selected Cell');\n\n    // Select cell above\n    await page.keyboard.press('Shift+ArrowUp');\n\n    // Expect updated text\n    await page.waitForSelector('text=Search in 2 Selected Cells');\n\n    // Expect 15 matches; this is 6/15, not 1/15 because current match is set\n    // in second cell and when selection is extended, it does not move; keeping\n    // the current match when extending the selection is desired as user may use\n    // it as a reference, especially when it was set as closest to the cursor.\n    await page.waitForSelector('text=6/15');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-in-two-selected-cells.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search in multiple selected cells from edit mode",
            "suites": [],
            "updatePoint": {
                "line": 237,
                "column": 56,
                "index": 9104
            },
            "line": 237,
            "code": "  test('Search in multiple selected cells from edit mode', async ({\n    page\n  }) => {\n    // This is testing focus handling when extending the selection after\n    // switching focus away from cell editor, which needs to protect against\n    // race conditions and CodeMirror6 focus issues when highlights get added.\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search in 1 Selected Cell');\n    await page.waitForSelector('text=1/4');\n\n    // Bring focus to first cell without switching to edit mode\n    let cell = await page.notebook.getCell(0);\n    await (await cell.$('.jp-Editor')).click();\n\n    // Switch back to command mode\n    await page.keyboard.press('Escape');\n\n    // Select two cells below\n    await page.keyboard.press('Shift+ArrowDown');\n    await page.keyboard.press('Shift+ArrowDown');\n\n    // Expect the filter text to be updated\n    await page.waitForSelector('text=Search in 3 Selected Cells');\n\n    // Expect 19 matches\n    await page.waitForSelector('text=1/19');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search in selected text",
            "suites": [],
            "updatePoint": {
                "line": 266,
                "column": 31,
                "index": 10210
            },
            "line": 266,
            "code": "  test('Search in selected text', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'text/');\n    await page.waitForSelector('text=1/3');\n\n    // Activate third cell\n    const cell = await page.notebook.getCell(2);\n    const editor = await cell.$('.jp-Editor');\n    await editor.click();\n\n    // Select 7 lines\n    await page.keyboard.press('Control+Home');\n    for (let i = 0; i < 6; i++) {\n      await page.keyboard.press('Shift+ArrowDown');\n    }\n\n    // Switch to selection search mode\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search in 7 Selected Lines');\n    await page.waitForSelector('text=1/2');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-in-selected-text.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlights are visible when text is selected",
            "suites": [],
            "updatePoint": {
                "line": 291,
                "column": 52,
                "index": 11104
            },
            "line": 291,
            "code": "  test('Highlights are visible when text is selected', async ({\n    page\n  }) => {\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    const cell = await page.notebook.getCell(0);\n    const editor = await cell.$('.jp-Editor');\n    await editor.click();\n\n    // Select text (to see if the highlights will still be visible)\n    await page.keyboard.press('Control+A');\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot('highlight-visible-under-selection.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight next hit same editor",
            "suites": [],
            "updatePoint": {
                "line": 305,
                "column": 38,
                "index": 11674
            },
            "line": 305,
            "code": "  test('Highlight next hit same editor', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n\n    // Click next button\n    await page.click('button[title=\"Next Match\"]');\n    const cell = await page.notebook.getCell(0);\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot('highlight-next-in-editor.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight next hit in the next cell",
            "suites": [],
            "updatePoint": {
                "line": 318,
                "column": 43,
                "index": 12155
            },
            "line": 318,
            "code": "  test('Highlight next hit in the next cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n\n    // Click next button\n    await page.click('button[title=\"Next Match\"]', {\n      clickCount: 4\n    });\n    const cell = await page.notebook.getCell(1);\n    expect(await cell.screenshot()).toMatchSnapshot('highlight-next-cell.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight previous hit",
            "suites": [],
            "updatePoint": {
                "line": 333,
                "column": 30,
                "index": 12623
            },
            "line": 333,
            "code": "  test('Highlight previous hit', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n\n    // Click previous button\n    await page.click('button[title=\"Previous Match\"]');\n    // Should cycle back\n    await page.waitForSelector('text=21/21');\n\n    // Click previous button twice\n    await page.click('button[title=\"Previous Match\"]');\n    await page.click('button[title=\"Previous Match\"]');\n    // Should move up by two\n    await page.waitForSelector('text=19/21');\n    const hit = await page.notebook.getCell(2);\n    expect(await hit.screenshot()).toMatchSnapshot('highlight-previous-element.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search from cursor",
            "suites": [],
            "updatePoint": {
                "line": 354,
                "column": 26,
                "index": 13365
            },
            "line": 354,
            "code": "  test('Search from cursor', async ({\n    page\n  }) => {\n    const cell = await page.notebook.getCell(5);\n    await cell.click();\n    await page.keyboard.press('Escape');\n    await cell.scrollIntoViewIfNeeded();\n\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=20/21');\n\n    // Click previous button\n    await page.click('button[title=\"Previous Match\"]');\n    await page.waitForSelector('text=19/21');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Highlight on markdown rendered state change",
            "suites": [],
            "updatePoint": {
                "line": 371,
                "column": 51,
                "index": 13907
            },
            "line": 371,
            "code": "  test('Highlight on markdown rendered state change', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n\n    // Click next button\n    await page.click('button[title=\"Next Match\"]', {\n      clickCount: 4\n    });\n    const cell = await page.notebook.getCell(1);\n    await cell.dblclick();\n    expect(await (await cell.$('.jp-Editor')).screenshot()).toMatchSnapshot('highlight-markdown-switch-state.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search on typing",
            "suites": [],
            "updatePoint": {
                "line": 387,
                "column": 24,
                "index": 14432
            },
            "line": 387,
            "code": "  test('Search on typing', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.notebook.setCell(5, 'code', 'with');\n    const cell = await page.notebook.getCell(5);\n    expect(await cell.screenshot()).toMatchSnapshot('search-typing.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search new outputs",
            "suites": [],
            "updatePoint": {
                "line": 397,
                "column": 26,
                "index": 14790
            },
            "line": 397,
            "code": "  test('Search new outputs', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.click('button[title=\"Show Search Filters\"]');\n    await page.click('text=Search Cell Outputs');\n    await page.waitForSelector('text=1/29');\n    const cell = await page.notebook.getCell(5);\n    await cell.click();\n    await page.notebook.runCell(5);\n    expect(await cell.screenshot()).toMatchSnapshot('search-new-outputs.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search on new cell",
            "suites": [],
            "updatePoint": {
                "line": 411,
                "column": 26,
                "index": 15317
            },
            "line": 411,
            "code": "  test('Search on new cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    const cell = await page.notebook.getCell(5);\n    await cell.click();\n    await page.notebook.clickToolbarItem('insert');\n    await page.notebook.setCell(6, 'code', 'with');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-on-new-cell.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search on deleted cell",
            "suites": [],
            "updatePoint": {
                "line": 425,
                "column": 30,
                "index": 15870
            },
            "line": 425,
            "code": "  test('Search on deleted cell', async ({\n    page\n  }) => {\n    // Open search box\n    await page.keyboard.press('Control+f');\n    await page.fill('[placeholder=\"Find\"]', 'with');\n    await page.waitForSelector('text=1/21');\n    const cell = await page.notebook.getCell(5);\n    await cell.click();\n    await page.keyboard.press('Escape');\n    await cell.scrollIntoViewIfNeeded();\n    await page.keyboard.press('d');\n    await page.keyboard.press('d');\n    await page.waitForSelector('text=1/19');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot('search-on-deleted-cell.png');\n  });",
            "file": "jupyterlab/notebook-search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Insert cells",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 20,
                "index": 681
            },
            "line": 18,
            "code": "  test('Insert cells', async ({\n    page\n  }) => {\n    const imageName = 'insert-cells.png';\n    await page.notebook.selectCells(0);\n    await page.notebook.clickToolbarItem('insert');\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('insert');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Copy-Paste cell",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 23,
                "index": 1096
            },
            "line": 29,
            "code": "  test('Copy-Paste cell', async ({\n    page\n  }) => {\n    const imageName = 'copy-paste-cell.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('copy');\n    await page.notebook.selectCells(0);\n    await page.notebook.clickToolbarItem('paste');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Cut cell",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 16,
                "index": 1504
            },
            "line": 40,
            "code": "  test('Cut cell', async ({\n    page\n  }) => {\n    const imageName = 'cut-cell.png';\n    await page.notebook.selectCells(1);\n    await page.notebook.clickToolbarItem('cut');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Paste cell",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 18,
                "index": 1815
            },
            "line": 49,
            "code": "  test('Paste cell', async ({\n    page\n  }) => {\n    // Cut cell to populate clipboard\n    await page.notebook.selectCells(1);\n    await page.notebook.clickToolbarItem('cut');\n    const imageName = 'paste-cell.png';\n    await page.notebook.selectCells(1);\n    await page.notebook.clickToolbarItem('paste');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Delete cells",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 20,
                "index": 2259
            },
            "line": 61,
            "code": "  test('Delete cells', async ({\n    page\n  }) => {\n    const imageName = 'delete-cell.png';\n    await page.notebook.selectCells(1, 2);\n    await page.menu.clickMenuItem('Edit>Delete Cells');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Run cell",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 16,
                "index": 2581
            },
            "line": 70,
            "code": "  test('Run cell', async ({\n    page\n  }) => {\n    const imageName = 'run-cell.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('run');\n    await page.waitForSelector('text=8');\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Change cell type to Markdown",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 36,
                "index": 2952
            },
            "line": 80,
            "code": "  test('Change cell type to Markdown', async ({\n    page\n  }) => {\n    const imageName = 'change-to-markdown.png';\n    await page.notebook.selectCells(2);\n    await page.notebook.clickToolbarItem('cellType');\n    await page.keyboard.press('m');\n    await page.keyboard.press('Enter');\n    await page.notebook.selectCells(2);\n    const nbPanel = await page.notebook.getNotebookInPanel();\n    expect(await nbPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Toolbar items act on owner widget",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 39,
                "index": 3419
            },
            "line": 93,
            "code": "test('Toolbar items act on owner widget', async ({\n  page\n}) => {\n  // Given two side-by-side notebooks and the second being active\n  const file1 = 'notebook1.ipynb';\n  await page.notebook.createNew(file1);\n  const panel1 = await page.activity.getPanel(file1);\n  const tab1 = await page.activity.getTab(file1);\n\n  // FIXME Calling a second time `page.notebook.createNew` is not robust\n  await page.menu.clickMenuItem('File>New>Notebook');\n  try {\n    await page.waitForSelector('.jp-Dialog', {\n      timeout: 5000\n    });\n    await page.click('.jp-Dialog .jp-mod-accept');\n  } catch (reason) {\n    // no-op\n  }\n  const tab2 = await page.activity.getTab();\n  const tab2BBox = await tab2.boundingBox();\n  await page.mouse.move(tab2BBox.x + 0.5 * tab2BBox.width, tab2BBox.y + 0.5 * tab2BBox.height);\n  await page.mouse.down();\n  await page.mouse.move(900, tab2BBox.y + tab2BBox.height + 200);\n  await page.mouse.up();\n  const classlist = await tab1.getAttribute('class');\n  expect(classlist.split(' ')).not.toContain('jp-mod-current');\n\n  // When clicking on toolbar item of the first file\n  await (await panel1.$('button[data-command=\"notebook:insert-cell-below\"]')).click();\n\n  // Then the first file is activated and the action is performed\n  const classlistEnd = await tab1.getAttribute('class');\n  expect(classlistEnd.split(' ')).toContain('jp-mod-current');\n  expect(await page.notebook.getCellCount()).toEqual(2);\n});",
            "file": "jupyterlab/notebook-toolbar.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Blank Markdown cell does not break trust",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 48,
                "index": 515
            },
            "line": 14,
            "code": "  test('Blank Markdown cell does not break trust', async ({\n    page\n  }) => {\n    // See https://github.com/jupyterlab/jupyterlab/issues/9765\n\n    // Add an empty Markdown cell\n    await page.notebook.addCell('markdown', '');\n    // The notebook should be trusted\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n    await page.notebook.save();\n    // Reload page\n    await page.reload({\n      waitForIsReady: false\n    });\n    // Should still be trusted\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n  });",
            "file": "jupyterlab/notebook-trust.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Trust is lost after manually editing notebook",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 53,
                "index": 1063
            },
            "line": 31,
            "code": "  test('Trust is lost after manually editing notebook', async ({\n    page\n  }) => {\n    const browserContext = page.context();\n    await browserContext.grantPermissions(['clipboard-read']);\n    // Add text to first cell\n    await page.notebook.setCell(0, 'code', 'TEST_TEXT');\n    await page.notebook.save();\n    // The notebook should be trusted\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(1);\n    await expect(page.locator(NOT_TRUSTED_SELECTOR)).toHaveCount(0);\n\n    // Open notebook in text editor using context menu\n    await page.click(`.jp-DirListing-item span:has-text(\"${fileName}\")`, {\n      button: 'right'\n    });\n    await page.hover('text=Open With');\n    await page.click('.lm-Menu li[role=\"menuitem\"]:has-text(\"Editor\")');\n    const editorContent = await page.waitForSelector('.jp-FileEditor .cm-content');\n    await editorContent.waitForSelector('text=TEST_TEXT');\n    const originalContent = await page.evaluate(async () => {\n      await window.jupyterapp.commands.execute('fileeditor:select-all');\n      await window.jupyterapp.commands.execute('fileeditor:cut');\n      return navigator.clipboard.readText();\n    });\n    const newContent = originalContent.replace('TEST_TEXT', 'SUBSTITUTED_TEXT');\n    await page.evaluate(async ([newContent]) => {\n      await window.jupyterapp.commands.execute('fileeditor:replace-selection', {\n        text: newContent\n      });\n      // Save file after changes\n      await window.jupyterapp.commands.execute('docmanager:save');\n      // Close the file editor view of the notebook\n      await window.jupyterapp.commands.execute('application:close');\n    }, [newContent]);\n\n    // Reload page\n    await page.reload({\n      waitForIsReady: false\n    });\n\n    // It should no longer be trusted\n    await expect(page.locator(TRUSTED_SELECTOR)).toHaveCount(0);\n    await expect(page.locator(NOT_TRUSTED_SELECTOR)).toHaveCount(1);\n  });",
            "file": "jupyterlab/notebook-trust.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display a  notification",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 47,
                "index": 443
            },
            "line": 11,
            "code": "    test(`should display a ${type} notification`, async ({\n      page\n    }) => {\n      await page.evaluate(kind => {\n        return window.jupyterapp.commands.execute('apputils:notify', {\n          message: 'This is a test message',\n          type: kind,\n          options: {\n            autoClose: false\n          }\n        });\n      }, type);\n      await page.waitForSelector('.Toastify__toast');\n      expect(await page.locator('.Toastify__toast').screenshot({\n        // Ensure consistency for in progress case\n        animations: 'disabled'\n      })).toMatchSnapshot({\n        name: `notification-${type}.png`\n      });\n    });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display a notification with actions",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 50,
                "index": 1084
            },
            "line": 32,
            "code": "  test('should display a notification with actions', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false,\n          actions: [{\n            label: 'Button 1',\n            commandId: 'apputils:notify',\n            args: {\n              message: 'Button 1 was clicked',\n              type: 'success',\n              options: {\n                autoClose: false\n              }\n            }\n          }, {\n            label: 'Button 2',\n            commandId: 'apputils:notify',\n            args: {\n              message: 'Button 2 was clicked',\n              type: 'success',\n              options: {\n                autoClose: false\n              }\n            }\n          }]\n        }\n      });\n    });\n    const handle = await page.waitForSelector('.Toastify__toast');\n    expect(await handle.screenshot({\n      animations: 'disabled'\n    })).toMatchSnapshot({\n      name: `notification-with-actions.png`\n    });\n    await Promise.all([handle.waitForElementState('hidden'), page.click('.Toastify__toast >> text=Button 2')]);\n    await expect(page.locator('.Toastify__toast').last()).toHaveText('Button 2 was clicked');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display a notification with action ",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 66,
                "index": 2442
            },
            "line": 74,
            "code": "    test(`should display a notification with action ${displayType}`, async ({\n      page\n    }) => {\n      await page.evaluate(displayType => {\n        return window.jupyterapp.commands.execute('apputils:notify', {\n          message: 'This is a test message',\n          options: {\n            autoClose: false,\n            actions: [{\n              label: 'Button 1',\n              commandId: 'apputils:notify',\n              args: {\n                message: 'Button 1 was clicked',\n                type: 'success',\n                options: {\n                  autoClose: false\n                }\n              },\n              displayType\n            }]\n          }\n        });\n      }, displayType);\n      const handle = await page.waitForSelector('.Toastify__toast');\n      expect(await handle.screenshot({\n        animations: 'disabled'\n      })).toMatchSnapshot({\n        name: `notification-${displayType}-action.png`\n      });\n    });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display as truncated text content the notification",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 65,
                "index": 3386
            },
            "line": 105,
            "code": "  test('should display as truncated text content the notification', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: '<style>.jp-dummy {\\n  color: pink;\\n}\\n</style>\\n<script>alert(\"I\\'m in\");</script>\\n\\n## Title\\n\\nThis _is_ a **Markdown** message.\\n\\n![logo](https://jupyter.org/assets/logos/rectanglelogo-greytext-orangebody-greymoons.svg)\\n\\n<p style=\"color:pink;\">Pink text</p>\\n\\n- Item 1\\n- Item 2',\n        options: {\n          autoClose: false\n        }\n      });\n    });\n    await page.waitForSelector('.Toastify__toast');\n    expect(await page.locator('.Toastify__toast-body').innerHTML()).toMatchSnapshot({\n      name: 'text-content-notification.txt'\n    });\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should update a notification",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 36,
                "index": 4132
            },
            "line": 121,
            "code": "  test('should update a notification', async ({\n    page\n  }) => {\n    const id = await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note',\n        options: {\n          autoClose: false\n        }\n      });\n    });\n    await page.waitForSelector('.Toastify__toast >> text=Simple note');\n    await page.evaluate(id => {\n      return window.jupyterapp.commands.execute('apputils:update-notification', {\n        id,\n        message: 'Updated message',\n        type: 'success'\n      });\n    }, id);\n    await expect(page.locator('.Toastify__toast')).toHaveText('Updated message');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should dismiss a notification",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 37,
                "index": 4786
            },
            "line": 142,
            "code": "  test('should dismiss a notification', async ({\n    page\n  }) => {\n    const id = await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note',\n        options: {\n          autoClose: false\n        }\n      });\n    });\n    await page.waitForSelector('.Toastify__toast >> text=Simple note');\n    await Promise.all([page.waitForSelector('.Toastify__toast >> text=Simple note', {\n      state: 'detached'\n    }), page.evaluate(id => {\n      return window.jupyterapp.commands.execute('apputils:dismiss-notification', {\n        id\n      });\n    }, id)]);\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display no notification by default",
            "suites": [],
            "updatePoint": {
                "line": 164,
                "column": 49,
                "index": 5469
            },
            "line": 164,
            "code": "  test('should display no notification by default', async ({\n    page\n  }) => {\n    const status = page.locator('.jp-Notification-Status');\n    expect(await status.getAttribute('class')).not.toMatch(/\\s?jp-mod-selected\\s?/);\n    await expect(status).toHaveText('0');\n    await status.click();\n    await expect(page.locator('.jp-Notification-Header')).toHaveText('No notifications');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should be highlighted for silent notification",
            "suites": [],
            "updatePoint": {
                "line": 173,
                "column": 53,
                "index": 5862
            },
            "line": 173,
            "code": "  test('should be highlighted for silent notification', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note'\n      });\n    });\n    const status = page.locator('.jp-Notification-Status');\n    expect(await status.getAttribute('class')).toMatch(/\\s?jp-mod-selected\\s?/);\n    await expect(status).toHaveText('1');\n    await status.click();\n    await expect(page.locator('.jp-Notification-Header')).toHaveText('1 notification');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should stop the highlight once the center is closed",
            "suites": [],
            "updatePoint": {
                "line": 187,
                "column": 59,
                "index": 6405
            },
            "line": 187,
            "code": "  test('should stop the highlight once the center is closed', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note'\n      });\n    });\n    const status = page.locator('.jp-Notification-Status');\n    await status.click();\n    await expect(page.locator('.jp-Notification-Header')).toHaveText('1 notification');\n    await page.locator('.jp-Notification-Header >> button[title=\"Hide notifications\"]').click();\n    expect(await status.getAttribute('class')).not.toMatch(/\\s?jp-mod-selected\\s?/);\n    await expect(status).toHaveText('1');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should forget dismissed notification",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 44,
                "index": 7034
            },
            "line": 202,
            "code": "  test('should forget dismissed notification', async ({\n    page\n  }) => {\n    await page.evaluate(async () => {\n      await window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note 1'\n      });\n      await window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'Simple note 2'\n      });\n    });\n    const status = page.locator('.jp-Notification-Status');\n    await expect(status).toHaveText('2');\n    await status.click();\n    await expect(page.locator('.jp-Notification-Header')).toHaveText('2 notifications');\n    await page.locator('.jp-Notification-List >> li >> [title=\"Dismiss notification\"]').first().click();\n    await expect(status).toHaveText('1');\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display all kinds of notification",
            "suites": [],
            "updatePoint": {
                "line": 220,
                "column": 48,
                "index": 7751
            },
            "line": 220,
            "code": "  test(`should display all kinds of notification`, async ({\n    page\n  }) => {\n    for (const type of NOTIFICATION_TYPE) {\n      await page.evaluate(kind => {\n        return window.jupyterapp.commands.execute('apputils:notify', {\n          message: 'This is a test message',\n          type: kind\n        });\n      }, type);\n    }\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('apputils:notify', {\n        message: 'This is a test message',\n        options: {\n          autoClose: false,\n          actions: [{\n            label: 'Button 1',\n            commandId: 'apputils:notify',\n            args: {\n              message: 'Button 1 was clicked',\n              type: 'success',\n              options: {\n                autoClose: false\n              }\n            }\n          }, {\n            label: 'Button 2',\n            commandId: 'apputils:notify',\n            args: {\n              message: 'Button 2 was clicked',\n              type: 'success',\n              options: {\n                autoClose: false\n              }\n            }\n          }]\n        }\n      });\n    });\n    const status = page.locator('.jp-Notification-Status');\n    await expect(status).toHaveText('7');\n    await status.click();\n    expect(await page.locator('.jp-Notification-Center').screenshot({\n      // Ensure consistency for in progress case\n      animations: 'disabled'\n    })).toMatchSnapshot({\n      name: `notification-center.png`\n    });\n  });",
            "file": "jupyterlab/notification.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Scrolling mode",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 22,
                "index": 798
            },
            "line": 24,
            "code": "  test('Scrolling mode', async ({\n    page\n  }) => {\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('notebook:enable-output-scrolling');\n    });\n    await page.notebook.selectCells(0);\n    await expect(page.locator(`${cellSelector} >> nth=0`)).toHaveClass(/jp-mod-outputsScrolled/);\n    const cell = await page.notebook.getCell(0);\n    expect(await (await cell.$('.jp-OutputArea')).screenshot()).toMatchSnapshot('cell-output-area-scrolling-mode.png');\n    await page.evaluate(() => {\n      return window.jupyterapp.commands.execute('notebook:disable-output-scrolling');\n    });\n    await expect(page.locator(`${cellSelector} >> nth=0`)).not.toHaveClass(/jp-mod-outputsScrolled/);\n  });",
            "file": "jupyterlab/output-scrolling.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Switching with prompt overlay",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 37,
                "index": 1532
            },
            "line": 39,
            "code": "  test('Switching with prompt overlay', async ({\n    page\n  }) => {\n    await page.locator(`${cellSelector} >> nth=1 >> .jp-OutputArea-promptOverlay`).hover();\n    const cell = await page.notebook.getCell(1);\n    expect(await cell.screenshot()).toMatchSnapshot('prompt-overlay-hover-normal.png');\n    await page.click(`${cellSelector} >> nth=1 >> .jp-OutputArea-promptOverlay`);\n    await expect(page.locator(`${cellSelector} >> nth=1`)).toHaveClass(/jp-mod-outputsScrolled/);\n    expect(await cell.screenshot()).toMatchSnapshot('prompt-overlay-hover-scroll.png');\n    await page.click(`${cellSelector} >> nth=1 >> .jp-OutputArea-promptOverlay`);\n    await expect(page.locator(`${cellSelector} >> nth=1`)).not.toHaveClass(/jp-mod-outputsScrolled/);\n  });",
            "file": "jupyterlab/output-scrolling.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Stdin history search",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 28,
                "index": 313
            },
            "line": 11,
            "code": "  test('Stdin history search', async ({\n    page\n  }) => {\n    await page.notebook.setCell(0, 'code', 'raise');\n    await page.notebook.addCell('code', '%debug');\n\n    // Run first cell and proceed to the second one.\n    await page.notebook.runCell(0);\n\n    // Run the selected (second) cell without proceeding and without waiting\n    // for it to complete (as it should stay waiting for input).\n    await page.keyboard.press('Control+Enter');\n\n    // enter a bunch of nonsense commands into the stdin attached to ipdb\n    await page.waitForSelector('.jp-Stdin-input');\n    await page.keyboard.insertText('foofoo');\n    await page.keyboard.press('Enter');\n    await page.waitForSelector('.jp-Stdin-input');\n    await page.keyboard.insertText('barbar');\n    await page.keyboard.press('Enter');\n    await page.waitForSelector('.jp-Stdin-input');\n    await page.keyboard.insertText('bazbaz');\n    await page.keyboard.press('Enter');\n\n    // search for the first nonsense command\n    await page.waitForSelector('.jp-Stdin-input');\n    await page.keyboard.insertText('foo');\n    await page.keyboard.press('Control+ArrowUp');\n\n    // Mask out random kernel temporary file path\n    // e.g. `/tmp/ipykernel_104185/2235509928.py`\n    const filePath = await page.$('.jp-OutputArea-output :text-matches(\"/tmp/\")');\n    await filePath.evaluate(node => node.textContent = '/tmp/masked.py');\n    const imageName = 'stdin-history-search.png';\n    const cell = await page.notebook.getCell(1);\n    expect(await cell.screenshot()).toMatchSnapshot(imageName);\n\n    // Check that the input remains focused and cursor is at the end.\n    await page.keyboard.insertText('x');\n    await expect(page.locator('.jp-Stdin-input')).toHaveValue('foofoox');\n  });",
            "file": "jupyterlab/outputarea-stdin.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Prompt to rename new  file",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 41,
                "index": 364
            },
            "line": 12,
            "code": "  test(`Prompt to rename new ${type} file`, async ({\n    page\n  }) => {\n    await page.menu.clickMenuItem(type === 'Notebook' ? `File>New>${type}` : `File>New>${type} File`);\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}${EXTENSION[type]}`);\n    if (type === 'Notebook') {\n      // Select the kernel\n      await page.click('.jp-Dialog >> button >> text=Select');\n    }\n    await page.menu.clickMenuItem(type === 'Markdown' ? `File>Save ${type} File` : `File>Save ${type}`);\n    await page.waitForSelector('.jp-Dialog >> text=Rename file');\n    await expect(page.locator('.jp-Dialog >> input[placeholder=\"File name\"]')).toHaveValue(type === 'Notebook' ? `U${DEFAULT_NAME.slice(1)}${EXTENSION[type]}` : `${DEFAULT_NAME}${EXTENSION[type]}`);\n    await page.click('.jp-Dialog >> button >> text=Cancel');\n  });",
            "file": "jupyterlab/save.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Should not prompt to rename new renamed  file",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 60,
                "index": 1270
            },
            "line": 28,
            "code": "  test(`Should not prompt to rename new renamed ${type} file`, async ({\n    page\n  }) => {\n    await page.menu.clickMenuItem(type === 'Notebook' ? `File>New>${type}` : `File>New>${type} File`);\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}${EXTENSION[type]}`);\n    if (type === 'Notebook') {\n      // Select the kernel\n      await page.click('.jp-Dialog >> button >> text=Select');\n    }\n    await page.menu.clickMenuItem(type === 'Markdown' ? `File>Rename ${type} File…` : `File>Rename ${type}…`);\n    await page.fill('.jp-Dialog >> input', `dummy${EXTENSION[type]}`);\n    await page.click('.jp-Dialog >> button >> text=Rename');\n    await page.menu.clickMenuItem(type === 'Markdown' ? `File>Save ${type} File` : `File>Save ${type}`);\n    await expect(page.locator('.jp-Dialog')).toHaveCount(0);\n  });",
            "file": "jupyterlab/save.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search with a text",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 24,
                "index": 1140
            },
            "line": 26,
            "code": "test('Search with a text', async ({\n  page\n}) => {\n  const searchText = 'ipsum';\n  await page.evaluate(async searchText => {\n    await window.jupyterapp.commands.execute('documentsearch:start', {\n      searchText\n    });\n  }, searchText);\n  await expect(page.locator('[placeholder=\"Find\"]')).toHaveValue(searchText);\n});",
            "file": "jupyterlab/search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Search with a text and replacement",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 40,
                "index": 1477
            },
            "line": 37,
            "code": "test('Search with a text and replacement', async ({\n  page\n}) => {\n  const searchText = 'ipsum';\n  const replaceText = 'banana';\n  await page.evaluate(async ([searchText, replaceText]) => {\n    await window.jupyterapp.commands.execute('documentsearch:startWithReplace', {\n      searchText,\n      replaceText\n    });\n  }, [searchText, replaceText]);\n  await expect(page.locator('[placeholder=\"Find\"]')).toHaveValue(searchText);\n  await expect(page.locator('[placeholder=\"Replace\"]')).toHaveValue(replaceText);\n});",
            "file": "jupyterlab/search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Populate search box with selected text",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 44,
                "index": 1994
            },
            "line": 51,
            "code": "test('Populate search box with selected text', async ({\n  page\n}) => {\n  const imageName = 'text-editor-search-from-selection.png';\n\n  // Enter first cell\n  await page.notebook.enterCellEditingMode(0);\n\n  // Go to first line\n  await page.keyboard.press('PageUp');\n  // Select first line\n  await page.keyboard.press('Home');\n  await page.keyboard.press('Control+Shift+ArrowRight');\n  // Open search box\n  await page.keyboard.press('Control+f');\n\n  // Expect it to be populated with the first word\n  const inputWithFirstWord = page.locator('[placeholder=\"Find\"] >> text=\"Lorem\"');\n  await expect(inputWithFirstWord).toBeVisible();\n  await expect(inputWithFirstWord).toBeFocused();\n  // Expect the newly set text to be selected\n  expect(await inputWithFirstWord.evaluate(getSelectionRange)).toStrictEqual({\n    start: 0,\n    end: 5\n  });\n\n  // Expect the first match to be highlighted\n  await page.waitForSelector('text=1/2');\n  const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n  expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n});",
            "file": "jupyterlab/search.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open the settings editor with a specific search query",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 59,
                "index": 250
            },
            "line": 6,
            "code": "test('Open the settings editor with a specific search query', async ({\n  page\n}) => {\n  await page.evaluate(async () => {\n    await window.jupyterapp.commands.execute('settingeditor:open', {\n      query: 'Command Palette'\n    });\n  });\n  expect(await page.locator('.jp-PluginList .jp-FilterBox input').inputValue()).toEqual('Command Palette');\n  await expect(page.locator('.jp-SettingsForm')).toHaveCount(1);\n  const pluginList = page.locator('.jp-PluginList');\n  expect(await pluginList.screenshot()).toMatchSnapshot('settings-plugin-list.png');\n  const settingsPanel = page.locator('.jp-SettingsPanel');\n  expect(await settingsPanel.screenshot()).toMatchSnapshot('settings-panel.png');\n});",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Increase Code Font Size",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 38,
                "index": 2885
            },
            "line": 60,
            "code": "  test('should Increase Code Font Size', async ({\n    page\n  }) => {\n    await createNewCodeCell(page);\n    const fontSize = await getCodeCellFontSize(page);\n    await changeCodeFontSize(page, 'Increase Code Font Size');\n    await page.waitForSelector('div[role=\"main\"] >> text=Launcher');\n    await page.waitForSelector('.jp-Notebook-cell');\n    const cellElement = await page.$('div.lm-Widget.jp-Cell.jp-CodeCell.jp-Notebook-cell.jp-mod-noOutputs.jp-mod-active.jp-mod-selected .cm-line');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), cellElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize + 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Decrease Code Font Size",
            "suites": [],
            "updatePoint": {
                "line": 72,
                "column": 38,
                "index": 3535
            },
            "line": 72,
            "code": "  test('should Decrease Code Font Size', async ({\n    page\n  }) => {\n    await createNewCodeCell(page);\n    const fontSize = await getCodeCellFontSize(page);\n    await changeCodeFontSize(page, 'Decrease Code Font Size');\n    await page.waitForSelector('div[role=\"main\"] >> text=Launcher');\n    await page.waitForSelector('.jp-Notebook-cell');\n    const cellElement = await page.$('div.lm-Widget.jp-Cell.jp-CodeCell.jp-Notebook-cell.jp-mod-noOutputs.jp-mod-active.jp-mod-selected .cm-line');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), cellElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize - 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Increase Content Font Size",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 41,
                "index": 4188
            },
            "line": 84,
            "code": "  test('should Increase Content Font Size', async ({\n    page\n  }) => {\n    const markdownFile = await createMarkdownFile(page);\n    await inputMarkdownFile(page, markdownFile);\n    await page.evaluate(() => {\n      return window.galata.app.commands.execute('fileeditor:markdown-preview');\n    });\n    const fontSize = await getMarkdownFontSize(page);\n    await changeCodeFontSize(page, 'Increase Content Font Size');\n    await page.waitForSelector('.jp-FileEditor .cm-content');\n    const fileElement = await page.$('.jp-RenderedHTMLCommon');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), fileElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize + 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Decrease Content Font Size",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 41,
                "index": 4891
            },
            "line": 99,
            "code": "  test('should Decrease Content Font Size', async ({\n    page\n  }) => {\n    const markdownFile = await createMarkdownFile(page);\n    await inputMarkdownFile(page, markdownFile);\n    await page.evaluate(() => {\n      return window.galata.app.commands.execute('fileeditor:markdown-preview');\n    });\n    const fontSize = await getMarkdownFontSize(page);\n    await changeCodeFontSize(page, 'Decrease Content Font Size');\n    await page.waitForSelector('.jp-FileEditor .cm-content');\n    const fileElement = await page.$('.jp-RenderedHTMLCommon');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), fileElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize - 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Increase UI Font Size",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 36,
                "index": 5589
            },
            "line": 114,
            "code": "  test('should Increase UI Font Size', async ({\n    page\n  }) => {\n    await page.notebook.createNew(ipynbFileName);\n    const fontSize = await getFileListFontSize(page);\n    await changeCodeFontSize(page, 'Increase UI Font Size');\n    await page.waitForSelector('.jp-DirListing-content .jp-DirListing-itemText');\n    const fileElement = await page.$('.jp-DirListing-content .jp-DirListing-itemText');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), fileElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize + 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should Decrease UI Font Size",
            "suites": [],
            "updatePoint": {
                "line": 125,
                "column": 36,
                "index": 6150
            },
            "line": 125,
            "code": "  test('should Decrease UI Font Size', async ({\n    page\n  }) => {\n    await page.notebook.createNew(ipynbFileName);\n    const fontSize = await getFileListFontSize(page);\n    await changeCodeFontSize(page, 'Decrease UI Font Size');\n    await page.waitForSelector('.jp-DirListing-content .jp-DirListing-itemText');\n    const fileElement = await page.$('.jp-DirListing-content .jp-DirListing-itemText');\n    const computedStyle = await page.evaluate(el => getComputedStyle(el), fileElement);\n    expect(computedStyle.fontSize).toEqual(`${fontSize - 1}px`);\n  });",
            "file": "jupyterlab/settings.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Shortcut commands must exist",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 34,
                "index": 378
            },
            "line": 10,
            "code": "test('Shortcut commands must exist', async ({\n  page\n}) => {\n  await page.goto();\n  const [shortcuts, commands] = await page.evaluate(async () => {\n    const shortcuts = window.jupyterapp.commands.keyBindings;\n    const commandIds = window.jupyterapp.commands.listCommands();\n    return Promise.resolve([shortcuts, commandIds]);\n  });\n  const missingCommands = shortcuts.filter(shortcut => !commands.includes(shortcut.command));\n  expect(missingCommands).toEqual([]);\n});",
            "file": "jupyterlab/shortcuts.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Shortcuts must be unique",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 30,
                "index": 846
            },
            "line": 22,
            "code": "test('Shortcuts must be unique', async ({\n  page\n}) => {\n  const warnings = [];\n  page.on('console', message => {\n    if (message.type() === 'warning') {\n      warnings.push(message.text());\n    }\n  });\n  await page.goto();\n  expect(warnings.filter(s => s.startsWith(DUPLICATE_SHORTCUT_WARNING))\n  // List warning messages only once\n  .reduce((agg, message) => {\n    if (!agg.includes(message)) {\n      agg.push(message);\n    }\n    return agg;\n  }, [])).toEqual([]);\n});",
            "file": "jupyterlab/shortcuts.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open Sidebar tab ",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 39,
                "index": 763
            },
            "line": 19,
            "code": "    test(`Open Sidebar tab ${sidebarId}`, async ({\n      page\n    }) => {\n      await page.sidebar.openTab(sidebarId);\n      expect(await page.sidebar.isTabOpen(sidebarId)).toEqual(true);\n      const imageName = `opened-sidebar-${sidebarId.replace('.', '-')}.png`;\n      const position = await page.sidebar.getTabPosition(sidebarId);\n      const sidebar = await page.sidebar.getContentPanel(position);\n      expect(await sidebar.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n    });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "File Browser has no unused rules",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 40,
                "index": 1263
            },
            "line": 30,
            "code": "  test('File Browser has no unused rules', async ({\n    page\n  }) => {\n    await page.sidebar.openTab('filebrowser');\n    const clickMenuItem = async command => {\n      const contextmenu = await page.menu.openContextMenu('.jp-DirListing-headerItem');\n      const item = await page.menu.getMenuItemInMenu(contextmenu, command);\n      await item.click();\n    };\n    await clickMenuItem('Show File Checkboxes');\n    await clickMenuItem('Show File Size Column');\n    await page.notebook.createNew('notebook.ipynb');\n    const unusedRules = await page.style.findUnusedStyleRules({\n      page,\n      fragments: ['jp-DirListing', 'jp-FileBrowser'],\n      exclude: [\n      // active during renaming\n      'jp-DirListing-editor',\n      // hidden files\n      '[data-is-dot]',\n      // filtering results\n      '.jp-DirListing-content mark',\n      // only added after resizing\n      'jp-DirListing-narrow']\n    });\n    expect(unusedRules.length).toEqual(0);\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Left light tabbar (with text)",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 37,
                "index": 2212
            },
            "line": 57,
            "code": "  test('Left light tabbar (with text)', async ({\n    page\n  }) => {\n    await page.theme.setLightTheme();\n    const imageName = 'left-light-tabbar-with-text.png';\n    const tabbar = await page.sidebar.getTabBar();\n    await mockLabelOnFirstTab(tabbar, 'File Browser');\n    expect(await tabbar.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Right dark tabbar (with text)",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 37,
                "index": 2567
            },
            "line": 66,
            "code": "  test('Right dark tabbar (with text)', async ({\n    page\n  }) => {\n    await page.theme.setDarkTheme();\n    const imageName = 'right-dark-tabbar-with-text.png';\n    const tabbar = await page.sidebar.getTabBar('right');\n    await mockLabelOnFirstTab(tabbar, 'Property Inspector');\n    expect(await tabbar.screenshot()).toMatchSnapshot(imageName.toLowerCase());\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move File Browser to right",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 34,
                "index": 2931
            },
            "line": 75,
            "code": "  test('Move File Browser to right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    expect(await page.sidebar.getTabPosition('filebrowser')).toBe('right');\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open File Browser on right",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 34,
                "index": 3132
            },
            "line": 81,
            "code": "  test('Open File Browser on right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    await page.sidebar.openTab('filebrowser');\n    expect(await page.sidebar.isTabOpen('filebrowser')).toEqual(true);\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open Sidebar on right",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 29,
                "index": 3370
            },
            "line": 88,
            "code": "  test('Open Sidebar on right', async ({\n    page\n  }) => {\n    await page.sidebar.open('right');\n    expect(await page.sidebar.isOpen('right')).toEqual(true);\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Close Sidebar on right",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 30,
                "index": 3537
            },
            "line": 94,
            "code": "  test('Close Sidebar on right', async ({\n    page\n  }) => {\n    await page.sidebar.open('right');\n    await page.menu.clickMenuItem('View>Appearance>Show Right Sidebar');\n    expect(await page.sidebar.isOpen('right')).toEqual(false);\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Capture File Browser on right",
            "suites": [],
            "updatePoint": {
                "line": 101,
                "column": 37,
                "index": 3785
            },
            "line": 101,
            "code": "  test('Capture File Browser on right', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToRight('filebrowser');\n    await page.sidebar.openTab('filebrowser');\n    let imageName = 'filebrowser-right.png';\n    expect(await page.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Move Debugger to left",
            "suites": [],
            "updatePoint": {
                "line": 109,
                "column": 29,
                "index": 4061
            },
            "line": 109,
            "code": "  test('Move Debugger to left', async ({\n    page\n  }) => {\n    await page.sidebar.moveTabToLeft('jp-debugger-sidebar');\n    expect(await page.sidebar.getTabPosition('jp-debugger-sidebar')).toEqual('left');\n  });",
            "file": "jupyterlab/sidebars.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "No non-specific selectors after pseudo-class ( theme)",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 71,
                "index": 2174
            },
            "line": 23,
            "code": "    test(`No non-specific selectors after pseudo-class (${theme} theme)`, async ({\n      page\n    }) => {\n      switch (theme) {\n        case 'dark':\n          await page.theme.setDarkTheme();\n          break;\n        case 'light':\n          await page.theme.setLightTheme();\n          break;\n        default:\n          expect(false);\n      }\n\n      // Create a new notebook and add a MathJax 2 element to ensure that\n      // we cover MathJax styles which get injected dynamically.\n      await page.notebook.createNew(fileName);\n      await page.notebook.addCell('markdown', '$test$');\n      await page.notebook.runCell(1, true);\n      await page.locator('.MathJax').isVisible();\n      const detectedTags = new Set(await page.evaluate(() => [...document.body.getElementsByTagName('*')].map(element => element.tagName.toLowerCase())));\n      // We do not rely on present element tags only as outputs in user notebooks may\n      // include additional element tags not used by JupyterLab itself; we do not rely on\n      // known tags only either, as JupyterLab or extensions may use tags we did not\n      // include in the list of known tags.\n\n      const allTags = new Set([...standardHTMLTags, ...detectedTags]);\n      const selectors = await page.style.collectAllSelectors();\n      const matcher = new RegExp(':hover.*\\\\s+(' + [...allTags].join('|') + ')($|\\\\s)');\n      const matchedSelectors = [];\n      for (const selectorGroup of selectors) {\n        for (const selector of selectorGroup.split(',')) {\n          if (selector.match(matcher)) {\n            matchedSelectors.push(selector);\n          }\n        }\n      }\n      if (matchedSelectors.length) {\n        console.warn('Detected CSS selectors that might cause performance issues in Chromium', matchedSelectors);\n      }\n      expect(matchedSelectors).toHaveLength(0);\n    });",
            "file": "jupyterlab/styles.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should appear in the sidebar",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 38,
                "index": 520
            },
            "line": 17,
            "code": "    test('should appear in the sidebar', async ({\n      page\n    }) => {\n      await page.sidebar.openTab('jp-running-sessions');\n      await expect(page.locator('text=terminals/1')).toBeVisible();\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Light theme terminal inherit",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 38,
                "index": 765
            },
            "line": 25,
            "code": "    test('Light theme terminal inherit', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'inherit');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-inherit.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Light theme terminal light",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 36,
                "index": 1100
            },
            "line": 33,
            "code": "    test('Light theme terminal light', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Light');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'light');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-light.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Light theme terminal dark",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 35,
                "index": 1500
            },
            "line": 42,
            "code": "    test('Light theme terminal dark', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Dark');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'dark');\n      expect(await terminal.screenshot()).toMatchSnapshot('light-term-dark.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Dark theme terminal inherit",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 37,
                "index": 1899
            },
            "line": 51,
            "code": "    test('Dark theme terminal inherit', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'inherit');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-inherit.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Dark theme terminal light",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 35,
                "index": 2271
            },
            "line": 60,
            "code": "    test('Dark theme terminal light', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Light');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'light');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-light.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Dark theme terminal dark",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 34,
                "index": 2708
            },
            "line": 70,
            "code": "    test('Dark theme terminal dark', async ({\n      page\n    }) => {\n      const terminal = page.locator(TERMINAL_SELECTOR);\n      await terminal.waitFor();\n      await page.theme.setDarkTheme();\n      await page.menu.clickMenuItem('Settings>Terminal Theme>Dark');\n      await expect(terminal).toHaveAttribute(TERMINAL_THEME_ATTRIBUTE, 'dark');\n      expect(await terminal.screenshot()).toMatchSnapshot('dark-term-dark.png');\n    });",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Terminal should open in Launcher cwd",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 42,
                "index": 3160
            },
            "line": 82,
            "code": "test('Terminal should open in Launcher cwd', async ({\n  page,\n  tmpPath\n}) => {\n  await page.waitForSelector(`.jp-Launcher-cwd > h3:has-text(\"${tmpPath}\")`);\n  await page.locator('[role=\"main\"] >> p:has-text(\"Terminal\")').click();\n  const terminal = page.locator(TERMINAL_SELECTOR);\n  await terminal.waitFor();\n  await page.waitForTimeout(1000);\n  await page.keyboard.type('basename $PWD');\n  await page.keyboard.press('Enter');\n  await page.waitForTimeout(1000);\n  expect(await terminal.screenshot()).toMatchSnapshot('launcher-term.png');\n});",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Terminal web link",
            "suites": [],
            "updatePoint": {
                "line": 96,
                "column": 23,
                "index": 3685
            },
            "line": 96,
            "code": "test('Terminal web link', async ({\n  page,\n  tmpPath\n}) => {\n  await page.waitForSelector(`.jp-Launcher-cwd > h3:has-text(\"${tmpPath}\")`);\n  await page.locator('[role=\"main\"] >> p:has-text(\"Terminal\")').click();\n  const terminal = page.locator(TERMINAL_SELECTOR);\n  await terminal.waitFor();\n  await page.waitForTimeout(1000);\n  await page.keyboard.type('echo https://jupyter.org/');\n  await page.keyboard.press('Enter');\n  await page.waitForTimeout(1000);\n  await Promise.all([terminal.locator('.jp-Terminal-body .xterm-cursor-pointer').waitFor(), terminal.locator('canvas.xterm-cursor-layer').hover({\n    position: {\n      x: 60,\n      y: 23\n    }\n  })]);\n  expect(await terminal.screenshot()).toMatchSnapshot('web-links-term.png');\n});",
            "file": "jupyterlab/terminal.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open a text editor",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 26,
                "index": 262
            },
            "line": 7,
            "code": "  test('Open a text editor', async ({\n    page\n  }) => {\n    const imageName = 'text-editor.png';\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n    expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/texteditor.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Changing a text editor settings",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 39,
                "index": 644
            },
            "line": 16,
            "code": "  test('Changing a text editor settings', async ({\n    page\n  }) => {\n    const imageName = 'text-editor-rulers.png';\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.getByRole('main').getByText(DEFAULT_NAME).waitFor();\n    await page.menu.clickMenuItem('Settings>Settings Editor');\n    await page.getByRole('tab', {\n      name: 'Text Editor'\n    }).getByText('Text Editor').click();\n\n    // Add two rulers\n    await page.locator('#root').getByRole('button', {\n      name: 'Add'\n    }).click();\n    await page.locator('input[id=\"root_rulers_0\"]').type('50');\n    await page.locator('#root').getByRole('button', {\n      name: 'Add'\n    }).click();\n    await page.locator('input[id=\"root_rulers_1\"]').type('75');\n    await page.activity.activateTab(DEFAULT_NAME);\n    const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n    expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/texteditor.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Go to line with argument",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 32,
                "index": 1563
            },
            "line": 40,
            "code": "  test('Go to line with argument', async ({\n    page\n  }) => {\n    const imageName = 'go-to-line-editor.png';\n    await page.menu.clickMenuItem('File>New>Text File');\n    await page.waitForSelector(`[role=\"main\"] >> text=${DEFAULT_NAME}`);\n    await page.type('.cm-content', `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam urna\nlibero, dictum a egestas non, placerat vel neque. In imperdiet iaculis fermentum.\nVestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia\nCurae; Cras augue tortor, tristique vitae varius nec, dictum eu lectus. Pellentesque\nid eleifend eros. In non odio in lorem iaculis sollicitudin. In faucibus ante ut\narcu fringilla interdum. Maecenas elit nulla, imperdiet nec blandit et, consequat\nut elit.`);\n    await page.evaluate(async () => {\n      await window.jupyterapp.commands.execute('fileeditor:go-to-line', {\n        line: 2,\n        column: 8\n      });\n    });\n    await page.keyboard.type('#2:8#');\n    const tabHandle = await page.activity.getPanel(DEFAULT_NAME);\n    expect(await tabHandle.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/texteditor.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display running indicators",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 41,
                "index": 966
            },
            "line": 21,
            "code": "  test('should display running indicators', async ({\n    page\n  }) => {\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const executed = page.notebook.run();\n    await tocPanel.waitForSelector('[data-running=\"1\"]');\n    expect(await tocPanel.screenshot()).toMatchSnapshot('toc-running-indicators.png');\n    await executed;\n  });",
            "file": "jupyterlab/toc-running.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should display running indicator on first visible top level",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 67,
                "index": 1390
            },
            "line": 30,
            "code": "  test('should display running indicator on first visible top level', async ({\n    page\n  }) => {\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    await page.notebook.run();\n\n    // Collapse ToC\n    await page.click('[aria-label=\"Table of Contents section\"] >> button:left-of(:text(\"Title 1\"))');\n    const executed = page.notebook.runCell(5);\n    await tocPanel.waitForSelector('[data-running=\"1\"]');\n    expect(await tocPanel.screenshot()).toMatchSnapshot('toc-running-indicator-top-level.png');\n    await executed;\n  });",
            "file": "jupyterlab/toc-running.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Open Table of Contents panel",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 36,
                "index": 1109
            },
            "line": 39,
            "code": "  test('Open Table of Contents panel', async ({\n    page\n  }) => {\n    const imageName = 'toc-panel.png';\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/toc.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Toggle list",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 19,
                "index": 1385
            },
            "line": 46,
            "code": "  test('Toggle list', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    const numberingButton = await tocPanel.$$('button[data-command=\"toc:display-numbering\"]');\n    expect(numberingButton.length).toBe(1);\n    const imageName = 'toggle-numbered-list.png';\n    await numberingButton[0].click();\n    expect(await tocPanel.screenshot()).toMatchSnapshot(imageName);\n  });",
            "file": "jupyterlab/toc.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "Notebook context menu",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 29,
                "index": 1899
            },
            "line": 57,
            "code": "  test('Notebook context menu', async ({\n    page\n  }) => {\n    await page.notebook.selectCells(0);\n    const tocPanel = await page.sidebar.getContentPanel(await page.sidebar.getTabPosition('table-of-contents'));\n    await Promise.all([page.locator('.jp-TableOfContents-tree >> .jp-tocItem-active >> text=\"2. Multiple output types\"'), page.locator('.jp-TableOfContents-tree >> text=\"2. Multiple output types\"').click({\n      button: 'right'\n    })]);\n    const menu = await page.menu.getOpenMenu();\n    await (await menu.$('text=Select and Run Cell(s) for this Heading')).click();\n    await page.locator('.jp-TableOfContents-tree >> text=\"2. HTML title\"').waitFor();\n    expect(await tocPanel.screenshot()).toMatchSnapshot('notebook-output-headings.png');\n  });",
            "file": "jupyterlab/toc.test.ts",
            "skipped": false,
            "dir": "galata/test"
        },
        {
            "name": "should construct a new layout restorer",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 48
            },
            "line": 14,
            "code": "      it('should construct a new layout restorer', () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve<void>(void 0),\n          registry: new CommandRegistry()\n        });\n        expect(restorer).toBeInstanceOf(LayoutRestorer);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a promise available right away",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#restored"
            ],
            "updatePoint": {
                "line": 25,
                "column": 50
            },
            "line": 25,
            "code": "      it('should be a promise available right away', () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve<void>(void 0),\n          registry: new CommandRegistry()\n        });\n        expect(restorer.restored).toBeInstanceOf(Promise);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should resolve when restorer is done",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#restored"
            ],
            "updatePoint": {
                "line": 34,
                "column": 46
            },
            "line": 34,
            "code": "      it('should resolve when restorer is done', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const promise = restorer.restored;\n        ready.resolve(void 0);\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget in the main area to be tracked by the restorer",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#add()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 76
            },
            "line": 48,
            "code": "      it('should add a widget in the main area to be tracked by the restorer', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: null },\n          leftArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout.mainArea?.currentWidget).toBe(currentWidget);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget in the down area to be tracked by the restorer",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#add()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 76
            },
            "line": 82,
            "code": "      it('should add a widget in the down area to be tracked by the restorer', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget, widgets: null, size: null },\n          leftArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout.downArea?.currentWidget).toBe(currentWidget);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should always return a value",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 118,
                "column": 38
            },
            "line": 118,
            "code": "      it('should always return a value', async () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: Promise.resolve(void 0),\n          registry: new CommandRegistry()\n        });\n        const layout = await restorer.fetch();\n        expect(layout).not.toBe(null);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should fetch saved data",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 33
            },
            "line": 128,
            "code": "      it('should fetch saved data', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        // The `fresh` attribute is only here to check against the return value.\n        const dehydrated: ILabShell.ILayout = {\n          fresh: false,\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: 0 },\n          leftArea: {\n            currentWidget,\n            collapsed: true,\n            widgets: [currentWidget],\n            visible: true\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout).toEqual(dehydrated);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should restore the widgets in a tracker",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#restore()"
            ],
            "updatePoint": {
                "line": 166,
                "column": 49
            },
            "line": 166,
            "code": "      it('should restore the widgets in a tracker', async () => {\n        const tracker = new WidgetTracker({ namespace: 'foo-widget' });\n        const registry = new CommandRegistry();\n        const state = new StateDB();\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: state,\n          first: ready.promise,\n          registry\n        });\n        let called = false;\n        const key = `${tracker.namespace}:${tracker.namespace}`;\n\n        registry.addCommand(tracker.namespace, {\n          execute: () => {\n            called = true;\n          }\n        });\n        await state.save(key, { data: null });\n        ready.resolve(undefined);\n        await restorer.restore(tracker, {\n          name: () => tracker.namespace,\n          command: tracker.namespace\n        });\n        await restorer.restored;\n        expect(called).toBe(true);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should not run before `first` promise",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#save()"
            ],
            "updatePoint": {
                "line": 196,
                "column": 47
            },
            "line": 196,
            "code": "      it('should not run before `first` promise', async () => {\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: new Promise(() => {\n            // no op\n          }),\n          registry: new CommandRegistry()\n        });\n        const dehydrated: ILabShell.ILayout = {\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: null },\n          leftArea: {\n            currentWidget: null,\n            collapsed: true,\n            widgets: null,\n            visible: false\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n\n        await expect(restorer.save(dehydrated)).rejects.toBe(\n          'save() was called prematurely.'\n        );\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should save data",
            "suites": [
                "apputils",
                "LayoutRestorer",
                "#save()"
            ],
            "updatePoint": {
                "line": 228,
                "column": 26
            },
            "line": 228,
            "code": "      it('should save data', async () => {\n        const ready = new PromiseDelegate<void>();\n        const restorer = new LayoutRestorer({\n          connector: new StateDB(),\n          first: ready.promise,\n          registry: new CommandRegistry()\n        });\n        const currentWidget = new Widget();\n        // The `fresh` attribute is only here to check against the return value.\n        const dehydrated: ILabShell.ILayout = {\n          fresh: false,\n          mainArea: { currentWidget: null, dock: null },\n          downArea: { currentWidget: null, widgets: null, size: 0 },\n          leftArea: {\n            currentWidget,\n            collapsed: true,\n            widgets: [currentWidget],\n            visible: true\n          },\n          rightArea: {\n            collapsed: true,\n            currentWidget: null,\n            widgets: null,\n            visible: false\n          },\n          relativeSizes: null,\n          topArea: { simpleVisibility: true }\n        };\n        restorer.add(currentWidget, 'test-one');\n        ready.resolve(void 0);\n        await restorer.restored;\n        await restorer.save(dehydrated);\n        const layout = await restorer.fetch();\n        expect(layout).toEqual(dehydrated);\n      });",
            "file": "layoutrestorer.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should construct a new router",
            "suites": [
                "apputils",
                "Router",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 22,
                "column": 39
            },
            "line": 22,
            "code": "      it('should construct a new router', () => {\n        expect(router).toBeInstanceOf(Router);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be the base URL of the application",
            "suites": [
                "apputils",
                "Router",
                "#base"
            ],
            "updatePoint": {
                "line": 28,
                "column": 51
            },
            "line": 28,
            "code": "      it('should be the base URL of the application', () => {\n        expect(router.base).toBe(base);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be the command registry used by the router",
            "suites": [
                "apputils",
                "Router",
                "#commands"
            ],
            "updatePoint": {
                "line": 34,
                "column": 59
            },
            "line": 34,
            "code": "      it('should be the command registry used by the router', () => {\n        expect(router.commands).toBe(commands);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should return the current window location as an object",
            "suites": [
                "apputils",
                "Router",
                "#current"
            ],
            "updatePoint": {
                "line": 40,
                "column": 64
            },
            "line": 40,
            "code": "      it('should return the current window location as an object', () => {\n        const path = '/';\n        const request = path;\n        const search = '';\n        const hash = '';\n\n        expect(router.current).toEqual({ hash, path, request, search });\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should emit a signal when a path is routed",
            "suites": [
                "apputils",
                "Router",
                "#routed"
            ],
            "updatePoint": {
                "line": 51,
                "column": 52
            },
            "line": 51,
            "code": "      it('should emit a signal when a path is routed', async () => {\n        let routed = false;\n\n        commands.addCommand('a', {\n          execute: () => {\n            routed = true;\n          }\n        });\n        router.register({ command: 'a', pattern: /.*/, rank: 10 });\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(routed).toBe(true);\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a unique token",
            "suites": [
                "apputils",
                "Router",
                "#stop"
            ],
            "updatePoint": {
                "line": 72,
                "column": 34
            },
            "line": 72,
            "code": "      it('should be a unique token', () => {\n        expect(router.stop).toBeInstanceOf(Token);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should stop routing if returned by a routed command",
            "suites": [
                "apputils",
                "Router",
                "#stop"
            ],
            "updatePoint": {
                "line": 76,
                "column": 61
            },
            "line": 76,
            "code": "      it('should stop routing if returned by a routed command', async () => {\n        const wanted = ['a', 'b'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        commands.addCommand('b', {\n          execute: () => {\n            recorded.push('b');\n          }\n        });\n        commands.addCommand('c', { execute: () => router.stop });\n        commands.addCommand('d', {\n          execute: () => {\n            recorded.push('d');\n          }\n        });\n\n        router.register({ command: 'a', pattern: /.*/, rank: 10 });\n        router.register({ command: 'b', pattern: /.*/, rank: 20 });\n        router.register({ command: 'c', pattern: /.*/, rank: 30 });\n        router.register({ command: 'd', pattern: /.*/, rank: 40 });\n\n        const promise = signalToPromise(router.routed);\n        await router.route();\n        await promise;\n        expect(recorded).toEqual(wanted);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "cannot be tested since changing location is a security risk",
            "suites": [
                "apputils",
                "Router",
                "#navigate()"
            ],
            "line": 110,
            "code": "      it.skip('cannot be tested since changing location is a security risk', () => {",
            "file": "router.spec.ts",
            "skipped": true,
            "dir": "packages/application/test"
        },
        {
            "name": "should register a command with a route pattern",
            "suites": [
                "apputils",
                "Router",
                "#register()"
            ],
            "updatePoint": {
                "line": 117,
                "column": 56
            },
            "line": 117,
            "code": "      it('should register a command with a route pattern', async () => {\n        const wanted = ['a'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        router.register({ command: 'a', pattern: /.*/ });\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(recorded).toEqual(wanted);\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should route the location to a command",
            "suites": [
                "apputils",
                "Router",
                "#route()"
            ],
            "updatePoint": {
                "line": 139,
                "column": 48
            },
            "line": 139,
            "code": "      it('should route the location to a command', async () => {\n        const wanted = ['a'];\n        const recorded: string[] = [];\n\n        commands.addCommand('a', {\n          execute: () => {\n            recorded.push('a');\n          }\n        });\n        router.register({ command: 'a', pattern: /#a/, rank: 10 });\n        expect(recorded.length).toBe(0);\n\n        // Change the hash because changing location is a security error.\n        window.location.hash = 'a';\n\n        let called = false;\n        router.routed.connect(() => {\n          expect(recorded).toEqual(wanted);\n          window.location.hash = '';\n          called = true;\n        });\n        await router.route();\n        expect(called).toBe(true);\n      });",
            "file": "router.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should create a LabShell instance",
            "suites": [
                "LabShell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 41
            },
            "line": 39,
            "code": "    it('should create a LabShell instance', () => {\n      expect(shell).toBeInstanceOf(LabShell);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should return whether the left area is collapsed",
            "suites": [
                "LabShell",
                "#leftCollapsed"
            ],
            "updatePoint": {
                "line": 45,
                "column": 56
            },
            "line": 45,
            "code": "    it('should return whether the left area is collapsed', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.leftCollapsed).toBe(true);\n      shell.activateById('foo');\n      expect(shell.leftCollapsed).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should return whether the right area is collapsed",
            "suites": [
                "LabShell",
                "#rightCollapsed"
            ],
            "updatePoint": {
                "line": 56,
                "column": 57
            },
            "line": 56,
            "code": "    it('should return whether the right area is collapsed', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.rightCollapsed).toBe(true);\n      shell.activateById('foo');\n      expect(shell.rightCollapsed).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be the current widget in the shell main area",
            "suites": [
                "LabShell",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 67,
                "column": 59
            },
            "line": 67,
            "code": "    it('should be the current widget in the shell main area', () => {\n      expect(shell.currentWidget).toBe(null);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.currentWidget).toBe(null);\n      simulate(widget.node, 'focus');\n      expect(shell.currentWidget).toBe(widget);\n      widget.parent = null;\n      expect(shell.currentWidget).toBe(null);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should test whether the main area is empty",
            "suites": [
                "LabShell",
                "#isEmpty()"
            ],
            "updatePoint": {
                "line": 81,
                "column": 50
            },
            "line": 81,
            "code": "    it('should test whether the main area is empty', () => {\n      expect(shell.isEmpty('main')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should test whether the top area is empty",
            "suites": [
                "LabShell",
                "#isEmpty()"
            ],
            "updatePoint": {
                "line": 89,
                "column": 49
            },
            "line": 89,
            "code": "    it('should test whether the top area is empty', () => {\n      // top-level menu area is added by default\n      expect(shell.isEmpty('top')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should test whether the menu area is empty",
            "suites": [
                "LabShell",
                "#isEmpty()"
            ],
            "updatePoint": {
                "line": 94,
                "column": 50
            },
            "line": 94,
            "code": "    it('should test whether the menu area is empty', () => {\n      expect(shell.isEmpty('menu')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should test whether the left area is empty",
            "suites": [
                "LabShell",
                "#isEmpty()"
            ],
            "updatePoint": {
                "line": 102,
                "column": 50
            },
            "line": 102,
            "code": "    it('should test whether the left area is empty', () => {\n      expect(shell.isEmpty('left')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should test whether the right area is empty",
            "suites": [
                "LabShell",
                "#isEmpty()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 51
            },
            "line": 110,
            "code": "    it('should test whether the right area is empty', () => {\n      expect(shell.isEmpty('right')).toBe(true);\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should resolve when the app is restored for the first time",
            "suites": [
                "LabShell",
                "#restored"
            ],
            "updatePoint": {
                "line": 120,
                "column": 66
            },
            "line": 120,
            "code": "    it('should resolve when the app is restored for the first time', async () => {\n      const restorer = new LayoutRestorer({\n        connector: new StateDB(),\n        first: Promise.resolve<void>(void 0),\n        registry: new CommandRegistry()\n      });\n      const mode: DockPanel.Mode = 'multiple-document';\n      await shell.restoreLayout(mode, restorer);\n      await expect(shell.restored).resolves.not.toThrow();\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the header",
            "suites": [
                "LabShell",
                "#add(widget, \"header\")"
            ],
            "updatePoint": {
                "line": 133,
                "column": 41
            },
            "line": 133,
            "code": "    it('should add a widget to the header', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'header');\n      expect(shell.isEmpty('header')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"header\")"
            ],
            "updatePoint": {
                "line": 140,
                "column": 49
            },
            "line": 140,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'header');\n      expect(shell.isEmpty('header')).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "LabShell",
                "#add(widget, \"header\")"
            ],
            "updatePoint": {
                "line": 146,
                "column": 29
            },
            "line": 146,
            "code": "    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'header', { rank: 10 });\n      expect(shell.isEmpty('header')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the menu",
            "suites": [
                "LabShell",
                "#add(widget, \"menu\")"
            ],
            "updatePoint": {
                "line": 155,
                "column": 39
            },
            "line": 155,
            "code": "    it('should add a widget to the menu', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"menu\")"
            ],
            "updatePoint": {
                "line": 162,
                "column": 49
            },
            "line": 162,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'menu');\n      expect(shell.isEmpty('menu')).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "LabShell",
                "#add(widget, \"menu\")"
            ],
            "updatePoint": {
                "line": 168,
                "column": 29
            },
            "line": 168,
            "code": "    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'menu', { rank: 10 });\n      expect(shell.isEmpty('menu')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the top area",
            "suites": [
                "LabShell",
                "#add(widget, \"top\")"
            ],
            "updatePoint": {
                "line": 177,
                "column": 43
            },
            "line": 177,
            "code": "    it('should add a widget to the top area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'top');\n      // top-level title and menu area are added by default\n      expect(Array.from(shell.widgets('top')).length).toEqual(3);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"top\")"
            ],
            "updatePoint": {
                "line": 185,
                "column": 49
            },
            "line": 185,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'top');\n      // top-level title and menu area are added by default\n      expect(Array.from(shell.widgets('top')).length).toEqual(2);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "LabShell",
                "#add(widget, \"top\")"
            ],
            "updatePoint": {
                "line": 192,
                "column": 29
            },
            "line": 192,
            "code": "    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'top', { rank: 10 });\n      // top-level title and menu area are added by default\n      expect(Array.from(shell.widgets('top')).length).toEqual(3);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add widgets according to their ranks",
            "suites": [
                "LabShell",
                "#add(widget, \"top\")"
            ],
            "updatePoint": {
                "line": 200,
                "column": 51
            },
            "line": 200,
            "code": "    it('should add widgets according to their ranks', () => {\n      const foo = new Widget();\n      const bar = new Widget();\n      foo.id = 'foo';\n      bar.id = 'bar';\n      shell.add(foo, 'top', { rank: 10001 });\n      shell.add(bar, 'top', { rank: 10000 });\n      expect(\n        Array.from(shell.widgets('top'))\n          .slice(-2)\n          .map(v => v.id)\n      ).toEqual(['bar', 'foo']);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the left area",
            "suites": [
                "LabShell",
                "#add(widget, \"left\")"
            ],
            "updatePoint": {
                "line": 216,
                "column": 44
            },
            "line": 216,
            "code": "    it('should add a widget to the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"left\")"
            ],
            "updatePoint": {
                "line": 223,
                "column": 49
            },
            "line": 223,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'left');\n      expect(shell.isEmpty('left')).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "LabShell",
                "#add(widget, \"left\")"
            ],
            "updatePoint": {
                "line": 229,
                "column": 29
            },
            "line": 229,
            "code": "    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left', { rank: 10 });\n      expect(shell.isEmpty('left')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the right area",
            "suites": [
                "LabShell",
                "#add(widget, \"right\")"
            ],
            "updatePoint": {
                "line": 238,
                "column": 45
            },
            "line": 238,
            "code": "    it('should add a widget to the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"right\")"
            ],
            "updatePoint": {
                "line": 245,
                "column": 49
            },
            "line": 245,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'right');\n      expect(shell.isEmpty('right')).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "LabShell",
                "#add(widget, \"right\")"
            ],
            "updatePoint": {
                "line": 251,
                "column": 29
            },
            "line": 251,
            "code": "    it('should accept options', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right', { rank: 10 });\n      expect(shell.isEmpty('right')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should add a widget to the main area",
            "suites": [
                "LabShell",
                "#add(widget, \"main\")"
            ],
            "updatePoint": {
                "line": 260,
                "column": 44
            },
            "line": 260,
            "code": "    it('should add a widget to the main area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget has no id",
            "suites": [
                "LabShell",
                "#add(widget, \"main\")"
            ],
            "updatePoint": {
                "line": 267,
                "column": 49
            },
            "line": 267,
            "code": "    it('should be a no-op if the widget has no id', () => {\n      const widget = new Widget();\n      shell.add(widget, 'main');\n      expect(shell.isEmpty('main')).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should activate a widget in the left area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 275,
                "column": 49
            },
            "line": 275,
            "code": "    it('should activate a widget in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget is not in the left area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 284,
                "column": 63
            },
            "line": 284,
            "code": "    it('should be a no-op if the widget is not in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should activate a widget in the right area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 292,
                "column": 50
            },
            "line": 292,
            "code": "    it('should activate a widget in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget is not in the right area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 301,
                "column": 64
            },
            "line": 301,
            "code": "    it('should be a no-op if the widget is not in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      expect(widget.isVisible).toBe(false);\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should activate a widget in the main area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 309,
                "column": 49
            },
            "line": 309,
            "code": "    it('should activate a widget in the main area', async () => {\n      const widget = new ContentWidget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      shell.activateById('foo');\n      await framePromise();\n      expect(widget.activated).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be a no-op if the widget is not in the main area",
            "suites": [
                "LabShell",
                "#activateById()"
            ],
            "updatePoint": {
                "line": 318,
                "column": 63
            },
            "line": 318,
            "code": "    it('should be a no-op if the widget is not in the main area', async () => {\n      const widget = new ContentWidget();\n      widget.id = 'foo';\n      shell.activateById('foo');\n      await framePromise();\n      expect(widget.activated).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should collapse all widgets in the left area",
            "suites": [
                "LabShell",
                "#collapseLeft()"
            ],
            "updatePoint": {
                "line": 328,
                "column": 52
            },
            "line": 328,
            "code": "    it('should collapse all widgets in the left area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'left');\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n      shell.collapseLeft();\n      expect(widget.isVisible).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should collapse all widgets in the right area",
            "suites": [
                "LabShell",
                "#collapseRight()"
            ],
            "updatePoint": {
                "line": 340,
                "column": 53
            },
            "line": 340,
            "code": "    it('should collapse all widgets in the right area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right');\n      shell.activateById('foo');\n      expect(widget.isVisible).toBe(true);\n      shell.collapseRight();\n      expect(widget.isVisible).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should expand the most recently used widget",
            "suites": [
                "LabShell",
                "#expandLeft()"
            ],
            "updatePoint": {
                "line": 352,
                "column": 51
            },
            "line": 352,
            "code": "    it('should expand the most recently used widget', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'left', { rank: 10 });\n      shell.add(widget2, 'left', { rank: 1 });\n      shell.activateById('foo');\n      shell.collapseLeft();\n      expect(widget.isVisible).toBe(false);\n      shell.expandLeft();\n      expect(widget.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should expand the first widget if none have been activated",
            "suites": [
                "LabShell",
                "#expandLeft()"
            ],
            "updatePoint": {
                "line": 366,
                "column": 66
            },
            "line": 366,
            "code": "    it('should expand the first widget if none have been activated', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'left', { rank: 10 });\n      shell.add(widget2, 'left', { rank: 1 });\n      expect(widget2.isVisible).toBe(false);\n      shell.expandLeft();\n      expect(widget2.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should expand the most recently used widget",
            "suites": [
                "LabShell",
                "#expandRight()"
            ],
            "updatePoint": {
                "line": 380,
                "column": 51
            },
            "line": 380,
            "code": "    it('should expand the most recently used widget', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.add(widget2, 'right', { rank: 1 });\n      shell.activateById('foo');\n      shell.collapseRight();\n      expect(widget.isVisible).toBe(false);\n      shell.expandRight();\n      expect(widget.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should expand the first widget if none have been activated",
            "suites": [
                "LabShell",
                "#expandRight()"
            ],
            "updatePoint": {
                "line": 394,
                "column": 66
            },
            "line": 394,
            "code": "    it('should expand the first widget if none have been activated', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      const widget2 = new Widget();\n      widget2.id = 'bar';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.add(widget2, 'right', { rank: 1 });\n      expect(widget2.isVisible).toBe(false);\n      shell.expandRight();\n      expect(widget2.isVisible).toBe(true);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should close all of the widgets in the main area",
            "suites": [
                "LabShell",
                "#closeAll()"
            ],
            "updatePoint": {
                "line": 408,
                "column": 56
            },
            "line": 408,
            "code": "    it('should close all of the widgets in the main area', () => {\n      const foo = new Widget();\n      foo.id = 'foo';\n      shell.add(foo, 'main');\n      const bar = new Widget();\n      bar.id = 'bar';\n      shell.add(bar, 'main');\n      shell.closeAll();\n      expect(foo.parent).toBe(null);\n      expect(bar.parent).toBe(null);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should save the layout of the shell",
            "suites": [
                "LabShell",
                "#saveLayout"
            ],
            "updatePoint": {
                "line": 422,
                "column": 43
            },
            "line": 422,
            "code": "    it('should save the layout of the shell', () => {\n      const foo = new Widget();\n      foo.id = 'foo';\n      shell.add(foo, 'main');\n      const state = shell.saveLayout();\n      shell.activateById('foo');\n      expect(shell.mode).toBe('multiple-document');\n      expect(state.mainArea?.currentWidget).toBe(null);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should restore the layout of the shell",
            "suites": [
                "LabShell",
                "#restoreLayout"
            ],
            "updatePoint": {
                "line": 434,
                "column": 46
            },
            "line": 434,
            "code": "    it('should restore the layout of the shell', async () => {\n      const restorer = new LayoutRestorer({\n        connector: new StateDB(),\n        first: Promise.resolve<void>(void 0),\n        registry: new CommandRegistry()\n      });\n      const mode: DockPanel.Mode = 'multiple-document';\n      shell.mode = 'single-document';\n      await shell.restoreLayout(mode, restorer);\n      expect(shell.mode).toBe('multiple-document');\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should list widgets in each area",
            "suites": [
                "LabShell",
                "#widgets"
            ],
            "updatePoint": {
                "line": 448,
                "column": 40
            },
            "line": 448,
            "code": "    it('should list widgets in each area', () => {\n      let widget: Widget;\n\n      widget = new Widget();\n      widget.id = 'header';\n      shell.add(widget, 'header');\n\n      widget = new Widget();\n      widget.id = 'top';\n      shell.add(widget, 'top');\n\n      widget = new Widget();\n      widget.id = 'menu';\n      shell.add(widget, 'menu');\n\n      widget = new Widget();\n      widget.id = 'left';\n      shell.add(widget, 'left');\n\n      widget = new Widget();\n      widget.id = 'right';\n      shell.add(widget, 'right');\n\n      widget = new Widget();\n      widget.id = 'main';\n      shell.add(widget, 'main');\n\n      expect(Array.from(shell.widgets('header')).map(v => v.id)).toEqual([\n        'header'\n      ]);\n      expect(\n        Array.from(shell.widgets('top'))\n          .slice(-1)\n          .map(v => v.id)\n      ).toEqual(['top']);\n      expect(Array.from(shell.widgets('menu')).map(v => v.id)).toEqual([\n        'menu'\n      ]);\n      expect(Array.from(shell.widgets('left')).map(v => v.id)).toEqual([\n        'left'\n      ]);\n      expect(Array.from(shell.widgets('right')).map(v => v.id)).toEqual([\n        'right'\n      ]);\n      expect(Array.from(shell.widgets('main')).map(v => v.id)).toEqual([\n        'main'\n      ]);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should default to main area",
            "suites": [
                "LabShell",
                "#widgets"
            ],
            "updatePoint": {
                "line": 497,
                "column": 35
            },
            "line": 497,
            "code": "    it('should default to main area', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'main');\n      expect(Array.from(shell.widgets()).map(v => v.id)).toEqual(['foo']);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should throw an error when an unrecognized area is given",
            "suites": [
                "LabShell",
                "#widgets"
            ],
            "updatePoint": {
                "line": 504,
                "column": 64
            },
            "line": 504,
            "code": "    it('should throw an error when an unrecognized area is given', () => {\n      expect(() => shell.widgets('foo' as any)).toThrow(/Invalid area/);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should be hidden in multiple document mode and visible in single document mode",
            "suites": [
                "LabShell",
                "#titlePanel"
            ],
            "updatePoint": {
                "line": 510,
                "column": 86
            },
            "line": 510,
            "code": "    it('should be hidden in multiple document mode and visible in single document mode', () => {\n      const widget = new Widget();\n      widget.id = 'foo';\n      shell.add(widget, 'right', { rank: 10 });\n      shell.mode = 'multiple-document';\n      expect(widget.isVisible).toBe(false);\n      shell.mode = 'single-document';\n      expect(widget.isVisible).toBe(false);\n    });",
            "file": "shell.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "%j & default %s has isEnabled %s",
            "suites": [
                "@jupyterlab/application",
                "createSemanticCommand"
            ],
            "line": 37,
            "code": "    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, false],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, false],\n      [[], true, true]\n    ])('%j & default %s has isEnabled %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isEnabled: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isEnabled: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isEnabled?.call({})).toEqual(expected);\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "%j & default %s has isToggled %s",
            "suites": [
                "@jupyterlab/application",
                "createSemanticCommand"
            ],
            "line": 73,
            "code": "    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, false],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, false],\n      [[], true, true]\n    ])('%j & default %s has isToggled %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isToggled: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isToggled: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isToggled?.call({})).toEqual(expected);\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "%j & default %s has isVisible %s",
            "suites": [
                "@jupyterlab/application",
                "createSemanticCommand"
            ],
            "line": 109,
            "code": "    it.each([\n      [[true, false], false, true],\n      [[true, false], true, true],\n      [[true, false], undefined, true],\n      [[false, false], false, false],\n      [[false, false], undefined, true],\n      [[false, false], true, true],\n      [[true, true], false, true],\n      [[true, true], true, true],\n      [[true, true], undefined, true],\n      [[], false, false],\n      [[], undefined, true],\n      [[], true, true]\n    ])('%j & default %s has isVisible %s', (values, defaultValue, expected) => {\n      for (let i = 0; i < values.length; i++) {\n        const id = `command-${i}`;\n        commands.addCommand(id, {\n          execute: () => null,\n          isVisible: () => values[i]\n        });\n\n        semanticCmd.add({ id });\n      }\n\n      const contextualCommand = createSemanticCommand(\n        app,\n        semanticCmd,\n        {\n          isVisible: defaultValue\n        },\n        translator.load('jupyterlab')\n      );\n\n      expect(contextualCommand.isVisible?.call({})).toEqual(expected);\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "labels/captions %j, and default %s has label/caption %s",
            "suites": [
                "@jupyterlab/application",
                "createSemanticCommand"
            ],
            "line": 146,
            "code": "    it.each([\n      [[], undefined, ''],\n      [[], 'default', 'default'],\n      [[''], 'default', ''],\n      [['label a'], 'default', 'label a'],\n      [['label a', 'label b'], 'default', 'label a and label b'],\n      [['label a', 'label b…'], 'default', 'label a and label b…'],\n      [['label a…', 'label b'], 'default', 'label a and label b…'],\n      [['label a…', 'label b…'], 'default', 'label a and label b…'],\n      [\n        ['label a', 'label b', 'label c'],\n        'default',\n        'label a, label b and label c'\n      ],\n      [\n        ['label a…', 'label b…', 'label c'],\n        'default',\n        'label a, label b and label c…'\n      ],\n      [\n        ['label a…', 'label b', 'label c…'],\n        'default',\n        'label a, label b and label c…'\n      ],\n      [\n        ['label a…', 'label b…', 'label c…'],\n        'default',\n        'label a, label b and label c…'\n      ],\n      [\n        ['label a', 'label b…', 'label c'],\n        'default',\n        'label a, label b and label c…'\n      ],\n      [\n        ['label a', 'label b…', 'label c…'],\n        'default',\n        'label a, label b and label c…'\n      ],\n      [\n        ['label a', 'label b', 'label c…'],\n        'default',\n        'label a, label b and label c…'\n      ]\n    ])(\n      'labels/captions %j, and default %s has label/caption %s',\n      (values, defaultValue, expected) => {\n        let myCommands: SemanticCommand[] = [];\n\n        for (let i = 0; i < values.length; i++) {\n          semanticCmd = new SemanticCommand();\n          const id = `command-${i}`;\n          const label = values[i];\n          const caption = label.replace('label', 'caption');\n          commands.addCommand(id, {\n            execute: () => null,\n            label: label,\n            caption: caption\n          });\n\n          semanticCmd.add({ id });\n          myCommands.push(semanticCmd);\n        }\n\n        const semanticCommandId = 'my-semantic-command';\n        commands.addCommand(\n          semanticCommandId,\n          createSemanticCommand(\n            app,\n            myCommands,\n            {\n              label: defaultValue,\n              caption: defaultValue?.replace('label', 'caption')\n            },\n            translator.load('jupyterlab')\n          )\n        );\n\n        expect(commands.label(semanticCommandId)).toEqual(expected);\n        expect(commands.caption(semanticCommandId)).toEqual(\n          expected.replace(/label/g, 'caption')\n        );\n      }\n    );",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/application/test"
        },
        {
            "name": "should create a command linker",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 12,
                "column": 40
            },
            "line": 12,
            "code": "      it('should create a command linker', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker).toBeInstanceOf(CommandLinker);\n        linker.dispose();\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should test whether a command linker has been disposed",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 20,
                "column": 64
            },
            "line": 20,
            "code": "      it('should test whether a command linker has been disposed', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker.isDisposed).toBe(false);\n        linker.dispose();\n        expect(linker.isDisposed).toBe(true);\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should connect a node to a command",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#connectNode()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 44
            },
            "line": 29,
            "code": "      it('should connect a node to a command', () => {\n        let called = false;\n        const command = 'commandlinker:connect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        const node = document.createElement('div');\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        document.body.appendChild(node);\n        linker.connectNode(node, command, undefined);\n\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should disconnect a node from a command",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#disconnectNode()"
            ],
            "updatePoint": {
                "line": 55,
                "column": 49
            },
            "line": 55,
            "code": "      it('should disconnect a node from a command', () => {\n        let called = false;\n        const command = 'commandlinker:disconnect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        const node = document.createElement('div');\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        document.body.appendChild(node);\n        linker.connectNode(node, command, undefined);\n\n        // Make sure connection is working.\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        // Reset flag.\n        called = false;\n\n        // Make sure disconnection is working.\n        linker.disconnectNode(node);\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(false);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dispose the resources held by the linker",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 57
            },
            "line": 91,
            "code": "      it('should dispose the resources held by the linker', () => {\n        const linker = new CommandLinker({ commands: new CommandRegistry() });\n        expect(linker.isDisposed).toBe(false);\n        linker.dispose();\n        expect(linker.isDisposed).toBe(true);\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should connect a node to a command",
            "suites": [
                "@jupyterlab/apputils",
                "CommandLinker",
                "#populateVNodeDataset()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 44
            },
            "line": 100,
            "code": "      it('should connect a node to a command', () => {\n        let called = false;\n        const command = 'commandlinker:connect-node';\n        const commands = new CommandRegistry();\n        const linker = new CommandLinker({ commands });\n        let node: HTMLElement;\n        let vnode: VirtualNode;\n        const disposable = commands.addCommand(command, {\n          execute: () => {\n            called = true;\n          }\n        });\n\n        vnode = h.div({\n          dataset: linker.populateVNodeDataset(command, undefined)\n        });\n        node = VirtualDOM.realize(vnode);\n        document.body.appendChild(node);\n\n        expect(called).toBe(false);\n        simulate(node, 'click');\n        expect(called).toBe(true);\n\n        document.body.removeChild(node);\n        linker.dispose();\n        disposable.dispose();\n      });",
            "file": "commandlinker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create a new command palette",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 36,
                "column": 45
            },
            "line": 36,
            "code": "      it('should create a new command palette', () => {\n        expect(palette).toBeInstanceOf(CommandPalette);\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create a new modal command palette",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 51
            },
            "line": 39,
            "code": "      it('should create a new modal command palette', () => {\n        expect(modalPalette).toBeInstanceOf(ModalCommandPalette);\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should attach to the document body",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 44
            },
            "line": 42,
            "code": "      it('should attach to the document body', () => {\n        expect(document.body.contains(modalPalette.node)).toBe(true);\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should start hidden",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 29
            },
            "line": 45,
            "code": "      it('should start hidden', () => {\n        expect(modalPalette.isHidden).toBe(true);\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should become visible when activated",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#activate()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 46
            },
            "line": 51,
            "code": "      it('should become visible when activated', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        expect(modalPalette.isVisible).toBe(true);\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should become hidden and clear the input when calling hideAndReset",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#hideAndReset()"
            ],
            "updatePoint": {
                "line": 58,
                "column": 76
            },
            "line": 58,
            "code": "      it('should become hidden and clear the input when calling hideAndReset', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search string…';\n        modalPalette.hideAndReset();\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should hide and reset when focus is shifted",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#blur()"
            ],
            "updatePoint": {
                "line": 68,
                "column": 53
            },
            "line": 68,
            "code": "      it('should hide and reset when focus is shifted', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search string…';\n        simulate(modalPalette.node, 'blur', {\n          relatedTarget: document.body\n        });\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should hide and reset when ESC is pressed",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#escape()"
            ],
            "updatePoint": {
                "line": 80,
                "column": 51
            },
            "line": 80,
            "code": "      it('should hide and reset when ESC is pressed', () => {\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        palette.inputNode.value = 'Search string…';\n        simulate(modalPalette.node, 'keydown', { keyCode: 27 });\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should hide and reset when a command is executed",
            "suites": [
                "@jupyterlab/apputils",
                "ModalCommandPalette",
                "#execute()"
            ],
            "updatePoint": {
                "line": 90,
                "column": 58
            },
            "line": 90,
            "code": "      it('should hide and reset when a command is executed', () => {\n        commands.addCommand('mock-command', {\n          execute: (args: JSONObject) => {\n            return args;\n          }\n        });\n        MessageLoop.sendMessage(modalPalette, Widget.Msg.ActivateRequest);\n        void commands.execute('mock-command');\n        expect(modalPalette.isVisible).toBe(false);\n        expect(palette.inputNode.value).toEqual('');\n      });",
            "file": "commandpalette.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept at least the title argument",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getBoolean()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 51
            },
            "line": 14,
            "code": "      it('should accept at least the title argument', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be false by default",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getBoolean()"
            ],
            "updatePoint": {
                "line": 23,
                "column": 36
            },
            "line": 23,
            "code": "      it('should be false by default', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getBoolean()"
            ],
            "updatePoint": {
                "line": 36,
                "column": 31
            },
            "line": 36,
            "code": "      it('should accept options', async () => {\n        const dialog = InputDialog.getBoolean({\n          title: 'Check or not',\n          value: true\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(true);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be editable",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getBoolean()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 28
            },
            "line": 50,
            "code": "      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getBoolean({\n          title: 'Check or not',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.checked = true;\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(true);\n        document.body.removeChild(node);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept at least two arguments",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getItem()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 46
            },
            "line": 76,
            "code": "      it('should accept at least two arguments', async () => {\n        const dialog = InputDialog.getItem({\n          title: 'list',\n          items: ['item1']\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the first item by default",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getItem()"
            ],
            "updatePoint": {
                "line": 86,
                "column": 45
            },
            "line": 86,
            "code": "      it('should be the first item by default', async () => {\n        const dialog = InputDialog.getItem({\n          items: ['item1', 'item2'],\n          title: 'Pick a choice'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item1');\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getItem()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 31
            },
            "line": 100,
            "code": "      it('should accept options', async () => {\n        const dialog = InputDialog.getItem({\n          label: 'list',\n          items: ['item1', 'item2'],\n          current: 1,\n          editable: false,\n          title: 'Pick a choice',\n          placeholder: 'item'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item2');\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be editable",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getItem()"
            ],
            "updatePoint": {
                "line": 118,
                "column": 28
            },
            "line": 118,
            "code": "      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getItem({\n          label: 'list',\n          items: ['item1', 'item2'],\n          title: 'Pick a choice',\n          placeholder: 'item',\n          editable: true,\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = 'item3';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('item3');\n        document.body.removeChild(node);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept at least two arguments",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getMultipleItems()"
            ],
            "updatePoint": {
                "line": 148,
                "column": 46
            },
            "line": 148,
            "code": "      it('should accept at least two arguments', async () => {\n        const dialog = InputDialog.getMultipleItems({\n          title: 'list',\n          items: ['item1']\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return empty list if none is selected",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getMultipleItems()"
            ],
            "updatePoint": {
                "line": 158,
                "column": 54
            },
            "line": 158,
            "code": "      it('should return empty list if none is selected', async () => {\n        const dialog = InputDialog.getMultipleItems({\n          items: ['item1', 'item2'],\n          title: 'Pick a choice'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toStrictEqual([]);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept option \"defaults\"",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getMultipleItems()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 41
            },
            "line": 172,
            "code": "      it('should accept option \"defaults\"', async () => {\n        const dialog = InputDialog.getMultipleItems({\n          label: 'list',\n          items: ['item1', 'item2', 'item3'],\n          defaults: ['item1', 'item3'],\n          title: 'Pick a choice'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toStrictEqual(['item1', 'item3']);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept at least one argument",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getText()"
            ],
            "updatePoint": {
                "line": 190,
                "column": 45
            },
            "line": 190,
            "code": "      it('should accept at least one argument', async () => {\n        const dialog = InputDialog.getText({\n          title: 'text'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be an empty string by default",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getText()"
            ],
            "updatePoint": {
                "line": 199,
                "column": 46
            },
            "line": 199,
            "code": "      it('should be an empty string by default', async () => {\n        const dialog = InputDialog.getText({\n          title: 'Give a text'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('');\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getText()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 31
            },
            "line": 212,
            "code": "      it('should accept options', async () => {\n        const dialog = InputDialog.getText({\n          label: 'text',\n          title: 'Give a text',\n          placeholder: 'your text',\n          text: 'answer'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('answer');\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be editable",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getText()"
            ],
            "updatePoint": {
                "line": 228,
                "column": 28
            },
            "line": 228,
            "code": "      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getText({\n          title: 'text',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = 'my answer';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe('my answer');\n        document.body.removeChild(node);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept at least one argument",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getNumber()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 45
            },
            "line": 254,
            "code": "      it('should accept at least one argument', async () => {\n        const dialog = InputDialog.getNumber({\n          title: 'number'\n        });\n\n        await dismissDialog();\n        expect((await dialog).button.accept).toBe(false);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be 0 by default",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getNumber()"
            ],
            "updatePoint": {
                "line": 263,
                "column": 32
            },
            "line": 263,
            "code": "      it('should be 0 by default', async () => {\n        const dialog = InputDialog.getNumber({\n          title: 'Pick a number'\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(0);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getNumber()"
            ],
            "updatePoint": {
                "line": 276,
                "column": 31
            },
            "line": 276,
            "code": "      it('should accept options', async () => {\n        const dialog = InputDialog.getNumber({\n          label: 'number',\n          title: 'Pick a number',\n          value: 10\n        });\n\n        await acceptDialog();\n\n        const result = await dialog;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(10);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be editable",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getNumber()"
            ],
            "updatePoint": {
                "line": 291,
                "column": 28
            },
            "line": 291,
            "code": "      it('should be editable', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getNumber({\n          label: 'text',\n          title: 'Pick a number',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = '25';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBe(25);\n        document.body.removeChild(node);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return NaN if empty",
            "suites": [
                "@jupyterlab/apputils",
                "InputDialog",
                "getNumber()"
            ],
            "updatePoint": {
                "line": 316,
                "column": 36
            },
            "line": 316,
            "code": "      it('should return NaN if empty', async () => {\n        const node = document.createElement('div');\n\n        document.body.appendChild(node);\n\n        const prompt = InputDialog.getNumber({\n          label: 'text',\n          title: 'Pick a number',\n          host: node\n        });\n\n        await waitForDialog(node);\n        const body = node.getElementsByClassName('jp-Input-Dialog').item(0)!;\n        const input = body.getElementsByTagName('input').item(0)!;\n        input.value = '';\n\n        await acceptDialog();\n\n        const result = await prompt;\n\n        expect(result.button.accept).toBe(true);\n        expect(result.value).toBeNaN();\n        document.body.removeChild(node);\n      });",
            "file": "inputdialog.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create a new main area widget",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 11,
                "column": 46
            },
            "line": 11,
            "code": "      it('should create a new main area widget', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        expect(widget).toBeInstanceOf(MainAreaWidget);\n        expect(widget.hasClass('jp-MainAreaWidget')).toBe(true);\n        expect(widget.title.closable).toBe(true);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow toolbar options",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 19,
                "column": 38
            },
            "line": 19,
            "code": "      it('should allow toolbar options', () => {\n        const content = new Widget();\n        const toolbar = new Toolbar();\n        const widget = new MainAreaWidget({ content, toolbar });\n        expect(widget.hasClass('jp-MainAreaWidget')).toBe(true);\n        expect(widget.toolbar).toBe(toolbar);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should exist and have correct type",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "contentHeader"
            ],
            "updatePoint": {
                "line": 29,
                "column": 44
            },
            "line": 29,
            "code": "      it('should exist and have correct type', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        expect(widget.contentHeader).toBeInstanceOf(BoxPanel);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should focus on activation",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 36
            },
            "line": 37,
            "code": "      it('should focus on activation', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(document.activeElement).toBe(widget.content.node);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dispose on close",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "#onCloseRequest()"
            ],
            "updatePoint": {
                "line": 47,
                "column": 33
            },
            "line": 47,
            "code": "      it('should dispose on close', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.CloseRequest);\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should propagate to the content",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 41
            },
            "line": 57,
            "code": "      it('should propagate to the content', () => {\n        let updated: boolean;\n        const content = new (class extends Widget {\n          onUpdateRequest() {\n            updated = true;\n          }\n        })();\n        const widget = new MainAreaWidget({ content });\n        Widget.attach(widget, document.body);\n        updated = false;\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(updated).toBe(true);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should proxy from content to main",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "title"
            ],
            "updatePoint": {
                "line": 73,
                "column": 43
            },
            "line": 73,
            "code": "      it('should proxy from content to main', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        content.title.label = 'foo';\n        expect(widget.title.label).toBe('foo');\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should proxy from main to content",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "title"
            ],
            "updatePoint": {
                "line": 80,
                "column": 43
            },
            "line": 80,
            "code": "      it('should proxy from main to content', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        widget.title.label = 'foo';\n        expect(content.title.label).toBe('foo');\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dispose of main",
            "suites": [
                "@jupyterlab/apputils",
                "MainAreaWidget",
                "dispose"
            ],
            "updatePoint": {
                "line": 89,
                "column": 32
            },
            "line": 89,
            "code": "      it('should dispose of main', () => {\n        const content = new Widget();\n        const widget = new MainAreaWidget({ content });\n        content.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "mainareawidget.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dismiss an given notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#dismiss"
            ],
            "updatePoint": {
                "line": 14,
                "column": 46
            },
            "line": 14,
            "code": "      it('should dismiss an given notification', () => {\n        const id1 = Notification.info('dummy 1');\n        const id2 = Notification.info('dummy 2');\n\n        Notification.dismiss(id1);\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id2);\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dismiss all notifications",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#dismiss"
            ],
            "updatePoint": {
                "line": 24,
                "column": 42
            },
            "line": 24,
            "code": "      it('should dismiss all notifications', () => {\n        Notification.info('dummy 1');\n        Notification.info('dummy 2');\n\n        Notification.dismiss();\n\n        expect(Notification.manager.count).toEqual(0);\n        expect(Notification.manager.notifications).toHaveLength(0);\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a notification of the type %s",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#emit"
            ],
            "line": 36,
            "code": "      it.each([\n        'default',\n        'error',\n        'info',\n        'in-progress',\n        'success',\n        'warning'\n      ])('should emit a notification of the type %s', type => {\n        const id = Notification.emit('dummy message', type as any);\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'dummy message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual(type);\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a default notification by default",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#emit"
            ],
            "updatePoint": {
                "line": 54,
                "column": 55
            },
            "line": 54,
            "code": "      it('should emit a default notification by default', () => {\n        Notification.emit('dummy 1');\n\n        expect(Notification.manager.notifications[0].type).toEqual('default');\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a notification with the provided options",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#emit"
            ],
            "updatePoint": {
                "line": 60,
                "column": 62
            },
            "line": 60,
            "code": "      it('should emit a notification with the provided options', () => {\n        const options: Notification.IOptions<ReadonlyJSONValue> = {\n          actions: [\n            {\n              label: 'my action',\n              callback: () => {\n                console.log('my action was triggered');\n              },\n              caption: 'my action description'\n            }\n          ],\n          autoClose: 2000,\n          data: {\n            a: 1,\n            b: 'data'\n          },\n          progress: 0.2\n        };\n        Notification.emit('dummy 1', 'default', options);\n\n        expect(Notification.manager.notifications[0].options).toEqual(options);\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should bound the progress %s",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#emit"
            ],
            "line": 84,
            "code": "    it.each([\n      [-1, 0],\n      [0, 0],\n      [0.2, 0.2],\n      [1, 1],\n      [2, 1]\n    ])('should bound the progress %s', (progress, expected) => {\n      Notification.emit('dummy message', 'in-progress', { progress });\n\n      expect(Notification.manager.notifications[0].options.progress).toEqual(\n        expected\n      );\n    });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit an error notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#error"
            ],
            "updatePoint": {
                "line": 99,
                "column": 43
            },
            "line": 99,
            "code": "      it('should emit an error notification', () => {\n        const id = Notification.error('dummy message');\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'dummy message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual('error');\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit an info notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#info"
            ],
            "updatePoint": {
                "line": 112,
                "column": 42
            },
            "line": 112,
            "code": "      it('should emit an info notification', () => {\n        const id = Notification.info('dummy message');\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'dummy message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual('info');\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a notification that turn into success when resolved",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#promise"
            ],
            "updatePoint": {
                "line": 125,
                "column": 73
            },
            "line": 125,
            "code": "      it('should emit a notification that turn into success when resolved', async () => {\n        const promise = new PromiseDelegate<string>();\n        Notification.promise(promise.promise, {\n          error: {\n            message: reason => `Promise got rejected: ${reason}`\n          },\n          pending: { message: 'Waiting for promise resolution' },\n          success: {\n            message: result => `Promise was resolved: ${result}`\n          }\n        });\n\n        expect(Notification.manager.notifications[0].type).toEqual(\n          'in-progress'\n        );\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'Waiting for promise resolution'\n        );\n\n        promise.resolve('Done');\n\n        const done = new PromiseDelegate<void>();\n        // Wait for promise to allow notification update to occurs\n        setTimeout(() => {\n          expect(Notification.manager.notifications[0].type).toEqual('success');\n          expect(Notification.manager.notifications[0].message).toEqual(\n            'Promise was resolved: Done'\n          );\n          done.resolve();\n        }, 0);\n\n        await done.promise;\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a notification that turn into error when rejected",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#promise"
            ],
            "updatePoint": {
                "line": 159,
                "column": 71
            },
            "line": 159,
            "code": "      it('should emit a notification that turn into error when rejected', async () => {\n        const promise = new PromiseDelegate<string>();\n        Notification.promise(promise.promise, {\n          error: {\n            message: reason => `Promise got rejected: ${reason}`\n          },\n          pending: { message: 'Waiting for promise resolution' },\n          success: {\n            message: result => `Promise was resolved ${result}`\n          }\n        });\n\n        expect(Notification.manager.notifications[0].type).toEqual(\n          'in-progress'\n        );\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'Waiting for promise resolution'\n        );\n\n        promise.reject('Failed');\n\n        const done = new PromiseDelegate<void>();\n        // Wait for promise to allow notification update to occurs\n        setTimeout(() => {\n          expect(Notification.manager.notifications[0].type).toEqual('error');\n          expect(Notification.manager.notifications[0].message).toEqual(\n            'Promise got rejected: Failed'\n          );\n          done.resolve();\n        }, 0);\n\n        await done.promise;\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a success notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#success"
            ],
            "updatePoint": {
                "line": 195,
                "column": 44
            },
            "line": 195,
            "code": "      it('should emit a success notification', () => {\n        const id = Notification.success('dummy message');\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'dummy message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual('success');\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should update a notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#update"
            ],
            "updatePoint": {
                "line": 208,
                "column": 38
            },
            "line": 208,
            "code": "      it('should update a notification', () => {\n        const id = Notification.emit('dummy message');\n\n        const options: Notification.IOptions<ReadonlyJSONValue> = {\n          actions: [\n            {\n              label: 'my action',\n              callback: () => {\n                console.log('my action was triggered');\n              },\n              caption: 'my action description'\n            }\n          ],\n          autoClose: 2000,\n          data: {\n            a: 1,\n            b: 'data'\n          }\n        };\n        Notification.update({\n          id,\n          message: 'Updated message',\n          type: 'success',\n          ...options\n        });\n\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'Updated message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual('success');\n        expect(Notification.manager.notifications[0].options).toEqual(options);\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should update only the progress",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#update"
            ],
            "updatePoint": {
                "line": 242,
                "column": 41
            },
            "line": 242,
            "code": "      it('should update only the progress', () => {\n        const id = Notification.emit('dummy message', 'in-progress', {\n          progress: 0\n        });\n\n        Notification.update({\n          id,\n          progress: 0.5\n        });\n        expect(Notification.manager.notifications[0].options.progress).toEqual(\n          0.5\n        );\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit a warning notification",
            "suites": [
                "@jupyterlab/apputils",
                "Notification",
                "#warning"
            ],
            "updatePoint": {
                "line": 258,
                "column": 44
            },
            "line": 258,
            "code": "      it('should emit a warning notification', () => {\n        const id = Notification.warning('dummy message');\n\n        expect(Notification.manager.count).toEqual(1);\n        expect(Notification.manager.notifications[0].id).toEqual(id);\n        expect(Notification.manager.notifications[0].message).toEqual(\n          'dummy message'\n        );\n        expect(Notification.manager.notifications[0].type).toEqual('warning');\n      });",
            "file": "notification.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow h1 tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 28
            },
            "line": 9,
            "code": "    it('should allow h1 tags', () => {\n      const h1 = '<h1>foo</h1>';\n      expect(sanitizer.sanitize(h1)).toBe(h1);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow h2 tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 28
            },
            "line": 14,
            "code": "    it('should allow h2 tags', () => {\n      const h2 = '<h2>foo</h2>';\n      expect(sanitizer.sanitize(h2)).toBe(h2);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should not allow svg tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 19,
                "column": 33
            },
            "line": 19,
            "code": "    it('should not allow svg tags', () => {\n      const svg = '<svg>foo</svg>';\n      expect(sanitizer.sanitize(svg)).toBe('foo');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow img tags and some attributes",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 49
            },
            "line": 24,
            "code": "    it('should allow img tags and some attributes', () => {\n      const img =\n        '<img src=\"smiley.gif\" alt=\"Smiley face\" height=\"42\" width=\"42\" />';\n      expect(sanitizer.sanitize(img)).toBe(img);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow span tags and class attribute",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 30,
                "column": 50
            },
            "line": 30,
            "code": "    it('should allow span tags and class attribute', () => {\n      const span = '<span class=\"foo\">bar</span>';\n      expect(sanitizer.sanitize(span)).toBe(span);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should set the rel attribute for <a> tags to \"nofollow",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 35,
                "column": 62
            },
            "line": 35,
            "code": "    it('should set the rel attribute for <a> tags to \"nofollow', () => {\n      const a = '<a rel=\"foo\" href=\"bar\">Baz</a>';\n      const expected = a.replace('foo', 'nofollow');\n      expect(sanitizer.sanitize(a)).toBe(expected);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow the `data-commandlinker-command` attribute for button tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 79
            },
            "line": 41,
            "code": "    it('should allow the `data-commandlinker-command` attribute for button tags', () => {\n      const button =\n        '<button data-commandlinker-command=\"terminal:create-new\" onClick={some evil code}>Create Terminal</button>';\n      const expectedButton =\n        '<button data-commandlinker-command=\"terminal:create-new\">Create Terminal</button>';\n      expect(sanitizer.sanitize(button)).toBe(expectedButton);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow the class attribute for code tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 54
            },
            "line": 49,
            "code": "    it('should allow the class attribute for code tags', () => {\n      const code = '<code class=\"foo\">bar</code>';\n      expect(sanitizer.sanitize(code)).toBe(code);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow the class attribute for div tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 54,
                "column": 53
            },
            "line": 54,
            "code": "    it('should allow the class attribute for div tags', () => {\n      const div = '<div class=\"foo\">bar</div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow the class attribute for p tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 59,
                "column": 51
            },
            "line": 59,
            "code": "    it('should allow the class attribute for p tags', () => {\n      const p = '<p class=\"foo\">bar</p>';\n      expect(sanitizer.sanitize(p)).toBe(p);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow the class attribute for pre tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 64,
                "column": 53
            },
            "line": 64,
            "code": "    it('should allow the class attribute for pre tags', () => {\n      const pre = '<pre class=\"foo\">bar</pre>';\n      expect(sanitizer.sanitize(pre)).toBe(pre);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip script tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 32
            },
            "line": 69,
            "code": "    it('should strip script tags', () => {\n      const script = '<script>alert(\"foo\")</script>';\n      expect(sanitizer.sanitize(script)).toBe('');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip iframe tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 32
            },
            "line": 74,
            "code": "    it('should strip iframe tags', () => {\n      const script = '<iframe src=\"\"></iframe>';\n      expect(sanitizer.sanitize(script)).toBe('');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip link tags",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 79,
                "column": 30
            },
            "line": 79,
            "code": "    it('should strip link tags', () => {\n      const link = '<link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\">';\n      expect(sanitizer.sanitize(link)).toBe('');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should pass through simple well-formed whitelisted markup",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 84,
                "column": 65
            },
            "line": 84,
            "code": "    it('should pass through simple well-formed whitelisted markup', () => {\n      const div = '<div><p>Hello <b>there</b></p></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow video tags with some attributes",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 89,
                "column": 52
            },
            "line": 89,
            "code": "    it('should allow video tags with some attributes', () => {\n      const video =\n        '<video src=\"my/video.mp4\" height=\"42\" width=\"42\"' +\n        ' autoplay controls loop muted></video>';\n      expect(sanitizer.sanitize(video)).toBe(video);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow audio tags with some attributes",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 52
            },
            "line": 96,
            "code": "    it('should allow audio tags with some attributes', () => {\n      const audio =\n        '<audio src=\"my/audio.ogg autoplay loop ' + 'controls muted\"></audio>';\n      expect(sanitizer.sanitize(audio)).toBe(audio);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow input tags but disable them",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 102,
                "column": 48
            },
            "line": 102,
            "code": "    it('should allow input tags but disable them', () => {\n      const html = sanitizer.sanitize('<input type=\"checkbox\" checked />');\n      const div = document.createElement('div');\n      let input: HTMLInputElement;\n\n      div.innerHTML = html;\n      input = div.querySelector('input')!;\n\n      expect(input.disabled).toBe(true);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow harmless inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 115,
                "column": 40
            },
            "line": 115,
            "code": "    it('should allow harmless inline CSS', () => {\n      const div = '<div style=\"color:green\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow abbreviated floats in CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 120,
                "column": 46
            },
            "line": 120,
            "code": "    it('should allow abbreviated floats in CSS', () => {\n      const div = '<div style=\"color:rgba(255,0,0,.8)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow background CSS line-gradient with directional",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 125,
                "column": 66
            },
            "line": 125,
            "code": "    it('should allow background CSS line-gradient with directional', () => {\n      const div =\n        '<div style=\"background:linear-gradient(to left top, blue, red)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow background CSS line-gradient with angle",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 60
            },
            "line": 131,
            "code": "    it('should allow background CSS line-gradient with angle', () => {\n      const div =\n        '<div style=\"background:linear-gradient(0deg, blue, green 40%, red)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow fully specified background CSS line-gradient",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 137,
                "column": 65
            },
            "line": 137,
            "code": "    it('should allow fully specified background CSS line-gradient', () => {\n      const div =\n        '<div style=\"background:linear-gradient(red 0%, orange 10% 30%, yellow 50% 70%, green 90% 100%)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow simple background CSS radial-gradient",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 143,
                "column": 58
            },
            "line": 143,
            "code": "    it('should allow simple background CSS radial-gradient', () => {\n      const div =\n        '<div style=\"background:radial-gradient(#e66465, #9198e5)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should allow fully specified background CSS radial-gradient",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 67
            },
            "line": 149,
            "code": "    it('should allow fully specified background CSS radial-gradient', () => {\n      const div =\n        '<div style=\"background:radial-gradient(ellipse farthest-corner at 90% 90%, red, yellow 10%, #1e90ff 50%, beige)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe(div);\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "strip incorrect CSS line-gradient",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 155,
                "column": 41
            },
            "line": 155,
            "code": "    it('strip incorrect CSS line-gradient', () => {\n      const div =\n        '<div style=\"background:linear-gradient(http://example.com)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip 'content' properties from inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 57
            },
            "line": 161,
            "code": "    it(\"should strip 'content' properties from inline CSS\", () => {\n      const div = '<div style=\"color: green; content: attr(title)\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div style=\"color:green\"></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip 'counter-increment' properties from inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 166,
                "column": 67
            },
            "line": 166,
            "code": "    it(\"should strip 'counter-increment' properties from inline CSS\", () => {\n      const div = '<div style=\"counter-increment: example-counter;\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip 'counter-reset' properties from inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 171,
                "column": 63
            },
            "line": 171,
            "code": "    it(\"should strip 'counter-reset' properties from inline CSS\", () => {\n      const div = '<div style=\"counter-reset: chapter-count 0;\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip 'widows' properties from inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 176,
                "column": 56
            },
            "line": 176,
            "code": "    it(\"should strip 'widows' properties from inline CSS\", () => {\n      const div = '<div style=\"widows: 2;\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should strip 'orphans' properties from inline CSS",
            "suites": [
                "sanitizer",
                "#sanitize()"
            ],
            "updatePoint": {
                "line": 181,
                "column": 57
            },
            "line": 181,
            "code": "    it(\"should strip 'orphans' properties from inline CSS\", () => {\n      const div = '<div style=\"orphans: 3;\"></div>';\n      expect(sanitizer.sanitize(div)).toBe('<div></div>');\n    });",
            "file": "sanitizer.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add a new command",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#add"
            ],
            "updatePoint": {
                "line": 18,
                "column": 34
            },
            "line": 18,
            "code": "      it('should add a new command', () => {\n        const commandId = 'test:command';\n        let test = 2;\n        semanticCmd.add({\n          id: commandId,\n          isEnabled: () => test === 2,\n          rank: 10\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add a command with default rank if not provided",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#add"
            ],
            "updatePoint": {
                "line": 30,
                "column": 64
            },
            "line": 30,
            "code": "      it('should add a command with default rank if not provided', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          rank: SemanticCommand.DEFAULT_RANK + 1\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add an enabled command if isEnabled not provided",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#add"
            ],
            "updatePoint": {
                "line": 44,
                "column": 65
            },
            "line": 44,
            "code": "      it('should add an enabled command if isEnabled not provided', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          isEnabled: () => false\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should reject adding a command with an already used id",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#add"
            ],
            "updatePoint": {
                "line": 58,
                "column": 64
            },
            "line": 58,
            "code": "      it('should reject adding a command with an already used id', () => {\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId\n        });\n\n        expect(() => {\n          semanticCmd.add({ id: commandId });\n        }).toThrow(/Command\\s.+\\sis already defined\\./);\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return null if no command is defined",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#getActiveCommandId"
            ],
            "updatePoint": {
                "line": 71,
                "column": 53
            },
            "line": 71,
            "code": "      it('should return null if no command is defined', () => {\n        expect(semanticCmd.getActiveCommandId(new Widget())).toBeNull();\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return null if no command is enabled",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#getActiveCommandId"
            ],
            "updatePoint": {
                "line": 75,
                "column": 53
            },
            "line": 75,
            "code": "      it('should return null if no command is enabled', () => {\n        semanticCmd.add({\n          id: 'test:disabled',\n          isEnabled: () => false\n        });\n        expect(semanticCmd.getActiveCommandId(new Widget())).toBeNull();\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return the enabled command with the smallest rank",
            "suites": [
                "@jupyterlab/apputils",
                "SemanticCommand",
                "#getActiveCommandId"
            ],
            "updatePoint": {
                "line": 83,
                "column": 66
            },
            "line": 83,
            "code": "      it('should return the enabled command with the smallest rank', () => {\n        semanticCmd.add({\n          id: 'not:selected',\n          rank: 20\n        });\n\n        const commandId = 'test:command';\n        semanticCmd.add({\n          id: commandId,\n          rank: 10\n        });\n\n        expect(semanticCmd.getActiveCommandId(new Widget())).toEqual(commandId);\n      });",
            "file": "semanticCommand.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create a session context",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 41
            },
            "line": 82,
            "code": "      it('should create a session context', () => {\n        expect(sessionContext).toBeInstanceOf(SessionContext);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when the session context is disposed",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#disposed"
            ],
            "updatePoint": {
                "line": 88,
                "column": 64
            },
            "line": 88,
            "code": "      it('should be emitted when the session context is disposed', async () => {\n        sessionContext.kernelPreference = { canStart: false };\n        await sessionContext.initialize();\n        let called = false;\n        sessionContext.disposed.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        sessionContext.dispose();\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when the kernel changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelChanged"
            ],
            "updatePoint": {
                "line": 103,
                "column": 51
            },
            "line": 103,
            "code": "      it('should be emitted when the kernel changes', async () => {\n        let called = false;\n        sessionContext.kernelChanged.connect(\n          (sender, { oldValue, newValue }) => {\n            if (oldValue !== null) {\n              return;\n            }\n            expect(sender).toBe(sessionContext);\n            expect(oldValue).toBeNull();\n            expect(newValue).toBe(sessionContext.session?.kernel || null);\n            called = true;\n          }\n        );\n        await sessionContext.initialize();\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when the session changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#sessionChanged"
            ],
            "updatePoint": {
                "line": 122,
                "column": 52
            },
            "line": 122,
            "code": "      it('should be emitted when the session changes', async () => {\n        let called = false;\n        sessionContext.sessionChanged.connect(\n          (sender, { oldValue, newValue }) => {\n            if (oldValue !== null) {\n              return;\n            }\n            expect(sender).toBe(sessionContext);\n            expect(oldValue).toBeNull();\n            expect(newValue).toBe(sessionContext.session);\n            called = true;\n          }\n        );\n        await sessionContext.initialize();\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when the status changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#statusChanged"
            ],
            "updatePoint": {
                "line": 141,
                "column": 51
            },
            "line": 141,
            "code": "      it('should be emitted when the status changes', async () => {\n        let called = false;\n        sessionContext.statusChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(typeof args).toBe('string');\n          called = true;\n        });\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted for iopub kernel messages",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#iopubMessage"
            ],
            "updatePoint": {
                "line": 155,
                "column": 53
            },
            "line": 155,
            "code": "      it('should be emitted for iopub kernel messages', async () => {\n        let called = false;\n        sessionContext.iopubMessage.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          called = true;\n        });\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when a session path changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#propertyChanged"
            ],
            "updatePoint": {
                "line": 168,
                "column": 55
            },
            "line": 168,
            "code": "      it('should be emitted when a session path changes', async () => {\n        let called = false;\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('path');\n          called = true;\n        });\n        await sessionContext.session!.setPath('foo');\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when a session name changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#propertyChanged"
            ],
            "updatePoint": {
                "line": 180,
                "column": 55
            },
            "line": 180,
            "code": "      it('should be emitted when a session name changes', async () => {\n        let called = false;\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('name');\n          called = true;\n        });\n        await sessionContext.session!.setName('foo');\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be emitted when a session type changes",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#propertyChanged"
            ],
            "updatePoint": {
                "line": 192,
                "column": 55
            },
            "line": 192,
            "code": "      it('should be emitted when a session type changes', async () => {\n        let called = false;\n\n        await sessionContext.initialize();\n        sessionContext.propertyChanged.connect((sender, args) => {\n          expect(sender).toBe(sessionContext);\n          expect(args).toBe('type');\n          called = true;\n        });\n        await sessionContext.session!.setType('foo');\n        expect(called).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the current kernel of the the session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernel"
            ],
            "updatePoint": {
                "line": 207,
                "column": 57
            },
            "line": 207,
            "code": "      it('should be the current kernel of the the session', async () => {\n        expect(sessionContext.session?.kernel).toBeFalsy();\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel).toBeTruthy();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the kernel preference of the session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelPreference"
            ],
            "updatePoint": {
                "line": 215,
                "column": 56
            },
            "line": 215,
            "code": "      it('should be the kernel preference of the session', () => {\n        const preference: ISessionContext.IKernelPreference = {\n          name: 'foo',\n          language: 'bar',\n          id: '1234',\n          shouldStart: true,\n          canStart: true\n        };\n        sessionContext.kernelPreference = preference;\n        expect(sessionContext.kernelPreference).toBe(preference);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the session manager used by the session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#manager"
            ],
            "updatePoint": {
                "line": 229,
                "column": 59
            },
            "line": 229,
            "code": "      it('should be the session manager used by the session', () => {\n        expect(sessionContext.sessionManager).toBe(sessionManager);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should start the default kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 235,
                "column": 41
            },
            "line": 235,
            "code": "      it('should start the default kernel', async () => {\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel?.name).toBe(\n          specsManager.specs!.default\n        );\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should connect to an existing session on the path",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 242,
                "column": 59
            },
            "line": 242,
            "code": "      it('should connect to an existing session on the path', async () => {\n        const other = await sessionManager.startNew({\n          name: '',\n          path,\n          type: 'test'\n        });\n\n        await sessionContext.initialize();\n        expect(other.kernel?.id).toBeDefined();\n        expect(other.kernel?.id).toBe(sessionContext.session?.kernel?.id);\n        await other.shutdown();\n        other.dispose();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should connect to an existing kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 256,
                "column": 46
            },
            "line": 256,
            "code": "      it('should connect to an existing kernel', async () => {\n        // Shut down and dispose the session so it can be re-instantiated.\n        await sessionContext.shutdown();\n\n        const other = await sessionManager.startNew({\n          name: '',\n          path: UUID.uuid4(),\n          type: 'test'\n        });\n        const kernelPreference = { id: other.kernel!.id };\n\n        sessionContext = new SessionContext({\n          sessionManager,\n          specsManager,\n          kernelPreference\n        });\n        await sessionContext.initialize();\n        expect(other.kernel?.id).toBeDefined();\n        expect(other.kernel?.id).toBe(sessionContext.session?.kernel?.id);\n        // We don't call other.shutdown() here because that\n        // is handled by the afterEach() handler above.\n        other.dispose();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should yield true if there is no distinct kernel to start",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 280,
                "column": 67
            },
            "line": 280,
            "code": "      it('should yield true if there is no distinct kernel to start', async () => {\n        // Remove the kernel preference before initializing.\n        sessionContext.kernelPreference = {};\n        const result = await sessionContext.initialize();\n        expect(result).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be a no-op if the shouldStart kernelPreference is false",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 287,
                "column": 72
            },
            "line": 287,
            "code": "      it('should be a no-op if the shouldStart kernelPreference is false', async () => {\n        sessionContext.kernelPreference = { shouldStart: false };\n        const result = await sessionContext.initialize();\n        expect(result).toBe(false);\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be a no-op if the canStart kernelPreference is false",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 294,
                "column": 69
            },
            "line": 294,
            "code": "      it('should be a no-op if the canStart kernelPreference is false', async () => {\n        sessionContext.kernelPreference = { canStart: false };\n        const result = await sessionContext.initialize();\n        expect(result).toBe(false);\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should handle an error during startup",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 301,
                "column": 47
            },
            "line": 301,
            "code": "      it('should handle an error during startup', async () => {\n        // Give it a mock manager that errors on connectTo\n        const mockManager = new SessionManager({ kernelManager });\n\n        sessionContext = new SessionContext({\n          path,\n          sessionManager: mockManager,\n          specsManager,\n          kernelPreference: { name: specsManager.specs?.default }\n        });\n\n        (mockManager as any).running = () => {\n          return [{ path }];\n        };\n        (mockManager as any).connectTo = () => {\n          throw new Error('mock error');\n        };\n\n        let caught = false;\n        const promise = sessionContext.initialize().catch(() => {\n          caught = true;\n        });\n        await Promise.all([promise, acceptDialog()]);\n        expect(caught).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the display name of the current kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayName"
            ],
            "updatePoint": {
                "line": 329,
                "column": 58
            },
            "line": 329,
            "code": "      it('should be the display name of the current kernel', async () => {\n        await sessionContext.initialize();\n        const spec = await sessionContext.session!.kernel!.spec;\n        expect(sessionContext.kernelDisplayName).toBe(spec!.display_name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should display \"No Kernel\" when there is no kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayName"
            ],
            "updatePoint": {
                "line": 335,
                "column": 60
            },
            "line": 335,
            "code": "      it('should display \"No Kernel\" when there is no kernel', async () => {\n        sessionContext.kernelPreference = {\n          canStart: false,\n          shouldStart: false\n        };\n        expect(sessionContext.kernelDisplayName).toBe('No Kernel');\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the status of the current kernel if connected",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayStatus"
            ],
            "updatePoint": {
                "line": 345,
                "column": 65
            },
            "line": 345,
            "code": "      it('should be the status of the current kernel if connected', async () => {\n        await sessionContext.initialize();\n        await sessionContext.session!.kernel!.info;\n        expect(sessionContext.kernelDisplayStatus).toBe(\n          sessionContext.session?.kernel?.status\n        );\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be the connection status of the current kernel if not connected",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayStatus"
            ],
            "updatePoint": {
                "line": 353,
                "column": 80
            },
            "line": 353,
            "code": "      it('should be the connection status of the current kernel if not connected', async () => {\n        await sessionContext.initialize();\n        const reconnect = sessionContext.session!.kernel!.reconnect();\n        expect(sessionContext.kernelDisplayStatus).toBe(\n          sessionContext.session?.kernel?.connectionStatus\n        );\n        await reconnect;\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be \"initializing\" if it looks like we are trying to start a kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayStatus"
            ],
            "updatePoint": {
                "line": 362,
                "column": 83
            },
            "line": 362,
            "code": "      it('should be \"initializing\" if it looks like we are trying to start a kernel', async () => {\n        sessionContext.kernelPreference = {};\n        expect(sessionContext.kernelDisplayStatus).toBe('initializing');\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be \"unknown\" if there is no current kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#kernelDisplayStatus"
            ],
            "updatePoint": {
                "line": 367,
                "column": 59
            },
            "line": 367,
            "code": "      it('should be \"unknown\" if there is no current kernel', async () => {\n        await sessionContext.initialize();\n        await sessionContext.shutdown();\n        expect(sessionContext.kernelDisplayStatus).toBe('unknown');\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should test whether a client session has been disposed",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 375,
                "column": 64
            },
            "line": 375,
            "code": "      it('should test whether a client session has been disposed', () => {\n        expect(sessionContext.isDisposed).toBe(false);\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dispose the resources held by the client session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 383,
                "column": 65
            },
            "line": 383,
            "code": "      it('should dispose the resources held by the client session', () => {\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n        sessionContext.dispose();\n        expect(sessionContext.isDisposed).toBe(true);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should not shut down the session by default",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 390,
                "column": 53
            },
            "line": 390,
            "code": "      it('should not shut down the session by default', async () => {\n        await sessionContext.initialize();\n        const id = sessionContext.session!.id;\n        sessionContext.dispose();\n        const sessions = await SessionAPI.listRunning();\n        expect(sessions.find(s => s.id === id)).toBeTruthy();\n        await SessionAPI.shutdownSession(id);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should shut down the session when shutdownOnDispose is true",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 399,
                "column": 69
            },
            "line": 399,
            "code": "      it('should shut down the session when shutdownOnDispose is true', async () => {\n        sessionContext.kernelPreference = {\n          ...sessionContext.kernelPreference,\n          shutdownOnDispose: true\n        };\n        const delegate = new PromiseDelegate();\n        await sessionContext.initialize();\n        const id = sessionContext.session!.id;\n        // Wait for the session to shut down.\n        sessionContext.sessionManager.runningChanged.connect((_, sessions) => {\n          if (!sessions.find(s => s.id === id)) {\n            delegate.resolve(void 0);\n            return;\n          }\n        });\n        sessionContext.dispose();\n        await expect(delegate.promise).resolves.not.toThrow();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should change the current kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 420,
                "column": 42
            },
            "line": 420,
            "code": "      it('should change the current kernel', async () => {\n        await sessionContext.initialize();\n\n        const name = sessionContext.session?.kernel?.name;\n        const id = sessionContext.session?.kernel?.id;\n        const kernel = (await sessionContext.changeKernel({ name }))!;\n\n        expect(kernel.id).not.toBe(id);\n        expect(kernel.name).toBe(name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should still work if called before fully initialized",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 431,
                "column": 62
            },
            "line": 431,
            "code": "      it('should still work if called before fully initialized', async () => {\n        const initPromise = sessionContext.initialize(); // Start but don't finish init.\n        const name = 'echo';\n        const kernelPromise = sessionContext.changeKernel({ name });\n\n        let lastKernel: IKernelConnection | null | undefined = null;\n        sessionContext.kernelChanged.connect(() => {\n          lastKernel = sessionContext.session?.kernel;\n        });\n        const results = await Promise.all([kernelPromise, initPromise]);\n        const kernel = results[0];\n        const shouldSelect = results[1];\n        expect(shouldSelect).toBe(false);\n        expect(lastKernel).toBe(kernel);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should handle multiple requests",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 447,
                "column": 41
            },
            "line": 447,
            "code": "      it('should handle multiple requests', async () => {\n        await sessionContext.initialize();\n        const name = 'echo';\n        const kernelPromise0 = sessionContext.changeKernel({ name });\n        // The last launched kernel should win.\n        const kernelPromise1 = sessionContext.changeKernel({ name });\n\n        let lastKernel: IKernelConnection | null | undefined = null;\n        sessionContext.kernelChanged.connect(() => {\n          lastKernel = sessionContext.session?.kernel;\n        });\n        const results = await Promise.all([kernelPromise0, kernelPromise1]);\n        // We can't know which of the two was launched first, so the result\n        // could be either, just make sure it isn't the original kernel.\n        expect([results[0], results[1]]).toContain(lastKernel);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should kill the kernel and shut down the session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#shutdown"
            ],
            "updatePoint": {
                "line": 466,
                "column": 58
            },
            "line": 466,
            "code": "      it('should kill the kernel and shut down the session', async () => {\n        await sessionContext.initialize();\n        expect(sessionContext.session?.kernel).toBeTruthy();\n        await sessionContext.shutdown();\n        expect(sessionContext.session?.kernel).toBeFalsy();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should handle a shutdown during startup",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                "#shutdown"
            ],
            "updatePoint": {
                "line": 473,
                "column": 49
            },
            "line": 473,
            "code": "      it('should handle a shutdown during startup', async () => {\n        const initPromise = sessionContext.initialize(); // Start but don't finish init.\n        const shutdownPromise = sessionContext.shutdown();\n        const results = await Promise.all([initPromise, shutdownPromise]);\n        expect(results[0]).toBe(false);\n        expect(sessionContext.session).toBe(null);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return null if no options are given",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                ".getDefaultKernel()"
            ],
            "updatePoint": {
                "line": 483,
                "column": 52
            },
            "line": 483,
            "code": "      it('should return null if no options are given', () => {\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: {}\n          })\n        ).toBeNull();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return a matching name",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                ".getDefaultKernel()"
            ],
            "updatePoint": {
                "line": 492,
                "column": 39
            },
            "line": 492,
            "code": "      it('should return a matching name', () => {\n        const spec =\n          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;\n\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: { name: spec.name }\n          })\n        ).toBe(spec.name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return null if no match is found",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                ".getDefaultKernel()"
            ],
            "updatePoint": {
                "line": 504,
                "column": 49
            },
            "line": 504,
            "code": "      it('should return null if no match is found', () => {\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: specsManager.specs,\n            preference: { name: 'foo' }\n          })\n        ).toBeNull();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return a matching language",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                ".getDefaultKernel()"
            ],
            "updatePoint": {
                "line": 513,
                "column": 43
            },
            "line": 513,
            "code": "      it('should return a matching language', () => {\n        const spec =\n          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;\n        const kernelspecs: any = {};\n\n        kernelspecs[spec.name] = spec;\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: {\n              default: spec.name,\n              kernelspecs\n            },\n            preference: { language: spec.language }\n          })\n        ).toBe(spec.name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return null if a language matches twice",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContext",
                ".getDefaultKernel()"
            ],
            "updatePoint": {
                "line": 530,
                "column": 56
            },
            "line": 530,
            "code": "      it('should return null if a language matches twice', () => {\n        const spec =\n          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;\n        const kernelspecs: any = {};\n\n        kernelspecs['foo'] = spec;\n        kernelspecs['bar'] = spec;\n        expect(\n          SessionContext.getDefaultKernel({\n            specs: {\n              default: spec.name,\n              kernelspecs\n            },\n            preference: { language: spec.language }\n          })\n        ).toBeNull();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should select a kernel for the session",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContextDialogs",
                "#selectKernel()"
            ],
            "updatePoint": {
                "line": 594,
                "column": 48
            },
            "line": 594,
            "code": "      it('should select a kernel for the session', async () => {\n        await sessionContext.initialize();\n\n        const { id, name } = sessionContext!.session!.kernel!;\n        const accept = acceptDialog();\n\n        await sessionContextDialogs.selectKernel(sessionContext);\n        await accept;\n\n        const session = sessionContext?.session;\n        expect(session!.kernel!.id).not.toBe(id);\n        expect(session!.kernel!.name).toBe(name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should keep the existing kernel if dismissed",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContextDialogs",
                "#selectKernel()"
            ],
            "updatePoint": {
                "line": 608,
                "column": 54
            },
            "line": 608,
            "code": "      it('should keep the existing kernel if dismissed', async () => {\n        await sessionContext.initialize();\n\n        const { id, name } = sessionContext!.session!.kernel!;\n        const dismiss = dismissDialog();\n\n        await sessionContextDialogs.selectKernel(sessionContext);\n        await dismiss;\n\n        const session = sessionContext.session;\n        expect(session!.kernel!.id).toBe(id);\n        expect(session!.kernel!.name).toBe(name);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should restart if the user accepts the dialog",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContextDialogs",
                "#restart()"
            ],
            "updatePoint": {
                "line": 624,
                "column": 55
            },
            "line": 624,
            "code": "      it('should restart if the user accepts the dialog', async () => {\n        const emission = testEmission(sessionContext.statusChanged, {\n          find: (_, args) => args === 'restarting'\n        });\n        await sessionContext.initialize();\n        await sessionContext!.session?.kernel?.info;\n        const restart = sessionContextDialogs.restart(sessionContext);\n\n        await acceptDialog();\n        expect(await restart).toBe(true);\n        await emission;\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should not restart if the user rejects the dialog",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContextDialogs",
                "#restart()"
            ],
            "updatePoint": {
                "line": 637,
                "column": 59
            },
            "line": 637,
            "code": "      it('should not restart if the user rejects the dialog', async () => {\n        let called = false;\n\n        await sessionContext.initialize();\n        sessionContext.statusChanged.connect((sender, args) => {\n          if (args === 'restarting') {\n            called = true;\n          }\n        });\n\n        const restart = sessionContextDialogs.restart(sessionContext);\n        await dismissDialog();\n        expect(await restart).toBe(false);\n        expect(called).toBe(false);\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should start the same kernel as the previously started kernel",
            "suites": [
                "@jupyterlab/apputils",
                "SessionContextDialogs",
                "#restart()"
            ],
            "updatePoint": {
                "line": 653,
                "column": 71
            },
            "line": 653,
            "code": "      it('should start the same kernel as the previously started kernel', async () => {\n        await sessionContext.initialize();\n        await sessionContext.shutdown();\n        await sessionContextDialogs.restart(sessionContext);\n        expect(sessionContext?.session?.kernel).toBeTruthy();\n      });",
            "file": "sessioncontext.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add an inline svg node with the 'stop' icon",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createInterruptButton()"
            ],
            "updatePoint": {
                "line": 44,
                "column": 62
            },
            "line": 44,
            "code": "        it(\"should add an inline svg node with the 'stop' icon\", async () => {\n          const button = Toolbar.createInterruptButton(sessionContext);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='stop']\")\n          ).toBeDefined();\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add an inline svg node with the 'refresh' icon",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createRestartButton()"
            ],
            "updatePoint": {
                "line": 55,
                "column": 65
            },
            "line": 55,
            "code": "        it(\"should add an inline svg node with the 'refresh' icon\", async () => {\n          const button = Toolbar.createRestartButton(\n            sessionContext,\n            new SessionContextDialogs()\n          );\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='refresh']\")\n          ).toBeDefined();\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should display the `'display_name'` of the kernel",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createKernelNameItem()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 61
            },
            "line": 69,
            "code": "        it(\"should display the `'display_name'` of the kernel\", async () => {\n          const item = Toolbar.createKernelNameItem(\n            sessionContext,\n            new SessionContextDialogs()\n          );\n          await sessionContext.initialize();\n          Widget.attach(item, document.body);\n          await framePromise();\n          const node = item.node.querySelector(\n            '.jp-ToolbarButtonComponent-label'\n          )!;\n          expect(node.textContent).toBe(sessionContext.kernelDisplayName);\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should display a busy status if the kernel status is busy",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createKernelStatusItem()"
            ],
            "updatePoint": {
                "line": 90,
                "column": 69
            },
            "line": 90,
            "code": "        it('should display a busy status if the kernel status is busy', async () => {\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          let called = false;\n          sessionContext.statusChanged.connect((_, status) => {\n            if (status === 'busy') {\n              // eslint-disable-next-line jest/no-conditional-expect\n              expect(\n                item.node.querySelector(\"[data-icon$='circle']\")\n              ).toBeDefined();\n              called = true;\n            }\n          });\n          const future = sessionContext.session!.kernel!.requestExecute({\n            code: 'a = 109\\na'\n          })!;\n          await future.done;\n          expect(called).toBe(true);\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should show the current status in the node title",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createKernelStatusItem()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 60
            },
            "line": 109,
            "code": "        it('should show the current status in the node title', async () => {\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          const status = sessionContext.session?.kernel?.status;\n          expect(item.node.title.toLowerCase()).toContain(status);\n          let called = false;\n          const future = sessionContext.session!.kernel!.requestExecute({\n            code: 'a = 1'\n          })!;\n          future.onIOPub = msg => {\n            if (sessionContext.session?.kernel?.status === 'busy') {\n              // eslint-disable-next-line jest/no-conditional-expect\n              expect(item.node.title.toLowerCase()).toContain('busy');\n              called = true;\n            }\n          };\n          await future.done;\n          expect(called).toBe(true);\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should handle a starting session",
            "suites": [
                "@jupyterlab/apputils",
                "Toolbar",
                "Kernel buttons",
                ".createKernelStatusItem()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 44
            },
            "line": 128,
            "code": "        it('should handle a starting session', async () => {\n          await sessionContext.session?.kernel?.info;\n          await sessionContext.shutdown();\n          sessionContext = await createSessionContext();\n          await sessionContext.initialize();\n          const item = Toolbar.createKernelStatusItem(sessionContext);\n          expect(item.node.title).toBe('Kernel Connecting');\n          expect(\n            item.node.querySelector(\"[data-icon$='circle-empty']\")\n          ).toBeDefined();\n          await sessionContext.initialize();\n          await sessionContext.session?.kernel?.info;\n        });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should set a default factory",
            "suites": [
                "@jupyterlab/apputils",
                "ToolbarWidgetRegistry",
                "#constructor"
            ],
            "updatePoint": {
                "line": 147,
                "column": 38
            },
            "line": 147,
            "code": "      it('should set a default factory', () => {\n        const dummy = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        expect(registry.defaultFactory).toBe(dummy);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should set a default factory",
            "suites": [
                "@jupyterlab/apputils",
                "ToolbarWidgetRegistry",
                "#defaultFactory"
            ],
            "updatePoint": {
                "line": 158,
                "column": 38
            },
            "line": 158,
            "code": "      it('should set a default factory', () => {\n        const dummy = jest.fn();\n        const dummy2 = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        registry.defaultFactory = dummy2;\n\n        expect(registry.defaultFactory).toBe(dummy2);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should call the default factory as fallback",
            "suites": [
                "@jupyterlab/apputils",
                "ToolbarWidgetRegistry",
                "#createWidget"
            ],
            "updatePoint": {
                "line": 172,
                "column": 53
            },
            "line": 172,
            "code": "      it('should call the default factory as fallback', () => {\n        const documentWidget = new Widget();\n        const dummyWidget = new Widget();\n        const dummy = jest.fn().mockReturnValue(dummyWidget);\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory: dummy\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        const widget = registry.createWidget('factory', documentWidget, item);\n\n        expect(widget).toBe(dummyWidget);\n        expect(dummy).toHaveBeenCalledWith('factory', documentWidget, item);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should call the registered factory",
            "suites": [
                "@jupyterlab/apputils",
                "ToolbarWidgetRegistry",
                "#createWidget"
            ],
            "updatePoint": {
                "line": 190,
                "column": 44
            },
            "line": 190,
            "code": "      it('should call the registered factory', () => {\n        const documentWidget = new Widget();\n        const dummyWidget = new Widget();\n        const defaultFactory = jest.fn().mockReturnValue(dummyWidget);\n        const dummy = jest.fn().mockReturnValue(dummyWidget);\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        registry.addFactory('factory', item.name, dummy);\n\n        const widget = registry.createWidget('factory', documentWidget, item);\n\n        expect(widget).toBe(dummyWidget);\n        expect(dummy).toHaveBeenCalledWith(documentWidget);\n        expect(defaultFactory).toHaveBeenCalledTimes(0);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return the previous registered factory",
            "suites": [
                "@jupyterlab/apputils",
                "ToolbarWidgetRegistry",
                "#addFactory"
            ],
            "updatePoint": {
                "line": 214,
                "column": 55
            },
            "line": 214,
            "code": "      it('should return the previous registered factory', () => {\n        const defaultFactory = jest.fn();\n        const dummy = jest.fn();\n        const dummy2 = jest.fn();\n        const registry = new ToolbarWidgetRegistry({\n          defaultFactory\n        });\n\n        const item: ToolbarRegistry.IWidget = {\n          name: 'test'\n        };\n\n        expect(\n          registry.addFactory('factory', item.name, dummy)\n        ).toBeUndefined();\n        expect(registry.addFactory('factory', item.name, dummy2)).toBe(dummy);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return the toolbar items",
            "suites": [
                "@jupyterlab/apputils",
                "createToolbarFactory"
            ],
            "updatePoint": {
                "line": 235,
                "column": 39
            },
            "line": 235,
            "code": "    it('should return the toolbar items', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: jest.fn()\n      });\n\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'insert',\n                command: 'notebook:insert-cell-below',\n                rank: 20\n              },\n              { name: 'spacer', type: 'spacer', rank: 100 },\n              { name: 'cut', command: 'notebook:cut-cell', rank: 21 },\n              {\n                name: 'clear-all',\n                command: 'notebook:clear-all-cell-outputs',\n                rank: 60,\n                disabled: true\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        languageCode: 'en',\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      await settingRegistry.load(bar.id);\n\n      const items = factory(new Widget());\n      expect(items).toHaveLength(3);\n      expect(items.get(0).name).toEqual('insert');\n      expect(items.get(1).name).toEqual('cut');\n      expect(items.get(2).name).toEqual('spacer');\n    });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should update the toolbar items with late settings load",
            "suites": [
                "@jupyterlab/apputils",
                "createToolbarFactory"
            ],
            "updatePoint": {
                "line": 323,
                "column": 63
            },
            "line": 323,
            "code": "    it('should update the toolbar items with late settings load', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: jest.fn()\n      });\n\n      const foo: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: 'foo',\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              { name: 'cut', command: 'notebook:cut-cell', rank: 21 },\n              { name: 'insert', rank: 40 },\n              {\n                name: 'clear-all',\n                disabled: true\n              }\n            ]\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'insert',\n                command: 'notebook:insert-cell-below',\n                rank: 20\n              },\n              {\n                name: 'clear-all',\n                command: 'notebook:clear-all-cell-outputs',\n                rank: 60\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            case foo.id:\n              return foo;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        languageCode: 'en',\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      const barPlugin = await settingRegistry.load(bar.id);\n      const baseToolbar = JSONExt.deepCopy(\n        barPlugin.composite['toolbar'] as any\n      );\n\n      let waitForChange = new PromiseDelegate<void>();\n      barPlugin.changed.connect(() => {\n        if (\n          !JSONExt.deepEqual(baseToolbar, barPlugin.composite['toolbar'] as any)\n        ) {\n          waitForChange.resolve();\n        }\n      });\n      await settingRegistry.load(foo.id);\n      await waitForChange.promise;\n\n      const items = factory(new Widget());\n      expect(items).toHaveLength(2);\n      expect(items.get(0).name).toEqual('cut');\n      expect(items.get(1).name).toEqual('insert');\n    });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be callable multiple times",
            "suites": [
                "@jupyterlab/apputils",
                "createToolbarFactory"
            ],
            "updatePoint": {
                "line": 445,
                "column": 41
            },
            "line": 445,
            "code": "    it('should be callable multiple times', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: jest.fn()\n      });\n\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'insert',\n                command: 'notebook:insert-cell-below',\n                rank: 20\n              },\n              { name: 'spacer', type: 'spacer', rank: 100 },\n              { name: 'cut', command: 'notebook:cut-cell', rank: 21 },\n              {\n                name: 'clear-all',\n                command: 'notebook:clear-all-cell-outputs',\n                rank: 60,\n                disabled: true\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        languageCode: 'en',\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      const factory2 = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      await settingRegistry.load(bar.id);\n\n      expect(factory(new Widget())).toHaveLength(3);\n      expect(factory2(new Widget())).toHaveLength(3);\n    });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should update the toolbar items with late item factory",
            "suites": [
                "@jupyterlab/apputils",
                "createToolbarFactory"
            ],
            "updatePoint": {
                "line": 538,
                "column": 62
            },
            "line": 538,
            "code": "    it('should update the toolbar items with late item factory', async () => {\n      const factoryName = 'dummyFactory';\n      const pluginId = 'test-plugin:settings';\n\n      const dummyWidget = new Widget();\n      const defaultFactory = jest.fn().mockReturnValue(dummyWidget);\n\n      const textContent = 'This is a test widget';\n      const node = document.createElement('div');\n      node.textContent = textContent;\n      const testWidget = new Widget({ node });\n      const itemFactory = jest.fn().mockReturnValue(testWidget);\n\n      const toolbarRegistry = new ToolbarWidgetRegistry({\n        defaultFactory: defaultFactory\n      });\n\n      const bar: ISettingRegistry.IPlugin = {\n        data: {\n          composite: {},\n          user: {}\n        },\n        id: pluginId,\n        raw: '{}',\n        schema: {\n          'jupyter.lab.toolbars': {\n            dummyFactory: [\n              {\n                name: 'test',\n                rank: 20\n              }\n            ]\n          },\n          'jupyter.lab.transform': true,\n          properties: {\n            toolbar: {\n              type: 'array'\n            }\n          },\n          type: 'object'\n        },\n        version: 'test'\n      };\n\n      const connector: IDataConnector<\n        ISettingRegistry.IPlugin,\n        string,\n        string,\n        string\n      > = {\n        fetch: jest.fn().mockImplementation((id: string) => {\n          switch (id) {\n            case bar.id:\n              return bar;\n            default:\n              return {};\n          }\n        }),\n        list: jest.fn(),\n        save: jest.fn(),\n        remove: jest.fn()\n      };\n\n      const settingRegistry = new SettingRegistry({\n        connector\n      });\n\n      const translator: ITranslator = {\n        languageCode: 'en',\n        load: jest.fn()\n      };\n\n      const factory = createToolbarFactory(\n        toolbarRegistry,\n        settingRegistry,\n        factoryName,\n        pluginId,\n        translator\n      );\n\n      await settingRegistry.load(bar.id);\n\n      const toolbar = factory(new Widget());\n\n      // Should contain the defaultFactory widget\n      expect(toolbar).toHaveLength(1);\n      expect(toolbar.get(0).widget.node.textContent).not.toContain(textContent);\n\n      // Add a factory item to the toolbar should re-render the widget.\n      toolbarRegistry.addFactory(factoryName, 'test', itemFactory);\n      expect(toolbar).toHaveLength(1);\n      expect(toolbar.get(0).widget.node.textContent).toContain(textContent);\n    });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create an WidgetTracker",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 47,
                "column": 40
            },
            "line": 47,
            "code": "      it('should create an WidgetTracker', () => {\n        expect(tracker).toBeInstanceOf(WidgetTracker);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit for the first added widget",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentChanged"
            ],
            "updatePoint": {
                "line": 66,
                "column": 48
            },
            "line": 66,
            "code": "      it('should emit for the first added widget', async () => {\n        const promise = signalToPromise(tracker.currentChanged);\n        void tracker.add(widget);\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit when a widget is added and there is another widget that does not have focus",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentChanged"
            ],
            "updatePoint": {
                "line": 72,
                "column": 97
            },
            "line": 72,
            "code": "      it('should emit when a widget is added and there is another widget that does not have focus', async () => {\n        await tracker.add(widget);\n        const promise = signalToPromise(tracker.currentChanged);\n        await tracker.add(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should not emit when a widget is added and there is another widget that has focus",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentChanged"
            ],
            "updatePoint": {
                "line": 79,
                "column": 91
            },
            "line": 79,
            "code": "      it('should not emit when a widget is added and there is another widget that has focus', async () => {\n        Widget.attach(widget, document.body);\n        focus(widget);\n        await tracker.add(widget);\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        await tracker.add(widget2);\n        expect(called).toBe(false);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit when the focus changes",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentChanged"
            ],
            "updatePoint": {
                "line": 91,
                "column": 44
            },
            "line": 91,
            "code": "      it('should emit when the focus changes', async () => {\n        Widget.attach(widget, document.body);\n        Widget.attach(widget2, document.body);\n        focus(widget);\n        await tracker.add(widget);\n        await tracker.add(widget2);\n        const promise = signalToPromise(tracker.currentChanged);\n        focus(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should emit when a widget has been added",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#widgetAdded"
            ],
            "updatePoint": {
                "line": 117,
                "column": 50
            },
            "line": 117,
            "code": "      it('should emit when a widget has been added', async () => {\n        const promise = signalToPromise(tracker.widgetAdded);\n\n        await tracker.add(widget);\n\n        const [sender, args] = await promise;\n\n        expect(sender).toBe(tracker);\n        expect(args).toBe(widget);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should not emit when a widget has been injected",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#widgetAdded"
            ],
            "updatePoint": {
                "line": 128,
                "column": 57
            },
            "line": 128,
            "code": "      it('should not emit when a widget has been injected', async () => {\n        let total = 0;\n        const promise = testEmission(tracker.currentChanged, {\n          find: () => {\n            return total === 1;\n          }\n        });\n\n        tracker.widgetAdded.connect(() => {\n          total++;\n        });\n        void tracker.add(widget);\n        void tracker.inject(widget2);\n        Widget.attach(widget2, document.body);\n        focus(widget2);\n        Widget.detach(widget2);\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 149,
                "column": 32
            },
            "line": 149,
            "code": "      it('should default to null', () => {\n        expect(tracker.currentWidget).toBeNull();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be updated when a widget is added",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 153,
                "column": 50
            },
            "line": 153,
            "code": "      it('should be updated when a widget is added', async () => {\n        const widget = createWidget();\n\n        await tracker.add(widget);\n        expect(tracker.currentWidget).toBe(widget);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be updated when a widget is focused",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 161,
                "column": 52
            },
            "line": 161,
            "code": "      it('should be updated when a widget is focused', async () => {\n        const panel = new Panel();\n        const widget0 = createWidget();\n        const widget1 = createWidget();\n\n        await tracker.add(widget0);\n        await tracker.add(widget1);\n        panel.addWidget(widget0);\n        panel.addWidget(widget1);\n        Widget.attach(panel, document.body);\n        expect(tracker.currentWidget).toBe(widget1);\n        focus(widget0);\n        expect(tracker.currentWidget).toBe(widget0);\n        panel.dispose();\n        widget0.dispose();\n        widget1.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should revert to last added widget on widget disposal",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 179,
                "column": 63
            },
            "line": 179,
            "code": "      it('should revert to last added widget on widget disposal', async () => {\n        const one = createWidget();\n        const two = createWidget();\n\n        await tracker.add(one);\n        await tracker.add(two);\n        focus(one);\n        focus(two);\n        expect(tracker.currentWidget).toBe(two);\n        two.dispose();\n        expect(tracker.currentWidget).toBe(one);\n        one.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should preserve the tracked widget on widget disposal",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 193,
                "column": 63
            },
            "line": 193,
            "code": "      it('should preserve the tracked widget on widget disposal', () => {\n        const panel = new Panel();\n        const widgets = [createWidget(), createWidget(), createWidget()];\n\n        widgets.forEach(widget => {\n          void tracker.add(widget);\n          panel.addWidget(widget);\n        });\n        Widget.attach(panel, document.body);\n\n        focus(widgets[0]);\n        expect(tracker.currentWidget).toBe(widgets[0]);\n\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        widgets[2].dispose();\n        expect(tracker.currentWidget).toBe(widgets[0]);\n        expect(called).toBe(false);\n        panel.dispose();\n        widgets.forEach(widget => {\n          widget.dispose();\n        });\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should select the previously added widget on widget disposal",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#currentWidget"
            ],
            "updatePoint": {
                "line": 219,
                "column": 70
            },
            "line": 219,
            "code": "      it('should select the previously added widget on widget disposal', () => {\n        const panel = new Panel();\n        const widgets = [createWidget(), createWidget(), createWidget()];\n\n        Widget.attach(panel, document.body);\n        widgets.forEach(widget => {\n          void tracker.add(widget);\n          panel.addWidget(widget);\n          focus(widget);\n        });\n\n        let called = false;\n        tracker.currentChanged.connect(() => {\n          called = true;\n        });\n        widgets[2].dispose();\n        expect(tracker.currentWidget).toBe(widgets[1]);\n        expect(called).toBe(true);\n        panel.dispose();\n        widgets.forEach(widget => {\n          widget.dispose();\n        });\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should test whether the tracker is disposed",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 245,
                "column": 53
            },
            "line": 245,
            "code": "      it('should test whether the tracker is disposed', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should add a widget to the tracker",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#add()"
            ],
            "updatePoint": {
                "line": 253,
                "column": 44
            },
            "line": 253,
            "code": "      it('should add a widget to the tracker', async () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should reject a widget that already exists",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#add()"
            ],
            "updatePoint": {
                "line": 261,
                "column": 52
            },
            "line": 261,
            "code": "      it('should reject a widget that already exists', async () => {\n        const widget = createWidget();\n        let failed = false;\n        expect(tracker.has(widget)).toBe(false);\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        try {\n          await tracker.add(widget);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should reject a widget that is disposed",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#add()"
            ],
            "updatePoint": {
                "line": 276,
                "column": 49
            },
            "line": 276,
            "code": "      it('should reject a widget that is disposed', async () => {\n        const widget = createWidget();\n        let failed = false;\n        expect(tracker.has(widget)).toBe(false);\n        widget.dispose();\n        try {\n          await tracker.add(widget);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should remove an added widget if it is disposed",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#add()"
            ],
            "updatePoint": {
                "line": 290,
                "column": 57
            },
            "line": 290,
            "code": "      it('should remove an added widget if it is disposed', async () => {\n        const widget = createWidget();\n        await tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n        expect(tracker.has(widget)).toBe(false);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should dispose of the resources used by the tracker",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 300,
                "column": 61
            },
            "line": 300,
            "code": "      it('should dispose of the resources used by the tracker', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 306,
                "column": 47
            },
            "line": 306,
            "code": "      it('should be safe to call multiple times', () => {\n        expect(tracker.isDisposed).toBe(false);\n        tracker.dispose();\n        tracker.dispose();\n        expect(tracker.isDisposed).toBe(true);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should find a tracked item that matches a filter function",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#find()"
            ],
            "updatePoint": {
                "line": 315,
                "column": 67
            },
            "line": 315,
            "code": "      it('should find a tracked item that matches a filter function', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.find(widget => widget.id === 'B')).toBe(widgetB);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return a void if no item is found",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#find()"
            ],
            "updatePoint": {
                "line": 331,
                "column": 50
            },
            "line": 331,
            "code": "      it('should return a void if no item is found', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.find(widget => widget.id === 'D')).toBeFalsy();\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should filter according to a predicate function",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#filter()"
            ],
            "updatePoint": {
                "line": 349,
                "column": 57
            },
            "line": 349,
            "code": "      it('should filter according to a predicate function', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'include-A';\n        widgetB.id = 'include-B';\n        widgetC.id = 'exclude-C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        const list = tracker.filter(\n          widget => widget.id.indexOf('include') !== -1\n        );\n        expect(list.length).toBe(2);\n        expect(list[0]).toBe(widgetA);\n        expect(list[1]).toBe(widgetB);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return an empty array if no item is found",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#filter()"
            ],
            "updatePoint": {
                "line": 370,
                "column": 58
            },
            "line": 370,
            "code": "      it('should return an empty array if no item is found', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        expect(tracker.filter(widget => widget.id === 'D').length).toBe(0);\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should iterate through all the tracked items",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#forEach()"
            ],
            "updatePoint": {
                "line": 388,
                "column": 54
            },
            "line": 388,
            "code": "      it('should iterate through all the tracked items', () => {\n        const widgetA = createWidget();\n        const widgetB = createWidget();\n        const widgetC = createWidget();\n        let visited = '';\n        widgetA.id = 'A';\n        widgetB.id = 'B';\n        widgetC.id = 'C';\n        void tracker.add(widgetA);\n        void tracker.add(widgetB);\n        void tracker.add(widgetC);\n        tracker.forEach(widget => {\n          visited += widget.id;\n        });\n        expect(visited).toBe('ABC');\n        widgetA.dispose();\n        widgetB.dispose();\n        widgetC.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should return `true` if an item exists in the tracker",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#has()"
            ],
            "updatePoint": {
                "line": 410,
                "column": 63
            },
            "line": 410,
            "code": "      it('should return `true` if an item exists in the tracker', () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        void tracker.add(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should inject a widget into the tracker",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#inject()"
            ],
            "updatePoint": {
                "line": 420,
                "column": 49
            },
            "line": 420,
            "code": "      it('should inject a widget into the tracker', async () => {\n        const widget = createWidget();\n        expect(tracker.has(widget)).toBe(false);\n        void tracker.inject(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should remove an injected widget if it is disposed",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#inject()"
            ],
            "updatePoint": {
                "line": 428,
                "column": 60
            },
            "line": 428,
            "code": "      it('should remove an injected widget if it is disposed', async () => {\n        const widget = createWidget();\n        void tracker.inject(widget);\n        expect(tracker.has(widget)).toBe(true);\n        widget.dispose();\n        expect(tracker.has(widget)).toBe(false);\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should be called when the current widget is changed",
            "suites": [
                "@jupyterlab/apputils",
                "WidgetTracker",
                "#onCurrentChanged()"
            ],
            "updatePoint": {
                "line": 438,
                "column": 61
            },
            "line": 438,
            "code": "      it('should be called when the current widget is changed', async () => {\n        const tracker = new TestTracker({ namespace });\n        const widget = createWidget();\n        await tracker.add(widget);\n        expect(tracker.methods).toEqual(\n          expect.arrayContaining(['onCurrentChanged'])\n        );\n        widget.dispose();\n      });",
            "file": "widgettracker.spec.ts",
            "skipped": false,
            "dir": "packages/apputils/test"
        },
        {
            "name": "should create an input area widget",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 22,
                "column": 44
            },
            "line": 22,
            "code": "      it('should create an input area widget', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget).toBeInstanceOf(InputArea);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the model used by the input area",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#model"
            ],
            "updatePoint": {
                "line": 32,
                "column": 52
            },
            "line": 32,
            "code": "      it('should be the model used by the input area', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget.model).toBe(model);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the content factory used by the input area",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#contentFactory"
            ],
            "updatePoint": {
                "line": 42,
                "column": 62
            },
            "line": 42,
            "code": "      it('should be the content factory used by the input area', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget.contentFactory).toBe(contentFactory);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the editor widget used by the input area",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#editorWidget"
            ],
            "updatePoint": {
                "line": 52,
                "column": 60
            },
            "line": 52,
            "code": "      it('should be the editor widget used by the input area', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget.editorWidget).toBeInstanceOf(CodeEditorWrapper);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the code editor used by the cell",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#editor"
            ],
            "updatePoint": {
                "line": 62,
                "column": 52
            },
            "line": 62,
            "code": "      it('should be the code editor used by the cell', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget.editor.host).toBe(widget.editorWidget.node);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the prompt node used by the cell",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#promptNode"
            ],
            "updatePoint": {
                "line": 72,
                "column": 52
            },
            "line": 72,
            "code": "      it('should be the prompt node used by the cell', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        expect(widget.promptNode.className).toContain('jp-InputPrompt');\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should render the widget",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#renderInput()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 34
            },
            "line": 82,
            "code": "      it('should render the widget', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        const rendered = new Widget();\n        Widget.attach(widget, document.body);\n        widget.renderInput(rendered);\n        expect(rendered.isAttached).toBe(true);\n        widget.dispose();\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be called to show the editor",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#showEditor()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 45
            },
            "line": 96,
            "code": "      it('should be called to show the editor', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        const rendered = new Widget();\n        Widget.attach(widget, document.body);\n        widget.renderInput(rendered);\n        widget.showEditor();\n        expect(rendered.isAttached).toBe(false);\n        widget.dispose();\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should change the value of the input prompt",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#setPrompt()"
            ],
            "updatePoint": {
                "line": 111,
                "column": 53
            },
            "line": 111,
            "code": "      it('should change the value of the input prompt', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        const prompt = widget.node.querySelector(`.${PROMPT_CLASS}`)!;\n        expect(prompt.textContent).toHaveLength(0);\n        widget.setPrompt('foo');\n        expect(prompt.textContent).toContain('foo');\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources used by the widget",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 124,
                "column": 60
            },
            "line": 124,
            "code": "      it('should dispose of the resources used by the widget', () => {\n        const widget = new InputArea({\n          contentFactory,\n          model\n        });\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new content factory",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                ".ContentFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 138,
                "column": 47
            },
            "line": 138,
            "code": "        it('should create a new content factory', () => {\n          const factory = new InputArea.ContentFactory({\n            editorFactory: NBTestUtils.editorFactory\n          });\n          expect(factory).toBeInstanceOf(InputArea.ContentFactory);\n        });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the code editor factory being used",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                ".ContentFactory",
                "#editorFactory"
            ],
            "updatePoint": {
                "line": 147,
                "column": 56
            },
            "line": 147,
            "code": "        it('should be the code editor factory being used', () => {\n          const factory = new InputArea.ContentFactory({\n            editorFactory: NBTestUtils.editorFactory\n          });\n          expect(factory.editorFactory).toBe(NBTestUtils.editorFactory);\n        });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create an input prompt",
            "suites": [
                "@jupyterlab/cells",
                "InputArea",
                ".ContentFactory",
                "#createInputPrompt()"
            ],
            "updatePoint": {
                "line": 156,
                "column": 41
            },
            "line": 156,
            "code": "        it('should create an input prompt', () => {\n          const factory = new InputArea.ContentFactory({\n            editorFactory: NBTestUtils.editorFactory\n          });\n          expect(factory.createInputPrompt()).toBeInstanceOf(InputPrompt);\n        });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create an input prompt",
            "suites": [
                "@jupyterlab/cells",
                "InputPrompt",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 168,
                "column": 39
            },
            "line": 168,
            "code": "      it('should create an input prompt', () => {\n        const widget = new InputPrompt();\n        expect(widget).toBeInstanceOf(InputPrompt);\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the execution count for the prompt",
            "suites": [
                "@jupyterlab/cells",
                "InputPrompt",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 175,
                "column": 54
            },
            "line": 175,
            "code": "      it('should be the execution count for the prompt', () => {\n        const widget = new InputPrompt();\n        expect(widget.executionCount).toBeNull();\n        widget.executionCount = '1';\n        expect(widget.executionCount).toBe('1');\n      });",
            "file": "inputarea.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a cell model",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 36
            },
            "line": 32,
            "code": "      it('should create a cell model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        expect(model).toBeInstanceOf(CellModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a base cell argument",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 44
            },
            "line": 39,
            "code": "      it('should accept a base cell argument', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: { trusted: false }\n        }) as YRawCell;\n        const model = new TestModel({ sharedModel });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.sharedModel.getSource()).toBe('foo');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a base cell argument with a multiline source",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 68
            },
            "line": 50,
            "code": "      it('should accept a base cell argument with a multiline source', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false },\n          id: 'cell_id'\n        }) as YRawCell;\n        const model = new TestModel({ sharedModel });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.sharedModel.getSource()).toBe('foo\\n\\nbar\\n\\nbaz');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should use the cell id if an id is supplied",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 62,
                "column": 53
            },
            "line": 62,
            "code": "      it('should use the cell id if an id is supplied', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false },\n          id: 'cell_id'\n        }) as YRawCell;\n        const model = new TestModel({ sharedModel, id: 'my_id' });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id).toBe('cell_id');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should use the id if an cell is not supplied",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 54
            },
            "line": 74,
            "code": "      it('should use the id if an cell is not supplied', () => {\n        const model = new TestModel({ id: 'cell_id' });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id).toBe('cell_id');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should generate an id if an id or cell id is not supplied",
            "suites": [
                "cells/model",
                "CellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 80,
                "column": 67
            },
            "line": 80,
            "code": "      it('should generate an id if an id or cell id is not supplied', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false }\n        }) as YRawCell;\n        const model = new TestModel({ sharedModel });\n        expect(model).toBeInstanceOf(CellModel);\n        expect(model.id.length).toBeGreaterThan(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should signal when model content has changed",
            "suites": [
                "cells/model",
                "CellModel",
                "#contentChanged"
            ],
            "updatePoint": {
                "line": 93,
                "column": 54
            },
            "line": 93,
            "code": "      it('should signal when model content has changed', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        expect(called).toBe(false);\n        model.sharedModel.setSource('foo');\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should signal when model state has changed",
            "suites": [
                "cells/model",
                "CellModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 108,
                "column": 52
            },
            "line": 108,
            "code": "      it('should signal when model state has changed', () => {\n        const model = new CodeCellModel();\n        let called = false;\n        const listener = (sender: any, args: IChangedArgs<any>) => {\n          if (args.name == 'executionCount') {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args.newValue).toBe(1);\n            called = true;\n          }\n        };\n        model.stateChanged.connect(listener);\n        model.executionCount = 1;\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should not signal when model state has not changed",
            "suites": [
                "cells/model",
                "CellModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 123,
                "column": 60
            },
            "line": 123,
            "code": "      it('should not signal when model state has not changed', () => {\n        const model = new CodeCellModel();\n        let called = 0;\n        model.sharedModel.changed.connect((model, change) => {\n          if (change.executionCountChange) {\n            called++;\n          }\n        });\n        expect(called).toBe(0);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the trusted state of the cell",
            "suites": [
                "cells/model",
                "CellModel",
                "#trusted"
            ],
            "updatePoint": {
                "line": 140,
                "column": 49
            },
            "line": 140,
            "code": "      it('should be the trusted state of the cell', () => {\n        const model = new CodeCellModel();\n        expect(model.trusted).toBe(false);\n        model.trusted = true;\n        expect(model.trusted).toBe(true);\n        const other = new CodeCellModel({\n          trusted: true\n        });\n        expect(other.trusted).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should update the trusted state of the output models",
            "suites": [
                "cells/model",
                "CellModel",
                "#trusted"
            ],
            "updatePoint": {
                "line": 151,
                "column": 62
            },
            "line": 151,
            "code": "      it('should update the trusted state of the output models', () => {\n        const model = new CodeCellModel();\n        model.outputs.add(DEFAULT_OUTPUTS[0]);\n        expect(model.outputs.get(0).trusted).toBe(false);\n        model.trusted = true;\n        expect(model.outputs.get(0).trusted).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should signal when model metadata has changed",
            "suites": [
                "cells/model",
                "CellModel",
                "#metadataChanged"
            ],
            "updatePoint": {
                "line": 161,
                "column": 55
            },
            "line": 161,
            "code": "      it('should signal when model metadata has changed', () => {\n        const model = new CodeCellModel();\n        const listener = (sender: any, args: any) => {\n          value = args.newValue;\n        };\n        let value = '';\n        model.metadataChanged.connect(listener);\n        expect(Object.keys(value)).toHaveLength(0);\n        model.setMetadata('foo', 'bar');\n        expect(value).toBe('bar');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should not signal when model metadata has not changed",
            "suites": [
                "cells/model",
                "CellModel",
                "#metadataChanged"
            ],
            "updatePoint": {
                "line": 173,
                "column": 63
            },
            "line": 173,
            "code": "      it('should not signal when model metadata has not changed', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' })\n        });\n        let called = 0;\n        model.metadataChanged.connect(() => {\n          called++;\n        });\n        expect(called).toBe(0);\n        model.setMetadata('foo', 'bar');\n        expect(called).toBe(1);\n        model.setMetadata('foo', 'bar');\n        expect(called).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should default to an empty string",
            "suites": [
                "cells/model",
                "CellModel",
                "#source"
            ],
            "updatePoint": {
                "line": 190,
                "column": 43
            },
            "line": 190,
            "code": "      it('should default to an empty string', () => {\n        const model = new CodeCellModel();\n        expect(model.sharedModel.getSource()).toHaveLength(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "cells/model",
                "CellModel",
                "#source"
            ],
            "updatePoint": {
                "line": 195,
                "column": 28
            },
            "line": 195,
            "code": "      it('should be settable', () => {\n        const model = new CodeCellModel();\n        expect(model.sharedModel.getSource()).toHaveLength(0);\n        model.sharedModel.setSource('foo');\n        expect(model.sharedModel.getSource()).toBe('foo');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be false by default",
            "suites": [
                "cells/model",
                "CellModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 204,
                "column": 36
            },
            "line": 204,
            "code": "      it('should be false by default', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        expect(model.isDisposed).toBe(false);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be true after model is disposed",
            "suites": [
                "cells/model",
                "CellModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 211,
                "column": 48
            },
            "line": 211,
            "code": "      it('should be true after model is disposed', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources held by the model",
            "suites": [
                "cells/model",
                "CellModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 221,
                "column": 59
            },
            "line": 221,
            "code": "      it('should dispose of the resources held by the model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' })\n        });\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "cells/model",
                "CellModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 229,
                "column": 47
            },
            "line": 229,
            "code": "      it('should be safe to call multiple times', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should return a base cell encapsulation of the model value",
            "suites": [
                "cells/model",
                "CellModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 240,
                "column": 68
            },
            "line": 240,
            "code": "      it('should return a base cell encapsulation of the model value', () => {\n        const cell: nbformat.IRawCell = {\n          id: '42',\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: { trusted: false }\n        };\n        const model = new TestModel({\n          sharedModel: createStandaloneCell(cell)\n        });\n        expect(model.toJSON()).not.toBe(cell);\n        expect(model.toJSON()).toEqual(cell);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should always return a string source",
            "suites": [
                "cells/model",
                "CellModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 46
            },
            "line": 254,
            "code": "      it('should always return a string source', () => {\n        const cell: nbformat.IRawCell = {\n          id: '42',\n          cell_type: 'raw',\n          source: ['foo\\n', 'bar\\n', 'baz'],\n          metadata: { trusted: false }\n        };\n        const model = new TestModel({\n          sharedModel: createStandaloneCell(cell)\n        });\n        cell.source = (cell.source as string[]).join('\\n');\n        expect(model.toJSON()).not.toBe(cell);\n        expect(model.toJSON()).toEqual(cell);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should handle a metadata for the cell",
            "suites": [
                "cells/model",
                "CellModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 271,
                "column": 47
            },
            "line": 271,
            "code": "      it('should handle a metadata for the cell', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        expect(model.getMetadata('foo')).toBeUndefined();\n        model.setMetadata('foo', 1);\n        expect(model.getMetadata('foo')).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should get a list of user metadata keys",
            "suites": [
                "cells/model",
                "CellModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 280,
                "column": 49
            },
            "line": 280,
            "code": "      it('should get a list of user metadata keys', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        expect(Array.from(Object.keys(model.metadata))).toHaveLength(0);\n        model.setMetadata('foo', 1);\n        expect(Object.keys(model.metadata)).toEqual(['foo']);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should trigger changed signal",
            "suites": [
                "cells/model",
                "CellModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 289,
                "column": 39
            },
            "line": 289,
            "code": "      it('should trigger changed signal', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        let called = false;\n        model.metadataChanged.connect(() => {\n          called = true;\n        });\n        model.setMetadata('foo', 1);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be set with type \"raw\"",
            "suites": [
                "cells/model",
                "RawCellModel",
                "#type"
            ],
            "updatePoint": {
                "line": 305,
                "column": 39
            },
            "line": 305,
            "code": "      it('should be set with type \"raw\"', () => {\n        const model = new RawCellModel();\n        expect(model.type).toBe('raw');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should return a raw cell encapsulation of the model value",
            "suites": [
                "cells/model",
                "RawCellModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 311,
                "column": 67
            },
            "line": 311,
            "code": "      it('should return a raw cell encapsulation of the model value', () => {\n        const cell: nbformat.IRawCell = {\n          cell_type: 'raw',\n          source: 'foo',\n          metadata: {},\n          id: 'cell_id'\n        };\n        const model = new RawCellModel({\n          sharedModel: createStandaloneCell(cell) as YRawCell\n        });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be set with type \"markdown\"",
            "suites": [
                "cells/model",
                "MarkdownCellModel",
                "#type"
            ],
            "updatePoint": {
                "line": 330,
                "column": 44
            },
            "line": 330,
            "code": "      it('should be set with type \"markdown\"', () => {\n        const model = new MarkdownCellModel();\n        expect(model.type).toBe('markdown');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should return a markdown cell encapsulation of the model value",
            "suites": [
                "cells/model",
                "MarkdownCellModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 336,
                "column": 72
            },
            "line": 336,
            "code": "      it('should return a markdown cell encapsulation of the model value', () => {\n        const cell: nbformat.IMarkdownCell = {\n          cell_type: 'markdown',\n          source: 'foo',\n          metadata: {},\n          id: 'cell_id'\n        };\n        const model = new MarkdownCellModel({\n          sharedModel: createStandaloneCell(cell) as YMarkdownCell\n        });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a code cell model",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 355,
                "column": 41
            },
            "line": 355,
            "code": "      it('should create a code cell model', () => {\n        const model = new CodeCellModel();\n        expect(model).toBeInstanceOf(CodeCellModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a code cell argument",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 360,
                "column": 44
            },
            "line": 360,
            "code": "      it('should accept a code cell argument', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [\n            {\n              output_type: 'display_data',\n              data: { 'text/plain': 'foo' },\n              metadata: {}\n            } as nbformat.IDisplayData\n          ],\n          source: 'foo',\n          metadata: { trusted: false }\n        }) as YCodeCell;\n        const model = new CodeCellModel({ sharedModel });\n        expect(model).toBeInstanceOf(CodeCellModel);\n        expect(model.sharedModel.getSource()).toBe('foo');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should connect the outputs changes to content change signal",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 379,
                "column": 69
            },
            "line": 379,
            "code": "      it('should connect the outputs changes to content change signal', () => {\n        const data = {\n          output_type: 'display_data',\n          data: { 'text/plain': 'foo' },\n          metadata: {}\n        } as nbformat.IDisplayData;\n        const model = new CodeCellModel();\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        expect(called).toBe(false);\n        model.outputs.add(data);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should sync collapsed and jupyter.outputs_hidden metadata on construction",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 395,
                "column": 83
            },
            "line": 395,
            "code": "      it('should sync collapsed and jupyter.outputs_hidden metadata on construction', () => {\n        let model: CodeCellModel;\n        let jupyter: JSONObject | undefined;\n\n        // Setting `collapsed` works\n        model = new CodeCellModel({\n          sharedModel: createStandaloneCell({\n            cell_type: 'code',\n            source: '',\n            metadata: { collapsed: true }\n          }) as YCodeCell\n        });\n        expect(model.getMetadata('collapsed')).toBe(true);\n        jupyter = model.getMetadata('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(true);\n\n        // Setting `jupyter.outputs_hidden` works\n        model = new CodeCellModel({\n          sharedModel: createStandaloneCell({\n            cell_type: 'code',\n            source: '',\n            metadata: { jupyter: { outputs_hidden: true } }\n          }) as YCodeCell\n        });\n        expect(model.getMetadata('collapsed')).toBe(true);\n        jupyter = model.getMetadata('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(true);\n\n        // `collapsed` takes precedence\n        model = new CodeCellModel({\n          sharedModel: createStandaloneCell({\n            cell_type: 'code',\n            source: '',\n            metadata: { collapsed: false, jupyter: { outputs_hidden: true } }\n          }) as YCodeCell\n        });\n        expect(model.getMetadata('collapsed')).toBe(false);\n        jupyter = model.getMetadata('jupyter') as JSONObject;\n        expect(jupyter.outputs_hidden).toBe(false);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be set with type \"code\"",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#type"
            ],
            "updatePoint": {
                "line": 438,
                "column": 40
            },
            "line": 438,
            "code": "      it('should be set with type \"code\"', () => {\n        const model = new CodeCellModel();\n        expect(model.type).toBe('code');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should show the execution count of the cell",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 445,
                "column": 53
            },
            "line": 445,
            "code": "      it('should show the execution count of the cell', () => {\n        const sharedModel = createStandaloneCell({\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [],\n          source: 'foo',\n          metadata: { trusted: false }\n        }) as YCodeCell;\n        const model = new CodeCellModel({ sharedModel });\n        expect(model.executionCount).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 457,
                "column": 28
            },
            "line": 457,
            "code": "      it('should be settable', () => {\n        const model = new CodeCellModel();\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should emit a state change signal when set",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 463,
                "column": 52
            },
            "line": 463,
            "code": "      it('should emit a state change signal when set', () => {\n        const model = new CodeCellModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        expect(called).toBe(false);\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should not signal when state has not changed",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 475,
                "column": 54
            },
            "line": 475,
            "code": "      it('should not signal when state has not changed', () => {\n        const model = new CodeCellModel();\n        let called = 0;\n        model.sharedModel.changed.connect((model, args) => {\n          if (args.executionCountChange) {\n            called++;\n          }\n        });\n        expect(called).toBe(0);\n        model.executionCount = 1;\n        expect(model.executionCount).toBe(1);\n        model.executionCount = 1;\n        expect(called).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should set dirty flag and signal",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#executionCount"
            ],
            "updatePoint": {
                "line": 490,
                "column": 42
            },
            "line": 490,
            "code": "      it('should set dirty flag and signal', () => {\n        const model = new CodeCellModel();\n        let called = 0;\n        model.stateChanged.connect((model, args) => {\n          if (args.name == 'isDirty') {\n            called++;\n          }\n        });\n        expect(model.executionCount).toBe(null);\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(0);\n\n        model.executionCount = 1;\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(0);\n\n        model.sharedModel.setSource('foo');\n        expect(model.isDirty).toBe(true);\n        expect(called).toBe(1);\n\n        model.executionCount = 2;\n        expect(model.isDirty).toBe(false);\n        expect(called).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be an output area model",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#outputs"
            ],
            "updatePoint": {
                "line": 517,
                "column": 40
            },
            "line": 517,
            "code": "      it('should be an output area model', () => {\n        const model = new CodeCellModel();\n        expect(model.outputs).toBeInstanceOf(OutputAreaModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources held by the model",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 524,
                "column": 59
            },
            "line": 524,
            "code": "      it('should dispose of the resources held by the model', () => {\n        const model = new CodeCellModel();\n        expect(model.outputs).toBeInstanceOf(OutputAreaModel);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n        expect(model.outputs).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 532,
                "column": 47
            },
            "line": 532,
            "code": "      it('should be safe to call multiple times', () => {\n        const model = new CodeCellModel();\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should return a code cell encapsulation of the model value",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 541,
                "column": 68
            },
            "line": 541,
            "code": "      it('should return a code cell encapsulation of the model value', () => {\n        const cell: nbformat.ICodeCell = {\n          cell_type: 'code',\n          execution_count: 1,\n          outputs: [\n            {\n              output_type: 'display_data',\n              data: {\n                'text/plain': 'foo',\n                'application/json': { bar: 1 }\n              },\n              metadata: {}\n            } as nbformat.IDisplayData\n          ],\n          source: 'foo',\n          metadata: { trusted: false },\n          id: 'cell_id'\n        };\n        const model = new CodeCellModel({\n          sharedModel: createStandaloneCell(cell) as ISharedCodeCell\n        });\n        const serialized = model.toJSON();\n        expect(serialized).not.toBe(cell);\n        expect(serialized).toEqual(cell);\n        const output = serialized.outputs[0] as any;\n        expect(output.data['application/json']['bar']).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should add new items correctly",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#onOutputsChange()"
            ],
            "updatePoint": {
                "line": 603,
                "column": 40
            },
            "line": 603,
            "code": "      it('should add new items correctly', () => {\n        const model = new CodeCellModel();\n        const sharedModel = model.sharedModel as YCodeCell;\n        expect(sharedModel.ymodel.get('outputs').length).toBe(0);\n\n        const newEvent0 = {\n          type: 'add',\n          newValues: [{ toJSON: () => output0 }],\n          oldValues: [],\n          oldIndex: -1,\n          newIndex: 0\n        } as any;\n        model['onOutputsChange'](null as any, newEvent0);\n        expect(sharedModel.ymodel.get('outputs').length).toBe(1);\n        expect(sharedModel.ymodel.get('outputs').get(0)).toEqual(output0);\n\n        const newEvent1 = {\n          type: 'add',\n          newValues: [{ toJSON: () => output1 }],\n          oldValues: [],\n          oldIndex: -1,\n          newIndex: 1\n        } as any;\n        model['onOutputsChange'](null as any, newEvent1);\n        expect(sharedModel.ymodel.get('outputs').length).toBe(2);\n        expect(sharedModel.ymodel.get('outputs').get(1)).toEqual(output1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should set new items correctly",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#onOutputsChange()"
            ],
            "updatePoint": {
                "line": 631,
                "column": 40
            },
            "line": 631,
            "code": "      it('should set new items correctly', () => {\n        const model = new CodeCellModel({\n          sharedModel: createStandaloneCell(cell) as ISharedCodeCell\n        });\n        const sharedModel = model.sharedModel as YCodeCell;\n        expect(sharedModel.ymodel.get('outputs').length).toBe(2);\n\n        const newEvent0 = {\n          type: 'set',\n          newValues: [{ toJSON: () => output2 }],\n          oldValues: [output0],\n          oldIndex: 0,\n          newIndex: 0\n        } as any;\n        model['onOutputsChange'](null as any, newEvent0);\n        expect(sharedModel.ymodel.get('outputs').length).toBe(2);\n        expect(sharedModel.ymodel.get('outputs').get(0)).toEqual(output2);\n        const newEvent1 = {\n          type: 'set',\n          newValues: [{ toJSON: () => output2 }],\n          oldValues: [output1],\n          oldIndex: 1,\n          newIndex: 1\n        } as any;\n        model['onOutputsChange'](null as any, newEvent1);\n        expect(sharedModel.ymodel.get('outputs').length).toBe(2);\n        expect(sharedModel.ymodel.get('outputs').get(1)).toEqual(output2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should remove items correctly",
            "suites": [
                "cells/model",
                "CodeCellModel",
                "#onOutputsChange()"
            ],
            "updatePoint": {
                "line": 660,
                "column": 39
            },
            "line": 660,
            "code": "      it('should remove items correctly', () => {\n        const model = new CodeCellModel({\n          sharedModel: createStandaloneCell(cell) as ISharedCodeCell\n        });\n        const sharedModel = model.sharedModel as YCodeCell;\n        expect(sharedModel.getOutputs().length).toBe(2);\n        const newEvent0 = {\n          type: 'remove',\n          newValues: [],\n          oldValues: [output0, output1],\n          oldIndex: 0,\n          newIndex: 0\n        } as any;\n        model['onOutputsChange'](null as any, newEvent0);\n        expect(sharedModel.ymodel.get('outputs').length).toBe(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should sync collapsed and jupyter.outputs_hidden metadata when changed",
            "suites": [
                "cells/model",
                "CodeCellModel",
                ".metadata"
            ],
            "updatePoint": {
                "line": 679,
                "column": 80
            },
            "line": 679,
            "code": "      it('should sync collapsed and jupyter.outputs_hidden metadata when changed', () => {\n        const cell = new CodeCellModel();\n\n        expect(cell.getMetadata('collapsed')).toBeUndefined();\n        expect(cell.getMetadata('jupyter')).toBeUndefined();\n\n        // Setting collapsed sets jupyter.outputs_hidden\n        cell.setMetadata('collapsed', true);\n        expect(cell.getMetadata('collapsed')).toBe(true);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: true\n        });\n\n        cell.setMetadata('collapsed', false);\n        expect(cell.getMetadata('collapsed')).toBe(false);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: false\n        });\n\n        cell.deleteMetadata('collapsed');\n        expect(cell.getMetadata('collapsed')).toBeUndefined();\n        expect(cell.getMetadata('jupyter')).toBeUndefined();\n\n        // Setting jupyter.outputs_hidden sets collapsed\n        cell.setMetadata('jupyter', { outputs_hidden: true });\n        expect(cell.getMetadata('collapsed')).toBe(true);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: true\n        });\n\n        cell.setMetadata('jupyter', { outputs_hidden: false });\n        expect(cell.getMetadata('collapsed')).toBe(false);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: false\n        });\n\n        cell.deleteMetadata('jupyter');\n        expect(cell.getMetadata('collapsed')).toBeUndefined();\n        expect(cell.getMetadata('jupyter')).toBeUndefined();\n\n        // Deleting jupyter.outputs_hidden preserves other jupyter fields\n        cell.setMetadata('jupyter', { outputs_hidden: true, other: true });\n        expect(cell.getMetadata('collapsed')).toBe(true);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: true,\n          other: true\n        });\n        cell.setMetadata('jupyter', { other: true });\n        expect(cell.getMetadata('collapsed')).toBeUndefined();\n        expect(cell.getMetadata('jupyter')).toEqual({\n          other: true\n        });\n\n        // Deleting collapsed preserves other jupyter fields\n        cell.setMetadata('jupyter', { outputs_hidden: true, other: true });\n        expect(cell.getMetadata('collapsed')).toBe(true);\n        expect(cell.getMetadata('jupyter')).toEqual({\n          outputs_hidden: true,\n          other: true\n        });\n        cell.deleteMetadata('collapsed');\n        expect(cell.getMetadata('collapsed')).toBeUndefined();\n        expect(cell.getMetadata('jupyter')).toEqual({\n          other: true\n        });\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new output area factory",
            "suites": [
                "cells/model",
                "CodeCellModel",
                ".ContentFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 749,
                "column": 51
            },
            "line": 749,
            "code": "        it('should create a new output area factory', () => {\n          const factory = new CodeCellModel.ContentFactory();\n          expect(factory).toBeInstanceOf(CodeCellModel.ContentFactory);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create an output area model",
            "suites": [
                "cells/model",
                "CodeCellModel",
                ".ContentFactory",
                "#createOutputArea()"
            ],
            "updatePoint": {
                "line": 756,
                "column": 46
            },
            "line": 756,
            "code": "        it('should create an output area model', () => {\n          const factory = new CodeCellModel.ContentFactory();\n          expect(factory.createOutputArea({ trusted: true })).toBeInstanceOf(\n            OutputAreaModel\n          );\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be an ContentFactory",
            "suites": [
                "cells/model",
                "CodeCellModel",
                ".defaultContentFactory"
            ],
            "updatePoint": {
                "line": 766,
                "column": 37
            },
            "line": 766,
            "code": "      it('should be an ContentFactory', () => {\n        expect(CodeCellModel.defaultContentFactory).toBeInstanceOf(\n          CodeCellModel.ContentFactory\n        );\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a base cell widget",
            "suites": [
                "cells/widget",
                "Cell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 113,
                "column": 42
            },
            "line": 113,
            "code": "      it('should create a base cell widget', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        expect(widget).toBeInstanceOf(Cell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a custom contentFactory",
            "suites": [
                "cells/widget",
                "Cell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 47
            },
            "line": 121,
            "code": "      it('should accept a custom contentFactory', () => {\n        const contentFactory = NBTestUtils.createBaseCellFactory();\n        const widget = new Cell({ model, contentFactory }).initializeState();\n        expect(widget).toBeInstanceOf(Cell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a custom editorConfig",
            "suites": [
                "cells/widget",
                "Cell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 45
            },
            "line": 127,
            "code": "      it('should accept a custom editorConfig', () => {\n        const editorConfig: Record<string, any> = {\n          matchBrackets: false\n        };\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          editorConfig,\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.editor!.getOption('matchBrackets')).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the model used by the widget",
            "suites": [
                "cells/widget",
                "Cell",
                "#model"
            ],
            "updatePoint": {
                "line": 142,
                "column": 48
            },
            "line": 142,
            "code": "      it('should be the model used by the widget', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.model).toEqual(model);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be a code editor widget",
            "suites": [
                "cells/widget",
                "Cell",
                "#editorWidget"
            ],
            "updatePoint": {
                "line": 156,
                "column": 40
            },
            "line": 156,
            "code": "      it('should be a code editor widget', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.editorWidget).toBeInstanceOf(CodeEditorWrapper);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be a cell editor",
            "suites": [
                "cells/widget",
                "Cell",
                "#editor"
            ],
            "updatePoint": {
                "line": 167,
                "column": 33
            },
            "line": 167,
            "code": "      it('should be a cell editor', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.editor!.uuid).toBeTruthy();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the input area for the cell",
            "suites": [
                "cells/widget",
                "Cell",
                "#inputArea"
            ],
            "updatePoint": {
                "line": 178,
                "column": 47
            },
            "line": 178,
            "code": "      it('should be the input area for the cell', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.inputArea).toBeInstanceOf(InputArea);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be a boolean",
            "suites": [
                "cells/widget",
                "Cell",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 189,
                "column": 29
            },
            "line": 189,
            "code": "      it('should be a boolean', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(typeof widget.readOnly).toEqual('boolean');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should default to false",
            "suites": [
                "cells/widget",
                "Cell",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 198,
                "column": 33
            },
            "line": 198,
            "code": "      it('should default to false', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "cells/widget",
                "Cell",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 207,
                "column": 28
            },
            "line": 207,
            "code": "      it('should be settable', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        widget.readOnly = true;\n        expect(widget.readOnly).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should ignore being set to the same value",
            "suites": [
                "cells/widget",
                "Cell",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 216,
                "column": 51
            },
            "line": 216,
            "code": "      it('should ignore being set to the same value', async () => {\n        const widget = new LogBaseCell().initializeState();\n        widget.readOnly = true;\n        widget.readOnly = true;\n        await framePromise();\n        expect(widget.methods).toEqual(['onUpdateRequest']);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should reflect model metadata",
            "suites": [
                "cells/widget",
                "Cell",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 224,
                "column": 39
            },
            "line": 224,
            "code": "      it('should reflect model metadata', () => {\n        model.setMetadata('editable', false);\n\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.readOnly).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the view state of the input being collapsed",
            "suites": [
                "cells/widget",
                "Cell",
                "#inputCollapsed"
            ],
            "updatePoint": {
                "line": 237,
                "column": 63
            },
            "line": 237,
            "code": "      it('should be the view state of the input being collapsed', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.inputHidden).toEqual(false);\n        widget.inputHidden = true;\n        expect(widget.inputHidden).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should load the editable state from the model",
            "suites": [
                "cells/widget",
                "Cell",
                "#loadEditableState()"
            ],
            "updatePoint": {
                "line": 246,
                "column": 55
            },
            "line": 246,
            "code": "      it('should load the editable state from the model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n\n        model.setMetadata('editable', false);\n        widget.loadEditableState();\n        expect(widget.readOnly).toEqual(true);\n\n        model.setMetadata('editable', true);\n        widget.loadEditableState();\n        expect(widget.readOnly).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should save the editable state to the model",
            "suites": [
                "cells/widget",
                "Cell",
                "#saveEditableState()"
            ],
            "updatePoint": {
                "line": 267,
                "column": 53
            },
            "line": 267,
            "code": "      it('should save the editable state to the model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.readOnly).toEqual(false);\n\n        widget.readOnly = true;\n        widget.saveEditableState();\n        expect(model.getMetadata('editable')).toEqual(false);\n\n        widget.readOnly = false;\n        widget.saveEditableState();\n        // Default values are not saved explicitly\n        expect(model.getMetadata('editable')).toEqual(undefined);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should control automatic syncing of editable state with model",
            "suites": [
                "cells/widget",
                "Cell",
                "#syncEditable"
            ],
            "updatePoint": {
                "line": 290,
                "column": 71
            },
            "line": 290,
            "code": "      it('should control automatic syncing of editable state with model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.syncEditable).toEqual(false);\n        expect(widget.readOnly).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.readOnly = true;\n        expect(model.getMetadata('editable')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.setMetadata('editable', true);\n        expect(widget.readOnly).toEqual(true);\n\n        widget.syncEditable = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.getMetadata('editable')).toEqual(undefined);\n        expect(widget.readOnly).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.readOnly = true;\n        expect(model.getMetadata('editable')).toEqual(false);\n\n        // Synced if setting metadata attribute\n        model.setMetadata('editable', true);\n        expect(widget.readOnly).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should load the input collapse state from the model",
            "suites": [
                "cells/widget",
                "Cell",
                "#loadCollapseState()"
            ],
            "updatePoint": {
                "line": 328,
                "column": 61
            },
            "line": 328,
            "code": "      it('should load the input collapse state from the model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.inputHidden).toEqual(false);\n\n        model.setMetadata('jupyter', { source_hidden: true });\n        widget.loadCollapseState();\n        expect(widget.inputHidden).toEqual(true);\n\n        model.setMetadata('jupyter', { source_hidden: false });\n        widget.loadCollapseState();\n        expect(widget.inputHidden).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should save the collapse state to the model",
            "suites": [
                "cells/widget",
                "Cell",
                "#saveCollapseState()"
            ],
            "updatePoint": {
                "line": 350,
                "column": 53
            },
            "line": 350,
            "code": "      it('should save the collapse state to the model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.inputHidden).toEqual(false);\n\n        widget.inputHidden = true;\n        widget.saveCollapseState();\n        expect(model.getMetadata('jupyter')).toEqual({\n          source_hidden: true\n        });\n\n        widget.inputHidden = false;\n        widget.saveCollapseState();\n        // Default values are not saved explicitly\n        expect(model.getMetadata('jupyter')).toEqual(undefined);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should control automatic syncing of collapse state with model",
            "suites": [
                "cells/widget",
                "Cell",
                "#syncCollapse"
            ],
            "updatePoint": {
                "line": 375,
                "column": 71
            },
            "line": 375,
            "code": "      it('should control automatic syncing of collapse state with model', () => {\n        const model = new TestModel({\n          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell\n        });\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model,\n          placeholder: false\n        }).initializeState();\n        expect(widget.syncCollapse).toEqual(false);\n        expect(widget.inputHidden).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.inputHidden = true;\n        expect(model.getMetadata('jupyter')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.setMetadata('jupyter', { source_hidden: false });\n        expect(widget.inputHidden).toEqual(true);\n\n        widget.syncCollapse = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.getMetadata('jupyter')).toEqual(undefined);\n        expect(widget.inputHidden).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.inputHidden = true;\n        expect(model.getMetadata('jupyter')).toEqual({\n          source_hidden: true\n        });\n\n        // Synced if setting metadata attribute\n        model.setMetadata('jupyter', {});\n        expect(widget.inputHidden).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should focus the cell editor",
            "suites": [
                "cells/widget",
                "Cell",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 415,
                "column": 38
            },
            "line": 415,
            "code": "      it('should focus the cell editor', async () => {\n        const widget = new LogBaseCell().initializeState();\n        Widget.attach(widget, document.body);\n        widget.activate();\n        await framePromise();\n        expect(widget.methods).toContain('onActivateRequest');\n        await framePromise();\n        expect(widget.editor!.hasFocus()).toEqual(true);\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should not throw an error (full test in input area)",
            "suites": [
                "cells/widget",
                "Cell",
                "#setPrompt()"
            ],
            "updatePoint": {
                "line": 428,
                "column": 61
            },
            "line": 428,
            "code": "      it('should not throw an error (full test in input area)', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        expect(() => {\n          widget.setPrompt('');\n        }).not.toThrow();\n        expect(() => {\n          widget.setPrompt('null');\n        }).not.toThrow();\n        expect(() => {\n          widget.setPrompt('test');\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "cells/widget",
                "Cell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 446,
                "column": 60
            },
            "line": 446,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "cells/widget",
                "Cell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 455,
                "column": 47
            },
            "line": 455,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = new Cell({\n          contentFactory: NBTestUtils.createBaseCellFactory(),\n          model\n        }).initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should run when widget is attached",
            "suites": [
                "cells/widget",
                "Cell",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 467,
                "column": 44
            },
            "line": 467,
            "code": "      it('should run when widget is attached', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.methods).not.toContain('onAfterAttach');\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toContain('onAfterAttach');\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should update the widget",
            "suites": [
                "cells/widget",
                "Cell",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 477,
                "column": 34
            },
            "line": 477,
            "code": "      it('should update the widget', () => {\n        const widget = new LogBaseCell().initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a ContentFactory",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 487,
                "column": 42
            },
            "line": 487,
            "code": "        it('should create a ContentFactory', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(Cell.ContentFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the editor factory used by the content factory",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#editorFactory"
            ],
            "updatePoint": {
                "line": 494,
                "column": 68
            },
            "line": 494,
            "code": "        it('should be the editor factory used by the content factory', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.editorFactory).toEqual(editorFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new cell header",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#createCellHeader()"
            ],
            "updatePoint": {
                "line": 501,
                "column": 43
            },
            "line": 501,
            "code": "        it('should create a new cell header', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.createCellHeader()).toBeInstanceOf(CellHeader);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new cell footer",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#createCellFooter()"
            ],
            "updatePoint": {
                "line": 508,
                "column": 43
            },
            "line": 508,
            "code": "        it('should create a new cell footer', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.createCellFooter()).toBeInstanceOf(CellFooter);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new output prompt",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#createOutputPrompt()"
            ],
            "updatePoint": {
                "line": 515,
                "column": 45
            },
            "line": 515,
            "code": "        it('should create a new output prompt', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.createOutputPrompt()).toBeInstanceOf(OutputPrompt);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new input prompt",
            "suites": [
                "cells/widget",
                "Cell",
                ".ContentFactory",
                "#createInputPrompt()"
            ],
            "updatePoint": {
                "line": 522,
                "column": 44
            },
            "line": 522,
            "code": "        it('should create a new input prompt', () => {\n          const factory = new Cell.ContentFactory({ editorFactory });\n          expect(factory.createInputPrompt()).toBeInstanceOf(InputPrompt);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a code cell widget",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 535,
                "column": 42
            },
            "line": 535,
            "code": "      it('should create a code cell widget', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(CodeCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a custom contentFactory",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 541,
                "column": 47
            },
            "line": 541,
            "code": "      it('should accept a custom contentFactory', () => {\n        const contentFactory = NBTestUtils.createCodeCellFactory();\n        const widget = new CodeCell({ model, contentFactory, rendermime });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(CodeCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the output area used by the cell",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#outputArea"
            ],
            "updatePoint": {
                "line": 550,
                "column": 52
            },
            "line": 550,
            "code": "      it('should be the output area used by the cell', () => {\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputArea).toBeInstanceOf(OutputArea);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should initialize from the model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#outputCollapsed"
            ],
            "updatePoint": {
                "line": 562,
                "column": 42
            },
            "line": 562,
            "code": "      it('should initialize from the model', () => {\n        const collapsedModel = new CodeCellModel();\n        let widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model: collapsedModel,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n\n        collapsedModel.setMetadata('collapsed', true);\n        widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model: collapsedModel,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(true);\n\n        collapsedModel.deleteMetadata('collapsed');\n        collapsedModel.setMetadata('jupyter', { outputs_hidden: true });\n        widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model: collapsedModel,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be the view state of the output being collapsed",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#outputCollapsed"
            ],
            "updatePoint": {
                "line": 592,
                "column": 64
            },
            "line": 592,
            "code": "      it('should be the view state of the output being collapsed', () => {\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n        widget.outputHidden = true;\n        expect(widget.outputHidden).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should initialize from the model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#outputsScrolled"
            ],
            "updatePoint": {
                "line": 606,
                "column": 42
            },
            "line": 606,
            "code": "      it('should initialize from the model', () => {\n        const model = new CodeCellModel();\n        let widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.setMetadata('scrolled', false);\n        widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.setMetadata('scrolled', 'auto');\n        widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.setMetadata('scrolled', true);\n        widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should load the output scrolled state from the model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#loadScrolledState()"
            ],
            "updatePoint": {
                "line": 646,
                "column": 62
            },
            "line": 646,
            "code": "      it('should load the output scrolled state from the model', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        model.setMetadata('scrolled', true);\n        widget.loadScrolledState();\n        expect(widget.outputsScrolled).toEqual(true);\n\n        model.setMetadata('scrolled', false);\n        widget.loadScrolledState();\n        expect(widget.outputsScrolled).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should save the collapse state to the model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#saveScrolledState()"
            ],
            "updatePoint": {
                "line": 667,
                "column": 53
            },
            "line": 667,
            "code": "      it('should save the collapse state to the model', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputsScrolled).toEqual(false);\n\n        widget.outputsScrolled = true;\n        widget.saveScrolledState();\n        expect(model.getMetadata('scrolled')).toEqual(true);\n\n        widget.outputsScrolled = false;\n        widget.saveScrolledState();\n        // Default values are not saved explicitly\n        expect(model.getMetadata('scrolled')).toEqual(undefined);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should control automatic syncing of scrolled state with model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#syncScrolled"
            ],
            "updatePoint": {
                "line": 689,
                "column": 71
            },
            "line": 689,
            "code": "      it('should control automatic syncing of scrolled state with model', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.syncScrolled).toEqual(false);\n        expect(widget.outputsScrolled).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.outputsScrolled = true;\n        expect(model.getMetadata('scrolled')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.setMetadata('scrolled', false);\n        expect(widget.outputsScrolled).toEqual(true);\n\n        widget.syncScrolled = true;\n\n        // Setting sync does an initial sync from model to view. This also sets\n        // the metadata to undefined if it is the default value.\n        expect(model.getMetadata('scrolled')).toEqual(undefined);\n        expect(widget.outputsScrolled).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.outputsScrolled = true;\n        expect(model.getMetadata('scrolled')).toEqual(true);\n\n        // Synced if setting metadata attribute\n        model.setMetadata('scrolled', false);\n        expect(widget.outputsScrolled).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should load the output collapse state from the model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#loadCollapseState()"
            ],
            "updatePoint": {
                "line": 726,
                "column": 62
            },
            "line": 726,
            "code": "      it('should load the output collapse state from the model', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(false);\n\n        model.setMetadata('collapsed', true);\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(true);\n\n        model.setMetadata('collapsed', false);\n        widget.loadCollapseState();\n        expect(widget.outputHidden).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should save the collapse state to the model `collapsed` metadata",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#saveCollapseState()"
            ],
            "updatePoint": {
                "line": 748,
                "column": 74
            },
            "line": 748,
            "code": "      it('should save the collapse state to the model `collapsed` metadata', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.outputHidden).toEqual(false);\n\n        widget.outputHidden = true;\n        widget.saveCollapseState();\n        expect(model.getMetadata('collapsed')).toEqual(true);\n\n        // Default values are not saved explicitly\n        widget.outputHidden = false;\n        widget.saveCollapseState();\n        expect(model.getMetadata('collapsed')).toEqual(undefined);\n\n        // Default values are explicitly deleted\n        model.setMetadata('collapsed', false);\n        widget.outputHidden = false;\n        widget.saveCollapseState();\n        expect(model.getMetadata('collapsed')).toEqual(undefined);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should control automatic syncing of collapse state with model",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#syncCollapse"
            ],
            "updatePoint": {
                "line": 776,
                "column": 71
            },
            "line": 776,
            "code": "      it('should control automatic syncing of collapse state with model', () => {\n        const model = new CodeCellModel();\n        const widget = new CodeCell({\n          contentFactory: NBTestUtils.createCodeCellFactory(),\n          model,\n          rendermime\n        });\n        widget.initializeState();\n        expect(widget.syncCollapse).toEqual(false);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Not synced if setting widget attribute\n        widget.outputHidden = true;\n        expect(model.getMetadata('collapsed')).toEqual(undefined);\n\n        // Not synced if setting metadata attribute\n        model.setMetadata('collapsed', false);\n        expect(widget.outputHidden).toEqual(true);\n\n        widget.syncCollapse = true;\n\n        // Setting sync does an initial sync from model to view.\n        expect(model.getMetadata('collapsed')).toEqual(undefined);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Synced if setting widget attribute\n        widget.outputHidden = true;\n        expect(model.getMetadata('collapsed')).toEqual(true);\n\n        // Synced if setting metadata attribute\n        model.setMetadata('collapsed', false);\n        expect(widget.outputHidden).toEqual(false);\n\n        // Synced if deleting collapsed metadata attribute\n        widget.outputHidden = true;\n        expect(model.getMetadata('collapsed')).toEqual(true);\n        model.deleteMetadata('collapsed');\n        expect(widget.outputHidden).toEqual(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 818,
                "column": 60
            },
            "line": 818,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 825,
                "column": 47
            },
            "line": 825,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = new CodeCell({ model, rendermime, contentFactory });\n        widget.initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should update the widget",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 835,
                "column": 34
            },
            "line": 835,
            "code": "      it('should update the widget', () => {\n        const widget = new LogCodeCell().initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should fire when model metadata changes",
            "suites": [
                "cells/widget",
                "CodeCell",
                "#onMetadataChanged()"
            ],
            "updatePoint": {
                "line": 844,
                "column": 49
            },
            "line": 844,
            "code": "      it('should fire when model metadata changes', () => {\n        const method = 'onMetadataChanged';\n        const widget = new LogCodeCell().initializeState();\n        expect(widget.methods).not.toContain(method);\n        widget.model.setMetadata('foo', 1);\n        expect(widget.methods).toContain(method);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should fulfill a promise if there is no code to execute",
            "suites": [
                "cells/widget",
                "CodeCell",
                ".execute()"
            ],
            "updatePoint": {
                "line": 876,
                "column": 65
            },
            "line": 876,
            "code": "      it('should fulfill a promise if there is no code to execute', async () => {\n        const widget = new CodeCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        await expect(\n          CodeCell.execute(widget, sessionContext)\n        ).resolves.not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should fulfill a promise if there is code to execute",
            "suites": [
                "cells/widget",
                "CodeCell",
                ".execute()"
            ],
            "updatePoint": {
                "line": 889,
                "column": 62
            },
            "line": 889,
            "code": "      it('should fulfill a promise if there is code to execute', async () => {\n        const widget = new CodeCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        let originalCount: number;\n        widget.model.sharedModel.setSource('foo');\n        originalCount = widget.model.executionCount!;\n        await CodeCell.execute(widget, sessionContext);\n        const executionCount = widget.model.executionCount;\n        expect(executionCount).not.toEqual(originalCount);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should not save timing info by default",
            "suites": [
                "cells/widget",
                "CodeCell",
                ".execute()"
            ],
            "updatePoint": {
                "line": 913,
                "column": 48
            },
            "line": 913,
            "code": "      it('should not save timing info by default', async () => {\n        const widget = new CodeCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        await CodeCell.execute(widget, sessionContext);\n        expect(widget.model.getMetadata('execution')).toBeUndefined();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should save timing info if requested",
            "suites": [
                "cells/widget",
                "CodeCell",
                ".execute()"
            ],
            "updatePoint": {
                "line": 923,
                "column": 46
            },
            "line": 923,
            "code": "      it('should save timing info if requested', async () => {\n        const widget = new CodeCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        await CodeCell.execute(widget, sessionContext, { recordTiming: true });\n        expect(widget.model.getMetadata('execution')).toBeDefined();\n        const timingInfo = widget.model.getMetadata('execution') as any;\n        for (const key of TIMING_KEYS) {\n          expect(timingInfo[key]).toBeDefined();\n        }\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should set the cell prompt properly while executing",
            "suites": [
                "cells/widget",
                "CodeCell",
                ".execute()"
            ],
            "updatePoint": {
                "line": 938,
                "column": 61
            },
            "line": 938,
            "code": "      it('should set the cell prompt properly while executing', async () => {\n        const widget = new CodeCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        widget.model.sharedModel.setSource('foo');\n        const future1 = CodeCell.execute(widget, sessionContext);\n        expect(widget.promptNode!.textContent).toEqual('[*]:');\n        const future2 = CodeCell.execute(widget, sessionContext);\n        expect(widget.promptNode!.textContent).toEqual('[*]:');\n        await expect(future1).rejects.toThrow('Canceled');\n        expect(widget.promptNode!.textContent).toEqual('[*]:');\n        const msg = await future2;\n        expect(msg).not.toBeUndefined();\n\n        expect(widget.promptNode!.textContent).toEqual(\n          `[${(msg as IExecuteReplyMsg).content.execution_count}]:`\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a markdown cell widget",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 967,
                "column": 46
            },
            "line": 967,
            "code": "      it('should create a markdown cell widget', () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(MarkdownCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should accept a custom contentFactory",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 978,
                "column": 47
            },
            "line": 978,
            "code": "      it('should accept a custom contentFactory', () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        expect(widget).toBeInstanceOf(MarkdownCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should set the default mimetype to text/x-ipythongfm",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 989,
                "column": 62
            },
            "line": 989,
            "code": "      it('should set the default mimetype to text/x-ipythongfm', () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        expect(widget.model.mimeType).toEqual('text/x-ipythongfm');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should default to true",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#rendered"
            ],
            "updatePoint": {
                "line": 1002,
                "column": 32
            },
            "line": 1002,
            "code": "      it('should default to true', async () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        Widget.attach(widget, document.body);\n        expect(widget.rendered).toEqual(true);\n        await framePromise();\n        expect(widget.node.classList.contains(RENDERED_CLASS)).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should unrender the widget",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#rendered"
            ],
            "updatePoint": {
                "line": 1016,
                "column": 36
            },
            "line": 1016,
            "code": "      it('should unrender the widget', async () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        Widget.attach(widget, document.body);\n        widget.rendered = false;\n        await signalToPromise(widget.renderedChanged);\n        await framePromise();\n        expect(widget.node.classList.contains(RENDERED_CLASS)).toEqual(false);\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 1034,
                "column": 60
            },
            "line": 1034,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 1046,
                "column": 47
            },
            "line": 1046,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = new MarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        });\n        widget.initializeState();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toEqual(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should update the widget",
            "suites": [
                "cells/widget",
                "MarkdownCell",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1061,
                "column": 34
            },
            "line": 1061,
            "code": "      it('should update the widget', () => {\n        const widget = new LogMarkdownCell({\n          model,\n          rendermime,\n          contentFactory,\n          placeholder: false\n        }).initializeState();\n        expect(widget.methods).not.toContain('onUpdateRequest');\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a raw cell widget",
            "suites": [
                "cells/widget",
                "RawCell",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 1079,
                "column": 41
            },
            "line": 1079,
            "code": "      it('should create a raw cell widget', () => {\n        const model = new RawCellModel();\n        const widget = new RawCell({\n          model,\n          contentFactory,\n          placeholder: false\n        }).initializeState();\n        expect(widget).toBeInstanceOf(RawCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new cell header",
            "suites": [
                "cells/widget",
                "CellHeader",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 1093,
                "column": 41
            },
            "line": 1093,
            "code": "      it('should create a new cell header', () => {\n        expect(new CellHeader()).toBeInstanceOf(CellHeader);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a new cell footer",
            "suites": [
                "cells/widget",
                "CellFooter",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 1101,
                "column": 41
            },
            "line": 1101,
            "code": "      it('should create a new cell footer', () => {\n        expect(new CellFooter()).toBeInstanceOf(CellFooter);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/cells/test"
        },
        {
            "name": "should create a CodeEditor Model",
            "suites": [
                "CodeEditor.Model",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 20,
                "column": 40
            },
            "line": 20,
            "code": "    it('should create a CodeEditor Model', () => {\n      expect(model).toBeInstanceOf(CodeEditor.Model);\n      expect(model.sharedModel.getSource()).toBe('');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should create a CodeEditor Model with an initial value",
            "suites": [
                "CodeEditor.Model",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 62
            },
            "line": 25,
            "code": "    it('should create a CodeEditor Model with an initial value', () => {\n      const sharedEditorModel = new YFile();\n      sharedEditorModel.setSource('Initial text here');\n      const other = new CodeEditor.Model({ sharedModel: sharedEditorModel });\n      expect(other).toBeInstanceOf(CodeEditor.Model);\n      expect(other.sharedModel.getSource()).toBe('Initial text here');\n      other.dispose();\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should create a CodeEditor Model with an initial mimetype",
            "suites": [
                "CodeEditor.Model",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 34,
                "column": 65
            },
            "line": 34,
            "code": "    it('should create a CodeEditor Model with an initial mimetype', () => {\n      const sharedEditorModel = new YFile();\n      sharedEditorModel.setSource('import this');\n      const other = new CodeEditor.Model({\n        sharedModel: sharedEditorModel,\n        mimeType: 'text/x-python'\n      });\n      expect(other).toBeInstanceOf(CodeEditor.Model);\n      expect(other.mimeType).toBe('text/x-python');\n      expect(other.sharedModel.getSource()).toBe('import this');\n      other.dispose();\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be emitted when the mime type changes",
            "suites": [
                "CodeEditor.Model",
                "#mimeTypeChanged"
            ],
            "updatePoint": {
                "line": 49,
                "column": 52
            },
            "line": 49,
            "code": "    it('should be emitted when the mime type changes', () => {\n      let called = false;\n      model.mimeTypeChanged.connect((sender, args) => {\n        expect(sender).toBe(model);\n        expect(args.oldValue).toBe('text/plain');\n        expect(args.newValue).toBe('text/foo');\n        called = true;\n      });\n      model.mimeType = 'text/foo';\n      expect(called).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the observable value of the model",
            "suites": [
                "CodeEditor.Model",
                "#value"
            ],
            "updatePoint": {
                "line": 63,
                "column": 51
            },
            "line": 63,
            "code": "    it('should be the observable value of the model', () => {\n      let called = false;\n      const handler = (sender: ISharedText, args: SourceChange) => {\n        expect(sender).toBe(model.sharedModel);\n        expect(args.sourceChange).toEqual([{ insert: 'foo' }]);\n        called = true;\n      };\n      model.sharedModel.changed.connect(handler);\n      model.sharedModel.setSource('foo');\n      expect(called).toBe(true);\n      model.sharedModel.changed.disconnect(handler);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle an insert",
            "suites": [
                "CodeEditor.Model",
                "#value"
            ],
            "updatePoint": {
                "line": 76,
                "column": 31
            },
            "line": 76,
            "code": "    it('should handle an insert', () => {\n      let called = false;\n      const handler = (sender: ISharedText, args: SourceChange) => {\n        expect(args.sourceChange).toEqual([{ insert: 'foo' }]);\n        called = true;\n      };\n      model.sharedModel.changed.connect(handler);\n      model.sharedModel.updateSource(0, 0, 'foo');\n      expect(called).toBe(true);\n      model.sharedModel.changed.disconnect(handler);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle a remove",
            "suites": [
                "CodeEditor.Model",
                "#value"
            ],
            "updatePoint": {
                "line": 88,
                "column": 30
            },
            "line": 88,
            "code": "    it('should handle a remove', () => {\n      let called = false;\n      model.sharedModel.setSource('foo');\n      const handler = (sender: ISharedText, args: SourceChange) => {\n        expect(args.sourceChange).toEqual([{ delete: 1 }]);\n        called = true;\n      };\n      model.sharedModel.changed.connect(handler);\n      model.sharedModel.updateSource(0, 1);\n      expect(called).toBe(true);\n      model.sharedModel.changed.disconnect(handler);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the selections associated with the model",
            "suites": [
                "CodeEditor.Model",
                "#selections"
            ],
            "updatePoint": {
                "line": 103,
                "column": 58
            },
            "line": 103,
            "code": "    it('should be the selections associated with the model', () => {\n      expect(model.selections.keys().length).toBe(0);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the mime type of the model",
            "suites": [
                "CodeEditor.Model",
                "#mimeType"
            ],
            "updatePoint": {
                "line": 109,
                "column": 44
            },
            "line": 109,
            "code": "    it('should be the mime type of the model', () => {\n      expect(model.mimeType).toBe('text/plain');\n      model.mimeType = 'text/foo';\n      expect(model.mimeType).toBe('text/foo');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should test whether the model is disposed",
            "suites": [
                "CodeEditor.Model",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 117,
                "column": 49
            },
            "line": 117,
            "code": "    it('should test whether the model is disposed', () => {\n      expect(model.isDisposed).toBe(false);\n      model.dispose();\n      expect(model.isDisposed).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should create a new metadata editor",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#constructor"
            ],
            "updatePoint": {
                "line": 68,
                "column": 45
            },
            "line": 68,
            "code": "      it('should create a new metadata editor', () => {\n        const newEditor = new JSONEditor({ editorFactory });\n        expect(newEditor).toBeInstanceOf(JSONEditor);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the header node used by the editor",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#headerNode"
            ],
            "updatePoint": {
                "line": 75,
                "column": 54
            },
            "line": 75,
            "code": "      it('should be the header node used by the editor', () => {\n        expect(Array.from(editor.headerNode.classList)).toEqual(\n          expect.arrayContaining(['jp-JSONEditor-header'])\n        );\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the editor host node used by the editor",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#editorHostNode"
            ],
            "updatePoint": {
                "line": 83,
                "column": 59
            },
            "line": 83,
            "code": "      it('should be the editor host node used by the editor', () => {\n        expect(Array.from(editor.editorHostNode.classList)).toEqual(\n          expect.arrayContaining(['jp-JSONEditor-host'])\n        );\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the revert button node used by the editor",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#revertButtonNode"
            ],
            "updatePoint": {
                "line": 91,
                "column": 61
            },
            "line": 91,
            "code": "      it('should be the revert button node used by the editor', () => {\n        expect(\n          editor.revertButtonNode.querySelector(\"[data-icon$='undo']\")\n        ).toBeDefined();\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the commit button node used by the editor",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#commitButtonNode"
            ],
            "updatePoint": {
                "line": 99,
                "column": 61
            },
            "line": 99,
            "code": "      it('should be the commit button node used by the editor', () => {\n        expect(\n          editor.commitButtonNode.querySelector(\"[data-icon$='check']\")\n        ).toBeDefined();\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be the source of the metadata",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source"
            ],
            "updatePoint": {
                "line": 107,
                "column": 46
            },
            "line": 107,
            "code": "      it('should be the source of the metadata', () => {\n        expect(editor.source).toBe(null);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source"
            ],
            "updatePoint": {
                "line": 111,
                "column": 28
            },
            "line": 111,
            "code": "      it('should be settable', () => {\n        const source = new ObservableJSON();\n        editor.source = source;\n        expect(editor.source).toBe(source);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should update the text area value",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source"
            ],
            "updatePoint": {
                "line": 117,
                "column": 43
            },
            "line": 117,
            "code": "      it('should update the text area value', () => {\n        const model = editor.model;\n        expect(model.sharedModel.getSource()).toBe('');\n        editor.source = new ObservableJSON();\n        expect(model.sharedModel.getSource()).toBe('{}');\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should test whether the editor value is dirty",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#isDirty"
            ],
            "updatePoint": {
                "line": 126,
                "column": 55
            },
            "line": 126,
            "code": "      it('should test whether the editor value is dirty', () => {\n        expect(editor.isDirty).toBe(false);\n        Widget.attach(editor, document.body);\n        editor.model.sharedModel.setSource('a');\n        expect(editor.isDirty).toBe(true);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should be dirty if the value changes while focused",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#isDirty"
            ],
            "updatePoint": {
                "line": 133,
                "column": 60
            },
            "line": 133,
            "code": "      it('should be dirty if the value changes while focused', () => {\n        editor.source = new ObservableJSON();\n        Widget.attach(editor, document.body);\n        editor.editor.focus();\n        expect(editor.isDirty).toBe(false);\n        editor.source.set('foo', 1);\n        expect(editor.isDirty).toBe(true);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should not be set if not focused",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#isDirty"
            ],
            "updatePoint": {
                "line": 142,
                "column": 42
            },
            "line": 142,
            "code": "      it('should not be set if not focused', () => {\n        editor.source = new ObservableJSON();\n        Widget.attach(editor, document.body);\n        expect(editor.isDirty).toBe(false);\n        editor.source.set('foo', 1);\n        expect(editor.isDirty).toBe(false);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should add the error flag if invalid JSON",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "model.value.changed"
            ],
            "updatePoint": {
                "line": 152,
                "column": 51
            },
            "line": 152,
            "code": "      it('should add the error flag if invalid JSON', () => {\n        editor.model.sharedModel.setSource('foo');\n        expect(editor.hasClass('jp-mod-error')).toBe(true);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should show the commit button if the value has changed",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "model.value.changed"
            ],
            "updatePoint": {
                "line": 157,
                "column": 64
            },
            "line": 157,
            "code": "      it('should show the commit button if the value has changed', () => {\n        editor.model.sharedModel.setSource('{\"foo\": 2}');\n        editor.model.sharedModel.setSource('{\"foo\": 1}');\n        expect(editor.commitButtonNode.hidden).toBe(false);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should not show the commit button if the value is invalid",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "model.value.changed"
            ],
            "updatePoint": {
                "line": 163,
                "column": 67
            },
            "line": 163,
            "code": "      it('should not show the commit button if the value is invalid', () => {\n        editor.model.sharedModel.setSource('foo');\n        expect(editor.commitButtonNode.hidden).toBe(true);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should show the revert button if the value has changed",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "model.value.changed"
            ],
            "updatePoint": {
                "line": 168,
                "column": 64
            },
            "line": 168,
            "code": "      it('should show the revert button if the value has changed', () => {\n        editor.model.sharedModel.setSource('foo');\n        expect(editor.revertButtonNode.hidden).toBe(false);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle blur events on the host node",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "blur"
            ],
            "updatePoint": {
                "line": 180,
                "column": 54
            },
            "line": 180,
            "code": "        it('should handle blur events on the host node', () => {\n          editor.editor.focus();\n          simulate(editor.editorHostNode, 'blur');\n          expect(editor.events).toEqual(expect.arrayContaining(['blur']));\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should revert to current data if there was no change",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "blur"
            ],
            "updatePoint": {
                "line": 186,
                "column": 64
            },
            "line": 186,
            "code": "        it('should revert to current data if there was no change', () => {\n          editor.source = new ObservableJSON();\n          editor.editor.focus();\n          editor.source.set('foo', 1);\n          const model = editor.model;\n          expect(model.sharedModel.getSource()).toBe('{}');\n          simulate(editor.editorHostNode, 'blur');\n          expect(model.sharedModel.getSource()).toBe('{\\n    \"foo\": 1\\n}');\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should not revert to current data if there was a change",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "blur"
            ],
            "updatePoint": {
                "line": 196,
                "column": 67
            },
            "line": 196,
            "code": "        it('should not revert to current data if there was a change', () => {\n          editor.source = new ObservableJSON();\n          editor.model.sharedModel.setSource('foo');\n          editor.source.set('foo', 1);\n          const model = editor.model;\n          expect(model.sharedModel.getSource()).toBe('foo');\n          simulate(editor.editorHostNode, 'blur');\n          expect(model.sharedModel.getSource()).toBe('foo');\n          expect(editor.commitButtonNode.hidden).toBe(true);\n          expect(editor.revertButtonNode.hidden).toBe(false);\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle click events on the revert button",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 210,
                "column": 59
            },
            "line": 210,
            "code": "        it('should handle click events on the revert button', () => {\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.events).toEqual(expect.arrayContaining(['click']));\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should revert the current data",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 215,
                "column": 42
            },
            "line": 215,
            "code": "        it('should revert the current data', () => {\n          editor.source = new ObservableJSON();\n          editor.model.sharedModel.setSource('foo');\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe('{}');\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle programmatic changes",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 222,
                "column": 46
            },
            "line": 222,
            "code": "        it('should handle programmatic changes', () => {\n          editor.source = new ObservableJSON();\n          editor.model.sharedModel.setSource('foo');\n          editor.source.set('foo', 1);\n          simulate(editor.revertButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe(\n            '{\\n    \"foo\": 1\\n}'\n          );\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should handle click events on the commit button",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 232,
                "column": 59
            },
            "line": 232,
            "code": "        it('should handle click events on the commit button', () => {\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.events).toEqual(expect.arrayContaining(['click']));\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should bail if it is not valid JSON",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 237,
                "column": 47
            },
            "line": 237,
            "code": "        it('should bail if it is not valid JSON', () => {\n          editor.source = new ObservableJSON();\n          editor.model.sharedModel.setSource('foo');\n          editor.source.set('foo', 1);\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe('foo');\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should override a key that was set programmatically",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 245,
                "column": 63
            },
            "line": 245,
            "code": "        it('should override a key that was set programmatically', () => {\n          editor.source = new ObservableJSON();\n          editor.model.sharedModel.setSource('{\"foo\": 2}');\n          editor.source.set('foo', 1);\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe(\n            '{\\n    \"foo\": 2\\n}'\n          );\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should allow a programmatic key to update",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 255,
                "column": 53
            },
            "line": 255,
            "code": "        it('should allow a programmatic key to update', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.sharedModel.setSource('{\"foo\":1, \"bar\": 2}');\n          editor.source.set('foo', 2);\n          simulate(editor.commitButtonNode, 'click');\n          const expected = '{\\n    \"foo\": 2,\\n    \"bar\": 2\\n}';\n          expect(editor.model.sharedModel.getSource()).toBe(expected);\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should allow a key to be added by the user",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 266,
                "column": 54
            },
            "line": 266,
            "code": "        it('should allow a key to be added by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.sharedModel.setSource('{\"foo\":1, \"bar\": 2, \"baz\": 3}');\n          editor.source.set('foo', 2);\n          simulate(editor.commitButtonNode, 'click');\n          const value = '{\\n    \"foo\": 2,\\n    \"bar\": 2,\\n    \"baz\": 3\\n}';\n          expect(editor.model.sharedModel.getSource()).toBe(value);\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should allow a key to be removed by the user",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 277,
                "column": 56
            },
            "line": 277,
            "code": "        it('should allow a key to be removed by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.sharedModel.setSource('{\"foo\": 1}');\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe(\n            '{\\n    \"foo\": 1\\n}'\n          );\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should allow a key to be removed programmatically that was not set by the user",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 288,
                "column": 90
            },
            "line": 288,
            "code": "        it('should allow a key to be removed programmatically that was not set by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.sharedModel.setSource('{\"foo\": 1, \"bar\": 3}');\n          editor.source.delete('foo');\n          simulate(editor.commitButtonNode, 'click');\n          expect(editor.model.sharedModel.getSource()).toBe(\n            '{\\n    \"bar\": 3\\n}'\n          );\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should keep a key that was removed programmatically that was changed by the user",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 300,
                "column": 92
            },
            "line": 300,
            "code": "        it('should keep a key that was removed programmatically that was changed by the user', () => {\n          editor.source = new ObservableJSON();\n          editor.source.set('foo', 1);\n          editor.source.set('bar', 1);\n          editor.model.sharedModel.setSource('{\"foo\": 2, \"bar\": 3}');\n          editor.source.set('foo', null);\n          simulate(editor.commitButtonNode, 'click');\n          const expected = '{\\n    \"foo\": 2,\\n    \"bar\": 3\\n}';\n          expect(editor.model.sharedModel.getSource()).toBe(expected);\n        });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should add event listeners",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 314,
                "column": 36
            },
            "line": 314,
            "code": "      it('should add event listeners', () => {\n        Widget.attach(editor, document.body);\n        expect(editor.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        editor.editor.focus();\n        simulate(editor.editorHostNode, 'blur');\n        simulate(editor.revertButtonNode, 'click');\n        simulate(editor.commitButtonNode, 'click');\n        expect(editor.events).toEqual(['blur', 'click', 'click']);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should remove event listeners",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#onBeforeDetach()"
            ],
            "updatePoint": {
                "line": 328,
                "column": 39
            },
            "line": 328,
            "code": "      it('should remove event listeners', () => {\n        Widget.attach(editor, document.body);\n        Widget.detach(editor);\n        expect(editor.methods).toEqual(\n          expect.arrayContaining(['onBeforeDetach'])\n        );\n        editor.editor.focus();\n        simulate(editor.editorHostNode, 'blur');\n        simulate(editor.revertButtonNode, 'click');\n        simulate(editor.commitButtonNode, 'click');\n        expect(editor.events).toEqual([]);\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should update the value",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source.changed"
            ],
            "updatePoint": {
                "line": 343,
                "column": 33
            },
            "line": 343,
            "code": "      it('should update the value', () => {\n        editor.source = new ObservableJSON();\n        editor.source.set('foo', 1);\n        expect(editor.model.sharedModel.getSource()).toBe('{\\n    \"foo\": 1\\n}');\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should bail if the input is dirty",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source.changed"
            ],
            "updatePoint": {
                "line": 349,
                "column": 43
            },
            "line": 349,
            "code": "      it('should bail if the input is dirty', () => {\n        Widget.attach(editor, document.body);\n        editor.source = new ObservableJSON();\n        editor.model.sharedModel.setSource('ha');\n        editor.source.set('foo', 2);\n        expect(editor.model.sharedModel.getSource()).toBe('ha');\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should bail if the input is focused",
            "suites": [
                "codeeditor",
                "JSONEditor",
                "#source.changed"
            ],
            "updatePoint": {
                "line": 357,
                "column": 45
            },
            "line": 357,
            "code": "      it('should bail if the input is focused', () => {\n        Widget.attach(editor, document.body);\n        editor.model.sharedModel.setSource('{}');\n        editor.source = new ObservableJSON();\n        editor.editor.focus();\n        editor.source.set('foo', 2);\n        expect(editor.model.sharedModel.getSource()).toBe('{}');\n      });",
            "file": "jsoneditor.spec.ts",
            "skipped": false,
            "dir": "packages/codeeditor/test"
        },
        {
            "name": "should create a CodeMirrorEditor",
            "suites": [
                "CodeMirrorEditor",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 40
            },
            "line": 76,
            "code": "    it('should create a CodeMirrorEditor', () => {\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should emit a signal when the top edge is requested",
            "suites": [
                "CodeMirrorEditor",
                "#edgeRequested"
            ],
            "updatePoint": {
                "line": 82,
                "column": 59
            },
            "line": 82,
            "code": "    it('should emit a signal when the top edge is requested', () => {\n      let edge: CodeEditor.EdgeLocation | null = null;\n      const event = generate('keydown', { keyCode: UP_ARROW });\n      const listener = (sender: any, args: CodeEditor.EdgeLocation) => {\n        edge = args;\n      };\n      editor.edgeRequested.connect(listener);\n      expect(edge).toBeNull();\n      editor.editor.contentDOM.dispatchEvent(event);\n      expect(edge).toBe('top');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should emit a signal when the bottom edge is requested",
            "suites": [
                "CodeMirrorEditor",
                "#edgeRequested"
            ],
            "updatePoint": {
                "line": 94,
                "column": 62
            },
            "line": 94,
            "code": "    it('should emit a signal when the bottom edge is requested', () => {\n      let edge: CodeEditor.EdgeLocation | null = null;\n      const event = generate('keydown', { keyCode: DOWN_ARROW });\n      const listener = (sender: any, args: CodeEditor.EdgeLocation) => {\n        edge = args;\n      };\n      editor.edgeRequested.connect(listener);\n      expect(edge).toBeNull();\n      editor.editor.contentDOM.dispatchEvent(event);\n      expect(edge).toBe('bottom');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be the unique id of the editor",
            "suites": [
                "CodeMirrorEditor",
                "#uuid"
            ],
            "updatePoint": {
                "line": 108,
                "column": 45
            },
            "line": 108,
            "code": "    it('should be the unique id of the editor', () => {\n      expect(editor.uuid).toBeTruthy();\n      const uuid = 'foo';\n      editor = new LogFileEditor({\n        extensionsRegistry,\n        model,\n        host,\n        uuid,\n        languages\n      });\n      expect(editor.uuid).toBe('foo');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be the codemirror editor wrapped by the editor",
            "suites": [
                "CodeMirrorEditor",
                "#editor"
            ],
            "updatePoint": {
                "line": 123,
                "column": 61
            },
            "line": 123,
            "code": "    it('should be the codemirror editor wrapped by the editor', () => {\n      const cm = editor.editor;\n      expect(cm.state.doc).toBe(editor.doc);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the number of lines in the editor",
            "suites": [
                "CodeMirrorEditor",
                "#lineCount"
            ],
            "updatePoint": {
                "line": 130,
                "column": 52
            },
            "line": 130,
            "code": "    it('should get the number of lines in the editor', () => {\n      expect(editor.lineCount).toBe(1);\n      editor.model.sharedModel.setSource('foo\\nbar\\nbaz');\n      expect(editor.lineCount).toBe(3);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get whether line numbers should be shown",
            "suites": [
                "CodeMirrorEditor",
                "#getOption()"
            ],
            "updatePoint": {
                "line": 138,
                "column": 55
            },
            "line": 138,
            "code": "    it('should get whether line numbers should be shown', () => {\n      expect(editor.getOption('lineNumbers')).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get whether horizontally scrolling should be used",
            "suites": [
                "CodeMirrorEditor",
                "#getOption()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 64
            },
            "line": 142,
            "code": "    it('should get whether horizontally scrolling should be used', () => {\n      expect(editor.getOption('lineWrap')).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get whether the editor is readonly",
            "suites": [
                "CodeMirrorEditor",
                "#getOption()"
            ],
            "updatePoint": {
                "line": 146,
                "column": 49
            },
            "line": 146,
            "code": "    it('should get whether the editor is readonly', () => {\n      expect(editor.getOption('readOnly')).toBe(false);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set whether line numbers should be shown",
            "suites": [
                "CodeMirrorEditor",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 152,
                "column": 55
            },
            "line": 152,
            "code": "    it('should set whether line numbers should be shown', () => {\n      editor.setOption('lineNumbers', false);\n      expect(editor.getOption('lineNumbers')).toBe(false);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set whether horizontally scrolling should be used",
            "suites": [
                "CodeMirrorEditor",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 157,
                "column": 64
            },
            "line": 157,
            "code": "    it('should set whether horizontally scrolling should be used', () => {\n      editor.setOption('lineWrap', false);\n      expect(editor.getOption('lineWrap')).toBe(false);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set whether the editor is readonly",
            "suites": [
                "CodeMirrorEditor",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 162,
                "column": 49
            },
            "line": 162,
            "code": "    it('should set whether the editor is readonly', () => {\n      editor.setOption('readOnly', true);\n      expect(editor.getOption('readOnly')).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the model used by the editor",
            "suites": [
                "CodeMirrorEditor",
                "#model"
            ],
            "updatePoint": {
                "line": 169,
                "column": 47
            },
            "line": 169,
            "code": "    it('should get the model used by the editor', () => {\n      expect(editor.model).toBe(model);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the text height of a line in the editor",
            "suites": [
                "CodeMirrorEditor",
                "#lineHeight"
            ],
            "updatePoint": {
                "line": 175,
                "column": 58
            },
            "line": 175,
            "code": "    it('should get the text height of a line in the editor', () => {\n      expect(editor.lineHeight).toBeGreaterThan(0);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the character width in the editor",
            "suites": [
                "CodeMirrorEditor",
                "#charWidth"
            ],
            "updatePoint": {
                "line": 181,
                "column": 52
            },
            "line": 181,
            "code": "    it('should get the character width in the editor', () => {\n      expect(editor.charWidth).toBeGreaterThan(0);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should test whether the editor is disposed",
            "suites": [
                "CodeMirrorEditor",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 187,
                "column": 50
            },
            "line": 187,
            "code": "    it('should test whether the editor is disposed', () => {\n      expect(editor.isDisposed).toBe(false);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should dispose of the resources used by the editor",
            "suites": [
                "CodeMirrorEditor",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 195,
                "column": 58
            },
            "line": 195,
            "code": "    it('should dispose of the resources used by the editor', () => {\n      expect(editor.isDisposed).toBe(false);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n      editor.dispose();\n      expect(editor.isDisposed).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get a line of text",
            "suites": [
                "CodeMirrorEditor",
                "#getLine()"
            ],
            "updatePoint": {
                "line": 205,
                "column": 33
            },
            "line": 205,
            "code": "    it('should get a line of text', () => {\n      model.sharedModel.setSource('foo\\nbar');\n      expect(editor.getLine(0)).toBe('foo');\n      expect(editor.getLine(1)).toBe('bar');\n      expect(editor.getLine(2)).toBeUndefined();\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the offset for a given position",
            "suites": [
                "CodeMirrorEditor",
                "#getOffsetAt()"
            ],
            "updatePoint": {
                "line": 214,
                "column": 50
            },
            "line": 214,
            "code": "    it('should get the offset for a given position', () => {\n      model.sharedModel.setSource('foo\\nbar');\n      let pos = {\n        column: 2,\n        line: 1\n      };\n      expect(editor.getOffsetAt(pos)).toBe(6);\n      pos = {\n        column: 2,\n        line: 5\n      };\n      expect(() => {\n        editor.getOffsetAt(pos);\n      }).toThrow(RangeError);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the position for a given offset",
            "suites": [
                "CodeMirrorEditor",
                "#getPositionAt()"
            ],
            "updatePoint": {
                "line": 232,
                "column": 50
            },
            "line": 232,
            "code": "    it('should get the position for a given offset', () => {\n      model.sharedModel.setSource('foo\\nbar');\n      let pos = editor.getPositionAt(6);\n      expect(pos.column).toBe(2);\n      expect(pos.line).toBe(1);\n      expect(() => {\n        pos = editor.getPositionAt(101);\n      }).toThrow(RangeError);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should undo one edit",
            "suites": [
                "CodeMirrorEditor",
                "#undo()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 28
            },
            "line": 244,
            "code": "    it('should undo one edit', () => {\n      model.sharedModel.setSource('foo');\n      editor.undo();\n      expect(model.sharedModel.getSource()).toBe('');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should redo one undone edit",
            "suites": [
                "CodeMirrorEditor",
                "#redo()"
            ],
            "updatePoint": {
                "line": 252,
                "column": 35
            },
            "line": 252,
            "code": "    it('should redo one undone edit', () => {\n      model.sharedModel.setSource('foo');\n      editor.undo();\n      editor.redo();\n      expect(model.sharedModel.getSource()).toBe('foo');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should clear the undo history",
            "suites": [
                "CodeMirrorEditor",
                "#clearHistory()"
            ],
            "updatePoint": {
                "line": 261,
                "column": 37
            },
            "line": 261,
            "code": "    it('should clear the undo history', () => {\n      model.sharedModel.setSource('foo');\n      editor.clearHistory();\n      editor.undo();\n      expect(model.sharedModel.getSource()).toBe('foo');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should give focus to the editor",
            "suites": [
                "CodeMirrorEditor",
                "#focus()"
            ],
            "updatePoint": {
                "line": 270,
                "column": 39
            },
            "line": 270,
            "code": "    it('should give focus to the editor', () => {\n      expect(host.contains(document.activeElement)).toBe(false);\n      editor.focus();\n      expect(host.contains(document.activeElement)).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should test whether the editor has focus",
            "suites": [
                "CodeMirrorEditor",
                "#hasFocus()"
            ],
            "updatePoint": {
                "line": 278,
                "column": 48
            },
            "line": 278,
            "code": "    it('should test whether the editor has focus', () => {\n      expect(editor.hasFocus()).toBe(false);\n      editor.focus();\n      expect(editor.hasFocus()).toBe(true);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should blur the editor",
            "suites": [
                "CodeMirrorEditor",
                "#blur()"
            ],
            "updatePoint": {
                "line": 286,
                "column": 30
            },
            "line": 286,
            "code": "    it('should blur the editor', () => {\n      editor.focus();\n      expect(host.contains(document.activeElement)).toBe(true);\n      editor.blur();\n      expect(host.contains(document.activeElement)).toBe(false);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should add the focus class to the host",
            "suites": [
                "CodeMirrorEditor",
                "#handleEvent",
                "focus"
            ],
            "updatePoint": {
                "line": 296,
                "column": 48
            },
            "line": 296,
            "code": "      it('should add the focus class to the host', () => {\n        simulate(editor.editor.contentDOM, 'focus');\n        expect(host.classList.contains('jp-mod-focused')).toBe(true);\n      });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should remove the focus class from the host",
            "suites": [
                "CodeMirrorEditor",
                "#handleEvent",
                "blur"
            ],
            "updatePoint": {
                "line": 303,
                "column": 53
            },
            "line": 303,
            "code": "      it('should remove the focus class from the host', () => {\n        simulate(editor.editor.contentDOM, 'focus');\n        expect(host.classList.contains('jp-mod-focused')).toBe(true);\n        simulate(editor.editor.contentDOM, 'blur');\n        expect(host.classList.contains('jp-mod-focused')).toBe(false);\n      });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should reveal the given position in the editor",
            "suites": [
                "CodeMirrorEditor",
                "#revealPosition()"
            ],
            "updatePoint": {
                "line": 313,
                "column": 54
            },
            "line": 313,
            "code": "    it('should reveal the given position in the editor', () => {\n      model.sharedModel.setSource(TEXT);\n      editor.revealPosition({ line: 50, column: 0 });\n      expect(editor).toBeTruthy();\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should reveal the given selection in the editor",
            "suites": [
                "CodeMirrorEditor",
                "#revealSelection()"
            ],
            "updatePoint": {
                "line": 321,
                "column": 55
            },
            "line": 321,
            "code": "    it('should reveal the given selection in the editor', () => {\n      model.sharedModel.setSource(TEXT);\n      const start = { line: 50, column: 0 };\n      const end = { line: 52, column: 0 };\n      editor.setSelection({ start, end });\n      editor.revealSelection(editor.getSelection());\n      expect(editor).toBeTruthy();\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the primary position of the cursor",
            "suites": [
                "CodeMirrorEditor",
                "#getCursorPosition()"
            ],
            "updatePoint": {
                "line": 332,
                "column": 53
            },
            "line": 332,
            "code": "    it('should get the primary position of the cursor', () => {\n      model.sharedModel.setSource(TEXT);\n      let pos = editor.getCursorPosition();\n      expect(pos.line).toBe(0);\n      expect(pos.column).toBe(0);\n\n      editor.setCursorPosition({ line: 12, column: 3 });\n      pos = editor.getCursorPosition();\n      expect(pos.line).toBe(12);\n      expect(pos.column).toBe(3);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set the primary position of the cursor",
            "suites": [
                "CodeMirrorEditor",
                "#setCursorPosition()"
            ],
            "updatePoint": {
                "line": 346,
                "column": 53
            },
            "line": 346,
            "code": "    it('should set the primary position of the cursor', () => {\n      model.sharedModel.setSource(TEXT);\n      editor.setCursorPosition({ line: 12, column: 3 });\n      const pos = editor.getCursorPosition();\n      expect(pos.line).toBe(12);\n      expect(pos.column).toBe(3);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the primary selection of the editor",
            "suites": [
                "CodeMirrorEditor",
                "#getSelection()"
            ],
            "updatePoint": {
                "line": 356,
                "column": 54
            },
            "line": 356,
            "code": "    it('should get the primary selection of the editor', () => {\n      const selection = editor.getSelection();\n      expect(selection.start.line).toBe(0);\n      expect(selection.end.line).toBe(0);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set the primary selection of the editor",
            "suites": [
                "CodeMirrorEditor",
                "#setSelection()"
            ],
            "updatePoint": {
                "line": 364,
                "column": 54
            },
            "line": 364,
            "code": "    it('should set the primary selection of the editor', () => {\n      model.sharedModel.setSource(TEXT);\n      const start = { line: 50, column: 0 };\n      const end = { line: 52, column: 0 };\n      editor.setSelection({ start, end });\n      expect(editor.getSelection().start).toEqual(start);\n      expect(editor.getSelection().end).toEqual(end);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should remove any secondary cursors",
            "suites": [
                "CodeMirrorEditor",
                "#setSelection()"
            ],
            "updatePoint": {
                "line": 373,
                "column": 43
            },
            "line": 373,
            "code": "    it('should remove any secondary cursors', () => {\n      model.sharedModel.setSource(TEXT);\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      editor.setSelection(range1);\n      expect(editor.getSelections().length).toBe(1);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get the selections for all the cursors",
            "suites": [
                "CodeMirrorEditor",
                "#getSelections()"
            ],
            "updatePoint": {
                "line": 390,
                "column": 53
            },
            "line": 390,
            "code": "    it('should get the selections for all the cursors', () => {\n      model.sharedModel.setSource(TEXT);\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      const selections = editor.getSelections();\n      expect(selections[0].start.line).toBe(50);\n      expect(selections[1].end.line).toBe(54);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set the selections for all the cursors",
            "suites": [
                "CodeMirrorEditor",
                "#setSelections()"
            ],
            "updatePoint": {
                "line": 408,
                "column": 53
            },
            "line": 408,
            "code": "    it('should set the selections for all the cursors', async () => {\n      model.sharedModel.setSource(TEXT);\n      const range0 = {\n        start: { line: 50, column: 0 },\n        end: { line: 52, column: 0 }\n      };\n      const range1 = {\n        start: { line: 53, column: 0 },\n        end: { line: 54, column: 0 }\n      };\n      editor.setSelections([range0, range1]);\n      const selections = editor.getSelections();\n      expect(selections[0].start.line).toBe(50);\n      expect(selections[1].end.line).toBe(54);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set a default selection for an empty array",
            "suites": [
                "CodeMirrorEditor",
                "#setSelections()"
            ],
            "updatePoint": {
                "line": 424,
                "column": 57
            },
            "line": 424,
            "code": "    it('should set a default selection for an empty array', () => {\n      model.sharedModel.setSource(TEXT);\n      editor.setSelections([]);\n      const selection = editor.getSelection();\n      expect(selection.start.line).toBe(0);\n      expect(selection.end.line).toBe(0);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should run when there is a keydown event on the editor",
            "suites": [
                "CodeMirrorEditor",
                "#onKeydown()"
            ],
            "updatePoint": {
                "line": 434,
                "column": 62
            },
            "line": 434,
            "code": "    it('should run when there is a keydown event on the editor', () => {\n      const event = generate('keydown', { keyCode: UP_ARROW });\n      expect(editor.methods).toEqual(expect.not.arrayContaining(['onKeydown']));\n      editor.editor.contentDOM.dispatchEvent(event);\n      expect(editor.methods).toEqual(expect.arrayContaining(['onKeydown']));\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return innermost token",
            "suites": [
                "CodeMirrorEditor",
                "#getTokenAt()"
            ],
            "updatePoint": {
                "line": 443,
                "column": 37
            },
            "line": 443,
            "code": "    it('should return innermost token', async () => {\n      model.mimeType = 'text/x-python';\n      model.sharedModel.setSource('foo = \"a\"\\nbar = 1');\n      // Needed to have the sharedModel content transferred to the editor document\n      await sleep(0.01);\n      expect(editor.getTokenAt(1)).toStrictEqual({\n        offset: 0,\n        type: 'VariableName',\n        value: 'foo'\n      });\n\n      expect(editor.getTokenAt(11)).toStrictEqual({\n        offset: 10,\n        type: 'VariableName',\n        value: 'bar'\n      });\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return preceeding token when it is the last token",
            "suites": [
                "CodeMirrorEditor",
                "#getTokenAt()"
            ],
            "updatePoint": {
                "line": 460,
                "column": 64
            },
            "line": 460,
            "code": "    it('should return preceeding token when it is the last token', async () => {\n      model.mimeType = 'text/x-python';\n      model.sharedModel.setSource('import');\n      // Needed to have the sharedModel content transferred to the editor document\n      await sleep(0.01);\n      expect(editor.getTokenAt(6)).toStrictEqual({\n        type: 'import',\n        offset: 0,\n        value: 'import'\n      });\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get a list of tokens",
            "suites": [
                "CodeMirrorEditor",
                "#getTokens()"
            ],
            "updatePoint": {
                "line": 474,
                "column": 35
            },
            "line": 474,
            "code": "    it('should get a list of tokens', async () => {\n      model.mimeType = 'text/x-python';\n      model.sharedModel.setSource('foo = \"a\"\\nbar = 1');\n      // Needed to have the sharedModel content transferred to the editor document\n      await sleep(0.01);\n      expect(editor.getTokens()).toStrictEqual([\n        {\n          offset: 0,\n          type: 'VariableName',\n          value: 'foo'\n        },\n        {\n          offset: 4,\n          type: 'AssignOp',\n          value: '='\n        },\n        {\n          offset: 6,\n          type: 'String',\n          value: '\"a\"'\n        },\n        {\n          offset: 10,\n          type: 'VariableName',\n          value: 'bar'\n        },\n        {\n          offset: 14,\n          type: 'AssignOp',\n          value: '='\n        },\n        {\n          offset: 16,\n          type: 'Number',\n          value: '1'\n        }\n      ]);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set text in empty editor",
            "suites": [
                "CodeMirrorEditor",
                "#replaceSelection()"
            ],
            "updatePoint": {
                "line": 515,
                "column": 39
            },
            "line": 515,
            "code": "    it('should set text in empty editor', () => {\n      model.sharedModel.setSource('');\n      editor.replaceSelection('text');\n      expect(model.sharedModel.source).toBe('text');\n      expect(editor.getSelection().end.column).toBe(4);\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should replace from start to end of selection",
            "suites": [
                "CodeMirrorEditor",
                "#replaceSelection()"
            ],
            "updatePoint": {
                "line": 522,
                "column": 53
            },
            "line": 522,
            "code": "    it('should replace from start to end of selection', () => {\n      model.sharedModel.setSource('axxc');\n      const start = { line: 0, column: 1 };\n      const end = { line: 0, column: 3 };\n      editor.setSelection({ start, end });\n      editor.replaceSelection('b');\n      expect(model.sharedModel.source).toBe('abc');\n    });",
            "file": "editor.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the default configuration by default",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "baseConfiguration"
            ],
            "updatePoint": {
                "line": 37,
                "column": 60
            },
            "line": 37,
            "code": "      it('should return the default configuration by default', () => {\n        const registry = createRegistry();\n\n        expect(registry.baseConfiguration).toEqual({\n          lineNumbers: true,\n          readOnly: false\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should override the default configuration",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "baseConfiguration"
            ],
            "updatePoint": {
                "line": 46,
                "column": 51
            },
            "line": 46,
            "code": "      it('should override the default configuration', () => {\n        const registry = createRegistry();\n        registry.baseConfiguration = { readOnly: true };\n        expect(registry.baseConfiguration).toEqual({\n          lineNumbers: true,\n          readOnly: true\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the default configuration",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "defaultConfiguration"
            ],
            "updatePoint": {
                "line": 57,
                "column": 49
            },
            "line": 57,
            "code": "      it('should return the default configuration', () => {\n        const registry = createRegistry();\n\n        expect(registry.defaultConfiguration).toEqual({\n          lineNumbers: true,\n          readOnly: false\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the configurable json schema",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "settingsSchema"
            ],
            "updatePoint": {
                "line": 68,
                "column": 52
            },
            "line": 68,
            "code": "      it('should return the configurable json schema', () => {\n        const registry = createRegistry();\n\n        expect(registry.settingsSchema).toEqual({\n          lineNumbers: {\n            type: 'boolean',\n            title: 'Line Numbers',\n            default: true\n          }\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should have schema default if defined",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "settingsSchema"
            ],
            "updatePoint": {
                "line": 80,
                "column": 47
            },
            "line": 80,
            "code": "      it('should have schema default if defined', () => {\n        const registry = new EditorExtensionRegistry();\n        registry.addExtension({\n          name: 'dummy',\n          default: true,\n          factory: () =>\n            EditorExtensionRegistry.createConfigurableExtension(v => []),\n          schema: {\n            type: 'boolean',\n            default: false\n          }\n        });\n\n        expect(registry.settingsSchema).toEqual({\n          dummy: {\n            type: 'boolean',\n            default: false\n          }\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should have null as default if undefined",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "settingsSchema"
            ],
            "updatePoint": {
                "line": 101,
                "column": 50
            },
            "line": 101,
            "code": "      it('should have null as default if undefined', () => {\n        const registry = new EditorExtensionRegistry();\n        registry.addExtension({\n          name: 'dummy',\n          factory: () =>\n            EditorExtensionRegistry.createConfigurableExtension(v => []),\n          schema: {\n            type: ['string', 'null']\n          }\n        });\n\n        expect(registry.settingsSchema).toEqual({\n          dummy: {\n            type: ['string', 'null'],\n            default: null\n          }\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should add a configurable extension factory",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "#addExtension"
            ],
            "updatePoint": {
                "line": 122,
                "column": 53
            },
            "line": 122,
            "code": "      it('should add a configurable extension factory', () => {\n        const registry = new EditorExtensionRegistry();\n        registry.addExtension({\n          name: 'dummy',\n          default: true,\n          factory: () =>\n            EditorExtensionRegistry.createConfigurableExtension(v => [])\n        });\n\n        expect(\n          registry\n            .createNew({ inline: false, model: {} as CodeEditor.IModel })\n            .hasOption('dummy')\n        ).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should add an immutable extension factory",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "#addExtension"
            ],
            "updatePoint": {
                "line": 138,
                "column": 51
            },
            "line": 138,
            "code": "      it('should add an immutable extension factory', () => {\n        const registry = new EditorExtensionRegistry();\n        registry.addExtension({\n          name: 'dummy',\n          factory: () =>\n            EditorExtensionRegistry.createConfigurableExtension(v => [])\n        });\n\n        const handler = registry.createNew({\n          inline: false,\n          model: {} as CodeEditor.IModel\n        });\n        expect(handler.hasOption('dummy')).toEqual(false);\n        expect(handler.getInitialExtensions()).toHaveLength(1);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should raise if an extension with the same name already exists",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "#addExtension"
            ],
            "updatePoint": {
                "line": 154,
                "column": 72
            },
            "line": 154,
            "code": "      it('should raise if an extension with the same name already exists', () => {\n        const registry = new EditorExtensionRegistry();\n        registry.addExtension({\n          name: 'dummy',\n          factory: () =>\n            EditorExtensionRegistry.createConfigurableExtension(v => [])\n        });\n\n        expect(() => {\n          registry.addExtension({\n            name: 'dummy',\n            factory: () =>\n              EditorExtensionRegistry.createConfigurableExtension(v => [])\n          });\n        }).toThrow();\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a extension handler",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "#createNew"
            ],
            "updatePoint": {
                "line": 173,
                "column": 43
            },
            "line": 173,
            "code": "      it('should create a extension handler', () => {\n        const registry = createRegistry();\n\n        const handler = registry.createNew({\n          inline: false,\n          model: {} as CodeEditor.IModel\n        });\n\n        expect(handler.getOption('lineNumbers')).toEqual(true);\n        expect(handler.getOption('readOnly')).toEqual(false);\n        expect(handler.hasOption('immutable')).toEqual(false);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a extension handler with custom configuration",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorExtensionRegistry",
                "#createNew"
            ],
            "updatePoint": {
                "line": 186,
                "column": 69
            },
            "line": 186,
            "code": "      it('should create a extension handler with custom configuration', () => {\n        const registry = createRegistry();\n        registry.baseConfiguration = {\n          lineNumbers: true,\n          readOnly: true\n        };\n        const handler = registry.createNew({\n          inline: false,\n          model: {} as CodeEditor.IModel,\n          config: {\n            lineNumbers: false\n          }\n        });\n\n        expect(handler.getOption('lineNumbers')).toEqual(false);\n        expect(handler.getOption('readOnly')).toEqual(true);\n        expect(handler.hasOption('immutable')).toEqual(false);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#constructor"
            ],
            "updatePoint": {
                "line": 226,
                "column": 34
            },
            "line": 226,
            "code": "      it('should accept no options', () => {\n        const handler = new ExtensionsHandler();\n\n        expect(handler).toBeInstanceOf(ExtensionsHandler);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#constructor"
            ],
            "updatePoint": {
                "line": 232,
                "column": 31
            },
            "line": 232,
            "code": "      it('should accept options', () => {\n        const handler = createHandler({\n          lineNumbers: false\n        });\n\n        expect(handler.getOption('lineNumbers')).toEqual(false);\n        expect(handler.getOption('readOnly')).toEqual(false);\n        expect(handler.hasOption('immutable')).toEqual(false);\n\n        expect(handler.getInitialExtensions()).toHaveLength(3);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be emitted when an option change",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#configChanged"
            ],
            "updatePoint": {
                "line": 246,
                "column": 49
            },
            "line": 246,
            "code": "      it('should be emitted when an option change', async () => {\n        const handler = createHandler();\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setOption('lineNumbers', false);\n\n        const [_, args] = await configChanged;\n        expect(args).toEqual({ lineNumbers: false });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be emitted when some base options change",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#configChanged"
            ],
            "updatePoint": {
                "line": 254,
                "column": 57
            },
            "line": 254,
            "code": "      it('should be emitted when some base options change', async () => {\n        const handler = createHandler();\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setBaseOptions({ lineNumbers: false, readOnly: true });\n        const [_, args] = await configChanged;\n        expect(args).toEqual({\n          lineNumbers: false,\n          readOnly: true\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be emitted when some options change",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#configChanged"
            ],
            "updatePoint": {
                "line": 264,
                "column": 52
            },
            "line": 264,
            "code": "      it('should be emitted when some options change', async () => {\n        const handler = createHandler();\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setOptions({ lineNumbers: false, readOnly: true });\n        const [_, args] = await configChanged;\n        expect(args).toEqual({\n          lineNumbers: false,\n          readOnly: true\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be emitted when the handler is disposed",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#disposed"
            ],
            "updatePoint": {
                "line": 277,
                "column": 56
            },
            "line": 277,
            "code": "      it('should be emitted when the handler is disposed', async () => {\n        const handler = new ExtensionsHandler();\n\n        const disposed = signalToPromise(handler.disposed);\n        handler.dispose();\n        await disposed;\n\n        expect(handler.isDisposed).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be false by default",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 289,
                "column": 36
            },
            "line": 289,
            "code": "      it('should be false by default', () => {\n        const handler = new ExtensionsHandler();\n\n        expect(handler.isDisposed).toEqual(false);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be true when the handler is disposed",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 295,
                "column": 53
            },
            "line": 295,
            "code": "      it('should be true when the handler is disposed', async () => {\n        const handler = new ExtensionsHandler();\n\n        const disposed = signalToPromise(handler.disposed);\n        handler.dispose();\n        await disposed;\n\n        expect(handler.isDisposed).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should dispose the resources of the handler",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#dispose"
            ],
            "updatePoint": {
                "line": 307,
                "column": 53
            },
            "line": 307,
            "code": "      it('should dispose the resources of the handler', () => {\n        const handler = new ExtensionsHandler();\n        handler.dispose();\n        expect(handler.isDisposed).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the value of an option",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#getOption"
            ],
            "updatePoint": {
                "line": 315,
                "column": 46
            },
            "line": 315,
            "code": "      it('should return the value of an option', () => {\n        const handler = createHandler();\n\n        expect(handler.getOption('lineNumbers')).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return undefined if the option does not exist",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#getOption"
            ],
            "updatePoint": {
                "line": 321,
                "column": 62
            },
            "line": 321,
            "code": "      it('should return undefined if the option does not exist', () => {\n        const handler = new ExtensionsHandler();\n\n        expect(handler.getOption('lineNumbers')).toBeUndefined();\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return true if an option exists",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#hasOption"
            ],
            "updatePoint": {
                "line": 329,
                "column": 48
            },
            "line": 329,
            "code": "      it('should return true if an option exists', () => {\n        const handler = createHandler();\n\n        expect(handler.hasOption('lineNumbers')).toEqual(true);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return false if the option does not exist",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#hasOption"
            ],
            "updatePoint": {
                "line": 335,
                "column": 58
            },
            "line": 335,
            "code": "      it('should return false if the option does not exist', () => {\n        const handler = new ExtensionsHandler();\n\n        expect(handler.hasOption('lineNumbers')).toEqual(false);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set an option and emit a signal",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#setOption"
            ],
            "updatePoint": {
                "line": 343,
                "column": 48
            },
            "line": 343,
            "code": "      it('should set an option and emit a signal', async () => {\n        const handler = createHandler();\n\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setOption('lineNumbers', false);\n\n        const [_, args] = await configChanged;\n        expect(args).toEqual({ lineNumbers: false });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set the base options and emit a signal",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#setBaseOptions"
            ],
            "updatePoint": {
                "line": 355,
                "column": 55
            },
            "line": 355,
            "code": "      it('should set the base options and emit a signal', async () => {\n        const handler = createHandler();\n\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setBaseOptions({ lineNumbers: false });\n\n        const [_, args] = await configChanged;\n        expect(args).toEqual({\n          lineNumbers: false,\n          // The signal will emit removed option with `undefined` value\n          readOnly: undefined\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should set the options and emit a signal",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#setOptions"
            ],
            "updatePoint": {
                "line": 371,
                "column": 50
            },
            "line": 371,
            "code": "      it('should set the options and emit a signal', async () => {\n        const handler = createHandler({ readOnly: true });\n\n        const configChanged = signalToPromise(handler.configChanged);\n        handler.setOptions({ lineNumbers: false });\n\n        const [_, args] = await configChanged;\n        expect(args).toEqual({\n          lineNumbers: false,\n          // The signal will emit removed option with base configuration value\n          readOnly: false\n        });\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the list of initial editor extensions",
            "suites": [
                "@jupyterlab/codemirror",
                "ExtensionsHandler",
                "#getInitialExtensions"
            ],
            "updatePoint": {
                "line": 387,
                "column": 61
            },
            "line": 387,
            "code": "      it('should return the list of initial editor extensions', () => {\n        const handler = createHandler();\n\n        expect(handler.getInitialExtensions()).toHaveLength(3);\n      });",
            "file": "extension.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a CodeMirrorEditorFactory",
            "suites": [
                "CodeMirrorEditorFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 47
            },
            "line": 48,
            "code": "    it('should create a CodeMirrorEditorFactory', () => {\n      const factory = new CodeMirrorEditorFactory();\n      expect(factory).toBeInstanceOf(CodeMirrorEditorFactory);\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a CodeMirrorEditorFactory with options",
            "suites": [
                "CodeMirrorEditorFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 53,
                "column": 60
            },
            "line": 53,
            "code": "    it('should create a CodeMirrorEditorFactory with options', () => {\n      const languages = new EditorLanguageRegistry();\n      const findBest = jest.spyOn(languages, 'findBest');\n      const factory = new CodeMirrorEditorFactory({ languages });\n      expect(factory).toBeInstanceOf(CodeMirrorEditorFactory);\n      factory.newInlineEditor({ host, model });\n      expect(findBest).toHaveBeenCalled();\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a new editor",
            "suites": [
                "CodeMirrorEditorFactory",
                "#newInlineEditor"
            ],
            "updatePoint": {
                "line": 64,
                "column": 34
            },
            "line": 64,
            "code": "    it('should create a new editor', () => {\n      const factory = new CodeMirrorEditorFactory();\n      const editor = factory.newInlineEditor({ host, model });\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      editor.dispose();\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a new editor with given options",
            "suites": [
                "CodeMirrorEditorFactory",
                "#newInlineEditor"
            ],
            "updatePoint": {
                "line": 71,
                "column": 53
            },
            "line": 71,
            "code": "    it('should create a new editor with given options', () => {\n      const factory = new CodeMirrorEditorFactory();\n      const editor = factory.newInlineEditor({\n        host,\n        model\n      }) as CodeMirrorEditor;\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      for (const key in Object.keys(defaults)) {\n        const option = key as keyof Record<string, any>;\n        expect(editor.getOption(option)).toBe(defaults[option]);\n      }\n      editor.dispose();\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a new editor",
            "suites": [
                "CodeMirrorEditorFactory",
                "#newDocumentEditor"
            ],
            "updatePoint": {
                "line": 87,
                "column": 34
            },
            "line": 87,
            "code": "    it('should create a new editor', () => {\n      const factory = new CodeMirrorEditorFactory();\n      const editor = factory.newDocumentEditor({ host, model });\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      editor.dispose();\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should create a new editor with given options",
            "suites": [
                "CodeMirrorEditorFactory",
                "#newDocumentEditor"
            ],
            "updatePoint": {
                "line": 94,
                "column": 53
            },
            "line": 94,
            "code": "    it('should create a new editor with given options', () => {\n      const factory = new CodeMirrorEditorFactory({ extensions });\n      const editor = factory.newDocumentEditor({\n        host,\n        model,\n        config: defaults\n      }) as CodeMirrorEditor;\n      expect(editor).toBeInstanceOf(CodeMirrorEditor);\n      for (const key in Object.keys(defaults)) {\n        expect(editor.getOption(key)).toBe(defaults[key]);\n      }\n      editor.dispose();\n    });",
            "file": "factory.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should get a non-empty list of spec",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorLanguageRegistry",
                "#getLanguage"
            ],
            "updatePoint": {
                "line": 22,
                "column": 45
            },
            "line": 22,
            "code": "      it('should get a non-empty list of spec', () => {\n        const specs = languages.getLanguages();\n        expect(specs.length).toBeTruthy();\n      });",
            "file": "language.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should load a defined spec",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorLanguageRegistry",
                "#getLanguage"
            ],
            "updatePoint": {
                "line": 27,
                "column": 36
            },
            "line": 27,
            "code": "      it('should load a defined spec', async () => {\n        const spec = (await languages.getLanguage('text/foo'))!;\n        expect(spec.name).toBe('foo');\n      });",
            "file": "language.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should load a bundled spec",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorLanguageRegistry",
                "#getLanguage"
            ],
            "updatePoint": {
                "line": 32,
                "column": 36
            },
            "line": 32,
            "code": "      it('should load a bundled spec', async () => {\n        for (const language of EditorLanguageRegistry.getDefaultLanguages().filter(\n          spec => spec.name === 'JSON'\n        )) {\n          languages.addLanguage(language);\n        }\n        const spec = (await languages.getLanguage('application/json'))!;\n        expect(spec.name).toBe('JSON');\n      });",
            "file": "language.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorLanguageRegistry",
                "#getLanguage"
            ],
            "updatePoint": {
                "line": 42,
                "column": 32
            },
            "line": 42,
            "code": "      it('should default to null', async () => {\n        const spec = (await languages.getLanguage('this is not a mode'))!;\n        expect(spec.name).toBe('none');\n      });",
            "file": "language.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should load a defined spec",
            "suites": [
                "@jupyterlab/codemirror",
                "EditorLanguageRegistry",
                "#highlight"
            ],
            "updatePoint": {
                "line": 49,
                "column": 36
            },
            "line": 49,
            "code": "      it('should load a defined spec', async () => {\n        const container = document.createElement('pre');\n        await languages.highlight(\n          `(defun check-login (name password) ; absolutely secure\n      (if (equal name \"admin\")\n        (equal password \"12345\")\n        #t))`,\n          languages.findBest('text/foo'),\n          container\n        );\n        expect(container.innerHTML).toEqual(\n          `<span class=\"ͼ19\">(</span>defun check-login <span class=\"ͼ19\">(</span>name password<span class=\"ͼ19\">)</span> <span class=\"ͼ11\">; absolutely secure</span>\n      <span class=\"ͼ19\">(</span>if <span class=\"ͼ19\">(</span>equal name <span class=\"ͼ12\">\"admin\"</span><span class=\"ͼ19\">)</span>\n        <span class=\"ͼ19\">(</span>equal password <span class=\"ͼ12\">\"12345\"</span><span class=\"ͼ19\">)</span>\n        <span class=\"ͼ1d\">#t</span><span class=\"ͼ19\">)</span><span class=\"ͼ19\">)</span>`\n        );\n      });",
            "file": "language.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math $ with no space",
            "suites": [],
            "updatePoint": {
                "line": 188,
                "column": 30
            },
            "line": 187,
            "code": "test(\n  'Inline math $ with no space',\n  `\n{P:{MaID:{maID:$}\\\\vec{F} = m \\\\vec{a}{maID:$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math $ with space after start",
            "suites": [],
            "updatePoint": {
                "line": 195,
                "column": 39
            },
            "line": 194,
            "code": "test(\n  'Inline math $ with space after start',\n  `\n{P:{MaID:{maID:$} \\\\vec{F} = m \\\\vec{a}{maID:$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math $ with space before end",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 38
            },
            "line": 201,
            "code": "test(\n  'Inline math $ with space before end',\n  `\n{P:{MaID:{maID:$}\\\\vec{F} = m \\\\vec{a} {maID:$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math $ with spaces",
            "suites": [],
            "updatePoint": {
                "line": 209,
                "column": 28
            },
            "line": 208,
            "code": "test(\n  'Inline math $ with spaces',\n  `\n {P:{MaID:{maID:$} \\\\vec{F} = m \\\\vec{a} {maID:$}} }\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math $ on multilines",
            "suites": [],
            "updatePoint": {
                "line": 216,
                "column": 30
            },
            "line": 215,
            "code": "test(\n  'Inline math $ on multilines',\n  `\n{P:{MaID:{maID:$}\\\\vec{F} =\nm \\\\vec{a}{maID:$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Not math $",
            "suites": [],
            "updatePoint": {
                "line": 224,
                "column": 13
            },
            "line": 223,
            "code": "test(\n  'Not math $',\n  `\n{P:Not a math dollar $}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Money symbol considered as math",
            "suites": [],
            "updatePoint": {
                "line": 231,
                "column": 34
            },
            "line": 230,
            "code": "test(\n  'Money symbol considered as math',\n  `\n{P:Problematic case: {MaID:{maID:$}20 and {maID:$}}22}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math \\( \\)",
            "suites": [],
            "updatePoint": {
                "line": 240,
                "column": 22
            },
            "line": 239,
            "code": "test(\n  'Inline math \\\\( \\\\)',\n  `\n{P:{MaIB:{maIB:\\\\\\\\(}\\\\vec{F} = m \\\\vec{a}{maIB:\\\\\\\\)}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Inline math \\( \\) on multilines",
            "suites": [],
            "updatePoint": {
                "line": 247,
                "column": 36
            },
            "line": 246,
            "code": "test(\n  'Inline math \\\\( \\\\) on multilines',\n  `\n{P:{MaIB:{maIB:\\\\\\\\(}\\\\vec{F} =\nm \\\\vec{a}{maIB:\\\\\\\\)}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Block math $$",
            "suites": [],
            "updatePoint": {
                "line": 257,
                "column": 16
            },
            "line": 256,
            "code": "test(\n  'Block math $$',\n  `\n{P:{MaBD:{maBD:$$}\\\\vec{F} = m \\\\vec{a}{maBD:$$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Block math $$ on multilines",
            "suites": [],
            "updatePoint": {
                "line": 264,
                "column": 30
            },
            "line": 263,
            "code": "test(\n  'Block math $$ on multilines',\n  `\n{P:{MaBD:{maBD:$$}\n\\\\begin{aligned}\n\\\\dot{x} & = \\\\sigma(y-x) {Esc:\\\\\\\\}\n\\\\dot{y} & = \\\\rho x - y - xz {Esc:\\\\\\\\}\n\\\\dot{z} & = -\\\\beta z + xy\n\\\\end{aligned}\n{maBD:$$}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Block math \\[ \\]",
            "suites": [],
            "updatePoint": {
                "line": 279,
                "column": 21
            },
            "line": 278,
            "code": "test(\n  'Block math \\\\[ \\\\]',\n  `\n{P:{MaBB:{maBB:\\\\\\\\[}\\\\vec{F} = m \\\\vec{a}{maBB:\\\\\\\\]}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "Block math \\[ \\] on multilines",
            "suites": [],
            "updatePoint": {
                "line": 286,
                "column": 35
            },
            "line": 285,
            "code": "test(\n  'Block math \\\\[ \\\\] on multilines',\n  `\n{P:{MaBB:{maBB:\\\\\\\\[}\n\\\\begin{aligned}\n\\\\dot{x} & = \\\\sigma(y-x) {Esc:\\\\\\\\}\n\\\\dot{y} & = \\\\rho x - y - xz {Esc:\\\\\\\\}\n\\\\dot{z} & = -\\\\beta z + xy\n\\\\end{aligned}\n{maBB:\\\\\\\\]}}}\n`\n);",
            "file": "mathparser.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the `jupyter` theme",
            "suites": [
                "themes",
                "#defaultTheme"
            ],
            "updatePoint": {
                "line": 20,
                "column": 41
            },
            "line": 20,
            "code": "    it('should return the `jupyter` theme', () => {\n      expect(themes.defaultTheme()).toBe(themes.getTheme('jupyter'));\n    });",
            "file": "theme.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should add a new theme",
            "suites": [
                "themes",
                "#addTheme"
            ],
            "updatePoint": {
                "line": 26,
                "column": 30
            },
            "line": 26,
            "code": "    it('should add a new theme', () => {\n      themes.addTheme({ name: 'one dark', theme: oneDark });\n\n      expect(themes.getTheme('one dark')).toBe(oneDark);\n    });",
            "file": "theme.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the given theme",
            "suites": [
                "themes",
                "#getTheme"
            ],
            "updatePoint": {
                "line": 34,
                "column": 37
            },
            "line": 34,
            "code": "    it('should return the given theme', () => {\n      themes.addTheme({ name: 'one dark', theme: oneDark });\n\n      expect(themes.getTheme('one dark')).toBe(oneDark);\n    });",
            "file": "theme.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should return the default theme if the name does not exist",
            "suites": [
                "themes",
                "#getTheme"
            ],
            "updatePoint": {
                "line": 40,
                "column": 66
            },
            "line": 40,
            "code": "    it('should return the default theme if the name does not exist', () => {\n      expect(themes.getTheme('bar')).toBe(themes.defaultTheme());\n    });",
            "file": "theme.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be a CodeEditorWrapper",
            "suites": [
                "CodeEditorWrapper",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 37
            },
            "line": 82,
            "code": "    it('should be a CodeEditorWrapper', () => {\n      expect(widget).toBeInstanceOf(CodeEditorWrapper);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should add a focus listener",
            "suites": [
                "CodeEditorWrapper",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 86,
                "column": 35
            },
            "line": 86,
            "code": "    it('should add a focus listener', () => {\n      widget.node.tabIndex = -1;\n      simulate(widget.node, 'focus');\n      const editor = widget.editor as LogEditor;\n      expect(editor.events).toEqual(expect.arrayContaining(['focus']));\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be a a code editor",
            "suites": [
                "CodeEditorWrapper",
                "#editor"
            ],
            "updatePoint": {
                "line": 95,
                "column": 33
            },
            "line": 95,
            "code": "    it('should be a a code editor', () => {\n      expect(widget.editor.getOption('lineNumbers')).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should dispose of the resources used by the widget",
            "suites": [
                "CodeEditorWrapper",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 101,
                "column": 58
            },
            "line": 101,
            "code": "    it('should dispose of the resources used by the widget', () => {\n      expect(widget.isDisposed).toBe(false);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should remove the focus listener",
            "suites": [
                "CodeEditorWrapper",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 40
            },
            "line": 109,
            "code": "    it('should remove the focus listener', () => {\n      const editor = widget.editor as LogEditor;\n      expect(editor.isDisposed).toBe(false);\n      widget.dispose();\n      expect(editor.isDisposed).toBe(true);\n\n      widget.node.tabIndex = -1;\n      simulate(widget.node, 'focus');\n      expect(editor.events).toEqual(expect.not.arrayContaining(['focus']));\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should be a no-op if the editor was not resized",
            "suites": [
                "CodeEditorWrapper",
                "#handleEvent()",
                "focus"
            ],
            "updatePoint": {
                "line": 123,
                "column": 57
            },
            "line": 123,
            "code": "      it('should be a no-op if the editor was not resized', () => {\n        Widget.attach(widget, document.body);\n        const editor = widget.editor as LogEditor;\n        editor.methods = [];\n        simulate(editor.editor.contentDOM, 'focus');\n        expect(editor.methods).toEqual([]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should focus the editor",
            "suites": [
                "CodeEditorWrapper",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 134,
                "column": 31
            },
            "line": 134,
            "code": "    it('should focus the editor', () => {\n      Widget.attach(widget, document.body);\n      MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n      expect(widget.methods).toEqual(\n        expect.arrayContaining(['onActivateRequest'])\n      );\n      expect(widget.editor.hasFocus()).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/codemirror/test"
        },
        {
            "name": "should accept results with `_jupyter_types_experimental` metadata",
            "suites": [
                "completer/default/kernelprovider",
                "KernelCompleterProvider",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 75
            },
            "line": 25,
            "code": "      it('should accept results with `_jupyter_types_experimental` metadata', async () => {\n        kernel.requestComplete = async (\n          contents: KernelMessage.ICompleteRequestMsg['content']\n        ) => {\n          return {\n            channel: 'shell',\n            header: {\n              msg_id: '8a1cb99c-fdff731a5471adf71bcccb01_103588_3078',\n              msg_type: 'complete_reply',\n              username: '',\n              session: '8a1cb99c-fdff731a5471adf71bcccb01',\n              date: '2023-05-07T13:37:29.216298Z',\n              version: '5.3'\n            },\n            parent_header: {\n              date: '2023-05-07T13:37:29.092000Z',\n              msg_id: '766951ae-5117-4282-abd3-b43b569aa496',\n              msg_type: 'complete_request',\n              session: '7ec9fde6-c8bb-40b2-a7f3-8e1b514f7037',\n              username: '',\n              version: '5.2'\n            },\n            metadata: {},\n            content: {\n              matches: ['staticmethod', 'str', '%store'],\n              cursor_end: 2,\n              cursor_start: 0,\n              metadata: {\n                _jupyter_types_experimental: [\n                  {\n                    start: 0,\n                    end: 2,\n                    text: 'staticmethod',\n                    type: 'class',\n                    signature: ''\n                  },\n                  {\n                    start: 0,\n                    end: 2,\n                    text: 'str',\n                    type: 'class',\n                    signature: ''\n                  },\n                  {\n                    start: 0,\n                    end: 2,\n                    text: '%store',\n                    type: 'magic',\n                    signature: ''\n                  }\n                ]\n              },\n              status: 'ok'\n            }\n          };\n        };\n\n        const result = await provider.fetch({ text: 'st', offset: 2 }, context);\n\n        expect(result).toStrictEqual({\n          start: 0,\n          end: 2,\n          items: [\n            {\n              label: 'staticmethod',\n              type: 'class',\n              insertText: 'staticmethod'\n            },\n            { label: 'str', type: 'class', insertText: 'str' },\n            { label: '%store', type: 'magic', insertText: '%store' }\n          ]\n        });\n      });",
            "file": "kernelprovider.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should accept results without `_jupyter_types_experimental` metadata",
            "suites": [
                "completer/default/kernelprovider",
                "KernelCompleterProvider",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 99,
                "column": 78
            },
            "line": 99,
            "code": "      it('should accept results without `_jupyter_types_experimental` metadata', async () => {\n        kernel.requestComplete = async (\n          contents: KernelMessage.ICompleteRequestMsg['content']\n        ) => {\n          return {\n            channel: 'shell',\n            header: {\n              msg_id: '6bb75124-996c-45b6-80ce-cd28f490a9d2',\n              session: 'fd6b9f46-6d46-4e11-b686-27f73b027f8d',\n              username: '',\n              date: '2023-05-07T13:10:54.600942Z',\n              msg_type: 'complete_reply',\n              version: '5.3'\n            },\n            parent_header: {\n              date: '2023-05-07T13:10:54.586Z',\n              msg_id: '7c93ba17-facd-44ed-b6a7-f34348a9ea42',\n              msg_type: 'complete_request',\n              session: 'fd6b9f46-6d46-4e11-b686-27f73b027f8d',\n              username: '',\n              version: '5.2'\n            },\n            metadata: {},\n            content: {\n              matches: [\n                'plclust',\n                'plnorm',\n                'plogis',\n                'plot',\n                'plot.default',\n                'plot.design',\n                'plot.ecdf',\n                'plot.function',\n                'plot.new',\n                'plot.spec.coherency',\n                'plot.spec.phase',\n                'plot.stepfun',\n                'plot.ts',\n                'plot.window',\n                'plot.xy'\n              ],\n              metadata: {},\n              cursor_start: 0,\n              cursor_end: 2,\n              status: 'ok'\n            }\n          };\n        };\n\n        const result = await provider.fetch({ text: 'pl', offset: 2 }, context);\n        expect(result).toStrictEqual({\n          start: 0,\n          end: 2,\n          items: [\n            { label: 'plclust' },\n            { label: 'plnorm' },\n            { label: 'plogis' },\n            { label: 'plot' },\n            { label: 'plot.default' },\n            { label: 'plot.design' },\n            { label: 'plot.ecdf' },\n            { label: 'plot.function' },\n            { label: 'plot.new' },\n            { label: 'plot.spec.coherency' },\n            { label: 'plot.spec.phase' },\n            { label: 'plot.stepfun' },\n            { label: 'plot.ts' },\n            { label: 'plot.window' },\n            { label: 'plot.xy' }\n          ]\n        });\n      });",
            "file": "kernelprovider.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should create a completer model",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 41
            },
            "line": 24,
            "code": "      it('should create a completer model', () => {\n        const model = new CompleterModel();\n        expect(model).toBeInstanceOf(CompleterModel);\n        expect(model.setCompletionItems).toBeDefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when model items have changed",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 32,
                "column": 53
            },
            "line": 32,
            "code": "      it('should signal when model items have changed', () => {\n        let model = new CompleterModel();\n        let called = 0;\n        let listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setCompletionItems([{ label: 'foo' }]);\n        expect(called).toBe(1);\n        model.setCompletionItems([{ label: 'foo' }]);\n        model.setCompletionItems([{ label: 'foo' }, { label: 'bar' }]);\n        expect(called).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not signal when items have not changed",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 47,
                "column": 55
            },
            "line": 47,
            "code": "      it('should not signal when items have not changed', () => {\n        let model = new CompleterModel();\n        let called = 0;\n        let listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.setCompletionItems([{ label: 'foo' }]);\n        model.setCompletionItems([{ label: 'foo' }]);\n        expect(called).toBe(1);\n        model.setCompletionItems([{ label: 'foo' }, { label: 'bar' }]);\n        model.setCompletionItems([{ label: 'foo' }, { label: 'bar' }]);\n        expect(called).toBe(2);\n        model.setCompletionItems([]);\n        model.setCompletionItems([]);\n        expect(called).toBe(3);\n        const itemsWithResolve = [\n          {\n            label: 'foo',\n            resolve: async () => {\n              return { label: 'foo', documentation: 'Foo docs' };\n            }\n          }\n        ];\n        model.setCompletionItems(itemsWithResolve);\n        model.setCompletionItems(itemsWithResolve);\n        expect(called).toBe(4);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when original request changes",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 77,
                "column": 53
            },
            "line": 77,
            "code": "      it('should signal when original request changes', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = makeState('foo');\n        expect(called).toBe(1);\n        model.original = null;\n        expect(called).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not signal when original request has not changed",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 91,
                "column": 65
            },
            "line": 91,
            "code": "      it('should not signal when original request has not changed', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = makeState('foo');\n        model.original = makeState('foo');\n        expect(called).toBe(1);\n        model.original = null;\n        model.original = null;\n        expect(called).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when current text changes",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 107,
                "column": 49
            },
            "line": 107,
            "code": "      it('should signal when current text changes', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = request;\n        expect(called).toBe(1);\n        model.cursor = cursor;\n        model.current = change;\n        expect(called).toBe(2);\n        model.current = null;\n        expect(called).toBe(3);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not signal when current text is unchanged",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 129,
                "column": 58
            },
            "line": 129,
            "code": "      it('should not signal when current text is unchanged', () => {\n        const model = new CompleterModel();\n        let called = 0;\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: void) => {\n          called++;\n        };\n        model.stateChanged.connect(listener);\n        expect(called).toBe(0);\n        model.original = request;\n        expect(called).toBe(1);\n        model.cursor = cursor;\n        model.current = change;\n        model.current = change;\n        expect(called).toBe(2);\n        model.current = null;\n        model.current = null;\n        expect(called).toBe(3);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when query is set via public setter",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#queryChanged"
            ],
            "updatePoint": {
                "line": 155,
                "column": 59
            },
            "line": 155,
            "code": "      it('should signal when query is set via public setter', () => {\n        const model = new CompleterModel();\n        let called: Record<'setter' | 'editorUpdate' | 'reset', number> = {\n          setter: 0,\n          editorUpdate: 0,\n          reset: 0\n        };\n        const listener = (sender: any, args: Completer.IQueryChange) => {\n          called[args.origin]++;\n        };\n        model.queryChanged.connect(listener);\n        expect(called.setter).toBe(0);\n        model.query = 'foo';\n        expect(called.setter).toBe(1);\n        model.query = 'bar';\n        expect(called.setter).toBe(2);\n        expect(called.editorUpdate).toBe(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when query gets reset",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#queryChanged"
            ],
            "updatePoint": {
                "line": 174,
                "column": 45
            },
            "line": 174,
            "code": "      it('should signal when query gets reset', () => {\n        const model = new CompleterModel();\n        let called: Record<'setter' | 'editorUpdate' | 'reset', number> = {\n          setter: 0,\n          editorUpdate: 0,\n          reset: 0\n        };\n        const listener = (sender: any, args: Completer.IQueryChange) => {\n          called[args.origin]++;\n        };\n        model.queryChanged.connect(listener);\n        expect(called.reset).toBe(0);\n        model.query = 'foo';\n        expect(called.reset).toBe(0);\n        model.reset();\n        expect(called.reset).toBe(1);\n        // Should not call again (query does not change with second reset)\n        model.reset();\n        expect(called.reset).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should signal when current text changes",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#queryChanged"
            ],
            "updatePoint": {
                "line": 195,
                "column": 49
            },
            "line": 195,
            "code": "      it('should signal when current text changes', () => {\n        const model = new CompleterModel();\n        let called: Record<'setter' | 'editorUpdate' | 'reset', number> = {\n          setter: 0,\n          editorUpdate: 0,\n          reset: 0\n        };\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: Completer.IQueryChange) => {\n          called[args.origin]++;\n        };\n        model.queryChanged.connect(listener);\n        expect(called.editorUpdate).toBe(0);\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        expect(called.editorUpdate).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not signal when current text is unchanged",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#queryChanged"
            ],
            "updatePoint": {
                "line": 218,
                "column": 58
            },
            "line": 218,
            "code": "      it('should not signal when current text is unchanged', () => {\n        const model = new CompleterModel();\n        let called: Record<'setter' | 'editorUpdate' | 'reset', number> = {\n          setter: 0,\n          editorUpdate: 0,\n          reset: 0\n        };\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        const listener = (sender: any, args: Completer.IQueryChange) => {\n          called[args.origin]++;\n        };\n        model.queryChanged.connect(listener);\n        expect(called.editorUpdate).toBe(0);\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        model.current = change;\n        expect(called.editorUpdate).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should default to { items: [] }",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 41
            },
            "line": 244,
            "code": "      it('should default to { items: [] }', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [];\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return unmarked ICompletionItems if query is blank",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 250,
                "column": 67
            },
            "line": 250,
            "code": "      it('should return unmarked ICompletionItems if query is blank', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ];\n        model.setCompletionItems([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return a marked list of items if query is set",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 265,
                "column": 62
            },
            "line": 265,
            "code": "      it('should return a marked list of items if query is set', () => {\n        let model = new CompleterModel();\n        let want = '<mark>f</mark>oo';\n        model.setCompletionItems([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        model.query = 'f';\n        expect(model.completionItems().length).toEqual(1);\n        expect(model.completionItems()[0].label).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should order list based on score",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 278,
                "column": 42
            },
            "line": 278,
            "code": "      it('should order list based on score', () => {\n        const model = new CompleterModel();\n        const want: CompletionHandler.ICompletionItems = [\n          { insertText: 'qux', label: '<mark>qux</mark>' },\n          { insertText: 'quux', label: '<mark>qu</mark>u<mark>x</mark>' }\n        ];\n        model.setCompletionItems([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' },\n          { label: 'quux' },\n          { label: 'qux' }\n        ]);\n        model.query = 'qux';\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should break ties in score by locale sort",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 295,
                "column": 51
            },
            "line": 295,
            "code": "      it('should break ties in score by locale sort', () => {\n        const model = new CompleterModel();\n        const want: CompletionHandler.ICompletionItems = [\n          { insertText: 'quux', label: '<mark>qu</mark>ux' },\n          { insertText: 'qux', label: '<mark>qu</mark>x' }\n        ];\n        model.setCompletionItems([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' },\n          { label: 'quux' },\n          { label: 'qux' }\n        ]);\n        model.query = 'qu';\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return { items: [] } if reset",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 312,
                "column": 46
            },
            "line": 312,
            "code": "      it('should return { items: [] } if reset', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [];\n        model.setCompletionItems([\n          { label: 'foo' },\n          { label: 'bar' },\n          { label: 'baz' }\n        ]);\n        model.reset();\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should escape HTML markup",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 324,
                "column": 35
            },
            "line": 324,
            "code": "      it('should escape HTML markup', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [\n          {\n            label: '&lt;foo&gt;&lt;/foo&gt;',\n            insertText: '<foo></foo>'\n          }\n        ];\n        model.setCompletionItems([{ label: '<foo></foo>' }]);\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should escape HTML with matches markup",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#completionItems()"
            ],
            "updatePoint": {
                "line": 336,
                "column": 48
            },
            "line": 336,
            "code": "      it('should escape HTML with matches markup', () => {\n        let model = new CompleterModel();\n        let want: CompletionHandler.ICompletionItems = [\n          {\n            label: '&lt;foo&gt;<mark>smi</mark>le&lt;/foo&gt;',\n            insertText: '<foo>smile</foo>'\n          }\n        ];\n        model.setCompletionItems([{ label: '<foo>smile</foo>' }]);\n        model.query = 'smi';\n        expect(model.completionItems()).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#original"
            ],
            "updatePoint": {
                "line": 351,
                "column": 32
            },
            "line": 351,
            "code": "      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.original).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return the original request",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#original"
            ],
            "updatePoint": {
                "line": 356,
                "column": 44
            },
            "line": 356,
            "code": "      it('should return the original request', () => {\n        const model = new CompleterModel();\n        const request = makeState('foo');\n        model.original = request;\n        expect(model.original).toBe(request);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#current"
            ],
            "updatePoint": {
                "line": 365,
                "column": 32
            },
            "line": 365,
            "code": "      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.current).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should initially equal the original request",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#current"
            ],
            "updatePoint": {
                "line": 370,
                "column": 53
            },
            "line": 370,
            "code": "      it('should initially equal the original request', () => {\n        const model = new CompleterModel();\n        const request = makeState('foo');\n        model.original = request;\n        expect(model.current).toBe(request);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not set if original request is nonexistent",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#current"
            ],
            "updatePoint": {
                "line": 377,
                "column": 59
            },
            "line": 377,
            "code": "      it('should not set if original request is nonexistent', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.current = change;\n        expect(model.current).toBeNull();\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        expect(model.current).toBe(change);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not set if cursor is nonexistent",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#current"
            ],
            "updatePoint": {
                "line": 392,
                "column": 49
            },
            "line": 392,
            "code": "      it('should not set if cursor is nonexistent', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.original = request;\n        model.cursor = null;\n        model.current = change;\n        expect(model.current).not.toBe(change);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should reset model if change is shorter than original",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#current"
            ],
            "updatePoint": {
                "line": 404,
                "column": 63
            },
            "line": 404,
            "code": "      it('should reset model if change is shorter than original', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'fo';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        model.original = request;\n        model.cursor = cursor;\n        model.current = change;\n        expect(model.current).toBeNull();\n        expect(model.original).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#cursor"
            ],
            "updatePoint": {
                "line": 420,
                "column": 32
            },
            "line": 420,
            "code": "      it('should default to null', () => {\n        const model = new CompleterModel();\n        expect(model.cursor).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should not set if original request is nonexistent",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#cursor"
            ],
            "updatePoint": {
                "line": 425,
                "column": 59
            },
            "line": 425,
            "code": "      it('should not set if original request is nonexistent', () => {\n        const model = new CompleterModel();\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState('foo');\n        model.cursor = cursor;\n        expect(model.cursor).toBeNull();\n        model.original = request;\n        model.cursor = cursor;\n        expect(model.cursor).toBe(cursor);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should be true if model has been disposed",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 438,
                "column": 51
            },
            "line": 438,
            "code": "      it('should be true if model has been disposed', () => {\n        const model = new CompleterModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should dispose of the model resources",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 447,
                "column": 47
            },
            "line": 447,
            "code": "      it('should dispose of the model resources', () => {\n        const model = new CompleterModel();\n        model.setCompletionItems([{ label: 'foo' }]);\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 455,
                "column": 47
            },
            "line": 455,
            "code": "      it('should be safe to call multiple times', () => {\n        const model = new CompleterModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should set current change value",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#handleTextChange()"
            ],
            "updatePoint": {
                "line": 465,
                "column": 41
            },
            "line": 465,
            "code": "      it('should set current change value', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foob';\n        const cursor: Completer.ICursorSpan = { start: 0, end: 0 };\n        const request = makeState(currentValue);\n        const change = makeState(newValue);\n        (change as any).column = 4;\n        model.original = request;\n        model.cursor = cursor;\n        expect(model.current).toBe(request);\n        model.handleTextChange(change);\n        expect(model.current).toBe(change);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should reset if last char is whitespace && column < original",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#handleTextChange()"
            ],
            "updatePoint": {
                "line": 480,
                "column": 70
            },
            "line": 480,
            "code": "      it('should reset if last char is whitespace && column < original', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo';\n        const newValue = 'foo ';\n        const request = makeState(currentValue);\n        (request as any).column = 3;\n        const change = makeState(newValue);\n        (change as any).column = 0;\n        model.original = request;\n        expect(model.original).toBe(request);\n        model.handleTextChange(change);\n        expect(model.original).toBeNull();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return a patch value",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#createPatch()"
            ],
            "updatePoint": {
                "line": 496,
                "column": 37
            },
            "line": 496,
            "code": "      it('should return a patch value', () => {\n        const model = new CompleterModel();\n        const patch = 'foobar';\n        const want: Completer.IPatch = {\n          start: 0,\n          end: 3,\n          value: patch\n        };\n        const cursor: Completer.ICursorSpan = { start: 0, end: 3 };\n        model.original = makeState('foo');\n        model.cursor = cursor;\n        expect(model.createPatch(patch)).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return undefined if original request or cursor are null",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#createPatch()"
            ],
            "updatePoint": {
                "line": 510,
                "column": 72
            },
            "line": 510,
            "code": "      it('should return undefined if original request or cursor are null', () => {\n        const model = new CompleterModel();\n        expect(model.createPatch('foo')).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should handle line breaks in original value",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#createPatch()"
            ],
            "updatePoint": {
                "line": 515,
                "column": 53
            },
            "line": 515,
            "code": "      it('should handle line breaks in original value', () => {\n        const model = new CompleterModel();\n        const currentValue = 'foo\\nbar';\n        const patch = 'barbaz';\n        const start = currentValue.length;\n        const end = currentValue.length;\n        const want: Completer.IPatch = {\n          start,\n          end,\n          value: patch\n        };\n        const cursor: Completer.ICursorSpan = { start, end };\n        model.original = makeState(currentValue);\n        model.cursor = cursor;\n        expect(model.createPatch(patch)).toEqual(want);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return `undefined` if the completion item list is empty.",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#resolveItem()"
            ],
            "updatePoint": {
                "line": 533,
                "column": 73
            },
            "line": 533,
            "code": "      it('should return `undefined` if the completion item list is empty.', () => {\n        const model = new CompleterModel();\n        expect(model.resolveItem(0)).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return undefined if item index is out of range.",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#resolveItem()"
            ],
            "updatePoint": {
                "line": 538,
                "column": 64
            },
            "line": 538,
            "code": "      it('should return undefined if item index is out of range.', () => {\n        const model = new CompleterModel();\n        model.setCompletionItems([{ label: 'foo' }, { label: 'bar' }]);\n        expect(model.resolveItem(3)).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should return the original item if `resolve` is missing.",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#resolveItem()"
            ],
            "updatePoint": {
                "line": 543,
                "column": 66
            },
            "line": 543,
            "code": "      it('should return the original item if `resolve` is missing.', async () => {\n        const model = new CompleterModel();\n        model.setCompletionItems([{ label: 'foo' }, { label: 'bar' }]);\n        const resolved = await model.resolveItem(0);\n        expect(resolved).toEqual({ label: 'foo' });\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should resolve missing fields and remove the `resolve` function itself",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#resolveItem()"
            ],
            "updatePoint": {
                "line": 549,
                "column": 80
            },
            "line": 549,
            "code": "      it('should resolve missing fields and remove the `resolve` function itself', async () => {\n        const model = new CompleterModel();\n        const item = {\n          label: 'foo',\n          resolve: () =>\n            Promise.resolve({ label: 'foo', documentation: 'Foo docs' })\n        };\n        model.setCompletionItems([item]);\n        const resolved = await model.resolveItem(0);\n        expect(resolved).toEqual({ label: 'foo', documentation: 'Foo docs' });\n        expect(item).toEqual({\n          label: 'foo',\n          documentation: 'Foo docs',\n          resolve: undefined\n        });\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should escape HTML markup",
            "suites": [
                "completer/model",
                "CompleterModel",
                "#resolveItem()"
            ],
            "updatePoint": {
                "line": 565,
                "column": 35
            },
            "line": 565,
            "code": "      it('should escape HTML markup', async () => {\n        let model = new CompleterModel();\n        const item = {\n          label: '<foo></foo>',\n          resolve: () =>\n            Promise.resolve({ label: '<foo></foo>', documentation: 'Foo docs' })\n        };\n        model.setCompletionItems([item]);\n        const resolved = await model.resolveItem(0);\n        expect(resolved).toEqual({\n          label: '&lt;foo&gt;&lt;/foo&gt;',\n          insertText: '<foo></foo>',\n          documentation: 'Foo docs',\n          resolve: undefined\n        });\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/completer/test"
        },
        {
            "name": "should create a new foreign handler",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 150,
                "column": 45
            },
            "line": 150,
            "code": "      it('should create a new foreign handler', () => {\n        expect(handler).toBeInstanceOf(ForeignHandler);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should default to `false`",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#enabled"
            ],
            "updatePoint": {
                "line": 156,
                "column": 35
            },
            "line": 156,
            "code": "      it('should default to `false`', () => {\n        expect(handler.enabled).toBe(false);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should allow foreign cells to be injected if `true`",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#enabled"
            ],
            "updatePoint": {
                "line": 160,
                "column": 61
            },
            "line": 160,
            "code": "      it('should allow foreign cells to be injected if `true`', async () => {\n        handler.enabled = true;\n        let called = false;\n        handler.injected.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should reject foreign cells if `false`",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#enabled"
            ],
            "updatePoint": {
                "line": 171,
                "column": 48
            },
            "line": 171,
            "code": "      it('should reject foreign cells if `false`', async () => {\n        handler.enabled = false;\n        let called = false;\n        handler.rejected.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should indicate whether the handler is disposed",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 184,
                "column": 57
            },
            "line": 184,
            "code": "      it('should indicate whether the handler is disposed', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a client session object",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#session"
            ],
            "updatePoint": {
                "line": 192,
                "column": 43
            },
            "line": 192,
            "code": "      it('should be a client session object', () => {\n        expect(handler.sessionContext.session!.path).toBeTruthy();\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be set upon instantiation",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#parent"
            ],
            "updatePoint": {
                "line": 198,
                "column": 42
            },
            "line": 198,
            "code": "      it('should be set upon instantiation', () => {\n        const parent = new TestParent();\n        handler = new TestHandler({\n          sessionContext: handler.sessionContext,\n          parent\n        });\n        expect(handler.parent).toBe(parent);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should dispose the resources held by the handler",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 209,
                "column": 58
            },
            "line": 209,
            "code": "      it('should dispose the resources held by the handler', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 215,
                "column": 47
            },
            "line": 215,
            "code": "      it('should be safe to call multiple times', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called when messages come through",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#onIOPubMessage()"
            ],
            "updatePoint": {
                "line": 224,
                "column": 53
            },
            "line": 224,
            "code": "      it('should be called when messages come through', async () => {\n        handler.enabled = false;\n        let called = false;\n        handler.received.connect(() => {\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should inject relevant cells into the parent",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#onIOPubMessage()"
            ],
            "updatePoint": {
                "line": 235,
                "column": 54
            },
            "line": 235,
            "code": "      it('should inject relevant cells into the parent', async () => {\n        handler.enabled = true;\n        const parent = handler.parent as TestParent;\n        expect(parent.widgets.length).toBe(0);\n        let called = false;\n        handler.injected.connect(() => {\n          expect(parent.widgets.length).toBeGreaterThan(0);\n          called = true;\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, streamMsg);\n        expect(called).toBe(true);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should not reject relevant iopub messages",
            "suites": [
                "@jupyterlab/console",
                "ForeignHandler",
                "#onIOPubMessage()"
            ],
            "updatePoint": {
                "line": 249,
                "column": 51
            },
            "line": 249,
            "code": "      it('should not reject relevant iopub messages', async () => {\n        let called = false;\n        let errored = false;\n        handler.enabled = true;\n        handler.rejected.connect(() => {\n          errored = true;\n        });\n        handler.received.connect((sender, msg) => {\n          if (KernelMessage.isClearOutputMsg(msg)) {\n            called = true;\n          }\n        });\n        await foreign.session!.kernel!.requestExecute({ code: 'foo' }).done;\n        Mock.emitIopubMessage(foreign, clearMsg);\n        expect(called).toBe(true);\n        expect(errored).toBe(false);\n      });",
            "file": "foreign.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a console history object",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 70,
                "column": 48
            },
            "line": 70,
            "code": "      it('should create a console history object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history).toBeInstanceOf(ConsoleHistory);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should get whether the object is disposed",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 77,
                "column": 51
            },
            "line": 77,
            "code": "      it('should get whether the object is disposed', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be the client session object",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#session"
            ],
            "updatePoint": {
                "line": 86,
                "column": 45
            },
            "line": 86,
            "code": "      it('should be the client session object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.sessionContext).toBe(sessionContext);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should dispose the history object",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 43
            },
            "line": 93,
            "code": "      it('should dispose the history object', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be safe to dispose multiple times",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 50
            },
            "line": 100,
            "code": "      it('should be safe to dispose multiple times', () => {\n        const history = new ConsoleHistory({ sessionContext });\n        expect(history.isDisposed).toBe(false);\n        history.dispose();\n        history.dispose();\n        expect(history.isDisposed).toBe(true);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should return an empty string if no history exists",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#back()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 60
            },
            "line": 110,
            "code": "      it('should return an empty string if no history exists', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const result = await history.back('');\n        expect(result).toBe('');\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should return previous items if they exist",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#back()"
            ],
            "updatePoint": {
                "line": 116,
                "column": 52
            },
            "line": 116,
            "code": "      it('should return previous items if they exist', async () => {\n        const history = new TestHistory({ sessionContext });\n        history.onHistory(mockHistory);\n        const result = await history.back('');\n        if (mockHistory.content.status !== 'ok') {\n          throw new Error('Test history reply is not an \"ok\" reply');\n        }\n        const index = mockHistory.content.history.length - 1;\n        const last = (mockHistory.content.history[index] as any)[2];\n        expect(result).toBe(last);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should return an empty string if no history exists",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#forward()"
            ],
            "updatePoint": {
                "line": 130,
                "column": 60
            },
            "line": 130,
            "code": "      it('should return an empty string if no history exists', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const result = await history.forward('');\n        expect(result).toBe('');\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should return next items if they exist",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#forward()"
            ],
            "updatePoint": {
                "line": 136,
                "column": 48
            },
            "line": 136,
            "code": "      it('should return next items if they exist', async () => {\n        const history = new TestHistory({ sessionContext });\n        history.onHistory(mockHistory);\n        await Promise.all([history.back(''), history.back('')]);\n        const result = await history.forward('');\n        if (mockHistory.content.status !== 'ok') {\n          throw new Error('Test history reply is not an \"ok\" reply');\n        }\n        const index = mockHistory.content.history.length - 1;\n        const last = (mockHistory.content.history[index] as any)[2];\n        expect(result).toBe(last);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should allow addition of history items",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#push()"
            ],
            "updatePoint": {
                "line": 151,
                "column": 48
            },
            "line": 151,
            "code": "      it('should allow addition of history items', async () => {\n        const history = new ConsoleHistory({ sessionContext });\n        const item = 'foo';\n        history.push(item);\n        const result = await history.back('');\n        expect(result).toBe(item);\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called upon an editor text change",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#onTextChange()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 53
            },
            "line": 161,
            "code": "      it('should be called upon an editor text change', () => {\n        const history = new TestHistory({ sessionContext });\n        expect(history.methods).toEqual(\n          expect.not.arrayContaining(['onTextChange'])\n        );\n        const model = new CodeEditor.Model({\n          sharedModel: createStandaloneCell({ cell_type: 'code' })\n        });\n        const host = document.createElement('div');\n        const editor = new CodeMirrorEditor({\n          model,\n          host,\n          extensions: [ybinding({ ytext: (model.sharedModel as any).ysource })]\n        });\n        history.editor = editor;\n        model.sharedModel.setSource('foo');\n        expect(history.methods).toEqual(\n          expect.arrayContaining(['onTextChange'])\n        );\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called upon an editor edge request",
            "suites": [
                "console/history",
                "ConsoleHistory",
                "#onEdgeRequest()"
            ],
            "updatePoint": {
                "line": 184,
                "column": 54
            },
            "line": 184,
            "code": "      it('should be called upon an editor edge request', async () => {\n        const history = new TestHistory({ sessionContext });\n        expect(history.methods).toEqual(\n          expect.not.arrayContaining(['onEdgeRequest'])\n        );\n        const host = document.createElement('div');\n        const model = new CodeEditor.Model({\n          sharedModel: createStandaloneCell({ cell_type: 'code' })\n        });\n        const editor = new CodeMirrorEditor({\n          model,\n          host,\n          extensions: [ybinding({ ytext: (model.sharedModel as any).ysource })]\n        });\n        history.editor = editor;\n        history.push('foo');\n        const promise = signalToPromise(editor.model.sharedModel.changed);\n        editor.edgeRequested.emit('top');\n        expect(history.methods).toEqual(\n          expect.arrayContaining(['onEdgeRequest'])\n        );\n        await promise;\n        expect(editor.model.sharedModel.getSource()).toBe('foo');\n      });",
            "file": "history.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a new console panel",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 59,
                "column": 43
            },
            "line": 59,
            "code": "      it('should create a new console panel', () => {\n        expect(panel).toBeInstanceOf(ConsolePanel);\n        expect(Array.from(panel.node.classList)).toEqual(\n          expect.arrayContaining(['jp-ConsolePanel'])\n        );\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should set the session context path to local path",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 66,
                "column": 59
            },
            "line": 66,
            "code": "      it('should set the session context path to local path', () => {\n        manager.contents.addDrive(new Drive({ name: 'TestDrive' }));\n        const localPath = `${UUID.uuid4()}.txt`;\n        const panel = new TestPanel({\n          manager,\n          contentFactory,\n          rendermime,\n          mimeTypeService,\n          path: `TestDrive:${localPath}`\n        });\n\n        expect(panel.sessionContext.path).toEqual(localPath);\n        panel.dispose();\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a code console widget created at instantiation",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#console"
            ],
            "updatePoint": {
                "line": 83,
                "column": 66
            },
            "line": 83,
            "code": "      it('should be a code console widget created at instantiation', () => {\n        expect(panel.console).toBeInstanceOf(CodeConsole);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a client session object",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#session"
            ],
            "updatePoint": {
                "line": 89,
                "column": 43
            },
            "line": 89,
            "code": "      it('should be a client session object', () => {\n        expect(panel.sessionContext.kernelChanged).toBeTruthy();\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should dispose of the resources held by the panel",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 59
            },
            "line": 95,
            "code": "      it('should dispose of the resources held by the panel', () => {\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should start the session",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 34
            },
            "line": 104,
            "code": "      it('should start the session', async () => {\n        Widget.attach(panel, document.body);\n        await panel.sessionContext.ready;\n        await expect(\n          panel.sessionContext.session!.kernel!.info\n        ).resolves.not.toThrow();\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should give the focus to the console prompt",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 114,
                "column": 53
            },
            "line": 114,
            "code": "      it('should give the focus to the console prompt', () => {\n        Widget.attach(panel, document.body);\n        MessageLoop.sendMessage(panel, Widget.Msg.ActivateRequest);\n        expect(panel.console.promptCell!.editor!.hasFocus()).toBe(true);\n        return dismissDialog();\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should dispose of the panel resources after closing",
            "suites": [
                "console/panel",
                "ConsolePanel",
                "#onCloseRequest()"
            ],
            "updatePoint": {
                "line": 123,
                "column": 61
            },
            "line": 123,
            "code": "      it('should dispose of the panel resources after closing', () => {\n        Widget.attach(panel, document.body);\n        expect(panel.isDisposed).toBe(false);\n        MessageLoop.sendMessage(panel, Widget.Msg.CloseRequest);\n        expect(panel.isDisposed).toBe(true);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a new code console factory",
            "suites": [
                "console/panel",
                "ConsolePanel",
                ".ContentFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 133,
                "column": 52
            },
            "line": 133,
            "code": "        it('should create a new code console factory', () => {\n          const factory = new ConsolePanel.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(ConsolePanel.ContentFactory);\n        });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a console widget",
            "suites": [
                "console/panel",
                "ConsolePanel",
                ".ContentFactory",
                "#createConsole()"
            ],
            "updatePoint": {
                "line": 140,
                "column": 42
            },
            "line": 140,
            "code": "        it('should create a console widget', () => {\n          const options = {\n            contentFactory: contentFactory,\n            rendermime,\n            mimeTypeService,\n            sessionContext: panel.sessionContext\n          };\n          expect(contentFactory.createConsole(options)).toBeInstanceOf(\n            CodeConsole\n          );\n        });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a new console content widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 71,
                "column": 52
            },
            "line": 71,
            "code": "      it('should create a new console content widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget).toBeInstanceOf(CodeConsole);\n        expect(Array.from(widget.node.classList)).toEqual(\n          expect.arrayContaining(['jp-CodeConsole'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should exist upon instantiation",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#cells"
            ],
            "updatePoint": {
                "line": 81,
                "column": 41
            },
            "line": 81,
            "code": "      it('should exist upon instantiation', () => {\n        expect(widget.cells).toBeTruthy();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should reflect the contents of the widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#cells"
            ],
            "updatePoint": {
                "line": 85,
                "column": 51
            },
            "line": 85,
            "code": "      it('should reflect the contents of the widget', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBe(1);\n        widget.clear();\n        expect(widget.cells.length).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should emit a date upon execution",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#executed"
            ],
            "updatePoint": {
                "line": 97,
                "column": 43
            },
            "line": 97,
            "code": "      it('should emit a date upon execution', async () => {\n        let called: Date | null = null;\n        const force = true;\n        Widget.attach(widget, document.body);\n        widget.executed.connect((sender, time) => {\n          called = time;\n        });\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(called).toBeInstanceOf(Date);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a code cell widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#promptCell"
            ],
            "updatePoint": {
                "line": 111,
                "column": 38
            },
            "line": 111,
            "code": "      it('should be a code cell widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be replaced after execution",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#promptCell"
            ],
            "updatePoint": {
                "line": 116,
                "column": 44
            },
            "line": 116,
            "code": "      it('should be replaced after execution', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n\n        const old = widget.promptCell;\n        expect(old).toBeInstanceOf(CodeCell);\n\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n        expect(widget.promptCell).not.toBe(old);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a client session object",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#session"
            ],
            "updatePoint": {
                "line": 131,
                "column": 43
            },
            "line": 131,
            "code": "      it('should be a client session object', () => {\n        expect(widget.sessionContext.sessionChanged).toBeTruthy();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be the content factory used by the widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#contentFactory"
            ],
            "updatePoint": {
                "line": 137,
                "column": 58
            },
            "line": 137,
            "code": "      it('should be the content factory used by the widget', () => {\n        expect(widget.contentFactory).toBeInstanceOf(\n          CodeConsole.ContentFactory\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should add a code cell to the content widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#addCell()"
            ],
            "updatePoint": {
                "line": 145,
                "column": 54
            },
            "line": 145,
            "code": "      it('should add a code cell to the content widget', () => {\n        const contentFactory = NBTestUtils.createCodeCellFactory();\n        const model = new CodeCellModel();\n        const cell = new CodeCell({\n          model,\n          contentFactory,\n          rendermime\n        }).initializeState();\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        widget.addCell(cell);\n        expect(widget.cells.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should clear all of the content cells except the banner",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#clear()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 65
            },
            "line": 161,
            "code": "      it('should clear all of the content cells except the banner', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBeGreaterThan(0);\n        widget.clear();\n        expect(widget.cells.length).toBe(0);\n        expect(widget.promptCell!.model.sharedModel.getSource()).toBe('');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should dispose the content widget",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 174,
                "column": 43
            },
            "line": 174,
            "code": "      it('should dispose the content widget', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be safe to dispose multiple times",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 181,
                "column": 50
            },
            "line": 181,
            "code": "      it('should be safe to dispose multiple times', () => {\n        Widget.attach(widget, document.body);\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should execute contents of the prompt if forced",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#execute()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 57
            },
            "line": 191,
            "code": "      it('should execute contents of the prompt if forced', async () => {\n        const force = true;\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n        expect(widget.cells.length).toBeGreaterThan(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should check if code is multiline and allow amending",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#execute()"
            ],
            "updatePoint": {
                "line": 200,
                "column": 62
            },
            "line": 200,
            "code": "      it('should check if code is multiline and allow amending', async () => {\n        const force = false;\n        const timeout = 9000;\n        Widget.attach(widget, document.body);\n        widget.promptCell!.model.sharedModel.setSource('for x in range(5):');\n        expect(widget.cells.length).toBe(0);\n        const session = widget.sessionContext as SessionContext;\n        session.kernelPreference = { name: 'ipython' };\n        await session.initialize();\n        await widget.execute(force, timeout);\n        expect(widget.cells.length).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should add a code cell and execute it",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#inject()"
            ],
            "updatePoint": {
                "line": 215,
                "column": 47
            },
            "line": 215,
            "code": "      it('should add a code cell and execute it', async () => {\n        const code = 'print(\"#inject()\")';\n        Widget.attach(widget, document.body);\n        expect(widget.cells.length).toBe(0);\n        await widget.inject(code);\n        expect(widget.cells.length).toBeGreaterThan(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should insert a line break into the prompt",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#insertLinebreak()"
            ],
            "updatePoint": {
                "line": 225,
                "column": 52
            },
            "line": 225,
            "code": "      it('should insert a line break into the prompt', () => {\n        Widget.attach(widget, document.body);\n\n        const model = widget.promptCell!.model;\n        expect(model.sharedModel.getSource()).toHaveLength(0);\n        widget.insertLinebreak();\n        expect(model.sharedModel.getSource()).toBe('\\n');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should serialize the contents of a console",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#serialize()"
            ],
            "updatePoint": {
                "line": 236,
                "column": 52
            },
            "line": 236,
            "code": "      it('should serialize the contents of a console', () => {\n        Widget.attach(widget, document.body);\n        widget.promptCell!.model.sharedModel.setSource('foo');\n\n        const serialized = widget.serialize();\n        expect(serialized).toHaveLength(1);\n        expect(serialized[0].source).toBe('foo');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called after attach, creating a prompt",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#newPromptCell()"
            ],
            "updatePoint": {
                "line": 247,
                "column": 58
            },
            "line": 247,
            "code": "      it('should be called after attach, creating a prompt', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['newPromptCell'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n        expect(widget.promptCell).toBeTruthy();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called after execution, creating a prompt",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#newPromptCell()"
            ],
            "updatePoint": {
                "line": 259,
                "column": 61
            },
            "line": 259,
            "code": "      it('should be called after execution, creating a prompt', async () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['newPromptCell'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n\n        const old = widget.promptCell;\n        const force = true;\n        expect(old).toBeInstanceOf(CodeCell);\n        widget.methods = [];\n\n        await (widget.sessionContext as SessionContext).initialize();\n        await widget.execute(force);\n\n        expect(widget.promptCell).toBeInstanceOf(CodeCell);\n        expect(widget.promptCell).not.toBe(old);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['newPromptCell'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should focus the prompt editor",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 286,
                "column": 40
            },
            "line": 286,
            "code": "      it('should focus the prompt editor', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onActivateRequest'])\n        );\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onActivateRequest'])\n        );\n        expect(widget.promptCell!.editor!.hasFocus()).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be called after attach, creating a prompt",
            "suites": [
                "console/widget",
                "CodeConsole",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 301,
                "column": 58
            },
            "line": 301,
            "code": "      it('should be called after attach, creating a prompt', () => {\n        expect(widget.promptCell).toBeFalsy();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onAfterAttach'])\n        );\n        Widget.attach(widget, document.body);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        expect(widget.promptCell).toBeTruthy();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a new ContentFactory",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ContentFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 316,
                "column": 46
            },
            "line": 316,
            "code": "        it('should create a new ContentFactory', () => {\n          const factory = new CodeConsole.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(CodeConsole.ContentFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a code cell",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ContentFactory",
                "#createCodeCell"
            ],
            "updatePoint": {
                "line": 323,
                "column": 37
            },
            "line": 323,
            "code": "        it('should create a code cell', () => {\n          const model = new CodeCellModel();\n          const prompt = contentFactory.createCodeCell({\n            rendermime: widget.rendermime,\n            model,\n            contentFactory\n          });\n          expect(prompt).toBeInstanceOf(CodeCell);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a foreign cell",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ContentFactory",
                "#createRawCell"
            ],
            "updatePoint": {
                "line": 335,
                "column": 40
            },
            "line": 335,
            "code": "        it('should create a foreign cell', () => {\n          const model = new RawCellModel();\n          const prompt = contentFactory.createRawCell({\n            model,\n            contentFactory\n          });\n          expect(prompt).toBeInstanceOf(RawCell);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a new model factory",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ModelFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 348,
                "column": 45
            },
            "line": 348,
            "code": "        it('should create a new model factory', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory).toBeInstanceOf(CodeConsole.ModelFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should accept a codeCellContentFactory",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ModelFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 353,
                "column": 50
            },
            "line": 353,
            "code": "        it('should accept a codeCellContentFactory', () => {\n          const codeCellContentFactory = new CodeCellModel.ContentFactory();\n          const factory = new CodeConsole.ModelFactory({\n            codeCellContentFactory\n          });\n          expect(factory.codeCellContentFactory).toBe(codeCellContentFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be the code cell content factory used by the factory",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ModelFactory",
                "#codeCellContentFactory"
            ],
            "updatePoint": {
                "line": 363,
                "column": 71
            },
            "line": 363,
            "code": "        it('should be the code cell content factory used by the factory', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory.codeCellContentFactory).toBe(\n            CodeCellModel.defaultContentFactory\n          );\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a code cell",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ModelFactory",
                "#createCodeCell()"
            ],
            "updatePoint": {
                "line": 372,
                "column": 37
            },
            "line": 372,
            "code": "        it('should create a code cell', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(\n            factory.createCodeCell({\n              sharedModel: createStandaloneCell({\n                cell_type: 'code'\n              }) as YCodeCell\n            })\n          ).toBeInstanceOf(CodeCellModel);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should create a raw cell model",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".ModelFactory",
                "#createRawCell()"
            ],
            "updatePoint": {
                "line": 385,
                "column": 42
            },
            "line": 385,
            "code": "        it('should create a raw cell model', () => {\n          const factory = new CodeConsole.ModelFactory({});\n          expect(factory.createRawCell({})).toBeInstanceOf(RawCellModel);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should be a ModelFactory",
            "suites": [
                "console/widget",
                "CodeConsole",
                ".defaultModelFactory"
            ],
            "updatePoint": {
                "line": 393,
                "column": 34
            },
            "line": 393,
            "code": "      it('should be a ModelFactory', () => {\n        expect(CodeConsole.defaultModelFactory).toBeInstanceOf(\n          CodeConsole.ModelFactory\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/console/test"
        },
        {
            "name": "should accept a signal",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 32
            },
            "line": 25,
            "code": "      it('should accept a signal', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor).toBeInstanceOf(ActivityMonitor);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should accept a timeout",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 30,
                "column": 33
            },
            "line": 30,
            "code": "      it('should accept a timeout', () => {\n        const monitor = new ActivityMonitor<TestObject, string[]>({\n          signal: testObj.two,\n          timeout: 100\n        });\n        expect(monitor).toBeInstanceOf(ActivityMonitor);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should be emitted after the signal has fired and a timeout",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#activityStopped"
            ],
            "updatePoint": {
                "line": 40,
                "column": 68
            },
            "line": 40,
            "code": "      it('should be emitted after the signal has fired and a timeout', async () => {\n        let called = false;\n        const monitor = new ActivityMonitor({ signal, timeout: 100 });\n        monitor.activityStopped.connect((sender, args) => {\n          expect(sender).toBe(monitor);\n          expect(args.sender).toBe(testObj);\n          expect(args.args).toBe(10);\n          called = true;\n        });\n        signal.emit(10);\n        expect(called).toBe(false);\n        await sleep(100);\n        expect(called).toBe(true);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should default to `1000`",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#timeout"
            ],
            "updatePoint": {
                "line": 57,
                "column": 34
            },
            "line": 57,
            "code": "      it('should default to `1000`', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor.timeout).toBe(1000);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should be set-able",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#timeout"
            ],
            "updatePoint": {
                "line": 62,
                "column": 28
            },
            "line": 62,
            "code": "      it('should be set-able', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.timeout = 200;\n        expect(monitor.timeout).toBe(200);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should test whether the monitor is disposed",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 70,
                "column": 53
            },
            "line": 70,
            "code": "      it('should test whether the monitor is disposed', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        expect(monitor.isDisposed).toBe(false);\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should dispose of the resources used by the monitor",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 79,
                "column": 61
            },
            "line": 79,
            "code": "      it('should dispose of the resources used by the monitor', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should be a no-op if called more than once",
            "suites": [
                "@jupyterlab/coreutils",
                "ActivityMonitor()",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 52
            },
            "line": 85,
            "code": "      it('should be a no-op if called more than once', () => {\n        const monitor = new ActivityMonitor<TestObject, number>({ signal });\n        monitor.dispose();\n        monitor.dispose();\n        expect(monitor.isDisposed).toBe(true);\n      });",
            "file": "activitymonitor.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return true for a valid markdown extension",
            "suites": [
                "@jupyterlab/coreutils",
                "MarkdownCodeBlocks",
                ".isMarkdown()"
            ],
            "updatePoint": {
                "line": 15,
                "column": 59
            },
            "line": 15,
            "code": "      it('should return true for a valid markdown extension', () => {\n        const isMarkdown = MarkdownCodeBlocks.isMarkdown('.md');\n        expect(isMarkdown).toBe(true);\n      });",
            "file": "markdowncodeblocks.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should find a simple block",
            "suites": [
                "@jupyterlab/coreutils",
                "MarkdownCodeBlocks",
                ".findMarkdownCodeBlocks()"
            ],
            "updatePoint": {
                "line": 22,
                "column": 36
            },
            "line": 22,
            "code": "      it('should find a simple block', () => {\n        const codeblocks =\n          MarkdownCodeBlocks.findMarkdownCodeBlocks(MULTI_LINE_BLOCK);\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10\\nb = 20\\n');\n      });",
            "file": "markdowncodeblocks.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should find a single line block",
            "suites": [
                "@jupyterlab/coreutils",
                "MarkdownCodeBlocks",
                ".findMarkdownCodeBlocks()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 41
            },
            "line": 29,
            "code": "      it('should find a single line block', () => {\n        const codeblocks =\n          MarkdownCodeBlocks.findMarkdownCodeBlocks(SINGLE_LINE_BLOCK);\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10');\n      });",
            "file": "markdowncodeblocks.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should find a block with a language",
            "suites": [
                "@jupyterlab/coreutils",
                "MarkdownCodeBlocks",
                ".findMarkdownCodeBlocks()"
            ],
            "updatePoint": {
                "line": 36,
                "column": 45
            },
            "line": 36,
            "code": "      it('should find a block with a language', () => {\n        const codeblocks = MarkdownCodeBlocks.findMarkdownCodeBlocks(\n          MULTI_LINE_BLOCK_WITH_LANGUAGE\n        );\n        expect(codeblocks.length).toBe(1);\n        expect(codeblocks[0].code).toBe('a = 10\\nb = 20\\n');\n      });",
            "file": "markdowncodeblocks.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get a known option",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getOption()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 35
            },
            "line": 14,
            "code": "      it('should get a known option', () => {\n        expect(PageConfig.getOption('foo')).toBe('bar');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return an empty string for an unknown option",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getOption()"
            ],
            "updatePoint": {
                "line": 18,
                "column": 61
            },
            "line": 18,
            "code": "      it('should return an empty string for an unknown option', () => {\n        expect(PageConfig.getOption('bar')).toBe('');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get last option value and set it to the passed value",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 69
            },
            "line": 24,
            "code": "      it('should get last option value and set it to the passed value', () => {\n        expect(PageConfig.setOption('foo', 'bar1')).toBe('bar');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get a known option",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 28,
                "column": 35
            },
            "line": 28,
            "code": "      it('should get a known option', () => {\n        expect(PageConfig.getOption('foo')).toBe('bar');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should add a new option",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 33
            },
            "line": 32,
            "code": "      it('should add a new option', () => {\n        expect(PageConfig.setOption('bar', 'foo')).toBe('');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get a different known option",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#setOption()"
            ],
            "updatePoint": {
                "line": 36,
                "column": 45
            },
            "line": 36,
            "code": "      it('should get a different known option', () => {\n        expect(PageConfig.getOption('bar')).toBe('foo');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get the base url of the page",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getBaseUrl()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 45
            },
            "line": 42,
            "code": "      it('should get the base url of the page', () => {\n        // The value was passed as a command line arg.\n        expect(PageConfig.getBaseUrl()).toContain('http://localhost');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get the base ws url of the page",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getWsUrl()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 48
            },
            "line": 49,
            "code": "      it('should get the base ws url of the page', () => {\n        // The value was passed as a command line arg.\n        const expected = 'ws' + PageConfig.getBaseUrl().slice(4);\n        expect(PageConfig.getWsUrl()).toBe(expected);\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle a good base url",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getWsUrl()"
            ],
            "updatePoint": {
                "line": 55,
                "column": 39
            },
            "line": 55,
            "code": "      it('should handle a good base url', () => {\n        const url = 'http://foo.com';\n        expect(PageConfig.getWsUrl(url)).toBe('ws://foo.com/');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should be an empty string for a bad base url",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getWsUrl()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 54
            },
            "line": 60,
            "code": "      it('should be an empty string for a bad base url', () => {\n        const url = 'blargh://foo.com';\n        expect(PageConfig.getWsUrl(url)).toBe('');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return shortest url by default",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getUrl()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 47
            },
            "line": 69,
            "code": "      it('should return shortest url by default', () => {\n        const url = PageConfig.getUrl({});\n        expect(url).toEqual('http://localhost/lab');\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return a local shareable url if shareUrl is undefined",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getUrl()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 70
            },
            "line": 74,
            "code": "      it('should return a local shareable url if shareUrl is undefined', () => {\n        const url = PageConfig.getUrl({\n          workspace: PageConfig.defaultWorkspace,\n          treePath: path,\n          toShare: true\n        });\n\n        expect(url).toEqual(`http://localhost/lab/tree${path}`);\n      });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return a non-local shareable url if shareUrl is defined",
            "suites": [
                "@jupyterlab/coreutils",
                "PageConfig",
                "#getUrl()",
                "hub environment"
            ],
            "updatePoint": {
                "line": 91,
                "column": 74
            },
            "line": 91,
            "code": "        it('should return a non-local shareable url if shareUrl is defined', () => {\n          const url = PageConfig.getUrl({\n            workspace: PageConfig.defaultWorkspace,\n            treePath: path,\n            toShare: true\n          });\n\n          expect(url).toEqual(`${shareUrl}/lab/tree${path}`);\n        });",
            "file": "pageconfig.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should join the arguments and normalize the path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".join()"
            ],
            "updatePoint": {
                "line": 11,
                "column": 58
            },
            "line": 11,
            "code": "      it('should join the arguments and normalize the path', () => {\n        const path = PathExt.join('foo', '../../../bar');\n        expect(path).toBe('../../bar');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should not return \".\" for an empty path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".join()"
            ],
            "updatePoint": {
                "line": 16,
                "column": 49
            },
            "line": 16,
            "code": "      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.join('', '');\n        expect(path).toBe('');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return the last portion of a path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".basename()"
            ],
            "updatePoint": {
                "line": 23,
                "column": 50
            },
            "line": 23,
            "code": "      it('should return the last portion of a path', () => {\n        expect(PathExt.basename(TESTPATH)).toBe('test-path.js');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get the directory name of a path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".dirname()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 49
            },
            "line": 29,
            "code": "      it('should get the directory name of a path', () => {\n        expect(PathExt.dirname(TESTPATH)).toBe('foo/test/simple');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should not return \".\" for an empty path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".dirname()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 49
            },
            "line": 33,
            "code": "      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.dirname('');\n        expect(path).toBe('');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should not return \".\" for a path in the root directory",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".dirname()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 64
            },
            "line": 38,
            "code": "      it('should not return \".\" for a path in the root directory', () => {\n        const path = PathExt.dirname('foo.txt');\n        expect(path).toBe('');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should get the file extension of the path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".extname()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 51
            },
            "line": 45,
            "code": "      it('should get the file extension of the path', () => {\n        expect(PathExt.extname(TESTPATH)).toBe('.js');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should only take the last occurrence of a dot",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".extname()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 55
            },
            "line": 49,
            "code": "      it('should only take the last occurrence of a dot', () => {\n        expect(PathExt.extname('foo.tar.gz')).toBe('.gz');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should normalize a string path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 55,
                "column": 40
            },
            "line": 55,
            "code": "      it('should normalize a string path', () => {\n        const path = PathExt.normalize('./fixtures///b/../b/c.js');\n        expect(path).toBe('fixtures/b/c.js');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should not return \".\" for an empty path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 49
            },
            "line": 60,
            "code": "      it('should not return \".\" for an empty path', () => {\n        const path = PathExt.normalize('');\n        expect(path).toBe('');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should resolve a sequence of paths to an absolute path on the server",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".resolve()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 78
            },
            "line": 67,
            "code": "      it('should resolve a sequence of paths to an absolute path on the server', () => {\n        const path = PathExt.resolve('var/src', '../', 'file/');\n        expect(path.indexOf('var/file')).not.toBe(-1);\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should solve the relative path",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".relative()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 40
            },
            "line": 74,
            "code": "      it('should solve the relative path', () => {\n        const path = PathExt.relative('var/src', 'var/apache');\n        expect(path).toBe('../apache');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should normalize a file extension to be of type `.foo`",
            "suites": [
                "@jupyterlab/coreutils",
                "PathExt",
                ".normalizeExtension()"
            ],
            "updatePoint": {
                "line": 81,
                "column": 64
            },
            "line": 81,
            "code": "      it('should normalize a file extension to be of type `.foo`', () => {\n        expect(PathExt.normalizeExtension('foo')).toBe('.foo');\n        expect(PathExt.normalizeExtension('.bar')).toBe('.bar');\n      });",
            "file": "path.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should convert a time to a human readable string",
            "suites": [
                "@jupyterlab/coreutils",
                "Time",
                ".formatHuman()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 58
            },
            "line": 9,
            "code": "      it('should convert a time to a human readable string', () => {\n        const date = new Date();\n        date.setSeconds(date.getSeconds() - 10);\n        const value = Time.formatHuman(date);\n        expect(value).toContain('seconds ago');\n        date.setMinutes(date.getMinutes() - 3);\n        expect(Time.formatHuman(date.toISOString())).toBe('3 minutes ago');\n      });",
            "file": "time.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should parse a url into a URLExt object",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".parse()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 49
            },
            "line": 9,
            "code": "      it('should parse a url into a URLExt object', () => {\n        const obj = URLExt.parse('http://www.example.com');\n        expect(obj.href).toBe('http://www.example.com/');\n        expect(obj.protocol).toBe('http:');\n        expect(obj.host).toBe('www.example.com');\n        expect(obj.hostname).toBe('www.example.com');\n        expect(obj.pathname).toBe('/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle query and hash",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".parse()"
            ],
            "updatePoint": {
                "line": 18,
                "column": 38
            },
            "line": 18,
            "code": "      it('should handle query and hash', () => {\n        const url = \"http://example.com/path?that's#all, folks\";\n        const obj = URLExt.parse(url);\n        // Chrome has a different href\n        expect([\n          'http://example.com/path?that%27s#all,%20folks',\n          'http://example.com/path?that%27s#all, folks'\n        ]).toContain(obj.href);\n        expect(obj.protocol).toBe('http:');\n        expect(obj.host).toBe('example.com');\n        expect(obj.hostname).toBe('example.com');\n        expect(obj.search).toBe('?that%27s');\n        expect(obj.pathname).toBe('/path');\n        // Chrome has a different hash\n        expect(['#all,%20folks', '#all, folks']).toContain(obj.hash);\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should join a sequence of url components",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".join()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 50
            },
            "line": 37,
            "code": "      it('should join a sequence of url components', () => {\n        expect(URLExt.join('/foo/', 'bar/')).toBe('/foo/bar/');\n        expect(URLExt.join('//example.com', 'bar/')).toBe('//example.com/bar/');\n        expect(URLExt.join('//example.com', 'foo:bar/')).toBe(\n          '//example.com/foo:bar/'\n        );\n        expect(URLExt.join('http://www.example.com/', '/bar')).toBe(\n          'http://www.example.com/bar'\n        );\n        expect(URLExt.join('http://user:pass@www.example.com/', '/bar')).toBe(\n          'http://user:pass@www.example.com/bar'\n        );\n        expect(URLExt.join('//example.com', 'foo:bar:', 'baz')).toBe(\n          '//example.com/foo:bar:/baz'\n        );\n        expect(URLExt.join('http://example.com', 'foo:bar:', 'baz')).toBe(\n          'http://example.com/foo:bar:/baz'\n        );\n        expect(\n          URLExt.join('http://example.com', 'foo', '..', '..', 'bar/')\n        ).toBe('http://example.com/bar/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should encode and join a sequence of url components",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".encodeParts()"
            ],
            "updatePoint": {
                "line": 62,
                "column": 61
            },
            "line": 62,
            "code": "      it('should encode and join a sequence of url components', () => {\n        expect(URLExt.encodeParts('>/>')).toBe('%3E/%3E');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle leading slash",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 68,
                "column": 37
            },
            "line": 68,
            "code": "      it('should handle leading slash', () => {\n        expect(URLExt.normalize('/')).toBe(location.origin + '/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle leading double slash",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 72,
                "column": 44
            },
            "line": 72,
            "code": "      it('should handle leading double slash', () => {\n        expect(URLExt.normalize('//foo')).toBe(location.protocol + '//foo/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle http",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 28
            },
            "line": 76,
            "code": "      it('should handle http', () => {\n        expect(URLExt.normalize('http://foo')).toBe('http://foo/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should handle other",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 80,
                "column": 29
            },
            "line": 80,
            "code": "      it('should handle other', () => {\n        expect(URLExt.normalize('ftp://foo')).toBe('ftp://foo/');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should return a serialized object string suitable for a query",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                "objectToQueryString()"
            ],
            "updatePoint": {
                "line": 86,
                "column": 71
            },
            "line": 86,
            "code": "      it('should return a serialized object string suitable for a query', () => {\n        const obj = {\n          name: 'foo',\n          id: 'baz'\n        };\n        expect(URLExt.objectToQueryString(obj)).toBe('?name=foo&id=baz');\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should test whether the url is a local url",
            "suites": [
                "@jupyterlab/coreutils",
                "URLExt",
                ".isLocal()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 52
            },
            "line": 96,
            "code": "      it('should test whether the url is a local url', () => {\n        expect(URLExt.isLocal('https://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('http://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('//foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('file://foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('data:text/plain,123ABC')).toBe(false);\n        expect(URLExt.isLocal('/foo/bar.txt')).toBe(false);\n        expect(URLExt.isLocal('httpserver/index.html')).toBe(true);\n        expect(URLExt.isLocal('../foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('./foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('foo/bar.txt')).toBe(true);\n        expect(URLExt.isLocal('bar.txt')).toBe(true);\n      });",
            "file": "url.spec.ts",
            "skipped": false,
            "dir": "packages/coreutils/test"
        },
        {
            "name": "should instantiate a `DSVModel`",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 88,
                "column": 41
            },
            "line": 88,
            "code": "      it('should instantiate a `DSVModel`', () => {\n        const d = new DSVModel({ data: 'a,b,c\\nd,e,f\\n', delimiter: ',' });\n        expect(d.rowCount('column-header')).toBe(1);\n        expect(d.rowCount('body')).toBe(1);\n        expect(d.columnCount('row-header')).toBe(1);\n        expect(d.columnCount('body')).toBe(3);\n        expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n          'a',\n          'b',\n          'c'\n        ]);\n        expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n          'd',\n          'e',\n          'f'\n        ]);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "parses a number of test files correctly",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 107,
                "column": 47
            },
            "line": 107,
            "code": "    it('parses a number of test files correctly', () => {\n      for (const [, csv, answer] of CSV_TEST_FILES) {\n        const d = new DSVModel({ data: csv, delimiter: ',' });\n        const labels = [];\n        for (let i = 0; i < d.columnCount('body'); i++) {\n          labels.push(d.data('column-header', 0, i));\n        }\n        const values = [];\n        for (let r = 0; r < d.rowCount('body'); r++) {\n          const row: { [key: string]: string } = {};\n          for (let c = 0; c < d.columnCount('body'); c++) {\n            row[labels[c]] = d.data('body', r, c);\n          }\n          values.push(row);\n        }\n        expect(values).toEqual(answer);\n      }\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles tab-separated data",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 126,
                "column": 34
            },
            "line": 126,
            "code": "    it('handles tab-separated data', () => {\n      const d = new DSVModel({ data: 'a\\tb\\tc\\nd\\te\\tf\\n', delimiter: '\\t' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles not having a header",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 140,
                "column": 35
            },
            "line": 140,
            "code": "    it('handles not having a header', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\nd,e,f\\n',\n        delimiter: ',',\n        header: false\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(2);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        '1',\n        '2',\n        '3'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['a', 'b', 'c']);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles having only a header",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 159,
                "column": 36
            },
            "line": 159,
            "code": "    it('handles having only a header', () => {\n      const d = new DSVModel({ data: 'a,b,c\\n', delimiter: ',', header: true });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(0);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles single non-header line",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 38
            },
            "line": 172,
            "code": "    it('handles single non-header line', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\n',\n        delimiter: ',',\n        header: false\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        '1',\n        '2',\n        '3'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['a', 'b', 'c']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles CRLF row delimiter",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 190,
                "column": 34
            },
            "line": 190,
            "code": "    it('handles CRLF row delimiter', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\r\\nd,e,f\\r\\n',\n        delimiter: ',',\n        rowDelimiter: '\\r\\n'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles CR row delimiter",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 208,
                "column": 32
            },
            "line": 208,
            "code": "    it('handles CR row delimiter', () => {\n      const d = new DSVModel({\n        data: 'a,b,c\\rd,e,f\\r',\n        delimiter: ',',\n        rowDelimiter: '\\r'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "can guess the row delimiter",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 226,
                "column": 35
            },
            "line": 226,
            "code": "    it('can guess the row delimiter', () => {\n      const d = new DSVModel({ data: 'a,b,c\\rd,e,f\\r', delimiter: ',' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a given quote character",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 240,
                "column": 39
            },
            "line": 240,
            "code": "    it('handles a given quote character', () => {\n      const d = new DSVModel({\n        data: `a,'b','c'\\r'd',e,'f'\\r`,\n        delimiter: ',',\n        quote: `'`\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['d', 'e', 'f']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles delimiters and quotes inside quotes",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 258,
                "column": 51
            },
            "line": 258,
            "code": "    it('handles delimiters and quotes inside quotes', () => {\n      const d = new DSVModel({\n        data: `'a\\rx',b,'c''x'\\r'd,x',e,'f'\\r`,\n        delimiter: ',',\n        quote: `'`,\n        rowDelimiter: '\\r'\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a\\rx',\n        'b',\n        `c'x`\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        'd,x',\n        'e',\n        'f'\n      ]);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles rows that are too short or too long",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 281,
                "column": 51
            },
            "line": 281,
            "code": "    it('handles rows that are too short or too long', () => {\n      const d = new DSVModel({ data: `a,b,c\\n,c,d,e,f\\ng,h`, delimiter: ',' });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(2);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        '',\n        'c',\n        'd,e,f'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['g', 'h', '']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles delayed parsing of rows past the initial rows",
            "suites": [
                "csvviewer/model",
                "DSVModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 300,
                "column": 61
            },
            "line": 300,
            "code": "    it('handles delayed parsing of rows past the initial rows', async () => {\n      const d = new DSVModel({\n        data: `a,b,c\\nc,d,e\\nf,g,h\\ni,j,k`,\n        delimiter: ',',\n        initialRows: 2\n      });\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(1);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n\n      // Expected behavior is that all unparsed data is lumped into the final field.\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual([\n        'c',\n        'd',\n        'e\\nf,g,h\\ni,j,k'\n      ]);\n\n      // Check everything is in order after all the data has been parsed asynchronously.\n      await d.ready;\n      expect(d.rowCount('column-header')).toBe(1);\n      expect(d.rowCount('body')).toBe(3);\n      expect(d.columnCount('row-header')).toBe(1);\n      expect(d.columnCount('body')).toBe(3);\n      expect([0, 1, 2].map(i => d.data('column-header', 0, i))).toEqual([\n        'a',\n        'b',\n        'c'\n      ]);\n      expect([0, 1, 2].map(i => d.data('body', 0, i))).toEqual(['c', 'd', 'e']);\n      expect([0, 1, 2].map(i => d.data('body', 1, i))).toEqual(['f', 'g', 'h']);\n      expect([0, 1, 2].map(i => d.data('body', 2, i))).toEqual(['i', 'j', 'k']);\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "does basic parsing of csv files",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 8,
                "column": 39
            },
            "line": 8,
            "code": "    it('does basic parsing of csv files', () => {\n      const data = `a,b,c,d\\r\\n0,1,2,3\\r\\n4,5,6,7`;\n      const options = { data };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([0, 9, 18]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 9, 11, 13, 15, 18, 20, 22, 24\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles trailing row delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 28,
                "column": 38
            },
            "line": 28,
            "code": "    it('handles trailing row delimiter', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles single-line data",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 45,
                "column": 32
            },
            "line": 45,
            "code": "    it('handles single-line data', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles changing the field delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 60,
                "column": 44
            },
            "line": 60,
            "code": "    it('handles changing the field delimiter', () => {\n      const data = `a\\tb\\tc\\td\\n0\\t1\\t2\\t3\\n4\\t5\\t6\\t7\\n`;\n      const options = { data, delimiter: '\\t', rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles starting on a new row",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 77,
                "column": 37
            },
            "line": 77,
            "code": "    it('handles starting on a new row', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14, 16, 18, 20, 22]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a max row argument",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 92,
                "column": 34
            },
            "line": 92,
            "code": "    it('handles a max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', maxRows: 2 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 8, 10, 12, 14]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a start index and max row argument",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 107,
                "column": 50
            },
            "line": 107,
            "code": "    it('handles a start index and max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8, maxRows: 1 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match first row by default",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 122,
                "column": 53
            },
            "line": 122,
            "code": "    it('adjusts columns to match first row by default', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 10, 10, 11, 13, 15, 17\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match first row by default with CRLF row delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 139,
                "column": 77
            },
            "line": 139,
            "code": "    it('adjusts columns to match first row by default with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 9, 11, 11, 11, 13, 15, 17, 19\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 156,
                "column": 38
            },
            "line": 156,
            "code": "    it('adjusts columns to match ncols', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 7, 8, 10, 10, 10, 10, 11, 13, 15, 17, 19\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with CRLF row delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 173,
                "column": 62
            },
            "line": 173,
            "code": "    it('adjusts columns to match ncols with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 7, 9, 11, 11, 11, 11, 13, 15, 17, 19, 21\n      ]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with one row",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 190,
                "column": 51
            },
            "line": 190,
            "code": "    it('adjusts columns to match ncols with one row', () => {\n      const data = `a,b,c,d`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with one row and trailing delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 205,
                "column": 74
            },
            "line": 205,
            "code": "    it('adjusts columns to match ncols with one row and trailing delimiter', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a single row delimiter",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 220,
                "column": 38
            },
            "line": 220,
            "code": "    it('handles a single row delimiter', () => {\n      const data = `\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles adding columns or merging columns as necessary",
            "suites": [
                "csvviewer/parsenoquotes",
                "parseDSVNoQuotes"
            ],
            "updatePoint": {
                "line": 235,
                "column": 62
            },
            "line": 235,
            "code": "    it('handles adding columns or merging columns as necessary', () => {\n      const data = `a,b,c\\n,c,d,e,f\\ng,h`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 6, 15]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 9, 15, 17, 18]);\n    });",
            "file": "parse-noquotes.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "does basic parsing of csv files",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 8,
                "column": 39
            },
            "line": 8,
            "code": "    it('does basic parsing of csv files', () => {\n      const data = `a,b,c,d\\r\\n0,1,2,3\\r\\n4,5,6,7`;\n      const options = { data };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([0, 9, 18]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 9, 11, 13, 15, 18, 20, 22, 24\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles trailing row delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 28,
                "column": 38
            },
            "line": 28,
            "code": "    it('handles trailing row delimiter', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles single-line data",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 45,
                "column": 32
            },
            "line": 45,
            "code": "    it('handles single-line data', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles changing the field delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 60,
                "column": 44
            },
            "line": 60,
            "code": "    it('handles changing the field delimiter', () => {\n      const data = `a\\tb\\tc\\td\\n0\\t1\\t2\\t3\\n4\\t5\\t6\\t7\\n`;\n      const options = { data, delimiter: '\\t', rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles starting on a new row",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 77,
                "column": 37
            },
            "line": 77,
            "code": "    it('handles starting on a new row', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([8, 16]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14, 16, 18, 20, 22]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a max row argument",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 92,
                "column": 34
            },
            "line": 92,
            "code": "    it('handles a max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', maxRows: 2 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 8, 10, 12, 14]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a start index and max row argument",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 107,
                "column": 50
            },
            "line": 107,
            "code": "    it('handles a start index and max row argument', () => {\n      const data = `a,b,c,d\\n0,1,2,3\\n4,5,6,7\\n`;\n      const options = { data, rowDelimiter: '\\n', startIndex: 8, maxRows: 1 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([8]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([8, 10, 12, 14]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match first row by default",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 122,
                "column": 53
            },
            "line": 122,
            "code": "    it('adjusts columns to match first row by default', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 8, 10, 10, 10, 11, 13, 15, 17\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match first row by default with CRLF row delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 139,
                "column": 77
            },
            "line": 139,
            "code": "    it('adjusts columns to match first row by default with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(4);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 9, 11, 11, 11, 13, 15, 17, 19\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 156,
                "column": 38
            },
            "line": 156,
            "code": "    it('adjusts columns to match ncols', () => {\n      const data = `a,b,c,d\\n0,\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 8, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 7, 8, 10, 10, 10, 10, 11, 13, 15, 17, 19\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with CRLF row delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 173,
                "column": 62
            },
            "line": 173,
            "code": "    it('adjusts columns to match ncols with CRLF row delimiter', () => {\n      const data = `a,b,c,d\\r\\n0,\\r\\n1,2,3,4,5,6`;\n      const options = { data, rowDelimiter: '\\r\\n', ncols: 5 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 9, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([\n        0, 2, 4, 6, 7, 9, 11, 11, 11, 11, 13, 15, 17, 19, 21\n      ]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with one row",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 190,
                "column": 51
            },
            "line": 190,
            "code": "    it('adjusts columns to match ncols with one row', () => {\n      const data = `a,b,c,d`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "adjusts columns to match ncols with one row and trailing delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 205,
                "column": 74
            },
            "line": 205,
            "code": "    it('adjusts columns to match ncols with one row and trailing delimiter', () => {\n      const data = `a,b,c,d\\n`;\n      const options = { data, rowDelimiter: '\\n', ncols: 7 };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(7);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 7, 7]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles a single row delimiter",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 220,
                "column": 38
            },
            "line": 220,
            "code": "    it('handles a single row delimiter', () => {\n      const data = `\\n`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles adding columns or merging columns as necessary",
            "suites": [
                "csvviewer/parse",
                "parseDSV"
            ],
            "updatePoint": {
                "line": 235,
                "column": 62
            },
            "line": 235,
            "code": "    it('handles adding columns or merging columns as necessary', () => {\n      const data = `a,b,c\\n,c,d,e,f\\ng,h`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(3);\n      expect(results.offsets).toEqual([0, 6, 15]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(3);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 4, 6, 7, 9, 15, 17, 18]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "does basic parsing of quoted csv files",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 252,
                "column": 46
            },
            "line": 252,
            "code": "    it('does basic parsing of quoted csv files', () => {\n      const data = `first,\"last\",address,city,zip`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(5);\n      expect(results.offsets).toEqual([0, 6, 13, 21, 26]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles quotes with field delimiters",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 267,
                "column": 44
            },
            "line": 267,
            "code": "    it('handles quotes with field delimiters', () => {\n      const data = `a,\"b,c\",d\\n\"e\",\"f\"`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 10]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 8, 10, 14, 17]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles quotes with row delimiters",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 282,
                "column": 42
            },
            "line": 282,
            "code": "    it('handles quotes with row delimiters', () => {\n      const data = `a,\"b\\nc\",d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 10]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 8, 10, 12, 13]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles quotes with escaped quotes",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 297,
                "column": 42
            },
            "line": 297,
            "code": "    it('handles quotes with escaped quotes', () => {\n      const data = `a,\"b\"\"c\",d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 11]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 9, 11, 13, 14]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles setting the quote character",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 312,
                "column": 43
            },
            "line": 312,
            "code": "    it('handles setting the quote character', () => {\n      const data = `a,'b'',\\nc',d\\ne,f`;\n      const options = { data, rowDelimiter: '\\n', quote: `'` };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(2);\n      expect(results.offsets).toEqual([0, 13]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(2);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 11, 13, 15, 16]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles single quoted field",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 327,
                "column": 35
            },
            "line": 327,
            "code": "    it('handles single quoted field', () => {\n      const data = `\"a\"`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles empty quoted field",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 342,
                "column": 34
            },
            "line": 342,
            "code": "    it('handles empty quoted field', () => {\n      const data = `a,\"\",b`;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(1);\n      expect(results.offsets).toEqual([0]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(1);\n      expect(results.ncols).toEqual(3);\n      expect(results.offsets).toEqual([0, 2, 5]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "handles empty file",
            "suites": [
                "csvviewer/parse",
                "parseDSV quotes"
            ],
            "updatePoint": {
                "line": 357,
                "column": 26
            },
            "line": 357,
            "code": "    it('handles empty file', () => {\n      const data = ``;\n      const options = { data, rowDelimiter: '\\n' };\n      let results;\n\n      results = parser({ ...options, columnOffsets: false });\n      expect(results.nrows).toEqual(0);\n      expect(results.offsets).toEqual([]);\n\n      results = parser({ ...options, columnOffsets: true });\n      expect(results.nrows).toEqual(0);\n      expect(results.ncols).toEqual(0);\n      expect(results.offsets).toEqual([]);\n    });",
            "file": "parse.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should instantiate a `CSVDelimiter` toolbar widget",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 60
            },
            "line": 24,
            "code": "      it('should instantiate a `CSVDelimiter` toolbar widget', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget).toBeInstanceOf(CSVDelimiter);\n        expect(Array.from(widget.node.classList)).toEqual(\n          expect.arrayContaining(['jp-CSVDelimiter'])\n        );\n        widget.dispose();\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should allow pre-selecting the delimiter",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 50
            },
            "line": 33,
            "code": "      it('should allow pre-selecting the delimiter', () => {\n        const wanted = (delimiter = DELIMITERS[DELIMITERS.length - 1]);\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.selectNode.value).toBe(wanted);\n        widget.dispose();\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should emit a value when the dropdown value changes",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#delimiterChanged"
            ],
            "updatePoint": {
                "line": 42,
                "column": 61
            },
            "line": 42,
            "code": "      it('should emit a value when the dropdown value changes', () => {\n        const parent = mockViewer();\n        const widget = new CSVDelimiter({ widget: parent });\n        const index = DELIMITERS.length - 1;\n        const wanted = DELIMITERS[index];\n        Widget.attach(widget, document.body);\n        widget.selectNode.selectedIndex = index;\n        simulate(widget.selectNode, 'change');\n        expect(parent.delimiter).toBe(wanted);\n        widget.dispose();\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should change the delimiter",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#handleEvent"
            ],
            "updatePoint": {
                "line": 56,
                "column": 37
            },
            "line": 56,
            "code": "      it('should change the delimiter', () => {\n        const viewer = mockViewer();\n        const widget = new CSVDelimiter({ widget: viewer });\n        const wanted = DELIMITERS[1];\n        widget.selectNode.value = wanted;\n        widget.handleEvent({ type: 'change' } as any);\n        expect(viewer.delimiter).toBe(wanted);\n        widget.dispose();\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should return the delimiter dropdown select tag",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#selectNode"
            ],
            "updatePoint": {
                "line": 68,
                "column": 57
            },
            "line": 68,
            "code": "      it('should return the delimiter dropdown select tag', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.selectNode.tagName.toLowerCase()).toBe('select');\n        widget.dispose();\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 60
            },
            "line": 76,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "csvviewer/toolbar",
                "CSVDelimiter",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 83,
                "column": 47
            },
            "line": 83,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = new CSVDelimiter({ widget: mockViewer() });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should instantiate a `CSVViewer`",
            "suites": [
                "csvviewer/widget",
                "CSVViewer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 26,
                "column": 42
            },
            "line": 26,
            "code": "      it('should instantiate a `CSVViewer`', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget).toBeInstanceOf(CSVViewer);\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should be the context for the file",
            "suites": [
                "csvviewer/widget",
                "CSVViewer",
                "#context"
            ],
            "updatePoint": {
                "line": 34,
                "column": 44
            },
            "line": 34,
            "code": "      it('should be the context for the file', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.context).toBe(context);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "csvviewer/widget",
                "CSVViewer",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 60
            },
            "line": 41,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "csvviewer/widget",
                "CSVViewer",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 47
            },
            "line": 48,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = new CSVViewer({ context });\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "searches incrementally and set background color",
            "suites": [
                "csvviewer/widget",
                "GridSearchService"
            ],
            "updatePoint": {
                "line": 82,
                "column": 55
            },
            "line": 82,
            "code": "    it('searches incrementally and set background color', () => {\n      const model = createModel();\n      const searchService = createGridSearchService(model);\n\n      const cellRenderer = searchService.cellBackgroundColorRendererFunc({\n        matchBackgroundColor: 'anotherMatch',\n        currentMatchBackgroundColor: 'currentMatch',\n        textColor: '',\n        horizontalAlignment: 'right'\n      });\n\n      /**\n       * fake rendering a cell and returns the background color for this coordinate.\n       */\n      function fakeRenderCell(row: number, column: number) {\n        const cellConfig = {\n          value: model.data('body', row, column),\n          row,\n          column\n        } as CellRenderer.CellConfig;\n        return cellRenderer(cellConfig);\n      }\n\n      // searching for \"match\", cells at (0,1) and (1,1) should match.\n      // (0,1) is the current match\n      const query = /match/;\n      searchService.find(query);\n      expect(fakeRenderCell(0, 1)).toBe('currentMatch');\n      expect(fakeRenderCell(1, 1)).toBe('anotherMatch');\n      expect(fakeRenderCell(0, 0)).toBe('');\n\n      // search again, the current match \"moves\" to be (1,1)\n      searchService.find(query);\n      expect(fakeRenderCell(0, 1)).toBe('anotherMatch');\n      expect(fakeRenderCell(1, 1)).toBe('currentMatch');\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/csvviewer/test"
        },
        {
            "name": "should compute a valid code id when the parameters are set",
            "suites": [
                "DebuggerConfig",
                "#getCodeId"
            ],
            "updatePoint": {
                "line": 15,
                "column": 66
            },
            "line": 15,
            "code": "    it('should compute a valid code id when the parameters are set', () => {\n      const [prefix, suffix] = ['foo', 'bar'];\n      config.setHashParams({ method: 'Murmur2', seed: 'bar', kernel });\n      config.setTmpFileParams({ prefix, suffix, kernel });\n      const codeId = config.getCodeId('i = 0', kernel);\n      expect(codeId.startsWith(prefix)).toBe(true);\n      expect(codeId.endsWith(suffix)).toBe(true);\n    });",
            "file": "config.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should throw if the kernel does not have hash parameters",
            "suites": [
                "DebuggerConfig",
                "#getCodeId"
            ],
            "updatePoint": {
                "line": 24,
                "column": 64
            },
            "line": 24,
            "code": "    it('should throw if the kernel does not have hash parameters', () => {\n      config.setTmpFileParams({ prefix: 'foo', suffix: 'bar', kernel });\n      expect(() => {\n        config.getCodeId('i = 0', kernel);\n      }).toThrow('has no hashing params');\n    });",
            "file": "config.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should throw if the kernel does not have tmp file parameters",
            "suites": [
                "DebuggerConfig",
                "#getCodeId"
            ],
            "updatePoint": {
                "line": 31,
                "column": 68
            },
            "line": 31,
            "code": "    it('should throw if the kernel does not have tmp file parameters', () => {\n      config.setHashParams({ method: 'Murmur2', seed: 'bar', kernel });\n      expect(() => {\n        config.getCodeId('i = 0', kernel);\n      }).toThrow('has no tmp file params');\n    });",
            "file": "config.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should create a new debugger sidebar",
            "suites": [
                "Debugger",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 44
            },
            "line": 164,
            "code": "    it('should create a new debugger sidebar', () => {\n      expect(sidebar).toBeInstanceOf(Debugger.Sidebar);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have 5 child widgets",
            "suites": [
                "Debugger",
                "Panel"
            ],
            "updatePoint": {
                "line": 176,
                "column": 35
            },
            "line": 176,
            "code": "    it('should have 5 child widgets', () => {\n      expect(sidebar.widgets.length).toBe(5);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have 5 toolbars",
            "suites": [
                "Debugger",
                "Panel"
            ],
            "updatePoint": {
                "line": 180,
                "column": 30
            },
            "line": 180,
            "code": "    it('should have 5 toolbars', () => {\n      expect(toolbarList.length).toBe(5);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have expanding icon",
            "suites": [
                "Debugger",
                "Panel",
                "Variable toolbar"
            ],
            "updatePoint": {
                "line": 188,
                "column": 36
            },
            "line": 188,
            "code": "      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have title",
            "suites": [
                "Debugger",
                "Panel",
                "Variable toolbar"
            ],
            "updatePoint": {
                "line": 194,
                "column": 27
            },
            "line": 194,
            "code": "      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Variables');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have two buttons",
            "suites": [
                "Debugger",
                "Panel",
                "Variable toolbar"
            ],
            "updatePoint": {
                "line": 201,
                "column": 33
            },
            "line": 201,
            "code": "      it('should have two buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(2);\n        expect(buttons[0].title).toBe('Tree View');\n        expect(buttons[1].title).toBe('Table View');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have expanding icon",
            "suites": [
                "Debugger",
                "Panel",
                "Callstack toolbar"
            ],
            "updatePoint": {
                "line": 213,
                "column": 36
            },
            "line": 213,
            "code": "      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have title",
            "suites": [
                "Debugger",
                "Panel",
                "Callstack toolbar"
            ],
            "updatePoint": {
                "line": 219,
                "column": 27
            },
            "line": 219,
            "code": "      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Callstack');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have six buttons",
            "suites": [
                "Debugger",
                "Panel",
                "Callstack toolbar"
            ],
            "updatePoint": {
                "line": 226,
                "column": 33
            },
            "line": 226,
            "code": "      it('should have six buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(6);\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have expanding icon",
            "suites": [
                "Debugger",
                "Panel",
                "Breakpoints toolbar"
            ],
            "updatePoint": {
                "line": 236,
                "column": 36
            },
            "line": 236,
            "code": "      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have title",
            "suites": [
                "Debugger",
                "Panel",
                "Breakpoints toolbar"
            ],
            "updatePoint": {
                "line": 242,
                "column": 27
            },
            "line": 242,
            "code": "      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Breakpoints');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have two buttons",
            "suites": [
                "Debugger",
                "Panel",
                "Breakpoints toolbar"
            ],
            "updatePoint": {
                "line": 249,
                "column": 33
            },
            "line": 249,
            "code": "      it('should have two buttons', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(2);\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have expanding icon",
            "suites": [
                "Debugger",
                "Panel",
                "Source toolbar"
            ],
            "updatePoint": {
                "line": 259,
                "column": 36
            },
            "line": 259,
            "code": "      it('should have expanding icon', () => {\n        const title = toolbar.querySelectorAll(\n          '.lm-AccordionPanel-titleCollapser'\n        );\n        expect(title[0].innerHTML).toContain('ui-components:caret-down');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have title",
            "suites": [
                "Debugger",
                "Panel",
                "Source toolbar"
            ],
            "updatePoint": {
                "line": 265,
                "column": 27
            },
            "line": 265,
            "code": "      it('should have title', () => {\n        const title = toolbar.querySelectorAll(\n          'span.lm-AccordionPanel-titleLabel'\n        );\n        expect(title.length).toBe(1);\n        expect(title[0].innerHTML).toContain('Source');\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have one button",
            "suites": [
                "Debugger",
                "Panel",
                "Source toolbar"
            ],
            "updatePoint": {
                "line": 273,
                "column": 32
            },
            "line": 273,
            "code": "      it('should have one button', () => {\n        const buttons = toolbar.querySelectorAll('button');\n        expect(buttons.length).toBe(1);\n      });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have a body",
            "suites": [
                "Debugger",
                "#callstack"
            ],
            "updatePoint": {
                "line": 281,
                "column": 26
            },
            "line": 281,
            "code": "    it('should have a body', () => {\n      expect(sidebar.callstack.widgets.length).toEqual(1);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have the jp-DebuggerCallstack class",
            "suites": [
                "Debugger",
                "#callstack"
            ],
            "updatePoint": {
                "line": 285,
                "column": 50
            },
            "line": 285,
            "code": "    it('should have the jp-DebuggerCallstack class', () => {\n      expect(sidebar.callstack.hasClass('jp-DebuggerCallstack')).toBe(true);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should display the stack frames",
            "suites": [
                "Debugger",
                "#callstack"
            ],
            "updatePoint": {
                "line": 289,
                "column": 39
            },
            "line": 289,
            "code": "    it('should display the stack frames', () => {\n      const node = sidebar.callstack.node;\n      const items = node.querySelectorAll('.jp-DebuggerCallstack-body li');\n\n      expect(items).toHaveLength(1);\n      expect(items[0].innerHTML).toContain('module');\n      expect(items[0].innerHTML).toContain('3'); // line for the first breakpoint\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have the jp-DebuggerBreakpoints class",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 300,
                "column": 52
            },
            "line": 300,
            "code": "    it('should have the jp-DebuggerBreakpoints class', () => {\n      expect(sidebar.breakpoints.hasClass('jp-DebuggerBreakpoints')).toBe(true);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should contain the list of breakpoints",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 304,
                "column": 46
            },
            "line": 304,
            "code": "    it('should contain the list of breakpoints', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      expect(items).toHaveLength(2);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should contain the path to the breakpoints",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 310,
                "column": 50
            },
            "line": 310,
            "code": "    it('should contain the path to the breakpoints', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-source');\n      items.forEach(item => {\n        // TODO: replace by toEqual when there is an alternative to the rtl\n        // breakpoint display\n        expect(item.innerHTML).toContain(path.slice(1));\n      });\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should contain the line number",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 320,
                "column": 38
            },
            "line": 320,
            "code": "    it('should contain the line number', async () => {\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-line');\n\n      await act(() => service.updateBreakpoints(code, breakpoints));\n\n      items.forEach((item, i) => {\n        const parsed = parseInt(item.innerHTML, 10);\n        expect(parsed).toEqual(lines[i]);\n      });\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should be updated when new breakpoints are added",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 332,
                "column": 56
            },
            "line": 332,
            "code": "    it('should be updated when new breakpoints are added', async () => {\n      const node = sidebar.breakpoints.node;\n      let items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      const len1 = items.length;\n\n      const bps = breakpoints.concat([\n        {\n          id: 3,\n          line: 4,\n          verified: true,\n          source: {\n            path\n          }\n        }\n      ]);\n\n      await act(() => service.updateBreakpoints(code, bps));\n\n      items = node.querySelectorAll('.jp-DebuggerBreakpoint');\n      const len2 = items.length;\n\n      expect(len2).toEqual(len1 + 1);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should contain the path after a restore",
            "suites": [
                "Debugger",
                "#breakpoints"
            ],
            "updatePoint": {
                "line": 356,
                "column": 47
            },
            "line": 356,
            "code": "    it('should contain the path after a restore', async () => {\n      await service.restoreState(true);\n      const node = sidebar.breakpoints.node;\n      const items = node.querySelectorAll('.jp-DebuggerBreakpoint-source');\n      items.forEach(item => {\n        // TODO: replace by toEqual when there is an alternative to the rtl\n        // breakpoint display\n        expect(item.innerHTML).toContain(path.slice(1));\n      });\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should have a body",
            "suites": [
                "Debugger",
                "#sources"
            ],
            "updatePoint": {
                "line": 369,
                "column": 26
            },
            "line": 369,
            "code": "    it('should have a body', () => {\n      expect(sidebar.sources.widgets.length).toEqual(1);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should display the source path in the header",
            "suites": [
                "Debugger",
                "#sources"
            ],
            "updatePoint": {
                "line": 373,
                "column": 52
            },
            "line": 373,
            "code": "    it('should display the source path in the header', () => {\n      const header = sidebar.sources.toolbar;\n      const pathWidget = header.node.innerHTML;\n      expect(pathWidget).toContain(path);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should display the source code in the body",
            "suites": [
                "Debugger",
                "#sources"
            ],
            "updatePoint": {
                "line": 379,
                "column": 50
            },
            "line": 379,
            "code": "    it('should display the source code in the body', () => {\n      const body = sidebar.sources.widgets[0] as SourcesBody;\n      const children = Array.from(body.children());\n      const editor = children[0] as CodeEditorWrapper;\n      expect(editor.model.sharedModel.getSource()).toEqual(code);\n    });",
            "file": "debugger.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return true for kernels that have support for debugging",
            "suites": [
                "Debugging support",
                "#isAvailable"
            ],
            "updatePoint": {
                "line": 66,
                "column": 70
            },
            "line": 66,
            "code": "    it('should return true for kernels that have support for debugging', async () => {\n      const enabled = await service.isAvailable({\n        kernel: { name: 'python3' }\n      } as any);\n      expect(enabled).toBe(true);\n    });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return false for kernels that do not have support for debugging",
            "suites": [
                "Debugging support",
                "#isAvailable"
            ],
            "line": 73,
            "code": "    it.skip('should return false for kernels that do not have support for debugging', async () => {",
            "file": "service.spec.ts",
            "skipped": true,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should create a new instance",
            "suites": [
                "DebuggerService",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 36
            },
            "line": 110,
            "code": "    it('should create a new instance', () => {\n      expect(service).toBeInstanceOf(Debugger.Service);\n    });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should start the service if the session is set",
            "suites": [
                "DebuggerService",
                "#start()"
            ],
            "updatePoint": {
                "line": 116,
                "column": 54
            },
            "line": 116,
            "code": "    it('should start the service if the session is set', async () => {\n      service.session = session;\n      await service.start();\n      expect(service.isStarted).toEqual(true);\n    });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should stop the service if the session is set",
            "suites": [
                "DebuggerService",
                "#stop()"
            ],
            "updatePoint": {
                "line": 124,
                "column": 53
            },
            "line": 124,
            "code": "    it('should stop the service if the session is set', async () => {\n      service.session = session;\n      await service.start();\n      await service.stop();\n      expect(service.isStarted).toEqual(false);\n    });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should emit the sessionChanged signal when setting the session",
            "suites": [
                "DebuggerService",
                "#session"
            ],
            "updatePoint": {
                "line": 133,
                "column": 70
            },
            "line": 133,
            "code": "    it('should emit the sessionChanged signal when setting the session', () => {\n      const sessionChangedEvents: (IDebugger.ISession | null)[] = [];\n      service.sessionChanged.connect((_, newSession) => {\n        sessionChangedEvents.push(newSession);\n      });\n      service.session = session;\n      expect(sessionChangedEvents.length).toEqual(1);\n      expect(sessionChangedEvents[0]).toEqual(session);\n    });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should update the breakpoints",
            "suites": [
                "DebuggerService",
                "protocol",
                "#updateBreakpoints"
            ],
            "updatePoint": {
                "line": 177,
                "column": 39
            },
            "line": 177,
            "code": "      it('should update the breakpoints', async () => {\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        await service.updateBreakpoints(code, breakpoints);\n        const bpList = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList.length).toEqual(breakpoints.length);\n        expect(bpList[0].line).toEqual(breakpoints[0].line);\n        expect(bpList[1].line).toEqual(breakpoints[1].line);\n        expect(bpList[0].source).toEqual(breakpoints[0].source);\n        expect(bpList[1].source).toEqual(breakpoints[1].source);\n      });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should restore the breakpoints",
            "suites": [
                "DebuggerService",
                "protocol",
                "#restoreState"
            ],
            "updatePoint": {
                "line": 193,
                "column": 40
            },
            "line": 193,
            "code": "      it('should restore the breakpoints', async () => {\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        const bpList1 = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList1.length).toEqual(0);\n        await service.restoreState(true);\n        const bpList2 = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList2).toEqual(breakpoints);\n      });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should restart the debugger and send the breakpoints again",
            "suites": [
                "DebuggerService",
                "protocol",
                "#restart"
            ],
            "updatePoint": {
                "line": 207,
                "column": 68
            },
            "line": 207,
            "code": "      it('should restart the debugger and send the breakpoints again', async () => {\n        await service.restart();\n        const { model } = service;\n        model.breakpoints.restoreBreakpoints(\n          new Map<string, IDebugger.IBreakpoint[]>()\n        );\n        await service.restoreState(true);\n        const bpList = model.breakpoints.getBreakpoints(sourceId);\n        expect(bpList).toEqual(breakpoints);\n      });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return false if the model is null",
            "suites": [
                "DebuggerService",
                "protocol",
                "#hasStoppedThreads"
            ],
            "updatePoint": {
                "line": 220,
                "column": 50
            },
            "line": 220,
            "code": "      it('should return false if the model is null', () => {\n        const hasStoppedThreads = service.hasStoppedThreads();\n        expect(hasStoppedThreads).toBe(false);\n      });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return true when the execution has stopped",
            "suites": [
                "DebuggerService",
                "protocol",
                "#hasStoppedThreads"
            ],
            "updatePoint": {
                "line": 225,
                "column": 59
            },
            "line": 225,
            "code": "      it('should return true when the execution has stopped', async () => {\n        const { model } = service;\n        const variablesChanged = signalToPromise(model.variables.changed);\n\n        // trigger a manual execute request\n        connection!.kernel!.requestExecute({ code });\n\n        // wait for the first stopped event and variables changed\n        await variablesChanged;\n\n        const hasStoppedThreads = service.hasStoppedThreads();\n        expect(hasStoppedThreads).toBe(true);\n        await service.restart();\n      });",
            "file": "service.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return whether the object is disposed",
            "suites": [
                "Debugger.Session",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 50,
                "column": 52
            },
            "line": 50,
            "code": "    it('should return whether the object is disposed', () => {\n      const debugSession = new Debugger.Session({\n        connection,\n        config\n      });\n      expect(debugSession.isDisposed).toEqual(false);\n      debugSession.dispose();\n      expect(debugSession.isDisposed).toEqual(true);\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should be emitted when sending debug messages",
            "suites": [
                "Debugger.Session",
                "#eventMessage"
            ],
            "updatePoint": {
                "line": 62,
                "column": 53
            },
            "line": 62,
            "code": "    it('should be emitted when sending debug messages', async () => {\n      const debugSession = new Debugger.Session({\n        connection,\n        config\n      });\n      let events: string[] = [];\n      debugSession.eventMessage.connect((sender, event) => {\n        events.push(event.event);\n      });\n      await debugSession.start();\n      await debugSession.stop();\n      expect(events).toEqual(\n        expect.arrayContaining(['output', 'initialized', 'process'])\n      );\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should send debug messages to the kernel",
            "suites": [
                "Debugger.Session",
                "#sendRequest success"
            ],
            "updatePoint": {
                "line": 80,
                "column": 48
            },
            "line": 80,
            "code": "    it('should send debug messages to the kernel', async () => {\n      const debugSession = new Debugger.Session({\n        connection,\n        config\n      });\n      await debugSession.start();\n      const code = 'i=0\\ni+=1\\ni+=1';\n      const reply = await debugSession.sendRequest('dumpCell', {\n        code\n      });\n      await debugSession.stop();\n      expect(reply.body.sourcePath).toContain('.py');\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should handle replies with success false",
            "suites": [
                "Debugger.Session",
                "#sendRequest failure"
            ],
            "updatePoint": {
                "line": 96,
                "column": 48
            },
            "line": 96,
            "code": "    it('should handle replies with success false', async () => {\n      const debugSession = new Debugger.Session({\n        connection,\n        config\n      });\n      await debugSession.start();\n      const reply = await debugSession.sendRequest('evaluate', {\n        expression: 'a'\n      });\n      await debugSession.stop();\n      const { success, message } = reply;\n      expect(success).toBe(false);\n      expect(message).toBeTruthy();\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return the state of the current debug session",
            "suites": [
                "protocol",
                "#debugInfo"
            ],
            "updatePoint": {
                "line": 198,
                "column": 60
            },
            "line": 198,
            "code": "    it('should return the state of the current debug session', async () => {\n      const reply = await debugSession.sendRequest('debugInfo', {});\n      expect(reply.body.isStarted).toBe(true);\n\n      const breakpoints = reply.body.breakpoints;\n      // breakpoints are in the same file\n      expect(breakpoints.length).toEqual(1);\n\n      const breakpointsInfo = breakpoints[0];\n      const breakpointLines = breakpointsInfo.breakpoints.map(bp => {\n        return bp.line;\n      });\n      expect(breakpointLines).toEqual([3, 5]);\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return the correct stackframes",
            "suites": [
                "protocol",
                "#stackTrace"
            ],
            "updatePoint": {
                "line": 215,
                "column": 45
            },
            "line": 215,
            "code": "    it('should return the correct stackframes', async () => {\n      const reply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      expect(reply.success).toBe(true);\n      const stackFrames = reply.body.stackFrames;\n      expect(stackFrames.length).toEqual(1);\n      const frame = stackFrames[0];\n      // first breakpoint\n      expect(frame.line).toEqual(3);\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return the correct scopes",
            "suites": [
                "protocol",
                "#scopes"
            ],
            "updatePoint": {
                "line": 229,
                "column": 40
            },
            "line": 229,
            "code": "    it('should return the correct scopes', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frameId = stackFramesReply.body.stackFrames[0].id;\n      const scopesReply = await debugSession.sendRequest('scopes', {\n        frameId\n      });\n      const scopes = scopesReply.body.scopes;\n      expect(scopes.length).toBeGreaterThanOrEqual(1);\n\n      const locals = scopes.find(scope => scope.name === 'Locals');\n      expect(locals).toBeTruthy();\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return the variables and their values",
            "suites": [
                "protocol",
                "#variables"
            ],
            "updatePoint": {
                "line": 267,
                "column": 52
            },
            "line": 267,
            "code": "    it('should return the variables and their values', async () => {\n      const variables = await getVariables();\n      expect(variables.length).toBeGreaterThan(0);\n      const i = find(variables, variable => variable.name === 'i');\n      expect(i).toBeDefined();\n      expect(i!.type).toEqual('int');\n      expect(i!.value).toEqual('1');\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should return the amount of variables requested",
            "suites": [
                "protocol",
                "#variablesPagination"
            ],
            "line": 278,
            "code": "    it.skip('should return the amount of variables requested', async () => {",
            "file": "session.spec.ts",
            "skipped": true,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should proceed to the next breakpoint",
            "suites": [
                "protocol",
                "#continue"
            ],
            "updatePoint": {
                "line": 288,
                "column": 45
            },
            "line": 288,
            "code": "    it('should proceed to the next breakpoint', async () => {\n      const [first, second] = signalToPromises(debugSession.eventMessage, 2);\n      await debugSession.sendRequest('continue', { threadId });\n\n      // wait for debug events\n      const [, continued] = await first;\n      expect(continued.event).toEqual('continued');\n      const [, stopped] = await second;\n      expect(stopped.event).toEqual('stopped');\n\n      const variables = await getVariables();\n      const i = find(variables, variable => variable.name === 'i');\n      expect(i).toBeDefined();\n      expect(i!.type).toEqual('int');\n      expect(i!.value).toEqual('2');\n\n      const j = find(variables, variable => variable.name === 'j');\n      expect(j).toBeDefined();\n      expect(j!.type).toEqual('int');\n      expect(j!.value).toEqual('4');\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should retrieve the source of the dumped code cell",
            "suites": [
                "protocol",
                "#source"
            ],
            "updatePoint": {
                "line": 312,
                "column": 58
            },
            "line": 312,
            "code": "    it('should retrieve the source of the dumped code cell', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frame = stackFramesReply.body.stackFrames[0];\n      const source = frame.source;\n      const reply = await debugSession.sendRequest('source', {\n        source: { path: source!.path! },\n        sourceReference: source!.sourceReference!\n      });\n      const sourceCode = reply.body.content;\n      expect(sourceCode).toEqual(code);\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should evaluate the code sent to the kernel",
            "suites": [
                "protocol",
                "#evaluate"
            ],
            "updatePoint": {
                "line": 328,
                "column": 51
            },
            "line": 328,
            "code": "    it('should evaluate the code sent to the kernel', async () => {\n      const stackFramesReply = await debugSession.sendRequest('stackTrace', {\n        threadId\n      });\n      const frameId = stackFramesReply.body.stackFrames[0].id;\n      const reply = await debugSession.sendRequest('evaluate', {\n        frameId,\n        context: 'repl',\n        expression: 'k = 123',\n        format: {}\n      });\n      expect(reply.success).toBe(true);\n\n      const variables = await getVariables();\n      const k = find(variables, variable => variable.name === 'k');\n      expect(k).toBeDefined();\n      expect(k!.type).toEqual('int');\n      expect(k!.value).toEqual('123');\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should be hit when the condition is true",
            "suites": [
                "protocol",
                "#setBreakpoints with condition"
            ],
            "updatePoint": {
                "line": 350,
                "column": 48
            },
            "line": 350,
            "code": "    it('should be hit when the condition is true', async () => {\n      const reply = await debugSession.sendRequest('dumpCell', {\n        code\n      });\n      await debugSession.sendRequest('setBreakpoints', {\n        breakpoints: [{ line: 9, condition: 'i == 5' }],\n        source: { path: reply.body.sourcePath },\n        sourceModified: false\n      });\n      await debugSession.sendRequest('configurationDone', {});\n\n      // advance to the conditional breakpoint\n      await debugSession.sendRequest('continue', { threadId });\n\n      const variables = await getVariables();\n      const j = find(variables, variable => variable.name === 'j');\n      expect(j).toBeDefined();\n      expect(j!.value).toEqual('25');\n    });",
            "file": "session.spec.ts",
            "skipped": false,
            "dir": "packages/debugger/test"
        },
        {
            "name": "should show overwrite dialog when file is already existing",
            "suites": [
                "docregistry/dialog",
                "@jupyterlab/docmanager",
                "#renameFile()"
            ],
            "updatePoint": {
                "line": 43,
                "column": 68
            },
            "line": 43,
            "code": "      it('should show overwrite dialog when file is already existing', async () => {\n        alreadyExistsError.response.status = 409;\n        await expect(\n          Promise.all([\n            dismissDialog(),\n            renameFile(manager, 'foo.ipynb', 'bar.ipynb')\n          ])\n        ).rejects.toBe('File not renamed');\n      });",
            "file": "dialog.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should throw error on no status",
            "suites": [
                "docregistry/dialog",
                "@jupyterlab/docmanager",
                "#renameFile()"
            ],
            "updatePoint": {
                "line": 52,
                "column": 41
            },
            "line": 52,
            "code": "      it('should throw error on no status', async () => {\n        alreadyExistsError.response = {};\n        await expect(\n          Promise.all([\n            dismissDialog(),\n            renameFile(manager, 'foo.ipynb', 'bar.ipynb')\n          ])\n        ).rejects.toBe(alreadyExistsError);\n      });",
            "file": "dialog.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should throw error on not 409 status",
            "suites": [
                "docregistry/dialog",
                "@jupyterlab/docmanager",
                "#renameFile()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 46
            },
            "line": 61,
            "code": "      it('should throw error on not 409 status', async () => {\n        alreadyExistsError.response.status = 408;\n        await expect(\n          Promise.all([\n            dismissDialog(),\n            renameFile(manager, 'foo.ipynb', 'bar.ipynb')\n          ])\n        ).rejects.toBe(alreadyExistsError);\n      });",
            "file": "dialog.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a new document manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 99,
                "column": 46
            },
            "line": 99,
            "code": "      it('should create a new document manager', () => {\n        expect(manager).toBeInstanceOf(DocumentManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should test whether the manager is disposed",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 105,
                "column": 53
            },
            "line": 105,
            "code": "      it('should test whether the manager is disposed', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should dispose of the resources used by the manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 113,
                "column": 61
            },
            "line": 113,
            "code": "      it('should dispose of the resources used by the manager', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should get the service manager for the manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#services"
            ],
            "updatePoint": {
                "line": 123,
                "column": 56
            },
            "line": 123,
            "code": "      it('should get the service manager for the manager', async () => {\n        await expect(manager.services.ready).resolves.not.toThrow();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should get the registry used by the manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#registry"
            ],
            "updatePoint": {
                "line": 129,
                "column": 53
            },
            "line": 129,
            "code": "      it('should get the registry used by the manager', () => {\n        expect(manager.registry).toBeInstanceOf(DocumentRegistry);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should open a file and return the widget used to view it",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#open()"
            ],
            "updatePoint": {
                "line": 135,
                "column": 66
            },
            "line": 135,
            "code": "      it('should open a file and return the widget used to view it', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path)!;\n        expect(widget.hasClass('WidgetFactory')).toBe(true);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should start a kernel if one is given",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#open()"
            ],
            "updatePoint": {
                "line": 145,
                "column": 47
            },
            "line": 145,
            "code": "      it('should start a kernel if one is given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        const session = await services.sessions.startNew({\n          name: '',\n          path: model.path,\n          type: 'test'\n        });\n        const id = session.kernel!.id;\n        widget = manager.open(session.path, 'default', { id })!;\n        context = manager.contextForWidget(widget)!;\n        await context.ready;\n        await context.sessionContext.ready;\n        expect(context.sessionContext.session?.kernel).toBeTruthy();\n        await context.sessionContext.shutdown();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should not auto-start a kernel if there is none given",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#open()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 63
            },
            "line": 164,
            "code": "      it('should not auto-start a kernel if there is none given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'default')!;\n        context = manager.contextForWidget(widget)!;\n        await dismissDialog();\n        expect(context.sessionContext.session?.kernel).toBeFalsy();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the factory is not found",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#open()"
            ],
            "updatePoint": {
                "line": 175,
                "column": 61
            },
            "line": 175,
            "code": "      it('should return undefined if the factory is not found', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the factory has no model factory",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#open()"
            ],
            "updatePoint": {
                "line": 184,
                "column": 69
            },
            "line": 184,
            "code": "      it('should return undefined if the factory has no model factory', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test',\n          modelName: 'foo',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.open(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should open a file and return the widget used to view it",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 201,
                "column": 66
            },
            "line": 201,
            "code": "      it('should open a file and return the widget used to view it', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        expect(widget.hasClass('WidgetFactory')).toBe(true);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should start a kernel if one is given",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 211,
                "column": 47
            },
            "line": 211,
            "code": "      it('should start a kernel if one is given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        const session = await services.sessions.startNew({\n          name: '',\n          path: model.path,\n          type: 'test'\n        });\n        const id = session.kernel!.id;\n        widget = manager.createNew(session.path, 'default', { id })!;\n        context = manager.contextForWidget(widget)!;\n        await context.ready;\n        await context.sessionContext.ready;\n        expect(context.sessionContext.session!.kernel!.id).toBe(id);\n        await context.sessionContext.shutdown();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should not start a kernel if not given",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 230,
                "column": 48
            },
            "line": 230,
            "code": "      it('should not start a kernel if not given', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'default')!;\n        context = manager.contextForWidget(widget)!;\n        await dismissDialog();\n        expect(context.sessionContext.session?.kernel).toBeFalsy();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the factory is not found",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 241,
                "column": 61
            },
            "line": 241,
            "code": "      it('should return undefined if the factory is not found', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the factory has no model factory",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 250,
                "column": 69
            },
            "line": 250,
            "code": "      it('should return undefined if the factory has no model factory', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test',\n          modelName: 'foo',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'foo');\n        expect(widget).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should find a widget given a file and a widget name",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 267,
                "column": 61
            },
            "line": 267,
            "code": "      it('should find a widget given a file and a widget name', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path);\n        expect(manager.findWidget(model.path, 'test')).toBe(widget);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should find a widget given a file",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 277,
                "column": 43
            },
            "line": 277,
            "code": "      it('should find a widget given a file', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path);\n        expect(manager.findWidget(model.path)).toBe(widget);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should fail to find a widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 287,
                "column": 38
            },
            "line": 287,
            "code": "      it('should fail to find a widget', () => {\n        expect(manager.findWidget('foo')).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should fail to find a widget with non default factory and the default widget name",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 291,
                "column": 91
            },
            "line": 291,
            "code": "      it('should fail to find a widget with non default factory and the default widget name', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test2',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'test2');\n        expect(manager.findWidget(model.path)).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should find a widget with non default factory given a file and a null widget name",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 305,
                "column": 91
            },
            "line": 305,
            "code": "      it('should find a widget with non default factory given a file and a null widget name', async () => {\n        const widgetFactory2 = new WidgetFactory({\n          name: 'test2',\n          fileTypes: ['text']\n        });\n        manager.registry.addWidgetFactory(widgetFactory2);\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path, 'test2');\n        expect(manager.findWidget(model.path, null)).toBe(widget);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should find the context for a widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#contextForWidget()"
            ],
            "updatePoint": {
                "line": 322,
                "column": 46
            },
            "line": 322,
            "code": "      it('should find the context for a widget', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        context = manager.contextForWidget(widget)!;\n        expect(context.path).toBe(model.path);\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should fail to find the context for the widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#contextForWidget()"
            ],
            "updatePoint": {
                "line": 333,
                "column": 56
            },
            "line": 333,
            "code": "      it('should fail to find the context for the widget', () => {\n        widget = new Widget();\n        expect(manager.contextForWidget(widget)).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should clone the given widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#cloneWidget()"
            ],
            "updatePoint": {
                "line": 340,
                "column": 39
            },
            "line": 340,
            "code": "      it('should clone the given widget', async () => {\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        widget = manager.createNew(model.path)!;\n        const clone = manager.cloneWidget(widget)!;\n        expect(manager.contextForWidget(widget)).toBe(\n          manager.contextForWidget(clone)\n        );\n        await dismissDialog();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the source widget is not managed",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#cloneWidget()"
            ],
            "updatePoint": {
                "line": 353,
                "column": 69
            },
            "line": 353,
            "code": "      it('should return undefined if the source widget is not managed', () => {\n        widget = new Widget();\n        expect(manager.cloneWidget(widget)).toBeUndefined();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should allow widget factories to have custom clone behavior",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#cloneWidget()"
            ],
            "updatePoint": {
                "line": 358,
                "column": 69
            },
            "line": 358,
            "code": "      it('should allow widget factories to have custom clone behavior', () => {\n        widget = manager.createNew('foo', 'CloneTestWidget')!;\n        const clonedWidget: CloneTestWidget = manager.cloneWidget(\n          widget\n        ) as CloneTestWidget;\n        expect(clonedWidget.counter).toBe(1);\n        const newWidget: CloneTestWidget = manager.createNew(\n          'bar',\n          'CloneTestWidget'\n        ) as CloneTestWidget;\n        expect(newWidget.counter).toBe(0);\n        expect(\n          (manager.cloneWidget(clonedWidget) as CloneTestWidget).counter\n        ).toBe(2);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should close the widgets associated with a given path",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#closeFile()"
            ],
            "updatePoint": {
                "line": 376,
                "column": 63
            },
            "line": 376,
            "code": "      it('should close the widgets associated with a given path', async () => {\n        let called = 0;\n        let path = '';\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        path = model.path;\n        widget = manager.createNew(path)!;\n        const clone = manager.cloneWidget(widget)!;\n\n        widget.disposed.connect(() => {\n          called++;\n        });\n        clone.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        await manager.closeFile(path);\n        expect(called).toBe(2);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be a no-op if there are no open files on that path",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#closeFile()"
            ],
            "updatePoint": {
                "line": 398,
                "column": 67
            },
            "line": 398,
            "code": "      it('should be a no-op if there are no open files on that path', async () => {\n        await expect(manager.closeFile('foo')).resolves.not.toThrow();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should close all of the open documents",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#closeAll()"
            ],
            "updatePoint": {
                "line": 404,
                "column": 48
            },
            "line": 404,
            "code": "      it('should close all of the open documents', async () => {\n        let called = 0;\n        let path = '';\n        const model = await services.contents.newUntitled({\n          type: 'file',\n          ext: '.txt'\n        });\n        path = model.path;\n        const widget0 = manager.createNew(path)!;\n        widget0.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        const widget1 = manager.createNew(path)!;\n        widget1.disposed.connect(() => {\n          called++;\n        });\n        await dismissDialog();\n        await manager.closeAll();\n        expect(called).toBe(2);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be a no-op if there are no open documents",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#closeAll()"
            ],
            "updatePoint": {
                "line": 426,
                "column": 58
            },
            "line": 426,
            "code": "      it('should be a no-op if there are no open documents', async () => {\n        await expect(manager.closeAll()).resolves.not.toThrow();\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a new save handler",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 47,
                "column": 42
            },
            "line": 47,
            "code": "      it('should create a new save handler', () => {\n        expect(handler).toBeInstanceOf(SaveHandler);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be the save interval of the handler",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#saveInterval()"
            ],
            "updatePoint": {
                "line": 53,
                "column": 52
            },
            "line": 53,
            "code": "      it('should be the save interval of the handler', () => {\n        expect(handler.saveInterval).toBe(120);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be set-able",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#saveInterval()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 28
            },
            "line": 57,
            "code": "      it('should be set-able', () => {\n        handler.saveInterval = 200;\n        expect(handler.saveInterval).toBe(200);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should test whether the handler is active",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#isActive"
            ],
            "updatePoint": {
                "line": 64,
                "column": 51
            },
            "line": 64,
            "code": "      it('should test whether the handler is active', () => {\n        expect(handler.isActive).toBe(false);\n        handler.start();\n        expect(handler.isActive).toBe(true);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should test whether the handler is disposed",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 72,
                "column": 53
            },
            "line": 72,
            "code": "      it('should test whether the handler is disposed', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be true after the context is disposed",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 78,
                "column": 54
            },
            "line": 78,
            "code": "      it('should be true after the context is disposed', () => {\n        context.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should dispose of the resources used by the handler",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 61
            },
            "line": 85,
            "code": "      it('should dispose of the resources used by the handler', () => {\n        expect(handler.isDisposed).toBe(false);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n        handler.dispose();\n        expect(handler.isDisposed).toBe(true);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should start the save handler",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#start()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 39
            },
            "line": 95,
            "code": "      it('should start the save handler', () => {\n        handler.start();\n        expect(handler.isActive).toBe(true);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should trigger a save",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#start()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 31
            },
            "line": 100,
            "code": "      it('should trigger a save', () => {\n        const promise = signalToPromise(context.fileChanged);\n        context.model.fromString('bar');\n        expect(handler.isActive).toBe(false);\n        handler.saveInterval = 0.1;\n        handler.start();\n        return promise;\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should continue to save",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#start()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 33
            },
            "line": 109,
            "code": "      it('should continue to save', async () => {\n        let called = 0;\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n        const promise = testEmission(context.fileChanged, {\n          test: () => {\n            if (called === 0) {\n              context.model.fromString('bar');\n              called++;\n            }\n            return called === 1;\n          }\n        });\n        context.model.fromString('foo');\n        expect(handler.isActive).toBe(false);\n        handler.saveInterval = 0.1;\n        handler.start();\n        return promise;\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should overwrite the file on disk",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#start()"
            ],
            "updatePoint": {
                "line": 129,
                "column": 43
            },
            "line": 129,
            "code": "      it('should overwrite the file on disk', async () => {\n        const delegate = new PromiseDelegate();\n\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n        context.model.fromString('foo');\n        await context.initialize(true);\n\n        // The context allows up to 0.5 difference in timestamps before complaining.\n        setTimeout(async () => {\n          await manager.contents.save(context.path, {\n            type: factory.contentType,\n            format: factory.fileFormat,\n            content: 'bar'\n          });\n          handler.saveInterval = 1;\n          handler.start();\n          context.model.fromString('baz');\n          context.fileChanged.connect(() => {\n            expect(context.model.toString()).toBe('baz');\n            delegate.resolve(undefined);\n          });\n        }, 1500);\n\n        // Extend the timeout to wait for the dialog because of the setTimeout.\n        await acceptDialog(document.body, 3000);\n        await delegate.promise;\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should revert to the file on disk",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#start()"
            ],
            "updatePoint": {
                "line": 158,
                "column": 43
            },
            "line": 158,
            "code": "      it('should revert to the file on disk', async () => {\n        const delegate = new PromiseDelegate();\n        const revert = () => {\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const buttons = dialog.getElementsByTagName('button');\n\n          for (let i = 0; i < buttons.length; i++) {\n            if (buttons[i].textContent === 'Revert') {\n              buttons[i].click();\n              return;\n            }\n          }\n        };\n\n        // Lower the duration multiplier.\n        (handler as any)._multiplier = 1;\n\n        await context.initialize(true);\n        context.model.fromString('foo');\n        context.fileChanged.connect(() => {\n          expect(context.model.toString()).toBe('bar');\n          delegate.resolve(undefined);\n        });\n\n        // The context allows up to 0.5 difference in timestamps before complaining.\n        setTimeout(async () => {\n          await manager.contents.save(context.path, {\n            type: factory.contentType,\n            format: factory.fileFormat,\n            content: 'bar'\n          });\n          handler.saveInterval = 1;\n          handler.start();\n          context.model.fromString('baz');\n        }, 1500);\n\n        // Extend the timeout to wait for the dialog because of the setTimeout.\n        await waitForDialog(document.body, 3000);\n        revert();\n        await delegate.promise;\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should stop the save timer",
            "suites": [
                "docregistry/savehandler",
                "SaveHandler",
                "#stop()"
            ],
            "updatePoint": {
                "line": 202,
                "column": 36
            },
            "line": 202,
            "code": "      it('should stop the save timer', () => {\n        handler.start();\n        expect(handler.isActive).toBe(true);\n        handler.stop();\n        expect(handler.isActive).toBe(false);\n      });",
            "file": "savehandler.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a new document widget manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 53
            },
            "line": 87,
            "code": "      it('should create a new document widget manager', () => {\n        expect(manager).toBeInstanceOf(DocumentWidgetManager);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should test whether the manager is disposed",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 93,
                "column": 53
            },
            "line": 93,
            "code": "      it('should test whether the manager is disposed', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should dispose of the resources used by the manager",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 101,
                "column": 61
            },
            "line": 101,
            "code": "      it('should dispose of the resources used by the manager', () => {\n        expect(manager.isDisposed).toBe(false);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n        manager.dispose();\n        expect(manager.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createWidget()"
            ],
            "updatePoint": {
                "line": 111,
                "column": 32
            },
            "line": 111,
            "code": "      it('should create a widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(widget).toBeInstanceOf(Widget);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should emit the widgetCreated signal",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#createWidget()"
            ],
            "updatePoint": {
                "line": 117,
                "column": 46
            },
            "line": 117,
            "code": "      it('should emit the widgetCreated signal', () => {\n        let called = false;\n\n        widgetFactory.widgetCreated.connect(() => {\n          called = true;\n        });\n        manager.createWidget(widgetFactory, context);\n        expect(called).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should install a message hook",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#adoptWidget()"
            ],
            "updatePoint": {
                "line": 129,
                "column": 39
            },
            "line": 129,
            "code": "      it('should install a message hook', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        MessageLoop.sendMessage(widget, new Message('foo'));\n        expect(manager.methods).toEqual(\n          expect.arrayContaining(['messageHook'])\n        );\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should add the document class",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#adoptWidget()"
            ],
            "updatePoint": {
                "line": 140,
                "column": 39
            },
            "line": 140,
            "code": "      it('should add the document class', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        expect(widget.hasClass('jp-Document')).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be retrievable",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#adoptWidget()"
            ],
            "updatePoint": {
                "line": 148,
                "column": 31
            },
            "line": 148,
            "code": "      it('should be retrievable', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        expect(manager.contextForWidget(widget)).toBe(context);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should find a registered widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 158,
                "column": 41
            },
            "line": 158,
            "code": "      it('should find a registered widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(manager.findWidget(context, 'test')).toBe(widget);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if not found",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#findWidget()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 46
            },
            "line": 164,
            "code": "      it('should return undefined if not found', () => {\n        expect(manager.findWidget(context, 'test')).toBeUndefined();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return the context for a widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#contextForWidget()"
            ],
            "updatePoint": {
                "line": 170,
                "column": 48
            },
            "line": 170,
            "code": "      it('should return the context for a widget', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n\n        expect(manager.contextForWidget(widget)).toBe(context);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if not tracked",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#contextForWidget()"
            ],
            "updatePoint": {
                "line": 176,
                "column": 48
            },
            "line": 176,
            "code": "      it('should return undefined if not tracked', () => {\n        expect(manager.contextForWidget(new Widget())).toBeUndefined();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a new widget with the same context using the same factory",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#cloneWidget()"
            ],
            "updatePoint": {
                "line": 182,
                "column": 81
            },
            "line": 182,
            "code": "      it('should create a new widget with the same context using the same factory', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const clone = manager.cloneWidget(widget)!;\n\n        expect(clone.hasClass('WidgetFactory')).toBe(true);\n        expect(clone.hasClass('jp-Document')).toBe(true);\n        expect(manager.contextForWidget(clone)).toBe(context);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return undefined if the source widget is not managed",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#cloneWidget()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 69
            },
            "line": 191,
            "code": "      it('should return undefined if the source widget is not managed', () => {\n        expect(manager.cloneWidget(new Widget())).toBeUndefined();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should close all of the widgets associated with a context",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#closeWidgets()"
            ],
            "updatePoint": {
                "line": 197,
                "column": 67
            },
            "line": 197,
            "code": "      it('should close all of the widgets associated with a context', async () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const clone = manager.cloneWidget(widget)!;\n\n        await manager.closeWidgets(context);\n        expect(widget.isDisposed).toBe(true);\n        expect(clone.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be called for a message to a tracked widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#messageHook()"
            ],
            "updatePoint": {
                "line": 208,
                "column": 60
            },
            "line": 208,
            "code": "      it('should be called for a message to a tracked widget', () => {\n        const content = new Widget();\n        const widget = new DocumentWidget({ content, context });\n\n        manager.adoptWidget(context, widget);\n        MessageLoop.sendMessage(widget, new Message('foo'));\n        expect(manager.methods).toEqual(\n          expect.arrayContaining(['messageHook'])\n        );\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return false for close-request messages",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#messageHook()"
            ],
            "updatePoint": {
                "line": 219,
                "column": 56
            },
            "line": 219,
            "code": "      it('should return false for close-request messages', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const msg = new Message('close-request');\n\n        expect(manager.messageHook(widget, msg)).toBe(false);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should return true for other messages",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#messageHook()"
            ],
            "updatePoint": {
                "line": 226,
                "column": 47
            },
            "line": 226,
            "code": "      it('should return true for other messages', () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const msg = new Message('foo');\n\n        expect(manager.messageHook(widget, msg)).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should set the title of the widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#setCaption()"
            ],
            "updatePoint": {
                "line": 235,
                "column": 44
            },
            "line": 235,
            "code": "      it('should set the title of the widget', async () => {\n        await context.initialize(true);\n\n        const widget = manager.createWidget(widgetFactory, context);\n        const delegate = new PromiseDelegate();\n\n        widget.title.changed.connect(async () => {\n          expect(manager.methods).toEqual(\n            expect.arrayContaining(['setCaption'])\n          );\n          expect(widget.title.caption).toContain('Last Checkpoint');\n          await dismissDialog();\n          delegate.resolve(undefined);\n        });\n        await delegate.promise;\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should be called when a widget is closed",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 50
            },
            "line": 254,
            "code": "      it('should be called when a widget is closed', async () => {\n        const widget = manager.createWidget(widgetFactory, context);\n        const delegate = new PromiseDelegate();\n\n        widget.disposed.connect(async () => {\n          expect(manager.methods).toEqual(expect.arrayContaining(['onClose']));\n          await dismissDialog();\n          delegate.resolve(undefined);\n        });\n        widget.close();\n        await delegate.promise;\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should ask confirmation when a widget is closing",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 267,
                "column": 58
            },
            "line": 267,
            "code": "      it('should ask confirmation when a widget is closing', async () => {\n        manager.confirmClosingDocument = true;\n        const widget = manager.createWidget(widgetFactory, context);\n\n        widget.close();\n        await dismissDialog();\n\n        expect(widget.isDisposed).toEqual(false);\n        widget.dispose();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should confirm widget close action",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 278,
                "column": 44
            },
            "line": 278,
            "code": "      it('should confirm widget close action', async () => {\n        manager.confirmClosingDocument = true;\n        const widget = manager.createWidget(widgetFactory, context);\n        const delegate = new PromiseDelegate();\n\n        widget.close();\n        await acceptDialog();\n\n        widget.disposed.connect(async () => {\n          expect(manager.methods).toEqual(expect.arrayContaining(['onClose']));\n          delegate.resolve(undefined);\n        });\n        await delegate.promise;\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should prompt the user before closing",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 293,
                "column": 47
            },
            "line": 293,
            "code": "      it('should prompt the user before closing', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const widget = manager.createWidget(widgetFactory, context);\n        const closed = manager.onClose(widget);\n\n        await Promise.all([dangerDialog(), closed]);\n\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should ask confirmation when a dirty widget is closing",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 305,
                "column": 64
            },
            "line": 305,
            "code": "      it('should ask confirmation when a dirty widget is closing', async () => {\n        manager.confirmClosingDocument = true;\n        context.model.fromString('foo');\n\n        const widget = manager.createWidget(widgetFactory, context);\n        const closed = manager.onClose(widget);\n\n        await Promise.all([dangerDialog(), closed]);\n\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should not prompt if the factory is readonly",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 317,
                "column": 54
            },
            "line": 317,
            "code": "      it('should not prompt if the factory is readonly', async () => {\n        const readonly = manager.createWidget(readOnlyFactory, context);\n\n        await manager.onClose(readonly);\n\n        expect(readonly.isDisposed).toBe(true);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should not prompt if the other widget is writable",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 325,
                "column": 59
            },
            "line": 325,
            "code": "      it('should not prompt if the other widget is writable', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const one = manager.createWidget(widgetFactory, context);\n        const two = manager.createWidget(widgetFactory, context);\n\n        await manager.onClose(one);\n\n        expect(one.isDisposed).toBe(true);\n        expect(two.isDisposed).toBe(false);\n        two.dispose();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should prompt if the only other widget has a readonly factory",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 339,
                "column": 71
            },
            "line": 339,
            "code": "      it('should prompt if the only other widget has a readonly factory', async () => {\n        // Populate the model with content.\n        context.model.fromString('foo');\n\n        const writable = manager.createWidget(widgetFactory, context);\n        const readonly = manager.createWidget(readOnlyFactory, context);\n        const closed = manager.onClose(writable);\n\n        await dangerDialog();\n        await closed;\n\n        expect(writable.isDisposed).toBe(true);\n        expect(readonly.isDisposed).toBe(false);\n        readonly.dispose();\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should close the widget",
            "suites": [
                "@jupyterlab/docmanager",
                "DocumentWidgetManager",
                "#onClose()"
            ],
            "updatePoint": {
                "line": 355,
                "column": 33
            },
            "line": 355,
            "code": "      it('should close the widget', async () => {\n        context.model.fromString('foo');\n        const widget = manager.createWidget(widgetFactory, context);\n        const promise = manager.onClose(widget);\n        await dismissDialog();\n        await promise;\n        expect(widget.isDisposed).toBe(false);\n      });",
            "file": "widgetmanager.spec.ts",
            "skipped": false,
            "dir": "packages/docmanager/test"
        },
        {
            "name": "should create a new context",
            "suites": [
                "docregistry/context",
                "Context",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 37
            },
            "line": 49,
            "code": "      it('should create a new context', () => {\n        context = new Context({\n          manager,\n          factory,\n          path: UUID.uuid4() + '.txt'\n        });\n        expect(context).toBeInstanceOf(Context);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should set the session path with local path",
            "suites": [
                "docregistry/context",
                "Context",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 58,
                "column": 53
            },
            "line": 58,
            "code": "      it('should set the session path with local path', () => {\n        const localPath = `${UUID.uuid4()}.txt`;\n        context = new Context({\n          manager,\n          factory,\n          path: `TestDrive:${localPath}`\n        });\n\n        expect(context.sessionContext.path).toEqual(localPath);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be emitted when the path changes",
            "suites": [
                "docregistry/context",
                "Context",
                "#pathChanged"
            ],
            "updatePoint": {
                "line": 71,
                "column": 49
            },
            "line": 71,
            "code": "      it('should be emitted when the path changes', async () => {\n        const newPath = UUID.uuid4() + '.txt';\n        let called = false;\n        context.pathChanged.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args).toBe(newPath);\n          called = true;\n        });\n        await context.initialize(true);\n        await manager.contents.rename(context.path, newPath);\n        expect(called).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be emitted when the file is saved",
            "suites": [
                "docregistry/context",
                "Context",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 86,
                "column": 50
            },
            "line": 86,
            "code": "      it('should be emitted when the file is saved', async () => {\n        const path = context.path;\n        let called = false;\n        context.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args.path).toBe(path);\n          called = true;\n        });\n        await context.initialize(true);\n        expect(called).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit 'starting' when the file starts saving",
            "suites": [
                "docregistry/context",
                "Context",
                "#saving"
            ],
            "updatePoint": {
                "line": 100,
                "column": 60
            },
            "line": 100,
            "code": "      it(\"should emit 'starting' when the file starts saving\", async () => {\n        let called = false;\n        let checked = false;\n        context.saveState.connect((sender, args) => {\n          if (!called) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args).toBe('started');\n\n            checked = true;\n          }\n\n          called = true;\n        });\n\n        await context.initialize(true);\n        expect(called).toBe(true);\n        expect(checked).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit 'completed' when the file ends saving",
            "suites": [
                "docregistry/context",
                "Context",
                "#saving"
            ],
            "updatePoint": {
                "line": 121,
                "column": 59
            },
            "line": 121,
            "code": "      it(\"should emit 'completed' when the file ends saving\", async () => {\n        let called = 0;\n        let checked = false;\n        context.saveState.connect((sender, args) => {\n          if (called > 0) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(args).toBe('completed');\n            checked = true;\n          }\n\n          called += 1;\n        });\n\n        await context.initialize(true);\n        expect(called).toBe(2);\n        expect(checked).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit 'failed' when the save operation fails out",
            "suites": [
                "docregistry/context",
                "Context",
                "#saving"
            ],
            "updatePoint": {
                "line": 141,
                "column": 64
            },
            "line": 141,
            "code": "      it(\"should emit 'failed' when the save operation fails out\", async () => {\n        context = new Context({\n          manager,\n          factory,\n          path: 'readonly.txt'\n        });\n\n        let called = 0;\n        let checked;\n        context.saveState.connect((sender, args) => {\n          if (called > 0) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(sender).toBe(context);\n            checked = args;\n          }\n\n          called += 1;\n        });\n\n        await expect(context.initialize(true)).rejects.toThrow(\n          'Invalid response: 403 Forbidden'\n        );\n        expect(called).toBe(2);\n        expect(checked).toBe('failed');\n\n        await acceptDialog();\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should indicate whether the context is ready",
            "suites": [
                "docregistry/context",
                "Context",
                "#isReady"
            ],
            "updatePoint": {
                "line": 171,
                "column": 54
            },
            "line": 171,
            "code": "      it('should indicate whether the context is ready', async () => {\n        expect(context.isReady).toBe(false);\n        const func = async () => {\n          await context.ready;\n          expect(context.isReady).toBe(true);\n        };\n        const promise = func();\n        await context.initialize(true);\n        await promise;\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should resolve when the file is saved for the first time",
            "suites": [
                "docregistry/context",
                "Context",
                "#ready()"
            ],
            "updatePoint": {
                "line": 184,
                "column": 66
            },
            "line": 184,
            "code": "      it('should resolve when the file is saved for the first time', async () => {\n        await context.initialize(true);\n        await expect(context.ready).resolves.not.toThrow();\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should resolve when the file is reverted for the first time",
            "suites": [
                "docregistry/context",
                "Context",
                "#ready()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 69
            },
            "line": 189,
            "code": "      it('should resolve when the file is reverted for the first time', async () => {\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(false);\n        await expect(context.ready).resolves.not.toThrow();\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be emitted when the context is disposed",
            "suites": [
                "docregistry/context",
                "Context",
                "#disposed"
            ],
            "updatePoint": {
                "line": 201,
                "column": 56
            },
            "line": 201,
            "code": "      it('should be emitted when the context is disposed', () => {\n        let called = false;\n        context.disposed.connect((sender, args) => {\n          expect(sender).toBe(context);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        context.dispose();\n        expect(called).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the model associated with the document",
            "suites": [
                "docregistry/context",
                "Context",
                "#model"
            ],
            "updatePoint": {
                "line": 214,
                "column": 58
            },
            "line": 214,
            "code": "      it('should be the model associated with the document', () => {\n        expect(context.model.toString()).toBe('');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a ISessionContext object",
            "suites": [
                "docregistry/context",
                "Context",
                "#sessionContext"
            ],
            "updatePoint": {
                "line": 220,
                "column": 44
            },
            "line": 220,
            "code": "      it('should be a ISessionContext object', () => {\n        expect(context.sessionContext).toBeInstanceOf(SessionContext);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the current path for the context",
            "suites": [
                "docregistry/context",
                "Context",
                "#path"
            ],
            "updatePoint": {
                "line": 226,
                "column": 52
            },
            "line": 226,
            "code": "      it('should be the current path for the context', () => {\n        expect(typeof context.path).toBe('string');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be 500ms by default",
            "suites": [
                "docregistry/context",
                "Context",
                "#lastModifiedCheckMargin"
            ],
            "updatePoint": {
                "line": 232,
                "column": 36
            },
            "line": 232,
            "code": "      it('should be 500ms by default', () => {\n        expect(context.lastModifiedCheckMargin).toBe(500);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be set-able",
            "suites": [
                "docregistry/context",
                "Context",
                "#lastModifiedCheckMargin"
            ],
            "updatePoint": {
                "line": 236,
                "column": 28
            },
            "line": 236,
            "code": "      it('should be set-able', () => {\n        context.lastModifiedCheckMargin = 600;\n        expect(context.lastModifiedCheckMargin).toBe(600);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be `null` before population",
            "suites": [
                "docregistry/context",
                "Context",
                "#contentsModel"
            ],
            "updatePoint": {
                "line": 243,
                "column": 44
            },
            "line": 243,
            "code": "      it('should be `null` before population', () => {\n        expect(context.contentsModel).toBeNull();\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be set after population",
            "suites": [
                "docregistry/context",
                "Context",
                "#contentsModel"
            ],
            "updatePoint": {
                "line": 247,
                "column": 40
            },
            "line": 247,
            "code": "      it('should be set after population', async () => {\n        const { path } = context;\n\n        void context.initialize(true);\n        await context.ready;\n        expect(context.contentsModel!.path).toBe(path);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the name of the factory used by the context",
            "suites": [
                "docregistry/context",
                "Context",
                "#factoryName"
            ],
            "updatePoint": {
                "line": 257,
                "column": 63
            },
            "line": 257,
            "code": "      it('should be the name of the factory used by the context', () => {\n        expect(context.factoryName).toBe(factory.name);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should test whether the context is disposed",
            "suites": [
                "docregistry/context",
                "Context",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 263,
                "column": 53
            },
            "line": 263,
            "code": "      it('should test whether the context is disposed', () => {\n        expect(context.isDisposed).toBe(false);\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should dispose of the resources used by the context",
            "suites": [
                "docregistry/context",
                "Context",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 271,
                "column": 61
            },
            "line": 271,
            "code": "      it('should dispose of the resources used by the context', () => {\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n        context.dispose();\n        expect(context.isDisposed).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should change the name of the file to the new name",
            "suites": [
                "docregistry/context",
                "Context",
                "#rename()"
            ],
            "updatePoint": {
                "line": 280,
                "column": 60
            },
            "line": 280,
            "code": "      it('should change the name of the file to the new name', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n\n        const newName = UUID.uuid4() + '.txt';\n\n        await context.rename(newName);\n        await context.save();\n\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n\n        const model = await manager.contents.get(newName, opts);\n\n        expect(model.content).toBe('foo');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should save the contents of the file to disk",
            "suites": [
                "docregistry/context",
                "Context",
                "#save()"
            ],
            "updatePoint": {
                "line": 302,
                "column": 54
            },
            "line": 302,
            "code": "      it('should save the contents of the file to disk', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n        await context.save();\n\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n\n        expect(model.content).toBe('foo');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should should preserve LF line endings upon save",
            "suites": [
                "docregistry/context",
                "Context",
                "#save()"
            ],
            "updatePoint": {
                "line": 317,
                "column": 58
            },
            "line": 317,
            "code": "      it('should should preserve LF line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\nbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\nbar');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should should preserve CR line endings upon save",
            "suites": [
                "docregistry/context",
                "Context",
                "#save()"
            ],
            "updatePoint": {
                "line": 335,
                "column": 58
            },
            "line": 335,
            "code": "      it('should should preserve CR line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\rbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\rbar');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should should preserve CRLF line endings upon save",
            "suites": [
                "docregistry/context",
                "Context",
                "#save()"
            ],
            "updatePoint": {
                "line": 353,
                "column": 60
            },
            "line": 353,
            "code": "      it('should should preserve CRLF line endings upon save', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\r\\nbar'\n        });\n        await context.revert();\n        await context.save();\n        const opts: Contents.IFetchOptions = {\n          format: factory.fileFormat,\n          type: factory.contentType,\n          content: true\n        };\n        const model = await manager.contents.get(context.path, opts);\n        expect(model.content).toBe('foo\\r\\nbar');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should save the document to a different path chosen by the user",
            "suites": [
                "docregistry/context",
                "Context",
                "#saveAs()"
            ],
            "updatePoint": {
                "line": 373,
                "column": 73
            },
            "line": 373,
            "code": "      it('should save the document to a different path chosen by the user', async () => {\n        const initialize = context.initialize(true);\n        const newPath = UUID.uuid4() + '.txt';\n\n        const func = async () => {\n          await initialize;\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n          input.value = newPath;\n          await acceptDialog();\n        };\n        const promise = func();\n        await initialize;\n\n        const changed = signalToPromise(manager.contents.fileChanged);\n        const oldPath = context.path;\n        await context.saveAs();\n        await promise;\n\n        // We no longer rename the current document\n        //expect(context.path).toBe(newPath);\n\n        // Make sure the signal emitted has a different path\n        const res = await changed;\n        expect(res[1].type).toBe('save');\n        expect(res[1].newValue?.path).toEqual(newPath);\n        expect(res[1].newValue?.path !== oldPath).toBe(true);\n\n        // Make sure the both files are there now.\n        const model = await manager.contents.get('', { content: true });\n        expect(model.content.find((x: any) => x.name === oldPath)).toBeTruthy();\n        expect(model.content.find((x: any) => x.name === newPath)).toBeTruthy();\n\n        // Make sure both files are equal\n        const model1 = await manager.contents.get(oldPath, { content: true });\n        const model2 = await manager.contents.get(newPath, { content: true });\n        expect(model1.content).toEqual(model2.content);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should bring up a conflict dialog",
            "suites": [
                "docregistry/context",
                "Context",
                "#saveAs()"
            ],
            "updatePoint": {
                "line": 413,
                "column": 43
            },
            "line": 413,
            "code": "      it('should bring up a conflict dialog', async () => {\n        const newPath = UUID.uuid4() + '.txt';\n\n        const func = async () => {\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n          input.value = newPath;\n          await acceptDialog(); // Accept rename dialog\n          await acceptDialog(); // Accept conflict dialog\n        };\n        await manager.contents.save(newPath, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(true);\n        const promise = func();\n\n        const oldPath = context.path;\n        await context.saveAs();\n        await promise;\n\n        // We no longer rename the current document\n        //expect(context.path).toBe(newPath);\n        // Make sure the both files are there now.\n        const model = await manager.contents.get('', { content: true });\n        expect(model.content.find((x: any) => x.name === oldPath)).toBeTruthy();\n        expect(model.content.find((x: any) => x.name === newPath)).toBeTruthy();\n\n        // Make sure both files are equal\n        const model1 = await manager.contents.get(oldPath, { content: true });\n        const model2 = await manager.contents.get(newPath, { content: true });\n        expect(model1.content).toEqual(model2.content);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should keep the file if overwrite is aborted",
            "suites": [
                "docregistry/context",
                "Context",
                "#saveAs()"
            ],
            "updatePoint": {
                "line": 449,
                "column": 54
            },
            "line": 449,
            "code": "      it('should keep the file if overwrite is aborted', async () => {\n        const oldPath = context.path;\n        const newPath = UUID.uuid4() + '.txt';\n        const func = async () => {\n          await waitForDialog();\n          const dialog = document.body.getElementsByClassName('jp-Dialog')[0];\n          const input = dialog.getElementsByTagName('input')[0];\n          input.value = newPath;\n          await acceptDialog(); // Accept rename dialog\n          await dismissDialog(); // Reject conflict dialog\n        };\n        await manager.contents.save(newPath, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo'\n        });\n        await context.initialize(true);\n        const promise = func();\n        await context.saveAs();\n        await promise;\n        expect(context.path).toBe(oldPath);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should just save if the file name does not change",
            "suites": [
                "docregistry/context",
                "Context",
                "#saveAs()"
            ],
            "updatePoint": {
                "line": 472,
                "column": 59
            },
            "line": 472,
            "code": "      it('should just save if the file name does not change', async () => {\n        const changed = signalToPromise(manager.contents.fileChanged);\n\n        const path = context.path;\n        await context.initialize(true);\n        const promise = context.saveAs();\n        await acceptDialog();\n        await promise;\n        expect(context.path).toBe(path);\n\n        const res = await changed;\n        expect(res[1].newValue?.path).toEqual(path);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should no trigger save signal if the user cancel the dialog",
            "suites": [
                "docregistry/context",
                "Context",
                "#saveAs()"
            ],
            "updatePoint": {
                "line": 486,
                "column": 69
            },
            "line": 486,
            "code": "      it('should no trigger save signal if the user cancel the dialog', async () => {\n        let saveEmitted = false;\n        await context.initialize(true);\n        manager.contents.fileChanged.connect((sender, args) => {\n          if (args.type === 'save') {\n            saveEmitted = true;\n          }\n        });\n        const promise = context.saveAs();\n        await dismissDialog();\n        await promise;\n        expect(saveEmitted).toEqual(false);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should revert the contents of the file to the disk",
            "suites": [
                "docregistry/context",
                "Context",
                "#revert()"
            ],
            "updatePoint": {
                "line": 502,
                "column": 60
            },
            "line": 502,
            "code": "      it('should revert the contents of the file to the disk', async () => {\n        await context.initialize(true);\n        context.model.fromString('foo');\n        await context.save();\n        context.model.fromString('bar');\n        await context.revert();\n        expect(context.model.toString()).toBe('foo');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should normalize CRLF line endings to LF",
            "suites": [
                "docregistry/context",
                "Context",
                "#revert()"
            ],
            "updatePoint": {
                "line": 511,
                "column": 50
            },
            "line": 511,
            "code": "      it('should normalize CRLF line endings to LF', async () => {\n        await context.initialize(true);\n        await manager.contents.save(context.path, {\n          type: factory.contentType,\n          format: factory.fileFormat,\n          content: 'foo\\r\\nbar'\n        });\n        await context.revert();\n        expect(context.model.toString()).toBe('foo\\nbar');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a checkpoint for the file",
            "suites": [
                "docregistry/context",
                "Context",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 524,
                "column": 49
            },
            "line": 524,
            "code": "      it('should create a checkpoint for the file', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        expect(model.id).toBeTruthy();\n        expect(model.last_modified).toBeTruthy();\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should delete the given checkpoint",
            "suites": [
                "docregistry/context",
                "Context",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 533,
                "column": 44
            },
            "line": 533,
            "code": "      it('should delete the given checkpoint', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        await context.deleteCheckpoint(model.id);\n        const models = await context.listCheckpoints();\n        expect(models.length).toBe(0);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should restore the value to the last checkpoint value",
            "suites": [
                "docregistry/context",
                "Context",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 543,
                "column": 63
            },
            "line": 543,
            "code": "      it('should restore the value to the last checkpoint value', async () => {\n        context.model.fromString('bar');\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        context.model.fromString('foo');\n        const id = model.id;\n        await context.save();\n        await context.restoreCheckpoint(id);\n        await context.revert();\n        expect(context.model.toString()).toBe('bar');\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should list the checkpoints for the file",
            "suites": [
                "docregistry/context",
                "Context",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 557,
                "column": 50
            },
            "line": 557,
            "code": "      it('should list the checkpoints for the file', async () => {\n        await context.initialize(true);\n        const model = await context.createCheckpoint();\n        const id = model.id;\n        const models = await context.listCheckpoints();\n        let found = false;\n        for (const model of models) {\n          if (model.id === id) {\n            found = true;\n          }\n        }\n        expect(found).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a url resolver",
            "suites": [
                "docregistry/context",
                "Context",
                "#urlResolver"
            ],
            "updatePoint": {
                "line": 573,
                "column": 34
            },
            "line": 573,
            "code": "      it('should be a url resolver', () => {\n        expect(context.urlResolver).toBeInstanceOf(\n          RenderMimeRegistry.UrlResolver\n        );\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add a sibling widget",
            "suites": [
                "docregistry/context",
                "Context",
                "#addSibling()"
            ],
            "updatePoint": {
                "line": 581,
                "column": 37
            },
            "line": 581,
            "code": "      it('should add a sibling widget', () => {\n        let called = false;\n        const opener = (widget: Widget) => {\n          called = true;\n        };\n        context = new Context({\n          manager,\n          factory,\n          path: UUID.uuid4() + '.txt',\n          opener\n        });\n        context.addSibling(new Widget());\n        expect(called).toBe(true);\n      });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#fileTypes"
            ],
            "updatePoint": {
                "line": 42,
                "column": 39
            },
            "line": 42,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.fileTypes).toEqual(['text']);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#name"
            ],
            "updatePoint": {
                "line": 52,
                "column": 39
            },
            "line": 52,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.name).toBe('test');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to an empty array",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#defaultFor"
            ],
            "updatePoint": {
                "line": 62,
                "column": 42
            },
            "line": 62,
            "code": "      it('should default to an empty array', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.defaultFor).toEqual([]);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#defaultFor"
            ],
            "updatePoint": {
                "line": 70,
                "column": 39
            },
            "line": 70,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          defaultFor: ['text']\n        });\n        expect(factory.defaultFor).toEqual(['text']);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to an empty array",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#defaultRendered"
            ],
            "updatePoint": {
                "line": 81,
                "column": 42
            },
            "line": 81,
            "code": "      it('should default to an empty array', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.defaultRendered).toEqual([]);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#defaultRendered"
            ],
            "updatePoint": {
                "line": 89,
                "column": 39
            },
            "line": 89,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          defaultRendered: ['text']\n        });\n        expect(factory.defaultRendered).toEqual(['text']);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to false",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 100,
                "column": 33
            },
            "line": 100,
            "code": "      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.readOnly).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 108,
                "column": 39
            },
            "line": 108,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          readOnly: true\n        });\n        expect(factory.readOnly).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to `text`",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#modelName"
            ],
            "updatePoint": {
                "line": 119,
                "column": 34
            },
            "line": 119,
            "code": "      it('should default to `text`', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.modelName).toBe('text');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#modelName"
            ],
            "updatePoint": {
                "line": 127,
                "column": 39
            },
            "line": 127,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          modelName: 'notebook'\n        });\n        expect(factory.modelName).toBe('notebook');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to false",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#preferKernel"
            ],
            "updatePoint": {
                "line": 138,
                "column": 33
            },
            "line": 138,
            "code": "      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.preferKernel).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#preferKernel"
            ],
            "updatePoint": {
                "line": 146,
                "column": 39
            },
            "line": 146,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          preferKernel: true\n        });\n        expect(factory.preferKernel).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should default to false",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#canStartKernel"
            ],
            "updatePoint": {
                "line": 157,
                "column": 33
            },
            "line": 157,
            "code": "      it('should default to false', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text']\n        });\n        expect(factory.canStartKernel).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be the value passed in",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#canStartKernel"
            ],
            "updatePoint": {
                "line": 165,
                "column": 39
            },
            "line": 165,
            "code": "      it('should be the value passed in', () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          canStartKernel: true\n        });\n        expect(factory.canStartKernel).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should have toolbar items",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#canStartKernel"
            ],
            "updatePoint": {
                "line": 174,
                "column": 35
            },
            "line": 174,
            "code": "      it('should have toolbar items', async () => {\n        const factory = new WidgetFactory({\n          name: 'test',\n          fileTypes: ['text'],\n          toolbarFactory: () => [\n            {\n              name: 'foo',\n              widget: new Widget()\n            },\n            {\n              name: 'bar',\n              widget: new Widget()\n            }\n          ]\n        });\n        const context = await createFileContextWithMockedServices();\n        const widget = factory.createNew(context);\n        const widget2 = factory.createNew(context);\n        expect(Array.from(widget.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(Array.from(widget2.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(Array.from(widget.toolbar.children()).length).toBe(3);\n        expect(Array.from(widget2.toolbar.children()).length).toBe(3);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get whether the factory has been disposed",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 208,
                "column": 58
            },
            "line": 208,
            "code": "      it('should get whether the factory has been disposed', () => {\n        const factory = createFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should dispose of the resources held by the factory",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 217,
                "column": 61
            },
            "line": 217,
            "code": "      it('should dispose of the resources held by the factory', () => {\n        const factory = createFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 223,
                "column": 47
            },
            "line": 223,
            "code": "      it('should be safe to call multiple times', () => {\n        const factory = createFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a new widget given a document model and a context",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 232,
                "column": 73
            },
            "line": 232,
            "code": "      it('should create a new widget given a document model and a context', async () => {\n        const factory = createFactory();\n        const context = await createFileContextWithMockedServices();\n        const widget = factory.createNew(context);\n        expect(widget).toBeInstanceOf(Widget);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should take an optional source widget for cloning",
            "suites": [
                "docregistry/default",
                "ABCWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 239,
                "column": 59
            },
            "line": 239,
            "code": "      it('should take an optional source widget for cloning', async () => {\n        const factory = createFactory();\n        const context = await createFileContextWithMockedServices();\n        const widget = factory.createNew(context);\n        const clonedWidget: IDocumentWidget = factory.createNew(\n          context,\n          widget\n        );\n        expect(clonedWidget).not.toBe(widget);\n        expect(clonedWidget.hasClass('WidgetFactory')).toBe(true);\n        expect(clonedWidget.context).toBe(widget.context);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the name of the model type",
            "suites": [
                "docregistry/default",
                "Base64ModelFactory",
                "#name"
            ],
            "updatePoint": {
                "line": 256,
                "column": 47
            },
            "line": 256,
            "code": "      it('should get the name of the model type', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.name).toBe('base64');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the file type",
            "suites": [
                "docregistry/default",
                "Base64ModelFactory",
                "#contentType"
            ],
            "updatePoint": {
                "line": 263,
                "column": 34
            },
            "line": 263,
            "code": "      it('should get the file type', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.contentType).toBe('file');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the file format",
            "suites": [
                "docregistry/default",
                "Base64ModelFactory",
                "#fileFormat"
            ],
            "updatePoint": {
                "line": 270,
                "column": 36
            },
            "line": 270,
            "code": "      it('should get the file format', () => {\n        const factory = new Base64ModelFactory();\n        expect(factory.fileFormat).toBe('base64');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a new document model",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 279,
                "column": 44
            },
            "line": 279,
            "code": "      it('should create a new document model', () => {\n        const model = new DocumentModel();\n        expect(model).toBeInstanceOf(DocumentModel);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should accept an optional language preference",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 284,
                "column": 55
            },
            "line": 284,
            "code": "      it('should accept an optional language preference', () => {\n        const model = new DocumentModel({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get whether the model has been disposed",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 291,
                "column": 56
            },
            "line": 291,
            "code": "      it('should get whether the model has been disposed', () => {\n        const model = new DocumentModel();\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be emitted when the content of the model changes",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#contentChanged"
            ],
            "updatePoint": {
                "line": 300,
                "column": 65
            },
            "line": 300,
            "code": "      it('should be emitted when the content of the model changes', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.contentChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        model.fromString('foo');\n        expect(called).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should not be emitted if the content does not change",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#contentChanged"
            ],
            "updatePoint": {
                "line": 312,
                "column": 62
            },
            "line": 312,
            "code": "      it('should not be emitted if the content does not change', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        model.fromString('');\n        expect(called).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be emitted when the state of the model changes",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 324,
                "column": 63
            },
            "line": 324,
            "code": "      it('should be emitted when the state of the model changes', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('readOnly');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.readOnly = true;\n        expect(called).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should not be emitted if the state does not change",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 338,
                "column": 60
            },
            "line": 338,
            "code": "      it('should not be emitted if the state does not change', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.dirty = false;\n        expect(called).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the dirty state of the document",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#dirty"
            ],
            "updatePoint": {
                "line": 350,
                "column": 52
            },
            "line": 350,
            "code": "      it('should get the dirty state of the document', () => {\n        const model = new DocumentModel();\n        expect(model.dirty).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit `stateChanged` when changed",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#dirty"
            ],
            "updatePoint": {
                "line": 355,
                "column": 49
            },
            "line": 355,
            "code": "      it('should emit `stateChanged` when changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('dirty');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.dirty = true;\n        expect(called).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should not emit `stateChanged` when not changed",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#dirty"
            ],
            "updatePoint": {
                "line": 369,
                "column": 57
            },
            "line": 369,
            "code": "      it('should not emit `stateChanged` when not changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.dirty = false;\n        expect(called).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the read only state of the document",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 381,
                "column": 56
            },
            "line": 381,
            "code": "      it('should get the read only state of the document', () => {\n        const model = new DocumentModel();\n        expect(model.readOnly).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit `stateChanged` when changed",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 386,
                "column": 49
            },
            "line": 386,
            "code": "      it('should emit `stateChanged` when changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('readOnly');\n          expect(args.oldValue).toBe(false);\n          expect(args.newValue).toBe(true);\n          called = true;\n        });\n        model.readOnly = true;\n        expect(called).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should not emit `stateChanged` when not changed",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#readOnly"
            ],
            "updatePoint": {
                "line": 400,
                "column": 57
            },
            "line": 400,
            "code": "      it('should not emit `stateChanged` when not changed', () => {\n        const model = new DocumentModel();\n        let called = false;\n        model.stateChanged.connect(() => {\n          called = true;\n        });\n        model.readOnly = false;\n        expect(called).toBe(false);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the default kernel name of the document",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#defaultKernelName"
            ],
            "updatePoint": {
                "line": 412,
                "column": 60
            },
            "line": 412,
            "code": "      it('should get the default kernel name of the document', () => {\n        const model = new DocumentModel();\n        expect(model.defaultKernelName).toBe('');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the default kernel language of the document",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "defaultKernelLanguage"
            ],
            "updatePoint": {
                "line": 419,
                "column": 64
            },
            "line": 419,
            "code": "      it('should get the default kernel language of the document', () => {\n        const model = new DocumentModel();\n        expect(model.defaultKernelLanguage).toBe('');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be set by the constructor arg",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "defaultKernelLanguage"
            ],
            "updatePoint": {
                "line": 424,
                "column": 46
            },
            "line": 424,
            "code": "      it('should be set by the constructor arg', () => {\n        const model = new DocumentModel({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should dispose of the resources held by the document manager",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 431,
                "column": 70
            },
            "line": 431,
            "code": "      it('should dispose of the resources held by the document manager', () => {\n        const model = new DocumentModel();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 437,
                "column": 47
            },
            "line": 437,
            "code": "      it('should be safe to call more than once', () => {\n        const model = new DocumentModel();\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should serialize the model to a string",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#toString()"
            ],
            "updatePoint": {
                "line": 446,
                "column": 48
            },
            "line": 446,
            "code": "      it('should serialize the model to a string', () => {\n        const model = new DocumentModel();\n        expect(model.toString()).toBe('');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should deserialize the model from a string",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#fromString()"
            ],
            "updatePoint": {
                "line": 453,
                "column": 52
            },
            "line": 453,
            "code": "      it('should deserialize the model from a string', () => {\n        const model = new DocumentModel();\n        model.fromString('foo');\n        expect(model.toString()).toBe('foo');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should serialize the model to JSON",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 461,
                "column": 44
            },
            "line": 461,
            "code": "      it('should serialize the model to JSON', () => {\n        const model = new DocumentModel();\n        const data = { foo: 1 };\n        model.fromJSON(data);\n        expect(model.toJSON()).toEqual(data);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should deserialize the model from JSON",
            "suites": [
                "docregistry/default",
                "DocumentModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 470,
                "column": 48
            },
            "line": 470,
            "code": "      it('should deserialize the model from JSON', () => {\n        const model = new DocumentModel();\n        const data: null = null;\n        model.fromJSON(data);\n        expect(model.toString()).toBe('null');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the name of the model type",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#name"
            ],
            "updatePoint": {
                "line": 481,
                "column": 47
            },
            "line": 481,
            "code": "      it('should get the name of the model type', () => {\n        const factory = new TextModelFactory();\n        expect(factory.name).toBe('text');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the file type",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#contentType"
            ],
            "updatePoint": {
                "line": 488,
                "column": 34
            },
            "line": 488,
            "code": "      it('should get the file type', () => {\n        const factory = new TextModelFactory();\n        expect(factory.contentType).toBe('file');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the file format",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#fileFormat"
            ],
            "updatePoint": {
                "line": 495,
                "column": 36
            },
            "line": 495,
            "code": "      it('should get the file format', () => {\n        const factory = new TextModelFactory();\n        expect(factory.fileFormat).toBe('text');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get whether the factory is disposed",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 502,
                "column": 52
            },
            "line": 502,
            "code": "      it('should get whether the factory is disposed', () => {\n        const factory = new TextModelFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should dispose of the resources held by the factory",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 511,
                "column": 61
            },
            "line": 511,
            "code": "      it('should dispose of the resources held by the factory', () => {\n        const factory = new TextModelFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 517,
                "column": 47
            },
            "line": 517,
            "code": "      it('should be safe to call multiple times', () => {\n        const factory = new TextModelFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a new model",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 526,
                "column": 35
            },
            "line": 526,
            "code": "      it('should create a new model', () => {\n        const factory = new TextModelFactory();\n        const model = factory.createNew();\n        expect(model).toBeInstanceOf(DocumentModel);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should accept a language preference",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 532,
                "column": 45
            },
            "line": 532,
            "code": "      it('should accept a language preference', () => {\n        const factory = new TextModelFactory();\n        const model = factory.createNew({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the preferred kernel language given an extension",
            "suites": [
                "docregistry/default",
                "TextModelFactory",
                "#preferredLanguage()"
            ],
            "updatePoint": {
                "line": 540,
                "column": 69
            },
            "line": 540,
            "code": "      it('should get the preferred kernel language given an extension', () => {\n        const factory = new TextModelFactory();\n        expect(factory.preferredLanguage('.py')).toBe('');\n        expect(factory.preferredLanguage('.jl')).toBe('');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should set the title for the path",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#constructor"
            ],
            "updatePoint": {
                "line": 572,
                "column": 43
            },
            "line": 572,
            "code": "      it('should set the title for the path', () => {\n        expect(widget.title.label).toBe(context.localPath);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should update the title when the path changes",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#constructor"
            ],
            "updatePoint": {
                "line": 576,
                "column": 55
            },
            "line": 576,
            "code": "      it('should update the title when the path changes', async () => {\n        const path = UUID.uuid4() + '.jl';\n        await manager.contents.rename(context.path, path);\n        expect(widget.title.label).toBe(path);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add the dirty class when the model is dirty",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#constructor"
            ],
            "updatePoint": {
                "line": 582,
                "column": 60
            },
            "line": 582,
            "code": "      it('should add the dirty class when the model is dirty', async () => {\n        context.model.fromString('bar');\n        expect(widget.title.className).toContain('jp-mod-dirty');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should remove the dirty class",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#constructor"
            ],
            "updatePoint": {
                "line": 587,
                "column": 39
            },
            "line": 587,
            "code": "      it('should remove the dirty class', () => {\n        context.model.dirty = true;\n        context.model.dirty = true;\n        expect(widget.title.className).toContain('jp-mod-dirty');\n        context.model.dirty = false;\n        expect(widget.title.className).not.toContain('jp-mod-dirty');\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should store the context",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#constructor"
            ],
            "updatePoint": {
                "line": 595,
                "column": 34
            },
            "line": 595,
            "code": "      it('should store the context', () => {\n        expect(widget.context).toBe(context);\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should resolve after the reveal and context ready promises",
            "suites": [
                "docregistry/default",
                "DocumentWidget",
                "#revealed"
            ],
            "updatePoint": {
                "line": 603,
                "column": 68
            },
            "line": 603,
            "code": "      it('should resolve after the reveal and context ready promises', async () => {\n        const thisContext = new Context({\n          manager,\n          factory: new TextModelFactory(),\n          path: UUID.uuid4()\n        });\n        const x = Object.create(null);\n        const reveal = sleep(300, x);\n        const contextReady = Promise.all([thisContext.ready, x]);\n        const widget = new DocumentWidget({\n          context: thisContext,\n          content,\n          reveal\n        });\n        expect(widget.isRevealed).toBe(false);\n\n        // Our promise should resolve before the widget reveal promise.\n        expect(await Promise.race([widget.revealed, reveal])).toBe(x);\n        // The context ready promise should also resolve first.\n        void thisContext.initialize(true);\n        expect(await Promise.race([widget.revealed, contextReady])).toEqual([\n          undefined,\n          x\n        ]);\n        // The widget.revealed promise should finally resolve.\n        expect(await widget.revealed).toBeUndefined();\n\n        thisContext.dispose();\n      });",
            "file": "default.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should require a context parameter",
            "suites": [
                "docregistry/mimedocument",
                "MimeDocumentFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 44
            },
            "line": 60,
            "code": "      it('should require a context parameter', () => {\n        const widgetFactory = new MimeDocumentFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          rendermime: RENDERMIME,\n          primaryFileType: DocumentRegistry.getDefaultTextFileType()\n        });\n        expect(widgetFactory.createNew(dContext)).toBeInstanceOf(MimeDocument);\n      });",
            "file": "mimedocument.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should require options",
            "suites": [
                "docregistry/mimedocument",
                "MimeContent",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 32
            },
            "line": 74,
            "code": "      it('should require options', () => {\n        const renderer = RENDERMIME.createRenderer('text/markdown');\n        const widget = new MimeContent({\n          context: dContext,\n          renderer,\n          mimeType: 'text/markdown',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        expect(widget).toBeInstanceOf(MimeContent);\n      });",
            "file": "mimedocument.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should resolve when the widget is ready",
            "suites": [
                "docregistry/mimedocument",
                "MimeContent",
                "#ready"
            ],
            "updatePoint": {
                "line": 88,
                "column": 49
            },
            "line": 88,
            "code": "      it('should resolve when the widget is ready', async () => {\n        const renderer = RENDERMIME.createRenderer('text/markdown');\n        const widget = new LogRenderer({\n          context: dContext,\n          renderer,\n          mimeType: 'text/markdown',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        await widget.ready;\n        const layout = widget.layout as BoxLayout;\n        expect(layout.widgets.length).toBe(1);\n      });",
            "file": "mimedocument.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should change the document contents",
            "suites": [
                "docregistry/mimedocument",
                "MimeContent",
                "contents changed"
            ],
            "updatePoint": {
                "line": 104,
                "column": 45
            },
            "line": 104,
            "code": "      it('should change the document contents', async () => {\n        RENDERMIME.addFactory(fooFactory);\n        const emission = testEmission(dContext.model.contentChanged, {\n          test: () => {\n            expect(dContext.model.toString()).toBe('bar');\n          }\n        });\n        const renderer = RENDERMIME.createRenderer('text/foo');\n        const widget = new LogRenderer({\n          context: dContext,\n          renderer,\n          mimeType: 'text/foo',\n          renderTimeout: 1000,\n          dataType: 'string'\n        });\n        await widget.ready;\n        await emission;\n      });",
            "file": "mimedocument.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get whether the registry has been disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 63,
                "column": 59
            },
            "line": 63,
            "code": "      it('should get whether the registry has been disposed', () => {\n        expect(registry.isDisposed).toBe(false);\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should dispose of the resources held by the registry",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 71,
                "column": 62
            },
            "line": 71,
            "code": "      it('should dispose of the resources held by the registry', () => {\n        registry.addFileType({ name: 'notebook', extensions: ['.ipynb'] });\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 77,
                "column": 47
            },
            "line": 77,
            "code": "      it('should be safe to call multiple times', () => {\n        registry.dispose();\n        registry.dispose();\n        expect(registry.isDisposed).toBe(true);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add the widget factory to the registry",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 55
            },
            "line": 85,
            "code": "      it('should add the widget factory to the registry', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(registry.getWidgetFactory(factory.name)).toBe(factory);\n        expect(registry.getWidgetFactory(factory.name.toUpperCase())).toBe(\n          factory\n        );\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should become the global default if `*` is given as a defaultFor",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 94,
                "column": 74
            },
            "line": 94,
            "code": "      it('should become the global default if `*` is given as a defaultFor', () => {\n        const factory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('*').name).toBe('global');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should override an existing global default",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 52
            },
            "line": 104,
            "code": "      it('should override an existing global default', () => {\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'global',\n            fileTypes: ['*'],\n            defaultFor: ['*']\n          })\n        );\n        const factory = new WidgetFactory({\n          name: 'bar',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('*').name).toBe('bar');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should override an existing extension default",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 55
            },
            "line": 121,
            "code": "      it('should override an existing extension default', () => {\n        registry.addWidgetFactory(createFactory());\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be removed from the registry when disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 59
            },
            "line": 128,
            "code": "      it('should be removed from the registry when disposed', () => {\n        const factory = createFactory();\n        const disposable = registry.addWidgetFactory(factory);\n        disposable.dispose();\n        expect(registry.getWidgetFactory('test')).toBeUndefined();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should throw for an invalid factory name",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetFactory()"
            ],
            "updatePoint": {
                "line": 135,
                "column": 50
            },
            "line": 135,
            "code": "      it('should throw for an invalid factory name', () => {\n        expect(() => {\n          registry.addWidgetFactory(\n            new WidgetFactory({\n              name: 'default',\n              fileTypes: [],\n              defaultFor: []\n            })\n          );\n        }).toThrow(/Invalid/);\n        expect(() => {\n          registry.addWidgetFactory(\n            new WidgetFactory({\n              name: '',\n              fileTypes: [],\n              defaultFor: []\n            })\n          );\n        }).toThrow(/Invalid/);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add the model factory to the registry",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addModelFactory()"
            ],
            "updatePoint": {
                "line": 158,
                "column": 54
            },
            "line": 158,
            "code": "      it('should add the model factory to the registry', () => {\n        const factory = new Base64ModelFactory();\n        expect(() => {\n          registry.addModelFactory(factory);\n        }).not.toThrow();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op a factory with the given `name` is already registered",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addModelFactory()"
            ],
            "updatePoint": {
                "line": 165,
                "column": 81
            },
            "line": 165,
            "code": "      it('should be a no-op a factory with the given `name` is already registered', () => {\n        const factory = new Base64ModelFactory();\n        registry.addModelFactory(factory);\n\n        expect(() => {\n          const disposable = registry.addModelFactory(new Base64ModelFactory());\n          disposable.dispose();\n        }).not.toThrow();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op if the same factory is already registered",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addModelFactory()"
            ],
            "updatePoint": {
                "line": 175,
                "column": 69
            },
            "line": 175,
            "code": "      it('should be a no-op if the same factory is already registered', () => {\n        const factory = new Base64ModelFactory();\n        registry.addModelFactory(factory);\n        expect(() => {\n          const disposable = registry.addModelFactory(factory);\n          disposable.dispose();\n        }).not.toThrow();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be removed from the registry when disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addModelFactory()"
            ],
            "updatePoint": {
                "line": 184,
                "column": 59
            },
            "line": 184,
            "code": "      it('should be removed from the registry when disposed', () => {\n        const factory = new Base64ModelFactory();\n        expect(() => {\n          const disposable = registry.addModelFactory(factory);\n          disposable.dispose();\n        }).not.toThrow();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add a widget extension to the registry",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetExtension()"
            ],
            "updatePoint": {
                "line": 194,
                "column": 55
            },
            "line": 194,
            "code": "      it('should add a widget extension to the registry', () => {\n        const extension = new WidgetExtension();\n        registry.addWidgetExtension('foo', extension);\n        expect(registry.widgetExtensions('foo').next().value).toBe(extension);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op if the extension is already registered for a given widget factory",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetExtension()"
            ],
            "updatePoint": {
                "line": 200,
                "column": 93
            },
            "line": 200,
            "code": "      it('should be a no-op if the extension is already registered for a given widget factory', () => {\n        const extension = new WidgetExtension();\n        registry.addWidgetExtension('foo', extension);\n        const disposable = registry.addWidgetExtension('foo', extension);\n        disposable.dispose();\n        expect(registry.widgetExtensions('foo').next().value).toBe(extension);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be removed from the registry when disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addWidgetExtension()"
            ],
            "updatePoint": {
                "line": 208,
                "column": 59
            },
            "line": 208,
            "code": "      it('should be removed from the registry when disposed', () => {\n        const extension = new WidgetExtension();\n        const disposable = registry.addWidgetExtension('foo', extension);\n        disposable.dispose();\n        expect(Array.from(registry.widgetExtensions('foo')).length).toBe(0);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add a file type to the document registry",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 217,
                "column": 57
            },
            "line": 217,
            "code": "      it('should add a file type to the document registry', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        registry.addFileType(fileType);\n        expect(registry.fileTypes().next().value.name).toBe(fileType.name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be removed from the registry when disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 224,
                "column": 59
            },
            "line": 224,
            "code": "      it('should be removed from the registry when disposed', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        const disposable = registry.addFileType(fileType);\n        disposable.dispose();\n        expect(Array.from(registry.fileTypes()).length).toBe(0);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op if a file type of the same name is registered",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 232,
                "column": 73
            },
            "line": 232,
            "code": "      it('should be a no-op if a file type of the same name is registered', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const fileType = { name: 'notebook', extensions: ['.ipynb'] };\n        registry.addFileType(fileType);\n        const disposable = registry.addFileType(fileType);\n        disposable.dispose();\n        expect(registry.fileTypes().next().value.name).toBe(fileType.name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add a file type to some factories",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 241,
                "column": 50
            },
            "line": 241,
            "code": "      it('should add a file type to some factories', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        expect(registry.defaultWidgetFactory('dummy.test').name).toEqual(\n          gFactory.name\n        );\n\n        const fileType = { name: 'test-file', extensions: ['.test'] };\n        registry.addFileType(fileType, [factory.name]);\n        expect(registry.defaultWidgetFactory('dummy.test').name).toEqual(\n          factory.name\n        );\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should add a file type to some factories without changing the default",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 263,
                "column": 79
            },
            "line": 263,
            "code": "      it('should add a file type to some factories without changing the default', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n\n        const newFactory = new WidgetFactory({\n          name: 'new-factory',\n          fileTypes: ['new-foobar']\n        });\n        registry.addWidgetFactory(newFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.foo.bar'] };\n        registry.addFileType(fileType, [newFactory.name]);\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n        expect(\n          registry.preferredWidgetFactories('dummy.foo.bar').map(f => f.name)\n        ).toContain(newFactory.name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should remove the link to factory when disposed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 294,
                "column": 57
            },
            "line": 294,
            "code": "      it('should remove the link to factory when disposed', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.test'] };\n        const disposable = registry.addFileType(fileType, [factory.name]);\n\n        disposable.dispose();\n\n        expect(registry.defaultWidgetFactory('dummy.test').name).toBe(\n          gFactory.name\n        );\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should remove the link to factory when disposed without changing the default",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#addFileType()"
            ],
            "updatePoint": {
                "line": 315,
                "column": 86
            },
            "line": 315,
            "code": "      it('should remove the link to factory when disposed without changing the default', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n\n        const newFactory = new WidgetFactory({\n          name: 'new-factory',\n          fileTypes: ['new-foobar']\n        });\n        registry.addWidgetFactory(newFactory);\n\n        const fileType = { name: 'test-file', extensions: ['.foo.bar'] };\n        const disposable = registry.addFileType(fileType, [newFactory.name]);\n\n        disposable.dispose();\n\n        expect(registry.defaultWidgetFactory('dummy.foo.bar').name).toEqual(\n          factory.name\n        );\n        expect(\n          registry.preferredWidgetFactories('dummy.foo.bar').map(f => f.name)\n        ).not.toContain(newFactory.name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should give the valid registered widget factories",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 353,
                "column": 59
            },
            "line": 353,
            "code": "      it('should give the valid registered widget factories', () => {\n        expect(\n          Array.from(registry.preferredWidgetFactories('foo.txt'))\n        ).toEqual([]);\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const factories = registry.preferredWidgetFactories('a.foo.bar');\n        expect(Array.from(factories)).toEqual([factory, gFactory]);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should not list a factory whose model is not registered",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 369,
                "column": 65
            },
            "line": 369,
            "code": "      it('should not list a factory whose model is not registered', () => {\n        registry.addWidgetFactory(createFactory('foobar'));\n        expect(registry.preferredWidgetFactories('a.foo.bar').length).toEqual(\n          0\n        );\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should select the factory for a given extension",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 376,
                "column": 57
            },
            "line": 376,
            "code": "      it('should select the factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.preferredWidgetFactories('a.txt')[0]).toBe(factory);\n        expect(registry.preferredWidgetFactories('a.md')[0]).toBe(mdFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should respect the priority order",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 388,
                "column": 43
            },
            "line": 388,
            "code": "      it('should respect the priority order', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        const factories = registry.preferredWidgetFactories('a.txt');\n        expect(Array.from(factories)).toEqual([factory, gFactory]);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should list a default rendered factory after the default factory",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 406,
                "column": 74
            },
            "line": 406,
            "code": "      it('should list a default rendered factory after the default factory', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultRendered: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n\n        const factories = registry.preferredWidgetFactories('a.md');\n        expect(factories).toEqual([mdFactory, gFactory]);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle multi-part extensions",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 426,
                "column": 45
            },
            "line": 426,
            "code": "      it('should handle multi-part extensions', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const tFactory = new WidgetFactory({\n          name: 'table',\n          fileTypes: ['tablejson']\n        });\n        registry.addWidgetFactory(tFactory);\n        const jFactory = new WidgetFactory({\n          name: 'json',\n          fileTypes: ['json']\n        });\n        registry.addWidgetFactory(jFactory);\n        let factories = registry.preferredWidgetFactories('foo.table.json');\n        expect(Array.from(factories)).toEqual([tFactory, jFactory]);\n        factories = registry.preferredWidgetFactories('foo.json');\n        expect(Array.from(factories)).toEqual([jFactory]);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle just a multi-part extension",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#preferredWidgetFactories()"
            ],
            "updatePoint": {
                "line": 445,
                "column": 51
            },
            "line": 445,
            "code": "      it('should handle just a multi-part extension', () => {\n        const factory = new WidgetFactory({\n          name: 'table',\n          fileTypes: ['tablejson']\n        });\n        registry.addWidgetFactory(factory);\n        let factories = registry.preferredWidgetFactories('foo.table.json');\n        expect(Array.from(factories)).toEqual([factory]);\n        factories = registry.preferredWidgetFactories('foo.json');\n        expect(Array.from(factories)).toEqual([]);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the default widget factory for a given extension",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#defaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 459,
                "column": 69
            },
            "line": 459,
            "code": "      it('should get the default widget factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultFor: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n        expect(registry.defaultWidgetFactory('a.md')).toBe(mdFactory);\n        expect(registry.defaultWidgetFactory()).toBe(gFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should override the default widget factory for a file type",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 481,
                "column": 68
            },
            "line": 481,
            "code": "      it('should override the default widget factory for a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(mdFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should override the default rendered widget factory for a file type",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 492,
                "column": 77
            },
            "line": 492,
            "code": "      it('should override the default rendered widget factory for a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        expect(registry.defaultRenderedWidgetFactory('a.foo.bar')).toBe(\n          mdFactory\n        );\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should revert to the default widget factory when unset",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 505,
                "column": 64
            },
            "line": 505,
            "code": "      it('should revert to the default widget factory when unset', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        registry.setDefaultWidgetFactory('foobar', undefined);\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should throw if the factory or file type do not exist",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 519,
                "column": 63
            },
            "line": 519,
            "code": "      it('should throw if the factory or file type do not exist', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        expect(() => {\n          registry.setDefaultWidgetFactory('foobar', 'fake');\n        }).toThrow(/Cannot find/);\n        expect(() => {\n          registry.setDefaultWidgetFactory('fake', undefined);\n        }).toThrow(/Cannot find/);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should throw if the factory cannot render a file type",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 530,
                "column": 63
            },
            "line": 530,
            "code": "      it('should throw if the factory cannot render a file type', () => {\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultFor: []\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(() => {\n          registry.setDefaultWidgetFactory('foobar', 'markdown');\n        }).toThrow(/cannot view/);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should revert to the default widget factory if the override is removed",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#setDefaultWidgetFactory()"
            ],
            "updatePoint": {
                "line": 542,
                "column": 80
            },
            "line": 542,
            "code": "      it('should revert to the default widget factory if the override is removed', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown', 'foobar'],\n          defaultFor: []\n        });\n        const disposable = registry.addWidgetFactory(mdFactory);\n        registry.setDefaultWidgetFactory('foobar', 'markdown');\n        disposable.dispose();\n        expect(registry.defaultWidgetFactory('a.foo.bar')).toBe(factory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the default rendered widget factory for a given extension",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#defaultRenderedWidgetFactory()"
            ],
            "updatePoint": {
                "line": 558,
                "column": 78
            },
            "line": 558,
            "code": "      it('should get the default rendered widget factory for a given extension', () => {\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown'],\n          defaultRendered: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.defaultRenderedWidgetFactory('a.baz')).toBe(factory);\n        expect(registry.defaultRenderedWidgetFactory('a.md')).toBe(mdFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the default widget factory if no default rendered factory is registered",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#defaultRenderedWidgetFactory()"
            ],
            "updatePoint": {
                "line": 571,
                "column": 92
            },
            "line": 571,
            "code": "      it('should get the default widget factory if no default rendered factory is registered', () => {\n        const gFactory = new WidgetFactory({\n          name: 'global',\n          fileTypes: ['*'],\n          defaultFor: ['*']\n        });\n        registry.addWidgetFactory(gFactory);\n        expect(registry.defaultRenderedWidgetFactory('a.md')).toBe(gFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the registered file types",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#fileTypes()"
            ],
            "updatePoint": {
                "line": 583,
                "column": 46
            },
            "line": 583,
            "code": "      it('should get the registered file types', () => {\n        registry = new DocumentRegistry({ initialFileTypes: [] });\n        expect(Array.from(registry.fileTypes()).length).toBe(0);\n        const fileTypes = [\n          { name: 'notebook', extensions: ['.ipynb'] },\n          { name: 'python', extensions: ['.py'] },\n          { name: 'table', extensions: ['.table.json'] }\n        ];\n        registry.addFileType(fileTypes[0]);\n        registry.addFileType(fileTypes[1]);\n        registry.addFileType(fileTypes[2]);\n        const values = registry.fileTypes();\n        expect(values.next().value.name).toBe(fileTypes[0].name);\n        expect(values.next().value.name).toBe(fileTypes[1].name);\n        expect(values.next().value.name).toBe(fileTypes[2].name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get a file type by name",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileType()"
            ],
            "updatePoint": {
                "line": 602,
                "column": 40
            },
            "line": 602,
            "code": "      it('should get a file type by name', () => {\n        expect(registry.getFileType('notebook')).toBeTruthy();\n        expect(registry.getFileType('python')).toBeTruthy();\n        expect(registry.getFileType('fizzbuzz')).toBeUndefined();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get a kernel preference",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getKernelPreference()"
            ],
            "updatePoint": {
                "line": 610,
                "column": 40
            },
            "line": 610,
            "code": "      it('should get a kernel preference', () => {\n        registry.addWidgetFactory(createFactory());\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'python',\n            fileTypes: ['python'],\n            preferKernel: true,\n            canStartKernel: true\n          })\n        );\n        registry.addWidgetFactory(\n          new WidgetFactory({\n            name: 'global',\n            fileTypes: ['*'],\n            defaultFor: ['*']\n          })\n        );\n        let pref = registry.getKernelPreference('.c', 'global');\n        expect(pref!.shouldStart).toBe(false);\n        expect(pref!.canStart).toBe(false);\n\n        pref = registry.getKernelPreference('.py', 'python');\n        expect(pref!.shouldStart).toBe(true);\n        expect(pref!.canStart).toBe(true);\n\n        pref = registry.getKernelPreference('.py', 'baz');\n        expect(pref).toBeUndefined();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get a registered model factory by name",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getModelFactory()"
            ],
            "updatePoint": {
                "line": 641,
                "column": 55
            },
            "line": 641,
            "code": "      it('should get a registered model factory by name', () => {\n        const mFactory = new Base64ModelFactory();\n        registry.addModelFactory(mFactory);\n        expect(registry.getModelFactory('base64')).toBe(mFactory);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get a widget factory by name",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getWidgetFactory()"
            ],
            "updatePoint": {
                "line": 649,
                "column": 45
            },
            "line": 649,
            "code": "      it('should get a widget factory by name', () => {\n        registry.addModelFactory(new Base64ModelFactory());\n        const factory = createFactory();\n        registry.addWidgetFactory(factory);\n        const mdFactory = new WidgetFactory({\n          name: 'markdown',\n          fileTypes: ['markdown']\n        });\n        registry.addWidgetFactory(mdFactory);\n        expect(registry.getWidgetFactory(factory.name)).toBe(factory);\n        expect(registry.getWidgetFactory('markdown')).toBe(mdFactory);\n        expect(registry.getWidgetFactory('baz')).toBeUndefined();\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the registered extensions for a given widget",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#widgetExtensions()"
            ],
            "updatePoint": {
                "line": 665,
                "column": 65
            },
            "line": 665,
            "code": "      it('should get the registered extensions for a given widget', () => {\n        const foo = new WidgetExtension();\n        const bar = new WidgetExtension();\n        registry.addWidgetExtension('fizz', foo);\n        registry.addWidgetExtension('fizz', bar);\n        registry.addWidgetExtension('buzz', foo);\n        const fizz = Array.from(registry.widgetExtensions('fizz'));\n        expect(fizz[0]).toBe(foo);\n        expect(fizz[1]).toBe(bar);\n        expect(fizz.length).toBe(2);\n        const buzz = Array.from(registry.widgetExtensions('buzz'));\n        expect(buzz[0]).toBe(foo);\n        expect(Array.from(buzz).length).toBe(1);\n        expect(registry.widgetExtensions('baz').next().done).toBe(true);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle a directory",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 689,
                "column": 35
            },
            "line": 689,
            "code": "      it('should handle a directory', () => {\n        const ft = registry.getFileTypeForModel({\n          type: 'directory'\n        });\n        expect(ft.name).toBe('directory');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle a notebook",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 696,
                "column": 34
            },
            "line": 696,
            "code": "      it('should handle a notebook', () => {\n        const ft = registry.getFileTypeForModel({\n          type: 'notebook'\n        });\n        expect(ft.name).toBe('notebook');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle a python file",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 703,
                "column": 37
            },
            "line": 703,
            "code": "      it('should handle a python file', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.py'\n        });\n        expect(ft.name).toBe('python');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle an unknown file",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 710,
                "column": 39
            },
            "line": 710,
            "code": "      it('should handle an unknown file', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.bar'\n        });\n        expect(ft.name).toBe('text');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the most specific extension",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 717,
                "column": 48
            },
            "line": 717,
            "code": "      it('should get the most specific extension', () => {\n        [\n          { name: 'json', extensions: ['.json'] },\n          { name: 'vega', extensions: ['.vg.json'] }\n        ].forEach(ft => {\n          registry.addFileType(ft);\n        });\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.vg.json'\n        });\n        expect(ft.name).toBe('vega');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be case insensitive",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypeForModel()"
            ],
            "updatePoint": {
                "line": 730,
                "column": 36
            },
            "line": 730,
            "code": "      it('should be case insensitive', () => {\n        const ft = registry.getFileTypeForModel({\n          name: 'foo.PY'\n        });\n        expect(ft.name).toBe('python');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle a notebook",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 745,
                "column": 34
            },
            "line": 745,
            "code": "      it('should handle a notebook', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.ipynb');\n        expect(ft[0].name).toBe('notebook');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should handle a python file",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 750,
                "column": 37
            },
            "line": 750,
            "code": "      it('should handle a python file', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.py');\n        expect(ft[0].name).toBe('python');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should return an empty list for an unknown file",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 755,
                "column": 57
            },
            "line": 755,
            "code": "      it('should return an empty list for an unknown file', () => {\n        const ft = registry.getFileTypesForPath('foo/bar/baz.weird');\n        expect(ft.length).toBe(0);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should get the most specific extension first",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 760,
                "column": 54
            },
            "line": 760,
            "code": "      it('should get the most specific extension first', () => {\n        [\n          { name: 'json', extensions: ['.json'] },\n          { name: 'vega', extensions: ['.vg.json'] }\n        ].forEach(ft => {\n          registry.addFileType(ft);\n        });\n        const ft = registry.getFileTypesForPath('foo/bar/baz.vg.json');\n        expect(ft[0].name).toBe('vega');\n        expect(ft[1].name).toBe('json');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be case insensitive",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "line": 772,
            "code": "      it.each([\n        ['python', null, 'foo/bar/baz.PY'],\n        ['r-markdown', ['.Rmd'], 'foo/bar/baz.Rmd']\n      ])('should be case insensitive', (name, extensions, filename) => {\n        if (extensions) {\n          registry.addFileType({ name, extensions });\n        }\n        const ft = registry.getFileTypesForPath(filename);\n        expect(ft[0].name).toBe(name);\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should support pattern matching",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 783,
                "column": 41
            },
            "line": 783,
            "code": "      it('should support pattern matching', () => {\n        registry.addFileType({\n          name: 'test',\n          extensions: ['.temp'],\n          pattern: '.*\\\\.test$'\n        });\n\n        const ft = registry.getFileTypesForPath('foo/bar/baz.test');\n        expect(ft[0].name).toBe('test');\n\n        const ft2 = registry.getFileTypesForPath('foo/bar/baz.temp');\n        expect(ft2[0].name).toBe('test');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should returns all file types",
            "suites": [
                "docregistry/registry",
                "DocumentRegistry",
                "#getFileTypesForPath()"
            ],
            "updatePoint": {
                "line": 797,
                "column": 39
            },
            "line": 797,
            "code": "      it('should returns all file types', () => {\n        registry.addFileType({\n          name: 'test',\n          extensions: ['.foo.bar']\n        });\n\n        const ft = registry.getFileTypesForPath('foo/bar/test.foo.bar');\n        expect(ft.length).toBeGreaterThanOrEqual(2);\n        expect(ft.map(f => f.name)).toContain('test');\n      });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a session context",
            "suites": [
                "mock",
                "createSimpleSessionContext()"
            ],
            "updatePoint": {
                "line": 13,
                "column": 39
            },
            "line": 13,
            "code": "    it('should create a session context', () => {\n      const context = Mock.createSimpleSessionContext();\n      expect(context.session!.kernel!.name).toEqual(DEFAULT_NAME);\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should accept a session model",
            "suites": [
                "mock",
                "createSimpleSessionContext()"
            ],
            "updatePoint": {
                "line": 18,
                "column": 37
            },
            "line": 18,
            "code": "    it('should accept a session model', () => {\n      const context = Mock.createSimpleSessionContext({\n        name: 'hi',\n        path: 'foo',\n        type: 'bar',\n        kernel: { name: 'fizz' }\n      });\n      expect(context.name).toEqual('hi');\n      expect(context.path).toEqual('foo');\n      expect(context.type).toEqual('bar');\n      expect(context.session!.kernel!.name).toEqual('fizz');\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should update the kernel status",
            "suites": [
                "mock",
                "updateKernelStatus()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 39
            },
            "line": 33,
            "code": "    it('should update the kernel status', () => {\n      const context = Mock.createSimpleSessionContext();\n      let called = false;\n      context.statusChanged.connect((_, status) => {\n        if (status === 'dead') {\n          called = true;\n        }\n      });\n      Mock.updateKernelStatus(context, 'dead');\n      expect(context.session!.kernel!.status).toEqual('dead');\n      expect(called).toEqual(true);\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should emit an iopub message",
            "suites": [
                "mock",
                "emitIopubMessage"
            ],
            "updatePoint": {
                "line": 48,
                "column": 36
            },
            "line": 48,
            "code": "    it('should emit an iopub message', () => {\n      const context = Mock.createSimpleSessionContext();\n      const source = KernelMessage.createMessage({\n        channel: 'iopub',\n        msgType: 'execute_input',\n        session: 'foo',\n        username: 'bar',\n        msgId: 'fizz',\n        content: {\n          code: 'hello, world!',\n          execution_count: 0\n        }\n      });\n      let called = false;\n      context.iopubMessage.connect((_, msg) => {\n        expect(msg).toBe(source);\n        called = true;\n      });\n      Mock.emitIopubMessage(context, source);\n      expect(called).toBe(true);\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a new context",
            "suites": [
                "mock",
                "SessionContextMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 73,
                "column": 37
            },
            "line": 73,
            "code": "      it('should create a new context', () => {\n        const context = new Mock.SessionContextMock({}, null);\n        expect(context.session!.kernel!.name).toBe(DEFAULT_NAME);\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "mock",
                "SessionContextMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 78,
                "column": 31
            },
            "line": 78,
            "code": "      it('should accept options', () => {\n        const session = new SessionConnectionMock({}, null);\n        const context = new Mock.SessionContextMock({ path: 'foo' }, session);\n        expect(context.session).toBe(session);\n        expect(context.path).toBe('foo');\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionContextMock",
                ".dispose()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 27
            },
            "line": 87,
            "code": "      it('should be a no-op', () => {\n        const context = new Mock.SessionContextMock({}, null);\n        expect(() => {\n          context.dispose();\n        }).not.toThrow();\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionContextMock",
                ".initialize()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 27
            },
            "line": 96,
            "code": "      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.initialize()).resolves.not.toThrow();\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionContextMock",
                ".ready"
            ],
            "updatePoint": {
                "line": 103,
                "column": 27
            },
            "line": 103,
            "code": "      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.ready).resolves.not.toThrow();\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should change the kernel",
            "suites": [
                "mock",
                "SessionContextMock",
                ".changeKernel()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 34
            },
            "line": 110,
            "code": "      it('should change the kernel', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        const oldId = context.session!.kernel!.id;\n        const kernel = await context.changeKernel({ name: DEFAULT_NAME });\n        expect(kernel!.id).not.toBe(oldId);\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionContextMock",
                ".shutdown()"
            ],
            "updatePoint": {
                "line": 119,
                "column": 27
            },
            "line": 119,
            "code": "      it('should be a no-op', async () => {\n        const context = new Mock.SessionContextMock({}, null);\n        await expect(context.shutdown()).resolves.not.toThrow();\n      });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a context without a kernel",
            "suites": [
                "mock",
                "createFileContext()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 48
            },
            "line": 127,
            "code": "    it('should create a context without a kernel', async () => {\n      const context = await Mock.createFileContextWithMockedServices();\n      expect(context.sessionContext.session).toBe(null);\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should create a context with a kernel",
            "suites": [
                "mock",
                "createFileContext()"
            ],
            "updatePoint": {
                "line": 132,
                "column": 45
            },
            "line": 132,
            "code": "    it('should create a context with a kernel', async () => {\n      const context = await Mock.createFileContextWithMockedServices(true);\n      expect(context.sessionContext.session!.kernel!.name).toBe(DEFAULT_NAME);\n    });",
            "file": "testutils.spec.ts",
            "skipped": false,
            "dir": "packages/docregistry/test"
        },
        {
            "name": "should copy case from %s to %s yielding %s",
            "suites": [
                "documentsearch/genericsearchprovider",
                "GenericSearchProvider",
                "#preserveCase()"
            ],
            "line": 26,
            "code": "      it.each([\n        ['OLD_TEXT_1', 'new_text_1', 'NEW_TEXT_1'],\n        ['OLD_TEXT_1', 'NEW_TEXT_1', 'NEW_TEXT_1'],\n        ['old_text_1', 'new_text_1', 'new_text_1'],\n        ['old_text_1', 'NEW_TEXT_1', 'new_text_1'],\n        ['Old', 'new', 'New'],\n        ['Old', '𐐶ew', '𐐎ew']\n      ])(\n        'should copy case from %s to %s yielding %s',\n        (oldText, newText, expected) => {\n          const replace = GenericSearchProvider.preserveCase(oldText, newText);\n          expect(replace).toEqual(expected);\n        }\n      );",
            "file": "documentsearchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should highlight %s fragment in %s",
            "suites": [
                "documentsearch/genericsearchprovider",
                "GenericSearchProvider",
                "#startQuery()"
            ],
            "line": 43,
            "code": "      it.each([\n        [/x/, '<pre>xyz</pre>', `<mark class=\"${MATCH_CLASSES}\">x</mark>yz`],\n        [/y/, '<pre>xyz</pre>', `x<mark class=\"${MATCH_CLASSES}\">y</mark>z`],\n        [/z/, '<pre>xyz</pre>', `xy<mark class=\"${MATCH_CLASSES}\">z</mark>`],\n        [\n          /x/,\n          '<pre><span>x</span>yz</pre>',\n          `<span><mark class=\"${MATCH_CLASSES}\">x</mark></span>yz`\n        ],\n        [\n          /y/,\n          '<pre><span>x</span>yz</pre>',\n          `<span>x</span><mark class=\"${MATCH_CLASSES}\">y</mark>z`\n        ],\n        [\n          /z/,\n          '<pre><span>x</span>yz</pre>',\n          `<span>x</span>y<mark class=\"${MATCH_CLASSES}\">z</mark>`\n        ],\n        [\n          /x/,\n          '<pre>x<span>y</span>z</pre>',\n          `<mark class=\"${MATCH_CLASSES}\">x</mark><span>y</span>z`\n        ],\n        [\n          /y/,\n          '<pre>x<span>y</span>z</pre>',\n          `x<span><mark class=\"${MATCH_CLASSES}\">y</mark></span>z`\n        ],\n        [\n          /z/,\n          '<pre>x<span>y</span>z</pre>',\n          `x<span>y</span><mark class=\"${MATCH_CLASSES}\">z</mark>`\n        ],\n        [\n          /x/,\n          '<pre>xy<span>z</span></pre>',\n          `<mark class=\"${MATCH_CLASSES}\">x</mark>y<span>z</span>`\n        ],\n        [\n          /y/,\n          '<pre>xy<span>z</span></pre>',\n          `x<mark class=\"${MATCH_CLASSES}\">y</mark><span>z</span>`\n        ],\n        [\n          /z/,\n          '<pre>xy<span>z</span></pre>',\n          `xy<span><mark class=\"${MATCH_CLASSES}\">z</mark></span>`\n        ]\n      ])(\n        'should highlight %s fragment in %s',\n        async (query, content, expected) => {\n          widget.node.innerHTML = content;\n          await provider.startQuery(query);\n          expect(widget.node.firstElementChild!.innerHTML).toEqual(expected);\n        }\n      );",
            "file": "documentsearchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should restore highlighted %s fragment in %s",
            "suites": [
                "documentsearch/genericsearchprovider",
                "GenericSearchProvider",
                "#endQuery()"
            ],
            "line": 103,
            "code": "      it.each([\n        [/x/, '<pre>xyz</pre>'],\n        [/y/, '<pre>xyz</pre>'],\n        [/z/, '<pre>xyz</pre>'],\n        [/x/, '<pre><span>x</span>yz</pre>'],\n        [/y/, '<pre><span>x</span>yz</pre>'],\n        [/z/, '<pre><span>x</span>yz</pre>'],\n        [/x/, '<pre>x<span>y</span>z</pre>'],\n        [/y/, '<pre>x<span>y</span>z</pre>'],\n        [/z/, '<pre>x<span>y</span>z</pre>'],\n        [/x/, '<pre>xy<span>z</span></pre>'],\n        [/y/, '<pre>xy<span>z</span></pre>'],\n        [/z/, '<pre>xy<span>z</span></pre>']\n      ])(\n        'should restore highlighted %s fragment in %s',\n        async (query, content) => {\n          widget.node.innerHTML = content;\n          await provider.startQuery(query);\n          await provider.endQuery();\n          expect(widget.node.innerHTML).toEqual(content);\n        }\n      );",
            "file": "documentsearchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should notify provider of new query when set",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#searchExpression"
            ],
            "updatePoint": {
                "line": 54,
                "column": 54
            },
            "line": 54,
            "code": "      it('should notify provider of new query when set', async () => {\n        model.searchExpression = 'query';\n        expect(model.searchExpression).toEqual('query');\n        const query = (await provider.queryReceived)!;\n        expect(query.test('query')).toEqual(true);\n        query.lastIndex = 0;\n        expect(query.test('test')).toEqual(false);\n        query.lastIndex = 0;\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should set informative string message on invalid regex",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#parsingError"
            ],
            "updatePoint": {
                "line": 66,
                "column": 64
            },
            "line": 66,
            "code": "      it('should set informative string message on invalid regex', async () => {\n        model.useRegex = true;\n        expect(model.parsingError).toEqual('');\n        model.searchExpression = 'query\\\\';\n        await signalToPromise(model.stateChanged);\n        expect(model.parsingError).toEqual(\n          'SyntaxError: Invalid regular expression: /query\\\\/: \\\\ at end of pattern'\n        );\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should return inital query from provider",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#suggestedInitialQuery"
            ],
            "updatePoint": {
                "line": 78,
                "column": 50
            },
            "line": 78,
            "code": "      it('should return inital query from provider', () => {\n        expect(model.suggestedInitialQuery).toEqual('unset');\n        provider.initialQuery = 'provider-set-query';\n        expect(model.suggestedInitialQuery).toEqual('provider-set-query');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should set/get inital non-empty query",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#initialQuery"
            ],
            "updatePoint": {
                "line": 86,
                "column": 47
            },
            "line": 86,
            "code": "      it('should set/get inital non-empty query', () => {\n        model.initialQuery = 'externally-set-query';\n        expect(model.initialQuery).toEqual('externally-set-query');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should fallback to previous search expression on empty value in setter",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#initialQuery"
            ],
            "updatePoint": {
                "line": 90,
                "column": 80
            },
            "line": 90,
            "code": "      it('should fallback to previous search expression on empty value in setter', () => {\n        model.searchExpression = 'search-expression';\n        model.initialQuery = '';\n        expect(model.initialQuery).toEqual('search-expression');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should remember last query",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#initialQuery"
            ],
            "updatePoint": {
                "line": 95,
                "column": 36
            },
            "line": 95,
            "code": "      it('should remember last query', async () => {\n        model.initialQuery = 'query';\n        expect(model.initialQuery).toEqual('query');\n        await model.endQuery();\n        expect(model.initialQuery).toEqual('query');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should start a case-sensitive query",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#caseSensitive"
            ],
            "updatePoint": {
                "line": 104,
                "column": 45
            },
            "line": 104,
            "code": "      it('should start a case-sensitive query', async () => {\n        model.searchExpression = 'query';\n        model.caseSensitive = true;\n        expect(model.caseSensitive).toEqual(true);\n        let query = (await provider.queryReceived)!;\n        expect(query.test('query')).toEqual(true);\n        query.lastIndex = 0;\n        expect(query.test('QUERY')).toEqual(false);\n        query.lastIndex = 0;\n\n        model.caseSensitive = false;\n        expect(model.caseSensitive).toEqual(false);\n        query = (await provider.queryReceived)!;\n        expect(query.test('query')).toEqual(true);\n        query.lastIndex = 0;\n        expect(query.test('QUERY')).toEqual(true);\n        query.lastIndex = 0;\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should start a whole-words query",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#wholeWords"
            ],
            "updatePoint": {
                "line": 125,
                "column": 42
            },
            "line": 125,
            "code": "      it('should start a whole-words query', async () => {\n        model.searchExpression = 'query';\n        model.wholeWords = true;\n        expect(model.wholeWords).toEqual(true);\n        let query = (await provider.queryReceived)!;\n        expect(query.test(' query ')).toEqual(true);\n        query.lastIndex = 0;\n        expect(query.test('XqueryX')).toEqual(false);\n        query.lastIndex = 0;\n\n        model.wholeWords = false;\n        expect(model.wholeWords).toEqual(false);\n        query = (await provider.queryReceived)!;\n        expect(query.test(' query ')).toEqual(true);\n        query.lastIndex = 0;\n        expect(query.test('XqueryX')).toEqual(true);\n        query.lastIndex = 0;\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "defaults to empty string",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#replaceText"
            ],
            "updatePoint": {
                "line": 146,
                "column": 34
            },
            "line": 146,
            "code": "      it('defaults to empty string', () => {\n        expect(model.replaceText).toEqual('');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "changes after assignment with setter",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#replaceText"
            ],
            "updatePoint": {
                "line": 150,
                "column": 46
            },
            "line": 150,
            "code": "      it('changes after assignment with setter', () => {\n        model.replaceText = 'test';\n        expect(model.replaceText).toEqual('test');\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "emits `stateChanged` signal on assignment",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#replaceText"
            ],
            "updatePoint": {
                "line": 155,
                "column": 51
            },
            "line": 155,
            "code": "      it('emits `stateChanged` signal on assignment', () => {\n        let emitted = false;\n        model.stateChanged.connect(() => {\n          emitted = true;\n        });\n        model.replaceText = 'test';\n        expect(emitted).toEqual(true);\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "does not emit `stateChanged` signal if value has not changed",
            "suites": [
                "documentsearch/searchmodel",
                "SearchDocumentModel",
                "#replaceText"
            ],
            "updatePoint": {
                "line": 164,
                "column": 70
            },
            "line": 164,
            "code": "      it('does not emit `stateChanged` signal if value has not changed', () => {\n        let emitted = 0;\n        model.stateChanged.connect(() => {\n          emitted += 1;\n        });\n        model.replaceText = '1';\n        model.replaceText = '1';\n        expect(emitted).toEqual(1);\n      });",
            "file": "searchmodel.spec.ts",
            "skipped": false,
            "dir": "packages/documentsearch/test"
        },
        {
            "name": "should return new FileBrowser instance",
            "suites": [
                "filebrowser/browser",
                "FileBrowser",
                "#constructor"
            ],
            "updatePoint": {
                "line": 71,
                "column": 48
            },
            "line": 71,
            "code": "      it('should return new FileBrowser instance', () => {\n        expect(fileBrowser).toBeInstanceOf(FileBrowser);\n      });",
            "file": "browser.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should focus newly created directory after rename",
            "suites": [
                "filebrowser/browser",
                "FileBrowser",
                "#createNewDirectory"
            ],
            "updatePoint": {
                "line": 77,
                "column": 59
            },
            "line": 77,
            "code": "      it('should focus newly created directory after rename', async () => {\n        const created = fileBrowser.createNewDirectory();\n        await signalToPromise(fileBrowser.renameCalled);\n        const editNode = document.querySelector(`.${EDITOR_CLASS}`);\n        if (!editNode) {\n          throw new Error('Edit node not found');\n        }\n        const itemNode = Array.from(\n          document.querySelectorAll(`.${ITEM_CLASS}`)\n        ).find(el => {\n          return el.contains(editNode);\n        });\n        if (!itemNode) {\n          throw new Error('Item node not found');\n        }\n        simulate(editNode, 'keydown', {\n          keyCode: 13,\n          key: 'Enter'\n        });\n        await created;\n        expect(itemNode.contains(document.activeElement)).toBe(true);\n      });",
            "file": "browser.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should focus newly created file after rename",
            "suites": [
                "filebrowser/browser",
                "FileBrowser",
                "#createNewFile"
            ],
            "updatePoint": {
                "line": 102,
                "column": 54
            },
            "line": 102,
            "code": "      it('should focus newly created file after rename', async () => {\n        const created = fileBrowser.createNewFile({ ext: '.txt' });\n        await signalToPromise(fileBrowser.renameCalled);\n        const editNode = document.querySelector(`.${EDITOR_CLASS}`);\n        if (!editNode) {\n          throw new Error('Edit node not found');\n        }\n        const itemNode = Array.from(\n          document.querySelectorAll(`.${ITEM_CLASS}`)\n        ).find(el => {\n          return el.contains(editNode);\n        });\n        if (!itemNode) {\n          throw new Error('Item node not found');\n        }\n        simulate(editNode, 'keydown', {\n          keyCode: 13,\n          key: 'Enter'\n        });\n        await created;\n        expect(itemNode.contains(document.activeElement)).toBe(true);\n      });",
            "file": "browser.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should create a new BreadCrumbs instance",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 97,
                "column": 50
            },
            "line": 97,
            "code": "      it('should create a new BreadCrumbs instance', () => {\n        const bread = new BreadCrumbs({ model });\n        expect(bread).toBeInstanceOf(BreadCrumbs);\n        const items = crumbs.node.querySelectorAll(ITEM_QUERY);\n        expect(items.length).toBe(1);\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should add the jp-BreadCrumbs class",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 45
            },
            "line": 104,
            "code": "      it('should add the jp-BreadCrumbs class', () => {\n        expect(crumbs.hasClass('jp-BreadCrumbs')).toBe(true);\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should switch to the parent directory",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 111,
                "column": 49
            },
            "line": 111,
            "code": "        it('should switch to the parent directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(4);\n          const promise = signalToPromise(model.pathChanged);\n          expect(items[2].textContent).toBe(second);\n          simulate(items[2], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(3);\n        });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should switch to the home directory",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 125,
                "column": 47
            },
            "line": 125,
            "code": "        it('should switch to the home directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.pathChanged);\n          simulate(items[0], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(1);\n          expect(model.path).toBe('');\n        });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should switch to the grandparent directory",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 138,
                "column": 54
            },
            "line": 138,
            "code": "        it('should switch to the grandparent directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.pathChanged);\n          simulate(items[1], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(2);\n          expect(model.path).toBe(first);\n        });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should refresh the current directory",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#handleEvent()",
                "click"
            ],
            "updatePoint": {
                "line": 151,
                "column": 48
            },
            "line": 151,
            "code": "        it('should refresh the current directory', async () => {\n          Widget.attach(crumbs, document.body);\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          let items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          const promise = signalToPromise(model.refreshed);\n          expect(items[3].textContent).toBe(third);\n          simulate(items[3], 'click');\n          await promise;\n          MessageLoop.sendMessage(crumbs, Widget.Msg.UpdateRequest);\n          items = crumbs.node.querySelectorAll(ITEM_QUERY);\n          expect(items.length).toBe(4);\n          expect(model.path).toBe(path);\n        });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 168,
                "column": 39
            },
            "line": 168,
            "code": "      it('should post an update request', async () => {\n        Widget.attach(crumbs, document.body);\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        await framePromise();\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should add event listeners",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 179,
                "column": 36
            },
            "line": 179,
            "code": "      it('should add event listeners', () => {\n        Widget.attach(crumbs, document.body);\n        simulate(crumbs.node, 'click');\n        expect(crumbs.events).toEqual(expect.arrayContaining(['click']));\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should remove event listeners",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#onBeforeDetach()"
            ],
            "updatePoint": {
                "line": 187,
                "column": 39
            },
            "line": 187,
            "code": "      it('should remove event listeners', () => {\n        Widget.attach(crumbs, document.body);\n        Widget.detach(crumbs);\n        simulate(crumbs.node, 'click');\n        expect(crumbs.events).not.toEqual(expect.arrayContaining(['click']));\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be called when the model updates",
            "suites": [
                "filebrowser/model",
                "BreadCrumbs",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 196,
                "column": 49
            },
            "line": 196,
            "code": "      it('should be called when the model updates', async () => {\n        const model = new FileBrowserModel({ manager });\n        await model.cd(path);\n        crumbs = new LogCrumbs({ model });\n        await model.cd('..');\n        await framePromise();\n\n        expect(crumbs.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        const items = crumbs.node.querySelectorAll(ITEM_QUERY);\n        expect(items.length).toBe(3);\n        model.dispose();\n      });",
            "file": "crumbs.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should reflect initial conditions",
            "suites": [
                "filebrowser/listing",
                "DirListing"
            ],
            "updatePoint": {
                "line": 78,
                "column": 41
            },
            "line": 78,
            "code": "    it('should reflect initial conditions', () => {\n      // Check initial conditions\n      const selectedItems = [...dirListing.selectedItems()];\n      const sortedItems = [...dirListing.sortedItems()];\n      expect(selectedItems).toHaveLength(0);\n      expect(sortedItems).toHaveLength(4);\n    });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should return new DirListing instance",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#constructor"
            ],
            "updatePoint": {
                "line": 87,
                "column": 47
            },
            "line": 87,
            "code": "      it('should return new DirListing instance', () => {\n        const options = createOptionsForConstructor();\n        const dirListing = new DirListing(options);\n        expect(dirListing).toBeInstanceOf(DirListing);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "backspace during rename does not trigger goUp method",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#rename"
            ],
            "updatePoint": {
                "line": 95,
                "column": 62
            },
            "line": 95,
            "code": "      it('backspace during rename does not trigger goUp method', async () => {\n        dirListing.selectNext();\n        const newNamePromise = dirListing.rename();\n        const goUpSpy = jest.spyOn(dirListing as any, 'goUp');\n        const editNode = dirListing['_editNode'];\n        simulate(editNode, 'keydown', {\n          key: 'Backspace',\n          keyCode: 8\n        });\n        // Can input node's value be changed with simulated key events?\n        editNode.value = 'new_name.txt';\n        simulate(editNode, 'keydown', {\n          key: 'Enter',\n          keyCode: 13\n        });\n        const newName = await newNamePromise;\n        expect(newName).toBe('new_name.txt');\n        expect(goUpSpy).not.toHaveBeenCalled();\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should focus item after rename",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#rename"
            ],
            "updatePoint": {
                "line": 115,
                "column": 40
            },
            "line": 115,
            "code": "      it('should focus item after rename', async () => {\n        dirListing.selectNext();\n        const newNamePromise = dirListing.rename();\n        const directoryUpdated = signalToPromise(dirListing.updated);\n        const editNode = dirListing['_editNode'];\n        // Give it a name that should put it at the bottom\n        editNode.value = 'z.txt';\n        simulate(editNode, 'keydown', {\n          key: 'Enter',\n          keyCode: 13\n        });\n        await newNamePromise;\n        const sortedItems = [...dirListing.sortedItems()];\n        const lastIndex = sortedItems.length - 1;\n        expect(sortedItems[lastIndex].name).toBe('z.txt');\n        const itemNode = dirListing['_items'][lastIndex];\n        await directoryUpdated;\n        expect(itemNode.contains(document.activeElement)).toBe(true);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should keep focus on item after user presses escape key",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#rename"
            ],
            "updatePoint": {
                "line": 135,
                "column": 65
            },
            "line": 135,
            "code": "      it('should keep focus on item after user presses escape key', async () => {\n        dirListing.selectNext();\n        const newNamePromise = dirListing.rename();\n        const editNode = dirListing['_editNode'];\n        simulate(editNode, 'keydown', {\n          key: 'Escape',\n          keyCode: 27\n        });\n        await newNamePromise;\n        const itemNode = dirListing['_items'][0];\n        expect(itemNode.contains(document.activeElement)).toBe(true);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should only select when to-index is same as from-index",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect"
            ],
            "updatePoint": {
                "line": 150,
                "column": 64
            },
            "line": 150,
            "code": "      it('should only select when to-index is same as from-index', () => {\n        // to-index unselected\n        dirListing['_focusItem'](1);\n        expect(Object.keys(dirListing['selection'])).toHaveLength(0);\n        dirListing['_handleMultiSelect'](1);\n        expect(Object.keys(dirListing['selection'])).toHaveLength(1);\n\n        // to-index selected\n        dirListing['_selectItem'](1, false, true);\n        const items = [...dirListing.sortedItems()];\n        expect(dirListing['selection']).toHaveProperty([items[1].path], true);\n        expect(Object.keys(dirListing['selection'])).toHaveLength(1);\n        dirListing['_handleMultiSelect'](1);\n        expect(dirListing['selection']).toHaveProperty([items[1].path], true);\n        expect(Object.keys(dirListing['selection'])).toHaveLength(1);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should leave to-index selected and unselect from-index and items in-between",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is selected",
                "when from-index and all items in-between are selected"
            ],
            "updatePoint": {
                "line": 183,
                "column": 89
            },
            "line": 183,
            "code": "          it('should leave to-index selected and unselect from-index and items in-between', () => {\n            // Directory listing is like this:\n            // 1. selected\n            // 2. selected\n            // 3. selected, focused\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(4);\n            dirListing['_handleMultiSelect'](0);\n            // Now directory should look like:\n            // - selected, unselected, unselected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(Object.keys(dirListing['selection'])).toHaveLength(2);\n            expect(dirListing['selection']).toHaveProperty(\n              [items[0].path],\n              true\n            );\n            expect(dirListing['selection']).toHaveProperty(\n              [items[3].path],\n              true\n            );\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should leave to-index selected and unselect from-index and items in-between",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is selected",
                "when all are selected except from-index"
            ],
            "updatePoint": {
                "line": 212,
                "column": 89
            },
            "line": 212,
            "code": "          it('should leave to-index selected and unselect from-index and items in-between', () => {\n            // Directory listing is like this:\n            // 1. selected\n            // 2. selected\n            // 3. unselected, focused\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(3);\n            dirListing['_handleMultiSelect'](0);\n            // Now directory should look like:\n            // - selected, unselected, unselected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(Object.keys(dirListing['selection'])).toHaveLength(2);\n            expect(dirListing['selection']).toHaveProperty(\n              [items[0].path],\n              true\n            );\n            expect(dirListing['selection']).toHaveProperty(\n              [items[3].path],\n              true\n            );\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select all in-between from- and to-index, leaving from-index unselected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is selected",
                "when from-index and some items in-between are not selected"
            ],
            "updatePoint": {
                "line": 240,
                "column": 92
            },
            "line": 240,
            "code": "          it('should select all in-between from- and to-index, leaving from-index unselected', () => {\n            // Directory listing is like this:\n            // 1. selected\n            // 2. unselected\n            // 3. unselected, focused\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(2);\n            dirListing['_handleMultiSelect'](0);\n            // Now directory should look like:\n            // - selected, selected, unselected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(items).toHaveLength(4);\n            expect(Object.keys(dirListing['selection'])).toHaveLength(3);\n            expect(dirListing['selection']).not.toHaveProperty([items[2].path]);\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select all in-between from- and to-index",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is selected",
                "when from-index is selected but some items in-between are not"
            ],
            "updatePoint": {
                "line": 262,
                "column": 61
            },
            "line": 262,
            "code": "          it('should select all in-between from- and to-index', () => {\n            // Directory listing is like this:\n            // 1. selected\n            // 2. unselected\n            // 3. selected, focused\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(3);\n            dirListing['_handleMultiSelect'](0);\n            // Now directory should look like:\n            // - selected, selected, selected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(items).toHaveLength(4);\n            expect(Object.keys(dirListing['selection'])).toHaveLength(4);\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select all between from- and to-index",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is unselected",
                "when from-index and in-between items are selected"
            ],
            "updatePoint": {
                "line": 295,
                "column": 58
            },
            "line": 295,
            "code": "          it('should select all between from- and to-index', () => {\n            // Directory listing is like this:\n            // 1. selected, focused\n            // 2. selected\n            // 3. unselected [target]\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(3);\n            dirListing['_handleMultiSelect'](2);\n            // Now directory should look like:\n            // - selected, selected, selected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(items).toHaveLength(4);\n            expect(Object.keys(dirListing['selection'])).toHaveLength(4);\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select all between from- and to-index",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "#_handleMultiSelect",
                "when to-index is unselected",
                "when from-index is unselected but in-between items are selected"
            ],
            "updatePoint": {
                "line": 317,
                "column": 58
            },
            "line": 317,
            "code": "          it('should select all between from- and to-index', () => {\n            // Directory listing is like this:\n            // 1. unselected, focused\n            // 2. selected\n            // 3. unselected [target]\n            // 4. selected\n            expect(Object.keys(dirListing['selection'])).toHaveLength(2);\n            dirListing['_handleMultiSelect'](2);\n            // Now directory should look like:\n            // - unselected, selected, selected, selected\n            const items = [...dirListing.sortedItems()];\n            expect(items).toHaveLength(4);\n            expect(Object.keys(dirListing['selection'])).toHaveLength(3);\n            expect(dirListing['selection']).not.toHaveProperty([items[0].path]);\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not open an item unless it is selected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "Enter key"
            ],
            "updatePoint": {
                "line": 337,
                "column": 55
            },
            "line": 337,
            "code": "      it('should not open an item unless it is selected', () => {\n        // Meaning, do not open the item that is focussed if it is not also\n        // selected.\n        dirListing['_selectItem'](0, true);\n        dirListing['_selectItem'](1, true);\n        dirListing['_focusItem'](2);\n        const handleOpenSpy = jest.spyOn(dirListing as any, 'handleOpen');\n        const itemNode = dirListing['_items'][2];\n        const nameNode = dirListing['_renderer'].getNameNode(itemNode);\n        simulate(nameNode, 'keydown', {\n          key: 'Enter',\n          keyCode: 13\n        });\n        expect(handleOpenSpy).toHaveBeenCalledTimes(2);\n        const sortedItems = [...dirListing.sortedItems()];\n        expect(handleOpenSpy).toHaveBeenCalledWith(sortedItems[0]);\n        expect(handleOpenSpy).toHaveBeenCalledWith(sortedItems[1]);\n        expect(handleOpenSpy).not.toHaveBeenCalledWith(sortedItems[2]);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select first item when nothing is selected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "ArrowDown key"
            ],
            "updatePoint": {
                "line": 380,
                "column": 59
            },
            "line": 380,
            "code": "      it('should select first item when nothing is selected', async () => {\n        simulate(\n          dirListing.node.querySelector(`.${ITEM_TEXT_CLASS}`)!,\n          'keydown',\n          {\n            key: 'ArrowDown',\n            keyCode: 40\n          }\n        );\n        await signalToPromise(dirListing.updated);\n        const sortedItems = [...dirListing.sortedItems()];\n        const selectedItems = [...dirListing.selectedItems()];\n        expect(selectedItems).toHaveLength(1);\n        expect(selectedItems[0]).toBe(sortedItems[0]);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should select second item once first item is selected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "ArrowDown key"
            ],
            "updatePoint": {
                "line": 396,
                "column": 63
            },
            "line": 396,
            "code": "      it('should select second item once first item is selected', async () => {\n        dirListing['_selectItem'](0, false);\n        simulate(\n          dirListing.node.querySelector(`.${ITEM_TEXT_CLASS}`)!,\n          'keydown',\n          {\n            key: 'ArrowDown',\n            keyCode: 40\n          }\n        );\n        await signalToPromise(dirListing.updated);\n        const sortedItems = [...dirListing.sortedItems()];\n        const selectedItems = [...dirListing.selectedItems()];\n        expect(selectedItems).toHaveLength(1);\n        expect(selectedItems[0]).toBe(sortedItems[1]);\n      });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should unselect if current item is selected and previous is unselected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "ArrowDown key",
                "when pressing shift key and next item is selected"
            ],
            "updatePoint": {
                "line": 414,
                "column": 82
            },
            "line": 414,
            "code": "        it('should unselect if current item is selected and previous is unselected', async () => {\n          dirListing['_selectItem'](2, true);\n          dirListing['_selectItem'](1, true);\n          // This should be the state:\n          // - unselected\n          // - selected, focussed\n          // - selected\n          await signalToPromise(dirListing.updated);\n          simulate(\n            dirListing.node.querySelector(`.${ITEM_TEXT_CLASS}`)!,\n            'keydown',\n            {\n              key: 'ArrowDown',\n              keyCode: 40,\n              shiftKey: true\n            }\n          );\n          await signalToPromise(dirListing.updated);\n          // Now it should be:\n          // - unselected\n          // - unselected\n          // - selected, focussed\n          const sortedItems = [...dirListing.sortedItems()];\n          const selectedItems = [...dirListing.selectedItems()];\n          expect(selectedItems).toHaveLength(1);\n          expect(selectedItems[0]).toBe(sortedItems[2]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should leave selected otherwise",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "ArrowDown key",
                "when pressing shift key and next item is selected"
            ],
            "updatePoint": {
                "line": 442,
                "column": 43
            },
            "line": 442,
            "code": "        it('should leave selected otherwise', async () => {\n          dirListing['_selectItem'](0, true);\n          dirListing['_selectItem'](2, true);\n          dirListing['_selectItem'](1, true);\n          // This should be the state:\n          // - selected\n          // - selected, focussed\n          // - selected\n          await signalToPromise(dirListing.updated);\n          simulate(dirListing.node, 'keydown', {\n            key: 'ArrowDown',\n            keyCode: 40,\n            shiftKey: true\n          });\n          await signalToPromise(dirListing.updated);\n          // Now it should be:\n          // - selected\n          // - selected\n          // - selected, focussed\n          const sortedItems = [...dirListing.sortedItems()];\n          const selectedItems = [...dirListing.selectedItems()];\n          expect(selectedItems).toHaveLength(3);\n          expect(sortedItems).toHaveLength(3);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be checked after item is selected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 478,
                "column": 52
            },
            "line": 478,
            "code": "        it('should be checked after item is selected', async () => {\n          const itemNode = dirListing.contentNode.children[0] as HTMLElement;\n          const checkbox = dirListing.renderer.getCheckboxNode!(\n            itemNode\n          ) as HTMLInputElement;\n          expect(checkbox.checked).toBe(false);\n          const nameNode = dirListing.renderer.getNameNode!(\n            itemNode\n          ) as HTMLElement;\n          expect(checkbox.getAttribute('aria-label')).toBe(\n            ariaSelectFile(nameNode.textContent)\n          );\n          dirListing.selectNext();\n          await signalToPromise(dirListing.updated);\n          expect(checkbox.checked).toBe(true);\n          expect(checkbox.getAttribute('aria-label')).toBe(\n            ariaDeselectFile(nameNode.textContent)\n          );\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be unchecked after item is unselected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 498,
                "column": 56
            },
            "line": 498,
            "code": "        it('should be unchecked after item is unselected', async () => {\n          const itemNode = dirListing.contentNode.children[0] as HTMLElement;\n          const checkbox = dirListing.renderer.getCheckboxNode!(\n            itemNode\n          ) as HTMLInputElement;\n          const nameNode = dirListing.renderer.getNameNode!(\n            itemNode\n          ) as HTMLElement;\n          dirListing.selectNext();\n          await signalToPromise(dirListing.updated);\n          expect(checkbox.checked).toBe(true);\n          expect(checkbox.getAttribute('aria-label')).toBe(\n            ariaDeselectFile(nameNode.textContent)\n          );\n          // Selecting the next item unselects the first.\n          dirListing.selectNext();\n          await signalToPromise(dirListing.updated);\n          expect(checkbox.checked).toBe(false);\n          expect(checkbox.getAttribute('aria-label')).toBe(\n            ariaSelectFile(nameNode.textContent)\n          );\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should allow selecting multiple items",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 521,
                "column": 49
            },
            "line": 521,
            "code": "        it('should allow selecting multiple items', async () => {\n          const itemNodes = Array.from(\n            dirListing.contentNode.children\n          ) as HTMLElement[];\n          // JSDOM doesn't render anything, which means that all the elements have\n          // zero dimensions, so this is needed in order for the DirListing\n          // mousedown handler to believe that the mousedown event is relevant.\n          itemNodes[0].getBoundingClientRect = (): any => ({\n            left: 0,\n            right: 10,\n            top: 0,\n            bottom: 10\n          });\n          itemNodes[1].getBoundingClientRect = (): any => ({\n            left: 0,\n            right: 10,\n            top: 10,\n            bottom: 20\n          });\n          const checkboxes = itemNodes.map(node =>\n            dirListing.renderer.getCheckboxNode!(node)\n          ) as HTMLInputElement[];\n          const items = Array.from(dirListing.sortedItems());\n          expect(dirListing.isSelected(items[0].name)).toBe(false);\n          expect(dirListing.isSelected(items[1].name)).toBe(false);\n          simulate(checkboxes[0], 'mousedown', {\n            clientX: 1,\n            clientY: 1\n          });\n          simulate(checkboxes[1], 'mousedown', {\n            clientX: 1,\n            clientY: 11\n          });\n          await signalToPromise(dirListing.updated);\n          expect(dirListing.isSelected(items[0].name)).toBe(true);\n          expect(dirListing.isSelected(items[1].name)).toBe(true);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should reflect multiple items selected",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 559,
                "column": 50
            },
            "line": 559,
            "code": "        it('should reflect multiple items selected', async () => {\n          const itemNodes = Array.from(\n            dirListing.contentNode.children\n          ) as HTMLElement[];\n          const checkboxes = itemNodes.map(node =>\n            dirListing.renderer.getCheckboxNode!(node)\n          ) as HTMLInputElement[];\n          const nameNodes = itemNodes.map(node =>\n            dirListing.renderer.getNameNode!(node)\n          ) as HTMLElement[];\n          expect(checkboxes[0].checked).toBe(false);\n          expect(checkboxes[1].checked).toBe(false);\n          expect(checkboxes[0].getAttribute('aria-label')).toBe(\n            ariaSelectFile(nameNodes[0].textContent)\n          );\n          expect(checkboxes[1].getAttribute('aria-label')).toBe(\n            ariaSelectFile(nameNodes[1].textContent)\n          );\n          dirListing.selectNext();\n          dirListing.selectNext(true); // true = keep existing selection\n          await signalToPromise(dirListing.updated);\n          expect(checkboxes[0].checked).toBe(true);\n          expect(checkboxes[1].checked).toBe(true);\n          expect(checkboxes[0].getAttribute('aria-label')).toBe(\n            ariaDeselectFile(nameNodes[0].textContent)\n          );\n          expect(checkboxes[1].getAttribute('aria-label')).toBe(\n            ariaDeselectFile(nameNodes[1].textContent)\n          );\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not open item on double click",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 592,
                "column": 48
            },
            "line": 592,
            "code": "        it('should not open item on double click', () => {\n          const itemNode = dirListing.contentNode.children[0] as HTMLElement;\n          const checkbox = dirListing.renderer.getCheckboxNode!(\n            itemNode\n          ) as HTMLInputElement;\n          const wasOpened = jest.fn();\n          dirListing.onItemOpened.connect(wasOpened);\n          simulate(checkbox, 'dblclick');\n          expect(wasOpened).not.toHaveBeenCalled();\n          dirListing.onItemOpened.disconnect(wasOpened);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not become unchecked due to right-click on selected item",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 604,
                "column": 75
            },
            "line": 604,
            "code": "        it('should not become unchecked due to right-click on selected item', async () => {\n          const itemNode = dirListing.contentNode.children[0] as HTMLElement;\n          itemNode.getBoundingClientRect = (): any => ({\n            left: 0,\n            right: 10,\n            top: 0,\n            bottom: 10\n          });\n          const checkbox = dirListing.renderer.getCheckboxNode!(\n            itemNode\n          ) as HTMLInputElement;\n          const item = dirListing.sortedItems().next();\n          const waitForUpdate = signalToPromise(dirListing.updated);\n          await dirListing.selectItemByName(item.value.name);\n          await waitForUpdate;\n          expect(checkbox.checked).toBe(true);\n          expect(dirListing.isSelected(item.value.name)).toBe(true);\n          const waitForUpdate2 = signalToPromise(dirListing.updated);\n          simulate(checkbox, 'mousedown', {\n            clientX: 1,\n            clientY: 1,\n            button: 2\n          });\n          await waitForUpdate2;\n          // Item is still selected and checkbox is still checked after\n          // right-click.\n          expect(dirListing.isSelected(item.value.name)).toBe(true);\n          expect(checkbox.checked).toBe(true);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not get checked by the default action of a click",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "file/item checkbox"
            ],
            "updatePoint": {
                "line": 638,
                "column": 67
            },
            "line": 638,
            "code": "        it('should not get checked by the default action of a click', () => {\n          const itemNode = dirListing.contentNode.children[0] as HTMLElement;\n          const checkbox = dirListing.renderer.getCheckboxNode!(\n            itemNode\n          ) as HTMLInputElement;\n          expect(checkbox.checked).toBe(false);\n          simulate(checkbox, 'click', { bubbles: false });\n          expect(checkbox.checked).toBe(false);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be unchecked when the current directory is empty",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "check-all checkbox"
            ],
            "updatePoint": {
                "line": 650,
                "column": 67
            },
            "line": 650,
            "code": "        it('should be unchecked when the current directory is empty', async () => {\n          const { path } = await dirListing.model.manager.newUntitled({\n            type: 'directory'\n          });\n          await dirListing.model.cd(path);\n          await signalToPromise(dirListing.updated);\n          const headerCheckbox = dirListing.renderer.getCheckboxNode!(\n            dirListing.headerNode\n          ) as HTMLInputElement;\n          expect(headerCheckbox.checked).toBe(false);\n          expect(headerCheckbox!.indeterminate).toBe(false);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should check all",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "check-all checkbox",
                "when previously unchecked"
            ],
            "updatePoint": {
                "line": 675,
                "column": 30
            },
            "line": 675,
            "code": "          it('should check all', async () => {\n            expectInitialConditions();\n            const headerCheckbox = dirListing.renderer.getCheckboxNode!(\n              dirListing.headerNode\n            ) as HTMLInputElement;\n            simulate(headerCheckbox, 'click');\n            await signalToPromise(dirListing.updated);\n            expect(Array.from(dirListing.selectedItems())).toHaveLength(4);\n            expect(headerCheckbox.getAttribute('aria-label')).toBe(\n              ariaDeselectAll\n            );\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should uncheck all",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "check-all checkbox",
                "when previously indeterminate"
            ],
            "updatePoint": {
                "line": 705,
                "column": 32
            },
            "line": 705,
            "code": "          it('should uncheck all', async () => {\n            expectInitialConditions();\n            const headerCheckbox = dirListing.renderer.getCheckboxNode!(\n              dirListing.headerNode\n            ) as HTMLInputElement;\n            simulate(headerCheckbox, 'click');\n            await signalToPromise(dirListing.updated);\n            expect(Array.from(dirListing.selectedItems())).toHaveLength(0);\n            expect(headerCheckbox.getAttribute('aria-label')).toBe(\n              ariaSelectAll\n            );\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should uncheck all",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "checkboxes",
                "check-all checkbox",
                "when previously checked"
            ],
            "updatePoint": {
                "line": 736,
                "column": 32
            },
            "line": 736,
            "code": "          it('should uncheck all', async () => {\n            expectInitialConditions();\n            const headerCheckbox = dirListing.renderer.getCheckboxNode!(\n              dirListing.headerNode\n            ) as HTMLInputElement;\n            simulate(headerCheckbox, 'click');\n            await signalToPromise(dirListing.updated);\n            expect(Array.from(dirListing.selectedItems())).toHaveLength(0);\n          });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should sort alphabetically ascending correctly",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "should sort correctly",
                "with sortNotebooksFirst set to false"
            ],
            "updatePoint": {
                "line": 783,
                "column": 58
            },
            "line": 783,
            "code": "        it('should sort alphabetically ascending correctly', async () => {\n          dirListing.sort({\n            direction: 'ascending',\n            key: 'name'\n          });\n          await signalToPromise(dirListing.updated);\n\n          expect(getItemTitles(dirListing)).toEqual([\n            '2',\n            '5',\n            '1.txt',\n            '3.ipynb',\n            '4.txt',\n            '6.ipynb'\n          ]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should sort alphabetically descending correctly",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "should sort correctly",
                "with sortNotebooksFirst set to false"
            ],
            "updatePoint": {
                "line": 799,
                "column": 59
            },
            "line": 799,
            "code": "        it('should sort alphabetically descending correctly', async () => {\n          dirListing.sort({\n            direction: 'descending',\n            key: 'name'\n          });\n          await signalToPromise(dirListing.updated);\n\n          expect(getItemTitles(dirListing)).toEqual([\n            '5',\n            '2',\n            '6.ipynb',\n            '4.txt',\n            '3.ipynb',\n            '1.txt'\n          ]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should sort alphabetically ascending correctly",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "should sort correctly",
                "with sortNotebooksFirst set to true"
            ],
            "updatePoint": {
                "line": 818,
                "column": 58
            },
            "line": 818,
            "code": "        it('should sort alphabetically ascending correctly', async () => {\n          dirListing.sort({\n            direction: 'ascending',\n            key: 'name'\n          });\n          await signalToPromise(dirListing.updated);\n          dirListing.setNotebooksFirstSorting(true);\n          await signalToPromise(dirListing.updated);\n\n          expect(getItemTitles(dirListing)).toEqual([\n            '2',\n            '5',\n            '3.ipynb',\n            '6.ipynb',\n            '1.txt',\n            '4.txt'\n          ]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should sort alphabetically descending correctly",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "should sort correctly",
                "with sortNotebooksFirst set to true"
            ],
            "updatePoint": {
                "line": 836,
                "column": 59
            },
            "line": 836,
            "code": "        it('should sort alphabetically descending correctly', async () => {\n          dirListing.setNotebooksFirstSorting(true);\n          await signalToPromise(dirListing.updated);\n          dirListing.sort({\n            direction: 'descending',\n            key: 'name'\n          });\n          await signalToPromise(dirListing.updated);\n\n          expect(getItemTitles(dirListing)).toEqual([\n            '5',\n            '2',\n            '6.ipynb',\n            '3.ipynb',\n            '4.txt',\n            '1.txt'\n          ]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should sort correctly when switching between options",
            "suites": [
                "filebrowser/listing",
                "DirListing",
                "should sort correctly",
                "with sortNotebooksFirst toggled on/off"
            ],
            "updatePoint": {
                "line": 857,
                "column": 64
            },
            "line": 857,
            "code": "        it('should sort correctly when switching between options', async () => {\n          dirListing.sort({\n            direction: 'descending',\n            key: 'last_modified'\n          });\n          await signalToPromise(dirListing.updated);\n          expect(getItemTitles(dirListing)).toEqual([\n            '2',\n            '5',\n            '1.txt',\n            '3.ipynb',\n            '4.txt',\n            '6.ipynb'\n          ]);\n\n          dirListing.setNotebooksFirstSorting(true);\n          await signalToPromise(dirListing.updated);\n          expect(getItemTitles(dirListing)).toEqual([\n            '2',\n            '5',\n            '3.ipynb',\n            '6.ipynb',\n            '1.txt',\n            '4.txt'\n          ]);\n\n          dirListing.setNotebooksFirstSorting(false);\n          await signalToPromise(dirListing.updated);\n          expect(getItemTitles(dirListing)).toEqual([\n            '2',\n            '5',\n            '1.txt',\n            '3.ipynb',\n            '4.txt',\n            '6.ipynb'\n          ]);\n        });",
            "file": "listing.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should construct a new file browser model",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 51
            },
            "line": 93,
            "code": "      it('should construct a new file browser model', () => {\n        model = new FileBrowserModel({ manager });\n        expect(model).toBeInstanceOf(FileBrowserModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted when the path changes",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#pathChanged"
            ],
            "updatePoint": {
                "line": 100,
                "column": 49
            },
            "line": 100,
            "code": "      it('should be emitted when the path changes', async () => {\n        let called = false;\n        model.pathChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.name).toBe('path');\n          expect(args.oldValue).toBe('');\n          expect(args.newValue).toBe(subDir);\n          called = true;\n        });\n        await model.cd(subDir);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted after a refresh",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#refreshed"
            ],
            "updatePoint": {
                "line": 115,
                "column": 43
            },
            "line": 115,
            "code": "      it('should be emitted after a refresh', async () => {\n        let called = false;\n        model.refreshed.connect((sender, arg) => {\n          expect(sender).toBe(model);\n          expect(arg).toBeUndefined();\n          called = true;\n        });\n        await model.cd();\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted when the path changes",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#refreshed"
            ],
            "updatePoint": {
                "line": 126,
                "column": 49
            },
            "line": 126,
            "code": "      it('should be emitted when the path changes', async () => {\n        let called = false;\n        model.refreshed.connect((sender, arg) => {\n          expect(sender).toBe(model);\n          expect(arg).toBeUndefined();\n          called = true;\n        });\n        await model.cd(subDir);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted when a file is created",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 139,
                "column": 50
            },
            "line": 139,
            "code": "      it('should be emitted when a file is created', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('new');\n          expect(args.oldValue).toBeNull();\n          expect(args.newValue!.type).toBe('file');\n          called = true;\n        });\n        await manager.newUntitled({ type: 'file' });\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted when a file is renamed",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 152,
                "column": 50
            },
            "line": 152,
            "code": "      it('should be emitted when a file is renamed', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('rename');\n          expect(args.oldValue!.path).toBe(name);\n          expect(args.newValue!.path).toBe(name + '.bak');\n          called = true;\n        });\n        await manager.rename(name, name + '.bak');\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be emitted when a file is deleted",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 165,
                "column": 50
            },
            "line": 165,
            "code": "      it('should be emitted when a file is deleted', async () => {\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('delete');\n          expect(args.oldValue!.path).toBe(name);\n          expect(args.newValue).toBeNull();\n          called = true;\n        });\n        await manager.deleteFile(name);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be the current path of the model",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#path"
            ],
            "updatePoint": {
                "line": 180,
                "column": 49
            },
            "line": 180,
            "code": "      it('should be the current path of the model', async () => {\n        expect(model.path).toBe('');\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be and remain the root path of the model",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#rootPath"
            ],
            "updatePoint": {
                "line": 188,
                "column": 57
            },
            "line": 188,
            "code": "      it('should be and remain the root path of the model', async () => {\n        expect(model.rootPath).toBe('');\n        await model.cd('src/');\n        expect(model.rootPath).toBe('');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should get an iterator of items in the current path",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#items()"
            ],
            "updatePoint": {
                "line": 196,
                "column": 61
            },
            "line": 196,
            "code": "      it('should get an iterator of items in the current path', () => {\n        const items = model.items();\n        expect(!items.next().done).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should test whether the model is disposed",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 203,
                "column": 51
            },
            "line": 203,
            "code": "      it('should test whether the model is disposed', () => {\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be the session models for the active notebooks",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#sessions()"
            ],
            "updatePoint": {
                "line": 211,
                "column": 63
            },
            "line": 211,
            "code": "      it('should be the session models for the active notebooks', async () => {\n        const contents = await manager.newUntitled({ type: 'notebook' });\n        const session = await serviceManager.sessions.startNew({\n          name: '',\n          path: contents.path,\n          type: 'test'\n        });\n        await model.cd();\n        expect(!model.sessions().next().done).toBe(true);\n        await session.shutdown();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should dispose of the resources held by the model",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 225,
                "column": 59
            },
            "line": 225,
            "code": "      it('should dispose of the resources held by the model', () => {\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 230,
                "column": 47
            },
            "line": 230,
            "code": "      it('should be safe to call more than once', () => {\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should refresh the contents",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#refresh()"
            ],
            "updatePoint": {
                "line": 238,
                "column": 37
            },
            "line": 238,
            "code": "      it('should refresh the contents', async () => {\n        await expect(model.refresh()).resolves.not.toThrow();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should change directory",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#cd()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 33
            },
            "line": 244,
            "code": "      it('should change directory', async () => {\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should change to a nested directory",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#cd()"
            ],
            "updatePoint": {
                "line": 249,
                "column": 45
            },
            "line": 249,
            "code": "      it('should change to a nested directory', async () => {\n        await model.cd(subSubDir);\n        expect(model.path).toBe(subSubDir);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should accept a relative path",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#cd()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 39
            },
            "line": 254,
            "code": "      it('should accept a relative path', async () => {\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should accept a parent directory",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#cd()"
            ],
            "updatePoint": {
                "line": 259,
                "column": 42
            },
            "line": 259,
            "code": "      it('should accept a parent directory', async () => {\n        await model.cd(subDir);\n        await model.cd('..');\n        expect(model.path).toBe('');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be resilient to a slow initial fetch",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#cd()"
            ],
            "updatePoint": {
                "line": 265,
                "column": 53
            },
            "line": 265,
            "code": "      it('should be resilient to a slow initial fetch', async () => {\n        const delayedServiceManager = new ServiceManagerMock();\n        (delayedServiceManager as any).contents = new DelayedContentsManager();\n        const contents = await delayedServiceManager.contents.newUntitled({\n          type: 'directory'\n        });\n        subDir = contents.path;\n\n        const manager = new DocumentManager({\n          registry,\n          opener,\n          manager: delayedServiceManager\n        });\n        model = new FileBrowserModel({ manager, state }); // Should delay 1000ms\n\n        // An initial refresh is called in the constructor.\n        // If it is too slow, it can come in after the directory change,\n        // causing a directory set by, e.g., the tree handler to be wrong.\n        // This checks to make sure we are handling that case correctly.\n        await model.cd(subDir); // should delay 500ms\n        await sleep(2000);\n        expect(model.path).toBe(subDir);\n\n        manager.dispose();\n        delayedServiceManager.contents.dispose();\n        delayedServiceManager.dispose();\n        model.dispose();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should restore based on ID",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#restore()"
            ],
            "updatePoint": {
                "line": 296,
                "column": 36
            },
            "line": 296,
            "code": "      it('should restore based on ID', async () => {\n        const id = 'foo';\n        const model2 = new FileBrowserModel({ manager, state });\n        await model.restore(id);\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n        expect(model2.path).toBe('');\n        await model2.restore(id);\n        expect(model2.path).toBe(subDir);\n        model2.dispose();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#restore()"
            ],
            "updatePoint": {
                "line": 308,
                "column": 47
            },
            "line": 308,
            "code": "      it('should be safe to call multiple times', async () => {\n        const id = 'bar';\n        const model2 = new FileBrowserModel({ manager, state });\n        await model.restore(id);\n        await model.cd(subDir);\n        expect(model.path).toBe(subDir);\n        expect(model2.path).toBe('');\n        await model2.restore(id);\n        await model2.restore(id);\n        expect(model2.path).toBe(subDir);\n        model2.dispose();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should download the file without error",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#download()"
            ],
            "line": 323,
            "code": "      it.skip('should download the file without error', () => {",
            "file": "model.spec.ts",
            "skipped": true,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should upload a file object",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()"
            ],
            "updatePoint": {
                "line": 329,
                "column": 37
            },
            "line": 329,
            "code": "      it('should upload a file object', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should overwrite",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()"
            ],
            "updatePoint": {
                "line": 338,
                "column": 26
            },
            "line": 338,
            "code": "      it('should overwrite', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n        const promise = model.upload(file);\n        await acceptDialog();\n        await promise;\n        expect(contents.name).toBe(fname);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not overwrite",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()"
            ],
            "updatePoint": {
                "line": 351,
                "column": 30
            },
            "line": 351,
            "code": "      it('should not overwrite', async () => {\n        const fname = UUID.uuid4() + '.html';\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        const contents = await model.upload(file);\n        expect(contents.name).toBe(fname);\n        const promise = model.upload(file);\n        await dismissDialog();\n\n        await expect(promise).rejects.toBe('File not uploaded');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()"
            ],
            "updatePoint": {
                "line": 364,
                "column": 44
            },
            "line": 364,
            "code": "      it('should emit the fileChanged signal', async () => {\n        const fname = UUID.uuid4() + '.html';\n        let called = false;\n        model.fileChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('save');\n          expect(args.oldValue).toBeNull();\n          expect(args.newValue!.path).toBe(fname);\n          called = true;\n        });\n        const file = new File(['<p>Hello world!</p>'], fname, {\n          type: 'text/html'\n        });\n        await model.upload(file);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should not upload large file",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()",
                "older notebook version"
            ],
            "updatePoint": {
                "line": 391,
                "column": 40
            },
            "line": 391,
            "code": "        it('should not upload large file', async () => {\n          const fname = UUID.uuid4() + '.html';\n          const file = new File([new ArrayBuffer(LARGE_FILE_SIZE + 1)], fname);\n\n          await expect(model.upload(file)).rejects.toBe(\n            `Cannot upload file (>15 MB). ${fname}`\n          );\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should upload a large  file of size ",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()",
                "newer notebook version"
            ],
            "updatePoint": {
                "line": 422,
                "column": 68
            },
            "line": 422,
            "code": "            it(`should upload a large ${ending} file of size ${size}`, async () => {\n              const fname = UUID.uuid4() + ending;\n\n              // minimal valid (according to server) notebook\n              let content =\n                '{\"nbformat\": 4, \"metadata\": {\"_\": \"\"}, \"nbformat_minor\": 2, \"cells\": []}';\n              // make metadata longer so that total document is `size` long\n              content = content.replace(\n                '\"_\": \"\"',\n                `\"_\": \"${' '.repeat(size - content.length)}\"`\n              );\n              const file = new File([content], fname, { type: 'text/plain' });\n              await model.upload(file);\n              // Ensure we get the file back.\n              const contentModel = await model.manager.services.contents.get(\n                fname\n              );\n              expect(contentModel.content.length).toBeGreaterThan(0);\n            });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should produce progress as a large file uploads",
            "suites": [
                "filebrowser/model",
                "FileBrowserModel",
                "#upload()",
                "newer notebook version"
            ],
            "updatePoint": {
                "line": 444,
                "column": 59
            },
            "line": 444,
            "code": "        it(`should produce progress as a large file uploads`, async () => {\n          const fname = UUID.uuid4() + '.txt';\n          const file = new File([new ArrayBuffer(2 * CHUNK_SIZE)], fname);\n\n          const [start, first, second, finished] = signalToPromises(\n            model.uploadChanged,\n            4\n          );\n\n          const uploaded = model.upload(file);\n          expect(Array.from(model.uploads())).toEqual([]);\n          expect(await start).toEqual([\n            model,\n            {\n              name: 'start',\n              oldValue: null,\n              newValue: { path: fname, progress: 0 }\n            }\n          ]);\n          expect(Array.from(model.uploads())).toEqual([\n            { path: fname, progress: 0 }\n          ]);\n          expect(await first).toEqual([\n            model,\n            {\n              name: 'update',\n              oldValue: { path: fname, progress: 0 },\n              newValue: { path: fname, progress: 0 }\n            }\n          ]);\n          expect(Array.from(model.uploads())).toEqual([\n            { path: fname, progress: 0 }\n          ]);\n          expect(await second).toEqual([\n            model,\n            {\n              name: 'update',\n              oldValue: { path: fname, progress: 0 },\n              newValue: { path: fname, progress: 1 / 2 }\n            }\n          ]);\n          expect(Array.from(model.uploads())).toEqual([\n            { path: fname, progress: 1 / 2 }\n          ]);\n          expect(await finished).toEqual([\n            model,\n            {\n              name: 'finish',\n              oldValue: { path: fname, progress: 1 / 2 },\n              newValue: null\n            }\n          ]);\n          expect(Array.from(model.uploads())).toEqual([]);\n          await uploaded;\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should construct a new filtered file browser model",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 46,
                "column": 60
            },
            "line": 46,
            "code": "      it('should construct a new filtered file browser model', () => {\n        const model = new FilterFileBrowserModel({ manager });\n        expect(model).toBeInstanceOf(FilterFileBrowserModel);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should accept filter option",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 37
            },
            "line": 51,
            "code": "      it('should accept filter option', () => {\n        const model = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => null\n        });\n        expect(model).toBeInstanceOf(FilterFileBrowserModel);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should list all elements if no filter is defined",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#items()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 58
            },
            "line": 61,
            "code": "      it('should list all elements if no filter is defined', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = Array.from(filteredModel.items());\n        const items = Array.from(model.items());\n        expect(filteredItems.length).toBe(items.length);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should list all directories if filterDirectories is false",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#items()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 67
            },
            "line": 74,
            "code": "      it('should list all directories if filterDirectories is false', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => null,\n          filterDirectories: false\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = Array.from(filteredModel.items());\n        const items = Array.from(model.items());\n        const folders = items.filter(item => item.type === 'directory');\n        expect(filteredItems.length).toBe(folders.length);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should filter files and directories if filterDirectories is true",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#items()"
            ],
            "updatePoint": {
                "line": 90,
                "column": 74
            },
            "line": 90,
            "code": "      it('should filter files and directories if filterDirectories is true', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) => null,\n          filterDirectories: true\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = Array.from(filteredModel.items());\n        expect(filteredItems.length).toBe(0);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should respect the filter",
            "suites": [
                "@jupyterlab/filebrowser",
                "FilterFileBrowserModel",
                "#items()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 35
            },
            "line": 104,
            "code": "      it('should respect the filter', async () => {\n        const filteredModel = new FilterFileBrowserModel({\n          manager,\n          filter: (model: Contents.IModel) =>\n            model.type === 'notebook' ? {} : null\n        });\n        await filteredModel.cd();\n        const model = new FileBrowserModel({ manager });\n        await model.cd();\n\n        const filteredItems = Array.from(\n          filteredModel.items()\n        ) as Contents.IModel[];\n        const items = Array.from(model.items());\n        const shownItems = items.filter(item => item.type === 'notebook');\n        expect(filteredItems.length).toBe(shownItems.length);\n        const notebooks = filteredItems.filter(\n          item => item.type === 'notebook'\n        );\n        expect(notebooks.length).toBeGreaterThan(0);\n      });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should create a dialog",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getOpenFiles()"
            ],
            "updatePoint": {
                "line": 129,
                "column": 30
            },
            "line": 129,
            "code": "    it('should create a dialog', async () => {\n      const dialog = FileDialog.getOpenFiles({\n        manager\n      });\n\n      await dismissDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(false);\n      expect(result.value).toBeNull();\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getOpenFiles()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 29
            },
            "line": 142,
            "code": "    it('should accept options', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getOpenFiles({\n        manager,\n        title: 'Select a notebook',\n        host: node,\n        filter: (value: Contents.IModel) =>\n          value.type === 'notebook' ? {} : null\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(true);\n      const items = result.value!;\n      expect(items.length).toBe(1);\n\n      document.body.removeChild(node);\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should return one selected file",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getOpenFiles()"
            ],
            "updatePoint": {
                "line": 166,
                "column": 39
            },
            "line": 166,
            "code": "    it('should return one selected file', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getOpenFiles({\n        manager,\n        title: 'Select a notebook',\n        host: node,\n        filter: (value: Contents.IModel) =>\n          value.type === 'notebook' ? {} : null\n      });\n\n      await waitForDialog();\n      await framePromise();\n\n      let counter = 0;\n      const listing = node.getElementsByClassName('jp-DirListing-content')[0];\n      expect(listing).toBeTruthy();\n\n      let items = listing.getElementsByTagName('li');\n      counter = 0;\n      // Wait for the directory listing to be populated\n      while (items.length === 0 && counter < 100) {\n        await sleep(10);\n        items = listing.getElementsByTagName('li');\n        counter++;\n      }\n\n      // Fails if there is no items shown\n      expect(items.length).toBeGreaterThan(0);\n\n      // Emulate notebook file selection\n      const item = listing.querySelector('li[data-file-type=\"notebook\"]')!;\n      simulate(item, 'mousedown');\n\n      await acceptDialog();\n      const result = await dialog;\n      const files = result.value!;\n      expect(files.length).toBe(1);\n      expect(files[0].type).toBe('notebook');\n      expect(files[0].name).toEqual(expect.stringMatching(/Untitled.*.ipynb/));\n\n      document.body.removeChild(node);\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should return current path if nothing is selected",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getOpenFiles()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 57
            },
            "line": 212,
            "code": "    it('should return current path if nothing is selected', async () => {\n      const dialog = FileDialog.getOpenFiles({\n        manager\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n      const items = result.value!;\n\n      expect(items.length).toBe(1);\n      expect(items[0].type).toBe('directory');\n      expect(items[0].path).toBe('');\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should create a dialog",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getExistingDirectory()"
            ],
            "updatePoint": {
                "line": 229,
                "column": 30
            },
            "line": 229,
            "code": "    it('should create a dialog', async () => {\n      const dialog = FileDialog.getExistingDirectory({\n        manager\n      });\n\n      await dismissDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(false);\n      expect(result.value).toBeNull();\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getExistingDirectory()"
            ],
            "updatePoint": {
                "line": 242,
                "column": 29
            },
            "line": 242,
            "code": "    it('should accept options', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getExistingDirectory({\n        manager,\n        title: 'Select a folder',\n        host: node\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n\n      expect(result.button.accept).toBe(true);\n      expect(result.value!.length).toBe(1);\n\n      document.body.removeChild(node);\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should return one selected directory",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getExistingDirectory()"
            ],
            "updatePoint": {
                "line": 263,
                "column": 44
            },
            "line": 263,
            "code": "    it('should return one selected directory', async () => {\n      const node = document.createElement('div');\n\n      document.body.appendChild(node);\n\n      const dialog = FileDialog.getExistingDirectory({\n        manager,\n        title: 'Select a folder',\n        host: node\n      });\n\n      await waitForDialog();\n      await framePromise();\n\n      let counter = 0;\n      const listing = node.getElementsByClassName('jp-DirListing-content')[0];\n      expect(listing).toBeTruthy();\n\n      let items = listing.getElementsByTagName('li');\n      // Wait for the directory listing to be populated\n      while (items.length === 0 && counter < 100) {\n        await sleep(10);\n        items = listing.getElementsByTagName('li');\n        counter++;\n      }\n\n      // Fails if there is no items shown\n      expect(items.length).toBeGreaterThan(0);\n\n      // Emulate notebook file selection\n      simulate(items.item(items.length - 1)!, 'mousedown');\n\n      await acceptDialog();\n      const result = await dialog;\n      const files = result.value!;\n      expect(files.length).toBe(1);\n      expect(files[0].type).toBe('directory');\n      expect(files[0].name).toEqual(\n        expect.stringMatching(/Untitled Folder( \\d+)?/)\n      );\n\n      document.body.removeChild(node);\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should return current path if nothing is selected",
            "suites": [
                "@jupyterlab/filebrowser",
                "FileDialog.getExistingDirectory()"
            ],
            "updatePoint": {
                "line": 307,
                "column": 57
            },
            "line": 307,
            "code": "    it('should return current path if nothing is selected', async () => {\n      const dialog = FileDialog.getExistingDirectory({\n        manager\n      });\n\n      await acceptDialog();\n\n      const result = await dialog;\n      const items = result.value!;\n\n      expect(items.length).toBe(1);\n      expect(items[0].type).toBe('directory');\n      expect(items[0].path).toBe('');\n    });",
            "file": "openfiledialog.spec.ts",
            "skipped": false,
            "dir": "packages/filebrowser/test"
        },
        {
            "name": "should extract headings from %s",
            "suites": [
                "@jupyterlab/fileeditor",
                "PythonTableOfContentsModel",
                "#getHeadings"
            ],
            "line": 15,
            "code": "      it.each<[string, IEditorHeading[]]>([\n        ['', []],\n        ['a = 2', []],\n        [\n          'def f(a, b):',\n          [\n            {\n              text: 'def f(a, b):',\n              level: 1,\n              line: 0\n            }\n          ]\n        ],\n        [\n          'class Klass:',\n          [\n            {\n              text: 'class Klass:',\n              level: 1,\n              line: 0\n            }\n          ]\n        ],\n        [\n          'import pathlib',\n          [\n            {\n              text: 'import pathlib',\n              level: 1,\n              line: 0\n            }\n          ]\n        ],\n        [\n          'from pathlib import Path',\n          [\n            {\n              text: 'from pathlib import Path',\n              level: 1,\n              line: 0\n            }\n          ]\n        ],\n        [\n          'import subprocess\\nfrom pathlib import Path\\n\\nimport tempfile',\n          [\n            {\n              text: 'import subprocess',\n              level: 1,\n              line: 0\n            }\n          ]\n        ],\n        [\n          'def f(a, b):\\n    def g():\\n        pass',\n          [\n            {\n              text: 'def f(a, b):',\n              level: 1,\n              line: 0\n            },\n            {\n              text: 'def g():',\n              level: 2,\n              line: 1\n            }\n          ]\n        ],\n        [\n          'def f(a, b):\\n    def g():\\n        class C:',\n          [\n            {\n              text: 'def f(a, b):',\n              level: 1,\n              line: 0\n            },\n            {\n              text: 'def g():',\n              level: 2,\n              line: 1\n            },\n            {\n              text: 'class C:',\n              level: 3,\n              line: 2\n            }\n          ]\n        ],\n        [\n          'def f(a, b):\\n    def g():\\n        pass\\n    pass\\ndef h():',\n          [\n            {\n              text: 'def f(a, b):',\n              level: 1,\n              line: 0\n            },\n            {\n              text: 'def g():',\n              level: 2,\n              line: 1\n            },\n            {\n              text: 'def h():',\n              level: 1,\n              line: 4\n            }\n          ]\n        ]\n      ])('should extract headings from %s', async (text, headers) => {\n        const model = new PythonTableOfContentsModel({\n          content: {\n            model: {\n              mimeType: 'text/x-python',\n              sharedModel: {\n                getSource: () => text\n              }\n            }\n          } as any\n        } as any);\n\n        const newHeadings = signalToPromise(model.headingsChanged);\n        model.isActive = true; // This will trigger refresh\n        if (headers.length > 0) {\n          // If text has no associated headings the new computed headings\n          // are gonna be empty. So the signal won't be emitted.\n          await newHeadings;\n        } else {\n          await model.refresh();\n        }\n        const headings = model.headings;\n\n        expect(headings).toHaveLength(headers.length);\n        for (let i = 0; i < headers.length; i++) {\n          expect(headings[i]).toEqual(headers[i]);\n        }\n      });",
            "file": "python.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should return number of matches",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#matchesCount"
            ],
            "updatePoint": {
                "line": 82,
                "column": 41
            },
            "line": 82,
            "code": "      it('should return number of matches', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.matchesCount).toBe(3);\n        await provider.startQuery(/t/, undefined);\n        expect(provider.matchesCount).toBe(6);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should highlight next match",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 37
            },
            "line": 91,
            "code": "      it('should highlight next match', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should find multi-line matches",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 101,
                "column": 40
            },
            "line": 101,
            "code": "      it('should find multi-line matches', async () => {\n        await provider.startQuery(/est\\nte/, undefined);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should not focus the editor",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 37
            },
            "line": 108,
            "code": "      it('should not focus the editor', async () => {\n        await provider.startQuery(/test/, undefined);\n        await provider.highlightNext();\n        expect(widget.editor.hasFocus()).toBe(false);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should loop back to first match",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 114,
                "column": 41
            },
            "line": 114,
            "code": "      it('should loop back to first match', async () => {\n        widget.editor.setCursorPosition({ line: 1, column: 0 });\n        await provider.startQuery(/test/, undefined);\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should do nothing if the document is empty",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 123,
                "column": 52
            },
            "line": 123,
            "code": "      it('should do nothing if the document is empty', async () => {\n        widget.context.model.fromString('');\n        await provider.startQuery(/test/, undefined);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(null);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should highlight previous match",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightPrevious()"
            ],
            "updatePoint": {
                "line": 133,
                "column": 41
            },
            "line": 133,
            "code": "      it('should highlight previous match', async () => {\n        widget.editor.setCursorPosition({ line: 1, column: 0 });\n        await provider.startQuery(/tes/, undefined);\n        expect(provider.currentMatchIndex).toBe(2);\n        expect(widget.editor.getCursorPosition().line).toBe(1);\n        await provider.highlightPrevious();\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightPrevious();\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should loop back to last match",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#highlightPrevious()"
            ],
            "updatePoint": {
                "line": 145,
                "column": 40
            },
            "line": 145,
            "code": "      it('should loop back to last match', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightPrevious();\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should replace highlighted match when editor is blurred",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 155,
                "column": 65
            },
            "line": 155,
            "code": "      it('should replace highlighted match when editor is blurred', async () => {\n        widget.editor.setCursorPosition({ line: 1, column: 0 });\n        await provider.startQuery(/tes/, undefined);\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.replaceCurrentMatch('bar');\n        expect(widget.context.model.toString()).toBe('test test\\nbart');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should replace first match when editor is blurred",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 59
            },
            "line": 164,
            "code": "      it('should replace first match when editor is blurred', async () => {\n        await provider.startQuery(/tes/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.replaceCurrentMatch('bar');\n        expect(widget.context.model.toString()).toBe('bart test\\ntest');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should replace first match when editor is focused",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 59
            },
            "line": 172,
            "code": "      it('should replace first match when editor is focused', async () => {\n        widget.editor.focus();\n        await provider.startQuery(/tes/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.replaceCurrentMatch('bar');\n        expect(widget.context.model.toString()).toBe('bart test\\ntest');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should replace all matches",
            "suites": [
                "@jupyterlab/fileeditor",
                "FileEditorSearchProvider",
                "#replaceAllMatches()"
            ],
            "updatePoint": {
                "line": 183,
                "column": 36
            },
            "line": 183,
            "code": "      it('should replace all matches', async () => {\n        await provider.startQuery(/test/, undefined);\n        await provider.replaceAllMatches('bar');\n        expect(widget.context.model.toString()).toBe('bar bar\\nbar');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should create an editor widget",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 89,
                "column": 40
            },
            "line": 89,
            "code": "      it('should create an editor widget', () => {\n        expect(widget).toBeInstanceOf(FileEditor);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should update the editor text when the model changes",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 62
            },
            "line": 93,
            "code": "      it('should update the editor text when the model changes', async () => {\n        await context.initialize(true);\n        await context.ready;\n        widget.context.model.fromString('foo');\n        expect(widget.editor.model.sharedModel.getSource()).toBe('foo');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should set the mime type for the path",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 47
            },
            "line": 100,
            "code": "      it('should set the mime type for the path', () => {\n        expect(widget.editor.model.mimeType).toBe('text/x-python');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should update the mime type when the path changes",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 59
            },
            "line": 104,
            "code": "      it('should update the mime type when the path changes', async () => {\n        let called = false;\n        context.pathChanged.connect((sender, args) => {\n          expect(widget.editor.model.mimeType).toBe('text/x-julia');\n          called = true;\n        });\n        await context.initialize(true);\n        await manager.contents.rename(context.path, UUID.uuid4() + '.jl');\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should be the context used by the widget",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#context"
            ],
            "updatePoint": {
                "line": 117,
                "column": 50
            },
            "line": 117,
            "code": "      it('should be the context used by the widget', () => {\n        expect(widget.context).toBe(context);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should focus the editor",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 133,
                "column": 35
            },
            "line": 133,
            "code": "        it('should focus the editor', () => {\n          simulate(widget.node, 'mousedown');\n          expect(widget.events).toContain('mousedown');\n          expect(widget.editor.hasFocus()).toBe(true);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should add event listeners",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 36
            },
            "line": 142,
            "code": "      it('should add event listeners', async () => {\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toContain('onAfterAttach');\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).toContain('mousedown');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should remove event listeners",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#onBeforeDetach()"
            ],
            "updatePoint": {
                "line": 152,
                "column": 39
            },
            "line": 152,
            "code": "      it('should remove event listeners', async () => {\n        Widget.attach(widget, document.body);\n        await framePromise();\n        Widget.detach(widget);\n        expect(widget.methods).toContain('onBeforeDetach');\n        widget.events = [];\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).not.toContain('mousedown');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should focus the node after an update",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 164,
                "column": 47
            },
            "line": 164,
            "code": "      it('should focus the node after an update', async () => {\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toContain('onActivateRequest');\n        await framePromise();\n        expect(widget.editor.hasFocus()).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should resolve after initialization",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditor",
                "#ready"
            ],
            "updatePoint": {
                "line": 174,
                "column": 45
            },
            "line": 174,
            "code": "      it('should resolve after initialization', async () => {\n        await context.initialize(true);\n        return expect(widget.ready).resolves.toBe(undefined);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should create an FileEditorFactory",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditorFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 195,
                "column": 44
            },
            "line": 195,
            "code": "      it('should create an FileEditorFactory', () => {\n        expect(widgetFactory).toBeInstanceOf(FileEditorFactory);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should create a document widget",
            "suites": [
                "fileeditorcodewrapper",
                "FileEditorFactory",
                "#createNewWidget()"
            ],
            "updatePoint": {
                "line": 201,
                "column": 41
            },
            "line": 201,
            "code": "      it('should create a document widget', () => {\n        const d = widgetFactory.createNew(context);\n        expect(d).toBeInstanceOf(DocumentWidget);\n        expect(d.content).toBeInstanceOf(FileEditor);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/fileeditor/test"
        },
        {
            "name": "should create an ImageViewer",
            "suites": [
                "ImageViewer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 36
            },
            "line": 82,
            "code": "    it('should create an ImageViewer', () => {\n      expect(widget).toBeInstanceOf(ImageViewer);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should keep the title in sync with the file name",
            "suites": [
                "ImageViewer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 86,
                "column": 56
            },
            "line": 86,
            "code": "    it('should keep the title in sync with the file name', async () => {\n      const newPath = ((IMAGE as any).path = UUID.uuid4() + '.png');\n      expect(widget.title.label).toBe(context.path);\n      let called = false;\n      context.pathChanged.connect(() => {\n        expect(widget.title.label).toBe(newPath);\n        called = true;\n      });\n      await manager.contents.rename(context.path, newPath);\n      expect(called).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should set the content after the context is ready",
            "suites": [
                "ImageViewer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 98,
                "column": 57
            },
            "line": 98,
            "code": "    it('should set the content after the context is ready', async () => {\n      await context.ready;\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      const img = widget.node.querySelector('img') as HTMLImageElement;\n      expect(img.src).toContain(IMAGE.content);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should handle a change to the content",
            "suites": [
                "ImageViewer",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 105,
                "column": 45
            },
            "line": 105,
            "code": "    it('should handle a change to the content', async () => {\n      await context.ready;\n      context.model.fromString(OTHER);\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      const img = widget.node.querySelector('img') as HTMLImageElement;\n      expect(img.src).toContain(OTHER);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should be the context associated with the widget",
            "suites": [
                "ImageViewer",
                "#context"
            ],
            "updatePoint": {
                "line": 115,
                "column": 56
            },
            "line": 115,
            "code": "    it('should be the context associated with the widget', () => {\n      expect(widget.context).toBe(context);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should default to 1",
            "suites": [
                "ImageViewer",
                "#scale"
            ],
            "updatePoint": {
                "line": 121,
                "column": 27
            },
            "line": 121,
            "code": "    it('should default to 1', () => {\n      expect(widget.scale).toBe(1);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "ImageViewer",
                "#scale"
            ],
            "updatePoint": {
                "line": 125,
                "column": 26
            },
            "line": 125,
            "code": "    it('should be settable', () => {\n      widget.scale = 0.5;\n      expect(widget.scale).toBe(0.5);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should dispose of the resources used by the widget",
            "suites": [
                "ImageViewer",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 132,
                "column": 58
            },
            "line": 132,
            "code": "    it('should dispose of the resources used by the widget', () => {\n      expect(widget.isDisposed).toBe(false);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n      widget.dispose();\n      expect(widget.isDisposed).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should render the image",
            "suites": [
                "ImageViewer",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 31
            },
            "line": 142,
            "code": "    it('should render the image', async () => {\n      const img: HTMLImageElement = widget.node.querySelector('img')!;\n      await widget.ready;\n      MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n      expect(widget.methods).toContain('onUpdateRequest');\n      expect(img.src).toContain(IMAGE.content);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should focus the widget",
            "suites": [
                "ImageViewer",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 152,
                "column": 31
            },
            "line": 152,
            "code": "    it('should focus the widget', () => {\n      Widget.attach(widget, document.body);\n      MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n      expect(widget.methods).toContain('onActivateRequest');\n      expect(widget.node.contains(document.activeElement)).toBe(true);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should create an image document widget",
            "suites": [
                "ImageViewerFactory",
                "#createNewWidget"
            ],
            "updatePoint": {
                "line": 163,
                "column": 46
            },
            "line": 163,
            "code": "    it('should create an image document widget', () => {\n      const factory = new ImageViewerFactory({\n        name: 'Image',\n        modelName: 'base64',\n        fileTypes: ['png'],\n        defaultFor: ['png']\n      });\n      const context = createFileContext(IMAGE.path, new ServiceManagerMock());\n      const d = factory.createNew(context);\n      expect(d).toBeInstanceOf(DocumentWidget);\n      expect(d.content).toBeInstanceOf(ImageViewer);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/imageviewer/test"
        },
        {
            "name": "should construct a new inspector widget",
            "suites": [
                "inspector/index",
                "Inspector",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 49
            },
            "line": 39,
            "code": "      it('should construct a new inspector widget', () => {\n        const widget = new InspectorPanel();\n        expect(widget).toBeInstanceOf(InspectorPanel);\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should add the `jp-Inspector` class",
            "suites": [
                "inspector/index",
                "Inspector",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 44,
                "column": 45
            },
            "line": 44,
            "code": "      it('should add the `jp-Inspector` class', () => {\n        const widget = new InspectorPanel();\n        expect(widget.hasClass('jp-Inspector')).toBe(true);\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should default to `null`",
            "suites": [
                "inspector/index",
                "Inspector",
                "#source"
            ],
            "updatePoint": {
                "line": 51,
                "column": 34
            },
            "line": 51,
            "code": "      it('should default to `null`', () => {\n        const widget = new InspectorPanel();\n        expect(widget.source).toBeNull();\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should be settable multiple times",
            "suites": [
                "inspector/index",
                "Inspector",
                "#source"
            ],
            "updatePoint": {
                "line": 56,
                "column": 43
            },
            "line": 56,
            "code": "      it('should be settable multiple times', () => {\n        const widget = new InspectorPanel();\n        const source = new TestInspectable();\n        expect(widget.source).toBeNull();\n        widget.source = source;\n        expect(widget.source).toBe(source);\n        widget.source = null;\n        expect(widget.source).toBeNull();\n        widget.source = new TestInspectable();\n        expect(widget.source).toBeInstanceOf(TestInspectable);\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should dispose of the resources used by the inspector",
            "suites": [
                "inspector/index",
                "Inspector",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 70,
                "column": 63
            },
            "line": 70,
            "code": "      it('should dispose of the resources used by the inspector', () => {\n        const widget = new InspectorPanel();\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should be a no-op if called more than once",
            "suites": [
                "inspector/index",
                "Inspector",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 77,
                "column": 52
            },
            "line": 77,
            "code": "      it('should be a no-op if called more than once', () => {\n        const widget = new InspectorPanel();\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should fire when a source updates",
            "suites": [
                "inspector/index",
                "Inspector",
                "#onInspectorUpdate()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 43
            },
            "line": 87,
            "code": "      it('should fire when a source updates', () => {\n        const widget = new TestInspectorPanel();\n        widget.source = new TestInspectable();\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onInspectorUpdate'])\n        );\n        (widget.source.inspected as any).emit({ content: new Widget() });\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onInspectorUpdate'])\n        );\n      });",
            "file": "inspector.spec.ts",
            "skipped": false,
            "dir": "packages/inspector/test"
        },
        {
            "name": "should create an LoggerOutputAreaModel",
            "suites": [
                "LoggerOutputAreaModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 46
            },
            "line": 38,
            "code": "    it('should create an LoggerOutputAreaModel', () => {\n      expect(model).toBeInstanceOf(LoggerOutputAreaModel);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should set the max length",
            "suites": [
                "LoggerOutputAreaModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 33
            },
            "line": 42,
            "code": "    it('should set the max length', async () => {\n      const model = new LoggerOutputAreaModel({ maxLength: 10 });\n      expect(model.maxLength).toEqual(10);\n      model.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should set the maximum number of messages in the first-in first-out queue",
            "suites": [
                "LoggerOutputAreaModel",
                "#maxLength"
            ],
            "updatePoint": {
                "line": 50,
                "column": 81
            },
            "line": 50,
            "code": "    it('should set the maximum number of messages in the first-in first-out queue', () => {\n      for (let i = 0; i < 12; i++) {\n        model.add({\n          output_type: 'display_data',\n          data: { 'text/plain': i.toString() },\n          timestamp: Date.now(),\n          level: 'info'\n        });\n      }\n      expect(model.length).toEqual(10);\n      expect(model.get(0).data['text/plain']).toEqual('2');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "setting maxLength should immediately apply and trim the message list",
            "suites": [
                "LoggerOutputAreaModel",
                "#maxLength"
            ],
            "updatePoint": {
                "line": 63,
                "column": 76
            },
            "line": 63,
            "code": "    it('setting maxLength should immediately apply and trim the message list', () => {\n      for (let i = 0; i < 12; i++) {\n        model.add({\n          output_type: 'display_data',\n          data: { 'text/plain': i.toString() },\n          timestamp: Date.now(),\n          level: 'info'\n        });\n      }\n      expect(model.maxLength).toEqual(10);\n      expect(model.length).toEqual(10);\n      model.maxLength = 5;\n      expect(model.maxLength).toEqual(5);\n      expect(model.length).toEqual(5);\n      expect(model.get(0).data['text/plain']).toEqual('7');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should create a Logger with initial properties",
            "suites": [
                "Logger",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 92,
                "column": 54
            },
            "line": 92,
            "code": "    it('should create a Logger with initial properties', () => {\n      expect(logger).toBeInstanceOf(Logger);\n      expect(logger.source).toEqual('test source');\n      expect(logger.maxLength).toEqual(10);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should set the maximum number of messages in the first-in first-out queue",
            "suites": [
                "Logger",
                "#maxLength"
            ],
            "updatePoint": {
                "line": 100,
                "column": 81
            },
            "line": 100,
            "code": "    it('should set the maximum number of messages in the first-in first-out queue', () => {\n      for (let i = 0; i < 12; i++) {\n        logger.log({ type: 'text', data: i.toString(), level: 'critical' });\n      }\n      expect(logger.length).toEqual(10);\n      expect(logger.outputAreaModel.get(0).data['text/plain']).toEqual('2');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "setting maxLength should immediately apply and trim the message list",
            "suites": [
                "Logger",
                "#maxLength"
            ],
            "updatePoint": {
                "line": 108,
                "column": 76
            },
            "line": 108,
            "code": "    it('setting maxLength should immediately apply and trim the message list', () => {\n      for (let i = 0; i < 12; i++) {\n        logger.log({ type: 'text', data: i.toString(), level: 'critical' });\n      }\n      const model = logger.outputAreaModel;\n      expect(logger.maxLength).toEqual(10);\n      expect(logger.length).toEqual(10);\n      logger.maxLength = 5;\n      expect(logger.maxLength).toEqual(5);\n      expect(logger.length).toEqual(5);\n      expect(model.get(0).data['text/plain']).toEqual('7');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should default to \"warning\"",
            "suites": [
                "Logger",
                "#level"
            ],
            "updatePoint": {
                "line": 130,
                "column": 35
            },
            "line": 130,
            "code": "    it('should default to \"warning\"', () => {\n      expect(logger.level).toEqual('warning');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "filters for messages: %s",
            "suites": [
                "Logger",
                "#level"
            ],
            "line": 134,
            "code": "    it.each(levels)('filters for messages: %s', (level: LogLevel) => {\n      logger.level = level;\n      const messages: ILogPayload[] = levels.map(level => ({\n        type: 'text',\n        data: level,\n        level\n      }));\n      messages.forEach(m => logger.log({ ...m }));\n      const logged: string[] = [];\n      for (let i = 0; i < logger.length; i++) {\n        const msg = logger.outputAreaModel.get(i);\n        logged.push(msg.level);\n      }\n      const shouldInclude = levels.slice(0, levels.indexOf(level) + 1);\n      const shouldExclude = levels.slice(levels.indexOf(level) + 1);\n      shouldInclude.forEach(x => {\n        expect(logged).toContain(x);\n      });\n      shouldExclude.forEach(x => {\n        expect(logged).not.toContain(x);\n      });\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs a \"metadata\" level text message if changed",
            "suites": [
                "Logger",
                "#level"
            ],
            "updatePoint": {
                "line": 157,
                "column": 55
            },
            "line": 157,
            "code": "    it('logs a \"metadata\" level text message if changed', () => {\n      logger.level = 'info';\n      const msg = logger.outputAreaModel.get(0);\n      expect(msg.level).toBe('metadata');\n      expect(msg.data['text/plain']).toContain('info');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits a stateChanged signal when changing",
            "suites": [
                "Logger",
                "#level"
            ],
            "updatePoint": {
                "line": 164,
                "column": 49
            },
            "line": 164,
            "code": "    it('emits a stateChanged signal when changing', () => {\n      const s = new SignalLogger(logger.stateChanged);\n      logger.level = 'info';\n      expect(s.args).toEqual([\n        {\n          name: 'level',\n          oldValue: 'warning',\n          newValue: 'info'\n        }\n      ]);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "setting to its current value has no effect",
            "suites": [
                "Logger",
                "#level"
            ],
            "updatePoint": {
                "line": 177,
                "column": 50
            },
            "line": 177,
            "code": "    it('setting to its current value has no effect', () => {\n      const s = new SignalLogger(logger.stateChanged);\n      logger.level = logger.level; // eslint-disable-line\n      expect(s.args.length).toBe(0);\n      expect(logger.length).toBe(0);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "records how many messages are stored",
            "suites": [
                "Logger",
                "#length"
            ],
            "updatePoint": {
                "line": 187,
                "column": 44
            },
            "line": 187,
            "code": "    it('records how many messages are stored', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.length).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "may be less than the messages logged if messages were combined",
            "suites": [
                "Logger",
                "#length"
            ],
            "updatePoint": {
                "line": 195,
                "column": 70
            },
            "line": 195,
            "code": "    it('may be less than the messages logged if messages were combined', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "initially is null",
            "suites": [
                "Logger",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 211,
                "column": 25
            },
            "line": 211,
            "code": "    it('initially is null', () => {\n      expect(logger.rendermime).toBe(null);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "sets the rendermime attribute",
            "suites": [
                "Logger",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 215,
                "column": 37
            },
            "line": 215,
            "code": "    it('sets the rendermime attribute', () => {\n      const value = new RenderMimeRegistry();\n      logger.rendermime = value;\n      expect(logger.rendermime).toBe(value);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits a stateChanged signal when changed",
            "suites": [
                "Logger",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 221,
                "column": 48
            },
            "line": 221,
            "code": "    it('emits a stateChanged signal when changed', () => {\n      const oldValue = (logger.rendermime = new RenderMimeRegistry());\n      const newValue = oldValue.clone();\n      const s = new SignalLogger(logger.stateChanged);\n      logger.rendermime = newValue;\n      expect(s.args).toEqual([{ name: 'rendermime', oldValue, newValue }]);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "setting to current value has no effect",
            "suites": [
                "Logger",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 230,
                "column": 46
            },
            "line": 230,
            "code": "    it('setting to current value has no effect', () => {\n      logger.rendermime = new RenderMimeRegistry();\n      const s = new SignalLogger(logger.stateChanged);\n      logger.rendermime = logger.rendermime; // eslint-disable-line\n      expect(s.args).toEqual([]);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "starts at zero",
            "suites": [
                "Logger",
                "#version"
            ],
            "updatePoint": {
                "line": 240,
                "column": 22
            },
            "line": 240,
            "code": "    it('starts at zero', () => {\n      expect(logger.version).toBe(0);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "increments every time a message is logged",
            "suites": [
                "Logger",
                "#version"
            ],
            "updatePoint": {
                "line": 244,
                "column": 49
            },
            "line": 244,
            "code": "    it('increments every time a message is logged', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.version).toBe(2);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "increments even if messages are combined",
            "suites": [
                "Logger",
                "#version"
            ],
            "updatePoint": {
                "line": 250,
                "column": 48
            },
            "line": 250,
            "code": "    it('increments even if messages are combined', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(logger.length).toBe(1);\n      expect(logger.version).toBe(2);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "does not increment on clearing messages",
            "suites": [
                "Logger",
                "#version"
            ],
            "updatePoint": {
                "line": 265,
                "column": 47
            },
            "line": 265,
            "code": "    it('does not increment on clearing messages', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.version).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n      expect(logger.version).toBe(2);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs text messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 276,
                "column": 26
            },
            "line": 276,
            "code": "    it('logs text messages', () => {\n      logger.log({ type: 'text', data: 'message', level: 'warning' });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs html messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 281,
                "column": 26
            },
            "line": 281,
            "code": "    it('logs html messages', () => {\n      logger.log({ type: 'html', data: 'message', level: 'warning' });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs output stream messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 286,
                "column": 35
            },
            "line": 286,
            "code": "    it('logs output stream messages', () => {\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message' },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs display_data messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 295,
                "column": 34
            },
            "line": 295,
            "code": "    it('logs display_data messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'display_data',\n          data: { 'text/plain': 'message' }\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs execute_result messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 307,
                "column": 36
            },
            "line": 307,
            "code": "    it('logs execute_result messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'execute_result',\n          data: { 'text/plain': 'message', execution_count: 5 }\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "logs error messages",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 319,
                "column": 27
            },
            "line": 319,
            "code": "    it('logs error messages', () => {\n      logger.log({\n        type: 'output',\n        data: {\n          output_type: 'error',\n          ename: 'Error',\n          evalue: 'Error',\n          traceback: ['level 1', 'level 2']\n        },\n        level: 'warning'\n      });\n      expect(logger.length).toBe(1);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits an \"append\" content changed signal",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 333,
                "column": 48
            },
            "line": 333,
            "code": "    it('emits an \"append\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits an \"append\" content changed signal and log outputs",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 340,
                "column": 64
            },
            "line": 340,
            "code": "    it('emits an \"append\" content changed signal and log outputs', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 1' },\n        level: 'critical'\n      });\n      logger.log({\n        type: 'output',\n        data: { output_type: 'stream', name: 'stdout', text: 'message 2' },\n        level: 'critical'\n      });\n      expect(s.args).toEqual(['append', 'append']);\n      expect(logger.length).toBe(1);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "adds a timestamp to the message",
            "suites": [
                "Logger",
                "#log()"
            ],
            "updatePoint": {
                "line": 357,
                "column": 39
            },
            "line": 357,
            "code": "    it('adds a timestamp to the message', () => {\n      const before = Date.now();\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      const after = Date.now();\n      const msgTime = logger.outputAreaModel.get(0).timestamp.getTime();\n      expect(msgTime).toBeGreaterThanOrEqual(before);\n      expect(msgTime).toBeLessThanOrEqual(after);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "clears messages",
            "suites": [
                "Logger",
                "#clear()"
            ],
            "updatePoint": {
                "line": 368,
                "column": 23
            },
            "line": 368,
            "code": "    it('clears messages', () => {\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.log({ type: 'text', data: 'message 2', level: 'warning' });\n      expect(logger.length).toBe(2);\n      logger.clear();\n      expect(logger.length).toBe(0);\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits a \"clear\" content changed signal",
            "suites": [
                "Logger",
                "#clear()"
            ],
            "updatePoint": {
                "line": 376,
                "column": 46
            },
            "line": 376,
            "code": "    it('emits a \"clear\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.log({ type: 'text', data: 'message 1', level: 'warning' });\n      logger.clear();\n      expect(s.args).toEqual(['append', 'clear']);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "adds a metadata message to the message list",
            "suites": [
                "Logger",
                "#checkpoint()"
            ],
            "updatePoint": {
                "line": 386,
                "column": 51
            },
            "line": 386,
            "code": "    it('adds a metadata message to the message list', () => {\n      logger.checkpoint();\n      expect(logger.outputAreaModel.get(0).level).toBe('metadata');\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits an \"append\" content changed signal",
            "suites": [
                "Logger",
                "#checkpoint()"
            ],
            "updatePoint": {
                "line": 391,
                "column": 48
            },
            "line": 391,
            "code": "    it('emits an \"append\" content changed signal', () => {\n      const s = new SignalLogger(logger.contentChanged);\n      logger.checkpoint();\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });",
            "file": "logger.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should create a registry with initial parameters",
            "suites": [
                "LoggerRegistry",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 56
            },
            "line": 42,
            "code": "    it('should create a registry with initial parameters', () => {\n      expect(registry).toBeInstanceOf(LoggerRegistry);\n      expect(registry.maxLength).toBe(10);\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "gets a specific logger",
            "suites": [
                "LoggerRegistry",
                "#getLogger()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 30
            },
            "line": 49,
            "code": "    it('gets a specific logger', () => {\n      const A = registry.getLogger('A');\n      const B = registry.getLogger('B');\n      expect(registry.getLogger('A')).toEqual(A);\n      expect(registry.getLogger('B')).toEqual(B);\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "creates a new logger on demand if needed with default parameters",
            "suites": [
                "LoggerRegistry",
                "#getLogger()"
            ],
            "updatePoint": {
                "line": 55,
                "column": 72
            },
            "line": 55,
            "code": "    it('creates a new logger on demand if needed with default parameters', () => {\n      const A = registry.getLogger('A');\n      expect(A.rendermime).toBe(defaultRendermime);\n      expect(A.maxLength).toBe(registry.maxLength);\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits a registry changed \"append\" signal",
            "suites": [
                "LoggerRegistry",
                "#getLogger()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 48
            },
            "line": 60,
            "code": "    it('emits a registry changed \"append\" signal', () => {\n      const s = new SignalLogger(registry.registryChanged);\n      registry.getLogger('A');\n      expect(s.args).toEqual(['append']);\n      s.dispose();\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "gets all current loggers",
            "suites": [
                "LoggerRegistry",
                "#getLoggers"
            ],
            "updatePoint": {
                "line": 69,
                "column": 32
            },
            "line": 69,
            "code": "    it('gets all current loggers', () => {\n      const A = registry.getLogger('A');\n      expect(registry.getLoggers()).toEqual([A]);\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "overrides the max length for all loggers",
            "suites": [
                "LoggerRegistry",
                "#maxLength"
            ],
            "updatePoint": {
                "line": 76,
                "column": 48
            },
            "line": 76,
            "code": "    it('overrides the max length for all loggers', () => {\n      const A = registry.getLogger('A');\n      const B = registry.getLogger('B');\n      A.maxLength = 5;\n      B.maxLength = 20;\n      expect(A.maxLength).toEqual(5);\n      expect(B.maxLength).toEqual(20);\n      registry.maxLength = 12;\n      expect(A.maxLength).toEqual(12);\n      expect(B.maxLength).toEqual(12);\n    });",
            "file": "registry.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should create a console with initial parameters",
            "suites": [
                "LogConsolePanel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 55
            },
            "line": 67,
            "code": "    it('should create a console with initial parameters', () => {\n      expect(logConsole).toBeInstanceOf(LogConsolePanel);\n      expect(logConsole.loggerRegistry).toBe(registry);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "returns the logger registry",
            "suites": [
                "LogConsolePanel",
                "#loggerRegistry"
            ],
            "updatePoint": {
                "line": 74,
                "column": 35
            },
            "line": 74,
            "code": "    it('returns the logger registry', () => {\n      expect(logConsole.loggerRegistry).toBe(registry);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "sets the current source",
            "suites": [
                "LogConsolePanel",
                "#source"
            ],
            "updatePoint": {
                "line": 80,
                "column": 31
            },
            "line": 80,
            "code": "    it('sets the current source', () => {\n      expect(logConsole.source).toBe(null);\n      registry.getLogger('A');\n      logConsole.source = 'A';\n      expect(logConsole.source).toBe('A');\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "displays output only from the current source",
            "suites": [
                "LogConsolePanel",
                "#source"
            ],
            "updatePoint": {
                "line": 87,
                "column": 52
            },
            "line": 87,
            "code": "    it('displays output only from the current source', () => {\n      const loggerA = registry.getLogger('A');\n      const loggerB = registry.getLogger('B');\n      loggerA.log({\n        type: 'html',\n        data: '<div id=\"A\"></div>',\n        level: 'warning'\n      });\n      loggerB.log({\n        type: 'html',\n        data: '<div id=\"B\"></div>',\n        level: 'warning'\n      });\n      logConsole.source = 'A';\n      const nodeA = logConsole.node.querySelector('#A')!;\n      const nodeB = logConsole.node.querySelector('#B')!;\n      expect(nodeA).not.toBeNull();\n      expect(anyAncestor(nodeA, isHiddenLumino)).toBe(false);\n      expect(nodeB).not.toBeNull();\n      expect(anyAncestor(nodeB, isHiddenLumino)).toBe(true);\n\n      logConsole.source = 'B';\n      expect(anyAncestor(nodeA, isHiddenLumino)).toBe(true);\n      expect(anyAncestor(nodeB, isHiddenLumino)).toBe(false);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits a source changed signal if changed",
            "suites": [
                "LogConsolePanel",
                "#source"
            ],
            "updatePoint": {
                "line": 113,
                "column": 48
            },
            "line": 113,
            "code": "    it('emits a source changed signal if changed', () => {\n      const s = new SignalLogger(logConsole.sourceChanged);\n      logConsole.source = 'A';\n      logConsole.source = null;\n      expect(s.args).toEqual([\n        { name: 'source', oldValue: null, newValue: 'A' },\n        { name: 'source', oldValue: 'A', newValue: null }\n      ]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "has no effect if not changed",
            "suites": [
                "LogConsolePanel",
                "#source"
            ],
            "updatePoint": {
                "line": 124,
                "column": 36
            },
            "line": 124,
            "code": "    it('has no effect if not changed', () => {\n      const s = new SignalLogger(logConsole.sourceChanged);\n      logConsole.source = null;\n      expect(s.args).toEqual([]);\n\n      registry.getLogger('A');\n      logConsole.source = 'A';\n\n      s.clear();\n      logConsole.source = 'A';\n      expect(s.args).toEqual([]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "gives the version for the current source",
            "suites": [
                "LogConsolePanel",
                "#sourceVersion"
            ],
            "updatePoint": {
                "line": 140,
                "column": 48
            },
            "line": 140,
            "code": "    it('gives the version for the current source', () => {\n      const A = registry.getLogger('A');\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      logConsole.source = 'A';\n      expect(logConsole.sourceVersion).toBe(A.version);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "is null if the source is null",
            "suites": [
                "LogConsolePanel",
                "#sourceVersion"
            ],
            "updatePoint": {
                "line": 147,
                "column": 37
            },
            "line": 147,
            "code": "    it('is null if the source is null', () => {\n      expect(logConsole.source).toBe(null);\n      expect(logConsole.sourceVersion).toBe(null);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "gives the logger for the current source",
            "suites": [
                "LogConsolePanel",
                "#logger"
            ],
            "updatePoint": {
                "line": 154,
                "column": 47
            },
            "line": 154,
            "code": "    it('gives the logger for the current source', () => {\n      const A = registry.getLogger('A');\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      A.log({ type: 'text', data: 'message', level: 'warning' });\n      logConsole.source = 'A';\n      expect(logConsole.logger).toBe(A);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "is null if the source is null",
            "suites": [
                "LogConsolePanel",
                "#logger"
            ],
            "updatePoint": {
                "line": 161,
                "column": 37
            },
            "line": 161,
            "code": "    it('is null if the source is null', () => {\n      expect(logConsole.source).toBe(null);\n      expect(logConsole.logger).toBe(null);\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits when console is attached",
            "suites": [
                "LogConsolePanel",
                "#sourceDisplayed"
            ],
            "updatePoint": {
                "line": 168,
                "column": 38
            },
            "line": 168,
            "code": "    it('emits when console is attached', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      logConsole.source = 'A';\n      expect(s.args).toEqual([]);\n\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits when console is shown",
            "suites": [
                "LogConsolePanel",
                "#sourceDisplayed"
            ],
            "updatePoint": {
                "line": 180,
                "column": 35
            },
            "line": 180,
            "code": "    it('emits when console is shown', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      logConsole.source = 'A';\n      logConsole.hide();\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n      logConsole.show();\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits when source is selected",
            "suites": [
                "LogConsolePanel",
                "#sourceDisplayed"
            ],
            "updatePoint": {
                "line": 193,
                "column": 37
            },
            "line": 193,
            "code": "    it('emits when source is selected', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      const loggerB = registry.getLogger('B');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      loggerB.log({ type: 'text', data: 'B1', level: 'warning' });\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n\n      logConsole.source = 'A';\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.clear();\n\n      loggerB.log({ type: 'text', data: 'B2', level: 'warning' });\n      expect(s.args).toEqual([]);\n      logConsole.source = 'B';\n      expect(s.args).toEqual([{ source: 'B', version: 2 }]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "emits when logging to displayed source",
            "suites": [
                "LogConsolePanel",
                "#sourceDisplayed"
            ],
            "updatePoint": {
                "line": 213,
                "column": 46
            },
            "line": 213,
            "code": "    it('emits when logging to displayed source', () => {\n      const s = new SignalLogger(logConsole.sourceDisplayed);\n      const loggerA = registry.getLogger('A');\n      loggerA.log({ type: 'text', data: 'A1', level: 'warning' });\n      Widget.attach(logConsole, document.body);\n      expect(s.args).toEqual([]);\n\n      logConsole.source = 'A';\n      expect(s.args).toEqual([{ source: 'A', version: 1 }]);\n      s.clear();\n\n      loggerA.log({ type: 'text', data: 'A2', level: 'warning' });\n      expect(s.args).toEqual([{ source: 'A', version: 2 }]);\n      s.dispose();\n    });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/logconsole/test"
        },
        {
            "name": "should construct a new edit menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "EditMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 42
            },
            "line": 25,
            "code": "      it('should construct a new edit menu', () => {\n        expect(menu).toBeInstanceOf(EditMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "edit.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new file menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "FileMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 42
            },
            "line": 25,
            "code": "      it('should construct a new file menu', () => {\n        expect(menu).toBeInstanceOf(FileMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "file.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a submenu for `New...` commands",
            "suites": [
                "@jupyterlab/mainmenu",
                "FileMenu",
                "#newMenu"
            ],
            "updatePoint": {
                "line": 33,
                "column": 51
            },
            "line": 33,
            "code": "      it('should be a submenu for `New...` commands', () => {\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.newMenu.title.label).toBe('');\n      });",
            "file": "file.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new help menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "HelpMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 42
            },
            "line": 25,
            "code": "      it('should construct a new help menu', () => {\n        expect(menu).toBeInstanceOf(HelpMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "help.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new kernel menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "KernelMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 44
            },
            "line": 25,
            "code": "      it('should construct a new kernel menu', () => {\n        expect(menu).toBeInstanceOf(KernelMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "kernel.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new main menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 42
            },
            "line": 37,
            "code": "      it('should construct a new main menu', () => {\n        const menu = new MainMenu(new CommandRegistry());\n        expect(menu).toBeInstanceOf(MainMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should add a new menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#addMenu()"
            ],
            "updatePoint": {
                "line": 44,
                "column": 31
            },
            "line": 44,
            "code": "      it('should add a new menu', () => {\n        const menu = new Menu({ commands });\n        mainMenu.addMenu(menu);\n        expect(find(mainMenu.menus, m => menu === m) !== undefined).toBe(true);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should take a rank as an option",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#addMenu()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 41
            },
            "line": 50,
            "code": "      it('should take a rank as an option', () => {\n        const menu1 = new Menu({ commands });\n        const menu2 = new Menu({ commands });\n        mainMenu.addMenu(menu1, false, { rank: 300 });\n        mainMenu.addMenu(menu2, false, { rank: 200 });\n        expect(\n          ArrayExt.firstIndexOf(mainMenu.menus, menu1) >\n            ArrayExt.firstIndexOf(mainMenu.menus, menu2)\n        ).toBe(true);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a FileMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#fileMenu"
            ],
            "updatePoint": {
                "line": 63,
                "column": 30
            },
            "line": 63,
            "code": "      it('should be a FileMenu', () => {\n        expect(mainMenu.fileMenu).toBeInstanceOf(FileMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 1",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#fileMenu"
            ],
            "updatePoint": {
                "line": 67,
                "column": 33
            },
            "line": 67,
            "code": "      it('has a default rank of 1', () => {\n        expect(mainMenu.fileMenu.rank).toEqual(1);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a EditMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#editMenu"
            ],
            "updatePoint": {
                "line": 73,
                "column": 30
            },
            "line": 73,
            "code": "      it('should be a EditMenu', () => {\n        expect(mainMenu.editMenu).toBeInstanceOf(EditMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 2",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#editMenu"
            ],
            "updatePoint": {
                "line": 77,
                "column": 33
            },
            "line": 77,
            "code": "      it('has a default rank of 2', () => {\n        expect(mainMenu.editMenu.rank).toEqual(2);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a ViewMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#viewMenu"
            ],
            "updatePoint": {
                "line": 83,
                "column": 30
            },
            "line": 83,
            "code": "      it('should be a ViewMenu', () => {\n        expect(mainMenu.viewMenu).toBeInstanceOf(ViewMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 3",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#viewMenu"
            ],
            "updatePoint": {
                "line": 87,
                "column": 33
            },
            "line": 87,
            "code": "      it('has a default rank of 3', () => {\n        expect(mainMenu.viewMenu.rank).toEqual(3);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a RunMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#runMenu"
            ],
            "updatePoint": {
                "line": 93,
                "column": 29
            },
            "line": 93,
            "code": "      it('should be a RunMenu', () => {\n        expect(mainMenu.runMenu).toBeInstanceOf(RunMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 4",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#runMenu"
            ],
            "updatePoint": {
                "line": 97,
                "column": 33
            },
            "line": 97,
            "code": "      it('has a default rank of 4', () => {\n        expect(mainMenu.runMenu.rank).toEqual(4);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a KernelMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#kernelMenu"
            ],
            "updatePoint": {
                "line": 103,
                "column": 32
            },
            "line": 103,
            "code": "      it('should be a KernelMenu', () => {\n        expect(mainMenu.kernelMenu).toBeInstanceOf(KernelMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 5",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#kernelMenu"
            ],
            "updatePoint": {
                "line": 107,
                "column": 33
            },
            "line": 107,
            "code": "      it('has a default rank of 5', () => {\n        expect(mainMenu.kernelMenu.rank).toEqual(5);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a TabsMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#tabsMenu"
            ],
            "updatePoint": {
                "line": 113,
                "column": 30
            },
            "line": 113,
            "code": "      it('should be a TabsMenu', () => {\n        expect(mainMenu.tabsMenu).toBeInstanceOf(TabsMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 500",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#tabsMenu"
            ],
            "updatePoint": {
                "line": 117,
                "column": 35
            },
            "line": 117,
            "code": "      it('has a default rank of 500', () => {\n        expect(mainMenu.tabsMenu.rank).toEqual(500);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a SettingsMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#settingsMenu"
            ],
            "updatePoint": {
                "line": 123,
                "column": 34
            },
            "line": 123,
            "code": "      it('should be a SettingsMenu', () => {\n        expect(mainMenu.settingsMenu).toBeInstanceOf(SettingsMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 999",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#settingsMenu"
            ],
            "updatePoint": {
                "line": 127,
                "column": 35
            },
            "line": 127,
            "code": "      it('has a default rank of 999', () => {\n        expect(mainMenu.settingsMenu.rank).toEqual(999);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should be a HelpMenu",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#helpMenu"
            ],
            "updatePoint": {
                "line": 133,
                "column": 30
            },
            "line": 133,
            "code": "      it('should be a HelpMenu', () => {\n        expect(mainMenu.helpMenu).toBeInstanceOf(HelpMenu);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "has a default rank of 1000",
            "suites": [
                "@jupyterlab/mainmenu",
                "MainMenu",
                "#helpMenu"
            ],
            "updatePoint": {
                "line": 137,
                "column": 36
            },
            "line": 137,
            "code": "      it('has a default rank of 1000', () => {\n        expect(mainMenu.helpMenu.rank).toEqual(1000);\n      });",
            "file": "mainmenu.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new run menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "RunMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 41
            },
            "line": 25,
            "code": "      it('should construct a new run menu', () => {\n        expect(menu).toBeInstanceOf(RunMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "run.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should construct a new view menu",
            "suites": [
                "@jupyterlab/mainmenu",
                "ViewMenu",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 42
            },
            "line": 25,
            "code": "      it('should construct a new view menu', () => {\n        expect(menu).toBeInstanceOf(ViewMenu);\n        // For localization this is now defined when on the mainmenu-extension.\n        expect(menu.title.label).toBe('');\n      });",
            "file": "view.spec.ts",
            "skipped": false,
            "dir": "packages/mainmenu/test"
        },
        {
            "name": "should return true for a valid json object",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 10,
                "column": 50
            },
            "line": 10,
            "code": "    it('should return true for a valid json object', () => {\n      expect(VALIDATE('application/json', { foo: 1 })).toBe(true);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should return true for a valid json-like object",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 14,
                "column": 55
            },
            "line": 14,
            "code": "    it('should return true for a valid json-like object', () => {\n      expect(VALIDATE('application/foo+json', { foo: 1 })).toBe(true);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should return true for a valid string object",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 18,
                "column": 52
            },
            "line": 18,
            "code": "    it('should return true for a valid string object', () => {\n      expect(VALIDATE('text/plain', 'foo')).toBe(true);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should return true for a valid array of strings object",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 22,
                "column": 62
            },
            "line": 22,
            "code": "    it('should return true for a valid array of strings object', () => {\n      expect(VALIDATE('text/plain', ['foo', 'bar'])).toBe(true);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should return false for a json type with string data",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 26,
                "column": 60
            },
            "line": 26,
            "code": "    it('should return false for a json type with string data', () => {\n      expect(VALIDATE('application/foo+json', 'bar')).toBe(false);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should return false for a string type with json data",
            "suites": [
                "@jupyterlab/nbformat",
                "validateMimeValue"
            ],
            "updatePoint": {
                "line": 30,
                "column": 60
            },
            "line": 30,
            "code": "    it('should return false for a string type with json data', () => {\n      expect(VALIDATE('foo/bar', { foo: 1 })).toBe(false);\n    });",
            "file": "nbformat.spec.ts",
            "skipped": false,
            "dir": "packages/nbformat/test"
        },
        {
            "name": "should emit when Markdown and code cells are run",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#executed"
            ],
            "updatePoint": {
                "line": 96,
                "column": 58
            },
            "line": 96,
            "code": "      it('should emit when Markdown and code cells are run', async () => {\n        const cell = widget.activeCell as CodeCell;\n        const next = widget.widgets[1] as MarkdownCell;\n        let emitted = 0;\n        let failed = 0;\n        widget.select(next);\n        cell.model.outputs.clear();\n        next.rendered = false;\n        NotebookActions.executed.connect((_, args) => {\n          const { success } = args;\n          emitted += 1;\n          if (!success) {\n            failed += 1;\n          }\n        });\n\n        await NotebookActions.run(widget, sessionContext);\n        expect(emitted).toBe(2);\n        expect(failed).toBe(0);\n        expect(next.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit an error for a cell execution failure.",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#executed"
            ],
            "updatePoint": {
                "line": 118,
                "column": 60
            },
            "line": 118,
            "code": "      it('should emit an error for a cell execution failure.', async () => {\n        let emitted = 0;\n        let failed = 0;\n        let cellError: KernelError | null | undefined = null;\n        NotebookActions.executed.connect((_, args) => {\n          const { success, error } = args;\n          emitted += 1;\n          if (!success) {\n            failed += 1;\n            cellError = error;\n          }\n        });\n        widget.model!.sharedModel.insertCell(widget.widgets.length, {\n          cell_type: 'code',\n          source: ERROR_INPUT\n        });\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        expect(result).toBe(false);\n        expect(emitted).toBe(2);\n        expect(failed).toBe(1);\n        expect(cellError).toBeInstanceOf(KernelError);\n        expect(cellError!.errorName).toBe('NameError');\n        expect(cellError!.errorValue).toBe(\"name 'foo' is not defined\");\n        expect(cellError!.traceback).not.toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit only when code cell execution is scheduled",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#executionScheduled"
            ],
            "updatePoint": {
                "line": 147,
                "column": 64
            },
            "line": 147,
            "code": "      it('should emit only when code cell execution is scheduled', async () => {\n        const cell = widget.activeCell as CodeCell;\n        const next = widget.widgets[1] as MarkdownCell;\n        let emitted = 0;\n        widget.activeCell!.model.sharedModel.setSource(\"print('hello')\");\n        widget.select(next);\n        cell.model.outputs.clear();\n        next.rendered = false;\n        NotebookActions.executionScheduled.connect(() => {\n          emitted += 1;\n        });\n\n        await NotebookActions.run(widget, sessionContext);\n        expect(emitted).toBe(1);\n        expect(next.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should split the active cell into two cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 166,
                "column": 53
            },
            "line": 166,
            "code": "      it('should split the active cell into two cells', () => {\n        const cell = widget.activeCell!;\n        const source = 'thisisasamplestringwithnospaces';\n        cell.model.sharedModel.setSource(source);\n        const index = widget.activeCellIndex;\n        const editor = cell.editor as CodeEditor.IEditor;\n        editor.setCursorPosition(editor.getPositionAt(10)!);\n        NotebookActions.splitCell(widget);\n        const cells = widget.model!.cells;\n        const newSource =\n          cells.get(index).sharedModel.getSource() +\n          cells.get(index + 1).sharedModel.getSource();\n        expect(newSource).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve leading white space in the second cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 181,
                "column": 64
            },
            "line": 181,
            "code": "      it('should preserve leading white space in the second cell', () => {\n        const cell = widget.activeCell!;\n        const source = 'this\\n\\n   is a test';\n        cell.model.sharedModel.setSource(source);\n        const editor = cell.editor as CodeEditor.IEditor;\n        editor.setCursorPosition(editor.getPositionAt(4)!);\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(\n          '   is a test'\n        );\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 193,
                "column": 45
            },
            "line": 193,
            "code": "      it('should clear the existing selection', () => {\n        for (const child of widget.widgets) {\n          widget.select(child);\n        }\n        NotebookActions.splitCell(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the second cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 206,
                "column": 41
            },
            "line": 206,
            "code": "      it('should activate the second cell', () => {\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the types of each cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 211,
                "column": 48
            },
            "line": 211,
            "code": "      it('should preserve the types of each cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell).toBeInstanceOf(MarkdownCell);\n        const prev = widget.widgets[0];\n        expect(prev).toBeInstanceOf(MarkdownCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create two empty cells if there is no content",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 219,
                "column": 62
            },
            "line": 219,
            "code": "      it('should create two empty cells if there is no content', () => {\n        widget.activeCell!.model.sharedModel.setSource('');\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');\n        const prev = widget.widgets[0];\n        expect(prev.model.sharedModel.getSource()).toBe('');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 227,
                "column": 48
            },
            "line": 227,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.splitCell(widget);\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should switch the widget mode to edit",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 233,
                "column": 47
            },
            "line": 233,
            "code": "      it('should switch the widget mode to edit', () => {\n        NotebookActions.splitCell(widget);\n        expect(widget.mode).toBe('edit');\n        widget.mode = 'edit';\n        NotebookActions.splitCell(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#splitCell({})"
            ],
            "updatePoint": {
                "line": 241,
                "column": 29
            },
            "line": 241,
            "code": "      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        const count = widget.widgets.length;\n        NotebookActions.splitCell(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should merge the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 253,
                "column": 41
            },
            "line": 253,
            "code": "      it('should merge the selected cells', () => {\n        let source = widget.activeCell!.model.sharedModel.getSource() + '\\n\\n';\n        let next = widget.widgets[1];\n        widget.select(next);\n        source += next.model.sharedModel.getSource() + '\\n\\n';\n        next = widget.widgets[2];\n        widget.select(next);\n        source += next.model.sharedModel.getSource();\n        const count = widget.widgets.length;\n        NotebookActions.mergeCells(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 267,
                "column": 48
            },
            "line": 267,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select the next cell if there is only one cell selected",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 273,
                "column": 72
            },
            "line": 273,
            "code": "      it('should select the next cell if there is only one cell selected', () => {\n        let source = widget.activeCell!.model.sharedModel.getSource() + '\\n\\n';\n        const next = widget.widgets[1];\n        source += next.model.sharedModel.getSource();\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select the previous cell if there is only one cell selected and mergeAbove is true",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 281,
                "column": 99
            },
            "line": 281,
            "code": "      it('should select the previous cell if there is only one cell selected and mergeAbove is true', () => {\n        widget.activeCellIndex = 1;\n        let source = widget.activeCell!.model.sharedModel.getSource();\n        const previous = widget.widgets[0];\n        source = previous.model.sharedModel.getSource() + '\\n\\n' + source;\n        NotebookActions.mergeCells(widget, true);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should do nothing if first cell selected and mergeAbove is true",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 290,
                "column": 73
            },
            "line": 290,
            "code": "      it('should do nothing if first cell selected and mergeAbove is true', () => {\n        let source = widget.activeCell!.model.sharedModel.getSource();\n        const cellNumber = widget.widgets.length;\n        NotebookActions.mergeCells(widget, true);\n        expect(widget.widgets.length).toBe(cellNumber);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the outputs of a code cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 298,
                "column": 49
            },
            "line": 298,
            "code": "      it('should clear the outputs of a code cell', () => {\n        NotebookActions.mergeCells(widget);\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should mark cell as trusted as cells without output are trusted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 304,
                "column": 73
            },
            "line": 304,
            "code": "      it('should mark cell as trusted as cells without output are trusted', () => {\n        NotebookActions.mergeCells(widget);\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the widget mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 310,
                "column": 41
            },
            "line": 310,
            "code": "      it('should preserve the widget mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.mergeCells(widget);\n        expect(widget.mode).toBe('edit');\n        widget.mode = 'command';\n        NotebookActions.mergeCells(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 319,
                "column": 29
            },
            "line": 319,
            "code": "      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        const count = widget.widgets.length;\n        NotebookActions.mergeCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should unrender a markdown cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 329,
                "column": 41
            },
            "line": 329,
            "code": "      it('should unrender a markdown cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        let cell = widget.activeCell as MarkdownCell;\n        cell.rendered = true;\n        NotebookActions.mergeCells(widget);\n        cell = widget.activeCell as MarkdownCell;\n        expect(cell.rendered).toBe(false);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the cell type of the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 339,
                "column": 58
            },
            "line": 339,
            "code": "      it('should preserve the cell type of the active cell', () => {\n        NotebookActions.changeCellType(widget, 'raw');\n        NotebookActions.mergeCells(widget);\n        expect(widget.activeCell).toBeInstanceOf(RawCell);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should merge attachments if the last selected cell is a %s cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "line": 346,
            "code": "      it.each(['raw', 'markdown'] as CellType[])(\n        'should merge attachments if the last selected cell is a %s cell',\n        type => {\n          for (let i = 0; i < 2; i++) {\n            NotebookActions.changeCellType(widget, type);\n            const markdownCell = widget.widgets[i] as MarkdownCell;\n            const attachment: IMimeBundle = { 'text/plain': 'test' };\n            markdownCell.model.attachments.set(UUID.uuid4(), attachment);\n            widget.select(markdownCell);\n          }\n          NotebookActions.mergeCells(widget);\n          const model = (widget.activeCell as MarkdownCell).model;\n          expect(model.attachments.length).toBe(2);\n        }\n      );",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should drop attachments if the last selected cell is a code cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#mergeCells"
            ],
            "updatePoint": {
                "line": 362,
                "column": 74
            },
            "line": 362,
            "code": "      it('should drop attachments if the last selected cell is a code cell', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        const markdownCell = widget.activeCell as MarkdownCell;\n        const attachment: IMimeBundle = { 'text/plain': 'test' };\n        markdownCell.model.attachments.set(UUID.uuid4(), attachment);\n\n        const codeCell = widget.widgets[1];\n        widget.select(codeCell);\n        NotebookActions.changeCellType(widget, 'code');\n        NotebookActions.deselectAll(widget);\n\n        widget.select(markdownCell);\n        widget.select(codeCell);\n\n        NotebookActions.mergeCells(widget);\n\n        const model = widget.activeCell!.model.toJSON();\n        expect(model.cell_type).toEqual('code');\n        expect(model.attachments).toBeUndefined();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should delete the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 385,
                "column": 42
            },
            "line": 385,
            "code": "      it('should delete the selected cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should increment deletedCells model when cells deleted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 393,
                "column": 64
            },
            "line": 393,
            "code": "      it('should increment deletedCells model when cells deleted', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.model!.deletedCells.length;\n        NotebookActions.deleteCells(widget);\n        expect(widget.model!.deletedCells.length).toBe(count + 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 401,
                "column": 48
            },
            "line": 401,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should switch to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 407,
                "column": 39
            },
            "line": 407,
            "code": "      it('should switch to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.deleteCells(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the cell after the last selected cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 413,
                "column": 63
            },
            "line": 413,
            "code": "      it('should activate the cell after the last selected cell', () => {\n        widget.activeCellIndex = 4;\n        const prev = widget.widgets[2];\n        widget.select(prev);\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCellIndex).toBe(3);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select the previous cell if the last cell is deleted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 421,
                "column": 69
            },
            "line": 421,
            "code": "      it('should select the previous cell if the last cell is deleted', () => {\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        NotebookActions.deleteCells(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add a code cell if all cells are deleted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 427,
                "column": 57
            },
            "line": 427,
            "code": "      it('should add a code cell if all cells are deleted', async () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.deleteCells(widget);\n        await sleep();\n        expect(widget.widgets.length).toBe(1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 437,
                "column": 29
            },
            "line": 437,
            "code": "      it('should be undo-able', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        const cell = widget.widgets[0];\n        expect(cell.model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able if all the cells are deleted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#deleteCells()"
            ],
            "updatePoint": {
                "line": 449,
                "column": 58
            },
            "line": 449,
            "code": "      it('should be undo-able if all the cells are deleted', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        const count = widget.widgets.length;\n        const source = widget.widgets[1].model.sharedModel.getSource();\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n        expect(widget.widgets[1].model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should insert a code cell above the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 463,
                "column": 57
            },
            "line": 463,
            "code": "      it('should insert a code cell above the active cell', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 471,
                "column": 48
            },
            "line": 471,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "widget mode should be preserved",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 477,
                "column": 41
            },
            "line": 477,
            "code": "      it('widget mode should be preserved', () => {\n        NotebookActions.insertAbove(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.insertAbove(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 485,
                "column": 29
            },
            "line": 485,
            "code": "      it('should be undo-able', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertAbove(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 492,
                "column": 45
            },
            "line": 492,
            "code": "      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.insertAbove(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the new active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 505,
                "column": 39
            },
            "line": 505,
            "code": "      it('should be the new active cell', () => {\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should mark inserted code cell as trusted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertAbove()"
            ],
            "updatePoint": {
                "line": 510,
                "column": 51
            },
            "line": 510,
            "code": "      it('should mark inserted code cell as trusted', () => {\n        NotebookActions.insertAbove(widget);\n        expect(widget.activeCell!.model.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should insert a code cell below the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 517,
                "column": 57
            },
            "line": 517,
            "code": "      it('should insert a code cell below the active cell', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 525,
                "column": 48
            },
            "line": 525,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should widget mode should be preserved",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 531,
                "column": 48
            },
            "line": 531,
            "code": "      it('should widget mode should be preserved', () => {\n        NotebookActions.insertBelow(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.insertBelow(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 539,
                "column": 29
            },
            "line": 539,
            "code": "      it('should be undo-able', () => {\n        const count = widget.widgets.length;\n        NotebookActions.insertBelow(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 546,
                "column": 45
            },
            "line": 546,
            "code": "      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.insertBelow(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the new active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 559,
                "column": 39
            },
            "line": 559,
            "code": "      it('should be the new active cell', () => {\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should mark inserted code cell as trusted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#insertBelow()"
            ],
            "updatePoint": {
                "line": 564,
                "column": 51
            },
            "line": 564,
            "code": "      it('should mark inserted code cell as trusted', () => {\n        NotebookActions.insertBelow(widget);\n        expect(widget.activeCell!.model.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change the selected cell type(s)",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 571,
                "column": 49
            },
            "line": 571,
            "code": "      it('should change the selected cell type(s)', () => {\n        let next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.changeCellType(widget, 'raw');\n        expect(widget.activeCell).toBeInstanceOf(RawCell);\n        next = widget.widgets[widget.activeCellIndex + 1];\n        expect(next).toBeInstanceOf(RawCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 580,
                "column": 48
            },
            "line": 580,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.changeCellType(widget, 'code');\n        expect(widget.activeCell).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the widget mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 586,
                "column": 41
            },
            "line": 586,
            "code": "      it('should preserve the widget mode', () => {\n        NotebookActions.changeCellType(widget, 'code');\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.changeCellType(widget, 'raw');\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 594,
                "column": 29
            },
            "line": 594,
            "code": "      it('should be undo-able', () => {\n        NotebookActions.changeCellType(widget, 'raw');\n        NotebookActions.undo(widget);\n        const cell = widget.widgets[0];\n        expect(cell).toBeInstanceOf(CodeCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 601,
                "column": 45
            },
            "line": 601,
            "code": "      it('should clear the existing selection', () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.changeCellType(widget, 'raw');\n        for (let i = 0; i < widget.widgets.length; i++) {\n          if (i === widget.activeCellIndex) {\n            continue;\n          }\n          expect(widget.isSelected(widget.widgets[i])).toBe(false);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should unrender markdown cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 614,
                "column": 40
            },
            "line": 614,
            "code": "      it('should unrender markdown cells', () => {\n        NotebookActions.changeCellType(widget, 'markdown');\n        const cell = widget.activeCell as MarkdownCell;\n        expect(cell.rendered).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should mark code cell as trusted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 620,
                "column": 42
            },
            "line": 620,
            "code": "      it('should mark code cell as trusted', () => {\n        // Switch to markdown and then to code as otherwise this is no-op.\n        NotebookActions.changeCellType(widget, 'markdown');\n        NotebookActions.changeCellType(widget, 'code');\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear trust metadata if switching away from code cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#changeCellType()"
            ],
            "updatePoint": {
                "line": 628,
                "column": 70
            },
            "line": 628,
            "code": "      it('should clear trust metadata if switching away from code cell', () => {\n        widget.activeCell!.model.trusted = true;\n        NotebookActions.changeCellType(widget, 'markdown');\n        const cell = widget.activeCell as MarkdownCell;\n        expect(cell.model.metadata.trusted).toBe(undefined);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should run the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 637,
                "column": 39
            },
            "line": 637,
            "code": "      it('should run the selected cells', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should delete deletedCells metadata when cell run",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 654,
                "column": 59
            },
            "line": 654,
            "code": "      it('should delete deletedCells metadata when cell run', () => {\n        const cell = widget.activeCell as CodeCell;\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        cell.model.outputs.clear();\n        return NotebookActions.run(widget, sessionContext).then(result => {\n          expect(result).toBe(true);\n          expect(widget.model!.deletedCells.length).toBe(0);\n          expect(emitted).toBe(1);\n        });\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 668,
                "column": 48
            },
            "line": 668,
            "code": "      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(false);\n        expect(emitted).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the last selected cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 679,
                "column": 48
            },
            "line": 679,
            "code": "      it('should activate the last selected cell', async () => {\n        const other = widget.widgets[2];\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.select(other);\n        other.model.sharedModel.setSource('a = 1');\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.activeCell).toBe(other);\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 693,
                "column": 36
            },
            "line": 693,
            "code": "      it('should clear the selection', async () => {\n        const next = widget.widgets[1];\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.select(next);\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 706,
                "column": 39
            },
            "line": 706,
            "code": "      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle no session",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 718,
                "column": 34
            },
            "line": 718,
            "code": "      it('should handle no session', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        const result = await NotebookActions.run(\n          widget,\n          {\n            isTerminating: false,\n            pendingInput: false,\n            hasNoKernel: true,\n            kernelPreference: { autoStartDefault: false },\n            startKernel: () => Promise.resolve(true)\n          } as ISessionContext,\n          { selectKernel: () => Promise.resolve() } as any\n        );\n        expect(result).toBe(true);\n        const cell = widget.activeCell as CodeCell;\n        expect(cell.model.executionCount).toBe(null);\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should stop executing code cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 740,
                "column": 54
            },
            "line": 740,
            "code": "      it('should stop executing code cells on an error', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.model!.sharedModel.insertCell(2, {\n          cell_type: 'code',\n          source: ERROR_INPUT\n        });\n        widget.select(widget.widgets[2]);\n        const cell = widget.model!.sharedModel.insertCell(\n          widget.widgets.length,\n          { cell_type: 'code' }\n        ) as ISharedCodeCell;\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        await sleep(400);\n        expect(result).toBe(false);\n        expect(cell.execution_count).toBeNull();\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should render all markdown cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#run()"
            ],
            "updatePoint": {
                "line": 762,
                "column": 54
            },
            "line": 762,
            "code": "      it('should render all markdown cells on an error', async () => {\n        let emitted = 0;\n        NotebookActions.selectionExecuted.connect(() => {\n          emitted += 1;\n        });\n        widget.model!.sharedModel.insertCell(widget.widgets.length, {\n          cell_type: 'markdown'\n        });\n        const child = widget.widgets[widget.widgets.length - 1] as MarkdownCell;\n        child.rendered = false;\n        widget.select(child);\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const result = await NotebookActions.run(widget, ipySessionContext);\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(400);\n        expect(result).toBe(false);\n        expect(child.rendered).toBe(true);\n        expect(emitted).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should run the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 786,
                "column": 39
            },
            "line": 786,
            "code": "      it('should run the selected cells', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 801,
                "column": 48
            },
            "line": 801,
            "code": "      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 810,
                "column": 45
            },
            "line": 810,
            "code": "      it('should clear the existing selection', async () => {\n        const next = widget.widgets[3];\n        widget.select(next);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        expect(result).toBe(false);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 821,
                "column": 39
            },
            "line": 821,
            "code": "      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the cell after the last selected cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 831,
                "column": 63
            },
            "line": 831,
            "code": "      it('should activate the cell after the last selected cell', async () => {\n        const next = widget.widgets[3] as MarkdownCell;\n        widget.select(next);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.activeCellIndex).toBe(4);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new code cell in edit mode if necessary",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 842,
                "column": 65
            },
            "line": 842,
            "code": "      it('should create a new code cell in edit mode if necessary', async () => {\n        const count = widget.widgets.length;\n        widget.activeCellIndex = count - 1;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.widgets.length).toBe(count + 1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n        expect(widget.activeCell!.model.trusted).toBe(true);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should allow an undo of the new cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 856,
                "column": 46
            },
            "line": 856,
            "code": "      it('should allow an undo of the new cell', async () => {\n        const count = widget.widgets.length;\n        widget.activeCellIndex = count - 1;\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should stop executing code cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 868,
                "column": 54
            },
            "line": 868,
            "code": "      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.model!.sharedModel.insertCell(\n          widget.widgets.length,\n          { cell_type: 'code' }\n        ) as ISharedCodeCell;\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        expect(result).toBe(false);\n        expect(cell.execution_count).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should render all markdown cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndAdvance()"
            ],
            "updatePoint": {
                "line": 883,
                "column": 54
            },
            "line": 883,
            "code": "      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        widget.select(cell);\n        const result = await NotebookActions.runAndAdvance(\n          widget,\n          ipySessionContext\n        );\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(400);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should run the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 903,
                "column": 39
            },
            "line": 903,
            "code": "      it('should run the selected cells', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        widget.select(next);\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 918,
                "column": 48
            },
            "line": 918,
            "code": "      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 927,
                "column": 45
            },
            "line": 927,
            "code": "      it('should clear the existing selection', async () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should insert a new code cell in edit mode after the last selected cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 938,
                "column": 81
            },
            "line": 938,
            "code": "      it('should insert a new code cell in edit mode after the last selected cell', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        next.model.sharedModel.setSource('a = 1');\n        const count = widget.widgets.length;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n        expect(widget.activeCell!.model.trusted).toBe(true);\n        expect(widget.mode).toBe('edit');\n        expect(widget.widgets.length).toBe(count + 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should allow an undo of the cell insert",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 954,
                "column": 49
            },
            "line": 954,
            "code": "      it('should allow an undo of the cell insert', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        next.model.sharedModel.setSource('a = 1');\n        const count = widget.widgets.length;\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          sessionContext\n        );\n        expect(result).toBe(true);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should stop executing code cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 968,
                "column": 54
            },
            "line": 968,
            "code": "      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.model!.sharedModel.insertCell(\n          widget.widgets.length,\n          { cell_type: 'code' }\n        ) as ISharedCodeCell;\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          ipySessionContext\n        );\n        await sleep(400);\n        expect(result).toBe(false);\n        expect(cell.execution_count).toBeNull();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should render all markdown cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAndInsert()"
            ],
            "updatePoint": {
                "line": 984,
                "column": 54
            },
            "line": 984,
            "code": "      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        widget.select(cell);\n        const result = await NotebookActions.runAndInsert(\n          widget,\n          ipySessionContext\n        );\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(500);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should run all of the cells in the notebook",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1009,
                "column": 53
            },
            "line": 1009,
            "code": "      it('should run all of the cells in the notebook', async () => {\n        const next = widget.widgets[1] as MarkdownCell;\n        const cell = widget.activeCell as CodeCell;\n        cell.model.outputs.clear();\n        next.rendered = false;\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(cell.model.outputs.length).toBeGreaterThan(0);\n        expect(next.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1020,
                "column": 48
            },
            "line": 1020,
            "code": "      it('should be a no-op if there is no model', async () => {\n        widget.model = null;\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1026,
                "column": 39
            },
            "line": 1026,
            "code": "      it('should change to command mode', async () => {\n        widget.mode = 'edit';\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the existing selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1033,
                "column": 45
            },
            "line": 1033,
            "code": "      it('should clear the existing selection', async () => {\n        const next = widget.widgets[2];\n        widget.select(next);\n        const result = await NotebookActions.runAll(widget, sessionContext);\n        expect(result).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the last cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1041,
                "column": 39
            },
            "line": 1041,
            "code": "      it('should activate the last cell', async () => {\n        await NotebookActions.runAll(widget, sessionContext);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should stop executing code cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1046,
                "column": 54
            },
            "line": 1046,
            "code": "      it('should stop executing code cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.model!.sharedModel.insertCell(\n          widget.widgets.length,\n          { cell_type: 'code' }\n        ) as ISharedCodeCell;\n        widget.select(widget.widgets[widget.widgets.length - 1]);\n        const result = await NotebookActions.runAll(widget, ipySessionContext);\n        expect(result).toBe(false);\n        expect(cell.execution_count).toBeNull();\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should render all markdown cells on an error",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#runAll()"
            ],
            "updatePoint": {
                "line": 1059,
                "column": 54
            },
            "line": 1059,
            "code": "      it('should render all markdown cells on an error', async () => {\n        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);\n        const cell = widget.widgets[1] as MarkdownCell;\n        cell.rendered = false;\n        const result = await NotebookActions.runAll(widget, ipySessionContext);\n        // Markdown rendering is asynchronous, but the cell\n        // provides no way to hook into that. Sleep here\n        // to make sure it finishes.\n        await sleep(400);\n        expect(result).toBe(false);\n        expect(cell.rendered).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select the cell above the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectAbove()"
            ],
            "updatePoint": {
                "line": 1074,
                "column": 54
            },
            "line": 1074,
            "code": "      it('should select the cell above the active cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectAbove()"
            ],
            "updatePoint": {
                "line": 1080,
                "column": 48
            },
            "line": 1080,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the bottom",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectAbove()"
            ],
            "updatePoint": {
                "line": 1086,
                "column": 46
            },
            "line": 1086,
            "code": "      it('should not wrap around to the bottom', () => {\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectAbove()"
            ],
            "updatePoint": {
                "line": 1091,
                "column": 34
            },
            "line": 1091,
            "code": "      it('should preserve the mode', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.selectAbove(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.selectAbove(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should skip collapsed cells in edit mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectAbove()"
            ],
            "updatePoint": {
                "line": 1100,
                "column": 50
            },
            "line": 1100,
            "code": "      it('should skip collapsed cells in edit mode', () => {\n        widget.activeCellIndex = 3;\n        widget.mode = 'edit';\n        widget.widgets[1].inputHidden = true;\n        widget.widgets[2].inputHidden = true;\n        widget.widgets[3].inputHidden = false;\n        NotebookActions.selectAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select the cell below the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectBelow()"
            ],
            "updatePoint": {
                "line": 1112,
                "column": 54
            },
            "line": 1112,
            "code": "      it('should select the cell below the active cell', () => {\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectBelow()"
            ],
            "updatePoint": {
                "line": 1117,
                "column": 48
            },
            "line": 1117,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the top",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectBelow()"
            ],
            "updatePoint": {
                "line": 1123,
                "column": 43
            },
            "line": 1123,
            "code": "      it('should not wrap around to the top', () => {\n        widget.activeCellIndex = widget.widgets.length - 1;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).not.toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectBelow()"
            ],
            "updatePoint": {
                "line": 1129,
                "column": 34
            },
            "line": 1129,
            "code": "      it('should preserve the mode', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.selectBelow(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.selectBelow(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not change if in edit mode and no non-collapsed cells below",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#selectBelow()"
            ],
            "updatePoint": {
                "line": 1138,
                "column": 76
            },
            "line": 1138,
            "code": "      it('should not change if in edit mode and no non-collapsed cells below', () => {\n        widget.activeCellIndex = widget.widgets.length - 2;\n        widget.mode = 'edit';\n        widget.widgets[widget.widgets.length - 1].inputHidden = true;\n        NotebookActions.selectBelow(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should extend the selection to the cell above",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1148,
                "column": 55
            },
            "line": 1148,
            "code": "      it('should extend the selection to the cell above', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should extend the selection to the topmost cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1154,
                "column": 57
            },
            "line": 1154,
            "code": "      it('should extend the selection to the topmost cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget, true);\n        for (let i = widget.activeCellIndex; i >= 0; i--) {\n          expect(widget.isSelected(widget.widgets[i])).toBe(true);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1162,
                "column": 48
            },
            "line": 1162,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode if there is a selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1168,
                "column": 63
            },
            "line": 1168,
            "code": "      it('should change to command mode if there is a selection', () => {\n        widget.mode = 'edit';\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the bottom",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1175,
                "column": 46
            },
            "line": 1175,
            "code": "      it('should not wrap around to the bottom', () => {\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n        const last = widget.widgets[widget.widgets.length - 1];\n        expect(widget.isSelected(last)).toBe(false);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deselect the current cell if the cell above is selected",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1184,
                "column": 72
            },
            "line": 1184,
            "code": "      it('should deselect the current cell if the cell above is selected', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        NotebookActions.extendSelectionBelow(widget);\n        const cell = widget.activeCell!;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(cell)).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select only the first cell if we move from the second to first",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1192,
                "column": 79
            },
            "line": 1192,
            "code": "      it('should select only the first cell if we move from the second to first', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        const cell = widget.activeCell!;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.isSelected(cell)).toBe(false);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionAbove()"
            ],
            "updatePoint": {
                "line": 1200,
                "column": 34
            },
            "line": 1200,
            "code": "      it('should activate the cell', () => {\n        widget.activeCellIndex = 1;\n        NotebookActions.extendSelectionAbove(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should extend the selection to the cell below",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1208,
                "column": 55
            },
            "line": 1208,
            "code": "      it('should extend the selection to the cell below', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should extend the selection the bottom-most cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1214,
                "column": 58
            },
            "line": 1214,
            "code": "      it('should extend the selection the bottom-most cell', () => {\n        NotebookActions.extendSelectionBelow(widget, true);\n        for (let i = widget.activeCellIndex; i < widget.widgets.length; i++) {\n          expect(widget.isSelected(widget.widgets[i])).toBe(true);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1220,
                "column": 48
            },
            "line": 1220,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode if there is a selection",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1226,
                "column": 63
            },
            "line": 1226,
            "code": "      it('should change to command mode if there is a selection', () => {\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the top",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1232,
                "column": 43
            },
            "line": 1232,
            "code": "      it('should not wrap around to the top', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        widget.mode = 'edit';\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(last);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deselect the current cell if the cell below is selected",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1242,
                "column": 72
            },
            "line": 1242,
            "code": "      it('should deselect the current cell if the cell below is selected', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        NotebookActions.extendSelectionAbove(widget);\n        NotebookActions.extendSelectionAbove(widget);\n        const current = widget.activeCell!;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(current)).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select only the last cell if we move from the second last to last",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1252,
                "column": 82
            },
            "line": 1252,
            "code": "      it('should select only the last cell if we move from the second last to last', () => {\n        const last = widget.widgets.length - 1;\n        widget.activeCellIndex = last;\n        NotebookActions.extendSelectionAbove(widget);\n        const current = widget.activeCell!;\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.isSelected(current)).toBe(false);\n        expect(widget.activeCellIndex).toBe(last);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#extendSelectionBelow()"
            ],
            "updatePoint": {
                "line": 1262,
                "column": 34
            },
            "line": 1262,
            "code": "      it('should activate the cell', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        expect(widget.activeCellIndex).toBe(1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should move the selected cells up",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveUp()"
            ],
            "updatePoint": {
                "line": 1269,
                "column": 43
            },
            "line": 1269,
            "code": "      it('should move the selected cells up', () => {\n        widget.activeCellIndex = 2;\n        NotebookActions.extendSelectionAbove(widget);\n        NotebookActions.moveUp(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(true);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(false);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should move the last cell up",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveUp()"
            ],
            "updatePoint": {
                "line": 1279,
                "column": 38
            },
            "line": 1279,
            "code": "      it('should move the last cell up', () => {\n        const lastIndex = widget.model!.cells.length - 1;\n        widget.activeCellIndex = lastIndex;\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(lastIndex - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveUp()"
            ],
            "updatePoint": {
                "line": 1286,
                "column": 48
            },
            "line": 1286,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the bottom",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveUp()"
            ],
            "updatePoint": {
                "line": 1292,
                "column": 46
            },
            "line": 1292,
            "code": "      it('should not wrap around to the bottom', () => {\n        expect(widget.activeCellIndex).toBe(0);\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveUp()"
            ],
            "updatePoint": {
                "line": 1298,
                "column": 29
            },
            "line": 1298,
            "code": "      it('should be undo-able', () => {\n        widget.activeCellIndex++;\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        NotebookActions.moveUp(widget);\n        expect(widget.model!.cells.get(0).sharedModel.getSource()).toBe(source);\n        NotebookActions.undo(widget);\n        expect(widget.model!.cells.get(1).sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should move the selected cells down",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveDown()"
            ],
            "updatePoint": {
                "line": 1309,
                "column": 45
            },
            "line": 1309,
            "code": "      it('should move the selected cells down', () => {\n        NotebookActions.extendSelectionBelow(widget);\n        NotebookActions.moveDown(widget);\n        expect(widget.isSelected(widget.widgets[0])).toBe(false);\n        expect(widget.isSelected(widget.widgets[1])).toBe(true);\n        expect(widget.isSelected(widget.widgets[2])).toBe(true);\n        expect(widget.activeCellIndex).toBe(2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveDown()"
            ],
            "updatePoint": {
                "line": 1318,
                "column": 48
            },
            "line": 1318,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.moveUp(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not wrap around to the top",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveDown()"
            ],
            "updatePoint": {
                "line": 1324,
                "column": 43
            },
            "line": 1324,
            "code": "      it('should not wrap around to the top', () => {\n        widget.activeCellIndex = widget.widgets.length - 1;\n        NotebookActions.moveDown(widget);\n        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#moveDown()"
            ],
            "updatePoint": {
                "line": 1330,
                "column": 29
            },
            "line": 1330,
            "code": "      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        NotebookActions.moveDown(widget);\n        expect(widget.model!.cells.get(1).sharedModel.getSource()).toBe(source);\n        NotebookActions.undo(widget);\n        expect(widget.model!.cells.get(0).sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should copy the selected cells to a utils.clipboard",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1340,
                "column": 61
            },
            "line": 1340,
            "code": "      it('should copy the selected cells to a utils.clipboard', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.copy(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n        const data = utils.clipboard.getData(JUPYTER_CELL_MIME);\n        expect(data.length).toBe(2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1349,
                "column": 48
            },
            "line": 1349,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.copy(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1355,
                "column": 39
            },
            "line": 1355,
            "code": "      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.copy(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should delete metadata.deletable",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1361,
                "column": 42
            },
            "line": 1361,
            "code": "      it('should delete metadata.deletable', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        next.model.setMetadata('deletable', false);\n        NotebookActions.copy(widget);\n        const data = utils.clipboard.getData(JUPYTER_CELL_MIME) as JSONArray;\n        data.map(cell => {\n          expect(\n            ((cell as JSONObject).metadata as JSONObject).deletable\n          ).toBeUndefined();\n        });\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should cut the selected cells to a utils.clipboard",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#cut()"
            ],
            "updatePoint": {
                "line": 1376,
                "column": 60
            },
            "line": 1376,
            "code": "      it('should cut the selected cells to a utils.clipboard', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#cut()"
            ],
            "updatePoint": {
                "line": 1384,
                "column": 48
            },
            "line": 1384,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.cut(widget);\n        expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#cut()"
            ],
            "updatePoint": {
                "line": 1390,
                "column": 39
            },
            "line": 1390,
            "code": "      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.cut(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#cut()"
            ],
            "updatePoint": {
                "line": 1396,
                "column": 29
            },
            "line": 1396,
            "code": "      it('should be undo-able', () => {\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        NotebookActions.cut(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets[0].model.sharedModel.getSource()).toBe(source);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add a new code cell if all cells were cut",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#cut()"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 58
            },
            "line": 1403,
            "code": "      it('should add a new code cell if all cells were cut', async () => {\n        for (let i = 0; i < widget.widgets.length; i++) {\n          widget.select(widget.widgets[i]);\n        }\n        NotebookActions.cut(widget);\n        await sleep();\n        expect(widget.widgets.length).toBe(1);\n        expect(widget.activeCell).toBeInstanceOf(CodeCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should paste cells from a utils.clipboard",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#paste()"
            ],
            "updatePoint": {
                "line": 1415,
                "column": 51
            },
            "line": 1415,
            "code": "      it('should paste cells from a utils.clipboard', () => {\n        const source = widget.activeCell!.model.sharedModel.getSource();\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        widget.activeCellIndex = 1;\n        NotebookActions.paste(widget);\n        expect(widget.widgets.length).toBe(count);\n        expect(widget.widgets[2].model.sharedModel.getSource()).toBe(source);\n        expect(widget.activeCellIndex).toBe(3);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#paste()"
            ],
            "updatePoint": {
                "line": 1428,
                "column": 48
            },
            "line": 1428,
            "code": "      it('should be a no-op if there is no model', () => {\n        NotebookActions.copy(widget);\n        widget.model = null;\n        NotebookActions.paste(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no cell data on the utils.clipboard",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#paste()"
            ],
            "updatePoint": {
                "line": 1435,
                "column": 75
            },
            "line": 1435,
            "code": "      it('should be a no-op if there is no cell data on the utils.clipboard', () => {\n        const count = widget.widgets.length;\n        NotebookActions.paste(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#paste()"
            ],
            "updatePoint": {
                "line": 1441,
                "column": 39
            },
            "line": 1441,
            "code": "      it('should change to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.cut(widget);\n        NotebookActions.paste(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be undo-able",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#paste()"
            ],
            "updatePoint": {
                "line": 1448,
                "column": 29
            },
            "line": 1448,
            "code": "      it('should be undo-able', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        const count = widget.widgets.length;\n        NotebookActions.cut(widget);\n        widget.activeCellIndex = 1;\n        widget.model?.sharedModel.clearUndoHistory();\n        NotebookActions.paste(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should undo a cell action",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#undo()"
            ],
            "updatePoint": {
                "line": 1462,
                "column": 35
            },
            "line": 1462,
            "code": "      it('should undo a cell action', () => {\n        const count = widget.widgets.length;\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should switch the widget to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#undo()"
            ],
            "updatePoint": {
                "line": 1471,
                "column": 50
            },
            "line": 1471,
            "code": "      it('should switch the widget to command mode', () => {\n        widget.mode = 'edit';\n        NotebookActions.undo(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#undo()"
            ],
            "updatePoint": {
                "line": 1477,
                "column": 48
            },
            "line": 1477,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.undo(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there are no cell actions to undo",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#undo()"
            ],
            "updatePoint": {
                "line": 1483,
                "column": 64
            },
            "line": 1483,
            "code": "      it('should be a no-op if there are no cell actions to undo', () => {\n        const count = widget.widgets.length;\n        NotebookActions.deleteCells(widget);\n        widget.model!.sharedModel.clearUndoHistory();\n        NotebookActions.undo(widget);\n        expect(widget.widgets.length).toBe(count - 1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should redo a cell action",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#redo()"
            ],
            "updatePoint": {
                "line": 1493,
                "column": 35
            },
            "line": 1493,
            "code": "      it('should redo a cell action', () => {\n        const count = widget.widgets.length;\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.deleteCells(widget);\n        NotebookActions.undo(widget);\n        NotebookActions.redo(widget);\n        expect(widget.widgets.length).toBe(count - 2);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should switch the widget to command mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#redo()"
            ],
            "updatePoint": {
                "line": 1503,
                "column": 50
            },
            "line": 1503,
            "code": "      it('should switch the widget to command mode', () => {\n        NotebookActions.undo(widget);\n        widget.mode = 'edit';\n        NotebookActions.redo(widget);\n        expect(widget.mode).toBe('command');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#redo()"
            ],
            "updatePoint": {
                "line": 1510,
                "column": 48
            },
            "line": 1510,
            "code": "      it('should be a no-op if there is no model', () => {\n        NotebookActions.undo(widget);\n        widget.model = null;\n        NotebookActions.redo(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there are no cell actions to redo",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#redo()"
            ],
            "updatePoint": {
                "line": 1517,
                "column": 64
            },
            "line": 1517,
            "code": "      it('should be a no-op if there are no cell actions to redo', () => {\n        const count = widget.widgets.length;\n        NotebookActions.redo(widget);\n        expect(widget.widgets.length).toBe(count);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should toggle line numbers on all cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#toggleAllLineNumbers()"
            ],
            "updatePoint": {
                "line": 1525,
                "column": 49
            },
            "line": 1525,
            "code": "      it('should toggle line numbers on all cells', () => {\n        const state = widget.activeCell!.editor!.getOption('lineNumbers');\n        NotebookActions.toggleAllLineNumbers(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const lineNumbers =\n            widget.widgets[i].editor!.getOption('lineNumbers');\n          expect(lineNumbers).toBe(!state);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be based on the state of the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#toggleAllLineNumbers()"
            ],
            "updatePoint": {
                "line": 1535,
                "column": 57
            },
            "line": 1535,
            "code": "      it('should be based on the state of the active cell', () => {\n        const state = widget.activeCell!.editor!.getOption('lineNumbers');\n        for (let i = 1; i < widget.widgets.length; i++) {\n          widget.widgets[i].editor!.setOption('lineNumbers', !state);\n        }\n        NotebookActions.toggleAllLineNumbers(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const lineNumbers =\n            widget.widgets[i].editor!.getOption('lineNumbers');\n          expect(lineNumbers).toBe(!state);\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the widget mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#toggleAllLineNumbers()"
            ],
            "updatePoint": {
                "line": 1548,
                "column": 41
            },
            "line": 1548,
            "code": "      it('should preserve the widget mode', () => {\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#toggleAllLineNumbers()"
            ],
            "updatePoint": {
                "line": 1556,
                "column": 48
            },
            "line": 1556,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.toggleAllLineNumbers(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the outputs on the selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearOutputs()"
            ],
            "updatePoint": {
                "line": 1564,
                "column": 56
            },
            "line": 1564,
            "code": "      it('should clear the outputs on the selected cells', () => {\n        // Select the next code cell that has outputs.\n        let index = 0;\n        for (let i = 1; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          if (cell instanceof CodeCell && cell.model.outputs.length) {\n            widget.select(cell);\n            index = i;\n            break;\n          }\n        }\n        NotebookActions.clearOutputs(widget);\n        let cell = widget.widgets[0] as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n        expect(cell.model.trusted).toBe(true);\n        cell = widget.widgets[index] as CodeCell;\n        expect(cell.model.outputs.length).toBe(0);\n        expect(cell.model.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the widget mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearOutputs()"
            ],
            "updatePoint": {
                "line": 1584,
                "column": 41
            },
            "line": 1584,
            "code": "      it('should preserve the widget mode', () => {\n        NotebookActions.clearOutputs(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.clearOutputs(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearOutputs()"
            ],
            "updatePoint": {
                "line": 1592,
                "column": 48
            },
            "line": 1592,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.clearOutputs(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clear the outputs on all cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearAllOutputs()"
            ],
            "updatePoint": {
                "line": 1600,
                "column": 47
            },
            "line": 1600,
            "code": "      it('should clear the outputs on all cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.clearAllOutputs(widget);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          if (cell instanceof CodeCell) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(cell.model.outputs.length).toBe(0);\n            expect(cell.model.trusted).toBe(true);\n          }\n        }\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve the widget mode",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearAllOutputs()"
            ],
            "updatePoint": {
                "line": 1614,
                "column": 41
            },
            "line": 1614,
            "code": "      it('should preserve the widget mode', () => {\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.mode).toBe('command');\n        widget.mode = 'edit';\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#clearAllOutputs()"
            ],
            "updatePoint": {
                "line": 1622,
                "column": 48
            },
            "line": 1622,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.clearAllOutputs(widget);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the markdown header level of selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1630,
                "column": 64
            },
            "line": 1630,
            "code": "      it('should set the markdown header level of selected cells', () => {\n        const next = widget.widgets[1];\n        widget.select(next);\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(\n          widget.activeCell!.model.sharedModel.getSource().slice(0, 3)\n        ).toBe('## ');\n        expect(next.model.sharedModel.getSource().slice(0, 3)).toBe('## ');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should convert the cells to markdown type",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1640,
                "column": 51
            },
            "line": 1640,
            "code": "      it('should convert the cells to markdown type', () => {\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell).toBeInstanceOf(MarkdownCell);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be clamped between 1 and 6",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1645,
                "column": 43
            },
            "line": 1645,
            "code": "      it('should be clamped between 1 and 6', () => {\n        NotebookActions.setMarkdownHeader(widget, -1);\n        expect(\n          widget.activeCell!.model.sharedModel.getSource().slice(0, 2)\n        ).toBe('# ');\n        NotebookActions.setMarkdownHeader(widget, 10);\n        expect(\n          widget.activeCell!.model.sharedModel.getSource().slice(0, 7)\n        ).toBe('###### ');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if there is no model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1656,
                "column": 48
            },
            "line": 1656,
            "code": "      it('should be a no-op if there is no model', () => {\n        widget.model = null;\n        NotebookActions.setMarkdownHeader(widget, 1);\n        expect(widget.activeCellIndex).toBe(-1);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should replace an existing header",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1662,
                "column": 43
            },
            "line": 1662,
            "code": "      it('should replace an existing header', () => {\n        widget.activeCell!.model.sharedModel.setSource('# foo');\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('## foo');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should replace leading white space",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1668,
                "column": 44
            },
            "line": 1668,
            "code": "      it('should replace leading white space', () => {\n        widget.activeCell!.model.sharedModel.setSource('      foo');\n        NotebookActions.setMarkdownHeader(widget, 2);\n        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('## foo');\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should unrender the cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#setMarkdownHeader()"
            ],
            "updatePoint": {
                "line": 1674,
                "column": 35
            },
            "line": 1674,
            "code": "      it('should unrender the cells', () => {\n        NotebookActions.setMarkdownHeader(widget, 1);\n        expect((widget.activeCell as MarkdownCell).rendered).toBe(false);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should trust the notebook cells if the user accepts",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#trust()"
            ],
            "updatePoint": {
                "line": 1681,
                "column": 61
            },
            "line": 1681,
            "code": "      it('should trust the notebook cells if the user accepts', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = model.cells.get(0);\n        expect(cell.trusted).not.toBe(true);\n        const promise = NotebookActions.trust(widget);\n        await acceptDialog();\n        await promise;\n        expect(cell.trusted).toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not trust the notebook cells if the user aborts",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#trust()"
            ],
            "updatePoint": {
                "line": 1692,
                "column": 64
            },
            "line": 1692,
            "code": "      it('should not trust the notebook cells if the user aborts', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = model.cells.get(0);\n        expect(cell.trusted).not.toBe(true);\n        const promise = NotebookActions.trust(widget);\n        await dismissDialog();\n        await promise;\n        expect(cell.trusted).not.toBe(true);\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if the model is `null`",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#trust()"
            ],
            "updatePoint": {
                "line": 1703,
                "column": 50
            },
            "line": 1703,
            "code": "      it('should be a no-op if the model is `null`', async () => {\n        widget.model = null;\n        await expect(NotebookActions.trust(widget)).resolves.not.toThrow();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should show a dialog if all cells are trusted",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookActions",
                "#trust()"
            ],
            "updatePoint": {
                "line": 1708,
                "column": 55
            },
            "line": 1708,
            "code": "      it('should show a dialog if all cells are trusted', async () => {\n        const model = widget.model!;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        for (let i = 0; i < model.cells.length; i++) {\n          const cell = model.cells.get(i);\n          cell.trusted = true;\n        }\n        const promise = NotebookActions.trust(widget);\n        await acceptDialog();\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "actions.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should initialize the model when the file is saved for the first time",
            "suites": [
                "Context#ready"
            ],
            "updatePoint": {
                "line": 21,
                "column": 75
            },
            "line": 21,
            "code": "  it('should initialize the model when the file is saved for the first time', async () => {\n    const context = await initNotebookContext({ manager });\n    context.model.fromJSON(DEFAULT_CONTENT);\n    expect(context.model.sharedModel.canUndo()).toBe(true);\n    await context.initialize(true);\n    await context.ready;\n    expect(context.model.sharedModel.canUndo()).toBe(false);\n  });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should initialize the model when the file is reverted for the first time",
            "suites": [
                "Context#ready"
            ],
            "updatePoint": {
                "line": 30,
                "column": 78
            },
            "line": 30,
            "code": "  it('should initialize the model when the file is reverted for the first time', async () => {\n    const context = await initNotebookContext({ manager });\n    await manager.contents.save(context.path, {\n      type: 'notebook',\n      format: 'json',\n      content: DEFAULT_CONTENT\n    });\n    context.model.fromJSON(DEFAULT_CONTENT);\n    expect(context.model.sharedModel.canUndo()).toBe(true);\n    await context.initialize(false);\n    await context.ready;\n    expect(context.model.sharedModel.canUndo()).toBe(false);\n  });",
            "file": "context.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should save when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createSaveButton()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 36
            },
            "line": 45,
            "code": "        it('should save when clicked', async () => {\n          const button = ToolbarItems.createSaveButton(panel);\n          Widget.attach(button, document.body);\n          const promise = signalToPromise(context.fileChanged);\n          await framePromise();\n          await button.renderPromise;\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await expect(promise).resolves.not.toThrow();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'save' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createSaveButton()"
            ],
            "updatePoint": {
                "line": 56,
                "column": 62
            },
            "line": 56,
            "code": "        it(\"should add an inline svg node with the 'save' icon\", async () => {\n          const button = ToolbarItems.createSaveButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='save']\")\n          ).toBeDefined();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should insert below when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createInsertButton()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 44
            },
            "line": 67,
            "code": "        it('should insert below when clicked', async () => {\n          const button = ToolbarItems.createInsertButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          await button.renderPromise;\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.activeCellIndex).toBe(1);\n          expect(panel.content.activeCell).toBeInstanceOf(CodeCell);\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'add' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createInsertButton()"
            ],
            "updatePoint": {
                "line": 78,
                "column": 61
            },
            "line": 78,
            "code": "        it(\"should add an inline svg node with the 'add' icon\", async () => {\n          const button = ToolbarItems.createInsertButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='add']\")).toBeDefined();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should cut when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCutButton()"
            ],
            "updatePoint": {
                "line": 88,
                "column": 35
            },
            "line": 88,
            "code": "        it('should cut when clicked', async () => {\n          const button = ToolbarItems.createCutButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          await button.renderPromise;\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.widgets.length).toBe(count - 1);\n          expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'cut' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCutButton()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 61
            },
            "line": 100,
            "code": "        it(\"should add an inline svg node with the 'cut' icon\", async () => {\n          const button = ToolbarItems.createCutButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='cut']\")).toBeDefined();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should copy when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCopyButton()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 36
            },
            "line": 110,
            "code": "        it('should copy when clicked', async () => {\n          const button = ToolbarItems.createCopyButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          await button.renderPromise;\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          expect(panel.content.widgets.length).toBe(count);\n          expect(utils.clipboard.hasData(JUPYTER_CELL_MIME)).toBe(true);\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'copy' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCopyButton()"
            ],
            "updatePoint": {
                "line": 122,
                "column": 62
            },
            "line": 122,
            "code": "        it(\"should add an inline svg node with the 'copy' icon\", async () => {\n          const button = ToolbarItems.createCopyButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='copy']\")\n          ).toBeDefined();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should paste when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createPasteButton()"
            ],
            "updatePoint": {
                "line": 134,
                "column": 37
            },
            "line": 134,
            "code": "        it('should paste when clicked', async () => {\n          const button = ToolbarItems.createPasteButton(panel);\n          const count = panel.content.widgets.length;\n          Widget.attach(button, document.body);\n          await framePromise();\n          await button.renderPromise;\n          NotebookActions.copy(panel.content);\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await sleep();\n          expect(panel.content.widgets.length).toBe(count + 1);\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'paste' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createPasteButton()"
            ],
            "updatePoint": {
                "line": 147,
                "column": 63
            },
            "line": 147,
            "code": "        it(\"should add an inline svg node with the 'paste' icon\", async () => {\n          const button = ToolbarItems.createPasteButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='paste']\")\n          ).toBeDefined();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should track the cell type of the current cell",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCellTypeItem()"
            ],
            "updatePoint": {
                "line": 159,
                "column": 58
            },
            "line": 159,
            "code": "        it('should track the cell type of the current cell', async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          await item.renderPromise;\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          panel.content.activeCellIndex++;\n          await framePromise();\n          await item.renderPromise;\n          expect(node.value).toBe('markdown');\n          item.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should display `'-'` if multiple cell types are selected",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCellTypeItem()"
            ],
            "updatePoint": {
                "line": 175,
                "column": 68
            },
            "line": 175,
            "code": "        it(\"should display `'-'` if multiple cell types are selected\", async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          await item.renderPromise;\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          panel.content.select(panel.content.widgets[1]);\n          await framePromise();\n          await item.renderPromise;\n          expect(node.value).toBe('-');\n          item.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should display the active cell type if multiple cells of the same type are selected",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#createCellTypeItem()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 95
            },
            "line": 191,
            "code": "        it('should display the active cell type if multiple cells of the same type are selected', async () => {\n          const item = ToolbarItems.createCellTypeItem(panel);\n          Widget.attach(item, document.body);\n          await framePromise();\n          await item.renderPromise;\n          const node = item.node.getElementsByTagName(\n            'select'\n          )[0] as HTMLSelectElement;\n          expect(node.value).toBe('code');\n          panel.model!.sharedModel.insertCell(0, { cell_type: 'code' });\n          panel.content.select(panel.content.widgets[1]);\n          await framePromise();\n          await item.renderPromise;\n          expect(node.value).toBe('code');\n          item.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should return the default items of the panel toolbar",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "noKernel",
                "#getDefaultItems()"
            ],
            "updatePoint": {
                "line": 210,
                "column": 64
            },
            "line": 210,
            "code": "        it('should return the default items of the panel toolbar', () => {\n          const names = ToolbarItems.getDefaultItems(panel).map(item => {\n            const name = item.name;\n            item.widget.dispose();\n            return name;\n          });\n          expect(names).toEqual([\n            'save',\n            'insert',\n            'cut',\n            'copy',\n            'paste',\n            'run',\n            'interrupt',\n            'restart',\n            'restart-and-run',\n            'cellType',\n            'spacer',\n            'kernelName'\n          ]);\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should run and advance when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "kernelRequired",
                "#createRunButton()"
            ],
            "updatePoint": {
                "line": 251,
                "column": 47
            },
            "line": 251,
            "code": "        it('should run and advance when clicked', async () => {\n          const button = ToolbarItems.createRunButton(panel);\n          const widget = panel.content;\n\n          // Clear and select the first two cells.\n          const codeCell = widget.widgets[0] as CodeCell;\n          codeCell.model.outputs.clear();\n          widget.select(codeCell);\n          const mdCell = widget.widgets[1] as MarkdownCell;\n          mdCell.rendered = false;\n          widget.select(mdCell);\n\n          Widget.attach(button, document.body);\n          await button.renderPromise;\n          await context.sessionContext.session!.kernel!.info;\n\n          const delegate = new PromiseDelegate();\n          panel.sessionContext.iopubMessage.connect((_, msg) => {\n            if (KernelMessage.isExecuteInputMsg(msg)) {\n              delegate.resolve(void 0);\n            }\n          });\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await expect(delegate.promise).resolves.not.toThrow();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'run' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "kernelRequired",
                "#createRunButton()"
            ],
            "updatePoint": {
                "line": 278,
                "column": 61
            },
            "line": 278,
            "code": "        it(\"should add an inline svg node with the 'run' icon\", async () => {\n          const button = ToolbarItems.createRunButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(button.node.querySelector(\"[data-icon$='run']\")).toBeDefined();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should restart and run all when clicked",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "kernelRequired",
                "#createRestartRunAllButton()"
            ],
            "updatePoint": {
                "line": 287,
                "column": 51
            },
            "line": 287,
            "code": "        it('should restart and run all when clicked', async () => {\n          const button = ToolbarItems.createRestartRunAllButton(panel);\n          const widget = panel.content;\n\n          // Clear the first two cells.\n          const codeCell = widget.widgets[0] as CodeCell;\n          codeCell.model.outputs.clear();\n          const mdCell = widget.widgets[1] as MarkdownCell;\n          mdCell.rendered = false;\n\n          Widget.attach(button, document.body);\n          await button.renderPromise;\n          await panel.sessionContext.ready;\n          const delegate = new PromiseDelegate();\n          panel.sessionContext.iopubMessage.connect((_, msg) => {\n            if (KernelMessage.isExecuteInputMsg(msg)) {\n              delegate.resolve(void 0);\n            }\n          });\n          simulate(button.node.firstChild as HTMLElement, 'mousedown');\n          await acceptDialog();\n          await expect(delegate.promise).resolves.not.toThrow();\n          button.dispose();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an inline svg node with the 'fast-forward' icon",
            "suites": [
                "@jupyterlab/notebook",
                "ToolbarItems",
                "kernelRequired",
                "#createRestartRunAllButton()"
            ],
            "updatePoint": {
                "line": 312,
                "column": 70
            },
            "line": 312,
            "code": "        it(\"should add an inline svg node with the 'fast-forward' icon\", async () => {\n          const button = ToolbarItems.createRestartRunAllButton(panel);\n          Widget.attach(button, document.body);\n          await framePromise();\n          expect(\n            button.node.querySelector(\"[data-icon$='fast-forward']\")\n          ).toBeDefined();\n        });",
            "file": "default-toolbar.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebook model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 12,
                "column": 40
            },
            "line": 12,
            "code": "      it('should create a notebook model', () => {\n        const model = new NotebookModel({});\n        expect(model).toBeInstanceOf(NotebookModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept an optional language preference",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 17,
                "column": 55
            },
            "line": 17,
            "code": "      it('should accept an optional language preference', () => {\n        const model = new NotebookModel({ languagePreference: 'python' });\n        const lang = model.getMetadata(\n          'language_info'\n        ) as nbformat.ILanguageInfoMetadata;\n        expect(lang.name).toBe('python');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when a metadata field changes",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadataChanged"
            ],
            "updatePoint": {
                "line": 27,
                "column": 57
            },
            "line": 27,
            "code": "      it('should be emitted when a metadata field changes', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.metadataChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.key).toBe('foo');\n          expect(args.oldValue).toBeUndefined();\n          expect(args.newValue).toBe(1);\n          called = true;\n        });\n        model.setMetadata('foo', 1);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not be emitted when the value does not change",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadataChanged"
            ],
            "updatePoint": {
                "line": 41,
                "column": 62
            },
            "line": 41,
            "code": "      it('should not be emitted when the value does not change', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.setMetadata('foo', 1);\n        model.metadataChanged.connect(() => {\n          called = true;\n        });\n        model.setMetadata('foo', 1);\n        expect(called).toBe(false);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be reset when loading from disk",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells"
            ],
            "updatePoint": {
                "line": 54,
                "column": 48
            },
            "line": 54,
            "code": "      it('should be reset when loading from disk', () => {\n        const model = new NotebookModel();\n        model.sharedModel.insertCell(0, { cell_type: 'code' });\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.cells.length).toBe(7);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should allow undoing a change",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells"
            ],
            "updatePoint": {
                "line": 61,
                "column": 39
            },
            "line": 61,
            "code": "      it('should allow undoing a change', () => {\n        const model = new NotebookModel();\n        const cell = model.sharedModel.insertCell(0, {\n          cell_type: 'code',\n          source: 'foo'\n        });\n        const cellJSON = cell.toJSON();\n        model.sharedModel.clearUndoHistory();\n        model.sharedModel.deleteCell(0);\n        model.sharedModel.undo();\n        expect(model.cells.length).toBe(1);\n        expect(model.cells.get(0).sharedModel.getSource()).toBe('foo');\n        // Previous model matches the restored model\n        expect(model.cells.get(0).toJSON()).toEqual(cellJSON);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit a `contentChanged` signal upon cell addition",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cells `changed` signal"
            ],
            "updatePoint": {
                "line": 78,
                "column": 68
            },
            "line": 78,
            "code": "        it('should emit a `contentChanged` signal upon cell addition', () => {\n          const model = new NotebookModel();\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.sharedModel.insertCell(0, { cell_type: 'code' });\n          expect(called).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit a `contentChanged` signal upon cell removal",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cells `changed` signal"
            ],
            "updatePoint": {
                "line": 88,
                "column": 67
            },
            "line": 88,
            "code": "        it('should emit a `contentChanged` signal upon cell removal', () => {\n          const model = new NotebookModel();\n          model.sharedModel.insertCell(0, { cell_type: 'code' });\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.sharedModel.deleteCell(0);\n          expect(called).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit a `contentChanged` signal upon cell move",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cells `changed` signal"
            ],
            "updatePoint": {
                "line": 99,
                "column": 64
            },
            "line": 99,
            "code": "        it('should emit a `contentChanged` signal upon cell move', () => {\n          const model = new NotebookModel();\n          model.sharedModel.insertCells(0, [\n            { cell_type: 'code' },\n            { cell_type: 'code' }\n          ]);\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.sharedModel.moveCell(0, 1);\n          expect(called).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the dirty flag",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cells `changed` signal"
            ],
            "updatePoint": {
                "line": 113,
                "column": 37
            },
            "line": 113,
            "code": "        it('should set the dirty flag', () => {\n          const model = new NotebookModel();\n          model.sharedModel.insertCell(0, { cell_type: 'code' });\n          expect(model.dirty).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when a cell content changes",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cell `changed` signal"
            ],
            "updatePoint": {
                "line": 121,
                "column": 56
            },
            "line": 121,
            "code": "        it('should be called when a cell content changes', () => {\n          const model = new NotebookModel();\n          const cell = model.sharedModel.insertCell(0, { cell_type: 'code' });\n          expect(() => {\n            cell.setSource('foo');\n          }).not.toThrow();\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `contentChanged` signal",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cell `changed` signal"
            ],
            "updatePoint": {
                "line": 129,
                "column": 51
            },
            "line": 129,
            "code": "        it('should emit the `contentChanged` signal', () => {\n          const model = new NotebookModel();\n          model.sharedModel.insertCell(0, { cell_type: 'code' });\n          let called = false;\n          model.contentChanged.connect(() => {\n            called = true;\n          });\n          model.setMetadata('foo', 'bar');\n          expect(called).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the dirty flag",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#cells",
                "cell `changed` signal"
            ],
            "updatePoint": {
                "line": 140,
                "column": 37
            },
            "line": 140,
            "code": "        it('should set the dirty flag', () => {\n          const model = new NotebookModel();\n          const cell = model.sharedModel.insertCell(0, { cell_type: 'code' });\n          model.dirty = false;\n          cell.setSource('foo');\n          expect(model.dirty).toBe(true);\n        });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the major version number of the nbformat",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#nbformat"
            ],
            "updatePoint": {
                "line": 151,
                "column": 61
            },
            "line": 151,
            "code": "      it('should get the major version number of the nbformat', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.nbformat).toBe(utils.DEFAULT_CONTENT.nbformat);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should present a dialog when the format changes",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#nbformat"
            ],
            "updatePoint": {
                "line": 157,
                "column": 57
            },
            "line": 157,
            "code": "      it('should present a dialog when the format changes', () => {\n        const model = new NotebookModel();\n        const content = {\n          ...utils.DEFAULT_CONTENT,\n          metadata: {\n            ...utils.DEFAULT_CONTENT.metadata,\n            orig_nbformat: 1\n          }\n        };\n        model.fromJSON(content);\n        expect(model.nbformat).toBe(nbformat.MAJOR_VERSION);\n        return acceptDialog();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the minor version number of the nbformat",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#nbformatMinor"
            ],
            "updatePoint": {
                "line": 173,
                "column": 61
            },
            "line": 173,
            "code": "      it('should get the minor version number of the nbformat', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.nbformatMinor).toBe(nbformat.MINOR_VERSION);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the default kernel name of the document",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#defaultKernelName()"
            ],
            "updatePoint": {
                "line": 181,
                "column": 60
            },
            "line": 181,
            "code": "      it('should get the default kernel name of the document', () => {\n        const model = new NotebookModel();\n        model.setMetadata('kernelspec', { name: 'python3' });\n        expect(model.defaultKernelName).toBe('python3');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should default to an empty string",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#defaultKernelName()"
            ],
            "updatePoint": {
                "line": 187,
                "column": 43
            },
            "line": 187,
            "code": "      it('should default to an empty string', () => {\n        const model = new NotebookModel();\n        expect(model.defaultKernelName).toBe('');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the default kernel language of the document",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#defaultKernelLanguage"
            ],
            "updatePoint": {
                "line": 194,
                "column": 64
            },
            "line": 194,
            "code": "      it('should get the default kernel language of the document', () => {\n        const model = new NotebookModel();\n        model.setMetadata('language_info', { name: 'python' });\n        expect(model.defaultKernelLanguage).toBe('python');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should default to an empty string",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#defaultKernelLanguage"
            ],
            "updatePoint": {
                "line": 200,
                "column": 43
            },
            "line": 200,
            "code": "      it('should default to an empty string', () => {\n        const model = new NotebookModel();\n        expect(model.defaultKernelLanguage).toBe('');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be set from the constructor arg",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#defaultKernelLanguage"
            ],
            "updatePoint": {
                "line": 205,
                "column": 48
            },
            "line": 205,
            "code": "      it('should be set from the constructor arg', () => {\n        const model = new NotebookModel({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should dispose of the resources held by the model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 59
            },
            "line": 212,
            "code": "      it('should dispose of the resources held by the model', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        model.dispose();\n        expect(model.cells).toBeNull();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 220,
                "column": 47
            },
            "line": 220,
            "code": "      it('should be safe to call multiple times', () => {\n        const model = new NotebookModel();\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize the model to a string",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#toString()"
            ],
            "updatePoint": {
                "line": 229,
                "column": 48
            },
            "line": 229,
            "code": "      it('should serialize the model to a string', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const text = model.toString();\n        const data = JSON.parse(text);\n        expect(data.cells.length).toBe(7);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deserialize the model from a string",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromString()"
            ],
            "updatePoint": {
                "line": 239,
                "column": 52
            },
            "line": 239,
            "code": "      it('should deserialize the model from a string', () => {\n        const model = new NotebookModel();\n        model.fromString(JSON.stringify(utils.DEFAULT_CONTENT));\n        expect(model.cells.length).toBe(7);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the dirty flag",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromString()"
            ],
            "updatePoint": {
                "line": 245,
                "column": 35
            },
            "line": 245,
            "code": "      it('should set the dirty flag', () => {\n        const model = new NotebookModel();\n        model.dirty = false;\n        model.fromString(JSON.stringify(utils.DEFAULT_CONTENT));\n        expect(model.dirty).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize the model to JSON",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 44
            },
            "line": 254,
            "code": "      it('should serialize the model to JSON', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const data = model.toJSON();\n        expect(data.cells.length).toBe(7);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize format 4.4 or earlier without cell ids",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 260,
                "column": 65
            },
            "line": 260,
            "code": "      it('should serialize format 4.4 or earlier without cell ids', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        const data = model.toJSON();\n        expect(data.nbformat).toBe(4);\n        expect(data.nbformat_minor).toBeLessThanOrEqual(4);\n        expect(data.cells.length).toBe(7);\n        expect(data.cells[0].id).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize format 4.5 or later with cell ids",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 269,
                "column": 60
            },
            "line": 269,
            "code": "      it('should serialize format 4.5 or later with cell ids', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT_45);\n        const data = model.toJSON();\n        expect(data.cells.length).toBe(7);\n        expect(data.cells[0].id).toBe('cell_1');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should only include `trusted` metadata in code cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 276,
                "column": 62
            },
            "line": 276,
            "code": "      it('should only include `trusted` metadata in code cells', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT_45);\n\n        [...model.cells].map(cell => (cell.trusted = true));\n        expect(model.cells.get(0).type).toBe('code');\n        expect(model.cells.get(1).type).toBe('markdown');\n        expect(model.cells.get(2).type).toBe('raw');\n\n        const data = model.toJSON();\n        // code cell trust should be preserved\n        expect(data.cells[0].metadata.trusted).toBe(true);\n        // markdown cell should have no trusted entry\n        expect(data.cells[1].metadata.trusted).toBeUndefined();\n        // raw cell should have no trusted entry\n        expect(data.cells[2].metadata.trusted).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize the model from format<=4.4 JSON",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 296,
                "column": 58
            },
            "line": 296,
            "code": "      it('should serialize the model from format<=4.4 JSON', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.cells.length).toBe(7);\n        expect(model.nbformat).toBe(utils.DEFAULT_CONTENT.nbformat);\n        expect(model.nbformatMinor).toBe(nbformat.MINOR_VERSION);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should serialize the model from format 4.5 JSON",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 304,
                "column": 57
            },
            "line": 304,
            "code": "      it('should serialize the model from format 4.5 JSON', () => {\n        const model = new NotebookModel();\n        const json = utils.DEFAULT_CONTENT_45;\n        model.fromJSON(json);\n        expect(model.cells.length).toBe(7);\n        expect(model.nbformat).toBe(json.nbformat);\n        expect(model.nbformatMinor).toBe(json.nbformat_minor);\n        expect(model.cells.get(0).id).toBe('cell_1');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the dirty flag",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 314,
                "column": 35
            },
            "line": 314,
            "code": "      it('should set the dirty flag', () => {\n        const model = new NotebookModel();\n        model.dirty = false;\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        expect(model.dirty).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should populate empty notebook with empty trusted code cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 321,
                "column": 69
            },
            "line": 321,
            "code": "      it('should populate empty notebook with empty trusted code cell', () => {\n        const model = new NotebookModel();\n        model.fromJSON(utils.EMPTY_CONTENT);\n        const cell = model.cells.get(0);\n        expect(cell.trusted).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should have default values",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 330,
                "column": 36
            },
            "line": 330,
            "code": "      it('should have default values', () => {\n        const model = new NotebookModel();\n        const metadata = model.metadata;\n        expect(metadata['kernelspec']).toBeTruthy();\n        expect(metadata['language_info']).toBeTruthy();\n        expect(Object.keys(metadata)).toHaveLength(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the dirty flag when changed",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 338,
                "column": 48
            },
            "line": 338,
            "code": "      it('should set the dirty flag when changed', () => {\n        const model = new NotebookModel();\n        expect(model.dirty).toBe(false);\n        model.setMetadata('foo', 'bar');\n        expect(model.dirty).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `contentChanged` signal",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 345,
                "column": 49
            },
            "line": 345,
            "code": "      it('should emit the `contentChanged` signal', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.contentChanged.connect(() => {\n          called = true;\n        });\n        model.setMetadata('foo', 'bar');\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `metadataChanged` signal",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 355,
                "column": 50
            },
            "line": 355,
            "code": "      it('should emit the `metadataChanged` signal', () => {\n        const model = new NotebookModel();\n        let called = false;\n        model.metadataChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.key).toBe('foo');\n          expect(args.oldValue).toBeUndefined();\n          expect(args.newValue).toBe('bar');\n          called = true;\n        });\n        model.setMetadata('foo', 'bar');\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be an empty model",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModel",
                "#initialize()"
            ],
            "updatePoint": {
                "line": 371,
                "column": 34
            },
            "line": 371,
            "code": "      it('should be an empty model', () => {\n        const model = new NotebookModel();\n        expect(model.cells.length).toBe(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new notebook model factory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 9,
                "column": 52
            },
            "line": 9,
            "code": "      it('should create a new notebook model factory', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory).toBeInstanceOf(NotebookModelFactory);\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the name of the model factory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#name"
            ],
            "updatePoint": {
                "line": 16,
                "column": 50
            },
            "line": 16,
            "code": "      it('should get the name of the model factory', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.name).toBe('notebook');\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the file type",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#contentType"
            ],
            "updatePoint": {
                "line": 23,
                "column": 34
            },
            "line": 23,
            "code": "      it('should get the file type', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.contentType).toBe('notebook');\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the file format",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#fileFormat"
            ],
            "updatePoint": {
                "line": 30,
                "column": 36
            },
            "line": 30,
            "code": "      it('should get the file format', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.fileFormat).toBe('json');\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get whether the factory is disposed",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 37,
                "column": 52
            },
            "line": 37,
            "code": "      it('should get whether the factory is disposed', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should dispose of the model factory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 46,
                "column": 45
            },
            "line": 46,
            "code": "      it('should dispose of the model factory', () => {\n        const factory = new NotebookModelFactory({});\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 52,
                "column": 47
            },
            "line": 52,
            "code": "      it('should be safe to call multiple times', () => {\n        const factory = new NotebookModelFactory({});\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new model for a given path",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 52
            },
            "line": 61,
            "code": "      it('should create a new model for a given path', () => {\n        const factory = new NotebookModelFactory({});\n        const model = factory.createNew();\n        expect(model).toBeInstanceOf(NotebookModel);\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept a language preference",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 45
            },
            "line": 67,
            "code": "      it('should accept a language preference', () => {\n        const factory = new NotebookModelFactory({});\n        const model = factory.createNew({ languagePreference: 'foo' });\n        expect(model.defaultKernelLanguage).toBe('foo');\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should always return an empty string",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookModelFactory",
                "#preferredLanguage()"
            ],
            "updatePoint": {
                "line": 75,
                "column": 46
            },
            "line": 75,
            "code": "      it('should always return an empty string', () => {\n        const factory = new NotebookModelFactory({});\n        expect(factory.preferredLanguage('')).toBe('');\n        expect(factory.preferredLanguage('.ipynb')).toBe('');\n      });",
            "file": "modelfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebooktools object",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 48
            },
            "line": 109,
            "code": "        it('should create a notebooktools object', () => {\n          expect(notebookTools).toBeInstanceOf(NotebookTools);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the active notebook",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#activeNotebookPanel"
            ],
            "updatePoint": {
                "line": 115,
                "column": 41
            },
            "line": 115,
            "code": "        it('should be the active notebook', () => {\n          expect(notebookTools.activeNotebookPanel).toBe(panel1);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.activeNotebookPanel).toBe(panel0);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the active cell",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#activeCell"
            ],
            "updatePoint": {
                "line": 124,
                "column": 37
            },
            "line": 124,
            "code": "        it('should be the active cell', () => {\n          expect(notebookTools.activeCell).toBe(panel1.content.activeCell);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.activeCell).toBe(panel0.content.activeCell);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the currently selected cells",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#selectedCells"
            ],
            "updatePoint": {
                "line": 133,
                "column": 50
            },
            "line": 133,
            "code": "        it('should be the currently selected cells', () => {\n          expect(notebookTools.selectedCells).toEqual([\n            panel1.content.activeCell\n          ]);\n          tabpanel.currentIndex = 0;\n          simulate(panel0.node, 'focus');\n          expect(notebookTools.selectedCells).toEqual([\n            panel0.content.activeCell\n          ]);\n          panel0.content.select(panel0.content.widgets[1]);\n          expect(notebookTools.selectedCells.length).toBe(2);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an empty section",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#addSection()"
            ],
            "updatePoint": {
                "line": 148,
                "column": 39
            },
            "line": 148,
            "code": "        it('should add an empty section', () => {\n          const newSectionName = 'newSection';\n          expect(() => {\n            notebookTools.addSection({ sectionName: newSectionName });\n          }).not.toThrow();\n          const currentWidgets = (\n            notebookTools.layout as PanelLayout\n          ).widgets.map(w => {\n            return (w as Collapser).widget;\n          });\n          expect(\n            currentWidgets.filter(w => w.title.label === newSectionName)\n          ).toHaveLength(1);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add an section with a widget",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#addSection()"
            ],
            "updatePoint": {
                "line": 163,
                "column": 47
            },
            "line": 163,
            "code": "        it('should add an section with a widget', () => {\n          const newSectionName = 'newSection';\n          const tool = new NotebookTools.Tool();\n          expect(() => {\n            notebookTools.addSection({ sectionName: newSectionName, tool });\n          }).not.toThrow();\n          const currentWidgets = (\n            notebookTools.layout as PanelLayout\n          ).widgets.map(w => {\n            return (w as Collapser).widget;\n          });\n          const sections = currentWidgets.filter(\n            w => w.title.label === newSectionName\n          );\n          expect(sections).toHaveLength(1);\n          expect((sections[0].layout as PanelLayout).widgets).toContain(tool);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add a cell tool item",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#addItem()"
            ],
            "updatePoint": {
                "line": 183,
                "column": 39
            },
            "line": 183,
            "code": "        it('should add a cell tool item', () => {\n          const tool = new NotebookTools.Tool();\n          expect(() => {\n            notebookTools.addItem({ tool, section: sectionName });\n          }).not.toThrow();\n          tool.dispose();\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept a rank",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools",
                "#addItem()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 32
            },
            "line": 191,
            "code": "        it('should accept a rank', () => {\n          const tool = new NotebookTools.Tool();\n          expect(() => {\n            notebookTools.addItem({ tool, section: sectionName, rank: 100 });\n          }).not.toThrow();\n          tool.dispose();\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new base tool",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#constructor"
            ],
            "updatePoint": {
                "line": 203,
                "column": 41
            },
            "line": 203,
            "code": "        it('should create a new base tool', () => {\n          const tool = new NotebookTools.Tool();\n          expect(tool).toBeInstanceOf(NotebookTools.Tool);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the notebooktools object used by the tool",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#parent"
            ],
            "updatePoint": {
                "line": 210,
                "column": 63
            },
            "line": 210,
            "code": "        it('should be the notebooktools object used by the tool', () => {\n          const tool = new NotebookTools.Tool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          expect(tool.notebookTools).toBe(notebookTools);\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the active notebook panel changes",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#onActiveNotebookPanelChanged()"
            ],
            "updatePoint": {
                "line": 218,
                "column": 67
            },
            "line": 218,
            "code": "        it('should be called when the active notebook panel changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          tool.methods = [];\n          simulate(panel0.node, 'focus');\n          expect(tool.methods).toContain('onActiveNotebookPanelChanged');\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the active cell changes",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#onActiveCellChanged()"
            ],
            "updatePoint": {
                "line": 228,
                "column": 57
            },
            "line": 228,
            "code": "        it('should be called when the active cell changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          tool.methods = [];\n          simulate(panel0.node, 'focus');\n          expect(tool.methods).toContain('onActiveCellChanged');\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the selection changes",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#onSelectionChanged()"
            ],
            "updatePoint": {
                "line": 238,
                "column": 55
            },
            "line": 238,
            "code": "        it('should be called when the selection changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          tool.methods = [];\n          const current = tracker.currentWidget!;\n          current.content.select(current.content.widgets[1]);\n          expect(tool.methods).toContain('onSelectionChanged');\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the active cell metadata changes",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#onActiveCellMetadataChanged()"
            ],
            "updatePoint": {
                "line": 249,
                "column": 66
            },
            "line": 249,
            "code": "        it('should be called when the active cell metadata changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          tool.methods = [];\n          const model = notebookTools.activeCell!.model;\n          model.setMetadata('foo', 1);\n          model.setMetadata('foo', 2);\n          expect(tool.methods).toContain('onActiveCellMetadataChanged');\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the active notebook panel metadata changes",
            "suites": [
                "@jupyterlab/notebook",
                "notebooktools",
                "NotebookTools.Tool",
                "#onActiveNotebookPanelMetadataChanged()"
            ],
            "updatePoint": {
                "line": 261,
                "column": 76
            },
            "line": 261,
            "code": "        it('should be called when the active notebook panel metadata changes', () => {\n          const tool = new LogTool({});\n          notebookTools.addItem({ tool, section: sectionName });\n          tool.methods = [];\n          const model = notebookTools.activeNotebookPanel!.model!;\n          model.setMetadata('foo', 1);\n          model.setMetadata('foo', 2);\n          expect(tool.methods).toContain(\n            'onActiveNotebookPanelMetadataChanged'\n          );\n        });",
            "file": "notebooktools.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebook panel",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 40
            },
            "line": 39,
            "code": "      it('should create a notebook panel', () => {\n        const content = utils.createNotebook();\n        const panel = new NotebookPanel({ context, content });\n        expect(panel).toBeInstanceOf(NotebookPanel);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change notebook to edit mode if we have a single empty code cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 81
            },
            "line": 45,
            "code": "      it('should change notebook to edit mode if we have a single empty code cell', async () => {\n        const panel = utils.createNotebookPanel(context);\n        const model = panel.content.model;\n        expect(model).toBe(context.model);\n        await context.initialize(true);\n        await context.ready;\n        expect(panel.content.mode).toBe('edit');\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the toolbar used by the widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#toolbar"
            ],
            "updatePoint": {
                "line": 56,
                "column": 50
            },
            "line": 56,
            "code": "      it('should be the toolbar used by the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.toolbar).toBeInstanceOf(Toolbar);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the notebook content widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#content"
            ],
            "updatePoint": {
                "line": 63,
                "column": 47
            },
            "line": 63,
            "code": "      it('should be the notebook content widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.content).toBeInstanceOf(Notebook);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the document context for the widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#context"
            ],
            "updatePoint": {
                "line": 70,
                "column": 56
            },
            "line": 70,
            "code": "      it('should get the document context for the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        expect(panel.context).toBe(context);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should dispose of the resources used by the widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 77,
                "column": 60
            },
            "line": 77,
            "code": "      it('should dispose of the resources used by the widget', () => {\n        const panel = utils.createNotebookPanel(context);\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 83,
                "column": 47
            },
            "line": 83,
            "code": "      it('should be safe to call more than once', () => {\n        const panel = utils.createNotebookPanel(context);\n        panel.dispose();\n        panel.dispose();\n        expect(panel.isDisposed).toBe(true);\n      });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new ContentFactory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                ".ContentFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 93,
                "column": 46
            },
            "line": 93,
            "code": "        it('should create a new ContentFactory', () => {\n          const factory = new NotebookPanel.ContentFactory({\n            editorFactory: utils.editorFactory\n          });\n          expect(factory).toBeInstanceOf(NotebookPanel.ContentFactory);\n        });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebook widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookPanel",
                ".ContentFactory",
                "#NBTestUtils.createNotebook()"
            ],
            "updatePoint": {
                "line": 102,
                "column": 43
            },
            "line": 102,
            "code": "        it('should create a notebook widget', () => {\n          const options = {\n            contentFactory: contentFactory,\n            rendermime: utils.defaultRenderMime(),\n            mimeTypeService: utils.mimeTypeService\n          };\n          expect(contentFactory.createNotebook(options)).toBeInstanceOf(\n            Notebook\n          );\n        });",
            "file": "panel.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should return number of matches",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#matchesCount"
            ],
            "updatePoint": {
                "line": 62,
                "column": 41
            },
            "line": 62,
            "code": "      it('should return number of matches', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.matchesCount).toBe(3);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should return number of matches in selected lines",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#matchesCount"
            ],
            "updatePoint": {
                "line": 67,
                "column": 59
            },
            "line": 67,
            "code": "      it('should return number of matches in selected lines', async () => {\n        panel.model!.sharedModel.deleteCellRange(0, 2);\n        panel.model!.sharedModel.insertCells(0, [\n          { cell_type: 'code', source: 'test1\\ntest2\\ntest3\\ntest4\\ntest5' }\n        ]);\n        panel.content.activeCellIndex = 0;\n        panel.content.mode = 'edit';\n\n        await provider.startQuery(/test/, { selection: true });\n        expect(provider.matchesCount).toBe(5);\n        await setSelections(panel.content.activeCell!.editor!, [\n          {\n            uuid: 'main-selection',\n            start: { line: 1, column: 0 },\n            end: { line: 2, column: 6 }\n          }\n        ]);\n        expect(provider.matchesCount).toBe(3);\n        await setSelections(panel.content.activeCell!.editor!, [\n          {\n            uuid: 'main-selection',\n            start: { line: 1, column: 0 },\n            end: { line: 1, column: 6 }\n          }\n        ]);\n        expect(provider.matchesCount).toBe(2);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should highlight next match",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 98,
                "column": 37
            },
            "line": 98,
            "code": "      it('should highlight next match', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should loop back to first match",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 41
            },
            "line": 108,
            "code": "      it('should loop back to first match', async () => {\n        panel.content.activeCellIndex = 1;\n        await provider.startQuery(/test/, undefined);\n        expect(panel.content.activeCellIndex).toBe(1);\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.highlightNext();\n        expect(panel.content.activeCellIndex).toBe(0);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should loop back to first match when limited to single cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 119,
                "column": 69
            },
            "line": 119,
            "code": "      it('should loop back to first match when limited to single cell', async () => {\n        panel.content.activeCellIndex = 0;\n        panel.content.mode = 'command';\n        await provider.startQuery(/test/, { selection: true });\n        expect(panel.content.activeCellIndex).toBe(0);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(0);\n        expect(panel.content.activeCellIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should loop back to first match in selected lines",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 133,
                "column": 59
            },
            "line": 133,
            "code": "      it('should loop back to first match in selected lines', async () => {\n        panel.model!.sharedModel.deleteCellRange(0, 2);\n        panel.model!.sharedModel.insertCells(0, [\n          { cell_type: 'code', source: 'test1\\ntest2\\ntest3\\ntest4\\ntest5' }\n        ]);\n        panel.content.activeCellIndex = 0;\n        panel.content.mode = 'edit';\n\n        await provider.startQuery(/test/, { selection: true });\n        await setSelections(panel.content.activeCell!.editor!, [\n          {\n            uuid: 'main-selection',\n            start: { line: 1, column: 0 },\n            end: { line: 2, column: 6 }\n          }\n        ]);\n        expect(panel.content.activeCellIndex).toBe(0);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should do nothing if there are no cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightNext()"
            ],
            "updatePoint": {
                "line": 160,
                "column": 49
            },
            "line": 160,
            "code": "      it('should do nothing if there are no cells', async () => {\n        await provider.startQuery(/test/, undefined);\n        for (let _ of panel.model!.sharedModel.cells) {\n          panel.model!.sharedModel.deleteCell(0);\n        }\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(null);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should highlight previous match",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightPrevious()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 41
            },
            "line": 172,
            "code": "      it('should highlight previous match', async () => {\n        panel.content.activeCellIndex = 1;\n        await provider.startQuery(/tes/, undefined);\n        expect(provider.currentMatchIndex).toBe(2);\n        expect(panel.content.activeCellIndex).toBe(1);\n        await provider.highlightPrevious();\n        expect(panel.content.activeCellIndex).toBe(0);\n        expect(provider.currentMatchIndex).toBe(1);\n        await provider.highlightPrevious();\n        expect(panel.content.activeCellIndex).toBe(0);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should loop back to last match",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightPrevious()"
            ],
            "updatePoint": {
                "line": 186,
                "column": 40
            },
            "line": 186,
            "code": "      it('should loop back to last match', async () => {\n        await provider.startQuery(/test/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightPrevious();\n        expect(provider.currentMatchIndex).toBe(2);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should go to previous cell if there is no current match in active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#highlightPrevious()"
            ],
            "updatePoint": {
                "line": 194,
                "column": 80
            },
            "line": 194,
            "code": "      it('should go to previous cell if there is no current match in active cell', async () => {\n        await provider.startQuery(/test/, undefined);\n        await provider.highlightNext();\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(2);\n        expect(panel.content.activeCellIndex).toBe(1);\n        await provider.highlightPrevious();\n        expect(panel.content.activeCellIndex).toBe(0);\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should replace with a shorter text and highlight next",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 207,
                "column": 63
            },
            "line": 207,
            "code": "      it('should replace with a shorter text and highlight next', async () => {\n        await provider.startQuery(/test\\d/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        let replaced = await provider.replaceCurrentMatch('bar');\n        expect(replaced).toBe(true);\n        const source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('bar test2');\n        expect(provider.currentMatchIndex).toBe(0);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should substitute groups in regular expressions",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 217,
                "column": 57
            },
            "line": 217,
            "code": "      it('should substitute groups in regular expressions', async () => {\n        await provider.startQuery(/test(\\d)/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        await provider.highlightNext();\n        expect(provider.currentMatchIndex).toBe(1);\n        let replaced = await provider.replaceCurrentMatch(\n          '$1st_bar (was $&)',\n          false,\n          { regularExpression: true }\n        );\n        expect(replaced).toBe(true);\n        const source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('test1 2st_bar (was test2)');\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not substitute if regular expression toggle is off",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 232,
                "column": 67
            },
            "line": 232,
            "code": "      it('should not substitute if regular expression toggle is off', async () => {\n        await provider.startQuery(/test(\\d)/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        let replaced = await provider.replaceCurrentMatch(\n          '$1st_bar (was $&)',\n          false,\n          { regularExpression: false }\n        );\n        expect(replaced).toBe(true);\n        const source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('$1st_bar (was $&) test2');\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should replace with a longer text and highlight next",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceCurrentMatch()"
            ],
            "updatePoint": {
                "line": 245,
                "column": 62
            },
            "line": 245,
            "code": "      it('should replace with a longer text and highlight next', async () => {\n        await provider.startQuery(/test\\d/, undefined);\n        expect(provider.currentMatchIndex).toBe(0);\n        let replaced = await provider.replaceCurrentMatch('rabarbar');\n        expect(replaced).toBe(true);\n        let source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('rabarbar test2');\n        expect(provider.currentMatchIndex).toBe(0);\n\n        replaced = await provider.replaceCurrentMatch('rabarbar');\n        expect(replaced).toBe(true);\n        source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('rabarbar rabarbar');\n        expect(provider.currentMatchIndex).toBe(0);\n\n        replaced = await provider.replaceCurrentMatch('rabarbar');\n        expect(replaced).toBe(true);\n        source = panel.model!.cells.get(1).sharedModel.getSource();\n        expect(source).toBe('rabarbar');\n        expect(provider.currentMatchIndex).toBe(null);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should replace all occurrences across cells",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceAllMatches()"
            ],
            "updatePoint": {
                "line": 269,
                "column": 53
            },
            "line": 269,
            "code": "      it('should replace all occurrences across cells', async () => {\n        await provider.startQuery(/test\\d/, undefined);\n        await provider.highlightNext();\n        const replaced = await provider.replaceAllMatches('test0');\n        expect(replaced).toBe(true);\n        let source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('test0 test0');\n        source = panel.model!.cells.get(1).sharedModel.getSource();\n        expect(source).toBe('test0');\n        expect(provider.currentMatchIndex).toBe(null);\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should only replace within first cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceAllMatches()"
            ],
            "updatePoint": {
                "line": 281,
                "column": 47
            },
            "line": 281,
            "code": "      it('should only replace within first cell', async () => {\n        await provider.startQuery(/test/, { selection: true });\n        panel.content.mode = 'command';\n        panel.content.activeCellIndex = 0;\n        await provider.cellChangeHandled;\n        expect(provider.currentMatchIndex).toBe(0);\n        const replaced = await provider.replaceAllMatches('bar');\n        expect(replaced).toBe(true);\n        let source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('bar1 bar2');\n        source = panel.model!.cells.get(1).sharedModel.getSource();\n        expect(source).toBe('test3');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should only replace within second cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceAllMatches()"
            ],
            "updatePoint": {
                "line": 296,
                "column": 48
            },
            "line": 296,
            "code": "      it('should only replace within second cell', async () => {\n        await provider.startQuery(/test/, { selection: true });\n        panel.content.mode = 'command';\n        panel.content.activeCellIndex = 1;\n        await provider.cellChangeHandled;\n        const replaced = await provider.replaceAllMatches('bar');\n        expect(replaced).toBe(true);\n        let source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('test1 test2');\n        source = panel.model!.cells.get(1).sharedModel.getSource();\n        expect(source).toBe('bar3');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should only replace within selected lines",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookSearchProvider",
                "#replaceAllMatches()"
            ],
            "updatePoint": {
                "line": 310,
                "column": 51
            },
            "line": 310,
            "code": "      it('should only replace within selected lines', async () => {\n        panel.model!.sharedModel.deleteCellRange(0, 2);\n        panel.model!.sharedModel.insertCells(0, [\n          { cell_type: 'code', source: 'test1\\ntest2\\ntest3\\ntest4\\ntest5' }\n        ]);\n        panel.content.activeCellIndex = 0;\n        panel.content.mode = 'edit';\n\n        await provider.startQuery(/test/, { selection: true });\n        await setSelections(panel.content.activeCell!.editor!, [\n          {\n            uuid: 'main-selection',\n            start: { line: 1, column: 0 },\n            end: { line: 2, column: 6 }\n          }\n        ]);\n        const replaced = await provider.replaceAllMatches('bar');\n        expect(replaced).toBe(true);\n        let source = panel.model!.cells.get(0).sharedModel.getSource();\n        expect(source).toBe('test1\\nbar2\\nbar3\\nbar4\\ntest5');\n        await provider.endQuery();\n      });",
            "file": "searchprovider.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a NotebookTracker",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 41
            },
            "line": 49,
            "code": "      it('should create a NotebookTracker', () => {\n        const tracker = new NotebookTracker({ namespace });\n        expect(tracker).toBeInstanceOf(NotebookTracker);\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be `null` if there is no tracked notebook panel",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#activeCell"
            ],
            "updatePoint": {
                "line": 56,
                "column": 64
            },
            "line": 56,
            "code": "      it('should be `null` if there is no tracked notebook panel', () => {\n        const tracker = new NotebookTracker({ namespace });\n        expect(tracker.activeCell).toBeNull();\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be `null` if a tracked notebook has no active cell",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#activeCell"
            ],
            "updatePoint": {
                "line": 61,
                "column": 67
            },
            "line": 61,
            "code": "      it('should be `null` if a tracked notebook has no active cell', () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        panel.content.model!.sharedModel.clearUndoHistory();\n        void tracker.add(panel);\n        expect(tracker.activeCell).toBeNull();\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the active cell if a tracked notebook has one",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#activeCell"
            ],
            "updatePoint": {
                "line": 69,
                "column": 65
            },
            "line": 69,
            "code": "      it('should be the active cell if a tracked notebook has one', async () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        await tracker.add(panel);\n        panel.content.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(tracker.activeCell).toBeInstanceOf(Cell);\n        panel.dispose();\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit a signal when the active cell changes",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#activeCellChanged"
            ],
            "updatePoint": {
                "line": 80,
                "column": 59
            },
            "line": 80,
            "code": "      it('should emit a signal when the active cell changes', async () => {\n        const tracker = new NotebookTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        let count = 0;\n        tracker.activeCellChanged.connect(() => {\n          count++;\n        });\n        panel.content.model!.fromJSON(utils.DEFAULT_CONTENT);\n        await tracker.add(panel);\n        expect(count).toBe(1);\n        panel.content.activeCellIndex = 1;\n        expect(count).toBe(2);\n        panel.dispose();\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the active cell changes",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookTracker",
                "#onCurrentChanged()"
            ],
            "updatePoint": {
                "line": 97,
                "column": 55
            },
            "line": 97,
            "code": "      it('should be called when the active cell changes', async () => {\n        const tracker = new TestTracker({ namespace });\n        const panel = utils.createNotebookPanel(context);\n        await tracker.add(panel);\n        expect(tracker.methods).toEqual(\n          expect.arrayContaining(['onCurrentChanged'])\n        );\n      });",
            "file": "tracker.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebook widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 157,
                "column": 41
            },
            "line": 157,
            "code": "      it('should create a notebook widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget).toBeInstanceOf(StaticNotebook);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add the `jp-Notebook` class",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 162,
                "column": 44
            },
            "line": 162,
            "code": "      it('should add the `jp-Notebook` class', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.hasClass('jp-Notebook')).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept an optional render",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 167,
                "column": 42
            },
            "line": 167,
            "code": "      it('should accept an optional render', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.contentFactory).toBe(contentFactory);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept an optional editor config",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 49
            },
            "line": 172,
            "code": "      it('should accept an optional editor config', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.editorConfig).toBe(editorConfig);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when the model changes",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#modelChanged"
            ],
            "updatePoint": {
                "line": 179,
                "column": 50
            },
            "line": 179,
            "code": "      it('should be emitted when the model changes', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        let called = false;\n        widget.modelChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        widget.model = model;\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when a cell is added",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#modelContentChanged"
            ],
            "updatePoint": {
                "line": 194,
                "column": 48
            },
            "line": 194,
            "code": "      it('should be emitted when a cell is added', () => {\n        const widget = new StaticNotebook(options);\n        widget.model = new NotebookModel();\n        let called = false;\n        widget.modelContentChanged.connect(() => {\n          called = true;\n        });\n        widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when metadata is set",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#modelContentChanged"
            ],
            "updatePoint": {
                "line": 205,
                "column": 48
            },
            "line": 205,
            "code": "      it('should be emitted when metadata is set', () => {\n        const widget = new StaticNotebook(options);\n        widget.model = new NotebookModel();\n        let called = false;\n        widget.modelContentChanged.connect(() => {\n          called = true;\n        });\n        widget.model!.setMetadata('foo', 1);\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the model for the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 218,
                "column": 45
            },
            "line": 218,
            "code": "      it('should get the model for the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.model).toBeNull();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the model for the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 223,
                "column": 45
            },
            "line": 223,
            "code": "      it('should set the model for the widget', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        expect(widget.model).toBe(model);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `modelChanged` signal",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 230,
                "column": 47
            },
            "line": 230,
            "code": "      it('should emit the `modelChanged` signal', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        let called = false;\n        widget.modelChanged.connect(() => {\n          called = true;\n        });\n        widget.model = new NotebookModel();\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if the value does not change",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 242,
                "column": 56
            },
            "line": 242,
            "code": "      it('should be a no-op if the value does not change', () => {\n        const widget = new StaticNotebook(options);\n        const model = new NotebookModel();\n        widget.model = model;\n        let called = false;\n        widget.modelChanged.connect(() => {\n          called = true;\n        });\n        widget.model = model;\n        expect(called).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add the model cells to the layout",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 254,
                "column": 50
            },
            "line": 254,
            "code": "      it('should add the model cells to the layout', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        model.fromJSON(utils.DEFAULT_CONTENT);\n        widget.model = model;\n        expect(widget.widgets.length).toBe(model.cells.length);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add a default cell if the notebook model is empty",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 262,
                "column": 66
            },
            "line": 262,
            "code": "      it('should add a default cell if the notebook model is empty', () => {\n        const widget = new LogStaticNotebook(options);\n        const model1 = new NotebookModel();\n        expect(model1.cells.length).toBe(0);\n\n        widget.model = model1;\n        expect(model1.cells.length).toBe(1);\n        expect(model1.cells.get(0).type).toBe('code');\n\n        widget.notebookConfig = {\n          ...widget.notebookConfig,\n          defaultCell: 'markdown'\n        };\n        const model2 = new NotebookModel({\n          defaultCell: 'markdown'\n        });\n        expect(model2.cells.length).toBe(0);\n\n        widget.model = model2;\n        expect(model2.cells.length).toBe(1);\n        expect(model2.cells.get(0).type).toBe('markdown');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the mime types of the cell widgets",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model"
            ],
            "updatePoint": {
                "line": 285,
                "column": 55
            },
            "line": 285,
            "code": "      it('should set the mime types of the cell widgets', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        model.setMetadata('language_info', value);\n        widget.model = model;\n        const child = widget.widgets[0];\n        expect(child.model.mimeType).toBe('text/x-python');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle changes to the model cell list",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 307,
                "column": 56
            },
            "line": 307,
            "code": "        it('should handle changes to the model cell list', async () => {\n          widget = createWidget();\n          widget.model!.sharedModel.insertCell(\n            widget.model!.sharedModel.cells.length,\n            { cell_type: 'code' }\n          );\n          await framePromise();\n          expect(widget.widgets.length).toBe(2);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle a remove",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 317,
                "column": 34
            },
            "line": 317,
            "code": "        it('should handle a remove', () => {\n          const cell = widget.model!.cells.get(1);\n          const child = widget.widgets[1];\n          widget.model!.sharedModel.deleteCell(1);\n          expect(cell.isDisposed).toBe(true);\n          expect(child.isDisposed).toBe(true);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle an add",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 325,
                "column": 32
            },
            "line": 325,
            "code": "        it('should handle an add', () => {\n          widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });\n          expect(widget.widgets.length).toBe(widget.model!.cells.length);\n          const child = widget.widgets[0];\n          expect(child.hasClass('jp-Notebook-cell')).toBe(true);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should initially render markdown cells with content",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 332,
                "column": 63
            },
            "line": 332,
            "code": "        it('should initially render markdown cells with content', () => {\n          widget.model!.sharedModel.insertCells(0, [\n            { cell_type: 'markdown', source: '# Hello' },\n            { cell_type: 'markdown' }\n          ]);\n          expect(widget.widgets.length).toBe(widget.model!.cells.length);\n          const child1 = widget.widgets[0] as MarkdownCell;\n          const child2 = widget.widgets[1] as MarkdownCell;\n          expect(child1.rendered).toBe(true);\n          expect(child2.rendered).toBe(false);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle a move",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 344,
                "column": 32
            },
            "line": 344,
            "code": "        it('should handle a move', () => {\n          const child = widget.widgets[1];\n          widget.model!.sharedModel.moveCell(1, 2);\n          expect(widget.widgets[2].id).toBe(child.id);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should handle a clear",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#model",
                "`cells.changed` signal"
            ],
            "updatePoint": {
                "line": 350,
                "column": 33
            },
            "line": 350,
            "code": "        it('should handle a clear', () => {\n          widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });\n          widget.model!.sharedModel.deleteCellRange(\n            0,\n            widget.model!.sharedModel.cells.length\n          );\n          expect(widget.widgets.length).toBe(0);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the rendermime instance used by the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 362,
                "column": 62
            },
            "line": 362,
            "code": "      it('should be the rendermime instance used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.rendermime).toBe(rendermime);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the cell widget contentFactory used by the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#contentFactory"
            ],
            "updatePoint": {
                "line": 369,
                "column": 69
            },
            "line": 369,
            "code": "      it('should be the cell widget contentFactory used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.contentFactory).toBeInstanceOf(\n          StaticNotebook.ContentFactory\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the cell widget contentFactory used by the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#editorConfig"
            ],
            "updatePoint": {
                "line": 378,
                "column": 69
            },
            "line": 378,
            "code": "      it('should be the cell widget contentFactory used by the widget', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.editorConfig).toBe(options.editorConfig);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#editorConfig"
            ],
            "updatePoint": {
                "line": 383,
                "column": 28
            },
            "line": 383,
            "code": "      it('should be settable', () => {\n        const widget = createWidget();\n        expect(widget.widgets[0].editor!.getOption('autoClosingBrackets')).toBe(\n          false\n        );\n        const newConfig = {\n          raw: editorConfig.raw,\n          markdown: editorConfig.markdown,\n          code: {\n            ...editorConfig.code,\n            autoClosingBrackets: true\n          }\n        };\n        widget.editorConfig = newConfig;\n        expect(widget.widgets[0].editor!.getOption('autoClosingBrackets')).toBe(\n          true\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the mime type for code cells",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#codeMimetype"
            ],
            "updatePoint": {
                "line": 404,
                "column": 49
            },
            "line": 404,
            "code": "      it('should get the mime type for code cells', () => {\n        const widget = new StaticNotebook(options);\n        expect(widget.codeMimetype).toBe('text/plain');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be set from language metadata",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#codeMimetype"
            ],
            "updatePoint": {
                "line": 409,
                "column": 46
            },
            "line": 409,
            "code": "      it('should be set from language metadata', () => {\n        const widget = new LogStaticNotebook(options);\n        const model = new NotebookModel();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        model.setMetadata('language_info', value);\n        widget.model = model;\n        expect(widget.codeMimetype).toBe('text/x-python');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the child widget at a specified index",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#widgets"
            ],
            "updatePoint": {
                "line": 420,
                "column": 58
            },
            "line": 420,
            "code": "      it('should get the child widget at a specified index', () => {\n        const widget = createWidget();\n        const child = widget.widgets[0];\n        expect(child).toBeInstanceOf(CodeCell);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should return `undefined` if out of range",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#widgets"
            ],
            "updatePoint": {
                "line": 426,
                "column": 51
            },
            "line": 426,
            "code": "      it('should return `undefined` if out of range', () => {\n        const widget = createWidget();\n        const child = widget.widgets[1];\n        expect(child).toBeUndefined();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the number of child widgets",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#widgets"
            ],
            "updatePoint": {
                "line": 432,
                "column": 48
            },
            "line": 432,
            "code": "      it('should get the number of child widgets', () => {\n        const widget = createWidget();\n        expect(widget.widgets.length).toBe(1);\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.widgets.length).toBe(utils.DEFAULT_CONTENT.cells.length);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should dispose of the resources held by the widget",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 441,
                "column": 60
            },
            "line": 441,
            "code": "      it('should dispose of the resources held by the widget', () => {\n        const widget = createWidget();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 447,
                "column": 47
            },
            "line": 447,
            "code": "      it('should be safe to call multiple times', () => {\n        const widget = createWidget();\n        widget.dispose();\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the model changes",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 456,
                "column": 49
            },
            "line": 456,
            "code": "      it('should be called when the model changes', () => {\n        const widget = new LogStaticNotebook(options);\n        widget.model = new NotebookModel();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not be called if the model does not change",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 464,
                "column": 59
            },
            "line": 464,
            "code": "      it('should not be called if the model does not change', () => {\n        const widget = createWidget();\n        widget.methods = [];\n        widget.model = widget.model; // eslint-disable-line\n        expect(widget.methods).toEqual(\n          expect.not.arrayContaining(['onModelChanged'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when the metadata on the notebook changes",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onMetadataChanged()"
            ],
            "updatePoint": {
                "line": 475,
                "column": 68
            },
            "line": 475,
            "code": "      it('should be called when the metadata on the notebook changes', () => {\n        const widget = createWidget();\n        widget.model!.setMetadata('foo', 1);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should update the `codeMimetype`",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onMetadataChanged()"
            ],
            "updatePoint": {
                "line": 483,
                "column": 42
            },
            "line": 483,
            "code": "      it('should update the `codeMimetype`', () => {\n        const widget = createWidget();\n        const value = { name: 'python', codemirror_mode: 'python' };\n        widget.model!.setMetadata('language_info', value);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n        expect(widget.codeMimetype).toBe('text/x-python');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should update the cell widget mimetype",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onMetadataChanged()"
            ],
            "updatePoint": {
                "line": 493,
                "column": 48
            },
            "line": 493,
            "code": "      it('should update the cell widget mimetype', () => {\n        const widget = createWidget();\n        const value = { name: 'python', mimetype: 'text/x-python' };\n        widget.model!.setMetadata('language_info', value);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onMetadataChanged'])\n        );\n        const child = widget.widgets[0];\n        expect(child.model.mimeType).toBe('text/x-python');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when a cell is inserted",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onCellInserted()"
            ],
            "updatePoint": {
                "line": 506,
                "column": 50
            },
            "line": 506,
            "code": "      it('should be called when a cell is inserted', () => {\n        const widget = createWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellInserted'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be called when a cell is removed",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                "#onCellRemoved()"
            ],
            "updatePoint": {
                "line": 516,
                "column": 49
            },
            "line": 516,
            "code": "      it('should be called when a cell is removed', () => {\n        const widget = createWidget();\n        widget.model!.sharedModel.deleteCell(0);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellRemoved'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new ContentFactory",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                ".ContentFactory",
                "#constructor"
            ],
            "updatePoint": {
                "line": 527,
                "column": 46
            },
            "line": 527,
            "code": "        it('should create a new ContentFactory', () => {\n          const editorFactory = utils.editorFactory;\n          const factory = new StaticNotebook.ContentFactory({ editorFactory });\n          expect(factory).toBeInstanceOf(StaticNotebook.ContentFactory);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a `CodeCell`",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                ".ContentFactory",
                "#createCodeCell({})"
            ],
            "updatePoint": {
                "line": 535,
                "column": 38
            },
            "line": 535,
            "code": "        it('should create a `CodeCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory({\n            editorFactory: utils.editorFactory\n          });\n          const model = new CodeCellModel();\n          const codeOptions = { model, rendermime, contentFactory };\n          const widget = contentFactory.createCodeCell(codeOptions);\n          expect(widget).toBeInstanceOf(CodeCell);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a `MarkdownCell`",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                ".ContentFactory",
                "#createMarkdownCell({})"
            ],
            "updatePoint": {
                "line": 547,
                "column": 42
            },
            "line": 547,
            "code": "        it('should create a `MarkdownCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory({\n            editorFactory: utils.editorFactory\n          });\n          const model = new MarkdownCellModel();\n          const mdOptions = { model, rendermime, contentFactory };\n          const widget = contentFactory.createMarkdownCell(mdOptions);\n          expect(widget).toBeInstanceOf(MarkdownCell);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a `RawCell`",
            "suites": [
                "@jupyter/notebook",
                "StaticNotebook",
                ".ContentFactory",
                "#createRawCell()"
            ],
            "updatePoint": {
                "line": 559,
                "column": 37
            },
            "line": 559,
            "code": "        it('should create a `RawCell`', () => {\n          const contentFactory = new StaticNotebook.ContentFactory({\n            editorFactory: utils.editorFactory\n          });\n          const model = new RawCellModel();\n          const rawOptions = { model, contentFactory };\n          const widget = contentFactory.createRawCell(rawOptions);\n          expect(widget).toBeInstanceOf(RawCell);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when the state of the notebook changes",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 574,
                "column": 66
            },
            "line": 574,
            "code": "      it('should be emitted when the state of the notebook changes', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('mode');\n          expect(args.oldValue).toBe('command');\n          expect(args.newValue).toBe('edit');\n          called = true;\n        });\n        widget.mode = 'edit';\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when the active cell changes",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellChanged"
            ],
            "updatePoint": {
                "line": 590,
                "column": 56
            },
            "line": 590,
            "code": "      it('should be emitted when the active cell changes', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.activeCellChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBe(widget.activeCell);\n          called = true;\n        });\n        widget.activeCellIndex++;\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not be emitted when the active cell does not change",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellChanged"
            ],
            "updatePoint": {
                "line": 603,
                "column": 68
            },
            "line": 603,
            "code": "      it('should not be emitted when the active cell does not change', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.activeCellChanged.connect(() => {\n          called = true;\n        });\n        widget.activeCellIndex = widget.activeCellIndex; // eslint-disable-line\n        expect(called).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be emitted when the selection changes",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#selectionChanged"
            ],
            "updatePoint": {
                "line": 616,
                "column": 54
            },
            "line": 616,
            "code": "      it('should be emitted when the selection changes', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.selectionChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args).toBeUndefined();\n          called = true;\n        });\n        widget.select(widget.widgets[1]);\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not be emitted when the selection does not change",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#selectionChanged"
            ],
            "updatePoint": {
                "line": 629,
                "column": 66
            },
            "line": 629,
            "code": "      it('should not be emitted when the selection does not change', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        let called = false;\n        widget.select(widget.widgets[1]);\n        widget.selectionChanged.connect(() => {\n          called = true;\n        });\n        widget.select(widget.widgets[1]);\n        expect(called).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the interactivity mode of the notebook",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 643,
                "column": 59
            },
            "line": 643,
            "code": "      it('should get the interactivity mode of the notebook', () => {\n        const widget = createActiveWidget();\n        expect(widget.mode).toBe('command');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the interactivity mode of the notebook",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 648,
                "column": 59
            },
            "line": 648,
            "code": "      it('should set the interactivity mode of the notebook', () => {\n        const widget = createActiveWidget();\n        widget.mode = 'edit';\n        expect(widget.mode).toBe('edit');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `stateChanged` signal",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 654,
                "column": 47
            },
            "line": 654,
            "code": "      it('should emit the `stateChanged` signal', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('mode');\n          expect(args.oldValue).toBe('command');\n          expect(args.newValue).toBe('edit');\n          called = true;\n        });\n        widget.mode = 'edit';\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if the value does not change",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 668,
                "column": 56
            },
            "line": 668,
            "code": "      it('should be a no-op if the value does not change', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.stateChanged.connect(() => {\n          called = true;\n        });\n        widget.mode = 'command';\n        expect(called).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 678,
                "column": 39
            },
            "line": 678,
            "code": "      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.mode = 'edit';\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deselect all cells if switching to edit mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 687,
                "column": 61
            },
            "line": 687,
            "code": "      it('should deselect all cells if switching to edit mode', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        widget.extendContiguousSelectionTo(widget.widgets.length - 1);\n        const selectedRange = Array.from(Array(widget.widgets.length).keys());\n        expect(selected(widget)).toEqual(selectedRange);\n        widget.mode = 'edit';\n        expect(selected(widget)).toEqual([]);\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should unrender a markdown cell when switching to edit mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#mode"
            ],
            "updatePoint": {
                "line": 700,
                "column": 69
            },
            "line": 700,
            "code": "      it('should unrender a markdown cell when switching to edit mode', () => {\n        const widget = createActiveWidget();\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        widget.model!.sharedModel.insertCell(0, {\n          cell_type: 'markdown',\n          source: '# Hello'\n        }); // Should be rendered with content.\n        const child = widget.widgets[0] as MarkdownCell;\n        expect(child.rendered).toBe(true);\n        widget.activeCellIndex = 0;\n        widget.mode = 'edit';\n        expect(child.rendered).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the active cell index of the notebook",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 717,
                "column": 58
            },
            "line": 717,
            "code": "      it('should get the active cell index of the notebook', () => {\n        const widget = createActiveWidget();\n        expect(widget.activeCellIndex).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the active cell index of the notebook",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 722,
                "column": 58
            },
            "line": 722,
            "code": "      it('should set the active cell index of the notebook', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        expect(widget.activeCellIndex).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clamp the index to the bounds of the notebook cells",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 729,
                "column": 68
            },
            "line": 729,
            "code": "      it('should clamp the index to the bounds of the notebook cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = -2;\n        expect(widget.activeCellIndex).toBe(0);\n        widget.activeCellIndex = 100;\n        expect(widget.activeCellIndex).toBe(widget.model!.cells.length - 1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should emit the `stateChanged` signal",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 738,
                "column": 47
            },
            "line": 738,
            "code": "      it('should emit the `stateChanged` signal', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(widget);\n          expect(args.name).toBe('activeCellIndex');\n          expect(args.oldValue).toBe(0);\n          expect(args.newValue).toBe(1);\n          called = true;\n        });\n        widget.activeCellIndex = 1;\n        expect(called).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if the value does not change",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 753,
                "column": 56
            },
            "line": 753,
            "code": "      it('should be a no-op if the value does not change', () => {\n        const widget = createActiveWidget();\n        let called = false;\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.stateChanged.connect(() => {\n          called = true;\n        });\n        widget.activeCellIndex = 0;\n        expect(called).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 764,
                "column": 39
            },
            "line": 764,
            "code": "      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        widget.activeCellIndex = 1;\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should update the active cell if necessary",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCellIndex"
            ],
            "updatePoint": {
                "line": 774,
                "column": 52
            },
            "line": 774,
            "code": "      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        expect(widget.activeCell).toBe(widget.widgets[1]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get the active cell widget",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#activeCell"
            ],
            "updatePoint": {
                "line": 783,
                "column": 43
            },
            "line": 783,
            "code": "      it('should get the active cell widget', () => {\n        const widget = createActiveWidget();\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should select a cell widget",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#select()"
            ],
            "updatePoint": {
                "line": 790,
                "column": 37
            },
            "line": 790,
            "code": "      it('should select a cell widget', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = widget.widgets[0];\n        widget.select(cell);\n        expect(widget.isSelected(cell)).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should allow multiple widgets to be selected",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#select()"
            ],
            "updatePoint": {
                "line": 798,
                "column": 54
            },
            "line": 798,
            "code": "      it('should allow multiple widgets to be selected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.widgets.forEach(cell => {\n          widget.select(cell);\n        });\n        const expectSelected = Array.from(Array(widget.widgets.length).keys());\n        expect(selected(widget)).toEqual(expectSelected);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deselect a cell",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#deselect()"
            ],
            "updatePoint": {
                "line": 810,
                "column": 32
            },
            "line": 810,
            "code": "      it('should deselect a cell', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        for (let i = 0; i < widget.widgets.length; i++) {\n          const cell = widget.widgets[i];\n          widget.select(cell);\n          expect(widget.isSelected(cell)).toBe(true);\n          widget.deselect(cell);\n          expect(widget.isSelected(cell)).toBe(false);\n        }\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should const the active cell be deselected",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#deselect()"
            ],
            "updatePoint": {
                "line": 822,
                "column": 52
            },
            "line": 822,
            "code": "      it('should const the active cell be deselected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        const cell = widget.activeCell!;\n        widget.select(cell);\n        expect(widget.isSelected(cell)).toBe(true);\n        widget.deselect(cell);\n        expect(widget.isSelected(cell)).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get whether the cell is selected",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#isSelected()"
            ],
            "updatePoint": {
                "line": 834,
                "column": 49
            },
            "line": 834,
            "code": "      it('should get whether the cell is selected', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.select(widget.widgets[0]);\n        widget.select(widget.widgets[2]);\n        expect(selected(widget)).toEqual([0, 2]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "reports selection whether or not cell is active",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#isSelected()"
            ],
            "updatePoint": {
                "line": 842,
                "column": 57
            },
            "line": 842,
            "code": "      it('reports selection whether or not cell is active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(selected(widget)).toEqual([]);\n        widget.select(widget.activeCell!);\n        expect(selected(widget)).toEqual([widget.activeCellIndex]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should deselect all cells",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#deselectAll()"
            ],
            "updatePoint": {
                "line": 852,
                "column": 35
            },
            "line": 852,
            "code": "      it('should deselect all cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.select(widget.widgets[0]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.select(widget.widgets[4]);\n        expect(selected(widget)).toEqual([0, 2, 3, 4]);\n        widget.deselectAll();\n        expect(selected(widget)).toEqual([]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should work in each permutation of anchor, head, and index",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 967,
                "column": 68
            },
            "line": 967,
            "code": "      it('should work in each permutation of anchor, head, and index', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], p[2]);\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should work when we only have an active cell, with no existing selection",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 978,
                "column": 82
            },
            "line": 978,
            "code": "      it('should work when we only have an active cell, with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(widget, p[0], p[1], p[2], false);\n            }\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clip when the index is greater than the last index",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 991,
                "column": 67
            },
            "line": 991,
            "code": "      it('should clip when the index is greater than the last index', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], Number.MAX_SAFE_INTEGER);\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clip when the index is greater than the last index with no existing selection",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 1002,
                "column": 94
            },
            "line": 1002,
            "code": "      it('should clip when the index is greater than the last index with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(\n                widget,\n                p[0],\n                p[1],\n                Number.MAX_SAFE_INTEGER,\n                false\n              );\n            }\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clip when the index is less than 0",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 1021,
                "column": 51
            },
            "line": 1021,
            "code": "      it('should clip when the index is less than 0', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            checkSelection(widget, p[0], p[1], -10);\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clip when the index is less than 0 with no existing selection",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 1032,
                "column": 78
            },
            "line": 1032,
            "code": "      it('should clip when the index is less than 0 with no existing selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        expect(() => {\n          permutations.forEach(p => {\n            if (p[0] === p[1]) {\n              checkSelection(widget, p[0], p[1], -10, false);\n            }\n          });\n        }).not.toThrow();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "handles the case of no cells",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#extendContiguousSelectionTo()"
            ],
            "updatePoint": {
                "line": 1045,
                "column": 38
            },
            "line": 1045,
            "code": "      it('handles the case of no cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.sharedModel.deleteCellRange(\n          0,\n          widget.model!.sharedModel.cells.length\n        );\n        expect(widget.widgets.length).toBe(0);\n\n        // Set up a selection event listener.\n        let selectionChanged = 0;\n        widget.selectionChanged.connect((sender, args) => {\n          selectionChanged += 1;\n        });\n\n        widget.extendContiguousSelectionTo(3);\n\n        expect(widget.activeCellIndex).toBe(-1);\n        expect(selectionChanged).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "throws an error when the selection is not contiguous",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1067,
                "column": 62
            },
            "line": 1067,
            "code": "      it('throws an error when the selection is not contiguous', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        expect(() => widget.getContiguousSelection()).toThrow(\n          /Selection not contiguous/\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "throws an error if the active cell is not at an endpoint",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1080,
                "column": 66
            },
            "line": 1080,
            "code": "      it('throws an error if the active cell is not at an endpoint', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n\n        // Check if active cell is outside selection.\n        widget.activeCellIndex = 0;\n        expect(() => widget.getContiguousSelection()).toThrow(\n          /Active cell not at endpoint of selection/\n        );\n\n        // Check if active cell is inside selection.\n        widget.activeCellIndex = 2;\n        expect(() => widget.getContiguousSelection()).toThrow(\n          /Active cell not at endpoint of selection/\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "returns null values if there is no selection",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1101,
                "column": 54
            },
            "line": 1101,
            "code": "      it('returns null values if there is no selection', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: null, anchor: null });\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "handles the case of no cells",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1109,
                "column": 38
            },
            "line": 1109,
            "code": "      it('handles the case of no cells', () => {\n        const widget = createActiveWidget();\n        widget.model!.sharedModel.deleteCellRange(\n          0,\n          widget.model!.sharedModel.cells.length\n        );\n        expect(widget.widgets.length).toBe(0);\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: null, anchor: null });\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "works if head is before the anchor",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1121,
                "column": 44
            },
            "line": 1121,
            "code": "      it('works if head is before the anchor', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 1;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 1, anchor: 3 });\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "works if head is after the anchor",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1134,
                "column": 43
            },
            "line": 1134,
            "code": "      it('works if head is after the anchor', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[1]);\n        widget.select(widget.widgets[2]);\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 3, anchor: 1 });\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "works if head and anchor are the same",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#getContiguousSelection()"
            ],
            "updatePoint": {
                "line": 1147,
                "column": 47
            },
            "line": 1147,
            "code": "      it('works if head and anchor are the same', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n\n        widget.select(widget.widgets[3]);\n        widget.activeCellIndex = 3;\n\n        const selection = widget.getContiguousSelection();\n        expect(selection).toEqual({ head: 3, anchor: 3 });\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the active cell index",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1174,
                "column": 44
            },
            "line": 1174,
            "code": "        it('should set the active cell index', () => {\n          const child = widget.widgets[1];\n          simulate(child.node, 'mousedown');\n          expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n          expect(widget.isSelected(widget.widgets[0])).toBe(false);\n          expect(widget.activeCellIndex).toBe(1);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be a no-op if not not a cell",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1182,
                "column": 47
            },
            "line": 1182,
            "code": "        it('should be a no-op if not not a cell', () => {\n          simulate(widget.node, 'mousedown');\n          expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n          expect(widget.activeCellIndex).toBe(0);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should preserve \"command\" mode if in a markdown cell",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1188,
                "column": 64
            },
            "line": 1188,
            "code": "        it('should preserve \"command\" mode if in a markdown cell', async () => {\n          widget.model!.sharedModel.insertCell(0, {\n            cell_type: 'markdown',\n            source: '# Hello'\n          });\n          const child = widget.widgets[0] as MarkdownCell;\n          if (!child.inViewport) {\n            await signalToPromise(child.inViewportChanged);\n          }\n          expect(child.rendered).toBe(true);\n          simulate(child.node, 'mousedown');\n          expect(child.rendered).toBe(true);\n          expect(widget.activeCell).toBe(child);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should extend selection if invoked with shift",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1203,
                "column": 57
            },
            "line": 1203,
            "code": "        it('should extend selection if invoked with shift', () => {\n          widget.activeCellIndex = 3;\n\n          // shift click below\n          simulate(widget.widgets[4].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(4);\n          expect(selected(widget)).toEqual([3, 4]);\n\n          // shift click above\n          simulate(widget.widgets[1].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(1);\n          expect(selected(widget)).toEqual([1, 2, 3]);\n\n          // shift click expand\n          simulate(widget.widgets[0].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(0);\n          expect(selected(widget)).toEqual([0, 1, 2, 3]);\n\n          // shift click contract\n          simulate(widget.widgets[2].node, 'mousedown', { shiftKey: true });\n          expect(widget.activeCellIndex).toBe(2);\n          expect(selected(widget)).toEqual([2, 3]);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should not extend a selection if there is text selected in the output",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1227,
                "column": 81
            },
            "line": 1227,
            "code": "        it('should not extend a selection if there is text selected in the output', () => {\n          const codeCellIndex = 3;\n          widget.activeCellIndex = codeCellIndex;\n\n          // Set a selection in the active cell outputs.\n          const selection = window.getSelection()!;\n          selection.selectAllChildren(\n            (widget.activeCell as CodeCell).outputArea.node\n          );\n\n          // Shift click below, which should not extend cells selection.\n          simulate(widget.widgets[codeCellIndex + 2].node, 'mousedown', {\n            shiftKey: true\n          });\n          expect(widget.activeCellIndex).toBe(codeCellIndex);\n          expect(selected(widget)).toEqual([]);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should leave a markdown cell rendered",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1245,
                "column": 49
            },
            "line": 1245,
            "code": "        it('should leave a markdown cell rendered', async () => {\n          widget.model!.sharedModel.insertCells(0, [\n            { cell_type: 'code' },\n            { cell_type: 'markdown', source: '# Hello' }\n          ]);\n          const codeChild = widget.widgets[0];\n          const mdChild = widget.widgets[1] as MarkdownCell;\n          if (!codeChild.inViewport) {\n            await signalToPromise(codeChild.inViewportChanged);\n          }\n          if (!mdChild.inViewport) {\n            await signalToPromise(mdChild.inViewportChanged);\n          }\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = 0;\n          expect(mdChild.rendered).toBe(true);\n          simulate(codeChild.editorWidget!.node, 'mousedown');\n          simulate(codeChild.editorWidget!.node, 'focusin');\n          expect(mdChild.rendered).toBe(true);\n          expect(widget.activeCell).toBe(codeChild);\n          expect(widget.mode).toBe('edit');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should remove selection and switch to command mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1269,
                "column": 62
            },
            "line": 1269,
            "code": "        it('should remove selection and switch to command mode', async () => {\n          widget.model!.sharedModel.insertCells(0, [\n            { cell_type: 'code' },\n            { cell_type: 'markdown', source: '# Hello' }\n          ]);\n          const codeChild = widget.widgets[0];\n          const mdChild = widget.widgets[1] as MarkdownCell;\n          if (!codeChild.inViewport) {\n            await signalToPromise(codeChild.inViewportChanged);\n          }\n          if (!mdChild.inViewport) {\n            await signalToPromise(mdChild.inViewportChanged);\n          }\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = 0;\n          simulate(codeChild.editorWidget!.node, 'mousedown');\n          simulate(codeChild.editorWidget!.node, 'focusin');\n          expect(widget.mode).toBe('edit');\n          simulate(codeChild.editorWidget!.node, 'mousedown', { button: 2 });\n          expect(widget.isSelected(mdChild)).toBe(false);\n          expect(widget.mode).toBe('command');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should have no effect on shift right click",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "mousedown"
            ],
            "updatePoint": {
                "line": 1293,
                "column": 54
            },
            "line": 1293,
            "code": "        it('should have no effect on shift right click', () => {\n          widget.model!.sharedModel.insertCells(0, [\n            { cell_type: 'code' },\n            { cell_type: 'markdown', source: '# Hello' }\n          ]);\n          const codeChild = widget.widgets[0];\n          const mdChild = widget.widgets[1] as MarkdownCell;\n          widget.select(codeChild);\n          widget.select(mdChild);\n          widget.activeCellIndex = 0;\n          simulate(codeChild.editorWidget!.node, 'mousedown', {\n            shiftKey: true,\n            button: 2\n          });\n          expect(widget.isSelected(mdChild)).toBe(true);\n          expect(widget.mode).toBe('command');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should unrender a markdown cell",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "dblclick"
            ],
            "updatePoint": {
                "line": 1313,
                "column": 43
            },
            "line": 1313,
            "code": "        it('should unrender a markdown cell', async () => {\n          widget.model!.sharedModel.insertCell(0, {\n            cell_type: 'markdown',\n            source: '# Hello'\n          });\n          const child = widget.widgets[0] as MarkdownCell;\n          if (!child.inViewport) {\n            await signalToPromise(child.inViewportChanged);\n          }\n          expect(child.rendered).toBe(true);\n          expect(widget.mode).toBe('command');\n          simulate(child.node, 'dblclick');\n          expect(widget.mode).toBe('command');\n          expect(child.rendered).toBe(false);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to edit mode if a child cell takes focus",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "focusin"
            ],
            "updatePoint": {
                "line": 1331,
                "column": 66
            },
            "line": 1331,
            "code": "        it('should change to edit mode if a child cell takes focus', () => {\n          const child = widget.widgets[0];\n          simulate(child.editorWidget!.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('edit');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should change to command mode if the widget takes focus",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "focusin"
            ],
            "updatePoint": {
                "line": 1338,
                "column": 67
            },
            "line": 1338,
            "code": "        it('should change to command mode if the widget takes focus', () => {\n          const child = widget.widgets[0];\n          simulate(child.editorWidget!.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('edit');\n          widget.events = [];\n          simulate(widget.node, 'focusin');\n          expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n          expect(widget.mode).toBe('command');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should switch to command mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "focusout"
            ],
            "updatePoint": {
                "line": 1351,
                "column": 41
            },
            "line": 1351,
            "code": "        it('should switch to command mode', () => {\n          simulate(widget.node, 'focusin');\n          widget.mode = 'edit';\n          const event = generate('focusout');\n          (event as any).relatedTarget = document.body;\n          widget.node.dispatchEvent(event);\n          expect(widget.mode).toBe('command');\n          MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n          expect(widget.mode).toBe('command');\n          expect(widget.activeCell!.editor!.hasFocus()).toBe(false);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set command mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#handleEvent()",
                "focusout"
            ],
            "updatePoint": {
                "line": 1363,
                "column": 35
            },
            "line": 1363,
            "code": "        it('should set command mode', () => {\n          simulate(widget.node, 'focusin');\n          widget.mode = 'edit';\n          const evt = generate('focusout');\n          (evt as any).relatedTarget = widget.activeCell!.node;\n          widget.node.dispatchEvent(evt);\n          expect(widget.mode).toBe('command');\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add event listeners",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 1375,
                "column": 36
            },
            "line": 1375,
            "code": "      it('should add event listeners', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        const child = widget.widgets[0];\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).toEqual(expect.arrayContaining(['mousedown']));\n        simulate(widget.node, 'dblclick');\n        expect(widget.events).toEqual(expect.arrayContaining(['dblclick']));\n        simulate(child.node, 'focusin');\n        expect(widget.events).toEqual(expect.arrayContaining(['focusin']));\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 1393,
                "column": 39
            },
            "line": 1393,
            "code": "      it('should post an update request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onAfterAttach'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should remove event listeners",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onBeforeDetach()"
            ],
            "updatePoint": {
                "line": 1410,
                "column": 39
            },
            "line": 1410,
            "code": "      it('should remove event listeners', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        Widget.attach(widget, document.body);\n        const child = widget.widgets[0];\n        await framePromise();\n        Widget.detach(widget);\n        expect(widget.methods).toContain('onBeforeDetach');\n        widget.events = [];\n        simulate(widget.node, 'mousedown');\n        expect(widget.events).not.toContain('mousedown');\n        simulate(widget.node, 'dblclick');\n        expect(widget.events).not.toContain('dblclick');\n        simulate(child.node, 'focusin');\n        expect(widget.events).not.toContain('focusin');\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should focus the node after an update",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onActivateRequest()"
            ],
            "updatePoint": {
                "line": 1430,
                "column": 47
            },
            "line": 1430,
            "code": "      it('should focus the node after an update', async () => {\n        const widget = createActiveWidget();\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onActivateRequest'])\n        );\n        await framePromise();\n        expect(document.activeElement).toBe(widget.node);\n        widget.dispose();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should apply the command class if in command mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1457,
                "column": 59
            },
            "line": 1457,
            "code": "      it('should apply the command class if in command mode', () => {\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n        expect(widget.hasClass('jp-mod-commandMode')).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should apply the edit class if in edit mode",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1464,
                "column": 53
            },
            "line": 1464,
            "code": "      it('should apply the edit class if in edit mode', async () => {\n        widget.mode = 'edit';\n        await framePromise();\n        expect(widget.hasClass('jp-mod-editMode')).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add the active class to the active widget",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1470,
                "column": 58
            },
            "line": 1470,
            "code": "      it('should add the active class to the active widget', () => {\n        const cell = widget.widgets[widget.activeCellIndex];\n        expect(cell.hasClass('jp-mod-active')).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should set the selected class on the selected widgets",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1475,
                "column": 63
            },
            "line": 1475,
            "code": "      it('should set the selected class on the selected widgets', async () => {\n        widget.select(widget.widgets[1]);\n        await framePromise();\n        for (let i = 0; i < 2; i++) {\n          const cell = widget.widgets[i];\n          expect(cell.hasClass('jp-mod-selected')).toBe(true);\n        }\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should add the multi select class if there is more than one widget",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 1484,
                "column": 76
            },
            "line": 1484,
            "code": "      it('should add the multi select class if there is more than one widget', async () => {\n        widget.select(widget.widgets[1]);\n        expect(widget.hasClass('jp-mod-multSelected')).toBe(false);\n        await framePromise();\n        expect(widget.hasClass('jp-mod-multSelected')).toBe(false);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should post an `update-request",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellInserted()"
            ],
            "updatePoint": {
                "line": 1493,
                "column": 40
            },
            "line": 1493,
            "code": "      it('should post an `update-request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellInserted'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should update the active cell if necessary",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellInserted()"
            ],
            "updatePoint": {
                "line": 1505,
                "column": 52
            },
            "line": 1505,
            "code": "      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should keep the currently active cell active",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellInserted()"
            ],
            "updatePoint": {
                "line": 1511,
                "column": 54
            },
            "line": 1511,
            "code": "      it('should keep the currently active cell active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 1;\n        widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });\n        expect(widget.activeCell).toBe(widget.widgets[2]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the previous cell if top is requested",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellInserted()",
                "`edgeRequested` signal"
            ],
            "updatePoint": {
                "line": 1520,
                "column": 65
            },
            "line": 1520,
            "code": "        it('should activate the previous cell if top is requested', async () => {\n          const widget = createActiveWidget();\n          widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n          widget.activeCellIndex = 1;\n          // Wait for the cell to be ready and the signal listener to be set\n          await sleep();\n          const child = widget.widgets[widget.activeCellIndex];\n          (child.editor!.edgeRequested as any).emit('top');\n          expect(widget.activeCellIndex).toBe(0);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should activate the next cell if bottom is requested",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellInserted()",
                "`edgeRequested` signal"
            ],
            "updatePoint": {
                "line": 1531,
                "column": 64
            },
            "line": 1531,
            "code": "        it('should activate the next cell if bottom is requested', async () => {\n          const widget = createActiveWidget();\n          widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n          // Wait for the cell to be ready and the signal listener to be set\n          await sleep();\n          const child = widget.widgets[widget.activeCellIndex];\n          (child.editor!.edgeRequested as any).emit('bottom');\n          expect(widget.activeCellIndex).toBe(1);\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should post an `update-request",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellRemoved()"
            ],
            "updatePoint": {
                "line": 1544,
                "column": 40
            },
            "line": 1544,
            "code": "      it('should post an `update-request', async () => {\n        const widget = createActiveWidget();\n        widget.model!.sharedModel.deleteCell(0);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onCellRemoved'])\n        );\n        await framePromise();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onUpdateRequest'])\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should update the active cell if necessary",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellRemoved()"
            ],
            "updatePoint": {
                "line": 1556,
                "column": 52
            },
            "line": 1556,
            "code": "      it('should update the active cell if necessary', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.model!.sharedModel.deleteCell(0);\n        expect(widget.activeCell).toBe(widget.widgets[0]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should keep the currently active cell active",
            "suites": [
                "@jupyter/notebook",
                "Notebook",
                "#onCellRemoved()"
            ],
            "updatePoint": {
                "line": 1563,
                "column": 54
            },
            "line": 1563,
            "code": "      it('should keep the currently active cell active', () => {\n        const widget = createActiveWidget();\n        widget.model!.fromJSON(utils.DEFAULT_CONTENT);\n        widget.activeCellIndex = 2;\n        widget.model!.sharedModel.deleteCell(1);\n        expect(widget.activeCell).toBe(widget.widgets[1]);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a notebook widget factory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 40,
                "column": 49
            },
            "line": 40,
            "code": "      it('should create a notebook widget factory', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory).toBeInstanceOf(NotebookWidgetFactory);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should get whether the factory has been disposed",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 47,
                "column": 58
            },
            "line": 47,
            "code": "      it('should get whether the factory has been disposed', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory.isDisposed).toBe(false);\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should dispose of the resources held by the factory",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 56,
                "column": 61
            },
            "line": 56,
            "code": "      it('should dispose of the resources held by the factory', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 62,
                "column": 47
            },
            "line": 62,
            "code": "      it('should be safe to call multiple times', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        factory.dispose();\n        factory.dispose();\n        expect(factory.isDisposed).toBe(true);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be the editor config passed into the constructor",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#editorConfig"
            ],
            "updatePoint": {
                "line": 71,
                "column": 65
            },
            "line": 71,
            "code": "      it('should be the editor config passed into the constructor', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        expect(factory.editorConfig).toBe(utils.defaultEditorConfig);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should be settable",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#editorConfig"
            ],
            "updatePoint": {
                "line": 76,
                "column": 28
            },
            "line": 76,
            "code": "      it('should be settable', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const newConfig = { ...utils.defaultEditorConfig };\n        factory.editorConfig = newConfig;\n        expect(factory.editorConfig).toBe(newConfig);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a new `NotebookPanel` widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 52
            },
            "line": 85,
            "code": "      it('should create a new `NotebookPanel` widget', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel).toBeInstanceOf(NotebookPanel);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should create a clone of the rendermime",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 49
            },
            "line": 91,
            "code": "      it('should create a clone of the rendermime', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel.content.rendermime).not.toBe(rendermime);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should pass the editor config to the notebook",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 97,
                "column": 55
            },
            "line": 97,
            "code": "      it('should pass the editor config to the notebook', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        expect(panel.content.editorConfig).toBe(utils.defaultEditorConfig);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should populate the default toolbar items",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 51
            },
            "line": 103,
            "code": "      it('should populate the default toolbar items', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        // It will only contain the popup opener\n        expect(Array.from(panel.toolbar.names())).toHaveLength(1);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should populate the customized toolbar items",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 54
            },
            "line": 110,
            "code": "      it('should populate the customized toolbar items', () => {\n        const toolbarFactory = () => [\n          { name: 'foo', widget: new ToolbarButton() },\n          { name: 'bar', widget: new ToolbarButton() }\n        ];\n        const factory = utils.createNotebookWidgetFactory(toolbarFactory);\n        const panel = factory.createNew(context);\n        const panel2 = factory.createNew(context);\n        expect(Array.from(panel.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(Array.from(panel2.toolbar.names())).toEqual([\n          'foo',\n          'bar',\n          'toolbar-popup-opener'\n        ]);\n        expect(Array.from(panel.toolbar.children()).length).toBe(3);\n        expect(Array.from(panel2.toolbar.children()).length).toBe(3);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should clone from the optional source widget",
            "suites": [
                "@jupyterlab/notebook",
                "NotebookWidgetFactory",
                "#createNew()"
            ],
            "updatePoint": {
                "line": 132,
                "column": 54
            },
            "line": 132,
            "code": "      it('should clone from the optional source widget', () => {\n        const factory = utils.createNotebookWidgetFactory();\n        const panel = factory.createNew(context);\n        const clone = factory.createNew(panel.context, panel);\n        expect(clone).toBeInstanceOf(NotebookPanel);\n        expect(clone.content.rendermime).toBe(panel.content.rendermime);\n        expect(clone.content.editorConfig).toBe(panel.content.editorConfig);\n        expect(clone.content.notebookConfig).toBe(panel.content.notebookConfig);\n      });",
            "file": "widgetfactory.spec.ts",
            "skipped": false,
            "dir": "packages/notebook/test"
        },
        {
            "name": "should accept no arguments",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#constructor"
            ],
            "updatePoint": {
                "line": 16,
                "column": 36
            },
            "line": 16,
            "code": "      it('should accept no arguments', () => {\n        const value = new ObservableValue();\n        expect(value instanceof ObservableValue).toBe(true);\n        expect(value.get()).toBeNull();\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept an initial JSON value",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#constructor"
            ],
            "updatePoint": {
                "line": 22,
                "column": 45
            },
            "line": 22,
            "code": "      it('should accept an initial JSON value', () => {\n        const value = new ObservableValue('value');\n        expect(value instanceof ObservableValue).toBe(true);\n        const value2 = new ObservableValue({ one: 'one', two: 2 });\n        expect(value2 instanceof ObservableValue).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `Value`",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#type"
            ],
            "updatePoint": {
                "line": 31,
                "column": 31
            },
            "line": 31,
            "code": "      it('should return `Value`', () => {\n        const value = new ObservableValue();\n        expect(value.type).toBe('Value');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should test whether the value is disposed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 38,
                "column": 51
            },
            "line": 38,
            "code": "      it('should test whether the value is disposed', () => {\n        const value = new ObservableValue();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be emitted when the map changes state",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#changed"
            ],
            "updatePoint": {
                "line": 47,
                "column": 54
            },
            "line": 47,
            "code": "      it('should be emitted when the map changes state', () => {\n        let called = false;\n        const value = new ObservableValue();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.set('set');\n        expect(called).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should have value changed args",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#changed"
            ],
            "updatePoint": {
                "line": 57,
                "column": 40
            },
            "line": 57,
            "code": "      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableValue();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.newValue).toBe('set');\n          expect(args.oldValue).toBeNull();\n          called = true;\n        });\n        value.set('set');\n        expect(called).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should get the value of the object",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#get"
            ],
            "updatePoint": {
                "line": 72,
                "column": 44
            },
            "line": 72,
            "code": "      it('should get the value of the object', () => {\n        const value = new ObservableValue('value');\n        expect(value.get()).toBe('value');\n        const value2 = new ObservableValue({ one: 'one', two: 2 });\n        expect(JSONExt.deepEqual(value2.get(), { one: 'one', two: 2 })).toBe(\n          true\n        );\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set the value of the object",
            "suites": [
                "@jupyterlab/observables",
                "ObservableValue",
                "#set"
            ],
            "updatePoint": {
                "line": 83,
                "column": 44
            },
            "line": 83,
            "code": "      it('should set the value of the object', () => {\n        const value = new ObservableValue();\n        value.set('value');\n        expect(value.get()).toBe('value');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept no arguments",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 36
            },
            "line": 93,
            "code": "      it('should accept no arguments', () => {\n        const db = new ModelDB();\n        expect(db instanceof ModelDB).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept a basePath",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 98,
                "column": 34
            },
            "line": 98,
            "code": "      it('should accept a basePath', () => {\n        const db = new ModelDB({ basePath: 'base' });\n        expect(db instanceof ModelDB).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept a baseDB",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 32
            },
            "line": 103,
            "code": "      it('should accept a baseDB', () => {\n        const base = new ModelDB();\n        const db = new ModelDB({ baseDB: base });\n        expect(db instanceof ModelDB).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should test whether it is disposed",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 111,
                "column": 44
            },
            "line": 111,
            "code": "      it('should test whether it is disposed', () => {\n        const db = new ModelDB();\n        expect(db.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return an empty string for a model without a baseDB",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#basePath"
            ],
            "updatePoint": {
                "line": 120,
                "column": 68
            },
            "line": 120,
            "code": "      it('should return an empty string for a model without a baseDB', () => {\n        const db = new ModelDB();\n        expect(db.basePath).toBe('');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the base path",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#basePath"
            ],
            "updatePoint": {
                "line": 125,
                "column": 37
            },
            "line": 125,
            "code": "      it('should return the base path', () => {\n        const db = new ModelDB({ basePath: 'base' });\n        expect(db.basePath).toBe('base');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return false for an in-memory database",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#isPrepopulated"
            ],
            "updatePoint": {
                "line": 132,
                "column": 55
            },
            "line": 132,
            "code": "      it('should return false for an in-memory database', () => {\n        const db = new ModelDB();\n        expect(db.isPrepopulated).toBe(false);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return false for an in-memory database",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#isCollaborative"
            ],
            "updatePoint": {
                "line": 139,
                "column": 55
            },
            "line": 139,
            "code": "      it('should return false for an in-memory database', () => {\n        const db = new ModelDB();\n        expect(db.isCollaborative).toBe(false);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should resolve immediately for an in-memory database",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#connected"
            ],
            "updatePoint": {
                "line": 146,
                "column": 62
            },
            "line": 146,
            "code": "      it('should resolve immediately for an in-memory database', async () => {\n        const db = new ModelDB();\n        await expect(db.connected).resolves.not.toThrow();\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should get a value that exists at a path",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#get"
            ],
            "updatePoint": {
                "line": 153,
                "column": 50
            },
            "line": 153,
            "code": "      it('should get a value that exists at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        const value2 = db.get('value');\n        expect(value2).toBe(value);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return undefined for a value that does not exist",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#get"
            ],
            "updatePoint": {
                "line": 160,
                "column": 65
            },
            "line": 160,
            "code": "      it('should return undefined for a value that does not exist', () => {\n        const db = new ModelDB();\n        expect(db.get('value')).toBeUndefined();\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return true if a value exists at a path",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#has"
            ],
            "updatePoint": {
                "line": 167,
                "column": 56
            },
            "line": 167,
            "code": "      it('should return true if a value exists at a path', () => {\n        const db = new ModelDB();\n        db.createValue('value');\n        expect(db.has('value')).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return false for a value that does not exist",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#has"
            ],
            "updatePoint": {
                "line": 173,
                "column": 61
            },
            "line": 173,
            "code": "      it('should return false for a value that does not exist', () => {\n        const db = new ModelDB();\n        expect(db.has('value')).toBe(false);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an ObservableString`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createString"
            ],
            "updatePoint": {
                "line": 180,
                "column": 44
            },
            "line": 180,
            "code": "      it('should create an ObservableString`', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        expect(str instanceof ObservableString).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be able to retrieve that string using `get`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createString"
            ],
            "updatePoint": {
                "line": 186,
                "column": 60
            },
            "line": 186,
            "code": "      it('should be able to retrieve that string using `get`', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        expect(db.get('str')).toBe(str);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an ObservableUndoableList`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createList"
            ],
            "updatePoint": {
                "line": 194,
                "column": 50
            },
            "line": 194,
            "code": "      it('should create an ObservableUndoableList`', () => {\n        const db = new ModelDB();\n        const str = db.createList('vec');\n        expect(str instanceof ObservableUndoableList).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be able to retrieve that vector using `get`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createList"
            ],
            "updatePoint": {
                "line": 200,
                "column": 60
            },
            "line": 200,
            "code": "      it('should be able to retrieve that vector using `get`', () => {\n        const db = new ModelDB();\n        const vec = db.createList('vec');\n        expect(db.get('vec')).toBe(vec);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an ObservableMap`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createMap"
            ],
            "updatePoint": {
                "line": 208,
                "column": 41
            },
            "line": 208,
            "code": "      it('should create an ObservableMap`', () => {\n        const db = new ModelDB();\n        const map = db.createMap('map');\n        expect(map instanceof ObservableJSON).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be able to retrieve that map using `get`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createMap"
            ],
            "updatePoint": {
                "line": 214,
                "column": 57
            },
            "line": 214,
            "code": "      it('should be able to retrieve that map using `get`', () => {\n        const db = new ModelDB();\n        const map = db.createMap('map');\n        expect(db.get('map')).toBe(map);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an ObservableValue`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createValue"
            ],
            "updatePoint": {
                "line": 222,
                "column": 43
            },
            "line": 222,
            "code": "      it('should create an ObservableValue`', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        expect(value instanceof ObservableValue).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be able to retrieve that value using `get`",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#createValue"
            ],
            "updatePoint": {
                "line": 228,
                "column": 59
            },
            "line": 228,
            "code": "      it('should be able to retrieve that value using `get`', () => {\n        const db = new ModelDB();\n        const value = db.createString('value');\n        expect(db.get('value')).toBe(value);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set a value at a path",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#setValue"
            ],
            "updatePoint": {
                "line": 236,
                "column": 38
            },
            "line": 236,
            "code": "      it('should set a value at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        db.setValue('value', 'set');\n        expect(value.get()).toBe('set');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should get a value at a path",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#getValue"
            ],
            "updatePoint": {
                "line": 245,
                "column": 38
            },
            "line": 245,
            "code": "      it('should get a value at a path', () => {\n        const db = new ModelDB();\n        const value = db.createValue('value');\n        value.set('set');\n        expect(db.getValue('value')).toBe('set');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should should return a ModelDB",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#view"
            ],
            "updatePoint": {
                "line": 254,
                "column": 40
            },
            "line": 254,
            "code": "      it('should should return a ModelDB', () => {\n        const db = new ModelDB();\n        const view = db.view('');\n        expect(view instanceof ModelDB).toBe(true);\n        expect(view === db).toBe(false);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set the baseDB path on the view",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#view"
            ],
            "updatePoint": {
                "line": 261,
                "column": 48
            },
            "line": 261,
            "code": "      it('should set the baseDB path on the view', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n        expect(view.basePath).toBe('base');\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return a view onto the base ModelDB",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#view"
            ],
            "updatePoint": {
                "line": 267,
                "column": 52
            },
            "line": 267,
            "code": "      it('should return a view onto the base ModelDB', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n\n        db.createString('base.str1');\n        expect(db.get('base.str1')).toBe(view.get('str1'));\n\n        view.createString('str2');\n        expect(db.get('base.str2')).toBe(view.get('str2'));\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be stackable",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#view"
            ],
            "updatePoint": {
                "line": 278,
                "column": 29
            },
            "line": 278,
            "code": "      it('should be stackable', () => {\n        const db = new ModelDB();\n        const view = db.view('one');\n        const viewView = view.view('two');\n\n        expect(view.basePath).toBe('one');\n        expect(viewView.basePath).toBe('two');\n\n        viewView.createString('str');\n        expect(viewView.get('str')).toBe(view.get('two.str'));\n        expect(viewView.get('str')).toBe(db.get('one.two.str'));\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should dispose of the resources used by the model",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#dispose"
            ],
            "updatePoint": {
                "line": 293,
                "column": 59
            },
            "line": 293,
            "code": "      it('should dispose of the resources used by the model', () => {\n        const db = new ModelDB();\n        const str = db.createString('str');\n        const view = db.view('base');\n        const str2 = view.createString('str');\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n        expect(view.isDisposed).toBe(false);\n        expect(str2.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n        expect(str.isDisposed).toBe(true);\n        expect(view.isDisposed).toBe(true);\n        expect(str2.isDisposed).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should not dispose of resources in base databases",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#dispose"
            ],
            "updatePoint": {
                "line": 309,
                "column": 59
            },
            "line": 309,
            "code": "      it('should not dispose of resources in base databases', () => {\n        const db = new ModelDB();\n        const view = db.view('base');\n        const str = db.createString('str');\n        const str2 = view.createString('str');\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n        expect(view.isDisposed).toBe(false);\n        expect(str2.isDisposed).toBe(false);\n        view.dispose();\n        expect(view.isDisposed).toBe(true);\n        expect(str2.isDisposed).toBe(true);\n        expect(db.isDisposed).toBe(false);\n        expect(str.isDisposed).toBe(false);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "@jupyterlab/observables",
                "ModelDB",
                "#dispose"
            ],
            "updatePoint": {
                "line": 325,
                "column": 47
            },
            "line": 325,
            "code": "      it('should be safe to call more than once', () => {\n        const db = new ModelDB();\n        expect(db.isDisposed).toBe(false);\n        db.dispose();\n        expect(db.isDisposed).toBe(true);\n      });",
            "file": "modeldb.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an observable JSON object",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 49
            },
            "line": 9,
            "code": "      it('should create an observable JSON object', () => {\n        const item = new ObservableJSON();\n        expect(item).toBeInstanceOf(ObservableJSON);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept initial values",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 38
            },
            "line": 14,
            "code": "      it('should accept initial values', () => {\n        const item = new ObservableJSON({\n          values: { foo: 1, bar: 'baz' }\n        });\n        expect(item).toBeInstanceOf(ObservableJSON);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should serialize the model to JSON",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 23,
                "column": 44
            },
            "line": 23,
            "code": "      it('should serialize the model to JSON', () => {\n        const item = new ObservableJSON();\n        item.set('foo', 1);\n        expect(item.toJSON()['foo']).toBe(1);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return a copy of the data",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 42
            },
            "line": 29,
            "code": "      it('should return a copy of the data', () => {\n        const item = new ObservableJSON();\n        item.set('foo', { bar: 1 });\n        const value = item.toJSON();\n        value['bar'] = 2;\n        expect((item.get('foo') as any)['bar']).toBe(1);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create a new message",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON.ChangeMessage",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 37
            },
            "line": 41,
            "code": "      it('should create a new message', () => {\n        const message = new ObservableJSON.ChangeMessage('jsonvalue-changed', {\n          key: 'foo',\n          type: 'add',\n          oldValue: 1,\n          newValue: 2\n        });\n        expect(message).toBeInstanceOf(ObservableJSON.ChangeMessage);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be the args of the message",
            "suites": [
                "@jupyterlab/observables",
                "ObservableJSON.ChangeMessage",
                "#args"
            ],
            "updatePoint": {
                "line": 53,
                "column": 43
            },
            "line": 53,
            "code": "      it('should be the args of the message', () => {\n        const args: IObservableJSON.IChangedArgs = {\n          key: 'foo',\n          type: 'add',\n          oldValue: 'ho',\n          newValue: 'hi'\n        };\n        const message = new ObservableJSON.ChangeMessage(\n          'jsonvalue-changed',\n          args\n        );\n        expect(message.args).toBe(args);\n      });",
            "file": "observablejson.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept no arguments",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 36
            },
            "line": 9,
            "code": "      it('should accept no arguments', () => {\n        const value = new ObservableList<number>();\n        expect(value instanceof ObservableList).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept an array argument",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 41
            },
            "line": 14,
            "code": "      it('should accept an array argument', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value instanceof ObservableList).toBe(true);\n        expect(Array.from(value)).toEqual([1, 2, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `List`",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#type"
            ],
            "updatePoint": {
                "line": 22,
                "column": 30
            },
            "line": 22,
            "code": "      it('should return `List`', () => {\n        const value = new ObservableList<number>();\n        expect(value.type).toBe('List');\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be emitted when the list changes state",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#changed"
            ],
            "updatePoint": {
                "line": 29,
                "column": 55
            },
            "line": 29,
            "code": "      it('should be emitted when the list changes state', () => {\n        let called = false;\n        const value = new ObservableList<number>();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.insert(0, 1);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should have value changed args",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#changed"
            ],
            "updatePoint": {
                "line": 39,
                "column": 40
            },
            "line": 39,
            "code": "      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableList<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(0);\n          expect(args.oldIndex).toBe(-1);\n          expect(args.newValues[0]).toBe(1);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.push(1);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should test whether the list is disposed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 57,
                "column": 50
            },
            "line": 57,
            "code": "      it('should test whether the list is disposed', () => {\n        const value = new ObservableList<number>();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should dispose of the resources held by the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 66,
                "column": 58
            },
            "line": 66,
            "code": "      it('should dispose of the resources held by the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should get the value at the specified index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#get()"
            ],
            "updatePoint": {
                "line": 74,
                "column": 53
            },
            "line": 74,
            "code": "      it('should get the value at the specified index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.get(1)).toBe(2);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set the item at a specific index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#set()"
            ],
            "updatePoint": {
                "line": 81,
                "column": 49
            },
            "line": 81,
            "code": "      it('should set the item at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.set(1, 4);\n        expect(Array.from(value)).toEqual([1, 4, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#set()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 41
            },
            "line": 87,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.set(1, 4);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should add an item to the end of the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#push()"
            ],
            "updatePoint": {
                "line": 105,
                "column": 51
            },
            "line": 105,
            "code": "      it('should add an item to the end of the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.push(4);\n        expect(Array.from(value)).toEqual([1, 2, 3, 4]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the new length of the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#push()"
            ],
            "updatePoint": {
                "line": 111,
                "column": 50
            },
            "line": 111,
            "code": "      it('should return the new length of the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.push(4)).toBe(4);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#push()"
            ],
            "updatePoint": {
                "line": 116,
                "column": 41
            },
            "line": 116,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(3);\n          expect(args.oldIndex).toBe(-1);\n          expect(args.oldValues.length).toBe(0);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.push(4);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should insert an item into the list at a specific index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#insert()"
            ],
            "updatePoint": {
                "line": 134,
                "column": 65
            },
            "line": 134,
            "code": "      it('should insert an item into the list at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.insert(1, 4);\n        expect(Array.from(value)).toEqual([1, 4, 2, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#insert()"
            ],
            "updatePoint": {
                "line": 140,
                "column": 41
            },
            "line": 140,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(-2);\n          expect(args.oldValues.length).toBe(0);\n          expect(args.newValues[0]).toBe(4);\n          called = true;\n        });\n        value.insert(1, 4);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should move an item from one index to another",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#move()"
            ],
            "updatePoint": {
                "line": 158,
                "column": 55
            },
            "line": 158,
            "code": "      it('should move an item from one index to another', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.move(1, 2);\n        expect(Array.from(value)).toEqual([1, 3, 2]);\n        value.move(2, 0);\n        expect(Array.from(value)).toEqual([2, 1, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#move()"
            ],
            "updatePoint": {
                "line": 166,
                "column": 41
            },
            "line": 166,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('move');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(0);\n          expect(args.oldValues[0]).toBe(1);\n          expect(args.newValues[0]).toBe(1);\n          called = true;\n        });\n        value.move(0, 1);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove the first occurrence of a specific item from the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeValue()"
            ],
            "updatePoint": {
                "line": 185,
                "column": 77
            },
            "line": 185,
            "code": "      it('should remove the first occurrence of a specific item from the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.removeValue(1);\n        expect(Array.from(value)).toEqual([2, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the index occupied by the item",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeValue()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 54
            },
            "line": 191,
            "code": "      it('should return the index occupied by the item', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.removeValue(1)).toBe(0);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `-1` if the item is not in the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeValue()"
            ],
            "updatePoint": {
                "line": 196,
                "column": 59
            },
            "line": 196,
            "code": "      it('should return `-1` if the item is not in the list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.removeValue(10)).toBe(-1);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeValue()"
            ],
            "updatePoint": {
                "line": 201,
                "column": 41
            },
            "line": 201,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.removeValue(2);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove the item at a specific index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#remove()"
            ],
            "updatePoint": {
                "line": 220,
                "column": 52
            },
            "line": 220,
            "code": "      it('should remove the item at a specific index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.remove(1);\n        expect(Array.from(value)).toEqual([1, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the item at the specified index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#remove()"
            ],
            "updatePoint": {
                "line": 226,
                "column": 55
            },
            "line": 226,
            "code": "      it('should return the item at the specified index', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.remove(1)).toBe(2);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `undefined` if the index is out of range",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#remove()"
            ],
            "updatePoint": {
                "line": 231,
                "column": 64
            },
            "line": 231,
            "code": "      it('should return `undefined` if the index is out of range', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        expect(value.remove(10)).toBeUndefined();\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#remove()"
            ],
            "updatePoint": {
                "line": 236,
                "column": 41
            },
            "line": 236,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(args.oldValues[0]).toBe(2);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.remove(1);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove all items from the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#clear()"
            ],
            "updatePoint": {
                "line": 255,
                "column": 47
            },
            "line": 255,
            "code": "      it('should remove all items from the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.clear();\n        expect(value.length).toBe(0);\n        value.clear();\n        expect(value.length).toBe(0);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#clear()"
            ],
            "updatePoint": {
                "line": 264,
                "column": 41
            },
            "line": 264,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(0);\n          expect(args.oldIndex).toBe(0);\n          expect(Array.from(args.oldValues)).toEqual(values);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should push an array of items to the end of the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#pushAll()"
            ],
            "updatePoint": {
                "line": 283,
                "column": 62
            },
            "line": 283,
            "code": "      it('should push an array of items to the end of the list', () => {\n        const value = new ObservableList<number>({ values: [1] });\n        value.pushAll([2, 3, 4]);\n        expect(Array.from(value)).toEqual([1, 2, 3, 4]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the new length of the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#pushAll()"
            ],
            "updatePoint": {
                "line": 289,
                "column": 50
            },
            "line": 289,
            "code": "      it('should return the new length of the list', () => {\n        const value = new ObservableList<number>({ values: [1] });\n        expect(value.pushAll([2, 3, 4])).toBe(4);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#pushAll()"
            ],
            "updatePoint": {
                "line": 294,
                "column": 41
            },
            "line": 294,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(3);\n          expect(args.oldIndex).toBe(-1);\n          expect(Array.from(args.newValues)).toEqual([4, 5, 6]);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.pushAll([4, 5, 6]);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should push an array of items into a list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#insertAll()"
            ],
            "updatePoint": {
                "line": 312,
                "column": 51
            },
            "line": 312,
            "code": "      it('should push an array of items into a list', () => {\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.insertAll(1, [2, 3, 4]);\n        expect(Array.from(value)).toEqual([1, 2, 3, 4, 2, 3]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#insertAll()"
            ],
            "updatePoint": {
                "line": 318,
                "column": 41
            },
            "line": 318,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableList<number>({ values: [1, 2, 3] });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newIndex).toBe(1);\n          expect(args.oldIndex).toBe(-2);\n          expect(Array.from(args.newValues)).toEqual([4, 5, 6]);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        value.insertAll(1, [4, 5, 6]);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove a range of items from the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeRange()"
            ],
            "updatePoint": {
                "line": 336,
                "column": 54
            },
            "line": 336,
            "code": "      it('should remove a range of items from the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        value.removeRange(1, 3);\n        expect(Array.from(value)).toEqual([1, 4, 5, 6]);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the new length of the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeRange()"
            ],
            "updatePoint": {
                "line": 343,
                "column": 50
            },
            "line": 343,
            "code": "      it('should return the new length of the list', () => {\n        const values = [1, 2, 3, 4, 5, 6];\n        const value = new ObservableList<number>({ values });\n        expect(value.removeRange(1, 3)).toBe(4);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableList",
                "#removeRange()"
            ],
            "updatePoint": {
                "line": 349,
                "column": 41
            },
            "line": 349,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const values = [1, 2, 3, 4];\n        const value = new ObservableList<number>({ values });\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.newIndex).toBe(-1);\n          expect(args.oldIndex).toBe(1);\n          expect(Array.from(args.oldValues)).toEqual([2, 3]);\n          expect(args.newValues.length).toBe(0);\n          called = true;\n        });\n        value.removeRange(1, 3);\n        expect(called).toBe(true);\n      });",
            "file": "observablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept no arguments",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 36
            },
            "line": 9,
            "code": "      it('should accept no arguments', () => {\n        const value = new ObservableMap<number>();\n        expect(value instanceof ObservableMap).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `Map`",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#type"
            ],
            "updatePoint": {
                "line": 16,
                "column": 29
            },
            "line": 16,
            "code": "      it('should return `Map`', () => {\n        const value = new ObservableMap<number>();\n        expect(value.type).toBe('Map');\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the number of entries in the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#size"
            ],
            "updatePoint": {
                "line": 23,
                "column": 56
            },
            "line": 23,
            "code": "      it('should return the number of entries in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        expect(value.size).toBe(2);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be emitted when the map changes state",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#changed"
            ],
            "updatePoint": {
                "line": 32,
                "column": 54
            },
            "line": 32,
            "code": "      it('should be emitted when the map changes state', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.set('entry', 1);\n        expect(called).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should have value changed args",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#changed"
            ],
            "updatePoint": {
                "line": 42,
                "column": 40
            },
            "line": 42,
            "code": "      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newValue).toBe(0);\n          expect(args.oldValue).toBeUndefined();\n          expect(args.key).toBe('entry');\n          called = true;\n        });\n        value.set('entry', 0);\n        expect(called).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should test whether the map is disposed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 59,
                "column": 49
            },
            "line": 59,
            "code": "      it('should test whether the map is disposed', () => {\n        const value = new ObservableMap<number>();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should dispose of the resources held by the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 68,
                "column": 57
            },
            "line": 68,
            "code": "      it('should dispose of the resources held by the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set the item at a specific key",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#set()"
            ],
            "updatePoint": {
                "line": 78,
                "column": 47
            },
            "line": 78,
            "code": "      it('should set the item at a specific key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('one')).toBe(1);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the old value for that key",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#set()"
            ],
            "updatePoint": {
                "line": 84,
                "column": 50
            },
            "line": 84,
            "code": "      it('should return the old value for that key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        const x = value.set('one', 1.01);\n        expect(x).toBe(1);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#set()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 41
            },
            "line": 91,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableMap<number>();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('add');\n          expect(args.newValue).toBe(1);\n          expect(args.oldValue).toBeUndefined();\n          expect(args.key).toBe('one');\n          called = true;\n        });\n        value.set('one', 1);\n        expect(called).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should get the value for a key",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#get()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 40
            },
            "line": 108,
            "code": "      it('should get the value for a key', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('one')).toBe(1);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return undefined if the key does not exist",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#get()"
            ],
            "updatePoint": {
                "line": 114,
                "column": 59
            },
            "line": 114,
            "code": "      it('should return undefined if the key does not exist', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.get('two')).toBeUndefined();\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should whether the key exists in a map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#has()"
            ],
            "updatePoint": {
                "line": 122,
                "column": 48
            },
            "line": 122,
            "code": "      it('should whether the key exists in a map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.has('one')).toBe(true);\n        expect(value.has('two')).toBe(false);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return a list of the keys in the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#keys()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 53
            },
            "line": 131,
            "code": "      it('should return a list of the keys in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        const keys = value.keys();\n        expect(keys).toEqual(['one', 'two', 'three']);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return a list of the values in the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#values()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 55
            },
            "line": 142,
            "code": "      it('should return a list of the values in the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        const keys = value.values();\n        expect(keys).toEqual([1, 2, 3]);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove an item from the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#delete()"
            ],
            "updatePoint": {
                "line": 153,
                "column": 44
            },
            "line": 153,
            "code": "      it('should remove an item from the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        expect(value.get('two')).toBe(2);\n        value.delete('two');\n        expect(value.get('two')).toBeUndefined();\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return the value of the key it removed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#delete()"
            ],
            "updatePoint": {
                "line": 163,
                "column": 55
            },
            "line": 163,
            "code": "      it('should return the value of the key it removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        expect(value.delete('one')).toBe(1);\n        expect(value.delete('one')).toBeUndefined();\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal if actually removed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#delete()"
            ],
            "updatePoint": {
                "line": 170,
                "column": 61
            },
            "line": 170,
            "code": "      it('should trigger a changed signal if actually removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        let called = false;\n\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('two');\n          expect(args.oldValue).toBe(2);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n        value.delete('two');\n        expect(called).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should not trigger a changed signal if not actually removed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#delete()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 69
            },
            "line": 189,
            "code": "      it('should not trigger a changed signal if not actually removed', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('three', 3);\n        let called = false;\n\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('two');\n          expect(args.oldValue).toBe(2);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n\n        // 'two' is not in the map\n        value.delete('two');\n        expect(called).toBe(false);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove all items from the map",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#clear()"
            ],
            "updatePoint": {
                "line": 211,
                "column": 46
            },
            "line": 211,
            "code": "      it('should remove all items from the map', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        value.set('two', 2);\n        value.set('three', 3);\n        value.clear();\n        expect(value.size).toBe(0);\n        value.clear();\n        expect(value.size).toBe(0);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableMap",
                "#clear()"
            ],
            "updatePoint": {
                "line": 222,
                "column": 41
            },
            "line": 222,
            "code": "      it('should trigger a changed signal', () => {\n        const value = new ObservableMap<number>();\n        value.set('one', 1);\n        let called = false;\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.key).toBe('one');\n          expect(args.oldValue).toBe(1);\n          expect(args.newValue).toBeUndefined();\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });",
            "file": "observablemap.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept no arguments",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 36
            },
            "line": 9,
            "code": "      it('should accept no arguments', () => {\n        const value = new ObservableString();\n        expect(value instanceof ObservableString).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should accept a string argument",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 41
            },
            "line": 14,
            "code": "      it('should accept a string argument', () => {\n        const value = new ObservableString('hello');\n        expect(value instanceof ObservableString).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should initialize the string value",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 19,
                "column": 44
            },
            "line": 19,
            "code": "      it('should initialize the string value', () => {\n        const value = new ObservableString('hello');\n        expect(value.text).toEqual('hello');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return `String`",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#type"
            ],
            "updatePoint": {
                "line": 26,
                "column": 32
            },
            "line": 26,
            "code": "      it('should return `String`', () => {\n        const value = new ObservableString();\n        expect(value.type).toBe('String');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should be emitted when the string changes",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#changed"
            ],
            "updatePoint": {
                "line": 33,
                "column": 51
            },
            "line": 33,
            "code": "      it('should be emitted when the string changes', () => {\n        let called = false;\n        const value = new ObservableString();\n        value.changed.connect(() => {\n          called = true;\n        });\n        value.text = 'change';\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should have value changed args",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#changed"
            ],
            "updatePoint": {
                "line": 43,
                "column": 40
            },
            "line": 43,
            "code": "      it('should have value changed args', () => {\n        let called = false;\n        const value = new ObservableString();\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(3);\n          expect(args.value).toBe('new');\n          called = true;\n        });\n        value.text = 'new';\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should test whether the string is disposed",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 60,
                "column": 52
            },
            "line": 60,
            "code": "      it('should test whether the string is disposed', () => {\n        const value = new ObservableString();\n        expect(value.isDisposed).toBe(false);\n        value.dispose();\n        expect(value.isDisposed).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should set the item at a specific index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#setter()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 49
            },
            "line": 69,
            "code": "      it('should set the item at a specific index', () => {\n        const value = new ObservableString('old');\n        value.text = 'new';\n        expect(value.text).toEqual('new');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#setter()"
            ],
            "updatePoint": {
                "line": 75,
                "column": 41
            },
            "line": 75,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('old');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(3);\n          expect(args.value).toBe('new');\n          called = true;\n        });\n        value.text = 'new';\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should insert an substring into the string at a specific index",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#insert()"
            ],
            "updatePoint": {
                "line": 92,
                "column": 72
            },
            "line": 92,
            "code": "      it('should insert an substring into the string at a specific index', () => {\n        const value = new ObservableString('one three');\n        value.insert(4, 'two ');\n        expect(value.text).toEqual('one two three');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#insert()"
            ],
            "updatePoint": {
                "line": 98,
                "column": 41
            },
            "line": 98,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('one three');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('insert');\n          expect(args.start).toBe(4);\n          expect(args.end).toBe(8);\n          expect(args.value).toBe('two ');\n          called = true;\n        });\n        value.insert(4, 'two ');\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should remove a substring from the string",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#remove()"
            ],
            "updatePoint": {
                "line": 115,
                "column": 51
            },
            "line": 115,
            "code": "      it('should remove a substring from the string', () => {\n        const value = new ObservableString('one two two three');\n        value.remove(4, 8);\n        expect(value.text).toEqual('one two three');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#remove()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 41
            },
            "line": 121,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('one two two three');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('remove');\n          expect(args.start).toBe(4);\n          expect(args.end).toBe(8);\n          expect(args.value).toBe('two ');\n          called = true;\n        });\n        value.remove(4, 8);\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should empty the string",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#clear()"
            ],
            "updatePoint": {
                "line": 138,
                "column": 33
            },
            "line": 138,
            "code": "      it('should empty the string', () => {\n        const value = new ObservableString('full');\n        value.clear();\n        expect(value.text.length).toBe(0);\n        expect(value.text).toBe('');\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should trigger a changed signal",
            "suites": [
                "@jupyterlab/observables",
                "ObservableString",
                "#clear()"
            ],
            "updatePoint": {
                "line": 145,
                "column": 41
            },
            "line": 145,
            "code": "      it('should trigger a changed signal', () => {\n        let called = false;\n        const value = new ObservableString('full');\n        value.changed.connect((sender, args) => {\n          expect(sender).toBe(value);\n          expect(args.type).toBe('set');\n          expect(args.start).toBe(0);\n          expect(args.end).toBe(0);\n          expect(args.value).toBe('');\n          called = true;\n        });\n        value.clear();\n        expect(called).toBe(true);\n      });",
            "file": "observablestring.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create a new ObservableUndoableList",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#constructor"
            ],
            "updatePoint": {
                "line": 38,
                "column": 52
            },
            "line": 38,
            "code": "      it('should create a new ObservableUndoableList', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list).toBeInstanceOf(ObservableUndoableList);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return false if there is no history",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#canRedo"
            ],
            "updatePoint": {
                "line": 45,
                "column": 52
            },
            "line": 45,
            "code": "      it('should return false if there is no history', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list.canRedo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return true if there is an undo that can be redone",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#canRedo"
            ],
            "updatePoint": {
                "line": 50,
                "column": 67
            },
            "line": 50,
            "code": "      it('should return true if there is an undo that can be redone', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(new Test(value));\n        list.undo();\n        expect(list.canRedo).toBe(true);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return false if there is no history",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#canUndo"
            ],
            "updatePoint": {
                "line": 59,
                "column": 52
            },
            "line": 59,
            "code": "      it('should return false if there is no history', () => {\n        const list = new ObservableUndoableList(serializer);\n        expect(list.canUndo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should return true if there is a change that can be undone",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#canUndo"
            ],
            "updatePoint": {
                "line": 64,
                "column": 68
            },
            "line": 64,
            "code": "      it('should return true if there is a change that can be undone', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        expect(list.canUndo).toBe(true);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should dispose of the resources used by the list",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 72,
                "column": 58
            },
            "line": 72,
            "code": "      it('should dispose of the resources used by the list', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.dispose();\n        expect(list.isDisposed).toBe(true);\n        list.dispose();\n        expect(list.isDisposed).toBe(true);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should begin a compound operation",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#beginCompoundOperation()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 43
            },
            "line": 82,
            "code": "      it('should begin a compound operation', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation();\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(true);\n        list.undo();\n        expect(list.canUndo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should not be undoable if isUndoAble is set to false",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#beginCompoundOperation()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 62
            },
            "line": 93,
            "code": "      it('should not be undoable if isUndoAble is set to false', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation(false);\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should end a compound operation",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#endCompoundOperation()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 41
            },
            "line": 104,
            "code": "      it('should end a compound operation', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.beginCompoundOperation();\n        list.push(serializer.fromJSON(value));\n        list.push(serializer.fromJSON(value));\n        list.endCompoundOperation();\n        expect(list.canUndo).toBe(true);\n        list.undo();\n        expect(list.canUndo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a push",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#undo()"
            ],
            "updatePoint": {
                "line": 117,
                "column": 28
            },
            "line": 117,
            "code": "      it('should undo a push', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.undo();\n        expect(list.length).toBe(0);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a pushAll",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#undo()"
            ],
            "updatePoint": {
                "line": 124,
                "column": 31
            },
            "line": 124,
            "code": "      it('should undo a pushAll', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.undo();\n        expect(list.length).toBe(0);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a remove",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#undo()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 30
            },
            "line": 131,
            "code": "      it('should undo a remove', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.remove(0);\n        list.undo();\n        expect(list.length).toBe(2);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a removeRange",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#undo()"
            ],
            "updatePoint": {
                "line": 139,
                "column": 35
            },
            "line": 139,
            "code": "      it('should undo a removeRange', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ]);\n        list.removeRange(1, 3);\n        list.undo();\n        expect(list.length).toBe(6);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a move",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#undo()"
            ],
            "updatePoint": {
                "line": 154,
                "column": 28
            },
            "line": 154,
            "code": "      it('should undo a move', () => {\n        const items = [\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ];\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll(items);\n        list.move(1, 2);\n        list.undo();\n        expect((list.get(1) as any)['count']).toBe((items[1] as any)['count']);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should redo a push",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#redo()"
            ],
            "updatePoint": {
                "line": 169,
                "column": 28
            },
            "line": 169,
            "code": "      it('should redo a push', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(1);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should redo a pushAll",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#redo()"
            ],
            "updatePoint": {
                "line": 177,
                "column": 31
            },
            "line": 177,
            "code": "      it('should redo a pushAll', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(2);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should redo a remove",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#redo()"
            ],
            "updatePoint": {
                "line": 185,
                "column": 30
            },
            "line": 185,
            "code": "      it('should redo a remove', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([serializer.fromJSON(value), serializer.fromJSON(value)]);\n        list.remove(0);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(1);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should redo a removeRange",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#redo()"
            ],
            "updatePoint": {
                "line": 194,
                "column": 35
            },
            "line": 194,
            "code": "      it('should redo a removeRange', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll([\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ]);\n        list.removeRange(1, 3);\n        list.undo();\n        list.redo();\n        expect(list.length).toBe(4);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should undo a move",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#redo()"
            ],
            "updatePoint": {
                "line": 210,
                "column": 28
            },
            "line": 210,
            "code": "      it('should undo a move', () => {\n        const items = [\n          serializer.fromJSON(value),\n          serializer.fromJSON(value),\n          serializer.fromJSON(value)\n        ];\n        const list = new ObservableUndoableList(serializer);\n        list.pushAll(items);\n        list.move(1, 2);\n        list.undo();\n        list.redo();\n        expect((list.get(2) as any)['count']).toBe((items[1] as any)['count']);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should clear the undo stack",
            "suites": [
                "@jupyterlab/observables",
                "ObservableUndoableList",
                "#clearUndo()"
            ],
            "updatePoint": {
                "line": 226,
                "column": 37
            },
            "line": 226,
            "code": "      it('should clear the undo stack', () => {\n        const list = new ObservableUndoableList(serializer);\n        list.push(serializer.fromJSON(value));\n        list.clearUndo();\n        expect(list.canUndo).toBe(false);\n      });",
            "file": "undoablelist.spec.ts",
            "skipped": false,
            "dir": "packages/observables/test"
        },
        {
            "name": "should create an output area model",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 21,
                "column": 44
            },
            "line": 21,
            "code": "      it('should create an output area model', () => {\n        expect(model).toBeInstanceOf(OutputAreaModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 31
            },
            "line": 25,
            "code": "      it('should accept options', () => {\n        const contentFactory = new OutputAreaModel.ContentFactory();\n        model = new OutputAreaModel({\n          values: DEFAULT_OUTPUTS,\n          contentFactory,\n          trusted: true\n        });\n        expect(model.contentFactory).toBe(contentFactory);\n        expect(model.trusted).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be emitted when the model changes",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#changed"
            ],
            "updatePoint": {
                "line": 38,
                "column": 50
            },
            "line": 38,
            "code": "      it('should be emitted when the model changes', () => {\n        let called = false;\n        model.changed.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args.type).toBe('add');\n          expect(args.oldIndex).toBe(-1);\n          expect(args.newIndex).toBe(0);\n          expect(args.oldValues.length).toBe(0);\n          called = true;\n        });\n        model.add(DEFAULT_OUTPUTS[0]);\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be emitted when an item changes",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#stateChanged"
            ],
            "updatePoint": {
                "line": 54,
                "column": 48
            },
            "line": 54,
            "code": "      it('should be emitted when an item changes', () => {\n        let called = false;\n        model.add(DEFAULT_OUTPUTS[0]);\n        model.stateChanged.connect((sender, args) => {\n          expect(sender).toBe(model);\n          expect(args).toEqual(0);\n          called = true;\n        });\n        const output = model.get(0);\n        output.setData({ ...output.data });\n        expect(called).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should get the length of the items in the model",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#length"
            ],
            "updatePoint": {
                "line": 69,
                "column": 57
            },
            "line": 69,
            "code": "      it('should get the length of the items in the model', () => {\n        expect(model.length).toBe(0);\n        model.add(DEFAULT_OUTPUTS[0]);\n        expect(model.length).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be the trusted state of the model",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#trusted"
            ],
            "updatePoint": {
                "line": 77,
                "column": 50
            },
            "line": 77,
            "code": "      it('should be the trusted state of the model', () => {\n        expect(model.trusted).toBe(false);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should cause all of the cells to `set`",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#trusted"
            ],
            "updatePoint": {
                "line": 81,
                "column": 48
            },
            "line": 81,
            "code": "      it('should cause all of the cells to `set`', () => {\n        let called = 0;\n        model.add(DEFAULT_OUTPUTS[0]);\n        model.add(DEFAULT_OUTPUTS[1]);\n        model.changed.connect(() => {\n          called++;\n        });\n        model.trusted = true;\n        expect(called).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be the content factory used by the model",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#contentFactory"
            ],
            "updatePoint": {
                "line": 94,
                "column": 57
            },
            "line": 94,
            "code": "      it('should be the content factory used by the model', () => {\n        expect(model.contentFactory).toBe(\n          OutputAreaModel.defaultContentFactory\n        );\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should test whether the model is disposed",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 102,
                "column": 51
            },
            "line": 102,
            "code": "      it('should test whether the model is disposed', () => {\n        expect(model.isDisposed).toBe(false);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should dispose of the resources used by the model",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 59
            },
            "line": 110,
            "code": "      it('should dispose of the resources used by the model', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n        expect(model.length).toBe(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 117,
                "column": 47
            },
            "line": 117,
            "code": "      it('should be safe to call more than once', () => {\n        model.dispose();\n        model.dispose();\n        expect(model.isDisposed).toBe(true);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should get the item at the specified index",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#get()"
            ],
            "updatePoint": {
                "line": 125,
                "column": 52
            },
            "line": 125,
            "code": "      it('should get the item at the specified index', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        const output = model.get(0);\n        expect(output.type).toBe(DEFAULT_OUTPUTS[0].output_type);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should return `undefined` if out of range",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#get()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 51
            },
            "line": 131,
            "code": "      it('should return `undefined` if out of range', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        expect(model.get(1)).toBeUndefined();\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should add an output",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#add()"
            ],
            "updatePoint": {
                "line": 138,
                "column": 30
            },
            "line": 138,
            "code": "      it('should add an output', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        expect(model.length).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should consolidate consecutive stream outputs of the same kind",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#add()"
            ],
            "updatePoint": {
                "line": 143,
                "column": 72
            },
            "line": 143,
            "code": "      it('should consolidate consecutive stream outputs of the same kind', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        model.add(DEFAULT_OUTPUTS[1]);\n        expect(model.length).toBe(2);\n        model.add(DEFAULT_OUTPUTS[2]);\n        expect(model.length).toBe(2);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should remove carriage returns and backspaces from streams",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#add()"
            ],
            "updatePoint": {
                "line": 151,
                "column": 68
            },
            "line": 151,
            "code": "      it('should remove carriage returns and backspaces from streams', () => {\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['Jupyter\\rj']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter');\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['\\njj\\bupyter']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter\\njupyter');\n        model.add({\n          name: 'stdout',\n          output_type: 'stream',\n          text: ['\\r\\r\\njupyter']\n        });\n        expect(model.get(0).toJSON().text).toBe('jupyter\\njupyter\\njupyter');\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should clear all of the output",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#clear()"
            ],
            "updatePoint": {
                "line": 174,
                "column": 40
            },
            "line": 174,
            "code": "      it('should clear all of the output', () => {\n        for (const output of DEFAULT_OUTPUTS) {\n          model.add(output);\n        }\n        model.clear();\n        expect(model.length).toBe(0);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should wait for next add if requested",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#clear()"
            ],
            "updatePoint": {
                "line": 182,
                "column": 47
            },
            "line": 182,
            "code": "      it('should wait for next add if requested', () => {\n        model.add(DEFAULT_OUTPUTS[0]);\n        model.clear(true);\n        expect(model.length).toBe(1);\n        model.add(DEFAULT_OUTPUTS[1]);\n        expect(model.length).toBe(1);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should disconnect the replaced output",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#set"
            ],
            "updatePoint": {
                "line": 192,
                "column": 47
            },
            "line": 192,
            "code": "      it('should disconnect the replaced output', () => {\n        const model = new OutputAreaModel({\n          values: [DEFAULT_OUTPUTS[0]]\n        });\n\n        const output = model.get(0);\n        let called = false;\n        model.stateChanged.connect((sender, args) => {\n          called = true;\n        });\n\n        model.set(0, DEFAULT_OUTPUTS[1]);\n\n        output.setData({ ...output.data });\n\n        expect(called).toEqual(false);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should deserialize the model from JSON",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#fromJSON()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 48
            },
            "line": 212,
            "code": "      it('should deserialize the model from JSON', () => {\n        model.clear();\n        model.fromJSON(DEFAULT_OUTPUTS);\n        expect(model.toJSON().length).toBe(5);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should serialize the model to JSON",
            "suites": [
                "outputarea/model",
                "OutputAreaModel",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 220,
                "column": 44
            },
            "line": 220,
            "code": "      it('should serialize the model to JSON', () => {\n        expect(model.toJSON()).toEqual([]);\n        model.fromJSON(DEFAULT_OUTPUTS);\n        expect(model.toJSON().length).toBe(5);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should create an output model",
            "suites": [
                "outputarea/model",
                ".ContentFactory",
                "#createOutputModel()"
            ],
            "updatePoint": {
                "line": 230,
                "column": 39
            },
            "line": 230,
            "code": "      it('should create an output model', () => {\n        const factory = new OutputAreaModel.ContentFactory();\n        const model = factory.createOutputModel({\n          value: DEFAULT_OUTPUTS[0]\n        });\n        expect(model).toBeInstanceOf(OutputModel);\n      });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be an instance of ContentFactory",
            "suites": [
                "outputarea/model",
                ".defaultContentFactory"
            ],
            "updatePoint": {
                "line": 241,
                "column": 47
            },
            "line": 241,
            "code": "    it('should be an instance of ContentFactory', () => {\n      expect(OutputAreaModel.defaultContentFactory).toBeInstanceOf(\n        OutputAreaModel.ContentFactory\n      );\n    });",
            "file": "model.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should create an output area widget",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 77,
                "column": 45
            },
            "line": 77,
            "code": "      it('should create an output area widget', () => {\n        expect(widget).toBeInstanceOf(OutputArea);\n        expect(widget.hasClass('jp-OutputArea')).toBe(true);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should take an optional contentFactory",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 48
            },
            "line": 82,
            "code": "      it('should take an optional contentFactory', () => {\n        const contentFactory = Object.create(OutputArea.defaultContentFactory);\n        const widget = new OutputArea({ rendermime, contentFactory, model });\n        expect(widget.contentFactory).toBe(contentFactory);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be the model used by the widget",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#model"
            ],
            "updatePoint": {
                "line": 90,
                "column": 48
            },
            "line": 90,
            "code": "      it('should be the model used by the widget', () => {\n        expect(widget.model).toBe(model);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be the rendermime instance used by the widget",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#rendermime"
            ],
            "updatePoint": {
                "line": 96,
                "column": 62
            },
            "line": 96,
            "code": "      it('should be the rendermime instance used by the widget', () => {\n        expect(widget.rendermime).toBe(rendermime);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be the contentFactory used by the widget",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#contentFactory"
            ],
            "updatePoint": {
                "line": 102,
                "column": 57
            },
            "line": 102,
            "code": "      it('should be the contentFactory used by the widget', () => {\n        expect(widget.contentFactory).toBe(OutputArea.defaultContentFactory);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should control the list of visible outputs",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#maxNumberOutputs"
            ],
            "line": 108,
            "code": "      test.each([20, 6, 5, 2])(\n        'should control the list of visible outputs',\n        maxNumberOutputs => {\n          const widget = new OutputArea({\n            rendermime,\n            model,\n            maxNumberOutputs\n          });\n\n          expect(widget.widgets.length).toBeLessThanOrEqual(\n            maxNumberOutputs + 1\n          );\n\n          if (widget.widgets.length > maxNumberOutputs) {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(\n              widget.widgets[widget.widgets.length - 1].node.textContent\n            ).toContain('Show more outputs');\n          } else {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(\n              widget.widgets[widget.widgets.length - 1].node.textContent\n            ).not.toContain('Show more outputs');\n          }\n        }\n      );",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should display all widgets when clicked",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#maxNumberOutputs"
            ],
            "updatePoint": {
                "line": 135,
                "column": 51
            },
            "line": 135,
            "code": "      test('should display all widgets when clicked', () => {\n        const widget = new OutputArea({\n          rendermime,\n          model,\n          maxNumberOutputs: 2\n        });\n\n        expect(widget.widgets.length).toBeLessThan(model.length);\n        Widget.attach(widget, document.body);\n        simulate(\n          widget.widgets[widget.widgets.length - 1].node.querySelector('a')!,\n          'click'\n        );\n        Widget.detach(widget);\n\n        expect(widget.widgets.length).toEqual(model.length);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should display new widgets if increased",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#maxNumberOutputs"
            ],
            "updatePoint": {
                "line": 153,
                "column": 51
            },
            "line": 153,
            "code": "      test('should display new widgets if increased', () => {\n        const widget = new OutputArea({\n          rendermime,\n          model,\n          maxNumberOutputs: 2\n        });\n        expect(widget.widgets.length).toBeLessThan(model.length);\n\n        widget.maxNumberOutputs += 1;\n\n        expect(widget.widgets.length).toEqual(widget.maxNumberOutputs + 1);\n        expect(widget.widgets.length).toBeLessThan(model.length);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should not change displayed widgets if reduced",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#maxNumberOutputs"
            ],
            "updatePoint": {
                "line": 167,
                "column": 58
            },
            "line": 167,
            "code": "      test('should not change displayed widgets if reduced', () => {\n        const widget = new OutputArea({\n          rendermime,\n          model,\n          maxNumberOutputs: 2\n        });\n        expect(widget.widgets.length).toBeLessThan(model.length);\n\n        widget.maxNumberOutputs -= 1;\n\n        expect(widget.widgets.length).toBeGreaterThan(\n          widget.maxNumberOutputs + 1\n        );\n        expect(widget.widgets.length).toBeLessThan(model.length);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should get the child widget at the specified index",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#widgets"
            ],
            "updatePoint": {
                "line": 185,
                "column": 60
            },
            "line": 185,
            "code": "      it('should get the child widget at the specified index', () => {\n        expect(widget.widgets[0]).toBeInstanceOf(Widget);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should get the number of child widgets",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#widgets"
            ],
            "updatePoint": {
                "line": 189,
                "column": 48
            },
            "line": 189,
            "code": "      it('should get the number of child widgets', () => {\n        expect(widget.widgets.length).toBe(DEFAULT_OUTPUTS.length - 1);\n        widget.model.clear();\n        expect(widget.widgets.length).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should execute code on a kernel and send outputs to the model",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#future"
            ],
            "updatePoint": {
                "line": 210,
                "column": 71
            },
            "line": 210,
            "code": "      it('should execute code on a kernel and send outputs to the model', async () => {\n        const future = sessionContext.session!.kernel!.requestExecute({\n          code: CODE\n        });\n        widget.future = future;\n        const reply = await future.done;\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(reply!.content.status).toBe('ok');\n        expect(model.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should clear existing outputs",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#future"
            ],
            "updatePoint": {
                "line": 221,
                "column": 39
            },
            "line": 221,
            "code": "      it('should clear existing outputs', async () => {\n        widget.model.fromJSON(DEFAULT_OUTPUTS);\n        const future = sessionContext.session!.kernel!.requestExecute({\n          code: CODE\n        });\n        widget.future = future;\n        const reply = await future.done;\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(model.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should handle an added output",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 234,
                "column": 39
            },
            "line": 234,
            "code": "      it('should handle an added output', () => {\n        widget.model.clear();\n        widget.methods = [];\n        widget.model.add(DEFAULT_OUTPUTS[0]);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should handle a clear",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 244,
                "column": 31
            },
            "line": 244,
            "code": "      it('should handle a clear', () => {\n        widget.model.fromJSON(DEFAULT_OUTPUTS);\n        widget.methods = [];\n        widget.model.clear();\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(0);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should handle a set",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 29
            },
            "line": 254,
            "code": "      it('should handle a set', () => {\n        widget.model.clear();\n        widget.model.add(DEFAULT_OUTPUTS[0]);\n        widget.methods = [];\n        widget.model.add(DEFAULT_OUTPUTS[0]);\n        expect(widget.methods).toEqual(\n          expect.arrayContaining(['onModelChanged'])\n        );\n        expect(widget.widgets.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should rerender when preferred mimetype changes",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 265,
                "column": 57
            },
            "line": 265,
            "code": "      it('should rerender when preferred mimetype changes', () => {\n        // Add output with both safe and unsafe types\n        widget.model.clear();\n        widget.model.add({\n          output_type: 'display_data',\n          data: {\n            'image/svg+xml':\n              '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\"></svg>',\n            'text/plain': 'hello, world'\n          },\n          metadata: {}\n        });\n        expect(widget.node.innerHTML).toContain('<img src=\"data:image/svg+xml');\n        widget.model.trusted = !widget.model.trusted;\n        expect(widget.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['<img src=\"data:image/svg+xml'])\n        );\n        widget.model.trusted = !widget.model.trusted;\n        expect(widget.node.innerHTML).toContain('<img src=\"data:image/svg+xml');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should rerender when isolation changes",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                "#onModelChanged()"
            ],
            "updatePoint": {
                "line": 286,
                "column": 48
            },
            "line": 286,
            "code": "      it('should rerender when isolation changes', () => {\n        // Add output with both safe and unsafe types\n        widget.model.clear();\n        widget.model.add({\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          }\n        });\n        expect(widget.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['<iframe'])\n        );\n        widget.model.set(0, {\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          },\n          metadata: {\n            isolated: true\n          }\n        });\n        expect(widget.node.innerHTML).toContain('<iframe');\n        widget.model.set(0, {\n          output_type: 'display_data',\n          data: {\n            'text/plain': 'hello, world'\n          }\n        });\n        expect(widget.node.innerHTML).not.toContain('<iframe');\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should execute code on a kernel and send outputs to the model",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".execute()"
            ],
            "updatePoint": {
                "line": 332,
                "column": 71
            },
            "line": 332,
            "code": "      it('should execute code on a kernel and send outputs to the model', async () => {\n        const reply = await OutputArea.execute(CODE, widget, sessionContext);\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(reply!.content.status).toBe('ok');\n        expect(model.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should clear existing outputs",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".execute()"
            ],
            "updatePoint": {
                "line": 339,
                "column": 39
            },
            "line": 339,
            "code": "      it('should clear existing outputs', async () => {\n        widget.model.fromJSON(DEFAULT_OUTPUTS);\n        const reply = await OutputArea.execute(CODE, widget, sessionContext);\n        expect(reply!.content.execution_count).toBeTruthy();\n        expect(model.length).toBe(1);\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should handle routing of display messages",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".execute()"
            ],
            "updatePoint": {
                "line": 346,
                "column": 51
            },
            "line": 346,
            "code": "      it('should handle routing of display messages', async () => {\n        const model0 = new OutputAreaModel({ trusted: true });\n        const widget0 = new LogOutputArea({ rendermime, model: model0 });\n        const model1 = new OutputAreaModel({ trusted: true });\n        const widget1 = new LogOutputArea({ rendermime, model: model1 });\n        const model2 = new OutputAreaModel({ trusted: true });\n        const widget2 = new LogOutputArea({ rendermime, model: model2 });\n\n        const code0 = [\n          'ip = get_ipython()',\n          'from IPython.display import display',\n          'def display_with_id(obj, display_id, update=False):',\n          '  iopub = ip.kernel.iopub_socket',\n          '  session = get_ipython().kernel.session',\n          '  data, md = ip.display_formatter.format(obj)',\n          '  transient = {\"display_id\": display_id}',\n          '  content = {\"data\": data, \"metadata\": md, \"transient\": transient}',\n          '  msg_type = \"update_display_data\" if update else \"display_data\"',\n          '  session.send(iopub, msg_type, content, parent=ip.parent_header)'\n        ].join('\\n');\n        const code1 = [\n          'display(\"above\")',\n          'display_with_id(1, \"here\")',\n          'display(\"below\")'\n        ].join('\\n');\n        const code2 = [\n          'display_with_id(2, \"here\")',\n          'display_with_id(3, \"there\")',\n          'display_with_id(4, \"here\")'\n        ].join('\\n');\n\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const promise0 = OutputArea.execute(code0, widget0, ipySessionContext);\n        const promise1 = OutputArea.execute(code1, widget1, ipySessionContext);\n        await Promise.all([promise0, promise1]);\n        expect(model1.length).toBe(3);\n        expect(model1.toJSON()[1].data).toEqual({ 'text/plain': '1' });\n        await OutputArea.execute(code2, widget2, ipySessionContext);\n\n        expect(model1.length).toBe(3);\n        expect(model1.toJSON()[1].data).toEqual({ 'text/plain': '4' });\n        expect(model2.length).toBe(3);\n        const outputs = model2.toJSON();\n        expect(outputs[0].data).toEqual({ 'text/plain': '4' });\n        expect(outputs[1].data).toEqual({ 'text/plain': '3' });\n        expect(outputs[2].data).toEqual({ 'text/plain': '4' });\n        await ipySessionContext.shutdown();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should stop on an error",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".execute()"
            ],
            "updatePoint": {
                "line": 399,
                "column": 33
            },
            "line": 399,
            "code": "      it('should stop on an error', async () => {\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const widget1 = new LogOutputArea({ rendermime, model });\n        const future1 = OutputArea.execute('a++1', widget, ipySessionContext);\n        const future2 = OutputArea.execute('a=1', widget1, ipySessionContext);\n        const reply = await future1;\n        const reply2 = await future2;\n        expect(reply!.content.status).toBe('error');\n        expect(reply2!.content.status).toBe('aborted');\n        expect(model.length).toBe(1);\n        widget1.dispose();\n        await ipySessionContext.shutdown();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should allow an error given \"raises-exception\" metadata tag",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".execute()"
            ],
            "updatePoint": {
                "line": 417,
                "column": 69
            },
            "line": 417,
            "code": "      it('should allow an error given \"raises-exception\" metadata tag', async () => {\n        let ipySessionContext: SessionContext;\n        ipySessionContext = await createSessionContext({\n          kernelPreference: { name: 'ipython' }\n        });\n        await ipySessionContext.initialize();\n        const widget1 = new LogOutputArea({ rendermime, model });\n        const metadata = { tags: ['raises-exception'] };\n        const future1 = OutputArea.execute(\n          'a++1',\n          widget,\n          ipySessionContext,\n          metadata\n        );\n        const future2 = OutputArea.execute('a=1', widget1, ipySessionContext);\n        const reply = await future1;\n        const reply2 = await future2;\n        expect(reply!.content.status).toBe('error');\n        expect(reply2!.content.status).toBe('ok');\n        widget1.dispose();\n        await ipySessionContext.shutdown();\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should create an output prompt",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".ContentFactory",
                "#createOutputPrompt()"
            ],
            "updatePoint": {
                "line": 443,
                "column": 42
            },
            "line": 443,
            "code": "        it('should create an output prompt', () => {\n          const factory = new OutputArea.ContentFactory();\n          expect(factory.createOutputPrompt().executionCount).toBeNull();\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should create a stdin widget",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".ContentFactory",
                "#createStdin()"
            ],
            "updatePoint": {
                "line": 450,
                "column": 40
            },
            "line": 450,
            "code": "        it('should create a stdin widget', async () => {\n          const manager = new KernelManager();\n          const kernel = await manager.startNew();\n          const factory = new OutputArea.ContentFactory();\n          const future = kernel.requestExecute({ code: CODE });\n          const options = {\n            parent_header: {\n              date: '',\n              msg_id: '',\n              msg_type: 'input_request' as const,\n              session: '',\n              username: '',\n              version: ''\n            },\n            prompt: 'hello',\n            password: false,\n            future\n          };\n          expect(factory.createStdin(options)).toBeInstanceOf(Widget);\n          await kernel.shutdown();\n          kernel.dispose();\n        });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should be a `contentFactory` instance",
            "suites": [
                "outputarea/widget",
                "OutputArea",
                ".defaultContentFactory"
            ],
            "updatePoint": {
                "line": 476,
                "column": 47
            },
            "line": 476,
            "code": "      it('should be a `contentFactory` instance', () => {\n        expect(OutputArea.defaultContentFactory).toBeInstanceOf(\n          OutputArea.ContentFactory\n        );\n      });",
            "file": "widget.spec.ts",
            "skipped": false,
            "dir": "packages/outputarea/test"
        },
        {
            "name": "should have text related mimeTypes",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 43,
                "column": 44
            },
            "line": 43,
            "code": "      it('should have text related mimeTypes', () => {\n        const mimeTypes = [\n          'text/plain',\n          'application/vnd.jupyter.stdout',\n          'application/vnd.jupyter.stderr'\n        ];\n        expect(textRendererFactory.mimeTypes).toEqual(mimeTypes);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be safe",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 54,
                "column": 24
            },
            "line": 54,
            "code": "      it('should be safe', () => {\n        expect(textRendererFactory.safe).toBe(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should output the correct HTML",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 40
            },
            "line": 60,
            "code": "      it('should output the correct HTML', async () => {\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, 'x = 2 ** a');\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be re-renderable",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 33
            },
            "line": 69,
            "code": "      it('should be re-renderable', async () => {\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, 'x = 2 ** a');\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should output the correct HTML with ansi colors",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "line": 79,
            "code": "      it.each([\n        [\n          'There is no text but \\x1b[01;41;32mtext\\x1b[00m.\\nWoo.',\n          '<pre>There is no text but <span class=\"ansi-green-intense-fg ansi-red-bg ansi-bold\">text</span>.\\nWoo.</pre>'\n        ],\n        [\n          '\\x1b[48;2;185;0;129mwww.example.\\x1b[0m\\x1b[48;2;113;0;119mcom\\x1b[0m',\n          '<pre><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\"><span style=\"background-color:rgb(185,0,129)\">www.example.</span><span style=\"background-color:rgb(113,0,119)\">com</span></a></pre>'\n        ],\n        [\n          'Prefix \\x1b[48;2;185;0;129m spacer www.example.\\x1b[0m\\x1b[48;2;113;0;119mcom\\x1b[0m',\n          '<pre>Prefix <span style=\"background-color:rgb(185,0,129)\"> spacer </span><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\"><span style=\"background-color:rgb(185,0,129)\">www.example.</span><span style=\"background-color:rgb(113,0,119)\">com</span></a></pre>'\n        ],\n        [\n          'Prefix www.example.\\x1b[0m\\x1b[48;2;113;0;119mcom postfix\\x1b[0m',\n          '<pre>Prefix <a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\">www.example.<span style=\"background-color:rgb(113,0,119)\">com</span></a><span style=\"background-color:rgb(113,0,119)\"> postfix</span></pre>'\n        ]\n      ])(\n        'should output the correct HTML with ansi colors',\n        async (source, expected) => {\n          const f = textRendererFactory;\n          const mimeType = 'application/vnd.jupyter.console-text';\n          const model = createModel(mimeType, source);\n          const w = f.createRenderer({ mimeType, ...defaultOptions });\n          await w.renderModel(model);\n          expect(w.node.innerHTML).toBe(expected);\n        }\n      );",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should escape inline html",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 35
            },
            "line": 108,
            "code": "      it('should escape inline html', async () => {\n        const f = textRendererFactory;\n        const source =\n          'There is no text <script>window.x=1</script> but \\x1b[01;41;32mtext\\x1b[00m.\\nWoo.';\n        const mimeType = 'application/vnd.jupyter.console-text';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(\n          '<pre>There is no text &lt;script&gt;window.x=1&lt;/script&gt; but <span class=\"ansi-green-intense-fg ansi-red-bg ansi-bold\">text</span>.\\nWoo.</pre>'\n        );\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should autolink single URL",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 36
            },
            "line": 121,
            "code": "      it('should autolink single URL', async () => {\n        const f = textRendererFactory;\n        const urls = [\n          ['https://example.com', '', ''],\n          ['https://example.com#', '', ''],\n          ['https://example.com/', '', ''],\n          ['www.example.com/', '', ''],\n          ['http://www.quotes.com/foo/', '\"', '\"'],\n          ['http://www.quotes.com/foo/', \"'\", \"'\"],\n          ['http://www.brackets.com/foo', '(', ')'],\n          ['http://www.brackets.com/foo', '{', '}'],\n          ['http://www.brackets.com/foo', '[', ']'],\n          ['http://www.brackets.com/foo', '<', '>'],\n          ['https://ends.with/&gt', '', ''],\n          ['http://www.brackets.com/inv', ')', '('],\n          ['http://www.brackets.com/inv', '}', '{'],\n          ['http://www.brackets.com/inv', ']', '['],\n          ['http://www.brackets.com/inv', '>', '<'],\n          ['https://ends.with/&lt', '', ''],\n          ['http://www.punctuation.com', '', ','],\n          ['http://www.punctuation.com', '', ':'],\n          ['http://www.punctuation.com', '', ';'],\n          ['http://www.punctuation.com', '', '.'],\n          ['http://www.punctuation.com', '', '!'],\n          ['http://www.punctuation.com', '', '?'],\n          ['https://example.com#anchor', '', ''],\n          ['http://localhost:9090/app', '', ''],\n          ['http://localhost:9090/app/', '', ''],\n          ['http://127.0.0.1/test?query=string', '', ''],\n          ['http://127.0.0.1/test?query=string&param=42', '', '']\n        ];\n        await Promise.all(\n          urls.map(async u => {\n            const [url, before, after] = u;\n            const source = `Text with the URL ${before}${url}${after} inside.`;\n            const mimeType = 'text/plain';\n            const model = createModel(mimeType, source);\n            const w = f.createRenderer({ mimeType, ...defaultOptions });\n            const [urlEncoded, beforeEncoded, afterEncoded] = [\n              url,\n              before,\n              after\n            ].map(encodeChars);\n            const prefixedUrl = urlEncoded.startsWith('www.')\n              ? 'https://' + urlEncoded\n              : urlEncoded;\n            await w.renderModel(model);\n            expect(w.node.innerHTML).toBe(\n              `<pre>Text with the URL ${beforeEncoded}<a href=\"${prefixedUrl}\" rel=\"noopener\" target=\"_blank\">${urlEncoded}</a>${afterEncoded} inside.</pre>`\n            );\n          })\n        );\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should not skip autolink",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 175,
                "column": 34
            },
            "line": 175,
            "code": "      it('should not skip autolink', async () => {\n        const source = 'www.example.com';\n        const expected =\n          '<pre><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\">www.example.com</a></pre>';\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, source);\n        sanitizer.setAutolink(true);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(expected);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should skip autolink",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 188,
                "column": 30
            },
            "line": 188,
            "code": "      it('should skip autolink', async () => {\n        const source = 'www.example.com';\n        const expected = '<pre>www.example.com</pre>';\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, source);\n        sanitizer.setAutolink(false);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(expected);\n        sanitizer.setAutolink(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should autolink multiple URLs",
            "suites": [
                "rendermime/factories",
                "textRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 201,
                "column": 39
            },
            "line": 201,
            "code": "      it('should autolink multiple URLs', async () => {\n        const source = 'www.example.com\\nwww.python.org';\n        const expected =\n          '<pre><a href=\"https://www.example.com\" rel=\"noopener\" target=\"_blank\">www.example.com</a>\\n<a href=\"https://www.python.org\" rel=\"noopener\" target=\"_blank\">www.python.org</a></pre>';\n        const f = textRendererFactory;\n        const mimeType = 'text/plain';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(expected);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should have the text/latex mimeType",
            "suites": [
                "rendermime/factories",
                "latexRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 217,
                "column": 45
            },
            "line": 217,
            "code": "      it('should have the text/latex mimeType', () => {\n        expect(latexRendererFactory.mimeTypes).toEqual(['text/latex']);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be safe",
            "suites": [
                "rendermime/factories",
                "latexRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 223,
                "column": 24
            },
            "line": 223,
            "code": "      it('should be safe', () => {\n        expect(latexRendererFactory.safe).toBe(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should set the textContent of the widget",
            "suites": [
                "rendermime/factories",
                "latexRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 229,
                "column": 50
            },
            "line": 229,
            "code": "      it('should set the textContent of the widget', async () => {\n        const source = 'sumlimits_{i=0}^{infty} \\frac{1}{n^2}';\n        const f = latexRendererFactory;\n        const mimeType = 'text/latex';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.textContent).toBe(source);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be re-renderable",
            "suites": [
                "rendermime/factories",
                "latexRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 239,
                "column": 33
            },
            "line": 239,
            "code": "      it('should be re-renderable', async () => {\n        const source = 'sumlimits_{i=0}^{infty} \\frac{1}{n^2}';\n        const f = latexRendererFactory;\n        const mimeType = 'text/latex';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.textContent).toBe(source);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should have the image/svg+xml mimeType",
            "suites": [
                "rendermime/factories",
                "svgRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 254,
                "column": 48
            },
            "line": 254,
            "code": "      it('should have the image/svg+xml mimeType', () => {\n        expect(svgRendererFactory.mimeTypes).toEqual(['image/svg+xml']);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should not be safe",
            "suites": [
                "rendermime/factories",
                "svgRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 260,
                "column": 28
            },
            "line": 260,
            "code": "      it('should not be safe', () => {\n        expect(svgRendererFactory.safe).toBe(false);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should create an img element with the uri encoded svg inline",
            "suites": [
                "rendermime/factories",
                "svgRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 266,
                "column": 70
            },
            "line": 266,
            "code": "      it('should create an img element with the uri encoded svg inline', async () => {\n        const source = '<svg></svg>';\n        const displaySource = '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n        const f = svgRendererFactory;\n        const mimeType = 'image/svg+xml';\n        const model = createModel(mimeType, source, true);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        const imgEl = w.node.getElementsByTagName('img')[0];\n        expect(imgEl).toBeTruthy();\n        expect(imgEl.src).toContain(encodeURIComponent(displaySource));\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should have the text/markdown mimeType",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 283,
                "column": 48
            },
            "line": 283,
            "code": "      it('should have the text/markdown mimeType', function () {\n        expect(markdownRendererFactory.mimeTypes).toEqual(['text/markdown']);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be safe",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 289,
                "column": 24
            },
            "line": 289,
            "code": "      it('should be safe', () => {\n        expect(markdownRendererFactory.safe).toBe(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should set the inner html with no parser",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 303,
                "column": 50
            },
            "line": 303,
            "code": "      it('should set the inner html with no parser', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(`<pre>${source}</pre>`);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should set the inner html with md parser",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 313,
                "column": 50
            },
            "line": 313,
            "code": "      it('should set the inner html with md parser', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({\n          mimeType,\n          ...defaultOptions,\n          markdownParser\n        });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(source);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be re-renderable",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 327,
                "column": 33
            },
            "line": 327,
            "code": "      it('should be re-renderable', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({\n          mimeType,\n          ...defaultOptions,\n          markdownParser\n        });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe(`${source}`);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should add header anchors",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 342,
                "column": 35
            },
            "line": 342,
            "code": "      it('should add header anchors', async () => {\n        const f = markdownRendererFactory;\n        const mimeType = 'text/markdown';\n        const sampleData = '### Title third level';\n\n        const model = createModel(mimeType, sampleData);\n        const w = f.createRenderer({\n          mimeType,\n          ...defaultOptions,\n          markdownParser: { render: content => '<h3>Title third level</h3>' }\n        });\n        await w.renderModel(model);\n        Widget.attach(w, document.body);\n\n        const node = document.getElementById('Title-third-level')!;\n        expect(node.localName).toBe('h3');\n        const anchor = node.firstChild!.nextSibling as HTMLAnchorElement;\n        expect(anchor.href).toContain('#Title-third-level');\n        expect(anchor.target).toBe('_self');\n        expect(anchor.className).toContain('jp-InternalAnchorLink');\n        expect(anchor.textContent).toBe('¶');\n        Widget.detach(w);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should sanitize the html",
            "suites": [
                "rendermime/factories",
                "markdownRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 366,
                "column": 34
            },
            "line": 366,
            "code": "      it('should sanitize the html', async () => {\n        const f = markdownRendererFactory;\n        const source = '<p>hello</p><script>alert(\"foo\")</script>';\n        const mimeType = 'text/markdown';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toEqual(\n          expect.not.arrayContaining(['script'])\n        );\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should have the text/html mimeType",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 382,
                "column": 44
            },
            "line": 382,
            "code": "      it('should have the text/html mimeType', () => {\n        expect(htmlRendererFactory.mimeTypes).toEqual(['text/html']);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be safe",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 388,
                "column": 24
            },
            "line": 388,
            "code": "      it('should be safe', () => {\n        expect(htmlRendererFactory.safe).toBe(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should set the inner HTML",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 394,
                "column": 35
            },
            "line": 394,
            "code": "      it('should set the inner HTML', async () => {\n        const f = htmlRendererFactory;\n        const source = '<h1>This is great</h1>';\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<h1>This is great</h1>');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be re-renderable",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 404,
                "column": 33
            },
            "line": 404,
            "code": "      it('should be re-renderable', async () => {\n        const f = htmlRendererFactory;\n        const source = '<h1>This is great</h1>';\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<h1>This is great</h1>');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should execute a script tag when attached",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#createRenderer()"
            ],
            "line": 416,
            "code": "      it.skip('should execute a script tag when attached', () => {",
            "file": "factories.spec.ts",
            "skipped": true,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should sanitize when untrusted",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 430,
                "column": 40
            },
            "line": 430,
            "code": "      it('should sanitize when untrusted', async () => {\n        const source = '<pre><script>window.y=3;</script></pre>';\n        const f = htmlRendererFactory;\n        const mimeType = 'text/html';\n        const model = createModel(mimeType, source);\n        const w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        expect(w.node.innerHTML).toBe('<pre></pre>');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should sanitize html",
            "suites": [
                "rendermime/factories",
                "htmlRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 441,
                "column": 28
            },
            "line": 441,
            "code": "    it('should sanitize html', async () => {\n      const model = createModel(\n        'text/html',\n        '<h1>foo <script>window.x=1></scrip></h1>'\n      );\n      const f = htmlRendererFactory;\n      const mimeType = 'text/html';\n      const w = f.createRenderer({ mimeType, ...defaultOptions });\n      await w.renderModel(model);\n      expect(w.node.innerHTML).toBe('<h1>foo </h1>');\n    });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should support multiple mimeTypes",
            "suites": [
                "rendermime/factories",
                "imageRendererFactory",
                "#mimeTypes"
            ],
            "updatePoint": {
                "line": 456,
                "column": 43
            },
            "line": 456,
            "code": "      it('should support multiple mimeTypes', () => {\n        expect(imageRendererFactory.mimeTypes).toEqual([\n          'image/bmp',\n          'image/png',\n          'image/jpeg',\n          'image/gif',\n          'image/webp'\n        ]);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be safe",
            "suites": [
                "rendermime/factories",
                "imageRendererFactory",
                "#safe"
            ],
            "updatePoint": {
                "line": 468,
                "column": 24
            },
            "line": 468,
            "code": "      it('should be safe', () => {\n        expect(imageRendererFactory.safe).toBe(true);\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should create an <img> with the right mimeType",
            "suites": [
                "rendermime/factories",
                "imageRendererFactory",
                "#createRenderer()"
            ],
            "updatePoint": {
                "line": 474,
                "column": 56
            },
            "line": 474,
            "code": "      it('should create an <img> with the right mimeType', async () => {\n        let source = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n        const f = imageRendererFactory;\n        let mimeType = 'image/png';\n        let model = createModel(mimeType, source);\n        let w = f.createRenderer({ mimeType, ...defaultOptions });\n\n        await w.renderModel(model);\n        let el = w.node.firstChild as HTMLImageElement;\n        expect(el.src).toBe('data:image/png;base64,' + source);\n        expect(el.localName).toBe('img');\n        expect(el.innerHTML).toBe('');\n\n        source = 'R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=';\n        mimeType = 'image/gif';\n        model = createModel(mimeType, source);\n        w = f.createRenderer({ mimeType, ...defaultOptions });\n        await w.renderModel(model);\n        el = w.node.firstChild as HTMLImageElement;\n        expect(el.src).toBe('data:image/gif;base64,' + source);\n        expect(el.localName).toBe('img');\n        expect(el.innerHTML).toBe('');\n      });",
            "file": "factories.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should split the text into text and math",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 8,
                "column": 48
            },
            "line": 8,
            "code": "    it('should split the text into text and math', () => {\n      const input = 'hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha $']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle code spans",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 15,
                "column": 32
            },
            "line": 15,
            "code": "    it('should handle code spans', () => {\n      const input = '`$foo` and `$bar` are variables';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle fenced code blocks",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 22,
                "column": 40
            },
            "line": 22,
            "code": "    it('should handle fenced code blocks', () => {\n      const input = '```\\n$foo\\n$bar\\n```';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle tilde fenced code blocks",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 46
            },
            "line": 29,
            "code": "    it('should handle tilde fenced code blocks', () => {\n      const input = '~~~\\n$foo\\n$bar\\n~~~';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle long fenced code blocks",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 36,
                "column": 45
            },
            "line": 36,
            "code": "    it('should handle long fenced code blocks', () => {\n      const input = '````\\n$foo\\n$bar\\n```\\n``````';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle fenced code blocks with info string",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 43,
                "column": 57
            },
            "line": 43,
            "code": "    it('should handle fenced code blocks with info string', () => {\n      const input = '```R\\ndata[data$foo > 1 & data$bar < 2,]\\n```';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle math markers",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 34
            },
            "line": 50,
            "code": "    it('should handle math markers', () => {\n      const input = ' @@0@@ hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe(' @@0@@ hello, @@1@@, there');\n      expect(math).toEqual(['@@0@@', '$ /alpha $']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle unbalanced braces",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 39
            },
            "line": 57,
            "code": "    it('should handle unbalanced braces', () => {\n      const input = 'hello, $ /alpha { $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha { $']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle balanced braces",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 64,
                "column": 37
            },
            "line": 64,
            "code": "    it('should handle balanced braces', () => {\n      const input = 'hello, $ /alpha { } $, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$ /alpha { } $']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle math blocks",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 71,
                "column": 33
            },
            "line": 71,
            "code": "    it('should handle math blocks', () => {\n      const input = 'hello, $$\\nfoo\\n$$, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['$$\\nfoo\\n$$']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle begin statements",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 78,
                "column": 38
            },
            "line": 78,
            "code": "    it('should handle begin statements', () => {\n      const input = 'hello, \\\\begin{align} \\\\end{align}, there';\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\begin{align} \\\\end{align}']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle `\\(` delimiters in GFM",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 45
            },
            "line": 85,
            "code": "    it('should handle `\\\\(` delimiters in GFM', () => {\n      const input = `\n      \\`\\`\\`\n        Some \\\\(text\n        \\'\\'\\'\n        **bold**\n        ## header\n      `;\n      const { text, math } = removeMath(input);\n      expect(text).toBe(input);\n      expect(math).toEqual([]);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle `\\\\(` delimiters for math",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 98,
                "column": 49
            },
            "line": 98,
            "code": "    it('should handle `\\\\\\\\(` delimiters for math', () => {\n      const input = `hello, \\\\\\\\\\(\n          /alpha\n      \\\\\\\\\\), there`;\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\\\\\(\\n          /alpha\\n      \\\\\\\\)']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should handle `\\\\[` delimiters for math",
            "suites": [
                "jupyter-ui",
                "removeMath()"
            ],
            "updatePoint": {
                "line": 107,
                "column": 49
            },
            "line": 107,
            "code": "    it('should handle `\\\\\\\\[` delimiters for math', () => {\n      const input = `hello, \\\\\\\\\\[\n          /alpha\n      \\\\\\\\\\], there`;\n      const { text, math } = removeMath(input);\n      expect(text).toBe('hello, @@0@@, there');\n      expect(math).toEqual(['\\\\\\\\[\\n          /alpha\\n      \\\\\\\\]']);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should recombine text split with removeMath",
            "suites": [
                "jupyter-ui",
                "replaceMath()"
            ],
            "updatePoint": {
                "line": 118,
                "column": 51
            },
            "line": 118,
            "code": "    it('should recombine text split with removeMath', () => {\n      const input = 'hello, $ /alpha $, there';\n      const { text, math } = removeMath(input);\n      expect(replaceMath(text, math)).toBe(input);\n    });",
            "file": "latex.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should create a new mime model",
            "suites": [
                "rendermime/mimemodel",
                "MimeModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 40
            },
            "line": 9,
            "code": "      it('should create a new mime model', () => {\n        const model = new MimeModel();\n        expect(model).toBeInstanceOf(MimeModel);\n      });",
            "file": "mimemodel.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should accept arguments",
            "suites": [
                "rendermime/mimemodel",
                "MimeModel",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 33
            },
            "line": 14,
            "code": "      it('should accept arguments', () => {\n        const model = new MimeModel({\n          data: { foo: 1 },\n          metadata: { bar: 'baz' }\n        });\n        expect(model).toBeInstanceOf(MimeModel);\n      });",
            "file": "mimemodel.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be the data observable map",
            "suites": [
                "rendermime/mimemodel",
                "MimeModel",
                "#data"
            ],
            "updatePoint": {
                "line": 24,
                "column": 43
            },
            "line": 24,
            "code": "      it('should be the data observable map', () => {\n        const model = new MimeModel({\n          data: { bar: 'baz' }\n        });\n        expect(model.data['bar']).toBe('baz');\n      });",
            "file": "mimemodel.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should be the metadata observable map",
            "suites": [
                "rendermime/mimemodel",
                "MimeModel",
                "#metadata"
            ],
            "updatePoint": {
                "line": 33,
                "column": 47
            },
            "line": 33,
            "code": "      it('should be the metadata observable map', () => {\n        const model = new MimeModel({\n          metadata: { bar: 'baz' }\n        });\n        expect(model.metadata['bar']).toBe('baz');\n      });",
            "file": "mimemodel.spec.ts",
            "skipped": false,
            "dir": "packages/rendermime/test"
        },
        {
            "name": "should load a config",
            "suites": [
                "config",
                "ConfigSection.create()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 28
            },
            "line": 33,
            "code": "    it('should load a config', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      expect(Object.keys(config.data).length).toBe(0);\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "config",
                "ConfigSection.create()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 37
            },
            "line": 38,
            "code": "    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const config = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      expect(Object.keys(config.data).length).toBe(0);\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "config",
                "ConfigSection.create()"
            ],
            "updatePoint": {
                "line": 47,
                "column": 45
            },
            "line": 47,
            "code": "    it('should fail for an incorrect response', async () => {\n      const serverSettings = getRequestHandler(201, {});\n      const configPromise = ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      await expect(configPromise).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update a config",
            "suites": [
                "config",
                "#update()"
            ],
            "updatePoint": {
                "line": 60,
                "column": 30
            },
            "line": 60,
            "code": "    it('should update a config', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      const data: any = await config.update({ foo: 'baz', spam: 'eggs' });\n      expect(data.foo).toBe('baz');\n      expect(config.data['foo']).toBe('baz');\n      expect(data['spam']).toBe('eggs');\n      expect(config.data['spam']).toBe('eggs');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "config",
                "#update()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 37
            },
            "line": 69,
            "code": "    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const config = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      const data: any = await config.update({ foo: 'baz', spam: 'eggs' });\n      expect(data.foo).toBe('baz');\n      expect(config.data['foo']).toBe('baz');\n      expect(data['spam']).toBe('eggs');\n      expect(config.data['spam']).toBe('eggs');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "config",
                "#update()"
            ],
            "updatePoint": {
                "line": 82,
                "column": 45
            },
            "line": 82,
            "code": "    it('should fail for an incorrect response', async () => {\n      const config = await ConfigSection.create({ name: randomName() });\n      handleRequest(config, 201, {});\n      const update = config.update({ foo: 'baz' });\n      await expect(update).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should complete properly",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 93,
                "column": 32
            },
            "line": 93,
            "code": "    it('should complete properly', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      expect(config).toBeInstanceOf(ConfigWithDefaults);\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a new config value",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#get()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 37
            },
            "line": 109,
            "code": "    it('should get a new config value', async () => {\n      const defaults: JSONObject = { foo: 'bar' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('foo');\n      expect(data).toBe('bar');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a default config value",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#get()"
            ],
            "updatePoint": {
                "line": 124,
                "column": 41
            },
            "line": 124,
            "code": "    it('should get a default config value', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('spam');\n      expect(data).toBe('eggs');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a default config value with no class",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#get()"
            ],
            "updatePoint": {
                "line": 139,
                "column": 55
            },
            "line": 139,
            "code": "    it('should get a default config value with no class', async () => {\n      const defaults: JSONObject = { spam: 'eggs' };\n      const className = 'testclass';\n      const section = await ConfigSection.create({\n        name: randomName()\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('spam');\n      expect(data).toBe('eggs');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a falsey value",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#get()"
            ],
            "updatePoint": {
                "line": 154,
                "column": 33
            },
            "line": 154,
            "code": "    it('should get a falsey value', async () => {\n      const defaults: JSONObject = { foo: true };\n      const className = 'testclass';\n      const serverSettings = getRequestHandler(200, { foo: false });\n      const section = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      const config = new ConfigWithDefaults({\n        section,\n        defaults,\n        className\n      });\n      const data = config.get('foo');\n      expect(data).toBeFalsy();\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set a value in a class immediately",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#set()"
            ],
            "updatePoint": {
                "line": 173,
                "column": 49
            },
            "line": 173,
            "code": "    it('should set a value in a class immediately', async () => {\n      const className = 'testclass';\n      const section = await ConfigSection.create({ name: randomName() });\n      const config = new ConfigWithDefaults({ section, className });\n      let data: any = await config.set('foo', 'bar');\n      data = section.data['testclass'] as JSONObject;\n      expect(data['foo']).toBe('bar');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set a top level value",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#set()"
            ],
            "updatePoint": {
                "line": 182,
                "column": 36
            },
            "line": 182,
            "code": "    it('should set a top level value', async () => {\n      const section = await ConfigSection.create({ name: randomName() });\n      const config = new ConfigWithDefaults({ section });\n      const set = config.set('foo', 'bar');\n      expect(section.data['foo']).toBe('bar');\n      await set;\n      expect(section.data['foo']).toBe('bar');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an invalid response",
            "suites": [
                "jupyter.services - ConfigWithDefaults",
                "#set()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 43
            },
            "line": 191,
            "code": "    it('should fail for an invalid response', async () => {\n      const serverSettings = getRequestHandler(200, {});\n      const section = await ConfigSection.create({\n        name: randomName(),\n        serverSettings\n      });\n      handleRequest(section, 201, { foo: 'bar' });\n      const config = new ConfigWithDefaults({ section });\n      const set = config.set('foo', 'bar');\n      expect(section.data['foo']).toBe('bar');\n      await expectFailure(set, 'Invalid response: 201 Created');\n    });",
            "file": "config/config.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "contents",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 52,
                "column": 32
            },
            "line": 52,
            "code": "    it('should accept no options', () => {\n      const contents = new ContentsManager();\n      expect(contents).toBeInstanceOf(ContentsManager);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "contents",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 29
            },
            "line": 57,
            "code": "    it('should accept options', () => {\n      const contents = new ContentsManager({\n        defaultDrive: new Drive()\n      });\n      expect(contents).toBeInstanceOf(ContentsManager);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a file changes",
            "suites": [
                "contents",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 66,
                "column": 45
            },
            "line": 66,
            "code": "    it('should be emitted when a file changes', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(sender).toBe(contents);\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled();\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should include the full path for additional drives",
            "suites": [
                "contents",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 80,
                "column": 58
            },
            "line": 80,
            "code": "    it('should include the full path for additional drives', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.newValue!.path).toBe('other:' + DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled({ path: 'other:' });\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is disposed",
            "suites": [
                "contents",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 95,
                "column": 51
            },
            "line": 95,
            "code": "    it('should test whether the manager is disposed', () => {\n      expect(contents.isDisposed).toBe(false);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources used by the manager",
            "suites": [
                "contents",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 59
            },
            "line": 103,
            "code": "    it('should dispose of the resources used by the manager', () => {\n      expect(contents.isDisposed).toBe(false);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n      contents.dispose();\n      expect(contents.isDisposed).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should add a new drive to the manager",
            "suites": [
                "contents",
                "#addDrive()"
            ],
            "updatePoint": {
                "line": 113,
                "column": 45
            },
            "line": 113,
            "code": "    it('should add a new drive to the manager', async () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      handleRequest(contents, 200, DEFAULT_FILE);\n      await expect(contents.get('other:')).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should parse the local part of a path",
            "suites": [
                "contents",
                "#localPath()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 45
            },
            "line": 121,
            "code": "    it('should parse the local part of a path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      contents.addDrive(new Drive({ name: 'alternative' }));\n\n      expect(contents.localPath('other:foo/bar/example.txt')).toBe(\n        'foo/bar/example.txt'\n      );\n\n      expect(contents.localPath('alternative:/foo/bar/example.txt')).toBe(\n        'foo/bar/example.txt'\n      );\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should allow the \":\" character in other parts of the path",
            "suites": [
                "contents",
                "#localPath()"
            ],
            "updatePoint": {
                "line": 134,
                "column": 65
            },
            "line": 134,
            "code": "    it('should allow the \":\" character in other parts of the path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.localPath('other:foo/odd:directory/example:file.txt')\n      ).toBe('foo/odd:directory/example:file.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should leave alone names with \":\" that are not drive names",
            "suites": [
                "contents",
                "#localPath()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 66
            },
            "line": 142,
            "code": "    it('should leave alone names with \":\" that are not drive names', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.localPath('which:foo/odd:directory/example:file.txt')\n      ).toBe('which:foo/odd:directory/example:file.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not prepend root path to an absolute path",
            "suites": [
                "contents",
                "#resolvePath"
            ],
            "updatePoint": {
                "line": 162,
                "column": 56
            },
            "line": 162,
            "code": "    it('should not prepend root path to an absolute path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(root, testPathAbs);\n      expect(result).toBe(testPath);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not have any affect on path relative to empty root",
            "suites": [
                "contents",
                "#resolvePath"
            ],
            "updatePoint": {
                "line": 169,
                "column": 65
            },
            "line": 169,
            "code": "    it('should not have any affect on path relative to empty root', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootEmpty, testPath);\n      expect(result).toBe(testPath);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not have any affect on path relative to \"/\"",
            "suites": [
                "contents",
                "#resolvePath"
            ],
            "updatePoint": {
                "line": 176,
                "column": 58
            },
            "line": 176,
            "code": "    it('should not have any affect on path relative to \"/\"', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootSlash, testPath);\n      expect(result).toBe(testPath);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should join root drive, root path, and path",
            "suites": [
                "contents",
                "#resolvePath"
            ],
            "updatePoint": {
                "line": 183,
                "column": 51
            },
            "line": 183,
            "code": "    it('should join root drive, root path, and path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootDrive, testPath);\n      expect(result).toBe(`${rootDrive}/${testPath}`);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should remove all leading slashes from result path",
            "suites": [
                "contents",
                "#resolvePath"
            ],
            "updatePoint": {
                "line": 190,
                "column": 58
            },
            "line": 190,
            "code": "    it('should remove all leading slashes from result path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      let result = contents.resolvePath(rootDriveAbs, testPath);\n      expect(result).toBe(`${rootDrive}/${testPath}`);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should parse the drive name a path",
            "suites": [
                "contents",
                "#driveName()"
            ],
            "updatePoint": {
                "line": 199,
                "column": 42
            },
            "line": 199,
            "code": "    it('should parse the drive name a path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n      contents.addDrive(new Drive({ name: 'alternative' }));\n\n      expect(contents.driveName('other:foo/bar/example.txt')).toBe('other');\n\n      expect(contents.driveName('alternative:/foo/bar/example.txt')).toBe(\n        'alternative'\n      );\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should allow the \":\" character in other parts of the path",
            "suites": [
                "contents",
                "#driveName()"
            ],
            "updatePoint": {
                "line": 210,
                "column": 65
            },
            "line": 210,
            "code": "    it('should allow the \":\" character in other parts of the path', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.driveName('other:foo/odd:directory/example:file.txt')\n      ).toBe('other');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should leave alone names with \":\" that are not drive names",
            "suites": [
                "contents",
                "#driveName()"
            ],
            "updatePoint": {
                "line": 218,
                "column": 66
            },
            "line": 218,
            "code": "    it('should leave alone names with \":\" that are not drive names', () => {\n      contents.addDrive(new Drive({ name: 'other' }));\n\n      expect(\n        contents.driveName('which:foo/odd:directory/example:file.txt')\n      ).toBe('');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a file",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 228,
                "column": 25
            },
            "line": 228,
            "code": "    it('should get a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const model = await contents.get('/foo', options);\n      expect(model.path).toBe('foo');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a directory",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 235,
                "column": 30
            },
            "line": 235,
            "code": "    it('should get a directory', async () => {\n      handleRequest(contents, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const model = await contents.get('/foo', options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a file from an additional drive",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 242,
                "column": 50
            },
            "line": 242,
            "code": "    it('should get a file from an additional drive', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.path).toBe('other:foo');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a directory from an additional drive",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 251,
                "column": 55
            },
            "line": 251,
            "code": "    it('should get a directory from an additional drive', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.content[0].path).toBe('other:foo/bar/buzz.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 260,
                "column": 45
            },
            "line": 260,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, DEFAULT_DIR);\n      const get = contents.get('/foo');\n      await expect(get).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should store original server path for directory",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 266,
                "column": 55
            },
            "line": 266,
            "code": "    it('should store original server path for directory', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.serverPath).toBe('foo/bar');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should store original server path for a file",
            "suites": [
                "contents",
                "#get()"
            ],
            "updatePoint": {
                "line": 275,
                "column": 52
            },
            "line": 275,
            "code": "    it('should store original server path for a file', async () => {\n      const drive = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(drive);\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const model = await contents.get('other:/foo', options);\n      expect(model.serverPath).toBe('foo/test');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the url of a file",
            "suites": [
                "contents",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 290,
                "column": 36
            },
            "line": 290,
            "code": "    it('should get the url of a file', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const test1 = contents.getDownloadUrl('bar.txt');\n      const test2 = contents.getDownloadUrl('fizz/buzz/bar.txt');\n      const test3 = contents.getDownloadUrl('/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should encode characters",
            "suites": [
                "contents",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 302,
                "column": 32
            },
            "line": 302,
            "code": "    it('should encode characters', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const url = await contents.getDownloadUrl('b ar?3.txt');\n      expect(url).toBe('http://foo/files/b%20ar%3F3.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle relative paths",
            "suites": [
                "contents",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 309,
                "column": 36
            },
            "line": 309,
            "code": "    it('should handle relative paths', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const contents = new ContentsManager({ defaultDrive: drive });\n      const url = await contents.getDownloadUrl('fizz/../bar.txt');\n      expect(url).toBe('http://foo/files/bar.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the url of a file from an additional drive",
            "suites": [
                "contents",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 316,
                "column": 61
            },
            "line": 316,
            "code": "    it('should get the url of a file from an additional drive', async () => {\n      const contents = new ContentsManager();\n      const other = new Drive({ name: 'other', serverSettings: settings });\n      contents.addDrive(other);\n      const test1 = contents.getDownloadUrl('other:bar.txt');\n      const test2 = contents.getDownloadUrl('other:fizz/buzz/bar.txt');\n      const test3 = contents.getDownloadUrl('other:/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a file",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 331,
                "column": 28
            },
            "line": 331,
            "code": "    it('should create a file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const model = await contents.newUntitled({ path: '/foo' });\n      expect(model.path).toBe('foo/test');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a directory",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 337,
                "column": 33
            },
            "line": 337,
            "code": "    it('should create a directory', async () => {\n      handleRequest(contents, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'directory'\n      };\n      const model = await contents.newUntitled(options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a file on an additional drive",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 347,
                "column": 51
            },
            "line": 347,
            "code": "    it('should create a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_FILE);\n      const model = await contents.newUntitled({ path: 'other:/foo' });\n      expect(model.path).toBe('other:foo/test');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a directory on an additional drive",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 355,
                "column": 56
            },
            "line": 355,
            "code": "    it('should create a directory on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: 'other:/foo',\n        type: 'directory'\n      };\n      const model = await contents.newUntitled(options);\n      expect(model.path).toBe('other:' + DEFAULT_DIR.path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 367,
                "column": 42
            },
            "line": 367,
            "code": "    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.newUntitled({ type: 'file', ext: 'test' });\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 380,
                "column": 42
            },
            "line": 380,
            "code": "    it('should fail for an incorrect model', async () => {\n      const dir = JSON.parse(JSON.stringify(DEFAULT_DIR));\n      dir.name = 1;\n      handleRequest(contents, 201, dir);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'py'\n      };\n      const newFile = contents.newUntitled(options);\n      await expect(newFile).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 393,
                "column": 45
            },
            "line": 393,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_DIR);\n      const newDir = contents.newUntitled();\n      await expect(newDir).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a file",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 401,
                "column": 28
            },
            "line": 401,
            "code": "    it('should delete a file', async () => {\n      handleRequest(contents, 204, {});\n      await expect(contents.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a file on an additional drive",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 406,
                "column": 51
            },
            "line": 406,
            "code": "    it('should delete a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      await expect(\n        contents.delete('other:/foo/bar.txt')\n      ).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 415,
                "column": 42
            },
            "line": 415,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const path = '/foo/bar.txt';\n      handleRequest(contents, 204, { path });\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('delete');\n        expect(args.oldValue!.path).toBe('foo/bar.txt');\n        called = true;\n      });\n      await contents.delete(path);\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 428,
                "column": 45
            },
            "line": 428,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const del = contents.delete('/foo/bar.txt');\n      await expect(del).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw a specific error",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 434,
                "column": 37
            },
            "line": 434,
            "code": "    it('should throw a specific error', async () => {\n      handleRequest(contents, 400, {});\n      const del = contents.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw a general error",
            "suites": [
                "contents",
                "#delete()"
            ],
            "updatePoint": {
                "line": 440,
                "column": 36
            },
            "line": 440,
            "code": "    it('should throw a general error', async () => {\n      handleRequest(contents, 500, {});\n      const del = contents.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should rename a file",
            "suites": [
                "contents",
                "#rename()"
            ],
            "updatePoint": {
                "line": 448,
                "column": 28
            },
            "line": 448,
            "code": "    it('should rename a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should rename a file on an additional drive",
            "suites": [
                "contents",
                "#rename()"
            ],
            "updatePoint": {
                "line": 455,
                "column": 51
            },
            "line": 455,
            "code": "    it('should rename a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 200, DEFAULT_FILE);\n      const rename = contents.rename(\n        'other:/foo/bar.txt',\n        'other:/foo/baz.txt'\n      );\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "contents",
                "#rename()"
            ],
            "updatePoint": {
                "line": 467,
                "column": 42
            },
            "line": 467,
            "code": "    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('rename');\n        expect(args.oldValue!.path).toBe('foo/bar.txt');\n        expect(args.newValue!.path).toBe('foo/test');\n        called = true;\n      });\n      await contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#rename()"
            ],
            "updatePoint": {
                "line": 480,
                "column": 42
            },
            "line": 480,
            "code": "    it('should fail for an incorrect model', async () => {\n      const dir = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete dir.path;\n      handleRequest(contents, 200, dir);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#rename()"
            ],
            "updatePoint": {
                "line": 488,
                "column": 45
            },
            "line": 488,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const rename = contents.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save a file",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 496,
                "column": 26
            },
            "line": 496,
            "code": "    it('should save a file', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save a file on an additional drive",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 503,
                "column": 49
            },
            "line": 503,
            "code": "    it('should save a file on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const save = contents.save('other:/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.path).toBe('other:foo');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new file",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 512,
                "column": 32
            },
            "line": 512,
            "code": "    it('should create a new file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 519,
                "column": 42
            },
            "line": 519,
            "code": "    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('save');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.save('/foo', { type: 'file', name: 'test' });\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 532,
                "column": 42
            },
            "line": 532,
            "code": "    it('should fail for an incorrect model', async () => {\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.format;\n      handleRequest(contents, 200, file);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#save()"
            ],
            "updatePoint": {
                "line": 540,
                "column": 45
            },
            "line": 540,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 204, DEFAULT_FILE);\n      const save = contents.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow(/Invalid response: 204 No Content/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should copy a file",
            "suites": [
                "contents",
                "#copy()"
            ],
            "updatePoint": {
                "line": 548,
                "column": 26
            },
            "line": 548,
            "code": "    it('should copy a file', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      const model = await contents.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should copy a file on an additional drive",
            "suites": [
                "contents",
                "#copy()"
            ],
            "updatePoint": {
                "line": 554,
                "column": 49
            },
            "line": 554,
            "code": "    it('should copy a file on an additional drive', async () => {\n      const other = new Drive({ serverSettings, name: 'other' });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_FILE);\n      const model = await contents.copy('other:/foo/test', 'other:/baz');\n      expect(model.path).toBe('other:foo/test');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "contents",
                "#copy()"
            ],
            "updatePoint": {
                "line": 562,
                "column": 42
            },
            "line": 562,
            "code": "    it('should emit the fileChanged signal', async () => {\n      handleRequest(contents, 201, DEFAULT_FILE);\n      let called = false;\n      contents.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await contents.copy('/foo/bar.txt', '/baz');\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#copy()"
            ],
            "updatePoint": {
                "line": 575,
                "column": 42
            },
            "line": 575,
            "code": "    it('should fail for an incorrect model', async () => {\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.type;\n      handleRequest(contents, 201, file);\n      const copy = contents.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#copy()"
            ],
            "updatePoint": {
                "line": 583,
                "column": 45
            },
            "line": 583,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_FILE);\n      const copy = contents.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a checkpoint",
            "suites": [
                "contents",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 591,
                "column": 34
            },
            "line": 591,
            "code": "    it('should create a checkpoint', async () => {\n      handleRequest(contents, 201, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a checkpoint on an additional drive",
            "suites": [
                "contents",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 598,
                "column": 57
            },
            "line": 598,
            "code": "    it('should create a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 201, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('other:/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 607,
                "column": 42
            },
            "line": 607,
            "code": "    it('should fail for an incorrect model', async () => {\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.last_modified;\n      handleRequest(contents, 201, cp);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 615,
                "column": 45
            },
            "line": 615,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, DEFAULT_CP);\n      const checkpoint = contents.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should list the checkpoints",
            "suites": [
                "contents",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 623,
                "column": 35
            },
            "line": 623,
            "code": "    it('should list the checkpoints', async () => {\n      handleRequest(contents, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should list the checkpoints on an additional drive",
            "suites": [
                "contents",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 630,
                "column": 58
            },
            "line": 630,
            "code": "    it('should list the checkpoints on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('other:/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "contents",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 639,
                "column": 42
            },
            "line": 639,
            "code": "    it('should fail for an incorrect model', async () => {\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.id;\n      handleRequest(contents, 200, [cp, DEFAULT_CP]);\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expectFailure(checkpoints);\n      handleRequest(contents, 200, DEFAULT_CP);\n      const newCheckpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expect(newCheckpoints).rejects.toThrow(/Invalid Checkpoint list/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 650,
                "column": 45
            },
            "line": 650,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 201, {});\n      const checkpoints = contents.listCheckpoints('/foo/bar.txt');\n      await expect(checkpoints).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should restore a checkpoint",
            "suites": [
                "contents",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 660,
                "column": 35
            },
            "line": 660,
            "code": "    it('should restore a checkpoint', async () => {\n      handleRequest(contents, 204, {});\n      const checkpoint = contents.restoreCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should restore a checkpoint on an additional drive",
            "suites": [
                "contents",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 669,
                "column": 58
            },
            "line": 669,
            "code": "    it('should restore a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      const checkpoint = contents.restoreCheckpoint(\n        'other:/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 680,
                "column": 45
            },
            "line": 680,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const checkpoint = contents.restoreCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a checkpoint",
            "suites": [
                "contents",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 691,
                "column": 34
            },
            "line": 691,
            "code": "    it('should delete a checkpoint', async () => {\n      handleRequest(contents, 204, {});\n      await expect(\n        contents.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a checkpoint on an additional drive",
            "suites": [
                "contents",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 698,
                "column": 57
            },
            "line": 698,
            "code": "    it('should delete a checkpoint on an additional drive', async () => {\n      const other = new Drive({ name: 'other', serverSettings });\n      contents.addDrive(other);\n      handleRequest(other, 204, {});\n      await expect(\n        contents.deleteCheckpoint('other:/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "contents",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 707,
                "column": 45
            },
            "line": 707,
            "code": "    it('should fail for an incorrect response', async () => {\n      handleRequest(contents, 200, {});\n      const checkpoint = contents.deleteCheckpoint(\n        '/foo/bar.txt',\n        DEFAULT_CP.id\n      );\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "drive",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 733,
                "column": 32
            },
            "line": 733,
            "code": "    it('should accept no options', () => {\n      const drive = new Drive();\n      expect(drive).toBeInstanceOf(Drive);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "drive",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 738,
                "column": 29
            },
            "line": 738,
            "code": "    it('should accept options', () => {\n      const drive = new Drive({\n        name: 'name'\n      });\n      expect(drive).toBeInstanceOf(Drive);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should return the name of the drive",
            "suites": [
                "drive",
                "#name"
            ],
            "updatePoint": {
                "line": 747,
                "column": 43
            },
            "line": 747,
            "code": "    it('should return the name of the drive', () => {\n      const drive = new Drive({\n        name: 'name'\n      });\n      expect(drive.name).toBe('name');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a file changes",
            "suites": [
                "drive",
                "#fileChanged"
            ],
            "updatePoint": {
                "line": 756,
                "column": 45
            },
            "line": 756,
            "code": "    it('should be emitted when a file changes', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(sender).toBe(drive);\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.newUntitled();\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the drive is disposed",
            "suites": [
                "drive",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 773,
                "column": 49
            },
            "line": 773,
            "code": "    it('should test whether the drive is disposed', () => {\n      const drive = new Drive();\n      expect(drive.isDisposed).toBe(false);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources used by the drive",
            "suites": [
                "drive",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 782,
                "column": 57
            },
            "line": 782,
            "code": "    it('should dispose of the resources used by the drive', () => {\n      const drive = new Drive();\n      expect(drive.isDisposed).toBe(false);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n      drive.dispose();\n      expect(drive.isDisposed).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a file",
            "suites": [
                "drive",
                "#get()"
            ],
            "updatePoint": {
                "line": 793,
                "column": 25
            },
            "line": 793,
            "code": "    it('should get a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const options: Contents.IFetchOptions = { type: 'file' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.path).toBe(DEFAULT_FILE.path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a directory",
            "suites": [
                "drive",
                "#get()"
            ],
            "updatePoint": {
                "line": 802,
                "column": 30
            },
            "line": 802,
            "code": "    it('should get a directory', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#get()"
            ],
            "updatePoint": {
                "line": 811,
                "column": 37
            },
            "line": 811,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const options: Contents.IFetchOptions = { type: 'directory' };\n      const get = drive.get('/foo', options);\n      const model = await get;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#get()"
            ],
            "updatePoint": {
                "line": 820,
                "column": 45
            },
            "line": 820,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const get = drive.get('/foo');\n      await expect(get).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the url of a file",
            "suites": [
                "drive",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 833,
                "column": 36
            },
            "line": 833,
            "code": "    it('should get the url of a file', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const test1 = drive.getDownloadUrl('bar.txt');\n      const test2 = drive.getDownloadUrl('fizz/buzz/bar.txt');\n      const test3 = drive.getDownloadUrl('/bar.txt');\n      const urls = await Promise.all([test1, test2, test3]);\n      expect(urls[0]).toBe('http://foo/files/bar.txt');\n      expect(urls[1]).toBe('http://foo/files/fizz/buzz/bar.txt');\n      expect(urls[2]).toBe('http://foo/files/bar.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should encode characters",
            "suites": [
                "drive",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 844,
                "column": 32
            },
            "line": 844,
            "code": "    it('should encode characters', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const url = await drive.getDownloadUrl('b ar?3.txt');\n      expect(url).toBe('http://foo/files/b%20ar%3F3.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle relative paths",
            "suites": [
                "drive",
                "#getDownloadUrl()"
            ],
            "updatePoint": {
                "line": 850,
                "column": 36
            },
            "line": 850,
            "code": "    it('should handle relative paths', async () => {\n      const drive = new Drive({ serverSettings: settings });\n      const url = await drive.getDownloadUrl('fizz/../bar.txt');\n      expect(url).toBe('http://foo/files/bar.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a file",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 858,
                "column": 28
            },
            "line": 858,
            "code": "    it('should create a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.newUntitled({ path: '/foo' });\n      expect(model.path).toBe(DEFAULT_FILE.path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a directory",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 865,
                "column": 33
            },
            "line": 865,
            "code": "    it('should create a directory', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'directory'\n      };\n      const newDir = drive.newUntitled(options);\n      const model = await newDir;\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 877,
                "column": 42
            },
            "line": 877,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.newUntitled({ type: 'file', ext: 'test' });\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 891,
                "column": 37
            },
            "line": 891,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_DIR);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'txt'\n      };\n      const model = await drive.newUntitled(options);\n      expect(model.content[0].path).toBe(DEFAULT_DIR.content[0].path);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 903,
                "column": 42
            },
            "line": 903,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const dir = JSON.parse(JSON.stringify(DEFAULT_DIR));\n      dir.name = 1;\n      handleRequest(drive, 201, dir);\n      const options: Contents.ICreateOptions = {\n        path: '/foo',\n        type: 'file',\n        ext: 'py'\n      };\n      const newFile = drive.newUntitled(options);\n      await expect(newFile).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#newUntitled()"
            ],
            "updatePoint": {
                "line": 917,
                "column": 45
            },
            "line": 917,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_DIR);\n      const newDir = drive.newUntitled();\n      await expect(newDir).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a file",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 926,
                "column": 28
            },
            "line": 926,
            "code": "    it('should delete a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      await expect(drive.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 932,
                "column": 42
            },
            "line": 932,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      const path = '/foo/bar.txt';\n      handleRequest(drive, 204, { path });\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('delete');\n        expect(args.oldValue!.path).toBe('/foo/bar.txt');\n        called = true;\n      });\n      await drive.delete(path);\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 946,
                "column": 37
            },
            "line": 946,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      await expect(drive.delete('/foo/bar.txt')).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 952,
                "column": 45
            },
            "line": 952,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const del = drive.delete('/foo/bar.txt');\n      await expect(del).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw a specific error",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 959,
                "column": 37
            },
            "line": 959,
            "code": "    it('should throw a specific error', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 400, {});\n      const del = drive.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw a general error",
            "suites": [
                "drive",
                "#delete()"
            ],
            "updatePoint": {
                "line": 966,
                "column": 36
            },
            "line": 966,
            "code": "    it('should throw a general error', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 500, {});\n      const del = drive.delete('/foo/');\n      await expect(del).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should rename a file",
            "suites": [
                "drive",
                "#rename()"
            ],
            "updatePoint": {
                "line": 975,
                "column": 28
            },
            "line": 975,
            "code": "    it('should rename a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "drive",
                "#rename()"
            ],
            "updatePoint": {
                "line": 983,
                "column": 42
            },
            "line": 983,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('rename');\n        expect(args.oldValue!.path).toBe('/foo/bar.txt');\n        expect(args.newValue!.path).toBe('foo/test');\n        called = true;\n      });\n      await drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#rename()"
            ],
            "updatePoint": {
                "line": 997,
                "column": 37
            },
            "line": 997,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      const model = await rename;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#rename()"
            ],
            "updatePoint": {
                "line": 1005,
                "column": 42
            },
            "line": 1005,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const dir = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete dir.path;\n      handleRequest(drive, 200, dir);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#rename()"
            ],
            "updatePoint": {
                "line": 1014,
                "column": 45
            },
            "line": 1014,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const rename = drive.rename('/foo/bar.txt', '/foo/baz.txt');\n      await expect(rename).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save a file",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1023,
                "column": 26
            },
            "line": 1023,
            "code": "    it('should save a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new file",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1031,
                "column": 32
            },
            "line": 1031,
            "code": "    it('should create a new file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1039,
                "column": 42
            },
            "line": 1039,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('save');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.save('/foo', { type: 'file', name: 'test' });\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1053,
                "column": 37
            },
            "line": 1053,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      const model = await save;\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1061,
                "column": 42
            },
            "line": 1061,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.format;\n      handleRequest(drive, 200, file);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#save()"
            ],
            "updatePoint": {
                "line": 1070,
                "column": 45
            },
            "line": 1070,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, DEFAULT_FILE);\n      const save = drive.save('/foo', { type: 'file', name: 'test' });\n      await expect(save).rejects.toThrow(/Invalid response: 204 No Content/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should copy a file",
            "suites": [
                "drive",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1079,
                "column": 26
            },
            "line": 1079,
            "code": "    it('should copy a file', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit the fileChanged signal",
            "suites": [
                "drive",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1086,
                "column": 42
            },
            "line": 1086,
            "code": "    it('should emit the fileChanged signal', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_FILE);\n      let called = false;\n      drive.fileChanged.connect((sender, args) => {\n        expect(args.type).toBe('new');\n        expect(args.oldValue).toBeNull();\n        expect(args.newValue!.path).toBe(DEFAULT_FILE.path);\n        called = true;\n      });\n      await drive.copy('/foo/bar.txt', '/baz');\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1100,
                "column": 37
            },
            "line": 1100,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_FILE);\n      const model = await drive.copy('/foo/bar.txt', '/baz');\n      expect(model.created).toBe(DEFAULT_FILE.created);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1107,
                "column": 42
            },
            "line": 1107,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const file = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete file.type;\n      handleRequest(drive, 201, file);\n      const copy = drive.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#copy()"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 45
            },
            "line": 1116,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_FILE);\n      const copy = drive.copy('/foo/bar.txt', '/baz');\n      await expect(copy).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a checkpoint",
            "suites": [
                "drive",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 1125,
                "column": 34
            },
            "line": 1125,
            "code": "    it('should create a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 1133,
                "column": 37
            },
            "line": 1133,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 201, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      const model = await checkpoint;\n      expect(model.last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 1141,
                "column": 42
            },
            "line": 1141,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.last_modified;\n      handleRequest(drive, 201, cp);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#createCheckpoint()"
            ],
            "updatePoint": {
                "line": 1150,
                "column": 45
            },
            "line": 1150,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, DEFAULT_CP);\n      const checkpoint = drive.createCheckpoint('/foo/bar.txt');\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should list the checkpoints",
            "suites": [
                "drive",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 1159,
                "column": 35
            },
            "line": 1159,
            "code": "    it('should list the checkpoints', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 1167,
                "column": 37
            },
            "line": 1167,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 200, [DEFAULT_CP, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      const models = await checkpoints;\n      expect(models[0].last_modified).toBe(DEFAULT_CP.last_modified);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect model",
            "suites": [
                "drive",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 1175,
                "column": 42
            },
            "line": 1175,
            "code": "    it('should fail for an incorrect model', async () => {\n      const drive = new Drive();\n      const cp = JSON.parse(JSON.stringify(DEFAULT_CP));\n      delete cp.id;\n      handleRequest(drive, 200, [cp, DEFAULT_CP]);\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expectFailure(checkpoints);\n      handleRequest(drive, 200, DEFAULT_CP);\n      const newCheckpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expect(newCheckpoints).rejects.toThrow(/Invalid Checkpoint list/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#listCheckpoints()"
            ],
            "updatePoint": {
                "line": 1187,
                "column": 45
            },
            "line": 1187,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 201, {});\n      const checkpoints = drive.listCheckpoints('/foo/bar.txt');\n      await expect(checkpoints).rejects.toThrow(\n        /Invalid response: 201 Created/\n      );\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should restore a checkpoint",
            "suites": [
                "drive",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 1198,
                "column": 35
            },
            "line": 1198,
            "code": "    it('should restore a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 1205,
                "column": 37
            },
            "line": 1205,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 1212,
                "column": 45
            },
            "line": 1212,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const checkpoint = drive.restoreCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a checkpoint",
            "suites": [
                "drive",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 1221,
                "column": 34
            },
            "line": 1221,
            "code": "    it('should delete a checkpoint', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 204, {});\n      await expect(\n        drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "drive",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 1229,
                "column": 37
            },
            "line": 1229,
            "code": "    it('should accept server settings', async () => {\n      const drive = new Drive({ serverSettings });\n      handleRequest(drive, 204, {});\n      await expect(\n        drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id)\n      ).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response",
            "suites": [
                "drive",
                "#deleteCheckpoint()"
            ],
            "updatePoint": {
                "line": 1237,
                "column": 45
            },
            "line": 1237,
            "code": "    it('should fail for an incorrect response', async () => {\n      const drive = new Drive();\n      handleRequest(drive, 200, {});\n      const checkpoint = drive.deleteCheckpoint('/foo/bar.txt', DEFAULT_CP.id);\n      await expect(checkpoint).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should list a directory and get the file contents",
            "suites": [
                "drive",
                "integration tests"
            ],
            "updatePoint": {
                "line": 1246,
                "column": 57
            },
            "line": 1246,
            "code": "    it('should list a directory and get the file contents', async () => {\n      let content: Contents.IModel[];\n      let path = '';\n      const listing = await contents.get('src');\n      content = listing.content as Contents.IModel[];\n      let called = false;\n      for (let i = 0; i < content.length; i++) {\n        if (content[i].type === 'file') {\n          path = content[i].path;\n          const msg = await contents.get(path, { type: 'file' });\n          // eslint-disable-next-line jest/no-conditional-expect\n          expect(msg.path).toBe(path);\n          called = true;\n        }\n      }\n      expect(called).toBe(true);\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new file, rename it, and delete it",
            "suites": [
                "drive",
                "integration tests"
            ],
            "updatePoint": {
                "line": 1264,
                "column": 58
            },
            "line": 1264,
            "code": "    it('should create a new file, rename it, and delete it', async () => {\n      const options: Contents.ICreateOptions = { type: 'file', ext: '.ipynb' };\n      const model0 = await contents.newUntitled(options);\n      const model1 = await contents.rename(model0.path, 'foo.ipynb');\n      expect(model1.path).toBe('foo.ipynb');\n      return contents.delete('foo.ipynb');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a file by name and delete it",
            "suites": [
                "drive",
                "integration tests"
            ],
            "updatePoint": {
                "line": 1272,
                "column": 50
            },
            "line": 1272,
            "code": "    it('should create a file by name and delete it', async () => {\n      const options: Partial<Contents.IModel> = {\n        type: 'file',\n        content: '',\n        format: 'text'\n      };\n      await contents.save('baz.txt', options);\n      await expect(contents.delete('baz.txt')).resolves.not.toThrow();\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should exercise the checkpoint API",
            "suites": [
                "drive",
                "integration tests"
            ],
            "updatePoint": {
                "line": 1282,
                "column": 42
            },
            "line": 1282,
            "code": "    it('should exercise the checkpoint API', async () => {\n      const options: Partial<Contents.IModel> = {\n        type: 'file',\n        format: 'text',\n        content: 'foo'\n      };\n      let checkpoint: Contents.ICheckpointModel;\n      const model0 = await contents.save('baz.txt', options);\n      expect(model0.name).toBe('baz.txt');\n      const value = await contents.createCheckpoint('baz.txt');\n      checkpoint = value;\n      const checkpoints = await contents.listCheckpoints('baz.txt');\n      expect(checkpoints[0]).toEqual(checkpoint);\n      await contents.restoreCheckpoint('baz.txt', checkpoint.id);\n      await contents.deleteCheckpoint('baz.txt', checkpoint.id);\n      await contents.delete('baz.txt');\n    });",
            "file": "contents/index.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass with valid data",
            "suites": [
                "validate",
                "validateContentsModel()"
            ],
            "updatePoint": {
                "line": 12,
                "column": 35
            },
            "line": 12,
            "code": "    it('should pass with valid data', () => {\n      expect(() => {\n        validateContentsModel(DEFAULT_FILE);\n      }).not.toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on missing data",
            "suites": [
                "validate",
                "validateContentsModel()"
            ],
            "updatePoint": {
                "line": 18,
                "column": 35
            },
            "line": 18,
            "code": "    it('should fail on missing data', () => {\n      const model = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      delete model['path'];\n      expect(() => validateContentsModel(model)).toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on incorrect data",
            "suites": [
                "validate",
                "validateContentsModel()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 37
            },
            "line": 24,
            "code": "    it('should fail on incorrect data', () => {\n      const model = JSON.parse(JSON.stringify(DEFAULT_FILE));\n      model.type = 1;\n      expect(() => validateContentsModel(model)).toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass with valid data",
            "suites": [
                "validate",
                "validateCheckpointModel()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 35
            },
            "line": 32,
            "code": "    it('should pass with valid data', () => {\n      expect(() => {\n        validateCheckpointModel({ id: 'foo', last_modified: 'yesterday ' });\n      }).not.toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on missing data",
            "suites": [
                "validate",
                "validateCheckpointModel()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 35
            },
            "line": 38,
            "code": "    it('should fail on missing data', () => {\n      const model = { id: 'foo' };\n      expect(() => validateCheckpointModel(model as any)).toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on incorrect data",
            "suites": [
                "validate",
                "validateCheckpointModel()"
            ],
            "updatePoint": {
                "line": 43,
                "column": 37
            },
            "line": 43,
            "code": "    it('should fail on incorrect data', () => {\n      const model = { id: 1, last_modified: '1' };\n      expect(() => validateCheckpointModel(model as any)).toThrow();\n    });",
            "file": "contents/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "setting",
                "EventManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 34,
                "column": 34
            },
            "line": 34,
            "code": "      it('should accept no options', () => {\n        const manager = new EventManager();\n        expect(manager).toBeInstanceOf(EventManager);\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "setting",
                "EventManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 31
            },
            "line": 39,
            "code": "      it('should accept options', () => {\n        const manager = new EventManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(EventManager);\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the server settings",
            "suites": [
                "setting",
                "EventManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 48,
                "column": 39
            },
            "line": 48,
            "code": "      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new EventManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should yield an event",
            "suites": [
                "setting",
                "EventManager",
                "#stream[Symbol.asyncIterator]()"
            ],
            "updatePoint": {
                "line": 57,
                "column": 31
            },
            "line": 57,
            "code": "      it('should yield an event', async () => {\n        const delegate = new PromiseDelegate<void>();\n        const expected = `#stream[Symbol.asyncIterator]() test`;\n        let received = '';\n        setTimeout(async () => {\n          for await (const emission of manager.stream) {\n            received = (emission.path as string) || '';\n            if (received === expected) {\n              break;\n            }\n          }\n          expect(received).toEqual(expected);\n          delegate.resolve();\n        });\n        setTimeout(() => {\n          void manager.emit({\n            // eslint-disable-next-line camelcase\n            schema_id:\n              'https://events.jupyter.org/jupyter_server/contents_service/v1',\n            data: { action: 'get', path: expected },\n            version: '1'\n          });\n        }, 500);\n        return delegate.promise;\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should yield an event",
            "suites": [
                "setting",
                "EventManager",
                "#stream.connect()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 31
            },
            "line": 85,
            "code": "      it('should yield an event', async () => {\n        const delegate = new PromiseDelegate<void>();\n        const expected = `#stream.connect() test`;\n        let received = '';\n        manager.stream.connect((_, emission) => {\n          received = (emission.path as string) || '';\n          if (received !== expected) {\n            return;\n          }\n          expect(received).toEqual(expected);\n          delegate.resolve();\n        });\n        setTimeout(() => {\n          void manager.emit({\n            // eslint-disable-next-line camelcase\n            schema_id:\n              'https://events.jupyter.org/jupyter_server/contents_service/v1',\n            data: { action: 'get', path: expected },\n            version: '1'\n          });\n        }, 500);\n        return delegate.promise;\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit an event",
            "suites": [
                "setting",
                "EventManager",
                "#emit()"
            ],
            "updatePoint": {
                "line": 111,
                "column": 30
            },
            "line": 111,
            "code": "      it('should emit an event', async () => {\n        const delegate = new PromiseDelegate<void>();\n        const expected = `#emit() test`;\n        let received = '';\n        setTimeout(async () => {\n          for await (const emission of manager.stream) {\n            received = (emission.path as string) || '';\n            if (received === expected) {\n              break;\n            }\n          }\n          expect(received).toEqual(expected);\n          delegate.resolve();\n        });\n        setTimeout(() => {\n          void manager.emit({\n            // eslint-disable-next-line camelcase\n            schema_id:\n              'https://events.jupyter.org/jupyter_server/contents_service/v1',\n            data: { action: 'get', path: expected },\n            version: '1'\n          });\n        }, 500);\n        return delegate.promise;\n      });",
            "file": "event/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create an instance of IComm",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#createComm()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 44
            },
            "line": 69,
            "code": "      it('should create an instance of IComm', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.targetName).toBe('test');\n        expect(typeof comm.commId).toBe('string');\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should use the given id",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#createComm()"
            ],
            "updatePoint": {
                "line": 75,
                "column": 33
            },
            "line": 75,
            "code": "      it('should use the given id', () => {\n        const comm = kernel.createComm('test', '1234');\n        expect(comm.targetName).toBe('test');\n        expect(comm.commId).toBe('1234');\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error if there is an existing comm",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#createComm()"
            ],
            "updatePoint": {
                "line": 81,
                "column": 60
            },
            "line": 81,
            "code": "      it('should throw an error if there is an existing comm', () => {\n        expect(() => kernel.createComm('test', '1234')).toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error when the kernel does not handle comms",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#createComm()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 69
            },
            "line": 85,
            "code": "      it('should throw an error when the kernel does not handle comms', async () => {\n        const kernel2 = await kernelManager.startNew(\n          { name: 'ipython' },\n          { handleComms: false }\n        );\n        expect(kernel2.handleComms).toBe(false);\n        expect(() => kernel2.createComm('test', '1234')).toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test if there is a registered comm",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#hasComm()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 51
            },
            "line": 96,
            "code": "      it('should test if there is a registered comm', () => {\n        expect(kernel.hasComm('test comm')).toBe(false);\n        const comm = kernel.createComm('test', 'test comm');\n        expect(kernel.hasComm('test comm')).toBe(true);\n        comm.dispose();\n        expect(kernel.hasComm('test comm')).toBe(false);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should call the provided callback",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#registerCommTarget()"
            ],
            "updatePoint": {
                "line": 106,
                "column": 43
            },
            "line": 106,
            "code": "      it('should call the provided callback', async () => {\n        const promise = new PromiseDelegate<\n          [Kernel.IComm, KernelMessage.ICommOpenMsg]\n        >();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          promise.resolve([comm, msg]);\n        };\n        kernel.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel.requestExecute({ code: SEND }, true).done;\n\n        // Get the comm.\n        const [comm, msg] = await promise.promise;\n        expect(msg.content.data).toBe('hello');\n\n        // Clean up\n        kernel.removeCommTarget('test', hook);\n        comm.dispose();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should do nothing if the kernel does not handle comms",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#registerCommTarget()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 63
            },
            "line": 127,
            "code": "      it('should do nothing if the kernel does not handle comms', async () => {\n        const promise = new PromiseDelegate<\n          [Kernel.IComm, KernelMessage.ICommOpenMsg]\n        >();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          promise.resolve([comm, msg]);\n        };\n        const kernel2 = await kernelManager.startNew(\n          { name: 'ipython' },\n          { handleComms: false }\n        );\n        kernel2.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel2.requestExecute({ code: SEND }, true).done;\n\n        // The promise above should not be fulfilled, even after a short delay.\n        expect(await isFulfilled(promise.promise, 300)).toBe(false);\n\n        // The kernel comm has not been closed - we just completely ignored it.\n        const reply = await kernel2.requestExecute(\n          { code: `assert comm._closed is False` },\n          true\n        ).done;\n        // If the assert was false, we would get an 'error' status\n        expect(reply!.content.status).toBe('ok');\n\n        // Clean up\n        kernel2.removeCommTarget('test', hook);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the comm info",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#commInfo()"
            ],
            "updatePoint": {
                "line": 160,
                "column": 34
            },
            "line": 160,
            "code": "      it('should get the comm info', async () => {\n        const commPromise = new PromiseDelegate<Kernel.IComm>();\n        const hook = (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => {\n          commPromise.resolve(comm);\n        };\n        kernel.registerCommTarget('test', hook);\n\n        // Request the comm creation.\n        await kernel.requestExecute({ code: SEND }, true).done;\n\n        // Get the comm.\n        const comm = await commPromise.promise;\n\n        // Ask the kernel for the list of current comms.\n        const msg = await kernel.requestCommInfo({});\n\n        if (msg.content.status !== 'ok') {\n          throw new Error('Message error');\n        }\n\n        // Test to make sure the comm we just created is listed.\n        const comms = msg.content.comms;\n        expect(comms[comm.commId].target_name).toBe('test');\n\n        // Clean up\n        kernel.removeCommTarget('test', hook);\n        comm.dispose();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should allow an optional target name",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#commInfo()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 46
            },
            "line": 189,
            "code": "      it('should allow an optional target name', async () => {\n        await kernel.requestExecute({ code: SEND }, true).done;\n        const msg = await kernel.requestCommInfo({ target_name: 'test' });\n        if (msg.content.status !== 'ok') {\n          throw new Error('Message error');\n        }\n        const comms = msg.content.comms;\n        for (const id in comms) {\n          expect(comms[id].target_name).toBe('test');\n        }\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be true after we dispose of the comm",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 203,
                "column": 53
            },
            "line": 203,
            "code": "      it('should be true after we dispose of the comm', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.isDisposed).toBe(false);\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 210,
                "column": 47
            },
            "line": 210,
            "code": "      it('should be safe to call multiple times', () => {\n        const comm = kernel.createComm('test');\n        expect(comm.isDisposed).toBe(false);\n        expect(comm.isDisposed).toBe(false);\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n        expect(comm.isDisposed).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources held by the comm",
            "suites": [
                "jupyter.services - Comm",
                "Kernel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 221,
                "column": 58
            },
            "line": 221,
            "code": "      it('should dispose of the resources held by the comm', () => {\n        const comm = kernel.createComm('foo');\n        comm.dispose();\n        expect(comm.isDisposed).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#id"
            ],
            "updatePoint": {
                "line": 237,
                "column": 28
            },
            "line": 237,
            "code": "      it('should be a string', () => {\n        expect(typeof comm.commId).toBe('string');\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#name"
            ],
            "updatePoint": {
                "line": 243,
                "column": 28
            },
            "line": 243,
            "code": "      it('should be a string', () => {\n        expect(comm.targetName).toBe('test');\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be readable and writable function",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#onClose"
            ],
            "updatePoint": {
                "line": 249,
                "column": 50
            },
            "line": 249,
            "code": "      it('should be readable and writable function', async () => {\n        expect(comm.onClose).toBeUndefined();\n        let called = false;\n        comm.onClose = msg => {\n          called = true;\n        };\n        await comm.close().done;\n        expect(called).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be called when the server side closes",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#onClose"
            ],
            "updatePoint": {
                "line": 259,
                "column": 54
            },
            "line": 259,
            "code": "      it('should be called when the server side closes', async () => {\n        const promise = new PromiseDelegate<void>();\n        kernel.registerCommTarget('test', (comm, msg) => {\n          comm.onClose = data => {\n            promise.resolve(void 0);\n          };\n          comm.send('quit');\n        });\n        await kernel.requestExecute({ code: SEND }, true).done;\n        await expect(promise.promise).resolves.not.toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be readable and writable function",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#onMsg"
            ],
            "updatePoint": {
                "line": 273,
                "column": 50
            },
            "line": 273,
            "code": "      it('should be readable and writable function', async () => {\n        let called = false;\n        comm.onMsg = msg => {\n          called = true;\n        };\n        expect(typeof comm.onMsg).toBe('function');\n        const msg = KernelMessage.createMessage({\n          msgType: 'comm_msg',\n          channel: 'iopub',\n          username: kernel.username,\n          session: kernel.clientId,\n          content: {\n            comm_id: 'abcd',\n            data: {}\n          }\n        });\n        await comm.onMsg(msg);\n        expect(called).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be called when the server side sends a message",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#onMsg"
            ],
            "updatePoint": {
                "line": 293,
                "column": 63
            },
            "line": 293,
            "code": "      it('should be called when the server side sends a message', async () => {\n        let called = false;\n        kernel.registerCommTarget('test', (comm, msg) => {\n          comm.onMsg = msg => {\n            expect(msg.content.data).toBe('hello');\n            called = true;\n          };\n        });\n        await kernel.requestExecute({ code: BLIP }, true).done;\n        expect(called).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a message to the server",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#open()"
            ],
            "updatePoint": {
                "line": 307,
                "column": 45
            },
            "line": 307,
            "code": "      it('should send a message to the server', async () => {\n        const future = kernel.requestExecute({ code: TARGET });\n        await future.done;\n        const encoder = new TextEncoder();\n        const data = encoder.encode('hello');\n        const future2 = comm.open({ foo: 'bar' }, { fizz: 'buzz' }, [\n          data,\n          data.buffer\n        ]);\n        await expect(future2.done).resolves.not.toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a message to the server",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#send()"
            ],
            "updatePoint": {
                "line": 321,
                "column": 45
            },
            "line": 321,
            "code": "      it('should send a message to the server', async () => {\n        await comm.open().done;\n        const future = comm.send({ foo: 'bar' }, { fizz: 'buzz' });\n        await expect(future.done).resolves.not.toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass through a buffers field",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#send()"
            ],
            "updatePoint": {
                "line": 327,
                "column": 45
            },
            "line": 327,
            "code": "      it('should pass through a buffers field', async () => {\n        await comm.open().done;\n        const future = comm.send({ buffers: 'bar' });\n        await expect(future.done).resolves.not.toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a message to the server",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#close()"
            ],
            "updatePoint": {
                "line": 335,
                "column": 45
            },
            "line": 335,
            "code": "      it('should send a message to the server', async () => {\n        await comm.open().done;\n        const encoder = new TextEncoder();\n        const data = encoder.encode('hello');\n        const future = comm.close({ foo: 'bar' }, {}, [data, data.buffer]);\n        await expect(future.done).resolves.not.toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should trigger an onClose",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#close()"
            ],
            "updatePoint": {
                "line": 343,
                "column": 35
            },
            "line": 343,
            "code": "      it('should trigger an onClose', async () => {\n        await comm.open().done;\n        let called = false;\n        comm.onClose = (msg: KernelMessage.ICommCloseMsg) => {\n          expect(msg.content.data).toEqual({ foo: 'bar' });\n          called = true;\n        };\n        const future = comm.close({ foo: 'bar' });\n        await future.done;\n        expect(called).toBe(true);\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not send subsequent messages",
            "suites": [
                "jupyter.services - Comm",
                "IComm",
                "#close()"
            ],
            "updatePoint": {
                "line": 355,
                "column": 45
            },
            "line": 355,
            "code": "      it('should not send subsequent messages', async () => {\n        await comm.open().done;\n        await comm.close({ foo: 'bar' }).done;\n        expect(() => {\n          comm.send('test');\n        }).toThrow();\n      });",
            "file": "kernel/comm.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should have a msg attribute",
            "suites": [
                "Kernel.IShellFuture"
            ],
            "updatePoint": {
                "line": 33,
                "column": 33
            },
            "line": 33,
            "code": "  it('should have a msg attribute', async () => {\n    const kernel = await kernelManager.startNew();\n    await kernel.info;\n    const future = kernel.requestExecute({ code: 'print(\"hello\")' });\n    expect(typeof future.msg.header.msg_id).toBe('string');\n    await future.done;\n    await kernel.shutdown();\n  });",
            "file": "kernel/ifuture.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should have the most recently registered hook run first",
            "suites": [
                "Kernel.IShellFuture",
                "Message hooks"
            ],
            "updatePoint": {
                "line": 43,
                "column": 63
            },
            "line": 43,
            "code": "    it('should have the most recently registered hook run first', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push('last');\n          return true;\n        });\n\n        future.registerMessageHook(msg => {\n          calls.push('first');\n          // Check to make sure we actually got the messages we expected.\n          if (msg.header.msg_type === 'stream') {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect((msg as KernelMessage.IStreamMsg).content.text).toBe('foo');\n          } else {\n            // eslint-disable-next-line jest/no-conditional-expect\n            expect(\n              (msg as KernelMessage.IStatusMsg).content.execution_state\n            ).toBe('idle');\n          }\n          // not returning should also continue handling\n          return void 0 as any;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual([\n        'first',\n        'last',\n        'iopub',\n        'first',\n        'last',\n        'iopub'\n      ]);\n    });",
            "file": "kernel/ifuture.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should abort processing if a hook returns false, but the done logic should still work",
            "suites": [
                "Kernel.IShellFuture",
                "Message hooks"
            ],
            "updatePoint": {
                "line": 136,
                "column": 93
            },
            "line": 136,
            "code": "    it('should abort processing if a hook returns false, but the done logic should still work', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(msg => {\n          calls.push('last');\n          return true;\n        });\n\n        future.registerMessageHook(async msg => {\n          calls.push('first');\n          return false;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual(['first', 'first']);\n    });",
            "file": "kernel/ifuture.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should process additions on the next run",
            "suites": [
                "Kernel.IShellFuture",
                "Message hooks"
            ],
            "updatePoint": {
                "line": 209,
                "column": 48
            },
            "line": 209,
            "code": "    it('should process additions on the next run', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(msg => {\n          calls.push('last');\n          future.registerMessageHook(msg => {\n            calls.push('first');\n            return true;\n          });\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['last', 'iopub', 'first', 'last', 'iopub']);\n    });",
            "file": "kernel/ifuture.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should deactivate message hooks immediately on removal",
            "suites": [
                "Kernel.IShellFuture",
                "Message hooks"
            ],
            "updatePoint": {
                "line": 279,
                "column": 62
            },
            "line": 279,
            "code": "    it('should deactivate message hooks immediately on removal', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n\n      const toDelete = (msg: KernelMessage.IIOPubMessage) => {\n        calls.push('delete');\n        return true;\n      };\n      const first = (msg: KernelMessage.IIOPubMessage) => {\n        if (calls.length > 0) {\n          // delete the hook the second time around\n          future.removeMessageHook(toDelete);\n        }\n        calls.push('first');\n        return true;\n      };\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        future.registerMessageHook(toDelete);\n        future.registerMessageHook(first);\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n\n      expect(calls).toEqual(['first', 'delete', 'iopub', 'first', 'iopub']);\n      future.dispose();\n      future.removeMessageHook(first);\n    });",
            "file": "kernel/ifuture.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the kernel is disposed",
            "suites": [
                "Kernel.IKernel",
                "#disposed"
            ],
            "updatePoint": {
                "line": 47,
                "column": 53
            },
            "line": 47,
            "code": "    it('should be emitted when the kernel is disposed', async () => {\n      await defaultKernel.info;\n      let called = false;\n      defaultKernel.disposed.connect((sender, args) => {\n        expect(sender).toBe(defaultKernel);\n        expect(args).toBeUndefined();\n        called = true;\n      });\n      defaultKernel.dispose();\n      expect(called).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the kernel is shut down",
            "suites": [
                "Kernel.IKernel",
                "#disposed"
            ],
            "updatePoint": {
                "line": 59,
                "column": 54
            },
            "line": 59,
            "code": "    it('should be emitted when the kernel is shut down', async () => {\n      await defaultKernel.info;\n      let called = false;\n      defaultKernel.disposed.connect((sender, args) => {\n        expect(sender).toBe(defaultKernel);\n        expect(args).toBeUndefined();\n        called = true;\n      });\n      await defaultKernel.shutdown();\n      expect(called).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a signal following the Kernel status",
            "suites": [
                "Kernel.IKernel",
                "#statusChanged"
            ],
            "updatePoint": {
                "line": 73,
                "column": 54
            },
            "line": 73,
            "code": "    it('should be a signal following the Kernel status', async () => {\n      let called = false;\n      defaultKernel.statusChanged.connect(() => {\n        if (defaultKernel.status === 'busy') {\n          called = true;\n        }\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      expect(called).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a signal following input request",
            "suites": [
                "Kernel.IKernel",
                "#pendingInput"
            ],
            "updatePoint": {
                "line": 86,
                "column": 50
            },
            "line": 86,
            "code": "    it('should be a signal following input request', async () => {\n      let called = false;\n      defaultKernel.pendingInput.connect((sender, args) => {\n        if (!called) {\n          called = true;\n          defaultKernel.sendInputReply(\n            { status: 'ok', value: 'foo' },\n            {\n              date: '',\n              msg_id: '',\n              msg_type: 'input_request',\n              session: '',\n              username: '',\n              version: ''\n            }\n          );\n        }\n      });\n      const code = `input(\"Input something\")`;\n      await defaultKernel.requestExecute(\n        {\n          code: code,\n          allow_stdin: true\n        },\n        true\n      ).done;\n      expect(called).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an iopub message",
            "suites": [
                "Kernel.IKernel",
                "#iopubMessage"
            ],
            "updatePoint": {
                "line": 117,
                "column": 46
            },
            "line": 117,
            "code": "    it('should be emitted for an iopub message', async () => {\n      let called = false;\n      defaultKernel.iopubMessage.connect((k, msg) => {\n        called = true;\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      expect(called).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted regardless of the sender",
            "suites": [
                "Kernel.IKernel",
                "#iopubMessage"
            ],
            "updatePoint": {
                "line": 126,
                "column": 50
            },
            "line": 126,
            "code": "    it('should be emitted regardless of the sender', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.iopubMessage, {\n        find: (k, msg) => msg.header.msg_id === msgId\n      });\n      const msg = KernelMessage.createMessage({\n        msgType: 'status',\n        channel: 'iopub',\n        session: tester.serverSessionId,\n        msgId,\n        content: {\n          execution_state: 'idle'\n        }\n      });\n      tester.send(msg);\n      await emission;\n      await expect(tester.shutdown()).resolves.not.toThrow();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an unhandled message",
            "suites": [
                "Kernel.IKernel",
                "#unhandledMessage"
            ],
            "updatePoint": {
                "line": 159,
                "column": 50
            },
            "line": 159,
            "code": "    it('should be emitted for an unhandled message', async () => {\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.unhandledMessage, {\n        find: (k, msg) => msg.header.msg_id === msgId\n      });\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n      await expect(emission).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not be emitted for an iopub signal",
            "suites": [
                "Kernel.IKernel",
                "#unhandledMessage"
            ],
            "updatePoint": {
                "line": 177,
                "column": 49
            },
            "line": 177,
            "code": "    it('should not be emitted for an iopub signal', async () => {\n      const kernel = await tester.start();\n\n      // We'll send two messages, first an iopub message, then a shell message.\n      // The unhandledMessage signal should only emit once for the shell message.\n      const msgId = UUID.uuid4();\n      const emission = testEmission(kernel.unhandledMessage, {\n        test: (k, msg) => {\n          expect(msg.header.msg_id).toBe(msgId);\n        }\n      });\n\n      // Send an iopub message.\n      tester.sendStatus(UUID.uuid4(), 'idle');\n\n      // Send a shell message.\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n\n      await emission;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not be emitted for a different client session",
            "suites": [
                "Kernel.IKernel",
                "#unhandledMessage"
            ],
            "updatePoint": {
                "line": 206,
                "column": 60
            },
            "line": 206,
            "code": "    it('should not be emitted for a different client session', async () => {\n      const kernel = await tester.start();\n\n      // We'll send two messages, first a message with a different session, then\n      // one with the current client session. The unhandledMessage signal should\n      // only emit once for the current session message.\n      const msgId = 'message from right session';\n      const emission = testEmission(kernel.unhandledMessage, {\n        test: (k, msg) => {\n          expect((msg.parent_header as KernelMessage.IHeader).session).toBe(\n            kernel.clientId\n          );\n          expect(msg.header.msg_id).toBe(msgId);\n        }\n      });\n\n      // Send a shell message with the wrong client (parent) session.\n      const msg1 = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId: 'message from wrong session',\n        content: {}\n      });\n      msg1.parent_header = { session: 'wrong session' } as any;\n      tester.send(msg1);\n\n      // Send a shell message with the right client (parent) session.\n      const msg2 = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId: msgId,\n        content: {}\n      });\n      msg2.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg2);\n\n      await emission;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an unhandled message",
            "suites": [
                "Kernel.IKernel",
                "#anyMessage"
            ],
            "updatePoint": {
                "line": 258,
                "column": 50
            },
            "line": 258,
            "code": "    it('should be emitted for an unhandled message', async () => {\n      const kernel = await tester.start();\n      const msgId = UUID.uuid4();\n\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, args) => {\n          expect(args.msg.header.msg_id).toBe(msgId);\n          expect(args.msg.header.msg_type).toBe('kernel_info_request');\n          expect(args.direction).toBe('recv');\n        }\n      });\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        session: tester.serverSessionId,\n        msgId,\n        content: {}\n      });\n      msg.parent_header = { session: kernel.clientId } as any;\n      tester.send(msg);\n      await emission;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an iopub message",
            "suites": [
                "Kernel.IKernel",
                "#anyMessage"
            ],
            "updatePoint": {
                "line": 282,
                "column": 46
            },
            "line": 282,
            "code": "    it('should be emitted for an iopub message', async () => {\n      const kernel = await tester.start();\n      const msgId = 'idle status';\n\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, args) => {\n          expect((args.msg.header as any).msg_id).toBe(msgId);\n          expect(args.direction).toBe('recv');\n        }\n      });\n      tester.sendStatus(msgId, 'idle');\n      await emission;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an stdin message",
            "suites": [
                "Kernel.IKernel",
                "#anyMessage"
            ],
            "updatePoint": {
                "line": 296,
                "column": 46
            },
            "line": 296,
            "code": "    it('should be emitted for an stdin message', async () => {\n      const kernel = await tester.start();\n      const emission = testEmission(kernel.anyMessage, {\n        test: (k, { msg, direction }) => {\n          if (!KernelMessage.isInputReplyMsg(msg)) {\n            throw new Error('Unexpected message');\n          }\n          if (msg.content.status !== 'ok') {\n            throw new Error('Message has been changed');\n          }\n          expect(msg.content.value).toBe('foo');\n          expect(direction).toBe('send');\n        }\n      });\n      kernel.sendInputReply(\n        { status: 'ok', value: 'foo' },\n        {\n          date: '',\n          msg_id: '',\n          msg_type: 'input_request',\n          session: '',\n          username: '',\n          version: ''\n        }\n      );\n      await emission;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "Kernel.IKernel",
                "#id"
            ],
            "updatePoint": {
                "line": 326,
                "column": 26
            },
            "line": 326,
            "code": "    it('should be a string', () => {\n      expect(typeof defaultKernel.id).toBe('string');\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "Kernel.IKernel",
                "#name"
            ],
            "updatePoint": {
                "line": 332,
                "column": 26
            },
            "line": 332,
            "code": "    it('should be a string', () => {\n      expect(typeof defaultKernel.name).toBe('string');\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "Kernel.IKernel",
                "#username"
            ],
            "updatePoint": {
                "line": 338,
                "column": 26
            },
            "line": 338,
            "code": "    it('should be a string', () => {\n      expect(typeof defaultKernel.username).toBe('string');\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the server settings",
            "suites": [
                "Kernel.IKernel",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 344,
                "column": 37
            },
            "line": 344,
            "code": "    it('should be the server settings', () => {\n      expect(defaultKernel.serverSettings.baseUrl).toBe(\n        PageConfig.getBaseUrl()\n      );\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "Kernel.IKernel",
                "#clientId"
            ],
            "updatePoint": {
                "line": 352,
                "column": 26
            },
            "line": 352,
            "code": "    it('should be a string', () => {\n      expect(typeof defaultKernel.clientId).toBe('string');\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get an idle status",
            "suites": [
                "Kernel.IKernel",
                "#status"
            ],
            "updatePoint": {
                "line": 362,
                "column": 33
            },
            "line": 362,
            "code": "    it('should get an idle status', async () => {\n      const emission = testEmission(defaultKernel.statusChanged, {\n        find: () => defaultKernel.status === 'idle'\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }).done;\n      await expect(emission).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a restarting status",
            "suites": [
                "Kernel.IKernel",
                "#status"
            ],
            "updatePoint": {
                "line": 370,
                "column": 38
            },
            "line": 370,
            "code": "    it('should get a restarting status', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      const emission = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'restarting'\n      });\n      await kernel.requestKernelInfo();\n      await kernel.restart();\n      await expect(emission).resolves.not.toThrow();\n      await kernel.requestKernelInfo();\n      await kernel.shutdown();\n    }, 30000);",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a busy status",
            "suites": [
                "Kernel.IKernel",
                "#status"
            ],
            "updatePoint": {
                "line": 383,
                "column": 32
            },
            "line": 383,
            "code": "    it('should get a busy status', async () => {\n      const emission = testEmission(defaultKernel.statusChanged, {\n        find: () => defaultKernel.status === 'busy'\n      });\n      await defaultKernel.requestExecute({ code: 'a=1' }, true).done;\n      await expect(emission).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get an unknown status while disconnected",
            "suites": [
                "Kernel.IKernel",
                "#status"
            ],
            "updatePoint": {
                "line": 391,
                "column": 55
            },
            "line": 391,
            "code": "    it('should get an unknown status while disconnected', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const emission = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'unknown'\n      });\n\n      await tester.close();\n      await expect(emission).resolves.not.toThrow();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get a dead status",
            "suites": [
                "Kernel.IKernel",
                "#status"
            ],
            "updatePoint": {
                "line": 403,
                "column": 32
            },
            "line": 403,
            "code": "    it('should get a dead status', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      await kernel.info;\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await expect(dead).resolves.not.toThrow();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the kernel info",
            "suites": [
                "Kernel.IKernel",
                "#info"
            ],
            "updatePoint": {
                "line": 417,
                "column": 34
            },
            "line": 417,
            "code": "    it('should get the kernel info', async () => {\n      const name = (await defaultKernel.info).language_info.name;\n      const defaultSpecs = specs.kernelspecs[specs.default]!;\n      expect(name).toBe(defaultSpecs.language);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve with the spec",
            "suites": [
                "Kernel.IKernel",
                "#spec"
            ],
            "updatePoint": {
                "line": 425,
                "column": 36
            },
            "line": 425,
            "code": "    it('should resolve with the spec', async () => {\n      const spec = await defaultKernel.spec;\n      expect(spec!.name).toBe(specs.default);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be true after we dispose of the kernel",
            "suites": [
                "Kernel.IKernel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 432,
                "column": 53
            },
            "line": 432,
            "code": "    it('should be true after we dispose of the kernel', async () => {\n      const kernel = defaultKernel.clone();\n      expect(kernel.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(kernel.isDisposed).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "Kernel.IKernel",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 439,
                "column": 45
            },
            "line": 439,
            "code": "    it('should be safe to call multiple times', async () => {\n      const kernel = defaultKernel.clone();\n      expect(kernel.isDisposed).toBe(false);\n      expect(kernel.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(kernel.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources held by the kernel",
            "suites": [
                "Kernel.IKernel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 450,
                "column": 58
            },
            "line": 450,
            "code": "    it('should dispose of the resources held by the kernel', async () => {\n      const kernel = defaultKernel.clone();\n      const future = kernel.requestExecute({ code: 'foo' });\n      expect(future.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call twice",
            "suites": [
                "Kernel.IKernel",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 458,
                "column": 36
            },
            "line": 458,
            "code": "    it('should be safe to call twice', async () => {\n      const kernel = defaultKernel.clone();\n      const future = kernel.requestExecute({ code: 'foo' });\n      expect(future.isDisposed).toBe(false);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n      kernel.dispose();\n      expect(future.isDisposed).toBe(true);\n      expect(kernel.isDisposed).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a message to the kernel",
            "suites": [
                "Kernel.IKernel",
                "#sendShellMessage()"
            ],
            "updatePoint": {
                "line": 485,
                "column": 43
            },
            "line": 485,
            "code": "    it('should send a message to the kernel', async () => {\n      const done = new PromiseDelegate<void>();\n      const msgId = UUID.uuid4();\n\n      tester.onMessage(msg => {\n        try {\n          expect(msg.header.msg_id).toBe(msgId);\n        } catch (e) {\n          done.reject(e);\n          throw e;\n        }\n        done.resolve();\n      });\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        msgId,\n        content: {}\n      });\n      kernel.sendShellMessage(msg, true);\n      await done.promise;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a binary message",
            "suites": [
                "Kernel.IKernel",
                "#sendShellMessage()"
            ],
            "updatePoint": {
                "line": 511,
                "column": 36
            },
            "line": 511,
            "code": "    it('should send a binary message', async () => {\n      const done = new PromiseDelegate<void>();\n      const msgId = UUID.uuid4();\n\n      tester.onMessage(msg => {\n        try {\n          const decoder = new TextDecoder('utf8');\n          const item = msg.buffers![0] as DataView;\n          expect(decoder.decode(item)).toBe('hello');\n        } catch (e) {\n          done.reject(e);\n          throw e;\n        }\n        done.resolve();\n      });\n\n      const encoder = new TextEncoder();\n      const data = encoder.encode('hello');\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        msgId,\n        content: {},\n        buffers: [data, data.buffer]\n      });\n      kernel.sendShellMessage(msg, true);\n      await done.promise;\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the kernel is dead",
            "suites": [
                "Kernel.IKernel",
                "#sendShellMessage()"
            ],
            "updatePoint": {
                "line": 542,
                "column": 41
            },
            "line": 542,
            "code": "    it('should fail if the kernel is dead', async () => {\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      expect(kernel.status).toBe('dead');\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        content: {}\n      });\n      expect(() => {\n        kernel.sendShellMessage(msg, true);\n      }).toThrow(/Kernel is dead/);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle out of order messages",
            "suites": [
                "Kernel.IKernel",
                "#sendShellMessage()"
            ],
            "updatePoint": {
                "line": 563,
                "column": 43
            },
            "line": 563,
            "code": "    it('should handle out of order messages', async () => {\n      // This test that a future.done promise resolves when a status idle and\n      // reply come through, even if the status comes first.\n\n      const msg = KernelMessage.createMessage({\n        msgType: 'kernel_info_request',\n        channel: 'shell',\n        username: kernel.username,\n        session: kernel.clientId,\n        content: {}\n      });\n      const future = kernel.sendShellMessage(msg, true);\n\n      tester.onMessage(msg => {\n        // trigger onDone\n        tester.send(\n          KernelMessage.createMessage({\n            msgType: 'status',\n            channel: 'iopub',\n            username: kernel.username,\n            session: kernel.clientId,\n            content: { execution_state: 'idle' },\n            parentHeader: msg.header\n          })\n        );\n\n        future.onIOPub = () => {\n          tester.send(\n            KernelMessage.createMessage({\n              msgType: 'comm_open',\n              channel: 'shell',\n              username: kernel.username,\n              session: kernel.clientId,\n              content: {\n                comm_id: 'abcd',\n                target_name: 'target',\n                data: {}\n              },\n              parentHeader: msg.header\n            })\n          );\n        };\n      });\n      await expect(future.done).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should interrupt and resolve with a valid server response",
            "suites": [
                "Kernel.IKernel",
                "#interrupt()"
            ],
            "updatePoint": {
                "line": 611,
                "column": 65
            },
            "line": 611,
            "code": "    it('should interrupt and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await expect(kernel.interrupt()).resolves.not.toThrow();\n      await kernel.shutdown();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "Kernel.IKernel",
                "#interrupt()"
            ],
            "updatePoint": {
                "line": 617,
                "column": 53
            },
            "line": 617,
            "code": "    it('should throw an error for an invalid response', async () => {\n      handleRequest(defaultKernel, 200, {\n        id: defaultKernel.id,\n        name: defaultKernel.name\n      });\n      const interrupt = defaultKernel.interrupt();\n      await expect(interrupt).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an error response",
            "suites": [
                "Kernel.IKernel",
                "#interrupt()"
            ],
            "updatePoint": {
                "line": 626,
                "column": 51
            },
            "line": 626,
            "code": "    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const interrupt = defaultKernel.interrupt();\n      await expect(interrupt).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the kernel is dead",
            "suites": [
                "Kernel.IKernel",
                "#interrupt()"
            ],
            "updatePoint": {
                "line": 632,
                "column": 41
            },
            "line": 632,
            "code": "    it('should fail if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.interrupt()).rejects.toThrow(/Kernel is dead/);\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should restart and resolve with a valid server response",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 652,
                "column": 63
            },
            "line": 652,
            "code": "    it('should restart and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      await kernel.requestKernelInfo();\n      await kernel.restart();\n      await expect(kernel.requestKernelInfo()).resolves.not.toThrow();\n      await kernel.shutdown();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the kernel does not restart",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 661,
                "column": 50
            },
            "line": 661,
            "code": "    it('should fail if the kernel does not restart', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 667,
                "column": 53
            },
            "line": 667,
            "code": "    it('should throw an error for an invalid response', async () => {\n      const { id, name } = defaultKernel;\n      handleRequest(defaultKernel, 205, { id, name });\n      await expect(defaultKernel.restart()).rejects.toThrow(\n        /Invalid response: 205 Reset Content/\n      );\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an error response",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 675,
                "column": 51
            },
            "line": 675,
            "code": "    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid id",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 681,
                "column": 47
            },
            "line": 681,
            "code": "    it('should throw an error for an invalid id', async () => {\n      handleRequest(defaultKernel, 200, {});\n      const restart = defaultKernel.restart();\n      await expect(restart).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of existing comm and future objects",
            "suites": [
                "Kernel.IKernel",
                "#restart()"
            ],
            "updatePoint": {
                "line": 687,
                "column": 58
            },
            "line": 687,
            "code": "    it('should dispose of existing comm and future objects', async () => {\n      const kernel = await kernelManager.startNew();\n      await kernel.info;\n      await kernel.requestKernelInfo();\n      const comm = kernel.createComm('test');\n      const future = kernel.requestExecute({ code: 'foo' });\n      await kernel.restart();\n      await kernel.requestKernelInfo();\n      expect(future.isDisposed).toBe(true);\n      expect(comm.isDisposed).toBe(true);\n      await kernel.shutdown();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new websocket and resolve the returned promise",
            "suites": [
                "Kernel.IKernel",
                "#reconnect()"
            ],
            "updatePoint": {
                "line": 702,
                "column": 70
            },
            "line": 702,
            "code": "    it('should create a new websocket and resolve the returned promise', async () => {\n      const oldWS = (defaultKernel as any)._ws;\n      await defaultKernel.reconnect();\n      expect((defaultKernel as any)._ws).not.toBe(oldWS);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit `\"connecting\"`, then `\"connected\"` status",
            "suites": [
                "Kernel.IKernel",
                "#reconnect()"
            ],
            "updatePoint": {
                "line": 708,
                "column": 61
            },
            "line": 708,
            "code": "    it('should emit `\"connecting\"`, then `\"connected\"` status', async () => {\n      const emission = testEmission(defaultKernel.connectionStatusChanged, {\n        find: () => defaultKernel.connectionStatus === 'connecting',\n        test: async () => {\n          await testEmission(defaultKernel.connectionStatusChanged, {\n            find: () => defaultKernel.connectionStatus === 'connected'\n          });\n        }\n      });\n      await defaultKernel.reconnect();\n      await expect(emission).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "return promise should reject if the kernel is disposed or disconnected",
            "suites": [
                "Kernel.IKernel",
                "#reconnect()"
            ],
            "updatePoint": {
                "line": 721,
                "column": 78
            },
            "line": 721,
            "code": "    it('return promise should reject if the kernel is disposed or disconnected', async () => {\n      const connection = defaultKernel.reconnect();\n      defaultKernel.dispose();\n      await expect(connection).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down and resolve with a valid server response",
            "suites": [
                "Kernel.IKernel",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 729,
                "column": 65
            },
            "line": 729,
            "code": "    it('should shut down and resolve with a valid server response', async () => {\n      const kernel = await kernelManager.startNew();\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "Kernel.IKernel",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 734,
                "column": 53
            },
            "line": 734,
            "code": "    it('should throw an error for an invalid response', async () => {\n      handleRequest(defaultKernel, 200, {\n        id: UUID.uuid4(),\n        name: 'foo'\n      });\n      const shutdown = defaultKernel.shutdown();\n      await expect(shutdown).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a 404 error",
            "suites": [
                "Kernel.IKernel",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 743,
                "column": 33
            },
            "line": 743,
            "code": "    it('should handle a 404 error', async () => {\n      const kernel = await kernelManager.startNew();\n      handleRequest(kernel, 404, {});\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an error response",
            "suites": [
                "Kernel.IKernel",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 749,
                "column": 51
            },
            "line": 749,
            "code": "    it('should throw an error for an error response', async () => {\n      handleRequest(defaultKernel, 500, {});\n      const shutdown = defaultKernel.shutdown();\n      await expect(shutdown).rejects.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should still pass if the kernel is dead",
            "suites": [
                "Kernel.IKernel",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 755,
                "column": 47
            },
            "line": 755,
            "code": "    it('should still pass if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.shutdown()).resolves.not.toThrow();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestKernelInfo()"
            ],
            "updatePoint": {
                "line": 771,
                "column": 34
            },
            "line": 771,
            "code": "    it('should resolve the promise', async () => {\n      const msg = (await defaultKernel.requestKernelInfo())!;\n      if (msg.content.status !== 'ok') {\n        throw new Error('Message error');\n      }\n      const name = msg.content.language_info.name;\n      expect(name).toBeTruthy();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestComplete()"
            ],
            "updatePoint": {
                "line": 782,
                "column": 34
            },
            "line": 782,
            "code": "    it('should resolve the promise', async () => {\n      const options: KernelMessage.ICompleteRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4\n      };\n      await expect(\n        defaultKernel.requestComplete(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should reject the promise if the kernel is dead",
            "suites": [
                "Kernel.IKernel",
                "#requestComplete()"
            ],
            "updatePoint": {
                "line": 792,
                "column": 55
            },
            "line": 792,
            "code": "    it('should reject the promise if the kernel is dead', async () => {\n      const options: KernelMessage.ICompleteRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4\n      };\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      await expect(kernel.requestComplete(options)).rejects.toThrow(\n        /Kernel is dead/\n      );\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestInspect()"
            ],
            "updatePoint": {
                "line": 814,
                "column": 34
            },
            "line": 814,
            "code": "    it('should resolve the promise', async () => {\n      const options: KernelMessage.IInspectRequestMsg['content'] = {\n        code: 'hello',\n        cursor_pos: 4,\n        detail_level: 0\n      };\n      await expect(\n        defaultKernel.requestInspect(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestIsComplete()"
            ],
            "updatePoint": {
                "line": 827,
                "column": 34
            },
            "line": 827,
            "code": "    it('should resolve the promise', async () => {\n      const options: KernelMessage.IIsCompleteRequestMsg['content'] = {\n        code: 'hello'\n      };\n      await expect(\n        defaultKernel.requestIsComplete(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "range messages should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestHistory()"
            ],
            "updatePoint": {
                "line": 838,
                "column": 49
            },
            "line": 838,
            "code": "    it('range messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'range',\n        session: 0,\n        start: 1,\n        stop: 2\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "tail messages should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestHistory()"
            ],
            "updatePoint": {
                "line": 852,
                "column": 48
            },
            "line": 852,
            "code": "    it('tail messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'tail',\n        n: 1\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "search messages should resolve the promise",
            "suites": [
                "Kernel.IKernel",
                "#requestHistory()"
            ],
            "updatePoint": {
                "line": 864,
                "column": 50
            },
            "line": 864,
            "code": "    it('search messages should resolve the promise', async () => {\n      const options: KernelMessage.IHistoryRequestMsg['content'] = {\n        output: true,\n        raw: true,\n        hist_access_type: 'search',\n        n: 1,\n        pattern: '*',\n        unique: true\n      };\n      await expect(\n        defaultKernel.requestHistory(options)\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send an input_reply message",
            "suites": [
                "Kernel.IKernel",
                "#sendInputReply()"
            ],
            "updatePoint": {
                "line": 880,
                "column": 42
            },
            "line": 880,
            "code": "    it('should send an input_reply message', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const done = new PromiseDelegate<void>();\n      tester.onMessage(msg => {\n        expect(msg.header.msg_type).toBe('input_reply');\n        done.resolve(undefined);\n      });\n      kernel.sendInputReply(\n        { status: 'ok', value: 'test' },\n        {\n          date: '',\n          msg_id: '',\n          msg_type: 'input_request',\n          session: '',\n          username: '',\n          version: ''\n        }\n      );\n      await done.promise;\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the kernel is dead",
            "suites": [
                "Kernel.IKernel",
                "#sendInputReply()"
            ],
            "updatePoint": {
                "line": 904,
                "column": 41
            },
            "line": 904,
            "code": "    it('should fail if the kernel is dead', async () => {\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n\n      // Create a promise that resolves when the kernel's status changes to dead\n      const dead = testEmission(kernel.statusChanged, {\n        find: () => kernel.status === 'dead'\n      });\n      tester.sendStatus(UUID.uuid4(), 'dead');\n      await dead;\n      expect(() => {\n        kernel.sendInputReply(\n          { status: 'ok', value: 'test' },\n          {\n            date: '',\n            msg_id: '',\n            msg_type: 'input_request',\n            session: '',\n            username: '',\n            version: ''\n          }\n        );\n      }).toThrow(/Kernel is dead/);\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send and handle incoming messages",
            "suites": [
                "Kernel.IKernel",
                "#requestExecute()"
            ],
            "updatePoint": {
                "line": 932,
                "column": 48
            },
            "line": 932,
            "code": "    it('should send and handle incoming messages', async () => {\n      const content: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n\n      const options = {\n        username: defaultKernel.username,\n        session: defaultKernel.clientId\n      };\n\n      let future: Kernel.IShellFuture;\n      const tester = new KernelTester();\n\n      tester.onMessage(msg => {\n        expect(msg.channel).toBe('shell');\n\n        // send a reply\n        tester.send(\n          KernelMessage.createMessage<KernelMessage.IExecuteReplyMsg>({\n            ...options,\n            msgType: 'execute_reply',\n            channel: 'shell',\n            content: {\n              execution_count: 1,\n              status: 'ok',\n              user_expressions: {}\n            },\n            parentHeader:\n              msg.header as KernelMessage.IExecuteRequestMsg['header']\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onStdin\n          tester.send(\n            KernelMessage.createMessage({\n              ...options,\n              channel: 'stdin',\n              msgType: 'input_request',\n              content: {\n                prompt: 'prompt',\n                password: false\n              },\n              parentHeader: msg.header\n            })\n          );\n        };\n\n        future.onStdin = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage<KernelMessage.IStreamMsg>({\n              ...options,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: '' },\n              parentHeader: msg.header\n            })\n          );\n        };\n\n        future.onIOPub = ioMsg => {\n          if (ioMsg.header.msg_type === 'stream') {\n            // trigger onDone\n            tester.send(\n              KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n                ...options,\n                channel: 'iopub',\n                msgType: 'status',\n                content: {\n                  execution_state: 'idle'\n                },\n                parentHeader: msg.header\n              })\n            );\n          }\n        };\n      });\n\n      const kernel = await tester.start();\n      future = kernel.requestExecute(content);\n      await future.done;\n      expect(future.isDisposed).toBe(true);\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should not dispose of KernelFuture when disposeOnDone=false",
            "suites": [
                "Kernel.IKernel",
                "#requestExecute()"
            ],
            "updatePoint": {
                "line": 1024,
                "column": 67
            },
            "line": 1024,
            "code": "    it('should not dispose of KernelFuture when disposeOnDone=false', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const future = defaultKernel.requestExecute(options, false);\n      await future.done;\n      expect(future.isDisposed).toBe(false);\n      future.dispose();\n      expect(future.isDisposed).toBe(true);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept cell metadata as part of request",
            "suites": [
                "Kernel.IKernel",
                "#checkExecuteMetadata()"
            ],
            "updatePoint": {
                "line": 1042,
                "column": 54
            },
            "line": 1042,
            "code": "    it('should accept cell metadata as part of request', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const metadata = { cellId: 'test' };\n      const future = defaultKernel.requestExecute(options, false, metadata);\n      await future.done;\n      expect(future.msg.metadata).toEqual(metadata);\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should have the most recently registered hook run first",
            "suites": [
                "Kernel.IKernel",
                "#registerMessageHook()"
            ],
            "updatePoint": {
                "line": 1059,
                "column": 63
            },
            "line": 1059,
            "code": "    it('should have the most recently registered hook run first', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      let future: Kernel.IShellFuture;\n\n      let kernel: Kernel.IKernelConnection;\n\n      const tester = new KernelTester();\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, async msg => {\n          // Make this hook call asynchronous\n          // tslint:disable-next-line:await-promise\n          await calls.push('last');\n          return true;\n        });\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('first');\n          // not returning should also continue handling\n          return void 0 as any;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual([\n        'first',\n        'last',\n        'iopub',\n        'first',\n        'last',\n        'iopub'\n      ]);\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should abort processing if a hook returns false, but the done logic should still work",
            "suites": [
                "Kernel.IKernel",
                "#registerMessageHook()"
            ],
            "updatePoint": {
                "line": 1145,
                "column": 93
            },
            "line": 1145,
            "code": "    it('should abort processing if a hook returns false, but the done logic should still work', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('last');\n          return true;\n        });\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('first');\n          return false;\n        });\n\n        future.onIOPub = async () => {\n          // tslint:disable-next-line:await-promise\n          await calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      // the last hook was called for the stream and the status message.\n      expect(calls).toEqual(['first', 'first']);\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should process additions on the next run",
            "suites": [
                "Kernel.IKernel",
                "#registerMessageHook()"
            ],
            "updatePoint": {
                "line": 1222,
                "column": 48
            },
            "line": 1222,
            "code": "    it('should process additions on the next run', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          calls.push('last');\n          kernel.registerMessageHook(parentHeader.msg_id, msg => {\n            calls.push('first');\n            return true;\n          });\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['last', 'iopub', 'first', 'last', 'iopub']);\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should deactivate a hook immediately on removal",
            "suites": [
                "Kernel.IKernel",
                "#registerMessageHook()"
            ],
            "updatePoint": {
                "line": 1295,
                "column": 55
            },
            "line": 1295,
            "code": "    it('should deactivate a hook immediately on removal', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: false,\n        stop_on_error: false\n      };\n      const calls: string[] = [];\n      const tester = new KernelTester();\n      let future: Kernel.IShellFuture;\n      let kernel: Kernel.IKernelConnection;\n\n      tester.onMessage(message => {\n        // send a reply\n        const parentHeader = message.header;\n        const session = 'session';\n        tester.send(\n          KernelMessage.createMessage({\n            parentHeader,\n            session,\n            channel: 'shell',\n            msgType: 'comm_open',\n            content: { comm_id: 'B', data: {}, target_name: 'C' }\n          })\n        );\n\n        future.onReply = () => {\n          // trigger onIOPub with a 'stream' message\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'stream',\n              content: { name: 'stdout', text: 'foo' }\n            })\n          );\n          // trigger onDone\n          tester.send(\n            KernelMessage.createMessage({\n              parentHeader,\n              session,\n              channel: 'iopub',\n              msgType: 'status',\n              content: { execution_state: 'idle' }\n            })\n          );\n        };\n\n        const toDelete = (msg: KernelMessage.IIOPubMessage) => {\n          calls.push('delete');\n          return true;\n        };\n        kernel.registerMessageHook(parentHeader.msg_id, toDelete);\n        kernel.registerMessageHook(parentHeader.msg_id, msg => {\n          if (calls.length > 0) {\n            // delete the hook the second time around\n            kernel.removeMessageHook(parentHeader.msg_id, toDelete);\n          }\n          calls.push('first');\n          return true;\n        });\n\n        future.onIOPub = () => {\n          calls.push('iopub');\n        };\n      });\n\n      kernel = await tester.start();\n      future = kernel.requestExecute(options, false);\n      await future.done;\n      expect(calls).toEqual(['first', 'delete', 'iopub', 'first', 'iopub']);\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should run handlers in order",
            "suites": [
                "Kernel.IKernel",
                "handles messages asynchronously"
            ],
            "updatePoint": {
                "line": 1379,
                "column": 36
            },
            "line": 1379,
            "code": "    it('should run handlers in order', async () => {\n      const options: KernelMessage.IExecuteRequestMsg['content'] = {\n        code: 'test',\n        silent: false,\n        store_history: true,\n        user_expressions: {},\n        allow_stdin: true,\n        stop_on_error: false\n      };\n\n      const tester = new KernelTester();\n      const kernel = await tester.start();\n      const future = kernel.requestExecute(options, false);\n\n      // The list of emissions from the anyMessage signal.\n      const msgSignal: string[][] = [];\n      const msgSignalExpected: string[][] = [];\n\n      // The list of message processing calls\n      const calls: string[][] = [];\n      const callsExpected: string[][] = [];\n\n      function pushIopub(msgId: string) {\n        callsExpected.push([msgId, 'future hook a']);\n        callsExpected.push([msgId, 'future hook b']);\n        callsExpected.push([msgId, 'kernel hook a']);\n        callsExpected.push([msgId, 'kernel hook b']);\n        callsExpected.push([msgId, 'iopub']);\n        msgSignalExpected.push([msgId, 'iopub']);\n      }\n\n      function pushCommOpen(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm open']);\n      }\n\n      function pushCommMsg(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm msg']);\n      }\n\n      function pushCommClose(msgId: string) {\n        pushIopub(msgId);\n        callsExpected.push([msgId, 'comm close']);\n      }\n\n      function pushStdin(msgId: string) {\n        callsExpected.push([msgId, 'stdin']);\n        msgSignalExpected.push([msgId, 'stdin']);\n      }\n\n      function pushReply(msgId: string) {\n        callsExpected.push([msgId, 'reply']);\n        msgSignalExpected.push([msgId, 'shell']);\n      }\n\n      const anyMessageDone = new PromiseDelegate();\n      const handlingBlock = new PromiseDelegate();\n\n      tester.onMessage(message => {\n        tester.onMessage(() => {\n          return;\n        });\n        tester.parentHeader = message.header;\n\n        pushIopub(tester.sendStatus('busy', 'busy'));\n        pushIopub(tester.sendStream('stdout', { name: 'stdout', text: 'foo' }));\n        pushCommOpen(\n          tester.sendCommOpen('comm open', {\n            target_name: 'commtarget',\n            comm_id: 'commid',\n            data: {}\n          })\n        );\n        pushIopub(\n          tester.sendDisplayData('display 1', { data: {}, metadata: {} })\n        );\n        pushCommMsg(\n          tester.sendCommMsg('comm 1', { comm_id: 'commid', data: {} })\n        );\n        pushCommMsg(\n          tester.sendCommMsg('comm 2', { comm_id: 'commid', data: {} })\n        );\n        pushCommClose(\n          tester.sendCommClose('comm close', { comm_id: 'commid', data: {} })\n        );\n        pushStdin(\n          tester.sendInputRequest('stdin', { prompt: '', password: false })\n        );\n        pushIopub(\n          tester.sendDisplayData('display 2', {\n            data: {},\n            metadata: {},\n            transient: { display_id: 'displayid' }\n          })\n        );\n        pushIopub(\n          tester.sendUpdateDisplayData('update display', {\n            data: {},\n            metadata: {},\n            transient: { display_id: 'displayid' }\n          })\n        );\n        pushIopub(\n          tester.sendExecuteResult('execute result', {\n            execution_count: 1,\n            data: {},\n            metadata: {}\n          })\n        );\n        pushIopub(tester.sendStatus('idle', 'idle'));\n        pushReply(\n          tester.sendExecuteReply('execute reply', {\n            status: 'ok',\n            execution_count: 1,\n            user_expressions: {}\n          })\n        );\n\n        tester.parentHeader = undefined;\n      });\n\n      kernel.anyMessage.connect((k, args) => {\n        msgSignal.push([args.msg.header.msg_id, args.msg.channel]);\n        if (args.msg.header.msg_id === 'execute reply') {\n          anyMessageDone.resolve(undefined);\n        }\n      });\n\n      kernel.registerMessageHook(future.msg.header.msg_id, async msg => {\n        // Make this hook call asynchronous\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'kernel hook b']);\n        return true;\n      });\n\n      kernel.registerMessageHook(future.msg.header.msg_id, async msg => {\n        calls.push([msg.header.msg_id, 'kernel hook a']);\n        return true;\n      });\n\n      kernel.registerCommTarget('commtarget', async (comm, msg) => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'comm open']);\n\n        comm.onMsg = async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push([msg.header.msg_id, 'comm msg']);\n        };\n        comm.onClose = async msg => {\n          // tslint:disable-next-line:await-promise\n          await calls.push([msg.header.msg_id, 'comm close']);\n        };\n      });\n\n      future.registerMessageHook(async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'future hook b']);\n        return true;\n      });\n\n      future.registerMessageHook(async msg => {\n        // Delay processing until after we've checked the anyMessage results.\n        await handlingBlock.promise;\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'future hook a']);\n        return true;\n      });\n\n      future.onIOPub = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'iopub']);\n      };\n\n      future.onStdin = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'stdin']);\n      };\n\n      future.onReply = async msg => {\n        // tslint:disable-next-line:await-promise\n        await calls.push([msg.header.msg_id, 'reply']);\n      };\n\n      // Give the kernel time to receive and queue up the messages.\n      await anyMessageDone.promise;\n\n      // At this point, the synchronous anyMessage signal should have been\n      // emitted for every message, but no actual message handling should have\n      // happened.\n      expect(msgSignal).toEqual(msgSignalExpected);\n      expect(calls).toEqual([]);\n\n      // Release the lock on message processing.\n      handlingBlock.resolve(undefined);\n      await future.done;\n      expect(calls).toEqual(callsExpected);\n\n      await tester.shutdown();\n      tester.dispose();\n    });",
            "file": "kernel/ikernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should yield a list of valid kernel ids",
            "suites": [
                "kernel",
                "Kernel.listRunning()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 47
            },
            "line": 42,
            "code": "    it('should yield a list of valid kernel ids', async () => {\n      const kernel = await KernelAPI.startNew();\n      expect(Array.from(await KernelAPI.listRunning()).length).toBeGreaterThan(\n        0\n      );\n      await KernelAPI.shutdownKernel(kernel.id);\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept server settings",
            "suites": [
                "kernel",
                "Kernel.listRunning()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 37
            },
            "line": 50,
            "code": "    it('should accept server settings', async () => {\n      const serverSettings = makeSettings();\n      const k = await KernelAPI.startNew({}, serverSettings);\n      const response = await KernelAPI.listRunning(serverSettings);\n      expect(Array.from(response).length).toBeGreaterThan(0);\n      await KernelAPI.shutdownKernel(k.id);\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid model",
            "suites": [
                "kernel",
                "Kernel.listRunning()"
            ],
            "updatePoint": {
                "line": 58,
                "column": 50
            },
            "line": 58,
            "code": "    it('should throw an error for an invalid model', async () => {\n      const data = { id: UUID.uuid4(), name: 'test' };\n      const settings = getRequestHandler(200, data);\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow(/Invalid kernel list/);\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "kernel",
                "Kernel.listRunning()"
            ],
            "updatePoint": {
                "line": 65,
                "column": 53
            },
            "line": 65,
            "code": "    it('should throw an error for an invalid response', async () => {\n      const settings = getRequestHandler(201, {});\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an error response",
            "suites": [
                "kernel",
                "Kernel.listRunning()"
            ],
            "updatePoint": {
                "line": 71,
                "column": 51
            },
            "line": 71,
            "code": "    it('should throw an error for an error response', async () => {\n      const settings = getRequestHandler(500, {});\n      const promise = KernelAPI.listRunning(settings);\n      await expect(promise).rejects.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept ajax options",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 79,
                "column": 34
            },
            "line": 79,
            "code": "    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      const k = await KernelAPI.startNew({}, serverSettings);\n      await expect(KernelAPI.shutdownKernel(k.id)).resolves.not.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should still construct connection if the kernel dies",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 85,
                "column": 60
            },
            "line": 85,
            "code": "    it('should still construct connection if the kernel dies', async () => {\n      // If a kernel dies immediately, the kernel connection should still send\n      // out the status signal, then dispose the connection.\n      tester = new KernelTester();\n      tester.initialStatus = 'dead';\n      const kernel = await tester.start();\n      const dead = testEmission(kernel.statusChanged, {\n        test: (sender, state) => state === 'dead'\n      });\n      await dead;\n      expect(kernel.isDisposed).toBe(true);\n      expect(kernel.status).toBe('dead');\n      tester.dispose();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid kernel id",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 54
            },
            "line": 100,
            "code": "    it('should throw an error for an invalid kernel id', async () => {\n      const serverSettings = getRequestHandler(201, { id: UUID.uuid4() });\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for another invalid kernel id",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 106,
                "column": 59
            },
            "line": 106,
            "code": "    it('should throw an error for another invalid kernel id', async () => {\n      const serverSettings = getRequestHandler(201, {\n        id: UUID.uuid4(),\n        name: 1\n      });\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 115,
                "column": 53
            },
            "line": 115,
            "code": "    it('should throw an error for an invalid response', async () => {\n      const data = { id: UUID.uuid4(), name: 'foo' };\n      const serverSettings = getRequestHandler(200, data);\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow(/Invalid response: 200 OK/);\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an error response",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 122,
                "column": 51
            },
            "line": 122,
            "code": "    it('should throw an error for an error response', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const kernelPromise = KernelAPI.startNew({}, serverSettings);\n      await expect(kernelPromise).rejects.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should auto-reconnect on websocket error",
            "suites": [
                "kernel",
                "KernelAPI.startNew()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 48
            },
            "line": 128,
            "code": "    it('should auto-reconnect on websocket error', async () => {\n      tester = new KernelTester();\n      const kernel = await tester.start();\n      await kernel.info;\n\n      const emission = testEmission(kernel.connectionStatusChanged, {\n        find: (k, status) => status === 'connecting'\n      });\n      await tester.close();\n      await expect(emission).resolves.not.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down a kernel by id",
            "suites": [
                "kernel",
                "Kernel.shutdown()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 39
            },
            "line": 142,
            "code": "    it('should shut down a kernel by id', async () => {\n      const kernel = await KernelAPI.startNew();\n      await KernelAPI.shutdownKernel(kernel.id);\n      const kernels = await KernelAPI.listRunning();\n      expect(kernels.find(k => k.id === kernel.id)).toBeUndefined();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a 404 error",
            "suites": [
                "kernel",
                "Kernel.shutdown()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 33
            },
            "line": 149,
            "code": "    it('should handle a 404 error', async () => {\n      await expect(\n        KernelAPI.shutdownKernel(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });",
            "file": "kernel/kernel.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take the options as an argument",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 48
            },
            "line": 42,
            "code": "      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new KernelManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        expect(manager instanceof KernelManager).toBe(true);\n        await manager.ready;\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 54,
                "column": 40
            },
            "line": 54,
            "code": "      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelManager({ serverSettings, standby });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the running sessions",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 66,
                "column": 41
            },
            "line": 66,
            "code": "      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toBeGreaterThan(0);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted in refreshRunning when the running kernels changed",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 72,
                "column": 78
            },
            "line": 72,
            "code": "      it('should be emitted in refreshRunning when the running kernels changed', async () => {\n        let called = false;\n        manager.runningChanged.connect((sender, args) => {\n          expect(sender).toBe(manager);\n          expect(Array.from(args).length).toBeGreaterThan(0);\n          called = true;\n        });\n        await KernelAPI.startNew();\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a kernel is shut down",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 84,
                "column": 54
            },
            "line": 84,
            "code": "      it('should be emitted when a kernel is shut down', async () => {\n        const kernel = await manager.startNew();\n        await kernel.info;\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.shutdown(kernel.id);\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is ready",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#isReady"
            ],
            "updatePoint": {
                "line": 98,
                "column": 50
            },
            "line": 98,
            "code": "      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new KernelManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve when the manager is ready",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#ready"
            ],
            "updatePoint": {
                "line": 108,
                "column": 50
            },
            "line": 108,
            "code": "      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running kernels",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 114,
                "column": 43
            },
            "line": 114,
            "code": "      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toBeGreaterThan(0);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running kernels when one is shut down",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 119,
                "column": 65
            },
            "line": 119,
            "code": "      it('should update the running kernels when one is shut down', async () => {\n        const old = Array.from(manager.running()).length;\n        await KernelAPI.startNew();\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toBeGreaterThan(old);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should start a new kernel",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 35
            },
            "line": 128,
            "code": "      it('should start a new kernel', async () => {\n        await expect(manager.startNew()).resolves.not.toThrow();\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 132,
                "column": 45
            },
            "line": 132,
            "code": "      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        const kernel = await manager.startNew();\n        await kernel.info;\n        expect(called).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should find an existing kernel by id",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#findById()"
            ],
            "updatePoint": {
                "line": 144,
                "column": 46
            },
            "line": 144,
            "code": "      it('should find an existing kernel by id', async () => {\n        const id = kernel.id;\n        const model = await manager.findById(id);\n        expect(model!.id).toBe(id);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should connect to an existing kernel",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 152,
                "column": 46
            },
            "line": 152,
            "code": "      it('should connect to an existing kernel', () => {\n        const id = kernel.id;\n        const newConnection = manager.connectTo({ model: kernel });\n        expect(newConnection.model.id).toBe(id);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down a kernel by id",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 160,
                "column": 41
            },
            "line": 160,
            "code": "      it('should shut down a kernel by id', async () => {\n        const kernel = await manager.startNew();\n        await kernel.info;\n        await manager.shutdown(kernel.id);\n        expect(kernel.isDisposed).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 167,
                "column": 45
            },
            "line": 167,
            "code": "      it('should emit a runningChanged signal', async () => {\n        const kernel = await manager.startNew();\n        const emission = testEmission(manager.runningChanged, {\n          test: () => {\n            expect(kernel.isDisposed).toBe(false);\n          }\n        });\n        await kernel.info;\n        await manager.shutdown(kernel.id);\n        await emission;\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of all relevant kernel connections",
            "suites": [
                "kernel/manager",
                "KernelManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 179,
                "column": 59
            },
            "line": 179,
            "code": "      it('should dispose of all relevant kernel connections', async () => {\n        const kernel0 = await manager.startNew();\n        const kernel1 = manager.connectTo({ model: kernel0.model });\n        await kernel0.info;\n        await kernel1.info;\n        await manager.refreshRunning();\n        await kernel0.shutdown();\n        expect(kernel0.status).toBe('dead');\n        expect(kernel0.isDisposed).toBe(true);\n\n        // Wait for the round trip to the server to update the connections.\n        await sleep(100);\n        expect(kernel1.status).toBe('dead');\n        expect(kernel1.isDisposed).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take the options as an argument",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 210,
                "column": 48
            },
            "line": 210,
            "code": "      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new KernelManager.NoopManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof KernelManager.NoopManager).toBe(true);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 222,
                "column": 40
            },
            "line": 222,
            "code": "      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelManager.NoopManager({ serverSettings, standby });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the running sessions",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 234,
                "column": 41
            },
            "line": 234,
            "code": "      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running kernels",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 241,
                "column": 43
            },
            "line": 241,
            "code": "      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 248,
                "column": 31
            },
            "line": 248,
            "code": "      it('should throw an error', () => {\n        return expect(manager.startNew()).rejects.toThrow();\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 31
            },
            "line": 254,
            "code": "      it('should throw an error', () => {\n        return expect(() => {\n          manager.connectTo({ model: kernel });\n        }).toThrow();\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "kernel/manager",
                "NoopManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 262,
                "column": 31
            },
            "line": 262,
            "code": "      it('should throw an error', () => {\n        return expect(manager.shutdown(kernel.id)).rejects.toThrow();\n      });",
            "file": "kernel/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a stream message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isStreamMsg()"
            ],
            "updatePoint": {
                "line": 17,
                "column": 46
            },
            "line": 17,
            "code": "    it('should check for a stream message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IStreamMsg>({\n        msgType: 'stream',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          name: 'stdout',\n          text: 'hello world'\n        }\n      });\n      expect(KernelMessage.isStreamMsg(msg)).toBe(true);\n      expect(KernelMessage.isStreamMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a display data message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isDisplayDataMsg()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 52
            },
            "line": 33,
            "code": "    it('should check for a display data message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IDisplayDataMsg>({\n        msgType: 'display_data',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          data: {},\n          metadata: {}\n        }\n      });\n      expect(KernelMessage.isDisplayDataMsg(msg)).toBe(true);\n      expect(KernelMessage.isDisplayDataMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a execute input message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isExecuteInputMsg()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 53
            },
            "line": 49,
            "code": "    it('should check for a execute input message type', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IExecuteInputMsg>({\n        msgType: 'execute_input',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          code: '',\n          execution_count: 1\n        }\n      });\n      expect(KernelMessage.isExecuteInputMsg(msg)).toBe(true);\n      expect(KernelMessage.isExecuteInputMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for an execute result message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isExecuteResultMsg()"
            ],
            "updatePoint": {
                "line": 65,
                "column": 55
            },
            "line": 65,
            "code": "    it('should check for an execute result message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'execute_result',\n        channel: 'iopub',\n        session: 'baz',\n        content: { data: {}, execution_count: 1, metadata: {} }\n      });\n      expect(KernelMessage.isExecuteResultMsg(msg)).toBe(true);\n      expect(KernelMessage.isExecuteResultMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a status message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isStatusMsg()"
            ],
            "updatePoint": {
                "line": 78,
                "column": 46
            },
            "line": 78,
            "code": "    it('should check for a status message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'status',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          execution_state: 'idle'\n        }\n      });\n      expect(KernelMessage.isStatusMsg(msg)).toBe(true);\n      const msg2 = KernelMessage.createMessage<KernelMessage.IExecuteInputMsg>({\n        msgType: 'execute_input',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          code: '',\n          execution_count: 1\n        }\n      });\n      expect(KernelMessage.isStatusMsg(msg2)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a clear output message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isClearOutputMsg()"
            ],
            "updatePoint": {
                "line": 102,
                "column": 52
            },
            "line": 102,
            "code": "    it('should check for a clear output message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'clear_output',\n        channel: 'iopub',\n        session: 'baz',\n        content: { wait: true }\n      });\n      expect(KernelMessage.isClearOutputMsg(msg)).toBe(true);\n      expect(KernelMessage.isClearOutputMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for a comm open message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isCommOpenMsg()"
            ],
            "updatePoint": {
                "line": 115,
                "column": 49
            },
            "line": 115,
            "code": "    it('should check for a comm open message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_open',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          comm_id: 'id',\n          data: {},\n          target_name: 'target'\n        }\n      });\n      expect(KernelMessage.isCommOpenMsg(msg)).toBe(true);\n      expect(KernelMessage.isCommOpenMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for an message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isErrorMsg()"
            ],
            "updatePoint": {
                "line": 132,
                "column": 40
            },
            "line": 132,
            "code": "    it('should check for an message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'error',\n        channel: 'iopub',\n        session: 'baz',\n        content: {\n          ename: '',\n          evalue: '',\n          traceback: []\n        }\n      });\n      expect(KernelMessage.isErrorMsg(msg)).toBe(true);\n      expect(KernelMessage.isErrorMsg(iopubStatusMsg)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should check for an input_request message type",
            "suites": [
                "kernel/messages",
                "KernelMessage.isInputRequestMsg()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 54
            },
            "line": 149,
            "code": "    it('should check for an input_request message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'input_request',\n        channel: 'stdin',\n        session: 'baz',\n        content: { prompt: '', password: false }\n      });\n      expect(KernelMessage.isInputRequestMsg(msg)).toBe(true);\n      const msg2 = KernelMessage.createMessage<KernelMessage.IInputReplyMsg>({\n        msgType: 'input_reply',\n        channel: 'stdin',\n        session: 'baz',\n        content: {\n          status: 'ok',\n          value: ''\n        }\n      });\n      expect(KernelMessage.isInputRequestMsg(msg2)).toBe(false);\n    });",
            "file": "kernel/messages.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass a valid message",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 9,
                "column": 35
            },
            "line": 9,
            "code": "    it('should pass a valid message', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'foo',\n        content: { comm_id: 'foo', data: {} }\n      });\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw if missing a field",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 21,
                "column": 39
            },
            "line": 21,
            "code": "    it('should throw if missing a field', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      delete (msg as any).channel;\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw if a field is invalid",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 32,
                "column": 42
            },
            "line": 32,
            "code": "    it('should throw if a field is invalid', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      (msg as any).header.username = 1;\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw if the parent header is given an invalid",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 43,
                "column": 61
            },
            "line": 43,
            "code": "    it('should throw if the parent header is given an invalid', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      msg.parent_header = msg.header;\n      (msg as any).parent_header.username = 1;\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw if the channel is not a string",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 55,
                "column": 51
            },
            "line": 55,
            "code": "    it('should throw if the channel is not a string', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      (msg as any).channel = 1;\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should validate an iopub message",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 66,
                "column": 40
            },
            "line": 66,
            "code": "    it('should validate an iopub message', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_close',\n        channel: 'iopub',\n        session: 'baz',\n        content: { comm_id: 'foo', data: {} }\n      });\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should ignore on an unknown iopub message type",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 78,
                "column": 54
            },
            "line": 78,
            "code": "    it('should ignore on an unknown iopub message type', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'foo',\n        channel: 'iopub',\n        session: 'baz',\n        content: {}\n      } as any);\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw on missing iopub message content",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 90,
                "column": 53
            },
            "line": 90,
            "code": "    it('should throw on missing iopub message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IErrorMsg>({\n        msgType: 'error',\n        channel: 'iopub',\n        session: 'baz',\n        content: {} as any\n      } as any);\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw on invalid iopub message content",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 100,
                "column": 53
            },
            "line": 100,
            "code": "    it('should throw on invalid iopub message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IClearOutputMsg>({\n        msgType: 'clear_output',\n        channel: 'iopub',\n        session: 'baz',\n        content: { wait: 1 as any }\n      });\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw on invalid iopub status message content",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 110,
                "column": 60
            },
            "line": 110,
            "code": "    it('should throw on invalid iopub status message content', () => {\n      const msg = KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n        msgType: 'status',\n        channel: 'iopub',\n        session: 'baz',\n        content: { execution_state: 'invalid-status' as Kernel.Status }\n      });\n      expect(() => validateMessage(msg)).toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle no buffers field",
            "suites": [
                "kernel/validate",
                "validateMessage"
            ],
            "updatePoint": {
                "line": 120,
                "column": 38
            },
            "line": 120,
            "code": "    it('should handle no buffers field', () => {\n      const msg = KernelMessage.createMessage({\n        msgType: 'comm_msg',\n        channel: 'iopub',\n        session: 'foo',\n        content: { comm_id: 'foo', data: {} }\n      });\n      delete msg['buffers'];\n      expect(() => {\n        validateMessage(msg);\n      }).not.toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass a valid id",
            "suites": [
                "kernel/validate",
                "#validateModel()"
            ],
            "updatePoint": {
                "line": 135,
                "column": 30
            },
            "line": 135,
            "code": "    it('should pass a valid id', () => {\n      const id: Kernel.IModel = { name: 'foo', id: 'baz' };\n      expect(() => {\n        validateModel(id);\n      }).not.toThrow();\n    });",
            "file": "kernel/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should load the kernelspecs",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 35
            },
            "line": 24,
            "code": "    it('should load the kernelspecs', async () => {\n      const specs = await KernelSpecAPI.getSpecs();\n      expect(specs.default).toBeTruthy();\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept ajax options",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 29,
                "column": 34
            },
            "line": 29,
            "code": "    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBeTruthy();\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a missing default parameter",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 35,
                "column": 49
            },
            "line": 35,
            "code": "    it('should handle a missing default parameter', async () => {\n      const serverSettings = getRequestHandler(200, {\n        kernelspecs: { python: PYTHON_SPEC }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBeTruthy();\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw for a missing kernelspecs parameter",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 43,
                "column": 56
            },
            "line": 43,
            "code": "    it('should throw for a missing kernelspecs parameter', async () => {\n      const serverSettings = getRequestHandler(200, {\n        default: PYTHON_SPEC.name\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should omit an invalid kernelspec",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 41
            },
            "line": 51,
            "code": "    it('should omit an invalid kernelspec', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.name = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: {\n          R: R_SPEC,\n          python: PYTHON_SPEC\n        }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n      expect(specs.default).toBe('python');\n      expect(specs.kernelspecs['R']).toBeUndefined();\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle an improper name",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 66,
                "column": 38
            },
            "line": 66,
            "code": "    it('should handle an improper name', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.name = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle an improper language",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 77,
                "column": 42
            },
            "line": 77,
            "code": "    it('should handle an improper language', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.language = 1;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle an improper argv",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 88,
                "column": 38
            },
            "line": 88,
            "code": "    it('should handle an improper argv', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.argv = 'hello';\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle an improper display_name",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 99,
                "column": 46
            },
            "line": 99,
            "code": "    it('should handle an improper display_name', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      R_SPEC.spec.display_name = ['hello'];\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle missing resources",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 39
            },
            "line": 110,
            "code": "    it('should handle missing resources', async () => {\n      const R_SPEC = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      delete R_SPEC.resources;\n      const serverSettings = getRequestHandler(200, {\n        default: 'R',\n        kernelspecs: { R: R_SPEC }\n      });\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/No valid kernelspecs found/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid response",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 53
            },
            "line": 121,
            "code": "    it('should throw an error for an invalid response', async () => {\n      const serverSettings = getRequestHandler(201, {});\n      const promise = KernelSpecAPI.getSpecs(serverSettings);\n      await expect(promise).rejects.toThrow(/Invalid response: 201 Created/);\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle metadata",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 30
            },
            "line": 127,
            "code": "    it('should handle metadata', async () => {\n      const PYTHON_SPEC_W_MD = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      // eslint-disable-next-line camelcase\n      PYTHON_SPEC_W_MD.spec.metadata = { some_application: { key: 'value' } };\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: { python: PYTHON_SPEC_W_MD }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n\n      expect(specs.kernelspecs['python']).toHaveProperty('metadata');\n      const metadata = specs.kernelspecs['python']!.metadata;\n      expect(metadata).toHaveProperty('some_application');\n      expect((metadata as any).some_application).toHaveProperty('key', 'value');\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle env values",
            "suites": [
                "kernel",
                "KernelSpec.getSpecs()"
            ],
            "updatePoint": {
                "line": 143,
                "column": 32
            },
            "line": 143,
            "code": "    it('should handle env values', async () => {\n      const PYTHON_SPEC_W_ENV = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      PYTHON_SPEC_W_ENV.spec.env = {\n        SOME_ENV: 'some_value',\n        LANG: 'en_US.UTF-8'\n      };\n      const serverSettings = getRequestHandler(200, {\n        default: 'python',\n        kernelspecs: { python: PYTHON_SPEC_W_ENV }\n      });\n      const specs = await KernelSpecAPI.getSpecs(serverSettings);\n\n      expect(specs.kernelspecs['python']).toHaveProperty('env');\n      const env = specs.kernelspecs['python']!.env;\n      expect(env).toHaveProperty('SOME_ENV', 'some_value');\n      expect(env).toHaveProperty('LANG', 'en_US.UTF-8');\n    });",
            "file": "kernelspec/kernelspec.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take the options as an argument",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 52,
                "column": 48
            },
            "line": 52,
            "code": "      it('should take the options as an argument', () => {\n        manager.dispose();\n        manager = new KernelSpecManager({\n          serverSettings: makeSettings(),\n          standby: 'never'\n        });\n        expect(manager instanceof KernelSpecManager).toBe(true);\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 63,
                "column": 40
            },
            "line": 63,
            "code": "      it('should get the server settings', () => {\n        manager.dispose();\n        const serverSettings = makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new KernelSpecManager({ serverSettings, standby });\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the kernel specs",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#specs"
            ],
            "updatePoint": {
                "line": 74,
                "column": 37
            },
            "line": 74,
            "code": "      it('should get the kernel specs', async () => {\n        await manager.ready;\n        expect(manager.specs!.default).toBeTruthy();\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the specs change",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#specsChanged"
            ],
            "updatePoint": {
                "line": 81,
                "column": 49
            },
            "line": 81,
            "code": "      it('should be emitted when the specs change', async () => {\n        const manager = new TestManager({ standby: 'never' });\n        const specs = JSONExt.deepCopy(KERNELSPECS) as KernelSpec.ISpecModels;\n        let called = false;\n        manager.specsChanged.connect(() => {\n          called = true;\n        });\n        await manager.ready;\n        expect(manager.specs!.default).toBe('echo');\n        specs.default = 'shell';\n        manager.intercept = specs;\n        await manager.refreshSpecs();\n        expect(manager.specs!.default).toBe('shell');\n        expect(called).toBe(true);\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is ready",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#isReady"
            ],
            "updatePoint": {
                "line": 99,
                "column": 50
            },
            "line": 99,
            "code": "      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new KernelSpecManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve when the manager is ready",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#ready"
            ],
            "updatePoint": {
                "line": 109,
                "column": 50
            },
            "line": 109,
            "code": "      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update list of kernel specs",
            "suites": [
                "kernel/manager",
                "KernelSpecManager",
                "#refreshSpecs()"
            ],
            "updatePoint": {
                "line": 115,
                "column": 44
            },
            "line": 115,
            "code": "      it('should update list of kernel specs', async () => {\n        const manager = new TestManager({ standby: 'never' });\n        const specs = JSONExt.deepCopy(KERNELSPECS) as KernelSpec.ISpecModels;\n        await manager.ready;\n        specs.default = 'shell';\n        manager.intercept = specs;\n        expect(manager.specs!.default).not.toBe('shell');\n        await manager.refreshSpecs();\n        expect(manager.specs!.default).toBe('shell');\n      });",
            "file": "kernelspec/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass with valid data",
            "suites": [
                "kernelspec/validate",
                "#validateSpecModel"
            ],
            "updatePoint": {
                "line": 13,
                "column": 35
            },
            "line": 13,
            "code": "    it('should pass with valid data', () => {\n      expect(() => {\n        validateSpecModel(PYTHON_SPEC);\n      }).not.toThrow();\n    });",
            "file": "kernelspec/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on missing data",
            "suites": [
                "kernelspec/validate",
                "#validateSpecModel"
            ],
            "updatePoint": {
                "line": 19,
                "column": 35
            },
            "line": 19,
            "code": "    it('should fail on missing data', () => {\n      const spec = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      delete spec['name'];\n      expect(() => validateSpecModel(spec)).toThrow();\n    });",
            "file": "kernelspec/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on incorrect data",
            "suites": [
                "kernelspec/validate",
                "#validateSpecModel"
            ],
            "updatePoint": {
                "line": 25,
                "column": 37
            },
            "line": 25,
            "code": "    it('should fail on incorrect data', () => {\n      const spec = JSON.parse(JSON.stringify(PYTHON_SPEC));\n      spec.spec.language = 1;\n      expect(() => validateSpecModel(spec)).toThrow();\n    });",
            "file": "kernelspec/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass with valid data",
            "suites": [
                "kernelspec/validate",
                "#validateSpecModels"
            ],
            "updatePoint": {
                "line": 33,
                "column": 35
            },
            "line": 33,
            "code": "    it('should pass with valid data', () => {\n      const model: JSONObject = {\n        default: 'python',\n        kernelspecs: {\n          python: PYTHON_SPEC\n        }\n      };\n      expect(() => {\n        validateSpecModels(model);\n      }).not.toThrow();\n    });",
            "file": "kernelspec/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on missing data",
            "suites": [
                "kernelspec/validate",
                "#validateSpecModels"
            ],
            "updatePoint": {
                "line": 45,
                "column": 35
            },
            "line": 45,
            "code": "    it('should fail on missing data', () => {\n      const model: any = {\n        default: 'python'\n      };\n      expect(() => validateSpecModels(model)).toThrow();\n    });",
            "file": "kernelspec/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new service manager",
            "suites": [
                "manager",
                "ServiceManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 45
            },
            "line": 38,
            "code": "      it('should create a new service manager', () => {\n        expect(manager).toBeInstanceOf(ServiceManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the sessions manager instance",
            "suites": [
                "manager",
                "ServiceManager",
                "#sessions"
            ],
            "updatePoint": {
                "line": 44,
                "column": 49
            },
            "line": 44,
            "code": "      it('should be the sessions manager instance', () => {\n        expect(manager.sessions).toBeInstanceOf(SessionManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the setting manager instance",
            "suites": [
                "manager",
                "ServiceManager",
                "#settings"
            ],
            "updatePoint": {
                "line": 50,
                "column": 48
            },
            "line": 50,
            "code": "      it('should be the setting manager instance', () => {\n        expect(manager.settings).toBeInstanceOf(SettingManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the content manager instance",
            "suites": [
                "manager",
                "ServiceManager",
                "#contents"
            ],
            "updatePoint": {
                "line": 56,
                "column": 48
            },
            "line": 56,
            "code": "      it('should be the content manager instance', () => {\n        expect(manager.contents).toBeInstanceOf(ContentsManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the terminal manager instance",
            "suites": [
                "manager",
                "ServiceManager",
                "#terminals"
            ],
            "updatePoint": {
                "line": 62,
                "column": 49
            },
            "line": 62,
            "code": "      it('should be the terminal manager instance', () => {\n        expect(manager.terminals).toBeInstanceOf(TerminalManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the workspace manager instance",
            "suites": [
                "manager",
                "ServiceManager",
                "#workspaces"
            ],
            "updatePoint": {
                "line": 68,
                "column": 50
            },
            "line": 68,
            "code": "      it('should be the workspace manager instance', () => {\n        expect(manager.workspaces).toBeInstanceOf(WorkspaceManager);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is ready",
            "suites": [
                "manager",
                "ServiceManager",
                "#isReady"
            ],
            "updatePoint": {
                "line": 74,
                "column": 50
            },
            "line": 74,
            "code": "      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new ServiceManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should clone a kernel",
            "suites": [
                "mock",
                "cloneKernel()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 29
            },
            "line": 9,
            "code": "    it('should clone a kernel', () => {\n      const kernel0 = new Mock.KernelMock({});\n      const kernel1 = Mock.cloneKernel(kernel0);\n      expect(kernel0.id).toBe(kernel1.id);\n      expect(kernel0.clientId).not.toBe(kernel1.clientId);\n    });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a mock kernel",
            "suites": [
                "mock",
                "KernelMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 19,
                "column": 37
            },
            "line": 19,
            "code": "      it('should create a mock kernel', () => {\n        const kernel = new Mock.KernelMock({});\n        expect(kernel.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take options",
            "suites": [
                "mock",
                "KernelMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 24,
                "column": 29
            },
            "line": 24,
            "code": "      it('should take options', () => {\n        const kernel = new Mock.KernelMock({ model: { name: 'foo' } });\n        expect(kernel.name).toBe('foo');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve with a kernel spec",
            "suites": [
                "mock",
                "KernelMock",
                ".spec()"
            ],
            "updatePoint": {
                "line": 31,
                "column": 43
            },
            "line": 31,
            "code": "      it('should resolve with a kernel spec', async () => {\n        const kernel = new Mock.KernelMock({});\n        const spec = await kernel.spec;\n        expect(spec!.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "KernelMock",
                ".dispose()"
            ],
            "updatePoint": {
                "line": 39,
                "column": 27
            },
            "line": 39,
            "code": "      it('should be a no-op', () => {\n        const kernel = new Mock.KernelMock({});\n        expect(() => {\n          kernel.dispose();\n        }).not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should clone the kernel",
            "suites": [
                "mock",
                "KernelMock",
                ".clone()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 33
            },
            "line": 48,
            "code": "      it('should clone the kernel', () => {\n        const kernel0 = new Mock.KernelMock({});\n        const kernel1 = kernel0.clone();\n        expect(kernel0.id).toBe(kernel1.id);\n        expect(kernel0.clientId).not.toBe(kernel1.clientId);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve with info",
            "suites": [
                "mock",
                "KernelMock",
                ".info"
            ],
            "updatePoint": {
                "line": 57,
                "column": 34
            },
            "line": 57,
            "code": "      it('should resolve with info', async () => {\n        const kernel = new Mock.KernelMock({});\n        const info = await kernel.info;\n        expect(info.language_info.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "KernelMock",
                ".shutdown()"
            ],
            "updatePoint": {
                "line": 65,
                "column": 27
            },
            "line": 65,
            "code": "      it('should be a no-op', async () => {\n        const kernel = new Mock.KernelMock({});\n        await expect(kernel.shutdown()).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the history info",
            "suites": [
                "mock",
                "KernelMock",
                ".requestHistory()"
            ],
            "updatePoint": {
                "line": 72,
                "column": 37
            },
            "line": 72,
            "code": "      it('should get the history info', async () => {\n        const kernel = new Mock.KernelMock({});\n        const reply = await kernel.requestHistory({} as any);\n        expect(reply.content.status).toBe('ok');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "KernelMock",
                ".restart()"
            ],
            "updatePoint": {
                "line": 80,
                "column": 27
            },
            "line": 80,
            "code": "      it('should be a no-op', async () => {\n        const kernel = new Mock.KernelMock({});\n        await expect(kernel.restart()).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should request execution",
            "suites": [
                "mock",
                "KernelMock",
                ".requestExecute()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 34
            },
            "line": 87,
            "code": "      it('should request execution', async () => {\n        const kernel = new Mock.KernelMock({});\n        let called = false;\n        kernel.iopubMessage.connect((_, msg) => {\n          if (msg.header.msg_type === 'execute_input') {\n            called = true;\n          }\n        });\n        const future = kernel.requestExecute({ code: 'foo ' });\n        await future.done;\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new SessionConnectionMock",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 104,
                "column": 51
            },
            "line": 104,
            "code": "      it('should create a new SessionConnectionMock', () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take options",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 29
            },
            "line": 109,
            "code": "      it('should take options', () => {\n        const kernel = new Mock.KernelMock({});\n        const session = new Mock.SessionConnectionMock(\n          { model: { name: 'foo' } },\n          kernel\n        );\n        expect(session.kernel).toBe(kernel);\n        expect(session.name).toBe('foo');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".dispose()"
            ],
            "updatePoint": {
                "line": 121,
                "column": 27
            },
            "line": 121,
            "code": "      it('should be a no-op', () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        expect(() => {\n          session.dispose();\n        }).not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should change the kernel",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".changeKernel()"
            ],
            "updatePoint": {
                "line": 130,
                "column": 34
            },
            "line": 130,
            "code": "      it('should change the kernel', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        const oldId = session.kernel!.id;\n        const kernel = await session.changeKernel({ name: Mock.DEFAULT_NAME });\n        expect(kernel!.id).not.toBe(oldId);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".shutdown()"
            ],
            "updatePoint": {
                "line": 139,
                "column": 27
            },
            "line": 139,
            "code": "      it('should be a no-op', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the path",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".setPath()"
            ],
            "updatePoint": {
                "line": 146,
                "column": 29
            },
            "line": 146,
            "code": "      it('should set the path', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'path') {\n            called = true;\n          }\n        });\n        await session.setPath('foo');\n        expect(session.path).toBe('foo');\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the type",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".setType()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 29
            },
            "line": 161,
            "code": "      it('should set the type', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'type') {\n            called = true;\n          }\n        });\n        await session.setType('foo');\n        expect(session.type).toBe('foo');\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the name",
            "suites": [
                "mock",
                "SessionConnectionMock",
                ".setName()"
            ],
            "updatePoint": {
                "line": 176,
                "column": 29
            },
            "line": 176,
            "code": "      it('should set the name', async () => {\n        const session = new Mock.SessionConnectionMock({}, null);\n        let called = false;\n        session.propertyChanged.connect((_, args) => {\n          if (args === 'name') {\n            called = true;\n          }\n        });\n        await session.setName('foo');\n        expect(session.name).toBe('foo');\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new mock",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 193,
                "column": 34
            },
            "line": 193,
            "code": "      it('should create a new mock', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(manager.localPath('foo')).toBe('foo');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new text file",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".newUntitled"
            ],
            "updatePoint": {
                "line": 200,
                "column": 39
            },
            "line": 200,
            "code": "      it('should create a new text file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type === 'new') {\n            called = true;\n          }\n        });\n        const contents = await manager.newUntitled();\n        expect(contents.type).toBe('file');\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new notebook",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".newUntitled"
            ],
            "updatePoint": {
                "line": 213,
                "column": 38
            },
            "line": 213,
            "code": "      it('should create a new notebook', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const contents = await manager.newUntitled({ type: 'notebook' });\n        expect(contents.type).toBe('notebook');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a checkpoint",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".createCheckpoint()"
            ],
            "updatePoint": {
                "line": 221,
                "column": 36
            },
            "line": 221,
            "code": "      it('should create a checkpoint', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        expect(checkpoint.id).toBeTruthy();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should list the checkpoints",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".listCheckpoints()"
            ],
            "updatePoint": {
                "line": 230,
                "column": 37
            },
            "line": 230,
            "code": "      it('should list the checkpoints', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        const checkpoints = await manager.listCheckpoints(content.path);\n        expect(checkpoints[0].id).toBe(checkpoint.id);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete a checkpoints",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".deleteCheckpoint"
            ],
            "updatePoint": {
                "line": 240,
                "column": 37
            },
            "line": 240,
            "code": "      it('should delete a checkpoints', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        const checkpoint = await manager.createCheckpoint(content.path);\n        await manager.deleteCheckpoint(content.path, checkpoint.id);\n        const checkpoints = await manager.listCheckpoints(content.path);\n        expect(checkpoints.length).toBe(0);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should restore the contents",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".restoreCheckpoint()"
            ],
            "updatePoint": {
                "line": 251,
                "column": 37
            },
            "line": 251,
            "code": "      it('should restore the contents', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        await manager.save(content.path, { content: 'foo' });\n        const checkpoint = await manager.createCheckpoint(content.path);\n        await manager.save(content.path, { content: 'bar' });\n        await manager.restoreCheckpoint(content.path, checkpoint.id);\n        const newContent = await manager.get(content.path);\n        expect(newContent.content).toBe('foo');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should normalize a path",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".normalize()"
            ],
            "updatePoint": {
                "line": 264,
                "column": 33
            },
            "line": 264,
            "code": "      it('should normalize a path', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(manager.normalize('foo/bar/../baz')).toBe('foo/baz');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the local path of a file",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".localPath"
            ],
            "updatePoint": {
                "line": 271,
                "column": 45
            },
            "line": 271,
            "code": "      it('should get the local path of a file', () => {\n        const manager = new Mock.ContentsManagerMock();\n        const defaultDrive = manager.driveName('foo');\n        expect(manager.localPath(`${defaultDrive}foo/bar`)).toBe('foo/bar');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the file contents",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".get()"
            ],
            "updatePoint": {
                "line": 279,
                "column": 38
            },
            "line": 279,
            "code": "      it('should get the file contents', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        const content = await manager.newUntitled();\n        await manager.save(content.path, { content: 'foo' });\n        const newContent = await manager.get(content.path);\n        expect(newContent.content).toBe('foo');\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the drive name of the path",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".driveName()"
            ],
            "updatePoint": {
                "line": 289,
                "column": 47
            },
            "line": 289,
            "code": "      it('should get the drive name of the path', () => {\n        const manager = new Mock.ContentsManagerMock();\n        const defaultDrive = manager.driveName('foo');\n        expect(manager.driveName(`${defaultDrive}/bar`)).toBe(defaultDrive);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should rename the file",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".rename()"
            ],
            "updatePoint": {
                "line": 297,
                "column": 32
            },
            "line": 297,
            "code": "      it('should rename the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'rename') {\n            return;\n          }\n          expect(args.newValue!.path).toBe('foo');\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.rename(contents.path, 'foo');\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should delete the file",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".delete()"
            ],
            "updatePoint": {
                "line": 314,
                "column": 32
            },
            "line": 314,
            "code": "      it('should delete the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'delete') {\n            return;\n          }\n          expect(args.newValue).toBe(null);\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.delete(contents.path);\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save the file",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".save()"
            ],
            "updatePoint": {
                "line": 331,
                "column": 30
            },
            "line": 331,
            "code": "      it('should save the file', async () => {\n        const manager = new Mock.ContentsManagerMock();\n        let called = false;\n        manager.fileChanged.connect((_, args) => {\n          if (args.type !== 'save') {\n            return;\n          }\n          expect(args.newValue!.content).toBe('bar');\n          called = true;\n        });\n        const contents = await manager.newUntitled();\n        await manager.save(contents.path, { content: 'bar' });\n        expect(called).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "ContentsManagerMock",
                ".dispose()"
            ],
            "updatePoint": {
                "line": 348,
                "column": 27
            },
            "line": 348,
            "code": "      it('should be a no-op', () => {\n        const manager = new Mock.ContentsManagerMock();\n        expect(() => {\n          manager.dispose();\n        }).not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new session manager",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 359,
                "column": 45
            },
            "line": 359,
            "code": "      it('should create a new session manager', () => {\n        const manager = new Mock.SessionManagerMock();\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should start a new session",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".startNew()"
            ],
            "updatePoint": {
                "line": 366,
                "column": 36
            },
            "line": 366,
            "code": "      it('should start a new session', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should connect to a session",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".connectTo()"
            ],
            "updatePoint": {
                "line": 379,
                "column": 37
            },
            "line": 379,
            "code": "      it('should connect to a session', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.connectTo({\n          model: {\n            id: 'fizz',\n            path: 'foo',\n            type: 'bar',\n            name: 'baz',\n            kernel: { name: Mock.DEFAULT_NAME, id: 'fuzz' }\n          }\n        });\n        expect(session.kernel!.name).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should remove a running kernel",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".stopIfNeeded()"
            ],
            "updatePoint": {
                "line": 395,
                "column": 40
            },
            "line": 395,
            "code": "      it('should remove a running kernel', async () => {\n        const manager = new Mock.SessionManagerMock();\n        const session = await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(Array.from(manager.running()).length).toBe(1);\n        await manager.stopIfNeeded(session.path);\n        expect(Array.from(manager.running()).length).toBe(0);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".refreshRunning()"
            ],
            "updatePoint": {
                "line": 410,
                "column": 27
            },
            "line": 410,
            "code": "      it('should be a no-op', async () => {\n        const manager = new Mock.SessionManagerMock();\n        await expect(manager.refreshRunning()).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be an iterable of running sessions",
            "suites": [
                "mock",
                "SessionManagerMock",
                ".running()"
            ],
            "updatePoint": {
                "line": 417,
                "column": 51
            },
            "line": 417,
            "code": "      it('should be an iterable of running sessions', async () => {\n        const manager = new Mock.SessionManagerMock();\n        await manager.startNew({\n          path: 'foo',\n          name: 'foo',\n          type: 'bar',\n          kernel: { name: Mock.DEFAULT_NAME }\n        });\n        expect(Array.from(manager.running()).length).toBe(1);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new mock",
            "suites": [
                "mock",
                "KernelSpecManagerMock",
                ".constructor"
            ],
            "updatePoint": {
                "line": 432,
                "column": 34
            },
            "line": 432,
            "code": "      it('should create a new mock', () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the kernel specs",
            "suites": [
                "mock",
                "KernelSpecManagerMock",
                ".specs"
            ],
            "updatePoint": {
                "line": 439,
                "column": 36
            },
            "line": 439,
            "code": "      it('should be the kernel specs', () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        expect(manager.specs!.default).toBe(Mock.DEFAULT_NAME);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "KernelSpecManagerMock",
                ".refreshSpecs()"
            ],
            "updatePoint": {
                "line": 446,
                "column": 27
            },
            "line": 446,
            "code": "      it('should be a no-op', async () => {\n        const manager = new Mock.KernelSpecManagerMock();\n        await expect(manager.refreshSpecs()).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new mock",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".constructor()"
            ],
            "updatePoint": {
                "line": 455,
                "column": 34
            },
            "line": 455,
            "code": "      it('should create a new mock', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".ready"
            ],
            "updatePoint": {
                "line": 462,
                "column": 24
            },
            "line": 462,
            "code": "      it('should resolve', async () => {\n        const manager = new Mock.ServiceManagerMock();\n        await expect(manager.ready).resolves.not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a contents manager",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".contents"
            ],
            "updatePoint": {
                "line": 469,
                "column": 38
            },
            "line": 469,
            "code": "      it('should be a contents manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.contents.normalize).toBeTruthy();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a sessions manager",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".sessions"
            ],
            "updatePoint": {
                "line": 476,
                "column": 38
            },
            "line": 476,
            "code": "      it('should be a sessions manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.sessions.isReady).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a kernelspecs manager",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".kernelspecs"
            ],
            "updatePoint": {
                "line": 483,
                "column": 41
            },
            "line": 483,
            "code": "      it('should be a kernelspecs manager', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(manager.kernelspecs.isReady).toBe(true);\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a no-op",
            "suites": [
                "mock",
                "ServiceManagerMock",
                ".dispose()"
            ],
            "updatePoint": {
                "line": 490,
                "column": 27
            },
            "line": 490,
            "code": "      it('should be a no-op', () => {\n        const manager = new Mock.ServiceManagerMock();\n        expect(() => {\n          manager.dispose();\n        }).not.toThrow();\n      });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new mock",
            "suites": [
                "mock",
                "MockShellFuture"
            ],
            "updatePoint": {
                "line": 500,
                "column": 32
            },
            "line": 500,
            "code": "    it('should create a new mock', async () => {\n      const msg = KernelMessage.createMessage({\n        channel: 'shell',\n        msgType: 'execute_reply',\n        session: 'foo',\n        username: 'bar',\n        msgId: 'fizz',\n        content: {\n          user_expressions: {},\n          execution_count: 0,\n          status: 'ok'\n        }\n      });\n      const future = new Mock.MockShellFuture(msg);\n      const reply = await future.done;\n      expect(reply).toBe(msg);\n      future.dispose();\n    });",
            "file": "mock.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should make a request to the server",
            "suites": [
                "ServerConnection",
                ".makeRequest()"
            ],
            "updatePoint": {
                "line": 21,
                "column": 43
            },
            "line": 21,
            "code": "    it('should make a request to the server', async () => {\n      const settings = getRequestHandler(200, 'hello');\n      const response = await ServerConnection.makeRequest(\n        settings.baseUrl,\n        {},\n        settings\n      );\n      expect(response.statusText).toBe('OK');\n      const data = await response.json();\n      expect(data).toBe('hello');\n    });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should use default settings",
            "suites": [
                "ServerConnection",
                ".makeSettings()"
            ],
            "updatePoint": {
                "line": 35,
                "column": 35
            },
            "line": 35,
            "code": "    it('should use default settings', () => {\n      const settings = ServerConnection.makeSettings();\n      expect(settings.baseUrl).toBe(PageConfig.getBaseUrl());\n      expect(settings.wsUrl).toBe(PageConfig.getWsUrl());\n      expect(settings.token).toBe(PageConfig.getOption('token'));\n    });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should use baseUrl for wsUrl",
            "suites": [
                "ServerConnection",
                ".makeSettings()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 36
            },
            "line": 42,
            "code": "    it('should use baseUrl for wsUrl', () => {\n      const conf: Partial<ServerConnection.ISettings> = {\n        baseUrl: 'https://host/path'\n      };\n      const settings = ServerConnection.makeSettings(conf);\n      expect(settings.baseUrl).toBe(conf.baseUrl);\n      expect(settings.wsUrl).toBe('wss://host/path');\n    });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle overrides",
            "suites": [
                "ServerConnection",
                ".makeSettings()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 31
            },
            "line": 51,
            "code": "    it('should handle overrides', () => {\n      const defaults: Partial<ServerConnection.ISettings> = {\n        baseUrl: 'http://localhost/foo',\n        wsUrl: 'http://localhost/bar',\n        init: {\n          credentials: 'same-origin'\n        },\n        token: 'baz'\n      };\n      const settings = ServerConnection.makeSettings(defaults);\n      expect(settings.baseUrl).toBe(defaults.baseUrl);\n      expect(settings.wsUrl).toBe(defaults.wsUrl);\n      expect(settings.token).toBe(defaults.token);\n      expect(settings.init.credentials).toBe(defaults.init!.credentials);\n    });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a server error from a server response",
            "suites": [
                "ServerConnection",
                ".makeError()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 59
            },
            "line": 69,
            "code": "    it('should create a server error from a server response', async () => {\n      const settings = getRequestHandler(200, 'hi');\n      const init = { body: 'hi', method: 'POST' };\n      const response = await ServerConnection.makeRequest(\n        settings.baseUrl,\n        init,\n        settings\n      );\n      const err = new ServerConnection.ResponseError(response);\n      expect(err.message).toBe('Invalid response: 200 OK');\n    });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a error response from %j",
            "suites": [
                "ServerConnection",
                "ResponseError",
                "#create"
            ],
            "line": 84,
            "code": "      it.each([\n        {\n          status: 456,\n          statusText: 'Dummy error'\n        },\n        {\n          status: 456,\n          statusText: 'Dummy error',\n          body: { message: 'Nice error message' }\n        },\n        {\n          status: 456,\n          statusText: 'Dummy error',\n          body: { traceback: 'Nice traceback' }\n        },\n        {\n          status: 456,\n          statusText: 'Dummy error',\n          body: {\n            message: 'Nice error message',\n            traceback: 'Nice traceback'\n          }\n        }\n      ])('should create a error response from %j', async response => {\n        const error = await ServerConnection.ResponseError.create({\n          ...response,\n          json: () => Promise.resolve(response.body ?? {})\n        } as any);\n\n        expect(error.message).toEqual(\n          response.body?.message ?? 'Invalid response: 456 Dummy error'\n        );\n        expect(error.traceback).toEqual(response.body?.traceback ?? '');\n      });",
            "file": "serverconnection.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit when the session is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#disposed"
            ],
            "updatePoint": {
                "line": 60,
                "column": 50
            },
            "line": 60,
            "code": "      it('should emit when the session is disposed', async () => {\n        let called = false;\n        session = await startNew();\n        session.disposed.connect(() => {\n          called = true;\n        });\n        await session.shutdown();\n        session.dispose();\n        expect(called).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit when the kernel changes",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#kernelChanged"
            ],
            "updatePoint": {
                "line": 73,
                "column": 45
            },
            "line": 73,
            "code": "      it('should emit when the kernel changes', async () => {\n        let called: Session.ISessionConnection.IKernelChangedArgs | null = null;\n        const object = {};\n        while (defaultSession.kernel!.connectionStatus !== 'connected') {\n          await sleep(100);\n        }\n        await defaultSession.kernel!.requestKernelInfo();\n        defaultSession.kernelChanged.connect((s, args) => {\n          called = args;\n          Signal.disconnectReceiver(object);\n        }, object);\n        const original = defaultSession.kernel!;\n        // Create a new kernel with the same kernel name (same type)\n        await defaultSession.changeKernel({ name: original.name });\n        expect(original).not.toBe(defaultSession.kernel);\n        expect(called).toEqual({\n          name: 'kernel',\n          oldValue: original,\n          newValue: defaultSession.kernel\n        });\n        original.dispose();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit when the kernel status changes",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#statusChanged"
            ],
            "updatePoint": {
                "line": 98,
                "column": 52
            },
            "line": 98,
            "code": "      it('should emit when the kernel status changes', async () => {\n        let called = false;\n        defaultSession.statusChanged.connect((s, status) => {\n          if (status === 'busy') {\n            called = true;\n          }\n        });\n        while (defaultSession.kernel!.connectionStatus !== 'connected') {\n          await sleep(100);\n        }\n        await defaultSession.kernel!.requestKernelInfo();\n        expect(called).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an iopub message",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#iopubMessage"
            ],
            "updatePoint": {
                "line": 114,
                "column": 48
            },
            "line": 114,
            "code": "      it('should be emitted for an iopub message', async () => {\n        let called = false;\n        defaultSession.iopubMessage.connect((s, msg) => {\n          if (msg.header.msg_type === 'status') {\n            called = true;\n          }\n        });\n        await defaultSession.kernel!.requestExecute({ code: 'a=1' }, true).done;\n        expect(called).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted for an unhandled message",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#unhandledMessage"
            ],
            "updatePoint": {
                "line": 137,
                "column": 52
            },
            "line": 137,
            "code": "      it('should be emitted for an unhandled message', async () => {\n        const session = await tester.startSession();\n        const msgId = UUID.uuid4();\n        const emission = testEmission(session.unhandledMessage, {\n          find: (k, msg) => msg.header.msg_id === msgId\n        });\n        const msg = KernelMessage.createMessage({\n          msgType: 'kernel_info_request',\n          channel: 'shell',\n          session: tester.serverSessionId,\n          msgId,\n          content: {}\n        });\n        msg.parent_header = { session: session.kernel!.clientId } as any;\n        tester.send(msg);\n        await emission;\n        await expect(tester.shutdown()).resolves.not.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the session path changes",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#propertyChanged"
            ],
            "updatePoint": {
                "line": 158,
                "column": 57
            },
            "line": 158,
            "code": "      it('should be emitted when the session path changes', async () => {\n        const newPath = UUID.uuid4();\n        let called = false;\n        const object = {};\n        defaultSession.propertyChanged.connect((s, type) => {\n          expect(defaultSession.path).toBe(newPath);\n          expect(type).toBe('path');\n          called = true;\n          Signal.disconnectReceiver(object);\n        }, object);\n        await defaultSession.setPath(newPath);\n        expect(called).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#id"
            ],
            "updatePoint": {
                "line": 174,
                "column": 28
            },
            "line": 174,
            "code": "      it('should be a string', () => {\n        expect(typeof defaultSession.id).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#path"
            ],
            "updatePoint": {
                "line": 180,
                "column": 28
            },
            "line": 180,
            "code": "      it('should be a string', () => {\n        expect(typeof defaultSession.path).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#name"
            ],
            "updatePoint": {
                "line": 186,
                "column": 28
            },
            "line": 186,
            "code": "      it('should be a string', () => {\n        expect(typeof defaultSession.name).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be a string",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#type"
            ],
            "updatePoint": {
                "line": 192,
                "column": 28
            },
            "line": 192,
            "code": "      it('should be a string', () => {\n        expect(typeof defaultSession.name).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be an IModel",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#model"
            ],
            "updatePoint": {
                "line": 198,
                "column": 29
            },
            "line": 198,
            "code": "      it('should be an IModel', () => {\n        const model = defaultSession.model;\n        expect(typeof model.id).toBe('string');\n        expect(typeof model.path).toBe('string');\n        expect(typeof model.kernel!.name).toBe('string');\n        expect(typeof model.kernel!.id).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be an IKernel object",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#kernel"
            ],
            "updatePoint": {
                "line": 208,
                "column": 37
            },
            "line": 208,
            "code": "      it('should be an IKernel object', () => {\n        expect(typeof defaultSession.kernel!.id).toBe('string');\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the serverSettings",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 214,
                "column": 38
            },
            "line": 214,
            "code": "      it('should be the serverSettings', () => {\n        expect(defaultSession.serverSettings.baseUrl).toBe(\n          PageConfig.getBaseUrl()\n        );\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be true after we dispose of the session",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 222,
                "column": 56
            },
            "line": 222,
            "code": "      it('should be true after we dispose of the session', async () => {\n        const session = await startNew();\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 229,
                "column": 47
            },
            "line": 229,
            "code": "      it('should be safe to call multiple times', async () => {\n        const session = await startNew();\n        expect(session.isDisposed).toBe(false);\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources held by the session",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 240,
                "column": 61
            },
            "line": 240,
            "code": "      it('should dispose of the resources held by the session', async () => {\n        const session = await startNew();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call twice",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 246,
                "column": 38
            },
            "line": 246,
            "code": "      it('should be safe to call twice', async () => {\n        const session = await startNew();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call if the kernel is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 58
            },
            "line": 254,
            "code": "      it('should be safe to call if the kernel is disposed', async () => {\n        const session = await startNew();\n        session.kernel!.dispose();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the path of the session",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setPath()"
            ],
            "updatePoint": {
                "line": 263,
                "column": 44
            },
            "line": 263,
            "code": "      it('should set the path of the session', async () => {\n        const newPath = UUID.uuid4();\n        await defaultSession.setPath(newPath);\n        expect(defaultSession.path).toBe(newPath);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setPath()"
            ],
            "updatePoint": {
                "line": 269,
                "column": 50
            },
            "line": 269,
            "code": "      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for error response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setPath()"
            ],
            "updatePoint": {
                "line": 274,
                "column": 47
            },
            "line": 274,
            "code": "      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper model",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setPath()"
            ],
            "updatePoint": {
                "line": 279,
                "column": 40
            },
            "line": 279,
            "code": "      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setPath(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the session is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setPath()"
            ],
            "updatePoint": {
                "line": 284,
                "column": 48
            },
            "line": 284,
            "code": "      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the type of the session",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setType()"
            ],
            "updatePoint": {
                "line": 295,
                "column": 44
            },
            "line": 295,
            "code": "      it('should set the type of the session', async () => {\n        const session = await startNew();\n        const type = UUID.uuid4();\n        await session.setType(type);\n        expect(session.type).toBe(type);\n        await session.shutdown();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setType()"
            ],
            "updatePoint": {
                "line": 303,
                "column": 50
            },
            "line": 303,
            "code": "      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for error response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setType()"
            ],
            "updatePoint": {
                "line": 308,
                "column": 47
            },
            "line": 308,
            "code": "      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper model",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setType()"
            ],
            "updatePoint": {
                "line": 313,
                "column": 40
            },
            "line": 313,
            "code": "      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setType(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the session is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setType()"
            ],
            "updatePoint": {
                "line": 318,
                "column": 48
            },
            "line": 318,
            "code": "      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should set the name of the session",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setName()"
            ],
            "updatePoint": {
                "line": 329,
                "column": 44
            },
            "line": 329,
            "code": "      it('should set the name of the session', async () => {\n        const name = UUID.uuid4();\n        await defaultSession.setName(name);\n        expect(defaultSession.name).toBe(name);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setName()"
            ],
            "updatePoint": {
                "line": 335,
                "column": 50
            },
            "line": 335,
            "code": "      it('should fail for improper response status', async () => {\n        handleRequest(defaultSession, 201, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for error response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setName()"
            ],
            "updatePoint": {
                "line": 340,
                "column": 47
            },
            "line": 340,
            "code": "      it('should fail for error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for improper model",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setName()"
            ],
            "updatePoint": {
                "line": 345,
                "column": 40
            },
            "line": 345,
            "code": "      it('should fail for improper model', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.setName(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the session is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#setName()"
            ],
            "updatePoint": {
                "line": 350,
                "column": 48
            },
            "line": 350,
            "code": "      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        const promise = session.setPath(UUID.uuid4());\n        await expect(promise).rejects.toThrow(/Session is disposed/);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new kernel with the new name",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 361,
                "column": 54
            },
            "line": 361,
            "code": "      it('should create a new kernel with the new name', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        await session.changeKernel({ name: previous.name });\n        expect(session.kernel!.name).toBe(previous.name);\n        expect(session.kernel!.id).not.toBe(previous.id);\n        expect(session.kernel).not.toBe(previous);\n        previous.dispose();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept the id of the new kernel",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 372,
                "column": 48
            },
            "line": 372,
            "code": "      it('should accept the id of the new kernel', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        const kernel = await KernelAPI.startNew();\n        await session.changeKernel({ id: kernel.id });\n        expect(session.kernel!.id).toBe(kernel.id);\n        expect(session.kernel).not.toBe(previous);\n        expect(session.kernel).not.toBe(kernel);\n        previous.dispose();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the session path if it has changed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#changeKernel()"
            ],
            "updatePoint": {
                "line": 384,
                "column": 58
            },
            "line": 384,
            "code": "      it('should update the session path if it has changed', async () => {\n        session = await startNew();\n        const previous = session.kernel!;\n        await previous.info;\n        const path = UUID.uuid4() + '.ipynb';\n        const model = { ...session.model, path };\n        handleRequest(session, 200, model);\n        await session.changeKernel({ name: previous.name });\n        expect(session.kernel!.name).toBe(previous.name);\n        expect(session.path).toBe(model.path);\n        previous.dispose();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down properly",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 399,
                "column": 35
            },
            "line": 399,
            "code": "      it('should shut down properly', async () => {\n        session = await startNew();\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a disposed signal",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 404,
                "column": 39
            },
            "line": 404,
            "code": "      it('should emit a disposed signal', async () => {\n        let called = false;\n        session = await startNew();\n        session.disposed.connect(() => {\n          called = true;\n        });\n        await session.shutdown();\n        expect(called).toBe(true);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an incorrect response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 414,
                "column": 54
            },
            "line": 414,
            "code": "      it('should fail for an incorrect response status', async () => {\n        handleRequest(defaultSession, 200, {});\n        await expect(defaultSession.shutdown()).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a 404 status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 419,
                "column": 36
            },
            "line": 419,
            "code": "      it('should handle a 404 status', async () => {\n        session = await startNew();\n        handleRequest(session, 404, {});\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a specific error status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 425,
                "column": 47
            },
            "line": 425,
            "code": "      it('should handle a specific error status', async () => {\n        handleRequest(defaultSession, 410, {});\n        const promise = defaultSession.shutdown();\n        await expect(promise).rejects.toThrow(\n          'The kernel was deleted but the session was not'\n        );\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for an error response status",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 433,
                "column": 50
            },
            "line": 433,
            "code": "      it('should fail for an error response status', async () => {\n        handleRequest(defaultSession, 500, {});\n        await expect(defaultSession.shutdown()).rejects.toThrow();\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail if the session is disposed",
            "suites": [
                "session",
                "Session.DefaultSession",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 438,
                "column": 48
            },
            "line": 438,
            "code": "      it('should fail if the session is disposed', async () => {\n        const session = sessionManager.connectTo({\n          model: defaultSession.model\n        });\n        session.dispose();\n        await expect(session.shutdown()).rejects.toThrow(/Session is disposed/);\n      });",
            "file": "session/isession.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new session manager",
            "suites": [
                "session/manager",
                "SessionManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 62,
                "column": 45
            },
            "line": 62,
            "code": "      it('should create a new session manager', () => {\n        expect(manager instanceof SessionManager).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "session/manager",
                "SessionManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 68,
                "column": 40
            },
            "line": 68,
            "code": "      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const token = serverSettings.token;\n        manager = new SessionManager({ kernelManager, serverSettings });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is ready",
            "suites": [
                "session/manager",
                "SessionManager",
                "#isReady"
            ],
            "updatePoint": {
                "line": 79,
                "column": 50
            },
            "line": 79,
            "code": "      it('should test whether the manager is ready', async () => {\n        manager.dispose();\n        manager = new SessionManager({ kernelManager });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve when the manager is ready",
            "suites": [
                "session/manager",
                "SessionManager",
                "#ready"
            ],
            "updatePoint": {
                "line": 89,
                "column": 50
            },
            "line": 89,
            "code": "      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the running sessions",
            "suites": [
                "session/manager",
                "SessionManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 41
            },
            "line": 95,
            "code": "      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        const running = Array.from(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the running sessions changed",
            "suites": [
                "session/manager",
                "SessionManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 103,
                "column": 61
            },
            "line": 103,
            "code": "      it('should be emitted when the running sessions changed', async () => {\n        const promise = testEmission(manager.runningChanged, {\n          test: (sender, args) => {\n            expect(sender).toBe(manager);\n            expect(Array.from(args).length).toBeGreaterThan(0);\n          }\n        });\n        await startNew(manager);\n        await promise;\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a session is shut down",
            "suites": [
                "session/manager",
                "SessionManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 114,
                "column": 55
            },
            "line": 114,
            "code": "      it('should be emitted when a session is shut down', async () => {\n        let called = false;\n        const s = await startNew(manager);\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await s.shutdown();\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a session is renamed",
            "suites": [
                "session/manager",
                "SessionManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 125,
                "column": 53
            },
            "line": 125,
            "code": "      it('should be emitted when a session is renamed', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await session.setPath(UUID.uuid4());\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a session changes kernels",
            "suites": [
                "session/manager",
                "SessionManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 135,
                "column": 58
            },
            "line": 135,
            "code": "      it('should be emitted when a session changes kernels', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await session.changeKernel({ name: session.kernel!.name });\n        await manager.refreshRunning();\n        expect(called).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should refresh the list of session ids",
            "suites": [
                "session/manager",
                "SessionManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 48
            },
            "line": 149,
            "code": "      it('should refresh the list of session ids', async () => {\n        await manager.refreshRunning();\n        const running = Array.from(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should start a session",
            "suites": [
                "session/manager",
                "SessionManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 157,
                "column": 32
            },
            "line": 157,
            "code": "      it('should start a session', async () => {\n        const session = await startNew(manager);\n        expect(session.id).toBeTruthy();\n        return session.shutdown();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "session/manager",
                "SessionManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 163,
                "column": 45
            },
            "line": 163,
            "code": "      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await startNew(manager);\n        expect(called).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should find an existing session by path",
            "suites": [
                "session/manager",
                "SessionManager",
                "#findByPath()"
            ],
            "updatePoint": {
                "line": 174,
                "column": 49
            },
            "line": 174,
            "code": "      it('should find an existing session by path', async () => {\n        const newModel = await manager.findByPath(session.path);\n        expect(newModel!.id).toBe(session.id);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should find an existing session by id",
            "suites": [
                "session/manager",
                "SessionManager",
                "#findById()"
            ],
            "updatePoint": {
                "line": 181,
                "column": 47
            },
            "line": 181,
            "code": "      it('should find an existing session by id', async () => {\n        const newModel = await manager.findById(session.id);\n        expect(newModel!.id).toBe(session.id);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should connect to a running session",
            "suites": [
                "session/manager",
                "SessionManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 188,
                "column": 45
            },
            "line": 188,
            "code": "      it('should connect to a running session', () => {\n        const newSession = manager.connectTo({ model: session.model });\n        expect(newSession.id).toBe(session.id);\n        expect(newSession.kernel!.id).toBe(session.kernel!.id);\n        expect(newSession).not.toBe(session);\n        expect(newSession.kernel).not.toBe(session.kernel);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down a session by id",
            "suites": [
                "session/manager",
                "SessionManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 198,
                "column": 42
            },
            "line": 198,
            "code": "      it('should shut down a session by id', async () => {\n        const temp = await startNew(manager);\n        await manager.shutdown(temp.id);\n        expect(temp.isDisposed).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "session/manager",
                "SessionManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 204,
                "column": 45
            },
            "line": 204,
            "code": "      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        const session = await startNew(manager);\n        manager.runningChanged.connect((sender, sessions) => {\n          // Make sure the sessions list does not have our shutdown session in it.\n          if (!sessions.find(s => s.id === session.id)) {\n            called = true;\n          }\n        });\n\n        await manager.shutdown(session.id);\n        expect(called).toBe(true);\n        expect(session.isDisposed).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of all session instances asynchronously",
            "suites": [
                "session/manager",
                "SessionManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 219,
                "column": 64
            },
            "line": 219,
            "code": "      it('should dispose of all session instances asynchronously', async () => {\n        const session0 = await startNew(manager);\n        const session1 = manager.connectTo({ model: session0.model });\n        const emission = testEmission(session1.disposed);\n        await session0.shutdown();\n        await expect(emission).resolves.not.toThrow();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take the options as an argument",
            "suites": [
                "session/manager",
                "NoopManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 248,
                "column": 48
            },
            "line": 248,
            "code": "      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new SessionManager.NoopManager({\n          kernelManager,\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof SessionManager.NoopManager).toBe(true);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "session/manager",
                "NoopManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 260,
                "column": 40
            },
            "line": 260,
            "code": "      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new SessionManager.NoopManager({\n          kernelManager,\n          serverSettings,\n          standby\n        });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the running sessions",
            "suites": [
                "session/manager",
                "NoopManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 276,
                "column": 41
            },
            "line": 276,
            "code": "      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running kernels",
            "suites": [
                "session/manager",
                "NoopManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 283,
                "column": 43
            },
            "line": 283,
            "code": "      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "session/manager",
                "NoopManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 290,
                "column": 31
            },
            "line": 290,
            "code": "      it('should throw an error', () => {\n        return expect(startNew(manager)).rejects.toThrow();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "session/manager",
                "NoopManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 296,
                "column": 31
            },
            "line": 296,
            "code": "      it('should throw an error', () => {\n        const model = {\n          id: UUID.uuid4(),\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'MYTEST',\n          kernel: { name: 'foo', id: UUID.uuid4() }\n        };\n        return expect(() => {\n          manager.connectTo({ model });\n        }).toThrow();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "session/manager",
                "NoopManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 311,
                "column": 31
            },
            "line": 311,
            "code": "      it('should throw an error', () => {\n        return expect(manager.shutdown(UUID.uuid4())).rejects.toThrow();\n      });",
            "file": "session/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should yield a list of valid session models",
            "suites": [
                "session",
                "Session.listRunning()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 51
            },
            "line": 32,
            "code": "    it('should yield a list of valid session models', async () => {\n      expect(Array.from(await SessionAPI.listRunning()).length).toBe(0);\n      const session = await SessionAPI.startSession({\n        name: UUID.uuid4(),\n        path: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(Array.from(await SessionAPI.listRunning())).toEqual([session]);\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for an invalid model",
            "suites": [
                "session",
                "Session.listRunning()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 50
            },
            "line": 42,
            "code": "    it('should throw an error for an invalid model', async () => {\n      const data = { id: '1234', path: 'test' };\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error for another invalid model",
            "suites": [
                "session",
                "Session.listRunning()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 55
            },
            "line": 48,
            "code": "    it('should throw an error for another invalid model', async () => {\n      const data = [{ id: '1234', kernel: { id: '', name: '' }, path: '' }];\n      const serverSettings = getRequestHandler(200, data);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for wrong response status",
            "suites": [
                "session",
                "Session.listRunning()"
            ],
            "updatePoint": {
                "line": 54,
                "column": 45
            },
            "line": 54,
            "code": "    it('should fail for wrong response status', async () => {\n      const serverSettings = getRequestHandler(201, [createSessionModel()]);\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for error response status",
            "suites": [
                "session",
                "Session.listRunning()"
            ],
            "updatePoint": {
                "line": 59,
                "column": 45
            },
            "line": 59,
            "code": "    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      await expect(SessionAPI.listRunning(serverSettings)).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should start a session",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 66,
                "column": 30
            },
            "line": 66,
            "code": "    it('should start a session', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      expect(session.id).toBeTruthy();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept ajax options",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 75,
                "column": 34
            },
            "line": 75,
            "code": "    it('should accept ajax options', async () => {\n      const serverSettings = makeSettings();\n      session = await SessionAPI.startSession(\n        {\n          path: UUID.uuid4(),\n          name: UUID.uuid4(),\n          type: 'test'\n        },\n        serverSettings\n      );\n      expect(session.id).toBeTruthy();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for wrong response status",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 88,
                "column": 45
            },
            "line": 88,
            "code": "    it('should fail for wrong response status', async () => {\n      const sessionModel = createSessionModel();\n      const serverSettings = getRequestHandler(200, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for error response status",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 96,
                "column": 45
            },
            "line": 96,
            "code": "    it('should fail for error response status', async () => {\n      const serverSettings = getRequestHandler(500, {});\n      const sessionModel = createSessionModel();\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail for wrong response model",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 104,
                "column": 44
            },
            "line": 104,
            "code": "    it('should fail for wrong response model', async () => {\n      const sessionModel = createSessionModel();\n      (sessionModel as any).path = 1;\n      const serverSettings = getRequestHandler(201, sessionModel);\n      await expect(\n        SessionAPI.startSession(sessionModel as any, serverSettings)\n      ).rejects.toThrow(/Property 'path' is not of type 'string'/);\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a deprecated response model",
            "suites": [
                "session",
                "SessionAPI.startNew"
            ],
            "updatePoint": {
                "line": 113,
                "column": 49
            },
            "line": 113,
            "code": "    it('should handle a deprecated response model', async () => {\n      const sessionModel = createSessionModel();\n      const data = {\n        id: sessionModel.id,\n        kernel: sessionModel.kernel,\n        notebook: { path: sessionModel.path }\n      };\n      const serverSettings = getRequestHandler(201, data);\n      const model = await SessionAPI.startSession(\n        sessionModel as any,\n        serverSettings\n      );\n      expect(model).toHaveProperty('id');\n      expect(model.path).toBeTruthy();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down a kernel by id",
            "suites": [
                "session",
                "Session.shutdown()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 39
            },
            "line": 131,
            "code": "    it('should shut down a kernel by id', async () => {\n      session = await SessionAPI.startSession({\n        path: UUID.uuid4(),\n        name: UUID.uuid4(),\n        type: 'test'\n      });\n      await expect(\n        SessionAPI.shutdownSession(session.id)\n      ).resolves.not.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a 404 status",
            "suites": [
                "session",
                "Session.shutdown()"
            ],
            "updatePoint": {
                "line": 142,
                "column": 34
            },
            "line": 142,
            "code": "    it('should handle a 404 status', async () => {\n      await expect(\n        SessionAPI.shutdownSession(UUID.uuid4())\n      ).resolves.not.toThrow();\n    });",
            "file": "session/session.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should pass a valid model",
            "suites": [
                "session/validate",
                "#validateModel()"
            ],
            "updatePoint": {
                "line": 12,
                "column": 33
            },
            "line": 12,
            "code": "    it('should pass a valid model', () => {\n      const model: Session.IModel = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        path: 'bar',\n        name: '',\n        type: ''\n      };\n      expect(() => {\n        validateModel(model);\n      }).not.toThrow();\n    });",
            "file": "session/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fail on missing data",
            "suites": [
                "session/validate",
                "#validateModel()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 35
            },
            "line": 25,
            "code": "    it('should fail on missing data', () => {\n      const model: any = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        path: 'bar',\n        name: ''\n      };\n      expect(() => validateModel(model)).toThrow();\n    });",
            "file": "session/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update a deprecated model",
            "suites": [
                "session/validate",
                "#updateLegacySessionModel()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 40
            },
            "line": 37,
            "code": "    it('should update a deprecated model', () => {\n      const model = {\n        id: 'foo',\n        kernel: { name: 'foo', id: '123' },\n        notebook: {\n          path: 'bar'\n        }\n      };\n      updateLegacySessionModel(model);\n      expect(() => {\n        validateModel(model);\n      }).not.toThrow();\n    });",
            "file": "session/validate.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "setting",
                "SettingManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 28,
                "column": 34
            },
            "line": 28,
            "code": "      it('should accept no options', () => {\n        const manager = new SettingManager();\n        expect(manager).toBeInstanceOf(SettingManager);\n      });",
            "file": "setting/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "setting",
                "SettingManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 31
            },
            "line": 33,
            "code": "      it('should accept options', () => {\n        const manager = new SettingManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(SettingManager);\n      });",
            "file": "setting/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the server settings",
            "suites": [
                "setting",
                "SettingManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 42,
                "column": 39
            },
            "line": 42,
            "code": "      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new SettingManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });",
            "file": "setting/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fetch settings for an extension",
            "suites": [
                "setting",
                "SettingManager",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 48
            },
            "line": 51,
            "code": "      it('should fetch settings for an extension', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n\n        expect((await manager.fetch(id)).id).toBe(id);\n      });",
            "file": "setting/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save a setting",
            "suites": [
                "setting",
                "SettingManager",
                "#save()"
            ],
            "updatePoint": {
                "line": 59,
                "column": 31
            },
            "line": 59,
            "code": "      it('should save a setting', async () => {\n        const id = '@jupyterlab/apputils-extension:themes';\n        const theme = 'Foo Theme';\n        const raw = `{\"theme\": \"${theme}\"}`;\n\n        await manager.save(id, raw);\n        expect(JSON.parse((await manager.fetch(id)).raw).theme).toBe(theme);\n      });",
            "file": "setting/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "terminal",
                "TerminalManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 34
            },
            "line": 41,
            "code": "      it('should accept no options', async () => {\n        const manager = new TerminalManager({ standby: 'never' });\n        await manager.ready;\n        expect(manager).toBeInstanceOf(TerminalManager);\n        manager.dispose();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "terminal",
                "TerminalManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 48,
                "column": 31
            },
            "line": 48,
            "code": "      it('should accept options', async () => {\n        const manager = new TerminalManager({\n          serverSettings: ServerConnection.makeSettings(),\n          standby: 'never'\n        });\n        await manager.ready;\n        expect(manager).toBeInstanceOf(TerminalManager);\n        manager.dispose();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "terminal",
                "TerminalManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 60,
                "column": 40
            },
            "line": 60,
            "code": "      it('should get the server settings', async () => {\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        const manager = new TerminalManager({ serverSettings, standby });\n        await manager.ready;\n        expect(manager.serverSettings.token).toBe(token);\n        manager.dispose();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the manager is ready",
            "suites": [
                "terminal",
                "TerminalManager",
                "#isReady"
            ],
            "updatePoint": {
                "line": 72,
                "column": 50
            },
            "line": 72,
            "code": "      it('should test whether the manager is ready', async () => {\n        const manager = new TerminalManager({ standby: 'never' });\n        expect(manager.isReady).toBe(false);\n        await manager.ready;\n        expect(manager.isReady).toBe(true);\n        manager.dispose();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve when the manager is ready",
            "suites": [
                "terminal",
                "TerminalManager",
                "#ready"
            ],
            "updatePoint": {
                "line": 82,
                "column": 50
            },
            "line": 82,
            "code": "      it('should resolve when the manager is ready', async () => {\n        await expect(manager.ready).resolves.not.toThrow();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether terminal sessions are available",
            "suites": [
                "terminal",
                "TerminalManager",
                "#isAvailable()"
            ],
            "updatePoint": {
                "line": 88,
                "column": 61
            },
            "line": 88,
            "code": "      it('should test whether terminal sessions are available', () => {\n        expect(Terminal.isAvailable()).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should give an iterator over the list of running models",
            "suites": [
                "terminal",
                "TerminalManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 94,
                "column": 65
            },
            "line": 94,
            "code": "      it('should give an iterator over the list of running models', async () => {\n        await TerminalAPI.startNew();\n        await manager.refreshRunning();\n        const running = Array.from(manager.running());\n        expect(running.length).toBeGreaterThan(0);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should startNew a new terminal session",
            "suites": [
                "terminal",
                "TerminalManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 48
            },
            "line": 103,
            "code": "      it('should startNew a new terminal session', async () => {\n        const session = await manager.startNew();\n        expect(session.name).toBeTruthy();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "terminal",
                "TerminalManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 108,
                "column": 45
            },
            "line": 108,
            "code": "      it('should emit a runningChanged signal', async () => {\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.startNew();\n        expect(called).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should connect to an existing session",
            "suites": [
                "terminal",
                "TerminalManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 119,
                "column": 47
            },
            "line": 119,
            "code": "      it('should connect to an existing session', async () => {\n        const session = await manager.startNew();\n        const session2 = manager.connectTo({ model: session.model });\n        expect(session).not.toBe(session2);\n        expect(session2.name).toBe(session.name);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down a session by id",
            "suites": [
                "terminal",
                "TerminalManager",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 42
            },
            "line": 128,
            "code": "      it('should shut down a session by id', async () => {\n        const temp = await manager.startNew();\n        await manager.shutdown(temp.name);\n        expect(temp.isDisposed).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should emit a runningChanged signal",
            "suites": [
                "terminal",
                "TerminalManager",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 134,
                "column": 45
            },
            "line": 134,
            "code": "      it('should emit a runningChanged signal', async () => {\n        const session = await manager.startNew();\n        let called = false;\n        manager.runningChanged.connect(() => {\n          called = true;\n        });\n        await manager.shutdown(session.name);\n        expect(called).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when the running terminals changed",
            "suites": [
                "terminal",
                "TerminalManager",
                "#runningChanged"
            ],
            "updatePoint": {
                "line": 146,
                "column": 62
            },
            "line": 146,
            "code": "      it('should be emitted when the running terminals changed', async () => {\n        const emission = testEmission(manager.runningChanged, {\n          test: (sender, args) => {\n            expect(sender).toBe(manager);\n            expect(Array.from(args).length).toBeGreaterThan(0);\n          }\n        });\n        await manager.startNew();\n        await emission;\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running session models",
            "suites": [
                "terminal",
                "TerminalManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 159,
                "column": 50
            },
            "line": 159,
            "code": "      it('should update the running session models', async () => {\n        const before = Array.from(manager.running()).length;\n        const model = await TerminalAPI.startNew();\n        await manager.refreshRunning();\n        const running = Array.from(manager.running());\n        expect(running.length).toBe(before + 1);\n        let found = false;\n        running.map(m => {\n          if (m.name === model.name) {\n            found = true;\n          }\n        });\n        expect(found).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should take the options as an argument",
            "suites": [
                "terminal",
                "NoopManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 48
            },
            "line": 189,
            "code": "      it('should take the options as an argument', async () => {\n        manager.dispose();\n        manager = new TerminalManager.NoopManager({\n          standby: 'never'\n        });\n        await manager.parentReady;\n        expect(manager instanceof TerminalManager.NoopManager).toBe(true);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the server settings",
            "suites": [
                "terminal",
                "NoopManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 200,
                "column": 40
            },
            "line": 200,
            "code": "      it('should get the server settings', async () => {\n        manager.dispose();\n        const serverSettings = ServerConnection.makeSettings();\n        const standby = 'never';\n        const token = serverSettings.token;\n        manager = new TerminalManager.NoopManager({ serverSettings, standby });\n        await manager.parentReady;\n        expect(manager.serverSettings.token).toBe(token);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should get the running sessions",
            "suites": [
                "terminal",
                "NoopManager",
                "#running()"
            ],
            "updatePoint": {
                "line": 212,
                "column": 41
            },
            "line": 212,
            "code": "      it('should get the running sessions', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should update the running kernels",
            "suites": [
                "terminal",
                "NoopManager",
                "#refreshRunning()"
            ],
            "updatePoint": {
                "line": 219,
                "column": 43
            },
            "line": 219,
            "code": "      it('should update the running kernels', async () => {\n        await manager.refreshRunning();\n        expect(Array.from(manager.running()).length).toEqual(0);\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "terminal",
                "NoopManager",
                "#startNew()"
            ],
            "updatePoint": {
                "line": 226,
                "column": 31
            },
            "line": 226,
            "code": "      it('should throw an error', () => {\n        return expect(manager.startNew()).rejects.toThrow();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "terminal",
                "NoopManager",
                "#connectTo()"
            ],
            "updatePoint": {
                "line": 232,
                "column": 31
            },
            "line": 232,
            "code": "      it('should throw an error', () => {\n        return expect(() => {\n          manager.connectTo({ model: { name: 'abcd' } });\n        }).toThrow();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should throw an error",
            "suites": [
                "terminal",
                "NoopManager",
                "shutdown()"
            ],
            "updatePoint": {
                "line": 240,
                "column": 31
            },
            "line": 240,
            "code": "      it('should throw an error', () => {\n        return expect(manager.shutdown('1234')).rejects.toThrow();\n      });",
            "file": "terminal/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether terminal sessions are available",
            "suites": [
                "terminal",
                "Terminal",
                ".isAvailable()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 61
            },
            "line": 37,
            "code": "      it('should test whether terminal sessions are available', () => {\n        expect(Terminal.isAvailable()).toBe(true);\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be emitted when a message is received",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#messageReceived"
            ],
            "updatePoint": {
                "line": 45,
                "column": 54
            },
            "line": 45,
            "code": "      it('should be emitted when a message is received', async () => {\n        session = await manager.startNew();\n        const emission = testEmission(session.messageReceived, {\n          test: (sender, msg) => {\n            return msg.type === 'stdout';\n          }\n        });\n        session.send({ type: 'stdin', content: ['cd\\r'] });\n        await expect(emission).resolves.not.toThrow();\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the name of the session",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#name"
            ],
            "updatePoint": {
                "line": 58,
                "column": 43
            },
            "line": 58,
            "code": "      it('should be the name of the session', () => {\n        expect(defaultSession.name).toBeTruthy();\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the server settings of the server",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 64,
                "column": 53
            },
            "line": 64,
            "code": "      it('should be the server settings of the server', () => {\n        expect(defaultSession.serverSettings.baseUrl).toBe(\n          PageConfig.getBaseUrl()\n        );\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should test whether the object is disposed",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 72,
                "column": 52
            },
            "line": 72,
            "code": "      it('should test whether the object is disposed', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        expect(session.isDisposed).toBe(false);\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should dispose of the resources used by the session",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 83,
                "column": 61
            },
            "line": 83,
            "code": "      it('should dispose of the resources used by the session', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 47
            },
            "line": 91,
            "code": "      it('should be safe to call more than once', async () => {\n        session = await manager.startNew();\n        const name = session.name;\n        session.dispose();\n        session.dispose();\n        expect(session.isDisposed).toBe(true);\n        await manager.shutdown(name);\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should send a message to the socket",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#send()"
            ],
            "updatePoint": {
                "line": 102,
                "column": 45
            },
            "line": 102,
            "code": "      it('should send a message to the socket', () => {\n        expect(() => {\n          session.send({ type: 'stdin', content: [1, 2] });\n        }).not.toThrow();\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should reconnect to the socket",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#reconnect()"
            ],
            "updatePoint": {
                "line": 110,
                "column": 40
            },
            "line": 110,
            "code": "      it('should reconnect to the socket', async () => {\n        const session = await manager.startNew();\n        const promise = session.reconnect();\n        expect(session.connectionStatus).toBe('connecting');\n        await promise;\n        expect(session.connectionStatus).toBe('connected');\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should shut down the terminal session",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 120,
                "column": 47
            },
            "line": 120,
            "code": "      it('should shut down the terminal session', async () => {\n        session = await manager.startNew();\n        await expect(session.shutdown()).resolves.not.toThrow();\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should handle a 404 status",
            "suites": [
                "terminal",
                ".ITerminalConnection",
                "#shutdown()"
            ],
            "updatePoint": {
                "line": 125,
                "column": 36
            },
            "line": 125,
            "code": "      it('should handle a 404 status', async () => {\n        handleRequest(defaultSession, 404, {});\n        await expect(defaultSession.shutdown()).resolves.not.toThrow();\n      });",
            "file": "terminal/terminal.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "user",
                "UserManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 28,
                "column": 34
            },
            "line": 28,
            "code": "      it('should accept no options', () => {\n        const manager = new UserManager();\n        expect(manager).toBeInstanceOf(UserManager);\n      });",
            "file": "user/user.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "user",
                "UserManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 31
            },
            "line": 33,
            "code": "      it('should accept options', () => {\n        const manager = new UserManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(UserManager);\n      });",
            "file": "user/user.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "Should have identity",
            "suites": [
                "user",
                "UserManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 28
            },
            "line": 41,
            "code": "    it('Should have identity', () => {\n      expect(manager.identity).not.toBeNull();\n    });",
            "file": "user/user.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve to the given value",
            "suites": [
                "test/utils",
                "testEmission"
            ],
            "updatePoint": {
                "line": 10,
                "column": 41
            },
            "line": 10,
            "code": "    it('should resolve to the given value', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await emission).toBe('done');\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should find the given emission",
            "suites": [
                "test/utils",
                "testEmission"
            ],
            "updatePoint": {
                "line": 20,
                "column": 38
            },
            "line": 20,
            "code": "    it('should find the given emission', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      expect(await emission).toBe('done');\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should reject if the test throws an error",
            "suites": [
                "test/utils",
                "testEmission"
            ],
            "updatePoint": {
                "line": 33,
                "column": 49
            },
            "line": 33,
            "code": "    it('should reject if the test throws an error', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        test: (a, b) => {\n          throw new Error('my error');\n        },\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      await expectFailure(emission, 'my error');\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve if the test succeeds",
            "suites": [
                "test/utils",
                "testEmission"
            ],
            "updatePoint": {
                "line": 49,
                "column": 43
            },
            "line": 49,
            "code": "    it('should resolve if the test succeeds', async () => {\n      const owner = {};\n      const x = new Signal<typeof owner, number>(owner);\n      const emission = testEmission(x, {\n        find: (a, b) => b === 1,\n        test: (a, b) => {\n          expect(b).toBe(1);\n        },\n        value: 'done'\n      });\n      x.emit(0);\n      expect(await isFulfilled(emission)).toBe(false);\n      x.emit(1);\n      expect(await emission).toBe('done');\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve to true only after a promise is fulfilled",
            "suites": [
                "test/utils",
                "isFulfilled"
            ],
            "updatePoint": {
                "line": 67,
                "column": 64
            },
            "line": 67,
            "code": "    it('should resolve to true only after a promise is fulfilled', async () => {\n      const p = new PromiseDelegate<number>();\n      expect(await isFulfilled(p.promise)).toBe(false);\n      p.resolve(10);\n      expect(await isFulfilled(p.promise)).toBe(true);\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should resolve to true even if the promise is rejected",
            "suites": [
                "test/utils",
                "isFulfilled"
            ],
            "updatePoint": {
                "line": 74,
                "column": 62
            },
            "line": 74,
            "code": "    it('should resolve to true even if the promise is rejected', async () => {\n      const p = new PromiseDelegate<number>();\n      expect(await isFulfilled(p.promise)).toBe(false);\n      p.reject(new Error('my error'));\n      expect(await isFulfilled(p.promise)).toBe(true);\n    });",
            "file": "utils.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept no options",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 28,
                "column": 34
            },
            "line": 28,
            "code": "      it('should accept no options', () => {\n        const manager = new WorkspaceManager();\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should accept options",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 31
            },
            "line": 33,
            "code": "      it('should accept options', () => {\n        const manager = new WorkspaceManager({\n          serverSettings: ServerConnection.makeSettings()\n        });\n        expect(manager).toBeInstanceOf(WorkspaceManager);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should be the server settings",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#serverSettings"
            ],
            "updatePoint": {
                "line": 42,
                "column": 39
            },
            "line": 42,
            "code": "      it('should be the server settings', () => {\n        const baseUrl = 'http://localhost/foo';\n        const serverSettings = ServerConnection.makeSettings({ baseUrl });\n        const manager = new WorkspaceManager({ serverSettings });\n        expect(manager.serverSettings.baseUrl).toBe(baseUrl);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fetch a saved workspace",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 40
            },
            "line": 51,
            "code": "      it('should fetch a saved workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should fetch a workspace list supporting arbitrary IDs",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#list()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 64
            },
            "line": 61,
            "code": "      it('should fetch a workspace list supporting arbitrary IDs', async () => {\n        const ids = ['foo', 'bar', 'baz', 'f/o/o', 'b/a/r', 'b/a/z'];\n        const promises = ids.map(id =>\n          manager.save(id, { data: {}, metadata: { id } })\n        );\n\n        await Promise.all(promises);\n        expect((await manager.list()).ids.sort()).toEqual(ids.sort());\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should remove a workspace",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#remove()"
            ],
            "updatePoint": {
                "line": 73,
                "column": 35
            },
            "line": 73,
            "code": "      it('should remove a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should save a workspace",
            "suites": [
                "workspace",
                "WorkspaceManager",
                "#save()"
            ],
            "updatePoint": {
                "line": 83,
                "column": 33
            },
            "line": 83,
            "code": "      it('should save a workspace', async () => {\n        const id = 'foo';\n\n        await manager.save(id, { data: {}, metadata: { id } });\n        expect((await manager.fetch(id)).metadata.id).toBe(id);\n        await manager.remove(id);\n      });",
            "file": "workspace/manager.spec.ts",
            "skipped": false,
            "dir": "packages/services/test"
        },
        {
            "name": "should create a new schema validator",
            "suites": [
                "@jupyterlab/settingregistry",
                "DefaultSchemaValidator",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 41,
                "column": 46
            },
            "line": 41,
            "code": "      it('should create a new schema validator', () => {\n        const validator = new DefaultSchemaValidator();\n\n        expect(validator).toBeInstanceOf(DefaultSchemaValidator);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should validate data against a schema",
            "suites": [
                "@jupyterlab/settingregistry",
                "DefaultSchemaValidator",
                "#validateData()"
            ],
            "updatePoint": {
                "line": 49,
                "column": 47
            },
            "line": 49,
            "code": "      it('should validate data against a schema', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string' }\n          },\n          type: 'object'\n        };\n        const composite = {};\n        const user = {};\n        const raw = '{ \"bar\": \"baz\" }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).toBe(null);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should return errors if the data fails to validate",
            "suites": [
                "@jupyterlab/settingregistry",
                "DefaultSchemaValidator",
                "#validateData()"
            ],
            "updatePoint": {
                "line": 69,
                "column": 60
            },
            "line": 69,
            "code": "      it('should return errors if the data fails to validate', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string' }\n          },\n          type: 'object'\n        };\n        const composite = {};\n        const user = {};\n        const raw = '{ \"baz\": \"qux\" }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).not.toBe(null);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should populate the composite data",
            "suites": [
                "@jupyterlab/settingregistry",
                "DefaultSchemaValidator",
                "#validateData()"
            ],
            "updatePoint": {
                "line": 89,
                "column": 44
            },
            "line": 89,
            "code": "      it('should populate the composite data', () => {\n        const id = 'foo';\n        const validator = new DefaultSchemaValidator();\n        const schema: ISettingRegistry.ISchema = {\n          additionalProperties: false,\n          properties: {\n            bar: { type: 'string', default: 'baz' }\n          },\n          type: 'object'\n        };\n        const composite = {} as JSONObject;\n        const user = {} as JSONObject;\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data: { composite, user }, raw, schema, version };\n        const errors = validator.validateData(plugin);\n\n        expect(errors).toBe(null);\n        expect(plugin.data.user.bar).toBeUndefined();\n        expect(plugin.data.composite.bar).toBe(schema.properties!.bar.default);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should create a new setting registry",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 128,
                "column": 46
            },
            "line": 128,
            "code": "      it('should create a new setting registry', () => {\n        expect(registry).toBeInstanceOf(SettingRegistry);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should emit when a plugin changes",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#pluginChanged"
            ],
            "updatePoint": {
                "line": 134,
                "column": 43
            },
            "line": 134,
            "code": "      it('should emit when a plugin changes', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        let called = false;\n        registry.pluginChanged.connect((sender: any, plugin: string) => {\n          expect(id).toBe(plugin);\n          called = true;\n        });\n        await registry.load(id);\n        await registry.set(id, key, value);\n        expect(called).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should return a list of registered plugins in registry",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#plugins"
            ],
            "updatePoint": {
                "line": 152,
                "column": 64
            },
            "line": 152,
            "code": "      it('should return a list of registered plugins in registry', async () => {\n        const one = 'foo';\n        const two = 'bar';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[one] = { type: 'object' };\n        connector.schemas[two] = { type: 'object' };\n        await registry.load(one);\n        expect(Object.keys(registry.plugins)).toHaveLength(1);\n        await registry.load(two);\n        expect(Object.keys(registry.plugins)).toHaveLength(2);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should get a setting item from a loaded plugin",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 167,
                "column": 56
            },
            "line": 167,
            "code": "      it('should get a setting item from a loaded plugin', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        (await registry.load(id)) as Settings;\n        const saved = await registry.get(id, key);\n        expect(saved.user).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should get a setting item from a plugin that is not loaded",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 179,
                "column": 68
            },
            "line": 179,
            "code": "      it('should get a setting item from a plugin that is not loaded', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should use schema default if user data not available",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 190,
                "column": 62
            },
            "line": 190,
            "code": "      it('should use schema default if user data not available', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(schema.properties![key].default);\n        expect(saved.composite).not.toBe(saved.user);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should let user value override schema default",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 209,
                "column": 55
            },
            "line": 209,
            "code": "      it('should let user value override schema default', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBe(value);\n        expect(saved.user).toBe(value);\n        expect(saved.composite).not.toBe(schema.properties![key].default);\n        expect(saved.user).not.toBe(schema.properties![key].default);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should reject if a plugin does not exist",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 231,
                "column": 50
            },
            "line": 231,
            "code": "      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.get('foo', 'bar');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should resolve `undefined` if a key does not exist",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#get()"
            ],
            "updatePoint": {
                "line": 241,
                "column": 60
            },
            "line": 241,
            "code": "      it('should resolve `undefined` if a key does not exist', async () => {\n        const id = 'foo';\n        const key = 'bar';\n\n        connector.schemas[id] = { type: 'object' };\n\n        const saved = await registry.get(id, key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should resolve a registered plugin's settings",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#load()"
            ],
            "updatePoint": {
                "line": 254,
                "column": 55
            },
            "line": 254,
            "code": "      it(`should resolve a registered plugin's settings`, async () => {\n        const id = 'foo';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object' };\n        const settings = (await registry.load(id)) as Settings;\n        expect(settings.id).toBe(id);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should reject if a plugin transformation times out",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#load()"
            ],
            "updatePoint": {
                "line": 263,
                "column": 60
            },
            "line": 263,
            "code": "      it(`should reject if a plugin transformation times out`, async () => {\n        const id = 'foo';\n        let failed = false;\n\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n\n        try {\n          await registry.load(id);\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should reject if a plugin does not exist",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#load()"
            ],
            "updatePoint": {
                "line": 280,
                "column": 50
            },
            "line": 280,
            "code": "      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.load('foo');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should load a registered plugin's settings",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#reload()"
            ],
            "updatePoint": {
                "line": 292,
                "column": 52
            },
            "line": 292,
            "code": "      it(`should load a registered plugin's settings`, async () => {\n        const id = 'foo';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object' };\n        const settings = await registry.reload(id);\n        expect(settings.id).toBe(id);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should replace a registered plugin's settings",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#reload()"
            ],
            "updatePoint": {
                "line": 301,
                "column": 55
            },
            "line": 301,
            "code": "      it(`should replace a registered plugin's settings`, async () => {\n        const id = 'foo';\n        const first = 'Foo';\n        const second = 'Bar';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = { type: 'object', title: first };\n        let settings = await registry.reload(id);\n        expect(settings.schema.title).toBe(first);\n        await Promise.resolve(undefined);\n        connector.schemas[id].title = second;\n        settings = await registry.reload(id);\n        expect(settings.schema.title).toBe(second);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should reject if a plugin does not exist",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#reload()"
            ],
            "updatePoint": {
                "line": 316,
                "column": 50
            },
            "line": 316,
            "code": "      it('should reject if a plugin does not exist', async () => {\n        let failed = false;\n        try {\n          await registry.reload('foo');\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should transform a plugin during the fetch phase",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#transform()"
            ],
            "updatePoint": {
                "line": 328,
                "column": 58
            },
            "line": 328,
            "code": "      it(`should transform a plugin during the fetch phase`, async () => {\n        const id = 'foo';\n        const version = 'transform-test';\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          fetch: plugin => {\n            plugin.version = version;\n            return plugin;\n          }\n        });\n        expect((await registry.load(id)).version).toBe(version);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should transform a plugin during the compose phase",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#transform()"
            ],
            "updatePoint": {
                "line": 346,
                "column": 60
            },
            "line": 346,
            "code": "      it(`should transform a plugin during the compose phase`, async () => {\n        const id = 'foo';\n        const composite = { a: 1 };\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          compose: plugin => {\n            plugin.data = { user: plugin.data.user, composite };\n            return plugin;\n          }\n        });\n        expect((await registry.load(id)).composite).toEqual(composite);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should disallow a transform that changes the plugin ID",
            "suites": [
                "@jupyterlab/settingregistry",
                "SettingRegistry",
                "#transform()"
            ],
            "updatePoint": {
                "line": 364,
                "column": 64
            },
            "line": 364,
            "code": "      it(`should disallow a transform that changes the plugin ID`, async () => {\n        const id = 'foo';\n        let failed = false;\n\n        expect(Object.keys(registry.plugins)).toHaveLength(0);\n        connector.schemas[id] = {\n          'jupyter.lab.transform': true,\n          type: 'object'\n        };\n        registry.transform(id, {\n          compose: plugin => {\n            plugin.id = 'bar';\n            return plugin;\n          }\n        });\n        try {\n          await registry.load(id);\n        } catch (e) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should merge menu tree",
            "suites": [
                "@jupyterlab/settingregistry",
                "reconcileMenus"
            ],
            "updatePoint": {
                "line": 390,
                "column": 30
            },
            "line": 390,
            "code": "    it('should merge menu tree', () => {\n      const a: ISettingRegistry.IMenu[] = [\n        {\n          id: '1',\n          items: [{ command: 'a' }]\n        },\n        {\n          id: '2',\n          items: [{ command: 'b' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [{ command: 'sub-1' }]\n              }\n            }\n          ]\n        }\n      ];\n      const b: ISettingRegistry.IMenu[] = [\n        {\n          id: '2',\n          items: [\n            { command: 'b', disabled: true },\n            { command: 'b', args: { input: 'hello' } },\n            { command: 'b', args: { input: 'world' } },\n            { command: 'c' }\n          ]\n        },\n        {\n          id: '3',\n          items: [{ command: 'd' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [\n                  { command: 'sub-1', disabled: true },\n                  { command: 'sub-2' }\n                ]\n              }\n            }\n          ]\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileMenus(a, b);\n      expect(merged).toHaveLength(4);\n      expect(merged[0].id).toEqual('1');\n      expect(merged[0].items).toHaveLength(1);\n      expect(merged[1].id).toEqual('2');\n      expect(merged[1].items).toHaveLength(4);\n      expect(merged[1].items![0].command).toEqual('b');\n      expect(merged[1].items![0].args).toBeUndefined();\n      expect(merged[1].items![0].disabled).toEqual(true);\n      expect(merged[1].items![1].command).toEqual('b');\n      expect(merged[1].items![1].args?.input).toEqual('hello');\n      expect(merged[1].items![2].command).toEqual('b');\n      expect(merged[1].items![2].args?.input).toEqual('world');\n      expect(merged[2].id).toEqual('4');\n      expect(merged[2].items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items).toHaveLength(2);\n      expect(merged[2].items![0].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged[2].items![0].submenu?.items![0].disabled).toEqual(true);\n      expect(merged[3].id).toEqual('3');\n      expect(merged[3].items).toHaveLength(1);\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should merge menu tree without adding new items",
            "suites": [
                "@jupyterlab/settingregistry",
                "reconcileMenus"
            ],
            "updatePoint": {
                "line": 466,
                "column": 55
            },
            "line": 466,
            "code": "    it('should merge menu tree without adding new items', () => {\n      const a: ISettingRegistry.IMenu[] = [\n        {\n          id: '1',\n          items: [{ command: 'a' }]\n        },\n        {\n          id: '2',\n          items: [{ command: 'b' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [{ command: 'sub-1' }]\n              }\n            }\n          ]\n        }\n      ];\n      const b: ISettingRegistry.IMenu[] = [\n        {\n          id: '2',\n          items: [\n            { command: 'b', disabled: true },\n            { command: 'b', args: { input: 'hello' } },\n            { command: 'b', args: { input: 'world' } },\n            { command: 'c' }\n          ]\n        },\n        {\n          id: '3',\n          items: [{ command: 'd' }]\n        },\n        {\n          id: '4',\n          items: [\n            {\n              type: 'submenu',\n              submenu: {\n                id: 'sub',\n                items: [\n                  { command: 'sub-1', disabled: true },\n                  { command: 'sub-2' }\n                ]\n              }\n            }\n          ],\n          disabled: true\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileMenus(a, b, false, false);\n      expect(merged).toHaveLength(3);\n      expect(merged![0].id).toEqual('1');\n      expect(merged![0].items).toHaveLength(1);\n      expect(merged![1].id).toEqual('2');\n      expect(merged![1].items).toHaveLength(1);\n      expect(merged[1].items![0].command).toEqual('b');\n      expect(merged[1].items![0].args).toBeUndefined();\n      expect(merged[1].items![0].disabled).toEqual(true);\n      expect(merged[2].id).toEqual('4');\n      expect(merged[2].items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items).toHaveLength(1);\n      expect(merged[2].items![0].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged[2].items![0].submenu?.items![0].disabled).toEqual(true);\n      expect(merged[2].disabled).toEqual(true);\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should merge items list",
            "suites": [
                "@jupyterlab/settingregistry",
                "reconcileItems"
            ],
            "updatePoint": {
                "line": 540,
                "column": 31
            },
            "line": 540,
            "code": "    it('should merge items list', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { command: 'b', selector: '.b' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1' }]\n          },\n          selector: '.sub'\n        }\n      ];\n      const b: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'b', selector: '.b', disabled: true },\n        { command: 'b', selector: '.bb' },\n        { command: 'b', selector: '.b1', args: { input: 'hello' } },\n        { command: 'b', selector: '.b2', args: { input: 'world' } },\n        { command: 'c', selector: '.c' },\n        { command: 'd', selector: '.d' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileItems(a, b);\n      expect(merged).toHaveLength(8);\n      expect(merged![1].command).toEqual('b');\n      expect(merged![1].selector).toEqual('.b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].submenu?.items).toHaveLength(2);\n      expect(merged![3].command).toEqual('b');\n      expect(merged![3].selector).toEqual('.bb');\n      expect(merged![4].command).toEqual('b');\n      expect(merged![4].args?.input).toEqual('hello');\n      expect(merged![5].command).toEqual('b');\n      expect(merged![5].args?.input).toEqual('world');\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should merge items list without adding new ones",
            "suites": [
                "@jupyterlab/settingregistry",
                "reconcileItems"
            ],
            "updatePoint": {
                "line": 584,
                "column": 55
            },
            "line": 584,
            "code": "    it('should merge items list without adding new ones', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { command: 'b', selector: '.b' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1' }]\n          },\n          selector: '.sub'\n        }\n      ];\n      const b: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'b', selector: '.b', disabled: true },\n        { command: 'b', selector: '.b1', args: { input: 'hello' } },\n        { command: 'b', selector: '.b2', args: { input: 'world' } },\n        { command: 'c', selector: '.c' },\n        { command: 'd', selector: '.d' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const merged = SettingRegistry.reconcileItems(a, b, false, false);\n      expect(merged).toHaveLength(3);\n      expect(merged![1].command).toEqual('b');\n      expect(merged![1].selector).toEqual('.b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].submenu?.items).toHaveLength(1);\n      expect(merged![2].submenu?.items![0].command).toEqual('sub-1');\n      expect(merged![2].submenu?.items![0].disabled).toEqual(true);\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should merge toolbar items list",
            "suites": [
                "@jupyterlab/settingregistry",
                "reconcileToolbarItems"
            ],
            "updatePoint": {
                "line": 625,
                "column": 39
            },
            "line": 625,
            "code": "    it('should merge toolbar items list', () => {\n      const a: ISettingRegistry.IToolbarItem[] = [\n        { name: 'a' },\n        { name: 'b', command: 'command-b' }\n      ];\n      const b: ISettingRegistry.IToolbarItem[] = [\n        { name: 'b', disabled: true },\n        { name: 'c', type: 'spacer' },\n        { name: 'd', command: 'command-d' }\n      ];\n\n      const merged = SettingRegistry.reconcileToolbarItems(a, b);\n      expect(merged).toHaveLength(4);\n      expect(merged![0].name).toEqual('a');\n      expect(merged![1].name).toEqual('b');\n      expect(merged![1].disabled).toEqual(true);\n      expect(merged![2].name).toEqual('c');\n      expect(merged![2].type).toEqual('spacer');\n      expect(merged![3].name).toEqual('d');\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should remove disabled menu item",
            "suites": [
                "@jupyterlab/settingregistry",
                "filterDisabledItems"
            ],
            "updatePoint": {
                "line": 648,
                "column": 40
            },
            "line": 648,
            "code": "    it('should remove disabled menu item', () => {\n      const a: ISettingRegistry.IContextMenuItem[] = [\n        { command: 'a', selector: '.a' },\n        { type: 'separator', selector: '.a' },\n        { command: 'b', disabled: true, selector: '.a' },\n        {\n          type: 'submenu',\n          submenu: {\n            id: 'sub',\n            items: [{ command: 'sub-1', disabled: true }, { command: 'sub-2' }]\n          },\n          selector: '.s'\n        }\n      ];\n\n      const filtered = SettingRegistry.filterDisabledItems(a);\n      expect(filtered).toHaveLength(3);\n      expect(filtered[0]?.command).toEqual('a');\n      expect(filtered[1]?.type).toEqual('separator');\n      expect(filtered[2]?.type).toEqual('submenu');\n      expect(filtered[2]?.submenu?.items).toHaveLength(1);\n      expect(filtered[2]?.submenu?.items![0].command).toEqual('sub-2');\n    });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should create a new settings object for a plugin",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 692,
                "column": 58
            },
            "line": 692,
            "code": "      it('should create a new settings object for a plugin', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings).toBeInstanceOf(Settings);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should emit when a plugin changes",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#changed"
            ],
            "updatePoint": {
                "line": 706,
                "column": 43
            },
            "line": 706,
            "code": "      it('should emit when a plugin changes', async () => {\n        const id = 'alpha';\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        const promise = signalToPromise(settings.changed);\n        await settings.set('foo', 'bar');\n        await expect(promise).resolves.toContain(settings);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should contain the merged user and default data",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#composite"
            ],
            "updatePoint": {
                "line": 719,
                "column": 57
            },
            "line": 719,
            "code": "      it('should contain the merged user and default data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.composite[key]).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should privilege user data",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#composite"
            ],
            "updatePoint": {
                "line": 738,
                "column": 36
            },
            "line": 738,
            "code": "      it('should privilege user data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        await settings.set(key, value);\n        expect(settings.composite[key]).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should expose the plugin ID",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#id"
            ],
            "updatePoint": {
                "line": 760,
                "column": 37
            },
            "line": 760,
            "code": "      it('should expose the plugin ID', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.id).toBe(id);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should test whether the settings object is disposed",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 774,
                "column": 61
            },
            "line": 774,
            "code": "      it('should test whether the settings object is disposed', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.isDisposed).toBe(false);\n        settings.dispose();\n        expect(settings.isDisposed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should expose the plugin schema",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#schema"
            ],
            "updatePoint": {
                "line": 790,
                "column": 41
            },
            "line": 790,
            "code": "      it('should expose the plugin schema', async () => {\n        const id = 'alpha';\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.schema).toEqual(schema);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should privilege user data",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#user"
            ],
            "updatePoint": {
                "line": 801,
                "column": 36
            },
            "line": 801,
            "code": "      it('should privilege user data', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        connector.schemas[id] = schema;\n        settings = (await registry.load(id)) as Settings;\n        await settings.set(key, value);\n        expect(settings.user[key]).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should expose the setting registry",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#registry"
            ],
            "updatePoint": {
                "line": 823,
                "column": 44
            },
            "line": 823,
            "code": "      it('should expose the setting registry', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.registry).toBe(registry);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should dispose the settings object",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 837,
                "column": 44
            },
            "line": 837,
            "code": "      it('should dispose the settings object', () => {\n        const id = 'alpha';\n        const data = { composite: {}, user: {} };\n        const schema: ISettingRegistry.ISchema = { type: 'object' };\n        const raw = '{ }';\n        const version = 'test';\n        const plugin = { id, data, raw, schema, version };\n\n        settings = new Settings({ plugin, registry });\n        expect(settings.isDisposed).toBe(false);\n        settings.dispose();\n        expect(settings.isDisposed).toBe(true);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should return a fully extrapolated schema default",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#default()"
            ],
            "updatePoint": {
                "line": 853,
                "column": 59
            },
            "line": 853,
            "code": "      it('should return a fully extrapolated schema default', async () => {\n        const id = 'omicron';\n        const defaults = {\n          foo: 'one',\n          bar: 100,\n          baz: {\n            qux: 'two',\n            quux: 'three',\n            quuz: {\n              corge: { grault: 200 }\n            }\n          }\n        };\n\n        connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            foo: { type: 'string', default: defaults.foo },\n            bar: { type: 'number', default: defaults.bar },\n            baz: {\n              type: 'object',\n              default: {},\n              properties: {\n                qux: { type: 'string', default: defaults.baz.qux },\n                quux: { type: 'string', default: defaults.baz.quux },\n                quuz: {\n                  type: 'object',\n                  default: {},\n                  properties: {\n                    corge: {\n                      type: 'object',\n                      default: {},\n                      properties: {\n                        grault: {\n                          type: 'number',\n                          default: defaults.baz.quuz.corge.grault\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            'nonexistent-default': { type: 'string' }\n          }\n        };\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.default('nonexistent-key')).toBeUndefined();\n        expect(settings.default('foo')).toBe(defaults.foo);\n        expect(settings.default('bar')).toBe(defaults.bar);\n        expect(settings.default('baz')).toEqual(defaults.baz);\n        expect(settings.default('nonexistent-default')).toBeUndefined();\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should use definition at top of the schema",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#default()"
            ],
            "updatePoint": {
                "line": 907,
                "column": 52
            },
            "line": 907,
            "code": "      it('should use definition at top of the schema', async () => {\n        const id = 'omicron';\n        const defaults = {\n          foo: [\n            { bar: 2, baz: 'zip' },\n            { bar: 0, baz: 'zip' }\n          ]\n        };\n\n        connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            foo: {\n              type: 'array',\n              items: { $ref: '#/definitions/fooItem' },\n              default: [{ bar: 2 }, {}]\n            }\n          },\n          definitions: {\n            fooItem: {\n              type: 'object',\n              properties: {\n                bar: {\n                  type: 'number',\n                  default: 0\n                },\n                baz: {\n                  type: 'string',\n                  default: 'zip'\n                }\n              }\n            }\n          }\n        };\n        settings = (await registry.load(id)) as Settings;\n        expect(settings.default()).toStrictEqual(defaults);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should get a setting item",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#get()"
            ],
            "updatePoint": {
                "line": 947,
                "column": 35
            },
            "line": 947,
            "code": "      it('should get a setting item', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.user).toBe(value);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should use schema default if user data not available",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#get()"
            ],
            "updatePoint": {
                "line": 959,
                "column": 62
            },
            "line": 959,
            "code": "      it('should use schema default if user data not available', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: value\n            }\n          }\n        });\n\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n\n        expect(saved.composite).toBe(schema.properties![key].default);\n        expect(saved.composite).not.toBe(saved.user);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should let user value override schema default",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#get()"
            ],
            "updatePoint": {
                "line": 980,
                "column": 55
            },
            "line": 980,
            "code": "      it('should let user value override schema default', async () => {\n        const id = 'alpha';\n        const key = 'beta';\n        const value = 'gamma';\n        const schema: ISettingRegistry.ISchema = (connector.schemas[id] = {\n          type: 'object',\n          properties: {\n            [key]: {\n              type: typeof value as ISettingRegistry.Primitive,\n              default: 'delta'\n            }\n          }\n        });\n\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.composite).toBe(value);\n        expect(saved.user).toBe(value);\n        expect(saved.composite).not.toBe(schema.properties![key].default);\n        expect(saved.user).not.toBe(schema.properties![key].default);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should be `undefined` if a key does not exist",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#get()"
            ],
            "updatePoint": {
                "line": 1003,
                "column": 55
            },
            "line": 1003,
            "code": "      it('should be `undefined` if a key does not exist', async () => {\n        const id = 'foo';\n        const key = 'bar';\n\n        connector.schemas[id] = { type: 'object' };\n\n        settings = (await registry.load(id)) as Settings;\n        const saved = settings.get(key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should remove a setting item",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#remove()"
            ],
            "updatePoint": {
                "line": 1017,
                "column": 38
            },
            "line": 1017,
            "code": "      it('should remove a setting item', async () => {\n        const id = 'foo';\n        const key = 'bar';\n        const value = 'baz';\n\n        connector.schemas[id] = { type: 'object' };\n        await connector.save(id, JSON.stringify({ [key]: value }));\n        settings = (await registry.load(id)) as Settings;\n        let saved = settings.get(key);\n        expect(saved.user).toBe(value);\n        await settings.remove(key);\n        saved = settings.get(key);\n        expect(saved.composite).toBeUndefined();\n        expect(saved.user).toBeUndefined();\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should save user setting data",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#save()"
            ],
            "updatePoint": {
                "line": 1035,
                "column": 39
            },
            "line": 1035,
            "code": "      it('should save user setting data', async () => {\n        const id = 'foo';\n        const one = 'one';\n        const two = 'two';\n\n        connector.schemas[id] = { type: 'object' };\n        settings = (await registry.load(id)) as Settings;\n        await settings.save(JSON.stringify({ one, two }));\n        let saved = settings.get('one');\n        expect(saved.composite).toBe(one);\n        expect(saved.user).toBe(one);\n\n        saved = settings.get('two');\n\n        expect(saved.composite).toBe(two);\n        expect(saved.user).toBe(two);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should set a user setting item",
            "suites": [
                "@jupyterlab/settingregistry",
                "Settings",
                "#set()"
            ],
            "updatePoint": {
                "line": 1055,
                "column": 40
            },
            "line": 1055,
            "code": "      it('should set a user setting item', async () => {\n        const id = 'foo';\n        const one = 'one';\n\n        connector.schemas[id] = { type: 'object' };\n        settings = (await registry.load(id)) as Settings;\n        await settings.set('one', one);\n        const saved = settings.get('one');\n        expect(saved.composite).toBe(one);\n        expect(saved.user).toBe(one);\n      });",
            "file": "settingregistry.spec.ts",
            "skipped": false,
            "dir": "packages/settingregistry/test"
        },
        {
            "name": "should create a RestorablePool",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 40
            },
            "line": 50,
            "code": "      it('should create a RestorablePool', () => {\n        expect(pool).toBeInstanceOf(RestorablePool);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should emit when an instance has been added",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#added"
            ],
            "updatePoint": {
                "line": 56,
                "column": 53
            },
            "line": 56,
            "code": "      it('should emit when an instance has been added', async () => {\n        const instance = new ObservableDisposable();\n        const promise = signalToPromise(pool.added);\n        await pool.add(instance);\n        const [sender, args] = await promise;\n        expect(sender).toBe(pool);\n        expect(args).toBe(instance);\n        instance.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should default to null",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#current"
            ],
            "updatePoint": {
                "line": 67,
                "column": 32
            },
            "line": 67,
            "code": "      it('should default to null', () => {\n        expect(pool.current).toBeNull();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should be settable by client code",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#current"
            ],
            "updatePoint": {
                "line": 71,
                "column": 43
            },
            "line": 71,
            "code": "      it('should be settable by client code', async () => {\n        const instance = new ObservableDisposable();\n        void pool.add(instance);\n        expect(pool.current).toBe(null);\n        pool.current = instance;\n        expect(pool.current).toBe(instance);\n        instance.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should be a no-op if set to an untracked instance",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#current"
            ],
            "updatePoint": {
                "line": 80,
                "column": 59
            },
            "line": 80,
            "code": "      it('should be a no-op if set to an untracked instance', async () => {\n        const instance = new ObservableDisposable();\n        expect(pool.current).toBe(null);\n        pool.current = instance;\n        expect(pool.current).toBe(null);\n        instance.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should emit when the current object has been updated",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#currentChanged"
            ],
            "updatePoint": {
                "line": 100,
                "column": 62
            },
            "line": 100,
            "code": "      it('should emit when the current object has been updated', async () => {\n        const promise = signalToPromise(pool.currentChanged);\n        void pool.add(instance);\n        pool.current = instance;\n        await expect(promise).resolves.not.toThrow();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should test whether the pool is disposed",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#isDisposed"
            ],
            "updatePoint": {
                "line": 109,
                "column": 50
            },
            "line": 109,
            "code": "      it('should test whether the pool is disposed', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should add an instance to the pool",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#add()"
            ],
            "updatePoint": {
                "line": 117,
                "column": 44
            },
            "line": 117,
            "code": "      it('should add an instance to the pool', async () => {\n        const instance = new ObservableDisposable();\n        expect(pool.has(instance)).toBe(false);\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should reject an instance that already exists",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#add()"
            ],
            "updatePoint": {
                "line": 124,
                "column": 55
            },
            "line": 124,
            "code": "      it('should reject an instance that already exists', async () => {\n        const instance = new ObservableDisposable();\n        let failed = false;\n        expect(pool.has(instance)).toBe(false);\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n        try {\n          await pool.add(instance);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should reject an instance that is disposed",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#add()"
            ],
            "updatePoint": {
                "line": 138,
                "column": 52
            },
            "line": 138,
            "code": "      it('should reject an instance that is disposed', async () => {\n        const instance = new ObservableDisposable();\n        let failed = false;\n        expect(pool.has(instance)).toBe(false);\n        instance.dispose();\n        try {\n          await pool.add(instance);\n        } catch (error) {\n          failed = true;\n        }\n        expect(failed).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should remove an added instance if it is disposed",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#add()"
            ],
            "updatePoint": {
                "line": 151,
                "column": 59
            },
            "line": 151,
            "code": "      it('should remove an added instance if it is disposed', async () => {\n        const instance = new ObservableDisposable();\n        await pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n        instance.dispose();\n        expect(pool.has(instance)).toBe(false);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should dispose of the resources used by the pool",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 161,
                "column": 58
            },
            "line": 161,
            "code": "      it('should dispose of the resources used by the pool', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should be safe to call multiple times",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 167,
                "column": 47
            },
            "line": 167,
            "code": "      it('should be safe to call multiple times', () => {\n        expect(pool.isDisposed).toBe(false);\n        pool.dispose();\n        pool.dispose();\n        expect(pool.isDisposed).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should find a tracked item that matches a filter function",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#find()"
            ],
            "updatePoint": {
                "line": 176,
                "column": 67
            },
            "line": 176,
            "code": "      it('should find a tracked item that matches a filter function', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.find(obj => obj.id === 'B')).toBe(instanceB);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should return a void if no item is found",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#find()"
            ],
            "updatePoint": {
                "line": 189,
                "column": 50
            },
            "line": 189,
            "code": "      it('should return a void if no item is found', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.find(widget => widget.id === 'D')).toBeFalsy();\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should filter according to a predicate function",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#filter()"
            ],
            "updatePoint": {
                "line": 204,
                "column": 57
            },
            "line": 204,
            "code": "      it('should filter according to a predicate function', () => {\n        const instanceA = new ObservableDisposable('include-A');\n        const instanceB = new ObservableDisposable('include-B');\n        const instanceC = new ObservableDisposable('exclude-C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        const list = pool.filter(obj => obj.id.indexOf('include') !== -1);\n        expect(list.length).toBe(2);\n        expect(list[0]).toBe(instanceA);\n        expect(list[1]).toBe(instanceB);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should return an empty array if no item is found",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#filter()"
            ],
            "updatePoint": {
                "line": 220,
                "column": 58
            },
            "line": 220,
            "code": "      it('should return an empty array if no item is found', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        expect(pool.filter(widget => widget.id === 'D').length).toBe(0);\n        instanceA.dispose();\n        instanceB.dispose();\n        instanceC.dispose();\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should iterate through all the tracked items",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#forEach()"
            ],
            "updatePoint": {
                "line": 235,
                "column": 54
            },
            "line": 235,
            "code": "      it('should iterate through all the tracked items', () => {\n        const instanceA = new ObservableDisposable('A');\n        const instanceB = new ObservableDisposable('B');\n        const instanceC = new ObservableDisposable('C');\n        let visited = '';\n        void pool.add(instanceA);\n        void pool.add(instanceB);\n        void pool.add(instanceC);\n        pool.forEach(obj => {\n          visited += obj.id;\n        });\n        expect(visited).toBe('ABC');\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should return `true` if an item exists in the pool",
            "suites": [
                "@jupyterlab/coreutils",
                "RestorablePool",
                "#has()"
            ],
            "updatePoint": {
                "line": 251,
                "column": 60
            },
            "line": 251,
            "code": "      it('should return `true` if an item exists in the pool', () => {\n        const instance = new ObservableDisposable();\n        expect(pool.has(instance)).toBe(false);\n        void pool.add(instance);\n        expect(pool.has(instance)).toBe(true);\n      });",
            "file": "restorablepool.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should create a state database",
            "suites": [
                "StateDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 38
            },
            "line": 9,
            "code": "    it('should create a state database', () => {\n      const db = new StateDB();\n      expect(db).toBeInstanceOf(StateDB);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should allow an overwrite data transformation",
            "suites": [
                "StateDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 14,
                "column": 53
            },
            "line": 14,
            "code": "    it('should allow an overwrite data transformation', async () => {\n      const connector = new StateDB.Connector();\n      const key = 'foo';\n      const correct = 'bar';\n      const incorrect = 'baz';\n\n      expect(await connector.fetch(key)).toBeUndefined();\n      await connector.save(key, `{ \"v\": \"${incorrect}\"}`);\n      expect(JSON.parse(await connector.fetch(key)).v).toBe(incorrect);\n\n      const transform = new PromiseDelegate<StateDB.DataTransform>();\n      const db = new StateDB({ connector, transform: transform.promise });\n      const transformation: StateDB.DataTransform = {\n        type: 'overwrite',\n        contents: { [key]: correct }\n      };\n\n      transform.resolve(transformation);\n      await transform.promise;\n      expect(await db.fetch(key)).toBe(correct);\n      expect(JSON.parse(await connector.fetch(key)).v).toBe(correct);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should allow a merge data transformation",
            "suites": [
                "StateDB",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 37,
                "column": 48
            },
            "line": 37,
            "code": "    it('should allow a merge data transformation', async () => {\n      const connector = new StateDB.Connector();\n      const k1 = 'foo';\n      const v1 = 'bar';\n      const k2 = 'baz';\n      const v2 = 'qux';\n\n      expect(await connector.fetch(k1)).toBeUndefined();\n      expect(await connector.fetch(k2)).toBeUndefined();\n      await connector.save(k1, `{ \"v\": \"${v1}\"}`);\n      expect(JSON.parse(await connector.fetch(k1)).v).toBe(v1);\n\n      const transform = new PromiseDelegate<StateDB.DataTransform>();\n      const db = new StateDB({ connector, transform: transform.promise });\n      const transformation: StateDB.DataTransform = {\n        type: 'merge',\n        contents: { [k2]: v2 }\n      };\n\n      transform.resolve(transformation);\n      await transform.promise;\n      expect(await db.fetch(k1)).toBe(v1);\n      expect(await db.fetch(k2)).toBe(v2);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should emit changes when the database is updated",
            "suites": [
                "StateDB",
                "#changed"
            ],
            "updatePoint": {
                "line": 64,
                "column": 56
            },
            "line": 64,
            "code": "    it('should emit changes when the database is updated', async () => {\n      const db = new StateDB();\n      const changes: StateDB.Change[] = [\n        { id: 'foo', type: 'save' },\n        { id: 'foo', type: 'remove' },\n        { id: 'bar', type: 'save' },\n        { id: 'bar', type: 'remove' }\n      ];\n      const recorded: StateDB.Change[] = [];\n\n      db.changed.connect((_, change) => {\n        recorded.push(change);\n      });\n\n      await db.save('foo', 0);\n      await db.remove('foo');\n      await db.save('bar', 1);\n      await db.remove('bar');\n      expect(recorded).toEqual(changes);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should empty the items in a state database",
            "suites": [
                "StateDB",
                "#clear()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 50
            },
            "line": 87,
            "code": "    it('should empty the items in a state database', async () => {\n      const connector = new StateDB.Connector();\n      const db = new StateDB({ connector });\n\n      expect((await connector.list()).ids).toHaveLength(0);\n      await db.save('foo', 'bar');\n      expect((await connector.list()).ids).toHaveLength(1);\n      await db.clear();\n      expect((await connector.list()).ids).toHaveLength(0);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should fetch a stored key",
            "suites": [
                "StateDB",
                "#fetch()"
            ],
            "updatePoint": {
                "line": 100,
                "column": 33
            },
            "line": 100,
            "code": "    it('should fetch a stored key', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      expect(await db.fetch(key)).toBeUndefined();\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should fetch a stored namespace",
            "suites": [
                "StateDB",
                "#list()"
            ],
            "updatePoint": {
                "line": 112,
                "column": 39
            },
            "line": 112,
            "code": "    it('should fetch a stored namespace', async () => {\n      const db = new StateDB();\n      const keys = [\n        'foo:bar',\n        'foo:baz',\n        'foo:qux',\n        'abc:def',\n        'abc:ghi',\n        'abc:jkl',\n        'foo-two:bar',\n        'foo-two:baz',\n        'foo-two:qux'\n      ];\n\n      await Promise.all(keys.map(key => db.save(key, { value: key })));\n\n      let fetched = await db.list('foo');\n      expect(fetched.ids.length).toBe(3);\n      expect(fetched.values.length).toBe(3);\n\n      let sorted = fetched.ids.sort((a, b) => a.localeCompare(b));\n      expect(sorted[0]).toBe(keys[0]);\n      expect(sorted[1]).toBe(keys[1]);\n      expect(sorted[2]).toBe(keys[2]);\n\n      fetched = await db.list('abc');\n      expect(fetched.ids.length).toBe(3);\n      expect(fetched.values.length).toBe(3);\n\n      sorted = fetched.ids.sort((a, b) => a.localeCompare(b));\n      expect(sorted[0]).toBe(keys[3]);\n      expect(sorted[1]).toBe(keys[4]);\n      expect(sorted[2]).toBe(keys[5]);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should remove a stored key",
            "suites": [
                "StateDB",
                "#remove()"
            ],
            "updatePoint": {
                "line": 149,
                "column": 34
            },
            "line": 149,
            "code": "    it('should remove a stored key', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      expect(await db.fetch(key)).toBeUndefined();\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n      await db.remove(key);\n      expect(await db.fetch(key)).toBeUndefined();\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should save a key and a value",
            "suites": [
                "StateDB",
                "#save()"
            ],
            "updatePoint": {
                "line": 163,
                "column": 37
            },
            "line": 163,
            "code": "    it('should save a key and a value', async () => {\n      const db = new StateDB();\n      const key = 'foo:bar';\n      const value = { baz: 'qux' };\n\n      await db.save(key, value);\n      expect(await db.fetch(key)).toEqual(value);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "return the full contents of a state database",
            "suites": [
                "StateDB",
                "#toJSON()"
            ],
            "updatePoint": {
                "line": 174,
                "column": 52
            },
            "line": 174,
            "code": "    it('return the full contents of a state database', async () => {\n      const db = new StateDB();\n      const contents: ReadonlyJSONObject = {\n        abc: 'def',\n        ghi: 'jkl',\n        mno: 1,\n        pqr: {\n          foo: { bar: { baz: 'qux' } }\n        }\n      };\n\n      await Promise.all(\n        Object.keys(contents).map(key => db.save(key, contents[key]))\n      );\n      const serialized = await db.toJSON();\n      expect(serialized).toEqual(contents);\n    });",
            "file": "statedb.spec.ts",
            "skipped": false,
            "dir": "packages/statedb/test"
        },
        {
            "name": "should construct a new status bar",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 23,
                "column": 43
            },
            "line": 23,
            "code": "      it('should construct a new status bar', () => {\n        const statusBar = new StatusBar();\n        expect(statusBar).toBeInstanceOf(StatusBar);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should add a new status item to the status bar",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 30,
                "column": 56
            },
            "line": 30,
            "code": "      it('should add a new status item to the status bar', () => {\n        const item = new Widget();\n        expect(item.isAttached).toBe(false);\n        statusBar.registerStatusItem('item', { item });\n        expect(item.isAttached).toBe(true);\n        expect(statusBar.contains(item)).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should raise an error if the same key is added twice",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 38,
                "column": 62
            },
            "line": 38,
            "code": "      it('should raise an error if the same key is added twice', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item', { item: item1 });\n        expect(\n          statusBar.registerStatusItem.bind(statusBar, 'item', { item: item2 })\n        ).toThrow();\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should put higher rank left items closer to the middle",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 47,
                "column": 64
            },
            "line": 47,
            "code": "      it('should put higher rank left items closer to the middle', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item1', {\n          item: item1,\n          align: 'left',\n          rank: 1\n        });\n        statusBar.registerStatusItem('item2', {\n          item: item2,\n          align: 'left',\n          rank: 0\n        });\n        expect(item2.node.nextSibling).toBe(item1.node);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should put higher rank right items closer to the middle",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 63,
                "column": 65
            },
            "line": 63,
            "code": "      it('should put higher rank right items closer to the middle', () => {\n        const item1 = new Widget();\n        const item2 = new Widget();\n        statusBar.registerStatusItem('item1', {\n          item: item1,\n          align: 'right',\n          rank: 0\n        });\n        statusBar.registerStatusItem('item2', {\n          item: item2,\n          align: 'right',\n          rank: 1\n        });\n        // Reverse order than what one might expect, as right-to-left\n        // is set in the styling of the right panel.\n        expect(item1.node.nextSibling).toBe(item2.node);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should allow insertion of status items in the middle",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 81,
                "column": 62
            },
            "line": 81,
            "code": "      it('should allow insertion of status items in the middle', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', {\n          item: item,\n          align: 'middle'\n        });\n        expect(item.isAttached).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should only show if isActive returns true",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 90,
                "column": 51
            },
            "line": 90,
            "code": "      it('should only show if isActive returns true', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', {\n          item,\n          isActive: () => false\n        });\n        expect(item.isHidden).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should update whether it is shown if activeStateChanged fires",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 99,
                "column": 71
            },
            "line": 99,
            "code": "      it('should update whether it is shown if activeStateChanged fires', () => {\n        const item = new Widget();\n        let active = false;\n        const isActive = () => active;\n        const activeStateChanged = new Signal<any, void>({});\n        statusBar.registerStatusItem('item', {\n          item,\n          isActive,\n          activeStateChanged\n        });\n        expect(item.isHidden).toBe(true);\n        active = true;\n        activeStateChanged.emit(void 0);\n        expect(item.isHidden).toBe(false);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should be removed from the status bar if disposed",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#registerStatusItem"
            ],
            "updatePoint": {
                "line": 115,
                "column": 59
            },
            "line": 115,
            "code": "      it('should be removed from the status bar if disposed', () => {\n        const item = new Widget();\n        const disposable = statusBar.registerStatusItem('item', { item });\n        expect(item.isVisible).toBe(true);\n        disposable.dispose();\n        expect(item.isVisible).toBe(false);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should dispose of the status bar",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#dispose"
            ],
            "updatePoint": {
                "line": 125,
                "column": 42
            },
            "line": 125,
            "code": "      it('should dispose of the status bar', () => {\n        expect(statusBar.isDisposed).toBe(false);\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should be safe to call more than once",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#dispose"
            ],
            "updatePoint": {
                "line": 131,
                "column": 47
            },
            "line": 131,
            "code": "      it('should be safe to call more than once', () => {\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n        statusBar.dispose();\n        expect(statusBar.isDisposed).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should dispose of the status items added to it",
            "suites": [
                "@jupyterlab/statusbar",
                "StatusBar",
                "#dispose"
            ],
            "updatePoint": {
                "line": 138,
                "column": 56
            },
            "line": 138,
            "code": "      it('should dispose of the status items added to it', () => {\n        const item = new Widget();\n        statusBar.registerStatusItem('item', { item });\n        expect(item.isDisposed).toBe(false);\n        statusBar.dispose();\n        expect(item.isDisposed).toBe(true);\n      });",
            "file": "statusbar.spec.ts",
            "skipped": false,
            "dir": "packages/statusbar/test"
        },
        {
            "name": "should create a terminal widget",
            "suites": [
                "terminal/index",
                "Terminal",
                "#constructor()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 41
            },
            "line": 76,
            "code": "      it('should create a terminal widget', () => {\n        expect(widget).toBeInstanceOf(Terminal);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should be the constructor value",
            "suites": [
                "terminal/index",
                "Terminal",
                "#session"
            ],
            "updatePoint": {
                "line": 82,
                "column": 41
            },
            "line": 82,
            "code": "      it('should be the constructor value', () => {\n        expect(widget.session).toBe(session);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should set the title when ready",
            "suites": [
                "terminal/index",
                "Terminal",
                "#session"
            ],
            "updatePoint": {
                "line": 86,
                "column": 41
            },
            "line": 86,
            "code": "      it('should set the title when ready', async () => {\n        if (session.connectionStatus !== 'connected') {\n          await testEmission(session.connectionStatusChanged, {\n            find: (_, status) => status === 'connected'\n          });\n        }\n        expect(widget.title.label).toContain(session.name);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should be 13 by default",
            "suites": [
                "terminal/index",
                "Terminal",
                "#fontSize"
            ],
            "updatePoint": {
                "line": 97,
                "column": 33
            },
            "line": 97,
            "code": "      it('should be 13 by default', () => {\n        expect(widget.getOption('fontSize')).toBe(13);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should trigger an update request",
            "suites": [
                "terminal/index",
                "Terminal",
                "#fontSize"
            ],
            "updatePoint": {
                "line": 101,
                "column": 42
            },
            "line": 101,
            "code": "      it('should trigger an update request', async () => {\n        widget.setOption('fontSize', 14);\n        expect(widget.getOption('fontSize')).toBe(14);\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should be 1000 by default",
            "suites": [
                "terminal/index",
                "Terminal",
                "#scrollback"
            ],
            "updatePoint": {
                "line": 110,
                "column": 35
            },
            "line": 110,
            "code": "      it('should be 1000 by default', () => {\n        expect(widget.getOption('scrollback')).toBe(1000);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should be set to inherit by default",
            "suites": [
                "terminal/index",
                "Terminal",
                "#theme"
            ],
            "updatePoint": {
                "line": 116,
                "column": 45
            },
            "line": 116,
            "code": "      it('should be set to inherit by default', () => {\n        expect(widget.getOption('theme')).toBe('inherit');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should be light if we change it",
            "suites": [
                "terminal/index",
                "Terminal",
                "#theme"
            ],
            "updatePoint": {
                "line": 120,
                "column": 41
            },
            "line": 120,
            "code": "      it('should be light if we change it', () => {\n        widget.setOption('theme', 'light');\n        expect(widget.getOption('theme')).toBe('light');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should dispose of the resources used by the widget",
            "suites": [
                "terminal/index",
                "Terminal",
                "#dispose()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 60
            },
            "line": 127,
            "code": "      it('should dispose of the resources used by the widget', () => {\n        expect(widget.isDisposed).toBe(false);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n        widget.dispose();\n        expect(widget.isDisposed).toBe(true);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should refresh the widget",
            "suites": [
                "terminal/index",
                "Terminal",
                "#refresh()"
            ],
            "updatePoint": {
                "line": 137,
                "column": 35
            },
            "line": 137,
            "code": "      it('should refresh the widget', async () => {\n        await expect(widget.refresh()).resolves.not.toThrow();\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should handle fit requests",
            "suites": [
                "terminal/index",
                "Terminal",
                "#processMessage()"
            ],
            "updatePoint": {
                "line": 143,
                "column": 36
            },
            "line": 143,
            "code": "      it('should handle fit requests', () => {\n        widget.processMessage(Widget.Msg.FitRequest);\n        expect(widget.methods).toContain('onFitRequest');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onAfterAttach()"
            ],
            "updatePoint": {
                "line": 150,
                "column": 39
            },
            "line": 150,
            "code": "      it('should post an update request', async () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should post an update request",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onAfterShow()"
            ],
            "updatePoint": {
                "line": 159,
                "column": 39
            },
            "line": 159,
            "code": "      it('should post an update request', async () => {\n        widget.hide();\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        await framePromise();\n        widget.methods = [];\n        widget.show();\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should trigger an update request",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onResize()"
            ],
            "updatePoint": {
                "line": 172,
                "column": 42
            },
            "line": 172,
            "code": "      it('should trigger an update request', async () => {\n        const msg = Widget.ResizeMessage.UnknownSize;\n        MessageLoop.sendMessage(widget, msg);\n        expect(widget.methods).toContain('onResize');\n        await framePromise();\n        expect(widget.methods).toContain('onUpdateRequest');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should attach the terminal",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onUpdateRequest()"
            ],
            "updatePoint": {
                "line": 182,
                "column": 36
            },
            "line": 182,
            "code": "      it('should attach the terminal', () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);\n        expect(widget.methods).toContain('onUpdateRequest');\n        expect(widget.node.firstElementChild!.classList).toContain(\n          'jp-Terminal-body'\n        );\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should send a resize request",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onFitRequest"
            ],
            "updatePoint": {
                "line": 194,
                "column": 38
            },
            "line": 194,
            "code": "      it('should send a resize request', () => {\n        MessageLoop.sendMessage(widget, Widget.Msg.FitRequest);\n        expect(widget.methods).toContain('onResize');\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        },
        {
            "name": "should focus the terminal element",
            "suites": [
                "terminal/index",
                "Terminal",
                "#onActivateRequest"
            ],
            "updatePoint": {
                "line": 201,
                "column": 43
            },
            "line": 201,
            "code": "      it('should focus the terminal element', () => {\n        Widget.detach(widget);\n        Widget.attach(widget, document.body);\n        expect(widget.node.contains(document.activeElement)).toBe(false);\n        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);\n        expect(widget.methods).toContain('onActivateRequest');\n        expect(widget.node.contains(document.activeElement)).toBe(true);\n      });",
            "file": "terminal.spec.ts",
            "skipped": false,
            "dir": "packages/terminal/test"
        }
    ],
    "error": "Cannot read properties of undefined (reading 'object')"
}