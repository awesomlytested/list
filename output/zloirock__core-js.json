{"repo":"zloirock/core-js","url":"https://github.com/zloirock/core-js","branch":"master","configs":[{"lang":"js","dir":"tests","framework":"qunit","pattern":"**/**.{ts,js}"}],"tests":[{"name":"\"","suites":[],"line":233,"code":"    return test == test.toLowerCase() && test.split('\"').length <= 3;","file":"compat/tests.js","skipped":false,"dir":"tests"},{"name":"prototype","suites":[],"line":652,"code":"    return typeof test == 'function' && !test.hasOwnProperty('prototype');","file":"compat/tests.js","skipped":false,"dir":"tests"},{"name":"abc","suites":[],"line":1058,"code":"    return re.test('abc') === true && execCalled;","file":"compat/tests.js","skipped":false,"dir":"tests"},{"name":"AggregateError","suites":[],"line":5,"code":"QUnit.test('AggregateError', assert => {\n  assert.isFunction(AggregateError);\n  assert.arity(AggregateError, 2);\n  assert.name(AggregateError, 'AggregateError');\n  assert.true(new AggregateError([1]) instanceof AggregateError);\n  assert.true(new AggregateError([1]) instanceof Error);\n  assert.true(AggregateError([1]) instanceof AggregateError);\n  assert.true(AggregateError([1]) instanceof Error);\n  assert.same(AggregateError([1], 'foo').message, 'foo');\n  assert.same(AggregateError([1], 123).message, '123');\n  assert.same(AggregateError([1]).message, '');\n  assert.deepEqual(AggregateError([1, 2, 3]).errors, [1, 2, 3]);\n  assert.throws(() => AggregateError([1], Symbol()), 'throws on symbol as a message');\n  assert.same(toString(AggregateError([1])), '[object Error]', 'Object#toString');\n  assert.true(AggregateError([1], 1) instanceof AggregateError, 'no cause, without new');\n  assert.true(new AggregateError([1], 1) instanceof AggregateError, 'no cause, with new');\n  assert.true(AggregateError([1], 1, {}) instanceof AggregateError, 'with options, without new');\n  assert.true(new AggregateError([1], 1, {}) instanceof AggregateError, 'with options, with new');\n  assert.true(AggregateError([1], 1, 'foo') instanceof AggregateError, 'non-object options, without new');\n  assert.true(new AggregateError([1], 1, 'foo') instanceof AggregateError, 'non-object options, with new');\n  assert.same(AggregateError([1], 1, {\n    cause: 7\n  }).cause, 7, 'cause, without new');\n  assert.same(new AggregateError([1], 1, {\n    cause: 7\n  }).cause, 7, 'cause, with new');\n  assert.same(AggregateError([1], 1, create({\n    cause: 7\n  })).cause, 7, 'prototype cause, without new');\n  assert.same(new AggregateError([1], 1, create({\n    cause: 7\n  })).cause, 7, 'prototype cause, with new');\n  let error = AggregateError([1], 1, {\n    cause: 7\n  });\n  assert.deepEqual(error.errors, [1]);\n  assert.same(error.name, 'AggregateError', 'instance name');\n  assert.same(error.message, '1', 'instance message');\n  assert.same(error.cause, 7, 'instance cause'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n  assert.true(error.hasOwnProperty('cause'), 'cause is own');\n  error = AggregateError([1]);\n  assert.deepEqual(error.errors, [1]);\n  assert.same(error.message, '', 'default instance message');\n  assert.same(error.cause, undefined, 'default instance cause undefined'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n  assert.false(error.hasOwnProperty('cause'), 'default instance cause missed');\n});","file":"pure/es.aggregate-error.js","skipped":false,"dir":"tests"},{"name":"Array#at","suites":[],"line":3,"code":"QUnit.test('Array#at', assert => {\n  assert.isFunction(at);\n  assert.same(1, at([1, 2, 3], 0));\n  assert.same(2, at([1, 2, 3], 1));\n  assert.same(3, at([1, 2, 3], 2));\n  assert.same(undefined, at([1, 2, 3], 3));\n  assert.same(3, at([1, 2, 3], -1));\n  assert.same(2, at([1, 2, 3], -2));\n  assert.same(1, at([1, 2, 3], -3));\n  assert.same(undefined, at([1, 2, 3], -4));\n  assert.same(1, at([1, 2, 3], 0.4));\n  assert.same(1, at([1, 2, 3], 0.5));\n  assert.same(1, at([1, 2, 3], 0.6));\n  assert.same(1, at([1], NaN));\n  assert.same(1, at([1]));\n  assert.same(1, at([1, 2, 3], -0));\n  assert.same(undefined, at(Array(1), 0));\n  assert.same(1, at({\n    0: 1,\n    length: 1\n  }, 0));\n\n  if (STRICT) {\n    assert.throws(() => at(null, 0), TypeError);\n    assert.throws(() => at(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.at.js","skipped":false,"dir":"tests"},{"name":"Array#concat","suites":[],"line":5,"code":"QUnit.test('Array#concat', assert => {\n  assert.isFunction(concat);\n  let array = [1, 2];\n  const sparseArray = [1,, 2];\n  const nonSpreadableArray = [1, 2];\n  nonSpreadableArray[Symbol.isConcatSpreadable] = false;\n  const arrayLike = {\n    0: 1,\n    1: 2,\n    length: 2\n  };\n  const spreadableArrayLike = {\n    0: 1,\n    1: 2,\n    length: 2,\n    [Symbol.isConcatSpreadable]: true\n  };\n  assert.deepEqual(concat(array), [1, 2], '#1');\n  assert.deepEqual(concat(sparseArray), [1,, 2], '#2');\n  assert.deepEqual(concat(nonSpreadableArray), [[1, 2]], '#3');\n  assert.deepEqual(concat(arrayLike), [{\n    0: 1,\n    1: 2,\n    length: 2\n  }], '#4');\n  assert.deepEqual(concat(spreadableArrayLike), [1, 2], '#5');\n  assert.deepEqual(concat([], array), [1, 2], '#6');\n  assert.deepEqual(concat([], sparseArray), [1,, 2], '#7');\n  assert.deepEqual(concat([], nonSpreadableArray), [[1, 2]], '#8');\n  assert.deepEqual(concat([], arrayLike), [{\n    0: 1,\n    1: 2,\n    length: 2\n  }], '#9');\n  assert.deepEqual(concat([], spreadableArrayLike), [1, 2], '#10');\n  assert.deepEqual(concat(array, sparseArray, nonSpreadableArray, arrayLike, spreadableArrayLike), [1, 2, 1,, 2, [1, 2], {\n    0: 1,\n    1: 2,\n    length: 2\n  }, 1, 2], '#11');\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(concat(array).foo, 1, '@@species');\n});","file":"pure/es.array.concat.js","skipped":false,"dir":"tests"},{"name":"Array#copyWithin","suites":[],"line":3,"code":"QUnit.test('Array#copyWithin', assert => {\n  assert.isFunction(copyWithin);\n  const array = [1];\n  assert.same(copyWithin(array, 0), array);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 0, 3), [4, 5, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 1, 3), [1, 4, 5, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 1, 2), [1, 3, 4, 5, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 2, 2), [1, 2, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 0, 3, 4), [4, 2, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 1, 3, 4), [1, 4, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 1, 2, 4), [1, 3, 4, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 0, -2), [4, 5, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], 0, -2, -1), [4, 2, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], -4, -3, -2), [1, 3, 3, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], -4, -3, -1), [1, 3, 4, 4, 5]);\n  assert.deepEqual(copyWithin([1, 2, 3, 4, 5], -4, -3), [1, 3, 4, 5, 5]);\n\n  if (STRICT) {\n    assert.throws(() => copyWithin(null, 0), TypeError);\n    assert.throws(() => copyWithin(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.copy-within.js","skipped":false,"dir":"tests"},{"name":"Array#every","suites":[],"line":3,"code":"QUnit.test('Array#every', assert => {\n  assert.isFunction(every);\n  const array = [1];\n  const context = {};\n  every(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(every([1, 2, 3], it => typeof it == 'number'));\n  assert.true(every([1, 2, 3], it => it < 4));\n  assert.false(every([1, 2, 3], it => it < 3));\n  assert.false(every([1, 2, 3], it => typeof it == 'string'));\n  assert.true(every([1, 2, 3], function () {\n    return +this === 1;\n  }, 1));\n  let rez = '';\n  every([1, 2, 3], (value, key) => rez += key);\n  assert.same(rez, '012');\n  const arr = [1, 2, 3];\n  assert.true(every(arr, (value, key, that) => that === arr));\n\n  if (STRICT) {\n    assert.throws(() => every(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => every(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n});","file":"pure/es.array.every.js","skipped":false,"dir":"tests"},{"name":"Array#fill","suites":[],"line":3,"code":"QUnit.test('Array#fill', assert => {\n  assert.isFunction(fill);\n  const array = fill(Array(5), 5);\n  assert.same(array, array);\n  assert.deepEqual(fill(Array(5), 5), [5, 5, 5, 5, 5]);\n  assert.deepEqual(fill(Array(5), 5, 1), [undefined, 5, 5, 5, 5]);\n  assert.deepEqual(fill(Array(5), 5, 1, 4), [undefined, 5, 5, 5, undefined]);\n  assert.deepEqual(fill(Array(5), 5, 6, 1), [undefined, undefined, undefined, undefined, undefined]);\n  assert.deepEqual(fill(Array(5), 5, -3, 4), [undefined, undefined, 5, 5, undefined]);\n  assert.arrayEqual(fill({\n    length: 5\n  }, 5), [5, 5, 5, 5, 5]);\n\n  if (STRICT) {\n    assert.throws(() => fill(null, 0), TypeError);\n    assert.throws(() => fill(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.fill.js","skipped":false,"dir":"tests"},{"name":"Array#filter","suites":[],"line":4,"code":"QUnit.test('Array#filter', assert => {\n  assert.isFunction(filter);\n  let array = [1];\n  const context = {};\n  filter(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], filter([1, 2, 3, 'q', {}, 4, true, 5], it => typeof it == 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filter(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filter(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(filter(array, Boolean).foo, 1, '@@species');\n});","file":"pure/es.array.filter.js","skipped":false,"dir":"tests"},{"name":"Array#findIndex","suites":[],"line":3,"code":"QUnit.test('Array#findIndex', assert => {\n  assert.isFunction(findIndex);\n  const array = [1];\n  const context = {};\n  findIndex(array, function (value, key, that) {\n    assert.same(this, context);\n    assert.same(value, 1);\n    assert.same(key, 0);\n    assert.same(that, array);\n  }, context);\n  assert.same(findIndex([1, 3, NaN, 42, {}], it => it === 42), 3);\n\n  if (STRICT) {\n    assert.throws(() => findIndex(null, 0), TypeError);\n    assert.throws(() => findIndex(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.find-index.js","skipped":false,"dir":"tests"},{"name":"Array#find","suites":[],"line":3,"code":"QUnit.test('Array#find', assert => {\n  assert.isFunction(find);\n  const array = [1];\n  const context = {};\n  find(array, function (value, key, that) {\n    assert.same(this, context);\n    assert.same(value, 1);\n    assert.same(key, 0);\n    assert.same(that, array);\n  }, context);\n  assert.same(find([1, 3, NaN, 42, {}], it => it === 42), 42);\n  assert.same(find([1, 3, NaN, 42, {}], it => it === 43), undefined);\n\n  if (STRICT) {\n    assert.throws(() => find(null, 0), TypeError);\n    assert.throws(() => find(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.find.js","skipped":false,"dir":"tests"},{"name":"Array#flatMap","suites":[],"line":3,"code":"QUnit.test('Array#flatMap', assert => {\n  assert.isFunction(flatMap);\n  assert.deepEqual(flatMap([], it => it), []);\n  assert.deepEqual(flatMap([1, 2, 3], it => it), [1, 2, 3]);\n  assert.deepEqual(flatMap([1, 2, 3], it => [it, it]), [1, 1, 2, 2, 3, 3]);\n  assert.deepEqual(flatMap([1, 2, 3], it => [[it], [it]]), [[1], [1], [2], [2], [3], [3]]);\n  assert.deepEqual(flatMap([1, [2, 3]], () => 1), [1, 1]);\n  const array = [1];\n  const context = {};\n  flatMap(array, function (value, index, that) {\n    assert.same(value, 1);\n    assert.same(index, 0);\n    assert.same(that, array);\n    assert.same(this, context);\n  }, context);\n\n  if (STRICT) {\n    assert.throws(() => flatMap(null, it => it), TypeError);\n    assert.throws(() => flatMap(undefined, it => it), TypeError);\n  }\n\n  assert.notThrows(() => flatMap({\n    length: -1\n  }, () => {\n    throw new Error();\n  }).length === 0, 'uses ToLength');\n});","file":"pure/es.array.flat-map.js","skipped":false,"dir":"tests"},{"name":"Array#flat","suites":[],"line":4,"code":"QUnit.test('Array#flat', assert => {\n  assert.isFunction(flat);\n  assert.deepEqual(flat([]), []);\n  const array = [1, [2, 3], [4, [5, 6]]];\n  assert.deepEqual(flat(array, 0), array);\n  assert.deepEqual(flat(array, 1), [1, 2, 3, 4, [5, 6]]);\n  assert.deepEqual(flat(array), [1, 2, 3, 4, [5, 6]]);\n  assert.deepEqual(flat(array, 2), [1, 2, 3, 4, 5, 6]);\n  assert.deepEqual(flat(array, 3), [1, 2, 3, 4, 5, 6]);\n  assert.deepEqual(flat(array, -1), array);\n  assert.deepEqual(flat(array, Infinity), [1, 2, 3, 4, 5, 6]);\n\n  if (STRICT) {\n    assert.throws(() => flat(null), TypeError);\n    assert.throws(() => flat(undefined), TypeError);\n  }\n\n  if (DESCRIPTORS) {\n    assert.notThrows(() => flat(defineProperty({\n      length: -1\n    }, 0, {\n      get() {\n        throw new Error();\n      }\n\n    })).length === 0, 'uses ToLength');\n  }\n});","file":"pure/es.array.flat.js","skipped":false,"dir":"tests"},{"name":"Array#forEach","suites":[],"line":3,"code":"QUnit.test('Array#forEach', assert => {\n  assert.isFunction(forEach);\n  let array = [1];\n  const context = {};\n  forEach(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  let result = '';\n  forEach([1, 2, 3], it => {\n    result += it;\n  });\n  assert.same(result, '123');\n  result = '';\n  forEach([1, 2, 3], (value, key) => {\n    result += key;\n  });\n  assert.same(result, '012');\n  result = '';\n  forEach([1, 2, 3], (value, key, that) => {\n    result += that;\n  });\n  assert.same(result, '1,2,31,2,31,2,3');\n  result = '';\n  forEach([1, 2, 3], function () {\n    result += this;\n  }, 1);\n  assert.same(result, '111');\n  result = '';\n  array = [];\n  array[5] = '';\n  forEach(array, (value, key) => {\n    result += key;\n  });\n  assert.same(result, '5');\n\n  if (STRICT) {\n    assert.throws(() => forEach(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => forEach(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n});","file":"pure/es.array.for-each.js","skipped":false,"dir":"tests"},{"name":"Array.from","suites":[],"line":7,"code":"QUnit.test('Array.from', assert => {\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  let types = {\n    'array-like': {\n      length: '3',\n      0: '1',\n      1: '2',\n      2: '3'\n    },\n    arguments: function () {\n      return arguments;\n    }('1', '2', '3'),\n    array: ['1', '2', '3'],\n    iterable: createIterable(['1', '2', '3']),\n    string: '123'\n  };\n\n  for (const type in types) {\n    const data = types[type];\n    assert.arrayEqual(from(data), ['1', '2', '3'], `Works with ${type}`);\n    assert.arrayEqual(from(data, it => it ** 2), [1, 4, 9], `Works with ${type} + mapFn`);\n  }\n\n  types = {\n    'array-like': {\n      length: 1,\n      0: 1\n    },\n    arguments: function () {\n      return arguments;\n    }(1),\n    array: [1],\n    iterable: createIterable([1]),\n    string: '1'\n  };\n\n  for (const type in types) {\n    const data = types[type];\n    const context = {};\n    assert.arrayEqual(from(data, function (value, key) {\n      assert.same(this, context, `Works with ${type}, correct callback context`);\n      assert.same(value, type === 'string' ? '1' : 1, `Works with ${type}, correct callback key`);\n      assert.same(key, 0, `Works with ${type}, correct callback value`);\n      assert.same(arguments.length, 2, `Works with ${type}, correct callback arguments number`);\n      return 42;\n    }, context), [42], `Works with ${type}, correct result`);\n  }\n\n  const primitives = [false, true, 0];\n\n  for (const primitive of primitives) {\n    assert.arrayEqual(from(primitive), [], `Works with ${primitive}`);\n  }\n\n  assert.throws(() => from(null), TypeError, 'Throws on null');\n  assert.throws(() => from(undefined), TypeError, 'Throws on undefined');\n  assert.arrayEqual(from('𠮷𠮷𠮷'), ['𠮷', '𠮷', '𠮷'], 'Uses correct string iterator');\n  let done = true;\n  from(createIterable([1, 2, 3], {\n    return() {\n      return done = false;\n    }\n\n  }), () => false);\n  assert.true(done, '.return #default');\n  done = false;\n\n  try {\n    from(createIterable([1, 2, 3], {\n      return() {\n        return done = true;\n      }\n\n    }), () => {\n      throw new Error();\n    });\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n\n  class C {\n    /* empty */\n  }\n\n  let instance = from.call(C, createIterable([1, 2]));\n  assert.true(instance instanceof C, 'generic, iterable case, instanceof');\n  assert.arrayEqual(instance, [1, 2], 'generic, iterable case, elements');\n  instance = from.call(C, {\n    0: 1,\n    1: 2,\n    length: 2\n  });\n  assert.true(instance instanceof C, 'generic, array-like case, instanceof');\n  assert.arrayEqual(instance, [1, 2], 'generic, array-like case, elements');\n  let array = [1, 2, 3];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  assert.arrayEqual(from(array), [1, 2, 3], 'Array with custom iterator, elements');\n  assert.true(done, 'call @@iterator in Array with custom iterator');\n  array = [1, 2, 3];\n  delete array[1];\n  assert.arrayEqual(from(array, String), ['1', 'undefined', '3'], 'Ignores holes');\n  assert.notThrows(() => from({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }), 'Uses ToLength');\n  assert.arrayEqual(from([], undefined), [], 'Works with undefined as asecond argument');\n  assert.throws(() => from([], null), TypeError, 'Throws with null as second argument');\n  assert.throws(() => from([], 0), TypeError, 'Throws with 0 as second argument');\n  assert.throws(() => from([], ''), TypeError, 'Throws with \"\" as second argument');\n  assert.throws(() => from([], false), TypeError, 'Throws with false as second argument');\n  assert.throws(() => from([], {}), TypeError, 'Throws with {} as second argument');\n\n  if (DESCRIPTORS) {\n    let called = false;\n    defineProperty(C.prototype, 0, {\n      set() {\n        called = true;\n      }\n\n    });\n    from.call(C, [1, 2, 3]);\n    assert.false(called, 'Should not call prototype accessors');\n  }\n});","file":"pure/es.array.from.js","skipped":false,"dir":"tests"},{"name":"Array#includes","suites":[],"line":3,"code":"QUnit.test('Array#includes', assert => {\n  assert.isFunction(includes);\n  const object = {};\n  const array = [1, 2, 3, -0, object];\n  assert.true(includes(array, 1));\n  assert.true(includes(array, -0));\n  assert.true(includes(array, 0));\n  assert.true(includes(array, object));\n  assert.false(includes(array, 4));\n  assert.false(includes(array, -0.5));\n  assert.false(includes(array, {}));\n  assert.true(includes(Array(1), undefined));\n  assert.true(includes([NaN], NaN));\n\n  if (STRICT) {\n    assert.throws(() => includes(null, 0), TypeError);\n    assert.throws(() => includes(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.includes.js","skipped":false,"dir":"tests"},{"name":"Array#indexOf","suites":[],"line":3,"code":"QUnit.test('Array#indexOf', assert => {\n  assert.isFunction(indexOf);\n  assert.same(0, indexOf([1, 1, 1], 1));\n  assert.same(-1, indexOf([1, 2, 3], 1, 1));\n  assert.same(1, indexOf([1, 2, 3], 2, 1));\n  assert.same(-1, indexOf([1, 2, 3], 2, -1));\n  assert.same(1, indexOf([1, 2, 3], 2, -2));\n  assert.same(-1, indexOf([NaN], NaN));\n  assert.same(3, indexOf(Array(2).concat([1, 2, 3]), 2));\n  assert.same(-1, indexOf(Array(1), undefined));\n  assert.same(0, indexOf([1], 1, -0), \"shouldn't return negative zero\");\n\n  if (STRICT) {\n    assert.throws(() => indexOf(null, 0), TypeError);\n    assert.throws(() => indexOf(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.index-of.js","skipped":false,"dir":"tests"},{"name":"Array.isArray","suites":[],"line":2,"code":"QUnit.test('Array.isArray', assert => {\n  assert.isFunction(isArray);\n  assert.false(isArray({}));\n  assert.false(isArray(function () {\n    return arguments;\n  }()));\n  assert.true(isArray([]));\n});","file":"pure/es.array.is-array.js","skipped":false,"dir":"tests"},{"name":"Array#@@iterator","suites":[],"line":4,"code":"QUnit.test('Array#@@iterator', assert => {\n  assert.isFunction(values);\n  const iterator = getIterator(['q', 'w', 'e']);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.same(String(iterator), '[object Array Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#keys","suites":[],"line":28,"code":"QUnit.test('Array#keys', assert => {\n  assert.isFunction(keys);\n  const iterator = keys(['q', 'w', 'e']);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 0,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 2,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#values","suites":[],"line":51,"code":"QUnit.test('Array#values', assert => {\n  assert.isFunction(values);\n  const iterator = values(['q', 'w', 'e']);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#entries","suites":[],"line":74,"code":"QUnit.test('Array#entries', assert => {\n  assert.isFunction(entries);\n  const iterator = entries(['q', 'w', 'e']);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: [0, 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: [1, 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: [2, 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#join","suites":[],"line":3,"code":"QUnit.test('Array#join', assert => {\n  assert.isFunction(join);\n  assert.same(join([1, 2, 3], undefined), '1,2,3');\n  assert.same(join('123'), '1,2,3');\n  assert.same(join('123', '|'), '1|2|3');\n\n  if (STRICT) {\n    assert.throws(() => join(null), TypeError);\n    assert.throws(() => join(undefined), TypeError);\n  }\n});","file":"pure/es.array.join.js","skipped":false,"dir":"tests"},{"name":"Array#lastIndexOf","suites":[],"line":3,"code":"QUnit.test('Array#lastIndexOf', assert => {\n  assert.isFunction(lastIndexOf);\n  assert.same(2, lastIndexOf([1, 1, 1], 1));\n  assert.same(-1, lastIndexOf([1, 2, 3], 3, 1));\n  assert.same(1, lastIndexOf([1, 2, 3], 2, 1));\n  assert.same(-1, lastIndexOf([1, 2, 3], 2, -3));\n  assert.same(-1, lastIndexOf([1, 2, 3], 1, -4));\n  assert.same(1, lastIndexOf([1, 2, 3], 2, -2));\n  assert.same(-1, lastIndexOf([NaN], NaN));\n  assert.same(1, lastIndexOf([1, 2, 3].concat(Array(2)), 2));\n  assert.same(0, lastIndexOf([1], 1, -0), \"shouldn't return negative zero\");\n\n  if (STRICT) {\n    assert.throws(() => lastIndexOf(null, 0), TypeError);\n    assert.throws(() => lastIndexOf(undefined, 0), TypeError);\n  }\n});","file":"pure/es.array.last-index-of.js","skipped":false,"dir":"tests"},{"name":"Array#map","suites":[],"line":4,"code":"QUnit.test('Array#map', assert => {\n  assert.isFunction(map);\n  let array = [1];\n  const context = {};\n  map(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([2, 3, 4], map([1, 2, 3], it => it + 1));\n  assert.deepEqual([1, 3, 5], map([1, 2, 3], (value, key) => value + key));\n  assert.deepEqual([2, 2, 2], map([1, 2, 3], function () {\n    return +this;\n  }, 2));\n\n  if (STRICT) {\n    assert.throws(() => map(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => map(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(map(array, Boolean).foo, 1, '@@species');\n});","file":"pure/es.array.map.js","skipped":false,"dir":"tests"},{"name":"Array.of","suites":[],"line":4,"code":"QUnit.test('Array.of', assert => {\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.deepEqual(of(1), [1]);\n  assert.deepEqual(of(1, 2, 3), [1, 2, 3]);\n\n  class C {\n    /* empty */\n  }\n\n  const instance = of.call(C, 1, 2);\n  assert.true(instance instanceof C);\n  assert.same(instance[0], 1);\n  assert.same(instance[1], 2);\n  assert.same(instance.length, 2);\n\n  if (DESCRIPTORS) {\n    let called = false;\n    defineProperty(C.prototype, 0, {\n      set() {\n        called = true;\n      }\n\n    });\n    of.call(C, 1, 2, 3);\n    assert.false(called, 'Should not call prototype accessors');\n  }\n});","file":"pure/es.array.of.js","skipped":false,"dir":"tests"},{"name":"Array#reduceRight","suites":[],"line":3,"code":"QUnit.test('Array#reduceRight', assert => {\n  assert.isFunction(reduceRight);\n  const array = [1];\n  const accumulator = {};\n  reduceRight(array, function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n  }, accumulator);\n  assert.same(reduceRight([1, 2, 3], (a, b) => a + b, 1), 7, 'works with initial accumulator');\n  reduceRight([1, 2], (memo, value, key) => {\n    assert.same(memo, 2, 'correct default accumulator');\n    assert.same(value, 1, 'correct start value without initial accumulator');\n    assert.same(key, 0, 'correct start index without initial accumulator');\n  });\n  assert.same(reduceRight([1, 2, 3], (a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  reduceRight([1, 2, 3], (memo, value, key) => {\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '321', 'correct order #1');\n  assert.same(keys, '210', 'correct order #2');\n  assert.same(reduceRight({\n    0: 1,\n    1: 2,\n    length: 2\n  }, (a, b) => a + b), 3, 'generic');\n\n  if (STRICT) {\n    assert.throws(() => reduceRight(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reduceRight(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"pure/es.array.reduce-right.js","skipped":false,"dir":"tests"},{"name":"Array#reduce","suites":[],"line":3,"code":"QUnit.test('Array#reduce', assert => {\n  assert.isFunction(reduce);\n  const array = [1];\n  const accumulator = {};\n  reduce(array, function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n  }, accumulator);\n  assert.same(reduce([1, 2, 3], (a, b) => a + b, 1), 7, 'works with initial accumulator');\n  reduce([1, 2], (memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 1, 'correct start index without initial accumulator');\n  });\n  assert.same(reduce([1, 2, 3], (a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  reduce([1, 2, 3], (memo, value, key) => {\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '123', 'correct order #1');\n  assert.same(keys, '012', 'correct order #2');\n  assert.same(reduce({\n    0: 1,\n    1: 2,\n    length: 2\n  }, (a, b) => a + b), 3, 'generic');\n\n  if (STRICT) {\n    assert.throws(() => reduce(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reduce(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"pure/es.array.reduce.js","skipped":false,"dir":"tests"},{"name":"Array#reverse","suites":[],"line":3,"code":"QUnit.test('Array#reverse', assert => {\n  assert.isFunction(reverse);\n  const a = [1, 2.2, 3.3];\n\n  function fn() {\n    +a;\n    reverse(a);\n  }\n\n  fn();\n  assert.arrayEqual(a, [3.3, 2.2, 1]);\n\n  if (STRICT) {\n    assert.throws(() => reverse(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reverse(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"pure/es.array.reverse.js","skipped":false,"dir":"tests"},{"name":"Array#slice","suites":[],"line":5,"code":"QUnit.test('Array#slice', assert => {\n  assert.isFunction(slice);\n  let array = ['1', '2', '3', '4', '5'];\n  assert.deepEqual(slice(array), array);\n  assert.deepEqual(slice(array, 1, 3), ['2', '3']);\n  assert.deepEqual(slice(array, 1, undefined), ['2', '3', '4', '5']);\n  assert.deepEqual(slice(array, 1, -1), ['2', '3', '4']);\n  assert.deepEqual(slice(array, -2, -1), ['4']);\n  assert.deepEqual(slice(array, -2, -3), []);\n  const string = '12345';\n  assert.deepEqual(slice(string), array);\n  assert.deepEqual(slice(string, 1, 3), ['2', '3']);\n  assert.deepEqual(slice(string, 1, undefined), ['2', '3', '4', '5']);\n  assert.deepEqual(slice(string, 1, -1), ['2', '3', '4']);\n  assert.deepEqual(slice(string, -2, -1), ['4']);\n  assert.deepEqual(slice(string, -2, -3), []);\n  const list = GLOBAL.document && document.body && document.body.childNodes;\n\n  if (list) {\n    assert.notThrows(() => isArray(slice(list)), 'works with NodeList');\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(slice(array).foo, 1, '@@species');\n});","file":"pure/es.array.slice.js","skipped":false,"dir":"tests"},{"name":"Array#some","suites":[],"line":3,"code":"QUnit.test('Array#some', assert => {\n  assert.isFunction(some);\n  let array = [1];\n  const context = {};\n  some(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(some([1, '2', 3], it => typeof it == 'number'));\n  assert.true(some([1, 2, 3], it => it < 3));\n  assert.false(some([1, 2, 3], it => it < 0));\n  assert.false(some([1, 2, 3], it => typeof it == 'string'));\n  assert.false(some([1, 2, 3], function () {\n    return +this !== 1;\n  }, 1));\n  let result = '';\n  some([1, 2, 3], (value, key) => {\n    result += key;\n    return false;\n  });\n  assert.same(result, '012');\n  array = [1, 2, 3];\n  assert.false(some(array, (value, key, that) => that !== array));\n\n  if (STRICT) {\n    assert.throws(() => some(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => some(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n});","file":"pure/es.array.some.js","skipped":false,"dir":"tests"},{"name":"Array#sort","suites":[],"line":3,"code":"QUnit.test('Array#sort', assert => {\n  assert.isFunction(sort);\n  assert.notThrows(() => sort([1, 2, 3], undefined), 'works with undefined');\n  assert.throws(() => sort([1, 2, 3], null), 'throws on null');\n  assert.throws(() => sort([1, 2, 3], {}), 'throws on {}');\n  assert.deepEqual(sort([1, 3, 2]), [1, 2, 3], '#1');\n  assert.deepEqual(sort([1, 3, 2, 11]), [1, 11, 2, 3], '#2');\n  assert.deepEqual(sort([1, -1, 3, NaN, 2, 0, 11, -0]), [-1, 0, -0, 1, 11, 2, 3, NaN], '#3');\n  let array = Array(5);\n  array[0] = 1;\n  array[2] = 3;\n  array[4] = 2;\n  let expected = Array(5);\n  expected[0] = 1;\n  expected[1] = 2;\n  expected[2] = 3;\n  assert.deepEqual(sort(array), expected, 'holes');\n  array = 'zyxwvutsrqponMLKJIHGFEDCBA'.split('');\n  expected = 'ABCDEFGHIJKLMnopqrstuvwxyz'.split('');\n  assert.deepEqual(sort(array), expected, 'alpha #1');\n  array = 'ёяюэьыъщшчцхфутсрПОНМЛКЙИЗЖЕДГВБА'.split('');\n  expected = 'АБВГДЕЖЗИЙКЛМНОПрстуфхцчшщъыьэюяё'.split('');\n  assert.deepEqual(sort(array), expected, 'alpha #2');\n  array = [undefined, 1];\n  assert.notThrows(() => sort(array, () => {\n    throw 1;\n  }), 'undefined #1');\n  assert.deepEqual(array, [1, undefined], 'undefined #2');\n  const object = {\n    valueOf: () => 1,\n    toString: () => -1\n  };\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  expected = {\n    0: -1,\n    1: object,\n    2: 1,\n    3: 2,\n    4: Infinity,\n    5: NaN,\n    6: 'X',\n    7: 'a',\n    8: true,\n    9: undefined,\n    length: 11\n  };\n  assert.deepEqual(sort(array), expected, 'custom generic');\n  let index, mod, code, chr, value;\n  expected = Array(516);\n  array = Array(516);\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  sort(array, (a, b) => (a / 4 | 0) - (b / 4 | 0));\n  assert.true(1 / sort([0, -0])[0] > 0, '-0');\n  assert.arrayEqual(array, expected, 'stable #1');\n  let result = '';\n  array = []; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n\n      case 68:\n      case 71:\n        value = 4;\n        break;\n\n      default:\n        value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      array.push({\n        k: chr + index,\n        v: value\n      });\n    }\n  }\n\n  sort(array, (a, b) => b.v - a.v);\n\n  for (index = 0; index < array.length; index++) {\n    chr = array[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  assert.same(result, 'DGBEFHACIJK', 'stable #2');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => sort([Symbol(1), Symbol(2)]), 'w/o cmp throws on symbols');\n  }\n\n  if (STRICT) {\n    assert.throws(() => sort(null), TypeError, 'ToObject(this)');\n    assert.throws(() => sort(undefined), TypeError, 'ToObject(this)');\n  }\n});","file":"pure/es.array.sort.js","skipped":false,"dir":"tests"},{"name":"Array#splice","suites":[],"line":4,"code":"QUnit.test('Array#splice', assert => {\n  assert.isFunction(splice);\n  let array = [1, 2, 3, 4, 5];\n  assert.deepEqual(splice(array, 2), [3, 4, 5]);\n  assert.deepEqual(array, [1, 2]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(splice(array, -2), [4, 5]);\n  assert.deepEqual(array, [1, 2, 3]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(splice(array, 2, 2), [3, 4]);\n  assert.deepEqual(array, [1, 2, 5]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(splice(array, 2, -2), []);\n  assert.deepEqual(array, [1, 2, 3, 4, 5]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(splice(array, 2, 2, 6, 7), [3, 4]);\n  assert.deepEqual(array, [1, 2, 6, 7, 5]); // ES6 semantics\n\n  array = [0, 1, 2];\n  assert.deepEqual(splice(array, 0), [0, 1, 2]);\n  array = [0, 1, 2];\n  assert.deepEqual(splice(array, 1), [1, 2]);\n  array = [0, 1, 2];\n  assert.deepEqual(splice(array, 2), [2]);\n\n  if (STRICT) {\n    assert.throws(() => splice(null), TypeError);\n    assert.throws(() => splice(undefined), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(splice(array).foo, 1, '@@species');\n});","file":"pure/es.array.splice.js","skipped":false,"dir":"tests"},{"name":"Date#getYear","suites":[],"line":2,"code":"QUnit.test('Date#getYear', assert => {\n  assert.isFunction(getYear);\n  const date = new Date();\n  assert.same(getYear(date), date.getFullYear() - 1900);\n});","file":"pure/es.date.get-year.js","skipped":false,"dir":"tests"},{"name":"Date.now","suites":[],"line":2,"code":"QUnit.test('Date.now', assert => {\n  assert.isFunction(now);\n  assert.epsilon(+new Date(), now(), 10, 'Date.now() ~ +new Date');\n});","file":"pure/es.date.now.js","skipped":false,"dir":"tests"},{"name":"Date#setYear","suites":[],"line":2,"code":"QUnit.test('Date#setYear', assert => {\n  assert.isFunction(setYear);\n  const date = new Date();\n  setYear(date, 1);\n  assert.same(date.getFullYear(), 1901);\n});","file":"pure/es.date.set-year.js","skipped":false,"dir":"tests"},{"name":"Date#toGMTString","suites":[],"line":2,"code":"QUnit.test('Date#toGMTString', assert => {\n  assert.isFunction(toGMTString);\n  const date = new Date();\n  assert.same(toGMTString(date), date.toUTCString());\n});","file":"pure/es.date.to-gmt-string.js","skipped":false,"dir":"tests"},{"name":"Date#toISOString","suites":[],"line":2,"code":"QUnit.test('Date#toISOString', assert => {\n  assert.isFunction(toISOString);\n  assert.same(toISOString(new Date(0)), '1970-01-01T00:00:00.000Z');\n  assert.same(toISOString(new Date(1e12 + 1)), '2001-09-09T01:46:40.001Z');\n  assert.same(toISOString(new Date(-5e13 - 1)), '0385-07-25T07:06:39.999Z');\n  const future = toISOString(new Date(1e15 + 1));\n  const properFuture = future === '+033658-09-27T01:46:40.001Z' || future === '33658-09-27T01:46:40.001Z';\n  assert.true(properFuture);\n  const prehistoric = toISOString(new Date(-1e15 + 1));\n  const properPrehistoric = prehistoric === '-029719-04-05T22:13:20.001Z' || prehistoric === '-29719-04-05T22:13:20.001Z';\n  assert.true(properPrehistoric);\n  assert.throws(() => toISOString(new Date(NaN)), RangeError);\n});","file":"pure/es.date.to-iso-string.js","skipped":false,"dir":"tests"},{"name":"Date#toJSON","suites":[],"line":3,"code":"QUnit.test('Date#toJSON', assert => {\n  assert.isFunction(toJSON);\n\n  if (Date.prototype.toISOString) {\n    const date = new Date();\n    assert.same(toJSON(date), toISOString(date), 'base');\n  }\n\n  assert.same(toJSON(new Date(NaN)), null, 'not finite');\n  assert.same(toJSON({\n    toISOString() {\n      return 42;\n    }\n\n  }), 42, 'generic');\n});","file":"pure/es.date.to-json.js","skipped":false,"dir":"tests"},{"name":" constructor with 'cause' param","suites":[],"line":6,"code":"  QUnit.test(`${ERROR_NAME} constructor with 'cause' param`, assert => {\n    assert.isFunction($Error);\n    assert.arity($Error, 1);\n    assert.name($Error, ERROR_NAME);\n\n    if (PROTO && $Error !== path.Error) {\n      // eslint-disable-next-line no-prototype-builtins -- safe\n      assert.true(path.Error.isPrototypeOf($Error), 'constructor has `Error` in the prototype chain');\n    }\n\n    assert.true($Error(1) instanceof $Error, 'no cause, without new');\n    assert.true(new $Error(1) instanceof $Error, 'no cause, with new');\n    assert.true($Error(1, {}) instanceof $Error, 'with options, without new');\n    assert.true(new $Error(1, {}) instanceof $Error, 'with options, with new');\n    assert.true($Error(1, 'foo') instanceof $Error, 'non-object options, without new');\n    assert.true(new $Error(1, 'foo') instanceof $Error, 'non-object options, with new');\n    assert.same($Error(1, {\n      cause: 7\n    }).cause, 7, 'cause, without new');\n    assert.same(new $Error(1, {\n      cause: 7\n    }).cause, 7, 'cause, with new');\n    assert.same($Error(1, create({\n      cause: 7\n    })).cause, 7, 'prototype cause, without new');\n    assert.same(new $Error(1, create({\n      cause: 7\n    })).cause, 7, 'prototype cause, with new');\n    let error = $Error(1, {\n      cause: 7\n    });\n    if (!WEB_ASSEMBLY) assert.same(error.name, ERROR_NAME, 'instance name');\n    assert.same(error.message, '1', 'instance message');\n    assert.same(error.cause, 7, 'instance cause'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n    assert.true(error.hasOwnProperty('cause'), 'cause is own');\n    error = $Error();\n    assert.same(error.message, '', 'default instance message');\n    assert.same(error.cause, undefined, 'default instance cause undefined'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n    assert.false(error.hasOwnProperty('cause'), 'default instance cause missed');\n  });","file":"pure/es.error.cause.js","skipped":false,"dir":"tests"},{"name":"escape","suites":[],"line":2,"code":"QUnit.test('escape', assert => {\n  assert.isFunction(escape);\n  assert.arity(escape, 1);\n  assert.same(escape('!q2ф'), '%21q2%u0444');\n  assert.same(escape(null), 'null');\n  assert.same(escape(undefined), 'undefined');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => escape(Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.escape.js","skipped":false,"dir":"tests"},{"name":"Function#bind","suites":[],"line":2,"code":"QUnit.test('Function#bind', assert => {\n  assert.isFunction(bind);\n  const object = {\n    a: 42\n  };\n  assert.same(bind(function () {\n    return this.a;\n  }, object)(), 42);\n  assert.same(new (bind(() => {\n    /* empty */\n  }, object))().a, undefined);\n\n  function C(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  const instance = new (bind(C, null, 1))(2);\n  assert.true(instance instanceof C);\n  assert.same(instance.a, 1);\n  assert.same(instance.b, 2);\n  assert.same(bind(it => it, null, 42)(), 42);\n  const regExpTest = bind(RegExp.prototype.test, /a/);\n  assert.true(regExpTest('a'));\n  const Date2017 = bind(Date, null, 2017);\n  const date = new Date2017(11);\n  assert.true(date instanceof Date);\n  assert.same(date.getFullYear(), 2017);\n  assert.same(date.getMonth(), 11);\n});","file":"pure/es.function.bind.js","skipped":false,"dir":"tests"},{"name":"Function#@@hasInstance","suites":[],"line":2,"code":"QUnit.test('Function#@@hasInstance', assert => {\n  assert.true(Symbol.hasInstance in Function.prototype);\n  assert.true(Function[Symbol.hasInstance](() => {\n    /* empty */\n  }));\n  assert.false(Function[Symbol.hasInstance]({}));\n});","file":"pure/es.function.has-instance.js","skipped":false,"dir":"tests"},{"name":"globalThis","suites":[],"line":2,"code":"QUnit.test('globalThis', assert => {\n  assert.same(globalThis, Object(globalThis), 'is object');\n  assert.same(globalThis.Math, Math, 'contains globals');\n});","file":"pure/es.global-this.js","skipped":false,"dir":"tests"},{"name":"Symbols & JSON.stringify","suites":[],"line":6,"code":"  QUnit.test('Symbols & JSON.stringify', assert => {\n    assert.same(stringify([1, Symbol('foo'), false, Symbol('bar'), {}]), '[1,null,false,null,{}]', 'array value');\n    assert.same(stringify({\n      symbol: Symbol('symbol')\n    }), '{}', 'object value');\n\n    if (DESCRIPTORS) {\n      const object = {\n        bar: 2\n      };\n      object[Symbol('symbol')] = 1;\n      assert.same(stringify(object), '{\"bar\":2}', 'object key');\n    }\n\n    assert.same(stringify(Symbol('symbol')), undefined, 'symbol value');\n\n    if (typeof Symbol() == 'symbol') {\n      assert.same(stringify(Object(Symbol('symbol'))), '{}', 'boxed symbol');\n    }\n\n    assert.same(stringify(undefined, () => 42), '42', 'replacer works with top-level undefined');\n  });","file":"pure/es.json.stringify.js","skipped":false,"dir":"tests"},{"name":"Well‑formed JSON.stringify","suites":[],"line":28,"code":"  QUnit.test('Well‑formed JSON.stringify', assert => {\n    assert.isFunction(stringify);\n    assert.arity(stringify, 3);\n    assert.name(stringify, 'stringify');\n    assert.same(stringify({\n      foo: 'bar'\n    }), '{\"foo\":\"bar\"}', 'basic');\n    assert.same(stringify('\\uDEAD'), '\"\\\\udead\"', 'r1');\n    assert.same(stringify('\\uDF06\\uD834'), '\"\\\\udf06\\\\ud834\"', 'r2');\n    assert.same(stringify('\\uDF06ab\\uD834'), '\"\\\\udf06ab\\\\ud834\"', 'r3');\n    assert.same(stringify('𠮷'), '\"𠮷\"', 'r4');\n    assert.same(stringify('\\uD834\\uDF06'), '\"𝌆\"', 'r5');\n    assert.same(stringify('\\uD834\\uD834\\uDF06'), '\"\\\\ud834𝌆\"', 'r6');\n    assert.same(stringify('\\uD834\\uDF06\\uDF06'), '\"𝌆\\\\udf06\"', 'r7');\n    assert.same(stringify({\n      '𠮷': ['\\uDF06\\uD834']\n    }), '{\"𠮷\":[\"\\\\udf06\\\\ud834\"]}', 'r8');\n  });","file":"pure/es.json.stringify.js","skipped":false,"dir":"tests"},{"name":"Map","suites":[],"line":15,"code":"QUnit.test('Map', assert => {\n  assert.isFunction(Map);\n  assert.true('clear' in Map.prototype, 'clear in Map.prototype');\n  assert.true('delete' in Map.prototype, 'delete in Map.prototype');\n  assert.true('forEach' in Map.prototype, 'forEach in Map.prototype');\n  assert.true('get' in Map.prototype, 'get in Map.prototype');\n  assert.true('has' in Map.prototype, 'has in Map.prototype');\n  assert.true('set' in Map.prototype, 'set in Map.prototype');\n  assert.true(new Map() instanceof Map, 'new Map instanceof Map');\n  assert.same(new Map(createIterable([[1, 1], [2, 2], [3, 3]])).size, 3, 'Init from iterable');\n  assert.same(new Map([[freeze({}), 1], [2, 3]]).size, 2, 'Support frozen objects');\n  let done = false;\n\n  try {\n    new Map(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  new Map(array);\n  assert.true(done);\n  const object = {};\n  new Map().set(object, 1);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(Map);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof Map, 'correct subclassing with native classes #2');\n    assert.same(new Subclass().set(1, 2).get(1), 2, 'correct subclassing with native classes #3');\n  }\n\n  if (typeof ArrayBuffer == 'function') {\n    const buffer = new ArrayBuffer(8);\n    const map = new Map([[buffer, 8]]);\n    assert.true(map.has(buffer), 'works with ArrayBuffer keys');\n  }\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#clear","suites":[],"line":80,"code":"QUnit.test('Map#clear', assert => {\n  assert.isFunction(Map.prototype.clear);\n  let map = new Map();\n  map.clear();\n  assert.same(map.size, 0);\n  map = new Map().set(1, 2).set(2, 3).set(1, 4);\n  map.clear();\n  assert.same(map.size, 0);\n  assert.false(map.has(1));\n  assert.false(map.has(2));\n  const frozen = freeze({});\n  map = new Map().set(1, 2).set(frozen, 3);\n  map.clear();\n  assert.same(map.size, 0, 'Support frozen objects');\n  assert.false(map.has(1));\n  assert.false(map.has(frozen));\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#delete","suites":[],"line":97,"code":"QUnit.test('Map#delete', assert => {\n  assert.isFunction(Map.prototype.delete);\n  const object = {};\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 7);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, 9);\n  assert.same(map.size, 5);\n  assert.true(map.delete(NaN));\n  assert.same(map.size, 4);\n  assert.false(map.delete(4));\n  assert.same(map.size, 4);\n  map.delete([]);\n  assert.same(map.size, 4);\n  map.delete(object);\n  assert.same(map.size, 3);\n  const frozen = freeze({});\n  map.set(frozen, 42);\n  assert.same(map.size, 4);\n  map.delete(frozen);\n  assert.same(map.size, 3);\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#forEach","suites":[],"line":122,"code":"QUnit.test('Map#forEach', assert => {\n  assert.isFunction(Map.prototype.forEach);\n  let result = {};\n  let count = 0;\n  const object = {};\n  let map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 7);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, 9);\n  map.forEach((value, key) => {\n    count++;\n    result[value] = key;\n  });\n  assert.same(count, 5);\n  assert.deepEqual(result, {\n    1: NaN,\n    7: 3,\n    5: 2,\n    4: 1,\n    9: object\n  });\n  map = new Map();\n  map.set('0', 9);\n  map.set('1', 9);\n  map.set('2', 9);\n  map.set('3', 9);\n  result = '';\n  map.forEach((value, key) => {\n    result += key;\n\n    if (key === '2') {\n      map.delete('2');\n      map.delete('3');\n      map.delete('1');\n      map.set('4', 9);\n    }\n  });\n  assert.same(result, '0124');\n  map = new Map([['0', 1]]);\n  result = '';\n  map.forEach(it => {\n    map.delete('0');\n    if (result !== '') throw new Error();\n    result += it;\n  });\n  assert.same(result, '1');\n  assert.throws(() => Map.prototype.forEach.call(new Set(), () => {\n    /* empty */\n  }), 'non-generic');\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#get","suites":[],"line":175,"code":"QUnit.test('Map#get', assert => {\n  assert.isFunction(Map.prototype.get);\n  const object = {};\n  const frozen = freeze({});\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(frozen, 42);\n  map.set(object, object);\n  assert.same(map.get(NaN), 1);\n  assert.same(map.get(4), undefined);\n  assert.same(map.get({}), undefined);\n  assert.same(map.get(object), object);\n  assert.same(map.get(frozen), 42);\n  assert.same(map.get(2), 5);\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#has","suites":[],"line":194,"code":"QUnit.test('Map#has', assert => {\n  assert.isFunction(Map.prototype.has);\n  const object = {};\n  const frozen = freeze({});\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(frozen, 42);\n  map.set(object, object);\n  assert.true(map.has(NaN));\n  assert.true(map.has(object));\n  assert.true(map.has(2));\n  assert.true(map.has(frozen));\n  assert.false(map.has(4));\n  assert.false(map.has({}));\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#set","suites":[],"line":213,"code":"QUnit.test('Map#set', assert => {\n  assert.isFunction(Map.prototype.set);\n  const object = {};\n  let map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, object);\n  assert.same(map.size, 5);\n  const chain = map.set(7, 2);\n  assert.same(chain, map);\n  map.set(7, 2);\n  assert.same(map.size, 6);\n  assert.same(map.get(7), 2);\n  assert.same(map.get(NaN), 1);\n  map.set(NaN, 42);\n  assert.same(map.size, 6);\n  assert.same(map.get(NaN), 42);\n  map.set({}, 11);\n  assert.same(map.size, 7);\n  assert.same(map.get(object), object);\n  map.set(object, 27);\n  assert.same(map.size, 7);\n  assert.same(map.get(object), 27);\n  map = new Map();\n  map.set(NaN, 2);\n  map.set(NaN, 3);\n  map.set(NaN, 4);\n  assert.same(map.size, 1);\n  const frozen = freeze({});\n  map = new Map().set(frozen, 42);\n  assert.same(map.get(frozen), 42);\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#size","suites":[],"line":248,"code":"QUnit.test('Map#size', assert => {\n  const map = new Map();\n  map.set(2, 1);\n  const {\n    size\n  } = map;\n  assert.same(typeof size, 'number', 'size is number');\n  assert.same(size, 1, 'size is correct');\n\n  if (DESCRIPTORS) {\n    const sizeDescriptor = getOwnPropertyDescriptor(Map.prototype, 'size');\n    const getter = sizeDescriptor && sizeDescriptor.get;\n    const setter = sizeDescriptor && sizeDescriptor.set;\n    assert.same(typeof getter, 'function', 'size is getter');\n    assert.same(typeof setter, 'undefined', 'size isnt setter');\n    assert.throws(() => Map.prototype.size, TypeError);\n  }\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map & -0","suites":[],"line":266,"code":"QUnit.test('Map & -0', assert => {\n  let map = new Map();\n  map.set(-0, 1);\n  assert.same(map.size, 1);\n  assert.true(map.has(0));\n  assert.true(map.has(-0));\n  assert.same(map.get(0), 1);\n  assert.same(map.get(-0), 1);\n  map.forEach((val, key) => {\n    assert.false(is(key, -0));\n  });\n  map.delete(-0);\n  assert.same(map.size, 0);\n  map = new Map([[-0, 1]]);\n  map.forEach((val, key) => {\n    assert.false(is(key, -0));\n  });\n  map = new Map();\n  map.set(4, 4);\n  map.set(3, 3);\n  map.set(2, 2);\n  map.set(1, 1);\n  map.set(0, 0);\n  assert.true(map.has(-0));\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#@@toStringTag","suites":[],"line":291,"code":"QUnit.test('Map#@@toStringTag', assert => {\n  assert.same(Map.prototype[Symbol.toStringTag], 'Map', 'Map::@@toStringTag is `Map`');\n  assert.same(String(new Map()), '[object Map]', 'correct stringification');\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map Iterator","suites":[],"line":295,"code":"QUnit.test('Map Iterator', assert => {\n  const map = new Map();\n  map.set('a', 1);\n  map.set('b', 2);\n  map.set('c', 3);\n  map.set('d', 4);\n  const results = [];\n  const iterator = map.keys();\n  results.push(iterator.next().value);\n  assert.true(map.delete('a'));\n  assert.true(map.delete('b'));\n  assert.true(map.delete('c'));\n  map.set('e');\n  results.push(iterator.next().value, iterator.next().value);\n  assert.true(iterator.next().done);\n  map.set('f');\n  assert.true(iterator.next().done);\n  assert.deepEqual(results, ['a', 'd', 'e']);\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#keys","suites":[],"line":314,"code":"QUnit.test('Map#keys', assert => {\n  assert.isFunction(Map.prototype.keys);\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'a',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 's',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'd',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#values","suites":[],"line":341,"code":"QUnit.test('Map#values', assert => {\n  assert.isFunction(Map.prototype.values);\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.values();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#entries","suites":[],"line":368,"code":"QUnit.test('Map#entries', assert => {\n  assert.isFunction(Map.prototype.entries);\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.entries();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['a', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['s', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['d', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#@@iterator","suites":[],"line":395,"code":"QUnit.test('Map#@@iterator', assert => {\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = getIterator(map);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.same(String(iterator), '[object Map Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: ['a', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['s', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['d', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.map.js","skipped":false,"dir":"tests"},{"name":"Math.acosh","suites":[],"line":3,"code":"QUnit.test('Math.acosh', assert => {\n  assert.isFunction(acosh);\n  assert.same(acosh(NaN), NaN);\n  assert.same(acosh(0.5), NaN);\n  assert.same(acosh(-1), NaN);\n  assert.same(acosh(-1e300), NaN);\n  assert.same(acosh(1), 0);\n  assert.same(acosh(Infinity), Infinity);\n  assert.epsilon(acosh(1234), 7.811163220849231);\n  assert.epsilon(acosh(8.88), 2.8737631531629235);\n  assert.epsilon(acosh(1e+160), 369.10676205960726);\n  assert.epsilon(acosh(Number.MAX_VALUE), 710.475860073944);\n  assert.epsilon(acosh(1 + EPSILON), 2.1073424255447017e-8);\n});","file":"pure/es.math.acosh.js","skipped":false,"dir":"tests"},{"name":"Math.asinh","suites":[],"line":2,"code":"QUnit.test('Math.asinh', assert => {\n  assert.isFunction(asinh);\n  assert.same(asinh(NaN), NaN);\n  assert.same(asinh(0), 0);\n  assert.same(asinh(-0), -0);\n  assert.same(asinh(Infinity), Infinity);\n  assert.same(asinh(-Infinity), -Infinity);\n  assert.epsilon(asinh(1234), 7.811163549201245);\n  assert.epsilon(asinh(9.99), 2.997227420191335);\n  assert.epsilon(asinh(1e150), 346.0809111296668);\n  assert.epsilon(asinh(1e7), 16.811242831518268);\n  assert.epsilon(asinh(-1e7), -16.811242831518268);\n});","file":"pure/es.math.asinh.js","skipped":false,"dir":"tests"},{"name":"Math.atanh","suites":[],"line":2,"code":"QUnit.test('Math.atanh', assert => {\n  assert.isFunction(atanh);\n  assert.same(atanh(NaN), NaN);\n  assert.same(atanh(-2), NaN);\n  assert.same(atanh(-1.5), NaN);\n  assert.same(atanh(2), NaN);\n  assert.same(atanh(1.5), NaN);\n  assert.same(atanh(-1), -Infinity);\n  assert.same(atanh(1), Infinity);\n  assert.same(atanh(0), 0);\n  assert.same(atanh(-0), -0);\n  assert.same(atanh(-1e300), NaN);\n  assert.same(atanh(1e300), NaN);\n  assert.epsilon(atanh(0.5), 0.5493061443340549);\n  assert.epsilon(atanh(-0.5), -0.5493061443340549);\n  assert.epsilon(atanh(0.444), 0.47720201260109457);\n});","file":"pure/es.math.atanh.js","skipped":false,"dir":"tests"},{"name":"Math.cbrt","suites":[],"line":2,"code":"QUnit.test('Math.cbrt', assert => {\n  assert.isFunction(cbrt);\n  assert.same(cbrt(NaN), NaN);\n  assert.same(cbrt(0), 0);\n  assert.same(cbrt(-0), -0);\n  assert.same(cbrt(Infinity), Infinity);\n  assert.same(cbrt(-Infinity), -Infinity);\n  assert.same(cbrt(-8), -2);\n  assert.same(cbrt(8), 2);\n  assert.epsilon(cbrt(-1000), -10);\n  assert.epsilon(cbrt(1000), 10);\n});","file":"pure/es.math.cbrt.js","skipped":false,"dir":"tests"},{"name":"Math.clz32","suites":[],"line":2,"code":"QUnit.test('Math.clz32', assert => {\n  assert.isFunction(clz32);\n  assert.same(clz32(0), 32);\n  assert.same(clz32(1), 31);\n  assert.same(clz32(-1), 0);\n  assert.same(clz32(0.6), 32);\n  assert.same(clz32(2 ** 32 - 1), 0);\n  assert.same(clz32(2 ** 32), 32);\n});","file":"pure/es.math.clz32.js","skipped":false,"dir":"tests"},{"name":"Math.cosh","suites":[],"line":2,"code":"QUnit.test('Math.cosh', assert => {\n  assert.isFunction(cosh);\n  assert.same(cosh(NaN), NaN);\n  assert.same(cosh(0), 1);\n  assert.same(cosh(-0), 1);\n  assert.same(cosh(Infinity), Infinity);\n  assert.same(cosh(-Infinity), Infinity);\n  assert.epsilon(cosh(12), 81377.395712574, 1e-9);\n  assert.epsilon(cosh(22), 1792456423.065795780980053377, 1e-5);\n  assert.epsilon(cosh(-10), 11013.23292010332313972137);\n  assert.epsilon(cosh(-23), 4872401723.1244513000, 1e-5);\n  assert.epsilon(cosh(710), 1.1169973830808557e+308, 1e+295);\n});","file":"pure/es.math.cosh.js","skipped":false,"dir":"tests"},{"name":"Math.expm1","suites":[],"line":2,"code":"QUnit.test('Math.expm1', assert => {\n  assert.isFunction(expm1);\n  assert.same(expm1(NaN), NaN);\n  assert.same(expm1(0), 0);\n  assert.same(expm1(-0), -0);\n  assert.same(expm1(Infinity), Infinity);\n  assert.same(expm1(-Infinity), -1);\n  assert.epsilon(expm1(10), 22025.465794806718);\n  assert.epsilon(expm1(-10), -0.9999546000702375);\n});","file":"pure/es.math.expm1.js","skipped":false,"dir":"tests"},{"name":"Math.fround","suites":[],"line":2,"code":"QUnit.test('Math.fround', assert => {\n  assert.isFunction(fround);\n  assert.same(fround(undefined), NaN);\n  assert.same(fround(NaN), NaN);\n  assert.same(fround(0), 0);\n  assert.same(fround(-0), -0);\n  assert.same(fround(Number.MIN_VALUE), 0);\n  assert.same(fround(-Number.MIN_VALUE), -0);\n  assert.same(fround(Infinity), Infinity);\n  assert.same(fround(-Infinity), -Infinity);\n  assert.same(fround(1.7976931348623157e+308), Infinity);\n  assert.same(fround(-1.7976931348623157e+308), -Infinity);\n  assert.same(fround(3.4028235677973366e+38), Infinity);\n  assert.same(fround(3), 3);\n  assert.same(fround(-3), -3);\n  const maxFloat32 = 3.4028234663852886e+38;\n  const minFloat32 = 1.401298464324817e-45;\n  assert.same(fround(maxFloat32), maxFloat32);\n  assert.same(fround(-maxFloat32), -maxFloat32);\n  assert.same(fround(maxFloat32 + 2 ** 102), maxFloat32);\n  assert.same(fround(minFloat32), minFloat32);\n  assert.same(fround(-minFloat32), -minFloat32);\n  assert.same(fround(minFloat32 / 2), 0);\n  assert.same(fround(-minFloat32 / 2), -0);\n  assert.same(fround(minFloat32 / 2 + 2 ** -202), minFloat32);\n  assert.same(fround(-minFloat32 / 2 - 2 ** -202), -minFloat32);\n  const maxSubnormal32 = 1.1754942106924411e-38;\n  const minNormal32 = 1.1754943508222875e-38;\n  assert.same(fround(1.1754942807573642e-38), maxSubnormal32, 'fround(1.1754942807573642e-38)');\n  assert.same(fround(1.1754942807573643e-38), minNormal32, 'fround(1.1754942807573643e-38)');\n  assert.same(fround(1.1754942807573644e-38), minNormal32, 'fround(1.1754942807573644e-38)');\n  assert.same(fround(-1.1754942807573642e-38), -maxSubnormal32, 'fround(-1.1754942807573642e-38)');\n  assert.same(fround(-1.1754942807573643e-38), -minNormal32, 'fround(-1.1754942807573643e-38)');\n  assert.same(fround(-1.1754942807573644e-38), -minNormal32, 'fround(-1.1754942807573644e-38)');\n});","file":"pure/es.math.fround.js","skipped":false,"dir":"tests"},{"name":"Math.hypot","suites":[],"line":2,"code":"QUnit.test('Math.hypot', assert => {\n  const {\n    sqrt\n  } = Math;\n  assert.isFunction(hypot);\n  assert.same(hypot(), 0);\n  assert.same(hypot(1), 1);\n  assert.same(hypot('', 0), 0);\n  assert.same(hypot(0, ''), 0);\n  assert.same(hypot(Infinity, 0), Infinity, 'Infinity, 0');\n  assert.same(hypot(-Infinity, 0), Infinity, '-Infinity, 0');\n  assert.same(hypot(0, Infinity), Infinity, '0, Infinity');\n  assert.same(hypot(0, -Infinity), Infinity, '0, -Infinity');\n  assert.same(hypot(Infinity, NaN), Infinity, 'Infinity, NaN');\n  assert.same(hypot(NaN, -Infinity), Infinity, 'NaN, -Infinity');\n  assert.same(hypot(NaN, 0), NaN, 'NaN, 0');\n  assert.same(hypot(0, NaN), NaN, '0, NaN');\n  assert.same(hypot(0, -0), 0);\n  assert.same(hypot(0, 0), 0);\n  assert.same(hypot(-0, -0), 0);\n  assert.same(hypot(-0, 0), 0);\n  assert.same(hypot(0, 1), 1);\n  assert.same(hypot(0, -1), 1);\n  assert.same(hypot(-0, 1), 1);\n  assert.same(hypot(-0, -1), 1);\n  assert.same(hypot(0), 0);\n  assert.same(hypot(1), 1);\n  assert.same(hypot(2), 2);\n  assert.same(hypot(0, 0, 1), 1);\n  assert.same(hypot(0, 1, 0), 1);\n  assert.same(hypot(1, 0, 0), 1);\n  assert.same(hypot(2, 3, 4), sqrt(2 * 2 + 3 * 3 + 4 * 4));\n  assert.same(hypot(2, 3, 4, 5), sqrt(2 * 2 + 3 * 3 + 4 * 4 + 5 * 5));\n  assert.epsilon(hypot(66, 66), 93.33809511662427);\n  assert.epsilon(hypot(0.1, 100), 100.0000499999875);\n  assert.same(hypot(1e+300, 1e+300), 1.4142135623730952e+300);\n  assert.same(Math.floor(hypot(1e-300, 1e-300) * 1e308), 141421356);\n  assert.same(hypot(1e+300, 1e+300, 2, 3), 1.4142135623730952e+300);\n  assert.same(hypot(-3, 4), 5);\n  assert.same(hypot(3, -4), 5);\n});","file":"pure/es.math.hypot.js","skipped":false,"dir":"tests"},{"name":"Math.imul","suites":[],"line":2,"code":"QUnit.test('Math.imul', assert => {\n  assert.isFunction(imul);\n  assert.same(imul(0, 0), 0);\n  assert.same(imul(123, 456), 56088);\n  assert.same(imul(-123, 456), -56088);\n  assert.same(imul(123, -456), -56088);\n  assert.same(imul(19088743, 4275878552), 602016552);\n  assert.same(imul(false, 7), 0);\n  assert.same(imul(7, false), 0);\n  assert.same(imul(false, false), 0);\n  assert.same(imul(true, 7), 7);\n  assert.same(imul(7, true), 7);\n  assert.same(imul(true, true), 1);\n  assert.same(imul(undefined, 7), 0);\n  assert.same(imul(7, undefined), 0);\n  assert.same(imul(undefined, undefined), 0);\n  assert.same(imul('str', 7), 0);\n  assert.same(imul(7, 'str'), 0);\n  assert.same(imul({}, 7), 0);\n  assert.same(imul(7, {}), 0);\n  assert.same(imul([], 7), 0);\n  assert.same(imul(7, []), 0);\n  assert.same(imul(0xFFFFFFFF, 5), -5);\n  assert.same(imul(0xFFFFFFFE, 5), -10);\n  assert.same(imul(2, 4), 8);\n  assert.same(imul(-1, 8), -8);\n  assert.same(imul(-2, -2), 4);\n  assert.same(imul(-0, 7), 0);\n  assert.same(imul(7, -0), 0);\n  assert.same(imul(0.1, 7), 0);\n  assert.same(imul(7, 0.1), 0);\n  assert.same(imul(0.9, 7), 0);\n  assert.same(imul(7, 0.9), 0);\n  assert.same(imul(1.1, 7), 7);\n  assert.same(imul(7, 1.1), 7);\n  assert.same(imul(1.9, 7), 7);\n  assert.same(imul(7, 1.9), 7);\n});","file":"pure/es.math.imul.js","skipped":false,"dir":"tests"},{"name":"Math.log10","suites":[],"line":2,"code":"QUnit.test('Math.log10', assert => {\n  assert.isFunction(log10);\n  assert.same(log10(''), log10(0));\n  assert.same(log10(NaN), NaN);\n  assert.same(log10(-1), NaN);\n  assert.same(log10(0), -Infinity);\n  assert.same(log10(-0), -Infinity);\n  assert.same(log10(1), 0);\n  assert.same(log10(Infinity), Infinity);\n  assert.epsilon(log10(0.1), -1);\n  assert.epsilon(log10(0.5), -0.3010299956639812);\n  assert.epsilon(log10(1.5), 0.17609125905568124);\n  assert.epsilon(log10(5), 0.6989700043360189);\n  assert.epsilon(log10(50), 1.6989700043360187);\n  assert.epsilon(log10(1000), 3);\n});","file":"pure/es.math.log10.js","skipped":false,"dir":"tests"},{"name":"Math.log1p","suites":[],"line":2,"code":"QUnit.test('Math.log1p', assert => {\n  assert.isFunction(log1p);\n  assert.same(log1p(''), log1p(0));\n  assert.same(log1p(NaN), NaN);\n  assert.same(log1p(-2), NaN);\n  assert.same(log1p(-1), -Infinity);\n  assert.same(log1p(0), 0);\n  assert.same(log1p(-0), -0);\n  assert.same(log1p(Infinity), Infinity);\n  assert.epsilon(log1p(5), 1.791759469228055);\n  assert.epsilon(log1p(50), 3.9318256327243257);\n});","file":"pure/es.math.log1p.js","skipped":false,"dir":"tests"},{"name":"Math.log2","suites":[],"line":2,"code":"QUnit.test('Math.log2', assert => {\n  assert.isFunction(log2);\n  assert.same(log2(''), log2(0));\n  assert.same(log2(NaN), NaN);\n  assert.same(log2(-1), NaN);\n  assert.same(log2(0), -Infinity);\n  assert.same(log2(-0), -Infinity);\n  assert.same(log2(1), 0);\n  assert.same(log2(Infinity), Infinity);\n  assert.same(log2(0.5), -1);\n  assert.same(log2(32), 5);\n  assert.epsilon(log2(5), 2.321928094887362);\n});","file":"pure/es.math.log2.js","skipped":false,"dir":"tests"},{"name":"Math.sign","suites":[],"line":2,"code":"QUnit.test('Math.sign', assert => {\n  assert.isFunction(sign);\n  assert.same(sign(NaN), NaN);\n  assert.same(sign(), NaN);\n  assert.same(sign(-0), -0);\n  assert.same(sign(0), 0);\n  assert.same(sign(Infinity), 1);\n  assert.same(sign(-Infinity), -1);\n  assert.same(sign(13510798882111488), 1);\n  assert.same(sign(-13510798882111488), -1);\n  assert.same(sign(42.5), 1);\n  assert.same(sign(-42.5), -1);\n});","file":"pure/es.math.sign.js","skipped":false,"dir":"tests"},{"name":"Math.sinh","suites":[],"line":2,"code":"QUnit.test('Math.sinh', assert => {\n  assert.isFunction(sinh);\n  assert.same(sinh(NaN), NaN);\n  assert.same(sinh(0), 0);\n  assert.same(sinh(-0), -0);\n  assert.same(sinh(Infinity), Infinity);\n  assert.same(sinh(-Infinity), -Infinity);\n  assert.epsilon(sinh(-5), -74.20321057778875);\n  assert.epsilon(sinh(2), 3.6268604078470186);\n  assert.same(sinh(-2e-17), -2e-17);\n});","file":"pure/es.math.sinh.js","skipped":false,"dir":"tests"},{"name":"Math.tanh","suites":[],"line":2,"code":"QUnit.test('Math.tanh', assert => {\n  assert.isFunction(tanh);\n  assert.same(tanh(NaN), NaN);\n  assert.same(tanh(0), 0);\n  assert.same(tanh(-0), -0);\n  assert.same(tanh(Infinity), 1);\n  assert.same(tanh(90), 1);\n  assert.epsilon(tanh(10), 0.9999999958776927);\n});","file":"pure/es.math.tanh.js","skipped":false,"dir":"tests"},{"name":"Math.trunc","suites":[],"line":2,"code":"QUnit.test('Math.trunc', assert => {\n  assert.isFunction(trunc);\n  assert.same(trunc(NaN), NaN, 'NaN -> NaN');\n  assert.same(trunc(-0), -0, '-0 -> -0');\n  assert.same(trunc(0), 0, '0 -> 0');\n  assert.same(trunc(Infinity), Infinity, 'Infinity -> Infinity');\n  assert.same(trunc(-Infinity), -Infinity, '-Infinity -> -Infinity');\n  assert.same(trunc(null), 0, 'null -> 0');\n  assert.same(trunc({}), NaN, '{} -> NaN');\n  assert.same(trunc([]), 0, '[] -> 0');\n  assert.same(trunc(1.01), 1, '1.01 -> 0');\n  assert.same(trunc(1.99), 1, '1.99 -> 0');\n  assert.same(trunc(-1), -1, '-1 -> -1');\n  assert.same(trunc(-1.99), -1, '-1.99 -> -1');\n  assert.same(trunc(-555.555), -555, '-555.555 -> -555');\n  assert.same(trunc(0x20000000000001), 0x20000000000001, '0x20000000000001 -> 0x20000000000001');\n  assert.same(trunc(-0x20000000000001), -0x20000000000001, '-0x20000000000001 -> -0x20000000000001');\n});","file":"pure/es.math.trunc.js","skipped":false,"dir":"tests"},{"name":"Number.EPSILON","suites":[],"line":2,"code":"QUnit.test('Number.EPSILON', assert => {\n  assert.same(EPSILON, 2 ** -52, 'Is 2^-52');\n  assert.notSame(1, 1 + EPSILON, '1 isnt 1 + EPSILON');\n  assert.same(1, 1 + EPSILON / 2, '1 is 1 + EPSILON / 2');\n});","file":"pure/es.number.epsilon.js","skipped":false,"dir":"tests"},{"name":"Number.isFinite","suites":[],"line":3,"code":"QUnit.test('Number.isFinite', assert => {\n  assert.isFunction(isFinite);\n  const finite = [1, 0.1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0];\n\n  for (const value of finite) {\n    assert.true(isFinite(value), `isFinite ${typeof value} ${value}`);\n  }\n\n  const notFinite = [NaN, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notFinite) {\n    assert.false(isFinite(value), `not isFinite ${typeof value} ${value}`);\n  }\n\n  assert.false(isFinite(create(null)), 'Number.isFinite(Object.create(null)) -> false');\n});","file":"pure/es.number.is-finite.js","skipped":false,"dir":"tests"},{"name":"Number.isInteger","suites":[],"line":3,"code":"QUnit.test('Number.isInteger', assert => {\n  assert.isFunction(isInteger);\n  const integers = [1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0];\n\n  for (const value of integers) {\n    assert.true(isInteger(value), `isInteger ${typeof value} ${value}`);\n  }\n\n  const notIntegers = [NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notIntegers) {\n    assert.false(isInteger(value), `not isInteger ${typeof value} ${value}`);\n  }\n\n  assert.false(isInteger(create(null)), 'Number.isInteger(Object.create(null)) -> false');\n});","file":"pure/es.number.is-integer.js","skipped":false,"dir":"tests"},{"name":"Number.isNaN","suites":[],"line":3,"code":"QUnit.test('Number.isNaN', assert => {\n  assert.isFunction(isNaN);\n  assert.true(isNaN(NaN), 'Number.isNaN NaN');\n  const notNaNs = [1, 0.1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notNaNs) {\n    assert.false(isNaN(value), `not Number.isNaN ${typeof value} ${value}`);\n  }\n\n  assert.false(isNaN(create(null)), 'Number.isNaN(Object.create(null)) -> false');\n});","file":"pure/es.number.is-nan.js","skipped":false,"dir":"tests"},{"name":"Number.isSafeInteger","suites":[],"line":3,"code":"QUnit.test('Number.isSafeInteger', assert => {\n  assert.isFunction(isSafeInteger);\n  const safeIntegers = [1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0, 9007199254740991, -9007199254740991];\n\n  for (const value of safeIntegers) {\n    assert.true(isSafeInteger(value), `isSafeInteger ${typeof value} ${value}`);\n  }\n\n  const notSafeIntegers = [9007199254740992, -9007199254740992, NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notSafeIntegers) {\n    assert.false(isSafeInteger(value), `not isSafeInteger ${typeof value} ${value}`);\n  }\n\n  assert.false(isSafeInteger(create(null)), 'Number.isSafeInteger(Object.create(null)) -> false');\n});","file":"pure/es.number.is-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.MAX_SAFE_INTEGER","suites":[],"line":2,"code":"QUnit.test('Number.MAX_SAFE_INTEGER', assert => {\n  assert.same(MAX_SAFE_INTEGER, 2 ** 53 - 1, 'Is 2^53 - 1');\n});","file":"pure/es.number.max-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.MIN_SAFE_INTEGER","suites":[],"line":2,"code":"QUnit.test('Number.MIN_SAFE_INTEGER', assert => {\n  assert.same(MIN_SAFE_INTEGER, -(2 ** 53) + 1, 'Is -2^53 + 1');\n});","file":"pure/es.number.min-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.parseFloat","suites":[],"line":3,"code":"QUnit.test('Number.parseFloat', assert => {\n  assert.isFunction(parseFloat);\n  assert.arity(parseFloat, 1);\n  assert.same(parseFloat('0'), 0);\n  assert.same(parseFloat(' 0'), 0);\n  assert.same(parseFloat('+0'), 0);\n  assert.same(parseFloat(' +0'), 0);\n  assert.same(parseFloat('-0'), -0);\n  assert.same(parseFloat(' -0'), -0);\n  assert.same(parseFloat(`${WHITESPACES}+0`), 0);\n  assert.same(parseFloat(`${WHITESPACES}-0`), -0);\n  assert.same(parseFloat(null), NaN);\n  assert.same(parseFloat(undefined), NaN);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => parseFloat(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseFloat(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"pure/es.number.parse-float.js","skipped":false,"dir":"tests"},{"name":"Number.parseInt","suites":[],"line":3,"code":"QUnit.test('Number.parseInt', assert => {\n  assert.isFunction(parseInt);\n  assert.arity(parseInt, 2);\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(parseInt('10', radix), radix, `radix ${radix}`);\n  }\n\n  const strings = ['01', '08', '10', '42'];\n\n  for (const string of strings) {\n    assert.same(parseInt(string), parseInt(string, 10), `default radix is 10: ${string}`);\n  }\n\n  assert.same(parseInt('0x16'), parseInt('0x16', 16), 'default radix is 16: 0x16');\n  assert.same(parseInt('  0x16'), parseInt('0x16', 16), 'ignores leading whitespace #1');\n  assert.same(parseInt('  42'), parseInt('42', 10), 'ignores leading whitespace #2');\n  assert.same(parseInt('  08'), parseInt('08', 10), 'ignores leading whitespace #3');\n  assert.same(parseInt(`${WHITESPACES}08`), parseInt('08', 10), 'ignores leading whitespace #4');\n  assert.same(parseInt(`${WHITESPACES}0x16`), parseInt('0x16', 16), 'ignores leading whitespace #5');\n  const fakeZero = {\n    valueOf() {\n      return 0;\n    }\n\n  };\n  assert.same(parseInt('08', fakeZero), parseInt('08', 10), 'valueOf #1');\n  assert.same(parseInt('0x16', fakeZero), parseInt('0x16', 16), 'valueOf #2');\n  assert.same(parseInt('-0xF'), -15, 'signed hex #1');\n  assert.same(parseInt('-0xF', 16), -15, 'signed hex #2');\n  assert.same(parseInt('+0xF'), 15, 'signed hex #3');\n  assert.same(parseInt('+0xF', 16), 15, 'signed hex #4');\n  assert.same(parseInt('10', -4294967294), 2, 'radix uses ToUint32');\n  assert.same(parseInt(null), NaN);\n  assert.same(parseInt(undefined), NaN);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => parseInt(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseInt(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"pure/es.number.parse-int.js","skipped":false,"dir":"tests"},{"name":"Number#toExponential","suites":[],"line":2,"code":"QUnit.test('Number#toExponential', assert => {\n  assert.isFunction(toExponential);\n  assert.same(toExponential.call(0.00008, 3), '8.000e-5');\n  assert.same(toExponential.call(0.9, 0), '9e-1');\n  assert.same(toExponential.call(1.255, 2), '1.25e+0');\n  assert.same(toExponential.call(1843654265.0774949, 5), '1.84365e+9');\n  assert.same(toExponential.call(1000000000000000128.0, 0), '1e+18');\n  assert.same(toExponential.call(1), '1e+0');\n  assert.same(toExponential.call(1, 0), '1e+0');\n  assert.same(toExponential.call(1, 1), '1.0e+0');\n  assert.same(toExponential.call(1, 1.1), '1.0e+0');\n  assert.same(toExponential.call(1, 0.9), '1e+0');\n  assert.same(toExponential.call(1, '0'), '1e+0');\n  assert.same(toExponential.call(1, '1'), '1.0e+0');\n  assert.same(toExponential.call(1, '1.1'), '1.0e+0');\n  assert.same(toExponential.call(1, '0.9'), '1e+0');\n  assert.same(toExponential.call(1, NaN), '1e+0');\n  assert.same(toExponential.call(1, 'some string'), '1e+0');\n  assert.notThrows(() => toExponential.call(1, -0.1) === '1e+0');\n  assert.same(toExponential.call(new Number(1)), '1e+0');\n  assert.same(toExponential.call(new Number(1), 0), '1e+0');\n  assert.same(toExponential.call(new Number(1), 1), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), 1.1), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), 0.9), '1e+0');\n  assert.same(toExponential.call(new Number(1), '0'), '1e+0');\n  assert.same(toExponential.call(new Number(1), '1'), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), '1.1'), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), '0.9'), '1e+0');\n  assert.same(toExponential.call(new Number(1), NaN), '1e+0');\n  assert.same(toExponential.call(new Number(1), 'some string'), '1e+0');\n  assert.notThrows(() => toExponential.call(new Number(1), -0.1) === '1e+0');\n  assert.same(toExponential.call(NaN), 'NaN');\n  assert.same(toExponential.call(NaN, 0), 'NaN');\n  assert.same(toExponential.call(NaN, 1), 'NaN');\n  assert.same(toExponential.call(NaN, 1.1), 'NaN');\n  assert.same(toExponential.call(NaN, 0.9), 'NaN');\n  assert.same(toExponential.call(NaN, '0'), 'NaN');\n  assert.same(toExponential.call(NaN, '1'), 'NaN');\n  assert.same(toExponential.call(NaN, '1.1'), 'NaN');\n  assert.same(toExponential.call(NaN, '0.9'), 'NaN');\n  assert.same(toExponential.call(NaN, NaN), 'NaN');\n  assert.same(toExponential.call(NaN, 'some string'), 'NaN');\n  assert.notThrows(() => toExponential.call(NaN, -0.1) === 'NaN');\n  assert.same(toExponential.call(new Number(1e21)), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 0), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 1), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), 1.1), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), 0.9), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), '0'), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), '1'), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), '1.1'), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), '0.9'), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), NaN), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 'some string'), '1e+21');\n  assert.same(toExponential.call(5, 19), '5.0000000000000000000e+0'); // ported from tests262, the license: https://github.com/tc39/test262/blob/main/LICENSE\n\n  assert.same(toExponential.call(123.456, 0), '1e+2');\n  assert.same(toExponential.call(123.456, 1), '1.2e+2');\n  assert.same(toExponential.call(123.456, 2), '1.23e+2');\n  assert.same(toExponential.call(123.456, 3), '1.235e+2');\n  assert.same(toExponential.call(123.456, 4), '1.2346e+2');\n  assert.same(toExponential.call(123.456, 5), '1.23456e+2');\n  assert.same(toExponential.call(123.456, 6), '1.234560e+2');\n  assert.same(toExponential.call(123.456, 7), '1.2345600e+2'); // assert.same(toExponential.call(123.456, 17), '1.23456000000000003e+2');\n  // assert.same(toExponential.call(123.456, 20), '1.23456000000000003070e+2');\n\n  assert.same(toExponential.call(-123.456, 0), '-1e+2');\n  assert.same(toExponential.call(-123.456, 1), '-1.2e+2');\n  assert.same(toExponential.call(-123.456, 2), '-1.23e+2');\n  assert.same(toExponential.call(-123.456, 3), '-1.235e+2');\n  assert.same(toExponential.call(-123.456, 4), '-1.2346e+2');\n  assert.same(toExponential.call(-123.456, 5), '-1.23456e+2');\n  assert.same(toExponential.call(-123.456, 6), '-1.234560e+2');\n  assert.same(toExponential.call(-123.456, 7), '-1.2345600e+2'); // assert.same(toExponential.call(-123.456, 17), '-1.23456000000000003e+2');\n  // assert.same(toExponential.call(-123.456, 20), '-1.23456000000000003070e+2');\n\n  assert.same(toExponential.call(0.0001, 0), '1e-4');\n  assert.same(toExponential.call(0.0001, 1), '1.0e-4');\n  assert.same(toExponential.call(0.0001, 2), '1.00e-4');\n  assert.same(toExponential.call(0.0001, 3), '1.000e-4');\n  assert.same(toExponential.call(0.0001, 4), '1.0000e-4'); // assert.same(toExponential.call(0.0001, 16), '1.0000000000000000e-4');\n  // assert.same(toExponential.call(0.0001, 17), '1.00000000000000005e-4');\n  // assert.same(toExponential.call(0.0001, 18), '1.000000000000000048e-4');\n  // assert.same(toExponential.call(0.0001, 19), '1.0000000000000000479e-4');\n  // assert.same(toExponential.call(0.0001, 20), '1.00000000000000004792e-4');\n\n  assert.same(toExponential.call(0.9999, 0), '1e+0');\n  assert.same(toExponential.call(0.9999, 1), '1.0e+0');\n  assert.same(toExponential.call(0.9999, 2), '1.00e+0');\n  assert.same(toExponential.call(0.9999, 3), '9.999e-1');\n  assert.same(toExponential.call(0.9999, 4), '9.9990e-1'); // assert.same(toExponential.call(0.9999, 16), '9.9990000000000001e-1');\n  // assert.same(toExponential.call(0.9999, 17), '9.99900000000000011e-1');\n  // assert.same(toExponential.call(0.9999, 18), '9.999000000000000110e-1');\n  // assert.same(toExponential.call(0.9999, 19), '9.9990000000000001101e-1');\n  // assert.same(toExponential.call(0.9999, 20), '9.99900000000000011013e-1');\n\n  assert.same(toExponential.call(25, 0), '3e+1'); // FF86- and Chrome 49-50 bugs\n\n  assert.same(toExponential.call(12345, 3), '1.235e+4'); // FF86- and Chrome 49-50 bugs\n\n  assert.same(toExponential.call(Number.prototype, 0), '0e+0', 'Number.prototype, 0');\n  assert.same(toExponential.call(0, 0), '0e+0', '0, 0');\n  assert.same(toExponential.call(-0, 0), '0e+0', '-0, 0');\n  assert.same(toExponential.call(0, -0), '0e+0', '0, -0');\n  assert.same(toExponential.call(-0, -0), '0e+0', '-0, -0');\n  assert.same(toExponential.call(0, 1), '0.0e+0', '0 and 1');\n  assert.same(toExponential.call(0, 2), '0.00e+0', '0 and 2');\n  assert.same(toExponential.call(0, 7), '0.0000000e+0', '0 and 7');\n  assert.same(toExponential.call(0, 20), '0.00000000000000000000e+0', '0 and 20');\n  assert.same(toExponential.call(-0, 1), '0.0e+0', '-0 and 1');\n  assert.same(toExponential.call(-0, 2), '0.00e+0', '-0 and 2');\n  assert.same(toExponential.call(-0, 7), '0.0000000e+0', '-0 and 7');\n  assert.same(toExponential.call(-0, 20), '0.00000000000000000000e+0', '-0 and 20');\n  assert.same(toExponential.call(NaN, 1000), 'NaN', 'NaN check before fractionDigits check');\n  assert.same(toExponential.call(Infinity, 1000), 'Infinity', 'Infinity check before fractionDigits check');\n  assert.notThrows(() => toExponential.call(new Number(1e21), -0.1) === '1e+21');\n  assert.throws(() => toExponential.call(1.0, -101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toExponential.call(1.0, 101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toExponential.call({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"pure/es.number.to-exponential.js","skipped":false,"dir":"tests"},{"name":"Number#toFixed","suites":[],"line":2,"code":"QUnit.test('Number#toFixed', assert => {\n  assert.isFunction(toFixed);\n  assert.same(toFixed(0.00008, 3), '0.000');\n  assert.same(toFixed(0.9, 0), '1');\n  assert.same(toFixed(1.255, 2), '1.25');\n  assert.same(toFixed(1843654265.0774949, 5), '1843654265.07749');\n  assert.same(toFixed(1000000000000000128, 0), '1000000000000000128');\n  assert.same(toFixed(1), '1');\n  assert.same(toFixed(1, 0), '1');\n  assert.same(toFixed(1, 1), '1.0');\n  assert.same(toFixed(1, 1.1), '1.0');\n  assert.same(toFixed(1, 0.9), '1');\n  assert.same(toFixed(1, '0'), '1');\n  assert.same(toFixed(1, '1'), '1.0');\n  assert.same(toFixed(1, '1.1'), '1.0');\n  assert.same(toFixed(1, '0.9'), '1');\n  assert.same(toFixed(1, NaN), '1');\n  assert.same(toFixed(1, 'some string'), '1');\n  assert.notThrows(() => toFixed(1, -0.1) === '1');\n  assert.same(toFixed(Object(1)), '1');\n  assert.same(toFixed(Object(1), 0), '1');\n  assert.same(toFixed(Object(1), 1), '1.0');\n  assert.same(toFixed(Object(1), 1.1), '1.0');\n  assert.same(toFixed(Object(1), 0.9), '1');\n  assert.same(toFixed(Object(1), '0'), '1');\n  assert.same(toFixed(Object(1), '1'), '1.0');\n  assert.same(toFixed(Object(1), '1.1'), '1.0');\n  assert.same(toFixed(Object(1), '0.9'), '1');\n  assert.same(toFixed(Object(1), NaN), '1');\n  assert.same(toFixed(Object(1), 'some string'), '1');\n  assert.notThrows(() => toFixed(Object(1), -0.1) === '1');\n  assert.same(toFixed(NaN), 'NaN');\n  assert.same(toFixed(NaN, 0), 'NaN');\n  assert.same(toFixed(NaN, 1), 'NaN');\n  assert.same(toFixed(NaN, 1.1), 'NaN');\n  assert.same(toFixed(NaN, 0.9), 'NaN');\n  assert.same(toFixed(NaN, '0'), 'NaN');\n  assert.same(toFixed(NaN, '1'), 'NaN');\n  assert.same(toFixed(NaN, '1.1'), 'NaN');\n  assert.same(toFixed(NaN, '0.9'), 'NaN');\n  assert.same(toFixed(NaN, NaN), 'NaN');\n  assert.same(toFixed(NaN, 'some string'), 'NaN');\n  assert.notThrows(() => toFixed(NaN, -0.1) === 'NaN');\n  assert.same(toFixed(1e21), String(1e21));\n  assert.same(toFixed(1e21, 0), String(1e21));\n  assert.same(toFixed(1e21, 1), String(1e21));\n  assert.same(toFixed(1e21, 1.1), String(1e21));\n  assert.same(toFixed(1e21, 0.9), String(1e21));\n  assert.same(toFixed(1e21, '0'), String(1e21));\n  assert.same(toFixed(1e21, '1'), String(1e21));\n  assert.same(toFixed(1e21, '1.1'), String(1e21));\n  assert.same(toFixed(1e21, '0.9'), String(1e21));\n  assert.same(toFixed(1e21, NaN), String(1e21));\n  assert.same(toFixed(1e21, 'some string'), String(1e21));\n  assert.notThrows(() => toFixed(1e21, -0.1) === String(1e21));\n  assert.throws(() => toFixed(1, -101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toFixed(1, 101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toFixed(NaN, Infinity), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toFixed({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"pure/es.number.to-fixed.js","skipped":false,"dir":"tests"},{"name":"Number#toPrecision","suites":[],"line":2,"code":"QUnit.test('Number#toPrecision', assert => {\n  assert.isFunction(toPrecision);\n  assert.same(toPrecision(0.00008, 3), '0.0000800', '0.00008.toPrecision(3)');\n  assert.same(toPrecision(1.255, 2), '1.3', '1.255.toPrecision(2)');\n  assert.same(toPrecision(1843654265.0774949, 13), '1843654265.077', '1843654265.0774949.toPrecision(13)');\n  assert.same(toPrecision(NaN, 1), 'NaN', 'If x is NaN, return the String \"NaN\".');\n  assert.same(toPrecision(123.456), '123.456', 'If precision is undefined, return ! ToString(x).');\n  assert.same(toPrecision(123.456, undefined), '123.456', 'If precision is undefined, return ! ToString(x).');\n  assert.throws(() => toPrecision(0.9, 0), RangeError, 'If p < 1 or p > 21, throw a RangeError exception.');\n  assert.throws(() => toPrecision(0.9, 101), RangeError, 'If p < 1 or p > 21, throw a RangeError exception.');\n  assert.throws(() => toPrecision({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"pure/es.number.to-precision.js","skipped":false,"dir":"tests"},{"name":"Object.assign","suites":[],"line":6,"code":"QUnit.test('Object.assign', assert => {\n  assert.isFunction(assign);\n  let object = {\n    q: 1\n  };\n  assert.same(object, assign(object, {\n    bar: 2\n  }), 'assign return target');\n  assert.same(object.bar, 2, 'assign define properties');\n  assert.deepEqual(assign({}, {\n    q: 1\n  }, {\n    w: 2\n  }), {\n    q: 1,\n    w: 2\n  });\n  assert.deepEqual(assign({}, 'qwe'), {\n    0: 'q',\n    1: 'w',\n    2: 'e'\n  });\n  assert.throws(() => assign(null, {\n    q: 1\n  }), TypeError);\n  assert.throws(() => assign(undefined, {\n    q: 1\n  }), TypeError);\n  let string = assign('qwe', {\n    q: 1\n  });\n  assert.same(typeof string, 'object');\n  assert.same(String(string), 'qwe');\n  assert.same(string.q, 1);\n  assert.same(assign({}, {\n    valueOf: 42\n  }).valueOf, 42, 'IE enum keys bug');\n\n  if (DESCRIPTORS) {\n    object = {\n      baz: 1\n    };\n    assign(object, defineProperty({}, 'bar', {\n      get() {\n        return this.baz + 1;\n      }\n\n    }));\n    assert.same(object.bar, undefined, \"assign don't copy descriptors\");\n    object = {\n      a: 'a'\n    };\n    const c = Symbol('c');\n    const d = Symbol('d');\n    object[c] = 'c';\n    defineProperty(object, 'b', {\n      value: 'b'\n    });\n    defineProperty(object, d, {\n      value: 'd'\n    });\n    const object2 = assign({}, object);\n    assert.same(object2.a, 'a', 'a');\n    assert.same(object2.b, undefined, 'b');\n    assert.same(object2[c], 'c', 'c');\n    assert.same(object2[d], undefined, 'd');\n\n    try {\n      assert.same(Function('assign', `\n        return assign({ b: 1 }, { get a() {\n          delete this.b;\n        }, b: 2 });\n      `)(assign).b, 1);\n    } catch {\n      /* empty */\n    }\n\n    try {\n      assert.same(Function('assign', `\n        return assign({ b: 1 }, { get a() {\n          Object.defineProperty(this, \"b\", {\n            value: 4,\n            enumerable: false\n          });\n        }, b: 2 });\n      `)(assign).b, 1);\n    } catch {\n      /* empty */\n    }\n  }\n\n  string = 'abcdefghijklmnopqrst';\n  const result = {};\n\n  for (let i = 0, {\n    length\n  } = string; i < length; ++i) {\n    const chr = string.charAt(i);\n    result[chr] = chr;\n  }\n\n  assert.same(keys(assign({}, result)).join(''), string);\n});","file":"pure/es.object.assign.js","skipped":false,"dir":"tests"},{"name":"Object.create","suites":[],"line":5,"code":"QUnit.test('Object.create', assert => {\n  function getPropertyNames(object) {\n    let result = [];\n\n    do {\n      result = result.concat(getOwnPropertyNames(object));\n    } while (object = getPrototypeOf(object));\n\n    return result;\n  }\n\n  assert.isFunction(create);\n  assert.arity(create, 2);\n  let object = {\n    q: 1\n  };\n  assert.true({}.isPrototypeOf.call(object, create(object)));\n  assert.same(create(object).q, 1);\n\n  function C() {\n    return this.a = 1;\n  }\n\n  assert.true(create(new C()) instanceof C);\n  assert.same(C.prototype, getPrototypeOf(getPrototypeOf(create(new C()))));\n  assert.same(create(new C()).a, 1);\n  assert.same(create({}, {\n    a: {\n      value: 42\n    }\n  }).a, 42);\n  object = create(null, {\n    w: {\n      value: 2\n    }\n  });\n  assert.same(object, Object(object));\n  assert.false('toString' in object);\n  assert.same(object.w, 2);\n  assert.deepEqual(getPropertyNames(create(null)), []);\n});","file":"pure/es.object.create.js","skipped":false,"dir":"tests"},{"name":"Object.create.sham flag","suites":[],"line":46,"code":"QUnit.test('Object.create.sham flag', assert => {\n  assert.same(create.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.object.create.js","skipped":false,"dir":"tests"},{"name":"Object#__defineGetter__","suites":[],"line":6,"code":"  QUnit.test('Object#__defineGetter__', assert => {\n    assert.isFunction(__defineGetter__);\n    const object = {};\n    assert.same(__defineGetter__(object, 'key', () => 42), undefined, 'void');\n    assert.same(object.key, 42, 'works');\n\n    __defineSetter__(object, 'key', function () {\n      this.foo = 43;\n    });\n\n    object.key = 44;\n    assert.same(object.key, 42, 'works with setter #1');\n    assert.same(object.foo, 43, 'works with setter #2');\n\n    if (STRICT) {\n      assert.throws(() => __defineGetter__(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __defineGetter__(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"pure/es.object.define-getter.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperties","suites":[],"line":3,"code":"QUnit.test('Object.defineProperties', assert => {\n  assert.isFunction(defineProperties);\n  assert.arity(defineProperties, 2);\n  const source = {};\n  const result = defineProperties(source, {\n    q: {\n      value: 42\n    },\n    w: {\n      value: 33\n    }\n  });\n  assert.same(result, source);\n  assert.same(result.q, 42);\n  assert.same(result.w, 33);\n\n  if (DESCRIPTORS) {\n    // eslint-disable-next-line prefer-arrow-callback -- required for testing\n    assert.same(defineProperties(function () {\n      /* empty */\n    }, {\n      prototype: {\n        value: 42,\n        writable: false\n      }\n    }).prototype, 42, 'function prototype with non-writable descriptor');\n  }\n});","file":"pure/es.object.define-properties.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperties.sham flag","suites":[],"line":31,"code":"QUnit.test('Object.defineProperties.sham flag', assert => {\n  assert.same(defineProperties.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.object.define-properties.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperty","suites":[],"line":4,"code":"QUnit.test('Object.defineProperty', assert => {\n  assert.isFunction(defineProperty);\n  assert.arity(defineProperty, 3);\n  const source = {};\n  const result = defineProperty(source, 'q', {\n    value: 42\n  });\n  assert.same(result, source);\n  assert.same(result.q, 42);\n\n  if (DESCRIPTORS) {\n    // eslint-disable-next-line prefer-arrow-callback -- required for testing\n    assert.same(defineProperty(function () {\n      /* empty */\n    }, 'prototype', {\n      value: 42,\n      writable: false\n    }).prototype, 42, 'function prototype with non-writable descriptor');\n  }\n\n  assert.throws(() => defineProperty(42, 1, {}));\n  assert.throws(() => defineProperty({}, create(null), {}));\n  assert.throws(() => defineProperty({}, 1, 1));\n});","file":"pure/es.object.define-property.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperty.sham flag","suites":[],"line":28,"code":"QUnit.test('Object.defineProperty.sham flag', assert => {\n  assert.same(defineProperty.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.object.define-property.js","skipped":false,"dir":"tests"},{"name":"Object#__defineSetter__","suites":[],"line":6,"code":"  QUnit.test('Object#__defineSetter__', assert => {\n    assert.isFunction(__defineSetter__);\n    let object = {};\n    assert.same(__defineSetter__(object, 'key', function () {\n      this.foo = 43;\n    }), undefined, 'void');\n    object.key = 44;\n    assert.same(object.foo, 43, 'works');\n    object = {};\n\n    __defineSetter__(object, 'key', function () {\n      this.foo = 43;\n    });\n\n    __defineGetter__(object, 'key', () => 42);\n\n    object.key = 44;\n    assert.same(object.key, 42, 'works with getter #1');\n    assert.same(object.foo, 43, 'works with getter #2');\n\n    if (STRICT) {\n      assert.throws(() => __defineSetter__(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __defineSetter__(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"pure/es.object.define-setter.js","skipped":false,"dir":"tests"},{"name":"Object.entries","suites":[],"line":4,"code":"QUnit.test('Object.entries', assert => {\n  assert.isFunction(entries);\n  assert.arity(entries, 1);\n  assert.name(entries, 'entries');\n  assert.deepEqual(entries({\n    q: 1,\n    w: 2,\n    e: 3\n  }), [['q', 1], ['w', 2], ['e', 3]]);\n  assert.deepEqual(entries(new String('qwe')), [['0', 'q'], ['1', 'w'], ['2', 'e']]);\n  assert.deepEqual(entries(assign(create({\n    q: 1,\n    w: 2,\n    e: 3\n  }), {\n    a: 4,\n    s: 5,\n    d: 6\n  })), [['a', 4], ['s', 5], ['d', 6]]);\n  assert.deepEqual(entries({\n    valueOf: 42\n  }), [['valueOf', 42]], 'IE enum keys bug');\n\n  try {\n    assert.deepEqual(Function('entries', `\n      return entries({ a: 1, get b() {\n        delete this.c;\n        return 2;\n      }, c: 3 });\n    `)(entries), [['a', 1], ['b', 2]]);\n  } catch {\n    /* empty */\n  }\n\n  try {\n    assert.deepEqual(Function('entries', `\n      return entries({ a: 1, get b() {\n        Object.defineProperty(this, \"c\", {\n          value: 4,\n          enumerable: false\n        });\n        return 2\n      }, c: 3 });\n    `)(entries), [['a', 1], ['b', 2]]);\n  } catch {\n    /* empty */\n  }\n});","file":"pure/es.object.entries.js","skipped":false,"dir":"tests"},{"name":"Object.freeze","suites":[],"line":6,"code":"QUnit.test('Object.freeze', assert => {\n  assert.isFunction(freeze);\n  assert.arity(freeze, 1);\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => freeze(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(freeze(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  const results = [];\n\n  for (const key in freeze({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(freeze({})), []);\n  assert.arrayEqual(getOwnPropertyNames(freeze({})), []);\n  assert.arrayEqual(getOwnPropertySymbols(freeze({})), []);\n  assert.arrayEqual(ownKeys(freeze({})), []);\n});","file":"pure/es.object.freeze.js","skipped":false,"dir":"tests"},{"name":"Object.fromEntries","suites":[],"line":4,"code":"QUnit.test('Object.fromEntries', assert => {\n  assert.isFunction(fromEntries);\n  assert.arity(fromEntries, 1);\n  assert.name(fromEntries, 'fromEntries');\n  assert.true(fromEntries([]) instanceof Object);\n  assert.same(fromEntries([['foo', 1]]).foo, 1);\n  assert.same(fromEntries(createIterable([['bar', 2]])).bar, 2);\n\n  class Unit {\n    constructor(id) {\n      this.id = id;\n    }\n\n    toString() {\n      return `unit${this.id}`;\n    }\n\n  }\n\n  const units = new Set([new Unit(101), new Unit(102), new Unit(103)]);\n  const object = fromEntries(units.entries());\n  assert.same(object.unit101.id, 101);\n  assert.same(object.unit102.id, 102);\n  assert.same(object.unit103.id, 103);\n});","file":"pure/es.object.from-entries.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptor","suites":[],"line":3,"code":"QUnit.test('Object.getOwnPropertyDescriptor', assert => {\n  assert.isFunction(getOwnPropertyDescriptor);\n  assert.arity(getOwnPropertyDescriptor, 2);\n  assert.deepEqual(getOwnPropertyDescriptor({\n    q: 42\n  }, 'q'), {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value: 42\n  });\n  assert.same(getOwnPropertyDescriptor({}, 'toString'), undefined);\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertyDescriptor(value) || true, `accept ${typeof value}`);\n  }\n\n  assert.throws(() => getOwnPropertyDescriptor(null), TypeError, 'throws on null');\n  assert.throws(() => getOwnPropertyDescriptor(undefined), TypeError, 'throws on undefined');\n});","file":"pure/es.object.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptor.sham flag","suites":[],"line":24,"code":"QUnit.test('Object.getOwnPropertyDescriptor.sham flag', assert => {\n  assert.same(getOwnPropertyDescriptor.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.object.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptors","suites":[],"line":5,"code":"QUnit.test('Object.getOwnPropertyDescriptors', assert => {\n  assert.isFunction(getOwnPropertyDescriptors);\n  const object = create({\n    q: 1\n  }, {\n    e: {\n      value: 3\n    }\n  });\n  object.w = 2;\n  const symbol = Symbol('4');\n  object[symbol] = 4;\n  const descriptors = getOwnPropertyDescriptors(object);\n  assert.same(descriptors.q, undefined);\n  assert.deepEqual(descriptors.w, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 2\n  });\n\n  if (DESCRIPTORS) {\n    assert.deepEqual(descriptors.e, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: 3\n    });\n  } else {\n    assert.deepEqual(descriptors.e, {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n  }\n\n  assert.same(descriptors[symbol].value, 4);\n});","file":"pure/es.object.get-own-property-descriptors.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptors.sham flag","suites":[],"line":44,"code":"QUnit.test('Object.getOwnPropertyDescriptors.sham flag', assert => {\n  assert.same(getOwnPropertyDescriptors.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.object.get-own-property-descriptors.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyNames","suites":[],"line":5,"code":"QUnit.test('Object.getOwnPropertyNames', assert => {\n  assert.isFunction(getOwnPropertyNames);\n  assert.arity(getOwnPropertyNames, 1);\n\n  function F1() {\n    this.w = 1;\n  }\n\n  function F2() {\n    this.toString = 1;\n  }\n\n  F1.prototype.q = F2.prototype.q = 1;\n  const names = getOwnPropertyNames([1, 2, 3]);\n  assert.same(names.length, 4);\n  assert.true(includes(names, '0'));\n  assert.true(includes(names, '1'));\n  assert.true(includes(names, '2'));\n  assert.true(includes(names, 'length'));\n  assert.deepEqual(getOwnPropertyNames(new F1()), ['w']);\n  assert.deepEqual(getOwnPropertyNames(new F2()), ['toString']);\n  assert.true(includes(getOwnPropertyNames(Array.prototype), 'toString'));\n  assert.true(includes(getOwnPropertyNames(Object.prototype), 'toString'));\n  assert.true(includes(getOwnPropertyNames(Object.prototype), 'constructor'));\n  assert.deepEqual(getOwnPropertyNames(freeze({})), [], 'frozen');\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertyNames(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => getOwnPropertyNames(null), TypeError, 'throws on null');\n  assert.throws(() => getOwnPropertyNames(undefined), TypeError, 'throws on undefined');\n\n  if (GLOBAL.document) {\n    assert.notThrows(() => {\n      const iframe = document.createElement('iframe');\n      iframe.src = 'http://example.com';\n      document.documentElement.appendChild(iframe);\n      const window = iframe.contentWindow;\n      document.documentElement.removeChild(iframe);\n      return getOwnPropertyNames(window);\n    }, 'IE11 bug with iframe and window');\n  }\n});","file":"pure/es.object.get-own-property-names.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertySymbols","suites":[],"line":5,"code":"QUnit.test('Object.getOwnPropertySymbols', assert => {\n  assert.isFunction(getOwnPropertySymbols);\n  const prototype = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  prototype[Symbol()] = 42;\n  prototype[Symbol()] = 43;\n  assert.deepEqual(getOwnPropertyNames(prototype).sort(), ['e', 'q', 'w']);\n  assert.same(getOwnPropertySymbols(prototype).length, 2);\n  const object = create(prototype);\n  object.a = 1;\n  object.s = 2;\n  object.d = 3;\n  object[Symbol()] = 44;\n  assert.deepEqual(getOwnPropertyNames(object).sort(), ['a', 'd', 's']);\n  assert.same(getOwnPropertySymbols(object).length, 1);\n  assert.same(getOwnPropertySymbols(Object.prototype).length, 0);\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertySymbols(value), `accept ${typeof value}`);\n  }\n});","file":"pure/es.object.get-own-property-symbols.js","skipped":false,"dir":"tests"},{"name":"Object.getPrototypeOf","suites":[],"line":4,"code":"QUnit.test('Object.getPrototypeOf', assert => {\n  assert.isFunction(getPrototypeOf);\n  assert.arity(getPrototypeOf, 1);\n  assert.same(getPrototypeOf({}), Object.prototype);\n  assert.same(getPrototypeOf([]), Array.prototype);\n\n  function F() {\n    /* empty */\n  }\n\n  assert.same(getPrototypeOf(new F()), F.prototype);\n  const object = {\n    q: 1\n  };\n  assert.same(getPrototypeOf(create(object)), object);\n  assert.same(getPrototypeOf(create(null)), null);\n  assert.same(getPrototypeOf(getPrototypeOf({})), null);\n\n  function Foo() {\n    /* empty */\n  }\n\n  Foo.prototype.foo = 'foo';\n\n  function Bar() {\n    /* empty */\n  }\n\n  Bar.prototype = create(Foo.prototype);\n  Bar.prototype.constructor = Bar;\n  assert.same(getPrototypeOf(Bar.prototype).foo, 'foo');\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getPrototypeOf(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => getPrototypeOf(null), TypeError, 'throws on null');\n  assert.throws(() => getPrototypeOf(undefined), TypeError, 'throws on undefined');\n  assert.same(getPrototypeOf('foo'), String.prototype);\n});","file":"pure/es.object.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object.getPrototypeOf.sham flag","suites":[],"line":45,"code":"QUnit.test('Object.getPrototypeOf.sham flag', assert => {\n  assert.same(getPrototypeOf.sham, CORRECT_PROTOTYPE_GETTER ? undefined : true);\n});","file":"pure/es.object.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object.hasOwn","suites":[],"line":3,"code":"QUnit.test('Object.hasOwn', assert => {\n  assert.isFunction(hasOwn);\n  assert.arity(hasOwn, 2);\n  assert.name(hasOwn, 'hasOwn');\n  assert.true(hasOwn({\n    q: 42\n  }, 'q'));\n  assert.false(hasOwn({\n    q: 42\n  }, 'w'));\n  assert.false(hasOwn(create({\n    q: 42\n  }), 'q'));\n  assert.true(hasOwn(Object.prototype, 'hasOwnProperty'));\n  let called = false;\n\n  try {\n    hasOwn(null, {\n      toString() {\n        called = true;\n      }\n\n    });\n  } catch {\n    /* empty */\n  }\n\n  assert.false(called, 'modern behaviour');\n  assert.throws(() => hasOwn(null, 'foo'), TypeError, 'throws on null');\n  assert.throws(() => hasOwn(undefined, 'foo'), TypeError, 'throws on undefined');\n});","file":"pure/es.object.has-own.js","skipped":false,"dir":"tests"},{"name":"Object.isExtensible","suites":[],"line":2,"code":"QUnit.test('Object.isExtensible', assert => {\n  assert.isFunction(isExtensible);\n  assert.arity(isExtensible, 1);\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isExtensible(value) || true, `accept ${value}`);\n    assert.false(isExtensible(value), `returns false on ${value}`);\n  }\n\n  assert.true(isExtensible({}));\n});","file":"pure/es.object.is-extensible.js","skipped":false,"dir":"tests"},{"name":"Object.isFrozen","suites":[],"line":2,"code":"QUnit.test('Object.isFrozen', assert => {\n  assert.isFunction(isFrozen);\n  assert.arity(isFrozen, 1);\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isFrozen(value) || true, `accept ${value}`);\n    assert.true(isFrozen(value), `returns true on ${value}`);\n  }\n\n  assert.false(isFrozen({}));\n});","file":"pure/es.object.is-frozen.js","skipped":false,"dir":"tests"},{"name":"Object.isSealed","suites":[],"line":2,"code":"QUnit.test('Object.isSealed', assert => {\n  assert.isFunction(isSealed);\n  assert.arity(isSealed, 1);\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isSealed(value) || true, `accept ${value}`);\n    assert.true(isSealed(value), `returns true on ${value}`);\n  }\n\n  assert.false(isSealed({}));\n});","file":"pure/es.object.is-sealed.js","skipped":false,"dir":"tests"},{"name":"Object.is","suites":[],"line":2,"code":"QUnit.test('Object.is', assert => {\n  assert.isFunction(is);\n  assert.true(is(1, 1), '1 is 1');\n  assert.true(is(NaN, NaN), '1 is 1');\n  assert.false(is(0, -0), '0 isnt -0');\n  assert.false(is({}, {}), '{} isnt {}');\n});","file":"pure/es.object.is.js","skipped":false,"dir":"tests"},{"name":"Object.keys","suites":[],"line":3,"code":"QUnit.test('Object.keys', assert => {\n  assert.isFunction(keys);\n  assert.arity(keys, 1);\n\n  function F1() {\n    this.w = 1;\n  }\n\n  function F2() {\n    this.toString = 1;\n  }\n\n  F1.prototype.q = F2.prototype.q = 1;\n  assert.deepEqual(keys([1, 2, 3]), ['0', '1', '2']);\n  assert.deepEqual(keys(new F1()), ['w']);\n  assert.deepEqual(keys(new F2()), ['toString']);\n  assert.false(includes(keys(Array.prototype), 'push'));\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => keys(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => keys(null), TypeError, 'throws on null');\n  assert.throws(() => keys(undefined), TypeError, 'throws on undefined');\n});","file":"pure/es.object.keys.js","skipped":false,"dir":"tests"},{"name":"Object#__lookupGetter__","suites":[],"line":7,"code":"  QUnit.test('Object#__lookupGetter__', assert => {\n    assert.isFunction(__lookupGetter__);\n    assert.same(__lookupGetter__({}, 'key'), undefined, 'empty object');\n    assert.same(__lookupGetter__({\n      key: 42\n    }, 'key'), undefined, 'data descriptor');\n    const object = {};\n\n    function getter() {\n      /* empty */\n    }\n\n    __defineGetter__(object, 'key', getter);\n\n    assert.same(__lookupGetter__(object, 'key'), getter, 'own getter');\n    assert.same(__lookupGetter__(create(object), 'key'), getter, 'proto getter');\n    assert.same(__lookupGetter__(create(object), 'foo'), undefined, 'empty proto');\n\n    if (STRICT) {\n      assert.throws(() => __lookupGetter__(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __lookupGetter__(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"pure/es.object.lookup-getter.js","skipped":false,"dir":"tests"},{"name":"Object#__lookupSetter__","suites":[],"line":7,"code":"  QUnit.test('Object#__lookupSetter__', assert => {\n    assert.isFunction(__lookupSetter__);\n    assert.same(__lookupSetter__({}, 'key'), undefined, 'empty object');\n    assert.same(__lookupSetter__({\n      key: 42\n    }, 'key'), undefined, 'data descriptor');\n    const object = {};\n\n    function setter() {\n      /* empty */\n    }\n\n    __defineSetter__(object, 'key', setter);\n\n    assert.same(__lookupSetter__(object, 'key'), setter, 'own getter');\n    assert.same(__lookupSetter__(create(object), 'key'), setter, 'proto getter');\n    assert.same(__lookupSetter__(create(object), 'foo'), undefined, 'empty proto');\n\n    if (STRICT) {\n      assert.throws(() => __lookupSetter__(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __lookupSetter__(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"pure/es.object.lookup-setter.js","skipped":false,"dir":"tests"},{"name":"Object.preventExtensions","suites":[],"line":6,"code":"QUnit.test('Object.preventExtensions', assert => {\n  assert.isFunction(preventExtensions);\n  assert.arity(preventExtensions, 1);\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => preventExtensions(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(preventExtensions(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  const results = [];\n\n  for (const key in preventExtensions({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(preventExtensions({})), []);\n  assert.arrayEqual(getOwnPropertyNames(preventExtensions({})), []);\n  assert.arrayEqual(getOwnPropertySymbols(preventExtensions({})), []);\n  assert.arrayEqual(ownKeys(preventExtensions({})), []);\n});","file":"pure/es.object.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Object.seal","suites":[],"line":6,"code":"QUnit.test('Object.seal', assert => {\n  assert.isFunction(seal);\n  assert.arity(seal, 1);\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => seal(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(seal(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  const results = [];\n\n  for (const key in seal({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(seal({})), []);\n  assert.arrayEqual(getOwnPropertyNames(seal({})), []);\n  assert.arrayEqual(getOwnPropertySymbols(seal({})), []);\n  assert.arrayEqual(ownKeys(seal({})), []);\n});","file":"pure/es.object.seal.js","skipped":false,"dir":"tests"},{"name":"Object.setPrototypeOf","suites":[],"line":3,"code":"if (PROTO) QUnit.test('Object.setPrototypeOf', assert => {\n  assert.isFunction(setPrototypeOf);\n  assert.true('apply' in setPrototypeOf({}, Function.prototype), 'Parent properties in target');\n  assert.same(setPrototypeOf({\n    a: 2\n  }, {\n    b() {\n      return this.a ** 2;\n    }\n\n  }).b(), 4, 'Child and parent properties in target');\n  const object = {};\n  assert.same(setPrototypeOf(object, {\n    a: 1\n  }), object, 'setPrototypeOf return target');\n  assert.false('toString' in setPrototypeOf({}, null), 'Can set null as prototype');\n});","file":"pure/es.object.set-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object.values","suites":[],"line":4,"code":"QUnit.test('Object.values', assert => {\n  assert.isFunction(values);\n  assert.arity(values, 1);\n  assert.name(values, 'values');\n  assert.deepEqual(values({\n    q: 1,\n    w: 2,\n    e: 3\n  }), [1, 2, 3]);\n  assert.deepEqual(values(new String('qwe')), ['q', 'w', 'e']);\n  assert.deepEqual(values(assign(create({\n    q: 1,\n    w: 2,\n    e: 3\n  }), {\n    a: 4,\n    s: 5,\n    d: 6\n  })), [4, 5, 6]);\n  assert.deepEqual(values({\n    valueOf: 42\n  }), [42], 'IE enum keys bug');\n\n  try {\n    assert.deepEqual(Function('values', `\n      return values({ a: 1, get b() {\n        delete this.c;\n        return 2;\n      }, c: 3 });\n   `)(values), [1, 2]);\n  } catch {\n    /* empty */\n  }\n\n  try {\n    assert.deepEqual(Function('values', `\n      return values({ a: 1, get b() {\n        Object.defineProperty(this, \"c\", {\n          value: 4,\n          enumerable: false\n        });\n        return 2;\n      }, c: 3 });\n    `)(values), [1, 2]);\n  } catch {\n    /* empty */\n  }\n});","file":"pure/es.object.values.js","skipped":false,"dir":"tests"},{"name":"parseFloat","suites":[],"line":3,"code":"QUnit.test('parseFloat', assert => {\n  assert.isFunction(parseFloat);\n  assert.arity(parseFloat, 1);\n  assert.same(parseFloat('0'), 0);\n  assert.same(parseFloat(' 0'), 0);\n  assert.same(parseFloat('+0'), 0);\n  assert.same(parseFloat(' +0'), 0);\n  assert.same(parseFloat('-0'), -0);\n  assert.same(parseFloat(' -0'), -0);\n  assert.same(parseFloat(`${WHITESPACES}+0`), 0);\n  assert.same(parseFloat(`${WHITESPACES}-0`), -0);\n  assert.same(parseFloat(null), NaN);\n  assert.same(parseFloat(undefined), NaN);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => parseFloat(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseFloat(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"pure/es.parse-float.js","skipped":false,"dir":"tests"},{"name":"parseInt","suites":[],"line":3,"code":"QUnit.test('parseInt', assert => {\n  assert.isFunction(parseInt);\n  assert.arity(parseInt, 2);\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(parseInt('10', radix), radix, `radix ${radix}`);\n  }\n\n  const strings = ['01', '08', '10', '42'];\n\n  for (const string of strings) {\n    assert.same(parseInt(string), parseInt(string, 10), `default radix is 10: ${string}`);\n  }\n\n  assert.same(parseInt('0x16'), parseInt('0x16', 16), 'default radix is 16: 0x16');\n  assert.same(parseInt('  0x16'), parseInt('0x16', 16), 'ignores leading whitespace #1');\n  assert.same(parseInt('  42'), parseInt('42', 10), 'ignores leading whitespace #2');\n  assert.same(parseInt('  08'), parseInt('08', 10), 'ignores leading whitespace #3');\n  assert.same(parseInt(`${WHITESPACES}08`), parseInt('08', 10), 'ignores leading whitespace #4');\n  assert.same(parseInt(`${WHITESPACES}0x16`), parseInt('0x16', 16), 'ignores leading whitespace #5');\n  const fakeZero = {\n    valueOf() {\n      return 0;\n    }\n\n  };\n  assert.same(parseInt('08', fakeZero), parseInt('08', 10), 'valueOf #1');\n  assert.same(parseInt('0x16', fakeZero), parseInt('0x16', 16), 'valueOf #2');\n  assert.same(parseInt('-0xF'), -15, 'signed hex #1');\n  assert.same(parseInt('-0xF', 16), -15, 'signed hex #2');\n  assert.same(parseInt('+0xF'), 15, 'signed hex #3');\n  assert.same(parseInt('+0xF', 16), 15, 'signed hex #4');\n  assert.same(parseInt('10', -4294967294), 2, 'radix uses ToUint32');\n  assert.same(parseInt(null), NaN);\n  assert.same(parseInt(undefined), NaN);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => parseInt(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseInt(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"pure/es.parse-int.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled","suites":[],"line":2,"code":"QUnit.test('Promise.allSettled', assert => {\n  assert.isFunction(Promise.allSettled);\n  assert.arity(Promise.allSettled, 1);\n  assert.true(Promise.allSettled([1, 2, 3]) instanceof Promise, 'returns a promise');\n});","file":"pure/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled, resolved","suites":[],"line":7,"code":"QUnit.test('Promise.allSettled, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.allSettled([Promise.resolve(1), Promise.reject(2), Promise.resolve(3)]).then(it => {\n    assert.deepEqual(it, [{\n      value: 1,\n      status: 'fulfilled'\n    }, {\n      reason: 2,\n      status: 'rejected'\n    }, {\n      value: 3,\n      status: 'fulfilled'\n    }], 'resolved with a correct value');\n    async();\n  });\n});","file":"pure/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled, rejected","suites":[],"line":24,"code":"QUnit.test('Promise.allSettled, rejected', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.allSettled().catch(() => {\n    assert.required('rejected as expected');\n    async();\n  });\n});","file":"pure/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.all","suites":[],"line":6,"code":"QUnit.test('Promise.all', assert => {\n  const {\n    all,\n    resolve\n  } = Promise;\n  assert.isFunction(all);\n  assert.arity(all, 1);\n  const iterable = createIterable([1, 2, 3]);\n  Promise.all(iterable).catch(() => {\n    /* empty */\n  });\n  assert.true(iterable.received, 'works with iterables: iterator received');\n  assert.true(iterable.called, 'works with iterables: next called');\n  const array = [];\n  let done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  Promise.all(array);\n  assert.true(done);\n  assert.throws(() => {\n    all.call(null, []).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n  done = false;\n\n  try {\n    Promise.resolve = function () {\n      throw new Error();\n    };\n\n    Promise.all(createIterable([1, 2, 3], {\n      return() {\n        done = true;\n      }\n\n    })).catch(() => {\n      /* empty */\n    });\n  } catch (error) {\n    /* empty */\n  }\n\n  Promise.resolve = resolve;\n  assert.true(done, 'iteration closing');\n\n  let FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  let FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = bind(resolve, Promise);\n  assert.true(all.call(FakePromise1, [1, 2, 3]) instanceof FakePromise1, 'subclassing, `this` pattern');\n\n  FakePromise1 = function () {\n    /* empty */\n  };\n\n  FakePromise2 = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise3 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = FakePromise3.resolve = bind(resolve, Promise);\n  assert.throws(() => {\n    all.call(FakePromise1, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    all.call(FakePromise2, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    all.call(FakePromise3, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"pure/es.promise.all.js","skipped":false,"dir":"tests"},{"name":"Promise.any","suites":[],"line":3,"code":"QUnit.test('Promise.any', assert => {\n  assert.isFunction(Promise.any);\n  assert.arity(Promise.any, 1);\n  assert.true(Promise.any([1, 2, 3]) instanceof Promise, 'returns a promise');\n});","file":"pure/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, resolved","suites":[],"line":8,"code":"QUnit.test('Promise.any, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.any([Promise.resolve(1), Promise.reject(2), Promise.resolve(3)]).then(it => {\n    assert.same(it, 1, 'resolved with a correct value');\n    async();\n  });\n});","file":"pure/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #1","suites":[],"line":16,"code":"QUnit.test('Promise.any, rejected #1', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  Promise.any([Promise.reject(1), Promise.reject(2), Promise.reject(3)]).catch(error => {\n    assert.true(error instanceof AggregateError, 'instanceof AggregateError');\n    assert.deepEqual(error.errors, [1, 2, 3], 'rejected with a correct value');\n    async();\n  });\n});","file":"pure/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #2","suites":[],"line":25,"code":"QUnit.test('Promise.any, rejected #2', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.any().catch(() => {\n    assert.required('rejected as expected');\n    async();\n  });\n});","file":"pure/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #3","suites":[],"line":33,"code":"QUnit.test('Promise.any, rejected #3', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  Promise.any([]).catch(error => {\n    assert.true(error instanceof AggregateError, 'instanceof AggregateError');\n    assert.deepEqual(error.errors, [], 'rejected with a correct value');\n    async();\n  });\n});","file":"pure/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise#catch","suites":[],"line":3,"code":"QUnit.test('Promise#catch', assert => {\n  assert.isFunction(Promise.prototype.catch);\n  assert.nonEnumerable(Promise.prototype, 'catch');\n  let promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  let FakePromise1 = promise.constructor = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.catch(() => {\n    /* empty */\n  }) instanceof FakePromise2, 'subclassing, @@species pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.catch(() => {\n    /* empty */\n  }) instanceof Promise, 'subclassing, incorrect `this` pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1[Symbol.species] = function () {\n    /* empty */\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #1');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #2');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #3');\n  assert.same(Promise.prototype.catch.call({\n    // eslint-disable-next-line unicorn/no-thenable -- required for testing\n    then(x, y) {\n      return y;\n    }\n\n  }, 42), 42, 'calling `.then`');\n});","file":"pure/es.promise.catch.js","skipped":false,"dir":"tests"},{"name":"Promise","suites":[],"line":6,"code":"QUnit.test('Promise', assert => {\n  assert.isFunction(Promise);\n  assert.throws(() => {\n    Promise();\n  }, 'throws w/o `new`');\n  new Promise(function (resolve, reject) {\n    assert.isFunction(resolve, 'resolver is function');\n    assert.isFunction(reject, 'rejector is function');\n    if (STRICT) assert.same(this, undefined, 'correct executor context');\n  });\n});","file":"pure/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise operations order","suites":[],"line":17,"code":"if (DESCRIPTORS) QUnit.test('Promise operations order', assert => {\n  let $resolve, $resolve2;\n  assert.expect(1);\n  const EXPECTED_ORDER = 'DEHAFGBC';\n  const async = assert.async();\n  let result = '';\n  const promise1 = new Promise(resolve => {\n    $resolve = resolve;\n  });\n  $resolve({\n    // eslint-disable-next-line unicorn/no-thenable -- required for testing\n    then() {\n      result += 'A';\n      throw Error();\n    }\n\n  });\n  promise1.catch(() => {\n    result += 'B';\n  });\n  promise1.catch(() => {\n    result += 'C';\n    assert.same(result, EXPECTED_ORDER);\n    async();\n  });\n  const promise2 = new Promise(resolve => {\n    $resolve2 = resolve;\n  }); // eslint-disable-next-line es-x/no-object-defineproperty, unicorn/no-thenable -- required for testing\n\n  $resolve2(Object.defineProperty({}, 'then', {\n    get() {\n      result += 'D';\n      throw Error();\n    }\n\n  }));\n  result += 'E';\n  promise2.catch(() => {\n    result += 'F';\n  });\n  promise2.catch(() => {\n    result += 'G';\n  });\n  result += 'H';\n  setTimeout(() => {\n    if (!~result.indexOf('C')) {\n      assert.same(result, EXPECTED_ORDER);\n      async();\n    }\n  }, 1e3);\n});","file":"pure/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#then","suites":[],"line":68,"code":"QUnit.test('Promise#then', assert => {\n  assert.isFunction(Promise.prototype.then);\n  assert.nonEnumerable(Promise.prototype, 'then');\n  let promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  let FakePromise1 = promise.constructor = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.then(() => {\n    /* empty */\n  }) instanceof FakePromise2, 'subclassing, @@species pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.then(() => {\n    /* empty */\n  }) instanceof Promise, 'subclassing, incorrect `this` pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1[Symbol.species] = function () {\n    /* empty */\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #1');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #2');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #3');\n});","file":"pure/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#@@toStringTag","suites":[],"line":155,"code":"QUnit.test('Promise#@@toStringTag', assert => {\n  assert.same(Promise.prototype[Symbol.toStringTag], 'Promise', 'Promise::@@toStringTag is `Promise`');\n  assert.same(String(new Promise(() => {\n    /* empty */\n  })), '[object Promise]', 'correct stringification');\n});","file":"pure/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise subclassing","suites":[],"line":161,"code":"if (PROTO) QUnit.test('Promise subclassing', assert => {\n  function SubPromise(executor) {\n    const self = new Promise(executor);\n    setPrototypeOf(self, SubPromise.prototype);\n    self.mine = 'subclass';\n    return self;\n  }\n\n  setPrototypeOf(SubPromise, Promise);\n  SubPromise.prototype = create(Promise.prototype);\n  SubPromise.prototype.constructor = SubPromise;\n  let promise1 = SubPromise.resolve(5);\n  assert.same(promise1.mine, 'subclass');\n  promise1 = promise1.then(it => {\n    assert.same(it, 5);\n  });\n  assert.same(promise1.mine, 'subclass');\n  let promise2 = new SubPromise(resolve => {\n    resolve(6);\n  });\n  assert.same(promise2.mine, 'subclass');\n  promise2 = promise2.then(it => {\n    assert.same(it, 6);\n  });\n  assert.same(promise2.mine, 'subclass');\n  const promise3 = SubPromise.all([promise1, promise2]);\n  assert.same(promise3.mine, 'subclass');\n  assert.true(promise3 instanceof Promise);\n  assert.true(promise3 instanceof SubPromise);\n  promise3.then(assert.async(), error => {\n    assert.avoid(error);\n  });\n}); // qunit@2.5 strange bug","file":"pure/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#finally","suites":[],"line":2,"code":"QUnit.test('Promise#finally', assert => {\n  assert.isFunction(Promise.prototype.finally);\n  assert.arity(Promise.prototype.finally, 1);\n  assert.nonEnumerable(Promise.prototype, 'finally');\n  assert.true(Promise.resolve(42).finally(() => {\n    /* empty */\n  }) instanceof Promise, 'returns a promise');\n});","file":"pure/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise#finally, resolved","suites":[],"line":10,"code":"QUnit.test('Promise#finally, resolved', assert => {\n  assert.expect(3);\n  const async = assert.async();\n  let called = 0;\n  let argument = null;\n  Promise.resolve(42).finally(it => {\n    called++;\n    argument = it;\n  }).then(it => {\n    assert.same(it, 42, 'resolved with a correct value');\n    assert.same(called, 1, 'onFinally function called one time');\n    assert.same(argument, undefined, 'onFinally function called with a correct argument');\n    async();\n  });\n});","file":"pure/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise#finally, rejected","suites":[],"line":25,"code":"QUnit.test('Promise#finally, rejected', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  let called = 0;\n  let argument = null;\n  Promise.reject(42).finally(it => {\n    called++;\n    argument = it;\n  }).catch(() => {\n    assert.same(called, 1, 'onFinally function called one time');\n    assert.same(argument, undefined, 'onFinally function called with a correct argument');\n    async();\n  });\n});","file":"pure/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise.race","suites":[],"line":6,"code":"QUnit.test('Promise.race', assert => {\n  const {\n    race,\n    resolve\n  } = Promise;\n  assert.isFunction(race);\n  assert.arity(race, 1);\n  const iterable = createIterable([1, 2, 3]);\n  Promise.race(iterable).catch(() => {\n    /* empty */\n  });\n  assert.true(iterable.received, 'works with iterables: iterator received');\n  assert.true(iterable.called, 'works with iterables: next called');\n  const array = [];\n  let done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  Promise.race(array);\n  assert.true(done);\n  assert.throws(() => {\n    race.call(null, []).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n  done = false;\n\n  try {\n    Promise.resolve = function () {\n      throw new Error();\n    };\n\n    Promise.race(createIterable([1, 2, 3], {\n      return() {\n        done = true;\n      }\n\n    })).catch(() => {\n      /* empty */\n    });\n  } catch (error) {\n    /* empty */\n  }\n\n  Promise.resolve = resolve;\n  assert.true(done, 'iteration closing');\n\n  let FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  let FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = bind(resolve, Promise);\n  assert.true(race.call(FakePromise1, [1, 2, 3]) instanceof FakePromise1, 'subclassing, `this` pattern');\n\n  FakePromise1 = function () {\n    /* empty */\n  };\n\n  FakePromise2 = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise3 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = FakePromise3.resolve = bind(resolve, Promise);\n  assert.throws(() => {\n    race.call(FakePromise1, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    race.call(FakePromise2, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    race.call(FakePromise3, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"pure/es.promise.race.js","skipped":false,"dir":"tests"},{"name":"Promise.reject","suites":[],"line":3,"code":"QUnit.test('Promise.reject', assert => {\n  const {\n    reject\n  } = Promise;\n  assert.isFunction(reject);\n  assert.throws(() => {\n    reject.call(null, 1).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n\n  function FakePromise1(executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  }\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(reject.call(FakePromise1, 42) instanceof FakePromise1, 'subclassing, `this` pattern');\n  assert.throws(() => {\n    reject.call(() => {\n      /* empty */\n    }, 42);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    reject.call(executor => {\n      executor(null, () => {\n        /* empty */\n      });\n    }, 42);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    reject.call(executor => {\n      executor(() => {\n        /* empty */\n      }, null);\n    }, 42);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"pure/es.promise.reject.js","skipped":false,"dir":"tests"},{"name":"Promise.resolve","suites":[],"line":3,"code":"QUnit.test('Promise.resolve', assert => {\n  const {\n    resolve\n  } = Promise;\n  assert.isFunction(resolve);\n  assert.throws(() => {\n    resolve.call(null, 1).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n\n  function FakePromise1(executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  }\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(resolve.call(FakePromise1, 42) instanceof FakePromise1, 'subclassing, `this` pattern');\n  assert.throws(() => {\n    resolve.call(() => {\n      /* empty */\n    }, 42);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    resolve.call(executor => {\n      executor(null, () => {\n        /* empty */\n      });\n    }, 42);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    resolve.call(executor => {\n      executor(() => {\n        /* empty */\n      }, null);\n    }, 42);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"pure/es.promise.resolve.js","skipped":false,"dir":"tests"},{"name":"Reflect.apply","suites":[],"line":2,"code":"QUnit.test('Reflect.apply', assert => {\n  assert.isFunction(apply);\n  assert.arity(apply, 3);\n\n  if ('name' in apply) {\n    assert.name(apply, 'apply');\n  }\n\n  assert.same(apply(Array.prototype.push, [1, 2], [3, 4, 5]), 5);\n\n  function F(a, b, c) {\n    return a + b + c;\n  }\n\n  F.apply = 42;\n  assert.same(apply(F, null, ['foo', 'bar', 'baz']), 'foobarbaz', 'works with redefined apply');\n  assert.throws(() => apply(42, null, []), TypeError, 'throws on primitive');\n  assert.throws(() => apply(() => {\n    /* empty */\n  }, null), TypeError, 'throws without third argument');\n  assert.throws(() => apply(() => {\n    /* empty */\n  }, null, '123'), TypeError, 'throws on primitive as third argument');\n});","file":"pure/es.reflect.apply.js","skipped":false,"dir":"tests"},{"name":"Reflect.construct","suites":[],"line":3,"code":"QUnit.test('Reflect.construct', assert => {\n  assert.isFunction(construct);\n  assert.arity(construct, 2);\n\n  if ('name' in construct) {\n    assert.name(construct, 'construct');\n  }\n\n  function A(a, b, c) {\n    this.qux = a + b + c;\n  }\n\n  assert.same(construct(A, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'basic');\n  A.apply = 42;\n  assert.same(construct(A, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'works with redefined apply');\n  const instance = construct(function () {\n    this.x = 42;\n  }, [], Array);\n  assert.same(instance.x, 42, 'constructor with newTarget');\n  assert.true(instance instanceof Array, 'prototype with newTarget');\n  assert.throws(() => construct(42, []), TypeError, 'throws on primitive');\n\n  function B() {\n    /* empty */\n  }\n\n  B.prototype = 42;\n  assert.notThrows(() => getPrototypeOf(construct(B, [])) === Object.prototype);\n  assert.notThrows(() => typeof construct(Date, []).getTime() == 'number', 'works with native constructors with 2 arguments');\n  assert.throws(() => construct(() => {\n    /* empty */\n  }), 'throws when the second argument is not an object');\n});","file":"pure/es.reflect.construct.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineProperty","suites":[],"line":5,"code":"QUnit.test('Reflect.defineProperty', assert => {\n  assert.isFunction(defineProperty);\n  assert.arity(defineProperty, 3);\n\n  if ('name' in defineProperty) {\n    assert.name(defineProperty, 'defineProperty');\n  }\n\n  let object = {};\n  assert.true(defineProperty(object, 'foo', {\n    value: 123\n  }));\n  assert.same(object.foo, 123);\n\n  if (DESCRIPTORS) {\n    object = {};\n    defineProperty(object, 'foo', {\n      value: 123,\n      enumerable: true\n    });\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'foo'), {\n      value: 123,\n      enumerable: true,\n      configurable: false,\n      writable: false\n    });\n    assert.false(defineProperty(object, 'foo', {\n      value: 42\n    }));\n  }\n\n  assert.throws(() => defineProperty(42, 'foo', {\n    value: 42\n  }), TypeError, 'throws on primitive');\n  assert.throws(() => defineProperty(42, 1, {}));\n  assert.throws(() => defineProperty({}, create(null), {}));\n  assert.throws(() => defineProperty({}, 1, 1));\n});","file":"pure/es.reflect.define-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineProperty.sham flag","suites":[],"line":43,"code":"QUnit.test('Reflect.defineProperty.sham flag', assert => {\n  assert.same(defineProperty.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.reflect.define-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.deleteProperty","suites":[],"line":5,"code":"QUnit.test('Reflect.deleteProperty', assert => {\n  assert.isFunction(deleteProperty);\n  assert.arity(deleteProperty, 2);\n\n  if ('name' in deleteProperty) {\n    assert.name(deleteProperty, 'deleteProperty');\n  }\n\n  const object = {\n    bar: 456\n  };\n  assert.true(deleteProperty(object, 'bar'));\n  assert.same(keys(object).length, 0);\n\n  if (DESCRIPTORS) {\n    assert.false(deleteProperty(defineProperty({}, 'foo', {\n      value: 42\n    }), 'foo'));\n  }\n\n  assert.throws(() => deleteProperty(42, 'foo'), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.delete-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnPropertyDescriptor","suites":[],"line":3,"code":"QUnit.test('Reflect.getOwnPropertyDescriptor', assert => {\n  assert.isFunction(getOwnPropertyDescriptor);\n  assert.arity(getOwnPropertyDescriptor, 2);\n\n  if ('name' in getOwnPropertyDescriptor) {\n    assert.name(getOwnPropertyDescriptor, 'getOwnPropertyDescriptor');\n  }\n\n  const object = {\n    baz: 789\n  };\n  const descriptor = getOwnPropertyDescriptor(object, 'baz');\n  assert.same(descriptor.value, 789);\n  assert.throws(() => getOwnPropertyDescriptor(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnPropertyDescriptor.sham flag","suites":[],"line":18,"code":"QUnit.test('Reflect.getOwnPropertyDescriptor.sham flag', assert => {\n  assert.same(getOwnPropertyDescriptor.sham, DESCRIPTORS ? undefined : true);\n});","file":"pure/es.reflect.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Reflect.getPrototypeOf","suites":[],"line":3,"code":"QUnit.test('Reflect.getPrototypeOf', assert => {\n  assert.isFunction(getPrototypeOf);\n  assert.arity(getPrototypeOf, 1);\n\n  if ('name' in getPrototypeOf) {\n    assert.name(getPrototypeOf, 'getPrototypeOf');\n  }\n\n  assert.same(getPrototypeOf([]), Array.prototype);\n  assert.throws(() => getPrototypeOf(42), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.getPrototypeOf.sham flag","suites":[],"line":14,"code":"QUnit.test('Reflect.getPrototypeOf.sham flag', assert => {\n  assert.same(getPrototypeOf.sham, CORRECT_PROTOTYPE_GETTER ? undefined : true);\n});","file":"pure/es.reflect.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.get","suites":[],"line":5,"code":"QUnit.test('Reflect.get', assert => {\n  assert.isFunction(get);\n\n  if ('name' in get) {\n    assert.name(get, 'get');\n  }\n\n  assert.same(get({\n    qux: 987\n  }, 'qux'), 987);\n\n  if (DESCRIPTORS) {\n    const target = create(defineProperty({\n      z: 3\n    }, 'w', {\n      get() {\n        return this;\n      }\n\n    }), {\n      x: {\n        value: 1\n      },\n      y: {\n        get() {\n          return this;\n        }\n\n      }\n    });\n    const receiver = {};\n    assert.same(get(target, 'x', receiver), 1, 'get x');\n    assert.same(get(target, 'y', receiver), receiver, 'get y');\n    assert.same(get(target, 'z', receiver), 3, 'get z');\n    assert.same(get(target, 'w', receiver), receiver, 'get w');\n    assert.same(get(target, 'u', receiver), undefined, 'get u');\n  }\n\n  assert.throws(() => get(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.get.js","skipped":false,"dir":"tests"},{"name":"Reflect.has","suites":[],"line":2,"code":"QUnit.test('Reflect.has', assert => {\n  assert.isFunction(has);\n  assert.arity(has, 2);\n\n  if ('name' in has) {\n    assert.name(has, 'has');\n  }\n\n  const object = {\n    qux: 987\n  };\n  assert.true(has(object, 'qux'));\n  assert.false(has(object, 'qwe'));\n  assert.true(has(object, 'toString'));\n  assert.throws(() => has(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.has.js","skipped":false,"dir":"tests"},{"name":"Reflect.isExtensible","suites":[],"line":4,"code":"QUnit.test('Reflect.isExtensible', assert => {\n  assert.isFunction(isExtensible);\n  assert.arity(isExtensible, 1);\n\n  if ('name' in isExtensible) {\n    assert.name(isExtensible, 'isExtensible');\n  }\n\n  assert.true(isExtensible({}));\n\n  if (DESCRIPTORS) {\n    assert.false(isExtensible(preventExtensions({})));\n  }\n\n  assert.throws(() => isExtensible(42), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.is-extensible.js","skipped":false,"dir":"tests"},{"name":"Reflect.ownKeys","suites":[],"line":6,"code":"QUnit.test('Reflect.ownKeys', assert => {\n  assert.isFunction(ownKeys);\n  assert.arity(ownKeys, 1);\n\n  if ('name' in ownKeys) {\n    assert.name(ownKeys, 'ownKeys');\n  }\n\n  const object = {\n    a: 1\n  };\n  defineProperty(object, 'b', {\n    value: 2\n  });\n  object[Symbol('c')] = 3;\n  let keys = ownKeys(object);\n  assert.same(keys.length, 3, 'ownKeys return all own keys');\n  assert.true(includes(keys, 'a'), 'ownKeys return all own keys: simple');\n  assert.true(includes(keys, 'b'), 'ownKeys return all own keys: hidden');\n  assert.same(object[keys[2]], 3, 'ownKeys return all own keys: symbol');\n  keys = ownKeys(create(object));\n  assert.same(keys.length, 0, 'ownKeys return only own keys');\n  assert.throws(() => ownKeys(42), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.own-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.preventExtensions","suites":[],"line":4,"code":"QUnit.test('Reflect.preventExtensions', assert => {\n  assert.isFunction(preventExtensions);\n  assert.arity(preventExtensions, 1);\n\n  if ('name' in preventExtensions) {\n    assert.name(preventExtensions, 'preventExtensions');\n  }\n\n  const object = {};\n  assert.true(preventExtensions(object));\n\n  if (DESCRIPTORS) {\n    assert.false(isExtensible(object));\n  }\n\n  assert.throws(() => preventExtensions(42), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Reflect.preventExtensions.sham flag","suites":[],"line":21,"code":"QUnit.test('Reflect.preventExtensions.sham flag', assert => {\n  assert.same(preventExtensions.sham, FREEZING ? undefined : true);\n});","file":"pure/es.reflect.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Reflect.setPrototypeOf","suites":[],"line":3,"code":"if (PROTO) QUnit.test('Reflect.setPrototypeOf', assert => {\n  assert.isFunction(setPrototypeOf);\n\n  if ('name' in setPrototypeOf) {\n    assert.name(setPrototypeOf, 'setPrototypeOf');\n  }\n\n  let object = {};\n  assert.true(setPrototypeOf(object, Array.prototype));\n  assert.true(object instanceof Array);\n  assert.throws(() => setPrototypeOf({}, 42), TypeError);\n  assert.throws(() => setPrototypeOf(42, {}), TypeError, 'throws on primitive');\n  object = {};\n  assert.false(setPrototypeOf(object, object), 'false on recursive __proto__');\n});","file":"pure/es.reflect.set-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.set","suites":[],"line":7,"code":"QUnit.test('Reflect.set', assert => {\n  assert.isFunction(set);\n\n  if ('name' in set) {\n    assert.name(set, 'set');\n  }\n\n  const object = {};\n  assert.true(set(object, 'quux', 654));\n  assert.same(object.quux, 654);\n  let target = {};\n  const receiver = {};\n  set(target, 'foo', 1, receiver);\n  assert.same(target.foo, undefined, 'target.foo === undefined');\n  assert.same(receiver.foo, 1, 'receiver.foo === 1');\n\n  if (DESCRIPTORS) {\n    defineProperty(receiver, 'bar', {\n      value: 0,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    set(target, 'bar', 1, receiver);\n    assert.same(receiver.bar, 1, 'receiver.bar === 1');\n    assert.false(getOwnPropertyDescriptor(receiver, 'bar').enumerable, 'enumerability not overridden');\n    let out = null;\n    target = create(defineProperty({\n      z: 3\n    }, 'w', {\n      set() {\n        out = this;\n      }\n\n    }), {\n      x: {\n        value: 1,\n        writable: true,\n        configurable: true\n      },\n      y: {\n        set() {\n          out = this;\n        }\n\n      },\n      c: {\n        value: 1,\n        writable: false,\n        configurable: false\n      }\n    });\n    assert.true(set(target, 'x', 2, target), 'set x');\n    assert.same(target.x, 2, 'set x');\n    out = null;\n    assert.true(set(target, 'y', 2, target), 'set y');\n    assert.same(out, target, 'set y');\n    assert.true(set(target, 'z', 4, target));\n    assert.same(target.z, 4, 'set z');\n    out = null;\n    assert.true(set(target, 'w', 1, target), 'set w');\n    assert.same(out, target, 'set w');\n    assert.true(set(target, 'u', 0, target), 'set u');\n    assert.same(target.u, 0, 'set u');\n    assert.false(set(target, 'c', 2, target), 'set c');\n    assert.same(target.c, 1, 'set c'); // https://github.com/zloirock/core-js/issues/392\n\n    let o = defineProperty({}, 'test', {\n      writable: false,\n      configurable: true\n    });\n    assert.false(set(getPrototypeOf(o), 'test', 1, o)); // https://github.com/zloirock/core-js/issues/393\n\n    o = defineProperty({}, 'test', {\n      get() {\n        /* empty */\n      }\n\n    });\n    assert.notThrows(() => !set(getPrototypeOf(o), 'test', 1, o));\n    o = defineProperty({}, 'test', {\n      // eslint-disable-next-line no-unused-vars -- required for testing\n      set(v) {\n        /* empty */\n      }\n\n    });\n    assert.notThrows(() => !set(getPrototypeOf(o), 'test', 1, o));\n  }\n\n  assert.throws(() => set(42, 'q', 42), TypeError, 'throws on primitive');\n});","file":"pure/es.reflect.set.js","skipped":false,"dir":"tests"},{"name":"Set","suites":[],"line":16,"code":"QUnit.test('Set', assert => {\n  assert.isFunction(Set);\n  assert.true('add' in Set.prototype, 'add in Set.prototype');\n  assert.true('clear' in Set.prototype, 'clear in Set.prototype');\n  assert.true('delete' in Set.prototype, 'delete in Set.prototype');\n  assert.true('forEach' in Set.prototype, 'forEach in Set.prototype');\n  assert.true('has' in Set.prototype, 'has in Set.prototype');\n  assert.true(new Set() instanceof Set, 'new Set instanceof Set');\n  let set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  assert.same(set.size, 3);\n  const result = [];\n  set.forEach(val => {\n    result.push(val);\n  });\n  assert.deepEqual(result, [1, 2, 3]);\n  assert.same(new Set(createIterable([1, 2, 3])).size, 3, 'Init from iterable');\n  assert.same(new Set([freeze({}), 1]).size, 2, 'Support frozen objects');\n  assert.same(new Set([NaN, NaN, NaN]).size, 1);\n  assert.deepEqual(from(new Set([3, 4]).add(2).add(1)), [3, 4, 2, 1]);\n  let done = false;\n  const {\n    add\n  } = Set.prototype;\n\n  Set.prototype.add = function () {\n    throw new Error();\n  };\n\n  try {\n    new Set(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  Set.prototype.add = add;\n  assert.true(done, '.return #throw');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  new Set(array);\n  assert.true(done);\n  const object = {};\n  new Set().add(object);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in results) keys.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(Set);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof Set, 'correct subclassing with native classes #2');\n    assert.true(new Subclass().add(2).has(2), 'correct subclassing with native classes #3');\n  }\n\n  if (typeof ArrayBuffer == 'function') {\n    const buffer = new ArrayBuffer(8);\n    set = new Set([buffer]);\n    assert.true(set.has(buffer), 'works with ArrayBuffer keys');\n  }\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#add","suites":[],"line":102,"code":"QUnit.test('Set#add', assert => {\n  assert.isFunction(Set.prototype.add);\n  const array = [];\n  let set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(array);\n  assert.same(set.size, 5);\n  const chain = set.add(NaN);\n  assert.same(chain, set);\n  assert.same(set.size, 5);\n  set.add(2);\n  assert.same(set.size, 5);\n  set.add(array);\n  assert.same(set.size, 5);\n  set.add([]);\n  assert.same(set.size, 6);\n  set.add(4);\n  assert.same(set.size, 7);\n  const frozen = freeze({});\n  set = new Set();\n  set.add(frozen);\n  assert.true(set.has(frozen));\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#clear","suites":[],"line":129,"code":"QUnit.test('Set#clear', assert => {\n  assert.isFunction(Set.prototype.clear);\n  let set = new Set();\n  set.clear();\n  assert.same(set.size, 0);\n  set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.clear();\n  assert.same(set.size, 0);\n  assert.false(set.has(1));\n  assert.false(set.has(2));\n  assert.false(set.has(3));\n  const frozen = freeze({});\n  set = new Set();\n  set.add(1);\n  set.add(frozen);\n  set.clear();\n  assert.same(set.size, 0, 'Support frozen objects');\n  assert.false(set.has(1));\n  assert.false(set.has(frozen));\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#delete","suites":[],"line":154,"code":"QUnit.test('Set#delete', assert => {\n  assert.isFunction(Set.prototype.delete);\n  const array = [];\n  const set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(array);\n  assert.same(set.size, 5);\n  assert.true(set.delete(NaN));\n  assert.same(set.size, 4);\n  assert.false(set.delete(4));\n  assert.same(set.size, 4);\n  set.delete([]);\n  assert.same(set.size, 4);\n  set.delete(array);\n  assert.same(set.size, 3);\n  const frozen = freeze({});\n  set.add(frozen);\n  assert.same(set.size, 4);\n  set.delete(frozen);\n  assert.same(set.size, 3);\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#forEach","suites":[],"line":179,"code":"QUnit.test('Set#forEach', assert => {\n  assert.isFunction(Set.prototype.forEach);\n  let result = [];\n  let count = 0;\n  let set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.forEach(value => {\n    count++;\n    result.push(value);\n  });\n  assert.same(count, 3);\n  assert.deepEqual(result, [1, 2, 3]);\n  set = new Set();\n  set.add('0');\n  set.add('1');\n  set.add('2');\n  set.add('3');\n  result = '';\n  set.forEach(it => {\n    result += it;\n\n    if (it === '2') {\n      set.delete('2');\n      set.delete('3');\n      set.delete('1');\n      set.add('4');\n    }\n  });\n  assert.same(result, '0124');\n  set = new Set();\n  set.add('0');\n  result = '';\n  set.forEach(it => {\n    set.delete('0');\n    if (result !== '') throw new Error();\n    result += it;\n  });\n  assert.same(result, '0');\n  assert.throws(() => {\n    Set.prototype.forEach.call(new Map(), () => {\n      /* empty */\n    });\n  }, 'non-generic');\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#has","suites":[],"line":227,"code":"QUnit.test('Set#has', assert => {\n  assert.isFunction(Set.prototype.has);\n  const array = [];\n  const frozen = freeze({});\n  const set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(frozen);\n  set.add(array);\n  assert.true(set.has(NaN));\n  assert.true(set.has(array));\n  assert.true(set.has(frozen));\n  assert.true(set.has(2));\n  assert.false(set.has(4));\n  assert.false(set.has([]));\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#size","suites":[],"line":246,"code":"QUnit.test('Set#size', assert => {\n  const set = new Set();\n  set.add(1);\n  const {\n    size\n  } = set;\n  assert.same(typeof size, 'number', 'size is number');\n  assert.same(size, 1, 'size is correct');\n\n  if (DESCRIPTORS) {\n    const sizeDescriptor = getOwnPropertyDescriptor(Set.prototype, 'size');\n    const getter = sizeDescriptor && sizeDescriptor.get;\n    const setter = sizeDescriptor && sizeDescriptor.set;\n    assert.same(typeof getter, 'function', 'size is getter');\n    assert.same(typeof setter, 'undefined', 'size isnt setter');\n    assert.throws(() => {\n      Set.prototype.size;\n    }, TypeError);\n  }\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set & -0","suites":[],"line":266,"code":"QUnit.test('Set & -0', assert => {\n  let set = new Set();\n  set.add(-0);\n  assert.same(set.size, 1);\n  assert.true(set.has(0));\n  assert.true(set.has(-0));\n  set.forEach(it => {\n    assert.false(is(it, -0));\n  });\n  set.delete(-0);\n  assert.same(set.size, 0);\n  set = new Set([-0]);\n  set.forEach(key => {\n    assert.false(is(key, -0));\n  });\n  set = new Set();\n  set.add(4);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(0);\n  assert.true(set.has(-0));\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#@@toStringTag","suites":[],"line":289,"code":"QUnit.test('Set#@@toStringTag', assert => {\n  assert.same(Set.prototype[Symbol.toStringTag], 'Set', 'Set::@@toStringTag is `Set`');\n  assert.same(String(new Set()), '[object Set]', 'correct stringification');\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set Iterator","suites":[],"line":293,"code":"QUnit.test('Set Iterator', assert => {\n  const set = new Set();\n  set.add('a');\n  set.add('b');\n  set.add('c');\n  set.add('d');\n  const results = [];\n  const iterator = set.keys();\n  results.push(iterator.next().value);\n  assert.true(set.delete('a'));\n  assert.true(set.delete('b'));\n  assert.true(set.delete('c'));\n  set.add('e');\n  results.push(iterator.next().value, iterator.next().value);\n  assert.true(iterator.next().done);\n  set.add('f');\n  assert.true(iterator.next().done);\n  assert.deepEqual(results, ['a', 'd', 'e']);\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#keys","suites":[],"line":312,"code":"QUnit.test('Set#keys', assert => {\n  assert.isFunction(Set.prototype.keys);\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#values","suites":[],"line":339,"code":"QUnit.test('Set#values', assert => {\n  assert.isFunction(Set.prototype.values);\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.values();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#entries","suites":[],"line":366,"code":"QUnit.test('Set#entries', assert => {\n  assert.isFunction(Set.prototype.entries);\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.entries();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['q', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['w', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['e', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#@@iterator","suites":[],"line":393,"code":"QUnit.test('Set#@@iterator', assert => {\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = getIterator(set);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.same(String(iterator), '[object Set Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/es.set.js","skipped":false,"dir":"tests"},{"name":"String#anchor","suites":[],"line":2,"code":"QUnit.test('String#anchor', assert => {\n  assert.isFunction(anchor);\n  assert.same(anchor('a', 'b'), '<a name=\"b\">a</a>', 'lower case');\n  assert.same(anchor('a', '\"'), '<a name=\"&quot;\">a</a>', 'escape quotes');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => anchor(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => anchor('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.string.anchor.js","skipped":false,"dir":"tests"},{"name":"String#at","suites":[],"line":4,"code":"QUnit.test('String#at', assert => {\n  assert.isFunction(at);\n  assert.same('1', at('123', 0));\n  assert.same('2', at('123', 1));\n  assert.same('3', at('123', 2));\n  assert.same(undefined, at('123', 3));\n  assert.same('3', at('123', -1));\n  assert.same('2', at('123', -2));\n  assert.same('1', at('123', -3));\n  assert.same(undefined, at('123', -4));\n  assert.same('1', at('123', 0.4));\n  assert.same('1', at('123', 0.5));\n  assert.same('1', at('123', 0.6));\n  assert.same('1', at('1', NaN));\n  assert.same('1', at('1'));\n  assert.same('1', at('123', -0)); // TODO: disabled by default because of the conflict with old proposal\n  // assert.same('\\uD842', at('𠮷'));\n\n  assert.same('1', at({\n    toString() {\n      return '123';\n    }\n\n  }, 0));\n  assert.throws(() => at(Symbol(), 0), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => at(null, 0), TypeError);\n    assert.throws(() => at(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.at-alternative.js","skipped":false,"dir":"tests"},{"name":"String#big","suites":[],"line":2,"code":"QUnit.test('String#big', assert => {\n  assert.isFunction(big);\n  assert.same(big('a'), '<big>a</big>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => big(Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.string.big.js","skipped":false,"dir":"tests"},{"name":"String#blink","suites":[],"line":2,"code":"QUnit.test('String#blink', assert => {\n  assert.isFunction(blink);\n  assert.same(blink('a'), '<blink>a</blink>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => blink(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.blink.js","skipped":false,"dir":"tests"},{"name":"String#bold","suites":[],"line":2,"code":"QUnit.test('String#bold', assert => {\n  assert.isFunction(bold);\n  assert.same(bold('a'), '<b>a</b>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => bold(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.bold.js","skipped":false,"dir":"tests"},{"name":"String#codePointAt","suites":[],"line":3,"code":"QUnit.test('String#codePointAt', assert => {\n  assert.isFunction(codePointAt);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', ''), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', '_'), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def'), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', -Infinity), undefined);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', -1), undefined);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', -0), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', 0), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', 3), 0x1D306);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', 4), 0xDF06);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', 5), 0x64);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', 42), undefined);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', Infinity), undefined);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', Infinity), undefined);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', NaN), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', false), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', null), 0x61);\n  assert.same(codePointAt('abc\\uD834\\uDF06def', undefined), 0x61);\n  assert.same(codePointAt('\\uD834\\uDF06def', ''), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', '1'), 0xDF06);\n  assert.same(codePointAt('\\uD834\\uDF06def', '_'), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def'), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', -1), undefined);\n  assert.same(codePointAt('\\uD834\\uDF06def', -0), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', 0), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', 1), 0xDF06);\n  assert.same(codePointAt('\\uD834\\uDF06def', 42), undefined);\n  assert.same(codePointAt('\\uD834\\uDF06def', false), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', null), 0x1D306);\n  assert.same(codePointAt('\\uD834\\uDF06def', undefined), 0x1D306);\n  assert.same(codePointAt('\\uD834abc', ''), 0xD834);\n  assert.same(codePointAt('\\uD834abc', '_'), 0xD834);\n  assert.same(codePointAt('\\uD834abc'), 0xD834);\n  assert.same(codePointAt('\\uD834abc', -1), undefined);\n  assert.same(codePointAt('\\uD834abc', -0), 0xD834);\n  assert.same(codePointAt('\\uD834abc', 0), 0xD834);\n  assert.same(codePointAt('\\uD834abc', false), 0xD834);\n  assert.same(codePointAt('\\uD834abc', NaN), 0xD834);\n  assert.same(codePointAt('\\uD834abc', null), 0xD834);\n  assert.same(codePointAt('\\uD834abc', undefined), 0xD834);\n  assert.same(codePointAt('\\uDF06abc', ''), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', '_'), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc'), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', -1), undefined);\n  assert.same(codePointAt('\\uDF06abc', -0), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', 0), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', false), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', NaN), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', null), 0xDF06);\n  assert.same(codePointAt('\\uDF06abc', undefined), 0xDF06);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => codePointAt(Symbol(), 1), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => codePointAt(null, 0), TypeError);\n    assert.throws(() => codePointAt(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.code-point-at.js","skipped":false,"dir":"tests"},{"name":"String#endsWith","suites":[],"line":4,"code":"QUnit.test('String#endsWith', assert => {\n  assert.isFunction(endsWith);\n  assert.true(endsWith('undefined'));\n  assert.false(endsWith('undefined', null));\n  assert.true(endsWith('abc', ''));\n  assert.true(endsWith('abc', 'c'));\n  assert.true(endsWith('abc', 'bc'));\n  assert.false(endsWith('abc', 'ab'));\n  assert.true(endsWith('abc', '', NaN));\n  assert.false(endsWith('abc', 'c', -1));\n  assert.true(endsWith('abc', 'a', 1));\n  assert.true(endsWith('abc', 'c', Infinity));\n  assert.true(endsWith('abc', 'a', true));\n  assert.false(endsWith('abc', 'c', 'x'));\n  assert.false(endsWith('abc', 'a', 'x'));\n\n  if (!Symbol.sham) {\n    assert.throws(() => endsWith(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => endsWith('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => endsWith(null, '.'), TypeError);\n    assert.throws(() => endsWith(undefined, '.'), TypeError);\n  }\n\n  const regexp = /./;\n  assert.throws(() => endsWith('/./', regexp), TypeError);\n  regexp[Symbol.match] = false;\n  assert.notThrows(() => endsWith('/./', regexp));\n  const object = {};\n  assert.notThrows(() => endsWith('[object Object]', object));\n  object[Symbol.match] = true;\n  assert.throws(() => endsWith('[object Object]', object), TypeError);\n});","file":"pure/es.string.ends-with.js","skipped":false,"dir":"tests"},{"name":"String#fixed","suites":[],"line":2,"code":"QUnit.test('String#fixed', assert => {\n  assert.isFunction(fixed);\n  assert.same(fixed('a'), '<tt>a</tt>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => fixed(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.fixed.js","skipped":false,"dir":"tests"},{"name":"String#fontcolor","suites":[],"line":2,"code":"QUnit.test('String#fontcolor', assert => {\n  assert.isFunction(fontcolor);\n  assert.same(fontcolor('a', 'b'), '<font color=\"b\">a</font>', 'lower case');\n  assert.same(fontcolor('a', '\"'), '<font color=\"&quot;\">a</font>', 'escape quotes');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => fontcolor(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => fontcolor('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.string.fontcolor.js","skipped":false,"dir":"tests"},{"name":"String#fontsize","suites":[],"line":2,"code":"QUnit.test('String#fontsize', assert => {\n  assert.isFunction(fontsize);\n  assert.same(fontsize('a', 'b'), '<font size=\"b\">a</font>', 'lower case');\n  assert.same(fontsize('a', '\"'), '<font size=\"&quot;\">a</font>', 'escape quotes');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => fontsize(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => fontsize('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.string.fontsize.js","skipped":false,"dir":"tests"},{"name":"String.fromCodePoint","suites":[],"line":2,"code":"QUnit.test('String.fromCodePoint', assert => {\n  assert.isFunction(fromCodePoint);\n  assert.arity(fromCodePoint, 1);\n\n  if ('name' in fromCodePoint) {\n    assert.name(fromCodePoint, 'fromCodePoint');\n  }\n\n  assert.same(fromCodePoint(''), '\\0');\n  assert.same(fromCodePoint(), '');\n  assert.same(fromCodePoint(-0), '\\0');\n  assert.same(fromCodePoint(0), '\\0');\n  assert.same(fromCodePoint(0x1D306), '\\uD834\\uDF06');\n  assert.same(fromCodePoint(0x1D306, 0x61, 0x1D307), '\\uD834\\uDF06a\\uD834\\uDF07');\n  assert.same(fromCodePoint(0x61, 0x62, 0x1D307), 'ab\\uD834\\uDF07');\n  assert.same(fromCodePoint(false), '\\0');\n  assert.same(fromCodePoint(null), '\\0');\n  assert.throws(() => fromCodePoint('_'), RangeError);\n  assert.throws(() => fromCodePoint('+Infinity'), RangeError);\n  assert.throws(() => fromCodePoint('-Infinity'), RangeError);\n  assert.throws(() => fromCodePoint(-1), RangeError);\n  assert.throws(() => fromCodePoint(0x10FFFF + 1), RangeError);\n  assert.throws(() => fromCodePoint(3.14), RangeError);\n  assert.throws(() => fromCodePoint(3e-2), RangeError);\n  assert.throws(() => fromCodePoint(-Infinity), RangeError);\n  assert.throws(() => fromCodePoint(Infinity), RangeError);\n  assert.throws(() => fromCodePoint(NaN), RangeError);\n  assert.throws(() => fromCodePoint(undefined), RangeError);\n  assert.throws(() => fromCodePoint({}), RangeError);\n  assert.throws(() => fromCodePoint(/./), RangeError);\n  let number = 0x60;\n  assert.same(fromCodePoint({\n    valueOf() {\n      return ++number;\n    }\n\n  }), 'a');\n  assert.same(number, 0x61); // one code unit per symbol\n\n  let counter = 2 ** 15 * 3 / 2;\n  let result = [];\n\n  while (--counter >= 0) result.push(0); // should not throw\n\n\n  fromCodePoint.apply(null, result);\n  counter = 2 ** 15 * 3 / 2;\n  result = [];\n\n  while (--counter >= 0) result.push(0xFFFF + 1); // should not throw\n\n\n  fromCodePoint.apply(null, result);\n});","file":"pure/es.string.from-code-point.js","skipped":false,"dir":"tests"},{"name":"String#includes","suites":[],"line":4,"code":"QUnit.test('String#includes', assert => {\n  assert.isFunction(includes);\n  assert.false(includes('abc'));\n  assert.true(includes('aundefinedb'));\n  assert.true(includes('abcd', 'b', 1));\n  assert.false(includes('abcd', 'b', 2));\n\n  if (!Symbol.sham) {\n    assert.throws(() => includes(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => includes('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => includes(null, '.'), TypeError);\n    assert.throws(() => includes(undefined, '.'), TypeError);\n  }\n\n  const re = /./;\n  assert.throws(() => includes('/./', re), TypeError);\n  re[Symbol.match] = false;\n  assert.notThrows(() => includes('/./', re));\n  const O = {};\n  assert.notThrows(() => includes('[object Object]', O));\n  O[Symbol.match] = true;\n  assert.throws(() => includes('[object Object]', O), TypeError);\n});","file":"pure/es.string.includes.js","skipped":false,"dir":"tests"},{"name":"String#italics","suites":[],"line":2,"code":"QUnit.test('String#italics', assert => {\n  assert.isFunction(italics);\n  assert.same(italics('a'), '<i>a</i>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => italics(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.italics.js","skipped":false,"dir":"tests"},{"name":"String#@@iterator","suites":[],"line":5,"code":"QUnit.test('String#@@iterator', assert => {\n  let iterator = getIterator('qwe');\n  assert.isIterator(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'String Iterator');\n  assert.same(String(iterator), '[object String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.same(from('𠮷𠮷𠮷').length, 3);\n  iterator = getIterator('𠮷𠮷𠮷');\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => getIteratorMethod('').call(Symbol()), 'throws on symbol context');\n});","file":"pure/es.string.iterator.js","skipped":false,"dir":"tests"},{"name":"String#link","suites":[],"line":2,"code":"QUnit.test('String#link', assert => {\n  assert.isFunction(link);\n  assert.same(link('a', 'b'), '<a href=\"b\">a</a>', 'lower case');\n  assert.same(link('a', '\"'), '<a href=\"&quot;\">a</a>', 'escape quotes');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => link(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => link('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.string.link.js","skipped":false,"dir":"tests"},{"name":"String#matchAll","suites":[],"line":5,"code":"QUnit.test('String#matchAll', assert => {\n  assert.isFunction(matchAll);\n  let data = ['aabc', {\n    toString() {\n      return 'aabc';\n    }\n\n  }];\n\n  for (const target of data) {\n    const iterator = matchAll(target, /[ac]/g);\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.deepEqual(iterator.next(), {\n      value: assign(['a'], {\n        input: 'aabc',\n        index: 0\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: assign(['a'], {\n        input: 'aabc',\n        index: 1\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: assign(['c'], {\n        input: 'aabc',\n        index: 3\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    });\n  }\n\n  let iterator = matchAll('1111a2b3cccc', /(\\d)(\\D)/g);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'RegExp String Iterator');\n  assert.same(String(iterator), '[object RegExp String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: assign(['1a', '1', 'a'], {\n      input: '1111a2b3cccc',\n      index: 3\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['2b', '2', 'b'], {\n      input: '1111a2b3cccc',\n      index: 5\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['3c', '3', 'c'], {\n      input: '1111a2b3cccc',\n      index: 7\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => matchAll('1111a2b3cccc', /(\\d)(\\D)/), TypeError);\n  iterator = matchAll('1111a2b3cccc', '(\\\\d)(\\\\D)');\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: assign(['1a', '1', 'a'], {\n      input: '1111a2b3cccc',\n      index: 3\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['2b', '2', 'b'], {\n      input: '1111a2b3cccc',\n      index: 5\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['3c', '3', 'c'], {\n      input: '1111a2b3cccc',\n      index: 7\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* IE8- issue\n  iterator = matchAll('abc', /\\B/g);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: assign([''], {\n      input: 'abc',\n      index: 1,\n    }),\n    done: false,\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign([''], {\n      input: 'abc',\n      index: 2,\n    }),\n    done: false,\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true,\n  });\n  */\n\n  data = [null, undefined, NaN, 42, {}, []];\n\n  for (const target of data) {\n    assert.notThrows(() => matchAll('', target), `Not throws on ${target} as the first argument`);\n  }\n\n  assert.throws(() => matchAll(Symbol(), /./), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => matchAll(null, /./g), TypeError, 'Throws on null as `this`');\n    assert.throws(() => matchAll(undefined, /./g), TypeError, 'Throws on undefined as `this`');\n  }\n});","file":"pure/es.string.match-all.js","skipped":false,"dir":"tests"},{"name":"String#padEnd","suites":[],"line":4,"code":"QUnit.test('String#padEnd', assert => {\n  assert.isFunction(padEnd);\n  assert.same(padEnd('abc', 5), 'abc  ');\n  assert.same(padEnd('abc', 4, 'de'), 'abcd');\n  assert.same(padEnd('abc'), 'abc');\n  assert.same(padEnd('abc', 5, '_'), 'abc__');\n  assert.same(padEnd('', 0), '');\n  assert.same(padEnd('foo', 1), 'foo');\n  assert.same(padEnd('foo', 5, ''), 'foo');\n  assert.throws(() => padEnd(Symbol(), 10, 'a'), 'throws on symbol context');\n  assert.throws(() => padEnd('a', 10, Symbol()), 'throws on symbol argument');\n\n  if (STRICT) {\n    assert.throws(() => padEnd(null, 0), TypeError);\n    assert.throws(() => padEnd(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.pad-end.js","skipped":false,"dir":"tests"},{"name":"String#padStart","suites":[],"line":4,"code":"QUnit.test('String#padStart', assert => {\n  assert.isFunction(padStart);\n  assert.same(padStart('abc', 5), '  abc');\n  assert.same(padStart('abc', 4, 'de'), 'dabc');\n  assert.same(padStart('abc'), 'abc');\n  assert.same(padStart('abc', 5, '_'), '__abc');\n  assert.same(padStart('', 0), '');\n  assert.same(padStart('foo', 1), 'foo');\n  assert.same(padStart('foo', 5, ''), 'foo');\n  assert.throws(() => padStart(Symbol(), 10, 'a'), 'throws on symbol context');\n  assert.throws(() => padStart('a', 10, Symbol()), 'throws on symbol argument');\n\n  if (STRICT) {\n    assert.throws(() => padStart(null, 0), TypeError);\n    assert.throws(() => padStart(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.pad-start.js","skipped":false,"dir":"tests"},{"name":"String.raw","suites":[],"line":2,"code":"QUnit.test('String.raw', assert => {\n  assert.isFunction(raw);\n  assert.arity(raw, 1);\n\n  if ('name' in raw) {\n    assert.name(raw, 'raw');\n  }\n\n  assert.same(raw({\n    raw: ['Hi\\\\n', '!']\n  }, 'Bob'), 'Hi\\\\nBob!', 'raw is array');\n  assert.same(raw({\n    raw: 'test'\n  }, 0, 1, 2), 't0e1s2t', 'raw is string');\n  assert.same(raw({\n    raw: 'test'\n  }, 0), 't0est', 'lacks substituting');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => raw({\n      raw: [Symbol()]\n    }, 0), TypeError, 'throws on symbol #1');\n    assert.throws(() => raw({\n      raw: 'test'\n    }, Symbol()), TypeError, 'throws on symbol #2');\n  }\n\n  assert.throws(() => raw({}), TypeError);\n  assert.throws(() => raw({\n    raw: null\n  }), TypeError);\n});","file":"pure/es.string.raw.js","skipped":false,"dir":"tests"},{"name":"String#repeat","suites":[],"line":3,"code":"QUnit.test('String#repeat', assert => {\n  assert.isFunction(repeat);\n  assert.same(repeat('qwe', 3), 'qweqweqwe');\n  assert.same(repeat('qwe', 2.5), 'qweqwe');\n  assert.throws(() => repeat('qwe', -1), RangeError);\n  assert.throws(() => repeat('qwe', Infinity), RangeError);\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => repeat(Symbol()), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => repeat(null, 1), TypeError);\n    assert.throws(() => repeat(undefined, 1), TypeError);\n  }\n});","file":"pure/es.string.repeat.js","skipped":false,"dir":"tests"},{"name":"String#replaceAll","suites":[],"line":4,"code":"QUnit.test('String#replaceAll', assert => {\n  assert.isFunction(replaceAll);\n  assert.same(replaceAll('q=query+string+parameters', '+', ' '), 'q=query string parameters');\n  assert.same(replaceAll('foo', 'o', {}), 'f[object Object][object Object]');\n  assert.same(replaceAll('[object Object]x[object Object]', {}, 'y'), 'yxy');\n  assert.same(replaceAll({}, 'bject', 'lolo'), '[ololo Ololo]');\n  assert.same(replaceAll('aba', 'b', (search, i, string) => {\n    assert.same(search, 'b', '`search` is `b`');\n    assert.same(i, 1, '`i` is 1');\n    assert.same(string, 'aba', '`string` is `aba`');\n    return 'c';\n  }), 'aca');\n  const searcher = {\n    [Symbol.replace](O, replaceValue) {\n      assert.same(this, searcher, '`this` is `searcher`');\n      assert.same(String(O), 'aba', '`O` is `aba`');\n      assert.same(String(replaceValue), 'c', '`replaceValue` is `c`');\n      return 'foo';\n    }\n\n  };\n  assert.same(replaceAll('aba', searcher, 'c'), 'foo');\n  assert.same(replaceAll('aba', 'b'), 'aundefineda');\n  assert.same(replaceAll('xxx', '', '_'), '_x_x_x_');\n  assert.same(replaceAll('121314', '1', '$$'), '$2$3$4', '$$');\n  assert.same(replaceAll('121314', '1', '$&'), '121314', '$&');\n  assert.same(replaceAll('121314', '1', '$`'), '212312134', '$`');\n  assert.same(replaceAll('121314', '1', '$\\''), '213142314344', '$\\'');\n  assert.throws(() => replaceAll(Symbol(), 'a', 'b'), 'throws on symbol context');\n  assert.throws(() => replaceAll('a', Symbol(), 'b'), 'throws on symbol argument 1');\n  assert.throws(() => replaceAll('a', 'b', Symbol()), 'throws on symbol argument 2');\n\n  if (STRICT) {\n    assert.throws(() => replaceAll(null, 'a', 'b'), TypeError);\n    assert.throws(() => replaceAll(undefined, 'a', 'b'), TypeError);\n  }\n\n  assert.throws(() => replaceAll('b.b.b.b.b', /\\./, 'a'), TypeError);\n  assert.same(replaceAll('b.b.b.b.b', /\\./g, 'a'), 'babababab');\n  const object = {};\n  assert.same(replaceAll('[object Object]', object, 'a'), 'a');\n});","file":"pure/es.string.replace-all.js","skipped":false,"dir":"tests"},{"name":"String#small","suites":[],"line":2,"code":"QUnit.test('String#small', assert => {\n  assert.isFunction(small);\n  assert.same(small('a'), '<small>a</small>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => small(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.small.js","skipped":false,"dir":"tests"},{"name":"String#startsWith","suites":[],"line":4,"code":"QUnit.test('String#startsWith', assert => {\n  assert.isFunction(startsWith);\n  assert.true(startsWith('undefined'));\n  assert.false(startsWith('undefined', null));\n  assert.true(startsWith('abc', ''));\n  assert.true(startsWith('abc', 'a'));\n  assert.true(startsWith('abc', 'ab'));\n  assert.false(startsWith('abc', 'bc'));\n  assert.true(startsWith('abc', '', NaN));\n  assert.true(startsWith('abc', 'a', -1));\n  assert.false(startsWith('abc', 'a', 1));\n  assert.false(startsWith('abc', 'a', Infinity));\n  assert.true(startsWith('abc', 'b', true));\n  assert.true(startsWith('abc', 'a', 'x'));\n\n  if (!Symbol.sham) {\n    assert.throws(() => startsWith(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => startsWith('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => startsWith(null, '.'), TypeError);\n    assert.throws(() => startsWith(undefined, '.'), TypeError);\n  }\n\n  const regexp = /./;\n  assert.throws(() => startsWith('/./', regexp), TypeError);\n  regexp[Symbol.match] = false;\n  assert.notThrows(() => startsWith('/./', regexp));\n  const object = {};\n  assert.notThrows(() => startsWith('[object Object]', object));\n  object[Symbol.match] = true;\n  assert.throws(() => startsWith('[object Object]', object), TypeError);\n});","file":"pure/es.string.starts-with.js","skipped":false,"dir":"tests"},{"name":"String#strike","suites":[],"line":2,"code":"QUnit.test('String#strike', assert => {\n  assert.isFunction(strike);\n  assert.same(strike('a'), '<strike>a</strike>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => strike(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.strike.js","skipped":false,"dir":"tests"},{"name":"String#sub","suites":[],"line":2,"code":"QUnit.test('String#sub', assert => {\n  assert.isFunction(sub);\n  assert.same(sub('a'), '<sub>a</sub>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => sub(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.sub.js","skipped":false,"dir":"tests"},{"name":"String#substr","suites":[],"line":3,"code":"QUnit.test('String#substr', assert => {\n  assert.isFunction(substr);\n  assert.same(substr('12345', 1, 3), '234');\n  assert.same(substr('ab', -1), 'b');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => substr(Symbol(), 1, 3), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => substr(null, 1, 3), TypeError, 'Throws on null as `this`');\n    assert.throws(() => substr(undefined, 1, 3), TypeError, 'Throws on undefined as `this`');\n  }\n});","file":"pure/es.string.substr.js","skipped":false,"dir":"tests"},{"name":"String#sup","suites":[],"line":2,"code":"QUnit.test('String#sup', assert => {\n  assert.isFunction(sup);\n  assert.same(sup('a'), '<sup>a</sup>', 'lower case');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => sup(Symbol()), 'throws on symbol context');\n  }\n});","file":"pure/es.string.sup.js","skipped":false,"dir":"tests"},{"name":"String#trimRight","suites":[],"line":5,"code":"QUnit.test('String#trimRight', assert => {\n  assert.isFunction(trimRight);\n  assert.same(trimRight(' \\n  q w e \\n  '), ' \\n  q w e', 'removes whitespaces at right side of string');\n  assert.same(trimRight(WHITESPACES), '', 'removes all whitespaces');\n  assert.same(trimRight('\\u200B\\u0085'), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimRight(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimRight(null, 0), TypeError);\n    assert.throws(() => trimRight(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.trim-end.js","skipped":false,"dir":"tests"},{"name":"String#trimEnd","suites":[],"line":17,"code":"QUnit.test('String#trimEnd', assert => {\n  assert.isFunction(trimEnd);\n  assert.same(trimEnd(' \\n  q w e \\n  '), ' \\n  q w e', 'removes whitespaces at right side of string');\n  assert.same(trimEnd(WHITESPACES), '', 'removes all whitespaces');\n  assert.same(trimEnd('\\u200B\\u0085'), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimEnd(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimEnd(null, 0), TypeError);\n    assert.throws(() => trimEnd(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.trim-end.js","skipped":false,"dir":"tests"},{"name":"String#trimLeft","suites":[],"line":5,"code":"QUnit.test('String#trimLeft', assert => {\n  assert.isFunction(trimLeft);\n  assert.same(trimLeft(' \\n  q w e \\n  '), 'q w e \\n  ', 'removes whitespaces at left side of string');\n  assert.same(trimLeft(WHITESPACES), '', 'removes all whitespaces');\n  assert.same(trimLeft('\\u200B\\u0085'), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimLeft(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimLeft(null, 0), TypeError);\n    assert.throws(() => trimLeft(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.trim-start.js","skipped":false,"dir":"tests"},{"name":"String#trimStart","suites":[],"line":17,"code":"QUnit.test('String#trimStart', assert => {\n  assert.isFunction(trimStart);\n  assert.same(trimStart(' \\n  q w e \\n  '), 'q w e \\n  ', 'removes whitespaces at left side of string');\n  assert.same(trimStart(WHITESPACES), '', 'removes all whitespaces');\n  assert.same(trimStart('\\u200B\\u0085'), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimStart(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimStart(null, 0), TypeError);\n    assert.throws(() => trimStart(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.trim-start.js","skipped":false,"dir":"tests"},{"name":"String#trim","suites":[],"line":3,"code":"QUnit.test('String#trim', assert => {\n  assert.isFunction(trim);\n  assert.same(trim(' \\n  q w e \\n  '), 'q w e', 'removes whitespaces at left & right side of string');\n  assert.same(trim(WHITESPACES), '', 'removes all whitespaces');\n  assert.same(trim('\\u200B\\u0085'), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => trim(Symbol()), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => trim(null, 0), TypeError);\n    assert.throws(() => trim(undefined, 0), TypeError);\n  }\n});","file":"pure/es.string.trim.js","skipped":false,"dir":"tests"},{"name":"Symbol.asyncIterator","suites":[],"line":2,"code":"QUnit.test('Symbol.asyncIterator', assert => {\n  assert.true('asyncIterator' in Symbol, 'Symbol.asyncIterator available');\n  assert.true(Object(Symbol.asyncIterator) instanceof Symbol, 'Symbol.asyncIterator is symbol');\n});","file":"pure/es.symbol.async-iterator.js","skipped":false,"dir":"tests"},{"name":"Symbol","suites":[],"line":14,"code":"QUnit.test('Symbol', assert => {\n  assert.isFunction(Symbol);\n  const symbol1 = Symbol('symbol');\n  const symbol2 = Symbol('symbol');\n  assert.notSame(symbol1, symbol2, 'Symbol(\"symbol\") !== Symbol(\"symbol\")');\n  const object = {};\n  object[symbol1] = 42;\n  assert.same(object[symbol1], 42, 'Symbol() work as key');\n  assert.notSame(object[symbol2], 42, 'Various symbols from one description are various keys'); // assert.throws(() => Symbol(Symbol('foo')), 'throws on symbol argument');\n\n  if (DESCRIPTORS) {\n    let count = 0; // eslint-disable-next-line no-unused-vars -- required for testing\n\n    for (const key in object) count++;\n\n    assert.same(count, 0, 'object[Symbol()] is not enumerable');\n  }\n});","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Well-known Symbols","suites":[],"line":32,"code":"QUnit.test('Well-known Symbols', assert => {\n  const wks = ['hasInstance', 'isConcatSpreadable', 'iterator', 'match', 'matchAll', 'replace', 'search', 'species', 'split', 'toPrimitive', 'toStringTag', 'unscopables'];\n\n  for (const name of wks) {\n    assert.true(name in Symbol, `Symbol.${name} available`);\n    assert.true(Object(Symbol[name]) instanceof Symbol, `Symbol.${name} is symbol`);\n  }\n});","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol#@@toPrimitive","suites":[],"line":40,"code":"QUnit.test('Symbol#@@toPrimitive', assert => {\n  const symbol = Symbol();\n  assert.isFunction(Symbol.prototype[Symbol.toPrimitive]);\n  assert.same(symbol, symbol[Symbol.toPrimitive](), 'works');\n});","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol#@@toStringTag","suites":[],"line":45,"code":"QUnit.test('Symbol#@@toStringTag', assert => {\n  assert.same(Symbol.prototype[Symbol.toStringTag], 'Symbol', 'Symbol::@@toStringTag is `Symbol`');\n});","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & descriptors","suites":[],"line":50,"code":"  QUnit.test('Symbols & descriptors', assert => {\n    const d = Symbol('d');\n    const e = Symbol('e');\n    const f = Symbol('f');\n    const i = Symbol('i');\n    const j = Symbol('j');\n    const prototype = {\n      g: 'g'\n    };\n    prototype[i] = 'i';\n    defineProperty(prototype, 'h', {\n      value: 'h'\n    });\n    defineProperty(prototype, 'j', {\n      value: 'j'\n    });\n    const object = create(prototype);\n    object.a = 'a';\n    object[d] = 'd';\n    defineProperty(object, 'b', {\n      value: 'b'\n    });\n    defineProperty(object, 'c', {\n      value: 'c',\n      enumerable: true\n    });\n    defineProperty(object, e, {\n      configurable: true,\n      writable: true,\n      value: 'e'\n    });\n    const descriptor = {\n      value: 'f',\n      enumerable: true\n    };\n    defineProperty(object, f, descriptor);\n    assert.true(descriptor.enumerable, 'defineProperty not changes descriptor object');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'a'), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'a'\n    }, 'getOwnPropertyDescriptor a');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'b'), {\n      configurable: false,\n      writable: false,\n      enumerable: false,\n      value: 'b'\n    }, 'getOwnPropertyDescriptor b');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'c'), {\n      configurable: false,\n      writable: false,\n      enumerable: true,\n      value: 'c'\n    }, 'getOwnPropertyDescriptor c');\n    assert.deepEqual(getOwnPropertyDescriptor(object, d), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'd'\n    }, 'getOwnPropertyDescriptor d');\n    assert.deepEqual(getOwnPropertyDescriptor(object, e), {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: 'e'\n    }, 'getOwnPropertyDescriptor e');\n    assert.deepEqual(getOwnPropertyDescriptor(object, f), {\n      configurable: false,\n      writable: false,\n      enumerable: true,\n      value: 'f'\n    }, 'getOwnPropertyDescriptor f');\n    assert.same(getOwnPropertyDescriptor(object, 'g'), undefined, 'getOwnPropertyDescriptor g');\n    assert.same(getOwnPropertyDescriptor(object, 'h'), undefined, 'getOwnPropertyDescriptor h');\n    assert.same(getOwnPropertyDescriptor(object, i), undefined, 'getOwnPropertyDescriptor i');\n    assert.same(getOwnPropertyDescriptor(object, j), undefined, 'getOwnPropertyDescriptor j');\n    assert.same(getOwnPropertyDescriptor(object, 'k'), undefined, 'getOwnPropertyDescriptor k');\n    assert.false(getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable, 'getOwnPropertyDescriptor on Object.prototype');\n    assert.same(getOwnPropertyDescriptor(Object.prototype, d), undefined, 'getOwnPropertyDescriptor on Object.prototype missed symbol');\n    assert.same(keys(object).length, 2, 'Object.keys');\n    assert.same(getOwnPropertyNames(object).length, 3, 'Object.getOwnPropertyNames');\n    assert.same(getOwnPropertySymbols(object).length, 3, 'Object.getOwnPropertySymbols');\n    assert.same(ownKeys(object).length, 6, 'Reflect.ownKeys');\n    delete object[e];\n    object[e] = 'e';\n    assert.deepEqual(getOwnPropertyDescriptor(object, e), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'e'\n    }, 'redefined non-enum key');\n  });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & Object.defineProperties","suites":[],"line":143,"code":"  QUnit.test('Symbols & Object.defineProperties', assert => {\n    const c = Symbol('c');\n    const d = Symbol('d');\n    const descriptors = {\n      a: {\n        value: 'a'\n      }\n    };\n    descriptors[c] = {\n      value: 'c'\n    };\n    defineProperty(descriptors, 'b', {\n      value: {\n        value: 'b'\n      }\n    });\n    defineProperty(descriptors, d, {\n      value: {\n        value: 'd'\n      }\n    });\n    const object = defineProperties({}, descriptors);\n    assert.same(object.a, 'a', 'a');\n    assert.same(object.b, undefined, 'b');\n    assert.same(object[c], 'c', 'c');\n    assert.same(object[d], undefined, 'd');\n  });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & Object.create","suites":[],"line":170,"code":"  QUnit.test('Symbols & Object.create', assert => {\n    const c = Symbol('c');\n    const d = Symbol('d');\n    const descriptors = {\n      a: {\n        value: 'a'\n      }\n    };\n    descriptors[c] = {\n      value: 'c'\n    };\n    defineProperty(descriptors, 'b', {\n      value: {\n        value: 'b'\n      }\n    });\n    defineProperty(descriptors, d, {\n      value: {\n        value: 'd'\n      }\n    });\n    const object = create(null, descriptors);\n    assert.same(object.a, 'a', 'a');\n    assert.same(object.b, undefined, 'b');\n    assert.same(object[c], 'c', 'c');\n    assert.same(object[d], undefined, 'd');\n  });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"@@species","suites":[],"line":204,"code":"    QUnit.test(`${name}@@species`, assert => {\n      assert.same(constructors[name][Symbol.species], constructors[name], `${name}@@species === ${name}`);\n      const Subclass = create(constructors[name]);\n      assert.same(Subclass[Symbol.species], Subclass, `${name} subclass`);\n    });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Array@@species","suites":[],"line":211,"code":"  QUnit.test('Array@@species', assert => {\n    assert.same(Array[Symbol.species], Array, 'Array@@species === Array');\n    const Subclass = create(Array);\n    assert.same(Subclass[Symbol.species], Subclass, 'Array subclass');\n  });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol.sham flag","suites":[],"line":216,"code":"  QUnit.test('Symbol.sham flag', assert => {\n    assert.same(Symbol.sham, typeof Symbol() == 'symbol' ? undefined : true);\n  });","file":"pure/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol.for","suites":[],"line":2,"code":"QUnit.test('Symbol.for', assert => {\n  assert.isFunction(Symbol.for, 'Symbol.for is function');\n  const symbol = Symbol.for('foo');\n  assert.strictEqual(Symbol.for('foo'), symbol, 'registry');\n  assert.true(Object(symbol) instanceof Symbol, 'returns symbol');\n  assert.throws(() => Symbol.for(Symbol('foo')), 'throws on symbol argument');\n});","file":"pure/es.symbol.for.js","skipped":false,"dir":"tests"},{"name":"Symbol.keyFor","suites":[],"line":2,"code":"QUnit.test('Symbol.keyFor', assert => {\n  assert.isFunction(Symbol.keyFor, 'Symbol.keyFor is function');\n  assert.strictEqual(Symbol.keyFor(Symbol.for('foo')), 'foo');\n  assert.strictEqual(Symbol.keyFor(Symbol('foo')), undefined);\n  assert.throws(() => Symbol.keyFor('foo'), 'throws on non-symbol');\n});","file":"pure/es.symbol.key-for.js","skipped":false,"dir":"tests"},{"name":"unescape","suites":[],"line":2,"code":"QUnit.test('unescape', assert => {\n  assert.isFunction(unescape);\n  assert.arity(unescape, 1);\n  assert.same(unescape('%21q2%u0444'), '!q2ф');\n  assert.same(unescape('%u044q2%21'), '%u044q2!');\n  assert.same(unescape(null), 'null');\n  assert.same(unescape(undefined), 'undefined');\n  /* eslint-disable es-x/no-symbol -- safe */\n\n  if (typeof Symbol == 'function') {\n    assert.throws(() => unescape(Symbol()), 'throws on symbol argument');\n  }\n});","file":"pure/es.unescape.js","skipped":false,"dir":"tests"},{"name":"WeakMap","suites":[],"line":11,"code":"QUnit.test('WeakMap', assert => {\n  assert.isFunction(WeakMap);\n  assert.true('delete' in WeakMap.prototype, 'delete in WeakMap.prototype');\n  assert.true('get' in WeakMap.prototype, 'get in WeakMap.prototype');\n  assert.true('has' in WeakMap.prototype, 'has in WeakMap.prototype');\n  assert.true('set' in WeakMap.prototype, 'set in WeakMap.prototype');\n  assert.true(new WeakMap() instanceof WeakMap, 'new WeakMap instanceof WeakMap');\n  let object = {};\n  assert.same(new WeakMap(createIterable([[object, 42]])).get(object), 42, 'Init from iterable');\n  let weakmap = new WeakMap();\n  const frozen = freeze({});\n  weakmap.set(frozen, 42);\n  assert.same(weakmap.get(frozen), 42, 'Support frozen objects');\n  weakmap = new WeakMap();\n  weakmap.set(frozen, 42);\n  assert.true(weakmap.has(frozen), 'works with frozen objects, #1');\n  assert.same(weakmap.get(frozen), 42, 'works with frozen objects, #2');\n  weakmap.delete(frozen);\n  assert.false(weakmap.has(frozen), 'works with frozen objects, #3');\n  assert.same(weakmap.get(frozen), undefined, 'works with frozen objects, #4');\n  let done = false;\n\n  try {\n    new WeakMap(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  assert.false('clear' in WeakMap.prototype, 'should not contains `.clear` method');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  new WeakMap(array);\n  assert.true(done);\n  object = {};\n  new WeakMap().set(object, 1);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(WeakMap);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof WeakMap, 'correct subclassing with native classes #2');\n    object = {};\n    assert.same(new Subclass().set(object, 2).get(object), 2, 'correct subclassing with native classes #3');\n  }\n\n  if (typeof ArrayBuffer == 'function') {\n    const buffer = new ArrayBuffer(8);\n    const map = new WeakMap([[buffer, 8]]);\n    assert.true(map.has(buffer), 'works with ArrayBuffer keys');\n  }\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#delete","suites":[],"line":87,"code":"QUnit.test('WeakMap#delete', assert => {\n  assert.isFunction(WeakMap.prototype.delete);\n  const a = {};\n  const b = {};\n  const weakmap = new WeakMap();\n  weakmap.set(a, 42);\n  weakmap.set(b, 21);\n  assert.true(weakmap.has(a), 'WeakMap has values before .delete() #1');\n  assert.true(weakmap.has(b), 'WeakMap has values before .delete() #2');\n  weakmap.delete(a);\n  assert.false(weakmap.has(a), 'WeakMap hasn`t value after .delete() #1');\n  assert.true(weakmap.has(b), 'WeakMap hasn`t value after .delete() #2');\n  assert.notThrows(() => !weakmap.delete(1), 'return false on primitive');\n  const object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.true(weakmap.has(object), 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'works with frozen objects #2');\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#get","suites":[],"line":107,"code":"QUnit.test('WeakMap#get', assert => {\n  assert.isFunction(WeakMap.prototype.get);\n  const weakmap = new WeakMap();\n  assert.same(weakmap.get({}), undefined, 'WeakMap .get() before .set() return undefined');\n  let object = {};\n  weakmap.set(object, 42);\n  assert.same(weakmap.get(object), 42, 'WeakMap .get() return value');\n  weakmap.delete(object);\n  assert.same(weakmap.get(object), undefined, 'WeakMap .get() after .delete() return undefined');\n  assert.notThrows(() => weakmap.get(1) === undefined, 'return undefined on primitive');\n  object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.same(weakmap.get(object), 42, 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.same(weakmap.get(object), undefined, 'works with frozen objects #2');\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#has","suites":[],"line":124,"code":"QUnit.test('WeakMap#has', assert => {\n  assert.isFunction(WeakMap.prototype.has);\n  const weakmap = new WeakMap();\n  assert.false(weakmap.has({}), 'WeakMap .has() before .set() return false');\n  let object = {};\n  weakmap.set(object, 42);\n  assert.true(weakmap.has(object), 'WeakMap .has() return true');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'WeakMap .has() after .delete() return false');\n  assert.notThrows(() => !weakmap.has(1), 'return false on primitive');\n  object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.true(weakmap.has(object), 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'works with frozen objects #2');\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#set","suites":[],"line":141,"code":"QUnit.test('WeakMap#set', assert => {\n  assert.isFunction(WeakMap.prototype.set);\n  const weakmap = new WeakMap();\n  const object = {};\n  weakmap.set(object, 33);\n  assert.same(weakmap.get(object), 33, 'works with object as keys');\n  assert.same(weakmap.set({}, 42), weakmap, 'chaining');\n  assert.throws(() => new WeakMap().set(42, 42), 'throws with primitive keys');\n  const object1 = freeze({});\n  const object2 = {};\n  weakmap.set(object1, 42);\n  weakmap.set(object2, 42);\n  freeze(object);\n  assert.same(weakmap.get(object1), 42, 'works with frozen objects #1');\n  assert.same(weakmap.get(object2), 42, 'works with frozen objects #2');\n  weakmap.delete(object1);\n  weakmap.delete(object2);\n  assert.same(weakmap.get(object1), undefined, 'works with frozen objects #3');\n  assert.same(weakmap.get(object2), undefined, 'works with frozen objects #4');\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#@@toStringTag","suites":[],"line":161,"code":"QUnit.test('WeakMap#@@toStringTag', assert => {\n  assert.same(WeakMap.prototype[Symbol.toStringTag], 'WeakMap', 'WeakMap::@@toStringTag is `WeakMap`');\n  assert.same(String(new WeakMap()), '[object WeakMap]', 'correct stringification');\n});","file":"pure/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakSet","suites":[],"line":11,"code":"QUnit.test('WeakSet', assert => {\n  assert.isFunction(WeakSet);\n  assert.true('add' in WeakSet.prototype, 'add in WeakSet.prototype');\n  assert.true('delete' in WeakSet.prototype, 'delete in WeakSet.prototype');\n  assert.true('has' in WeakSet.prototype, 'has in WeakSet.prototype');\n  assert.true(new WeakSet() instanceof WeakSet, 'new WeakSet instanceof WeakSet');\n  let object = {};\n  assert.true(new WeakSet(createIterable([object])).has(object), 'Init from iterable');\n  const weakset = new WeakSet();\n  const frozen = freeze({});\n  weakset.add(frozen);\n  assert.true(weakset.has(frozen), 'works with frozen objects, #1');\n  weakset.delete(frozen);\n  assert.false(weakset.has(frozen), 'works with frozen objects, #2');\n  let done = false;\n\n  try {\n    new WeakSet(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  assert.false('clear' in WeakSet.prototype, 'should not contains `.clear` method');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return getIteratorMethod([]).call(this);\n  };\n\n  new WeakSet(array);\n  assert.true(done);\n  object = {};\n  new WeakSet().add(object);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(WeakSet);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof WeakSet, 'correct subclassing with native classes #2');\n    object = {};\n    assert.true(new Subclass().add(object).has(object), 'correct subclassing with native classes #3');\n  }\n\n  if (typeof ArrayBuffer == 'function') {\n    const buffer = new ArrayBuffer(8);\n    const set = new WeakSet([buffer]);\n    assert.true(set.has(buffer), 'works with ArrayBuffer keys');\n  }\n});","file":"pure/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#add","suites":[],"line":81,"code":"QUnit.test('WeakSet#add', assert => {\n  assert.isFunction(WeakSet.prototype.add);\n  const weakset = new WeakSet();\n  assert.same(weakset.add({}), weakset, 'chaining');\n  assert.throws(() => new WeakSet().add(42), 'throws with primitive keys');\n});","file":"pure/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#delete","suites":[],"line":87,"code":"QUnit.test('WeakSet#delete', assert => {\n  assert.isFunction(WeakSet.prototype.delete);\n  const a = {};\n  const b = {};\n  const weakset = new WeakSet().add(a).add(b);\n  assert.true(weakset.has(a), 'WeakSet has values before .delete() #1');\n  assert.true(weakset.has(b), 'WeakSet has values before .delete() #2');\n  weakset.delete(a);\n  assert.false(weakset.has(a), 'WeakSet hasn`t value after .delete() #1');\n  assert.true(weakset.has(b), 'WeakSet hasn`t value after .delete() #2');\n  assert.notThrows(() => !weakset.delete(1), 'return false on primitive');\n});","file":"pure/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#has","suites":[],"line":99,"code":"QUnit.test('WeakSet#has', assert => {\n  assert.isFunction(WeakSet.prototype.has);\n  const weakset = new WeakSet();\n  assert.false(weakset.has({}), 'WeakSet has`nt value');\n  const object = {};\n  weakset.add(object);\n  assert.true(weakset.has(object), 'WeakSet has value after .add()');\n  weakset.delete(object);\n  assert.false(weakset.has(object), 'WeakSet hasn`t value after .delete()');\n  assert.notThrows(() => !weakset.has(1), 'return false on primitive');\n});","file":"pure/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet::@@toStringTag","suites":[],"line":110,"code":"QUnit.test('WeakSet::@@toStringTag', assert => {\n  assert.same(WeakSet.prototype[Symbol.toStringTag], 'WeakSet', 'WeakSet::@@toStringTag is `WeakSet`');\n  assert.same(String(new WeakSet()), '[object WeakSet]', 'correct stringification');\n});","file":"pure/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"Array#filterOut","suites":[],"line":5,"code":"QUnit.test('Array#filterOut', assert => {\n  assert.isFunction(filterOut);\n  let array = [1];\n  const context = {};\n  filterOut(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], filterOut([1, 2, 3, 'q', {}, 4, true, 5], it => typeof it != 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filterOut(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filterOut(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(filterOut(array, Boolean).foo, 1, '@@species');\n});","file":"pure/esnext.array.filter-out.js","skipped":false,"dir":"tests"},{"name":"Array#filterReject","suites":[],"line":4,"code":"QUnit.test('Array#filterReject', assert => {\n  assert.isFunction(filterReject);\n  let array = [1];\n  const context = {};\n  filterReject(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], filterReject([1, 2, 3, 'q', {}, 4, true, 5], it => typeof it != 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filterReject(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filterReject(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(filterReject(array, Boolean).foo, 1, '@@species');\n});","file":"pure/esnext.array.filter-reject.js","skipped":false,"dir":"tests"},{"name":"Array#findLastIndex","suites":[],"line":3,"code":"QUnit.test('Array#findLastIndex', assert => {\n  assert.isFunction(findLastIndex);\n  const array = [1];\n  const context = {};\n  findLastIndex(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(findLastIndex([{}, 2, NaN, 42, 1], it => !(it % 2)), 3);\n  assert.same(findLastIndex([{}, 2, NaN, 42, 1], it => it === 43), -1);\n  let values = '';\n  let keys = '';\n  findLastIndex([1, 2, 3], (value, key) => {\n    values += value;\n    keys += key;\n  });\n  assert.same(values, '321');\n  assert.same(keys, '210');\n\n  if (STRICT) {\n    assert.throws(() => findLastIndex(null, 0), TypeError);\n    assert.throws(() => findLastIndex(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => findLastIndex({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === -1, 'uses ToLength');\n});","file":"pure/esnext.array.find-last-index.js","skipped":false,"dir":"tests"},{"name":"Array#findLast","suites":[],"line":3,"code":"QUnit.test('Array#findLast', assert => {\n  assert.isFunction(findLast);\n  const array = [1];\n  const context = {};\n  findLast(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(findLast([{}, 2, NaN, 42, 1], it => !(it % 2)), 42);\n  assert.same(findLast([{}, 2, NaN, 42, 1], it => it === 43), undefined);\n  let values = '';\n  let keys = '';\n  findLast([1, 2, 3], (value, key) => {\n    values += value;\n    keys += key;\n  });\n  assert.same(values, '321');\n  assert.same(keys, '210');\n\n  if (STRICT) {\n    assert.throws(() => findLast(null, 0), TypeError);\n    assert.throws(() => findLast(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => findLast({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === undefined, 'uses ToLength');\n});","file":"pure/esnext.array.find-last.js","skipped":false,"dir":"tests"},{"name":"Array.fromAsync","suites":[],"line":5,"code":"QUnit.test('Array.fromAsync', assert => {\n  assert.expect(25);\n  const async = assert.async();\n  assert.isFunction(fromAsync);\n  assert.arity(fromAsync, 1);\n  assert.name(fromAsync, 'fromAsync');\n\n  function C() {\n    /* empty */\n  }\n\n  fromAsync(createAsyncIterable([1, 2, 3]), it => it ** 2).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'async iterable and mapfn');\n    return fromAsync(createAsyncIterable([1]), function (arg, index) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      assert.same(index, 0, 'index');\n    });\n  }).then(() => {\n    return fromAsync(createAsyncIterable([1, 2, 3]));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'async iterable without mapfn');\n    return fromAsync(createIterable([1, 2, 3]), arg => arg ** 2);\n  }).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'iterable and mapfn');\n    return fromAsync(createIterable([1, 2, 3]), arg => Promise.resolve(arg ** 2));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'iterable and async mapfn');\n    return fromAsync(createIterable([1]), function (arg, index) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      assert.same(index, 0, 'index');\n    });\n  }).then(() => {\n    return fromAsync(createIterable([1, 2, 3]));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'iterable and without mapfn');\n    return fromAsync([1, Promise.resolve(2), 3]);\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'array');\n    return fromAsync('123');\n  }).then(it => {\n    assert.arrayEqual(it, ['1', '2', '3'], 'string');\n    return fromAsync.call(C, [1]);\n  }).then(it => {\n    assert.true(it instanceof C, 'subclassable');\n    return fromAsync({\n      length: 1,\n      0: 1\n    });\n  }).then(it => {\n    assert.arrayEqual(it, [1], 'non-iterable');\n    return fromAsync(createIterable([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n    return fromAsync(undefined, () => {\n      /* empty */\n    });\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync(null, () => {\n      /* empty */\n    });\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync([1], null);\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync([1], {});\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    async();\n  });\n});","file":"pure/esnext.array.from-async.js","skipped":false,"dir":"tests"},{"name":"Array#groupByToMap","suites":[],"line":6,"code":"QUnit.test('Array#groupByToMap', assert => {\n  assert.isFunction(groupByToMap);\n  let array = [1];\n  const context = {};\n  groupByToMap(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(groupByToMap([], it => it) instanceof Map, 'returns Map');\n  assert.deepEqual(from(groupByToMap([1, 2, 3], it => it % 2)), [[1, [1, 3]], [0, [2]]], '#1');\n  assert.deepEqual(from(groupByToMap([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], it => `i${it % 5}`)), [['i1', [1, 6, 11]], ['i2', [2, 7, 12]], ['i3', [3, 8]], ['i4', [4, 9]], ['i0', [5, 10]]], '#2');\n  assert.deepEqual(from(groupByToMap(Array(3), it => it)), [[undefined, [undefined, undefined, undefined]]], '#3');\n\n  if (STRICT) {\n    assert.throws(() => groupByToMap(null, () => {\n      /* empty */\n    }), TypeError, 'null this -> TypeError');\n    assert.throws(() => groupByToMap(undefined, () => {\n      /* empty */\n    }), TypeError, 'undefined this -> TypeError');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(groupByToMap(array, Boolean).get(true).foo, undefined, 'no @@species');\n});","file":"pure/esnext.array.group-by-to-map.js","skipped":false,"dir":"tests"},{"name":"Array#groupBy","suites":[],"line":5,"code":"QUnit.test('Array#groupBy', assert => {\n  assert.isFunction(groupBy);\n  let array = [1];\n  const context = {};\n  groupBy(array, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(getPrototypeOf(groupBy([], it => it)), null, 'null proto');\n  assert.deepEqual(groupBy([1, 2, 3], it => it % 2), {\n    1: [1, 3],\n    0: [2]\n  }, '#1');\n  assert.deepEqual(groupBy([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], it => `i${it % 5}`), {\n    i1: [1, 6, 11],\n    i2: [2, 7, 12],\n    i3: [3, 8],\n    i4: [4, 9],\n    i0: [5, 10]\n  }, '#2');\n  assert.deepEqual(groupBy(Array(3), it => it), {\n    undefined: [undefined, undefined, undefined]\n  }, '#3');\n\n  if (STRICT) {\n    assert.throws(() => groupBy(null, () => {\n      /* empty */\n    }), TypeError, 'null this -> TypeError');\n    assert.throws(() => groupBy(undefined, () => {\n      /* empty */\n    }), TypeError, 'undefined this -> TypeError');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(groupBy(array, Boolean).true.foo, undefined, 'no @@species');\n});","file":"pure/esnext.array.group-by.js","skipped":false,"dir":"tests"},{"name":"Array.isTemplateObject","suites":[],"line":3,"code":"QUnit.test('Array.isTemplateObject', assert => {\n  assert.isFunction(isTemplateObject);\n  assert.arity(isTemplateObject, 1);\n  assert.name(isTemplateObject, 'isTemplateObject');\n  assert.false(isTemplateObject(undefined));\n  assert.false(isTemplateObject(null));\n  assert.false(isTemplateObject({}));\n  assert.false(isTemplateObject(function () {\n    return arguments;\n  }()));\n  assert.false(isTemplateObject([]));\n  assert.false(isTemplateObject(freeze([])));\n\n  const template = (() => {\n    try {\n      // eslint-disable-next-line no-template-curly-in-string -- ignore\n      return Function('return (it => it)`qwe${ 123 }asd`')();\n    } catch {\n      /* empty */\n    }\n  })();\n\n  if (template) assert.true(isTemplateObject(template));\n});","file":"pure/esnext.array.is-template-object.js","skipped":false,"dir":"tests"},{"name":"Array#toReversed","suites":[],"line":4,"code":"QUnit.test('Array#toReversed', assert => {\n  assert.isFunction(toReversed);\n  let array = [1, 2];\n  assert.notSame(toReversed(array), array, 'immutable');\n  assert.deepEqual(toReversed([1, 2.2, 3.3]), [3.3, 2.2, 1], 'basic');\n  const object = {};\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  const expected = [Infinity, undefined, NaN, object, true, 'a', -1, 'X', 1, 2, undefined];\n  assert.deepEqual(toReversed(array), expected, 'non-array target');\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(toReversed(array) instanceof Array, 'non-generic');\n\n  if (STRICT) {\n    assert.throws(() => toReversed(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => toReversed(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"pure/esnext.array.to-reversed.js","skipped":false,"dir":"tests"},{"name":"Array#toSorted","suites":[],"line":4,"code":"QUnit.test('Array#toSorted', assert => {\n  assert.isFunction(toSorted);\n  let array = [1];\n  assert.notSame(toSorted(array), array, 'immutable');\n  assert.deepEqual(toSorted([1, 3, 2]), [1, 2, 3], '#1');\n  assert.deepEqual(toSorted([1, 3, 2, 11]), [1, 11, 2, 3], '#2');\n  assert.deepEqual(toSorted([1, -1, 3, NaN, 2, 0, 11, -0]), [-1, 0, -0, 1, 11, 2, 3, NaN], '#1');\n  array = Array(5);\n  array[0] = 1;\n  array[2] = 3;\n  array[4] = 2;\n  let expected = Array(5);\n  expected[0] = 1;\n  expected[1] = 2;\n  expected[2] = 3;\n  assert.deepEqual(toSorted(array), expected, 'holes');\n  array = 'zyxwvutsrqponMLKJIHGFEDCBA'.split('');\n  expected = 'ABCDEFGHIJKLMnopqrstuvwxyz'.split('');\n  assert.deepEqual(toSorted(array), expected, 'alpha #1');\n  array = 'ёяюэьыъщшчцхфутсрПОНМЛКЙИЗЖЕДГВБА'.split('');\n  expected = 'АБВГДЕЖЗИЙКЛМНОПрстуфхцчшщъыьэюяё'.split('');\n  assert.deepEqual(toSorted(array), expected, 'alpha #2');\n  array = [undefined, 1];\n  assert.notThrows(() => array = toSorted(array, () => {\n    throw 1;\n  }), 'undefined #1');\n  assert.deepEqual(array, [1, undefined], 'undefined #2');\n  const object = {\n    valueOf: () => 1,\n    toString: () => -1\n  };\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  expected = [-1, object, 1, 2, Infinity, NaN, 'X', 'a', true, undefined, undefined];\n  assert.deepEqual(toSorted(array), expected, 'non-array target');\n  let index, mod, code, chr, value;\n  expected = Array(516);\n  array = Array(516);\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  assert.arrayEqual(toSorted(array, (a, b) => (a / 4 | 0) - (b / 4 | 0)), expected, 'stable #1');\n  assert.true(1 / toSorted([0, -0])[0] > 0, '-0');\n  let result = '';\n  array = []; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n\n      case 68:\n      case 71:\n        value = 4;\n        break;\n\n      default:\n        value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      array.push({\n        k: chr + index,\n        v: value\n      });\n    }\n  }\n\n  array = toSorted(array, (a, b) => b.v - a.v);\n\n  for (index = 0; index < array.length; index++) {\n    chr = array[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  assert.same(result, 'DGBEFHACIJK', 'stable #2');\n  assert.notThrows(() => toSorted([1, 2, 3], undefined).length === 3, 'works with undefined');\n  assert.throws(() => toSorted([1, 2, 3], null), 'throws on null');\n  assert.throws(() => toSorted([1, 2, 3], {}), 'throws on {}');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => toSorted([Symbol(1), Symbol(2)]), 'w/o cmp throws on symbols');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(toSorted(array) instanceof Array, 'non-generic');\n\n  if (STRICT) {\n    assert.throws(() => toSorted(null), TypeError, 'ToObject(this)');\n    assert.throws(() => toSorted(undefined), TypeError, 'ToObject(this)');\n  }\n});","file":"pure/esnext.array.to-sorted.js","skipped":false,"dir":"tests"},{"name":"Array#toSpliced","suites":[],"line":4,"code":"QUnit.test('Array#toSpliced', assert => {\n  assert.isFunction(toSpliced);\n  let array = [1, 2, 3, 4, 5];\n  assert.notSame(toSpliced(array, 2), array);\n  assert.deepEqual(toSpliced([1, 2, 3, 4, 5], 2), [1, 2]);\n  assert.deepEqual(toSpliced([1, 2, 3, 4, 5], -2), [1, 2, 3]);\n  assert.deepEqual(toSpliced([1, 2, 3, 4, 5], 2, 2), [1, 2, 5]);\n  assert.deepEqual(toSpliced([1, 2, 3, 4, 5], 2, -2), [1, 2, 3, 4, 5]);\n  assert.deepEqual(toSpliced([1, 2, 3, 4, 5], 2, 2, 6, 7), [1, 2, 6, 7, 5]);\n\n  if (STRICT) {\n    assert.throws(() => toSpliced(null), TypeError);\n    assert.throws(() => toSpliced(undefined), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(toSpliced(array) instanceof Array, 'non-generic');\n});","file":"pure/esnext.array.to-spliced.js","skipped":false,"dir":"tests"},{"name":"Array#uniqueBy","suites":[],"line":3,"code":"QUnit.test('Array#uniqueBy', assert => {\n  assert.isFunction(uniqueBy);\n  let array = [1, 2, 3, 2, 1];\n  assert.notSame(uniqueBy(array), array);\n  assert.deepEqual(uniqueBy(array), [1, 2, 3]);\n  array = [{\n    id: 1,\n    uid: 10000\n  }, {\n    id: 2,\n    uid: 10000\n  }, {\n    id: 3,\n    uid: 10001\n  }];\n  assert.deepEqual(uniqueBy(array, it => it.uid), [{\n    id: 1,\n    uid: 10000\n  }, {\n    id: 3,\n    uid: 10001\n  }]);\n  assert.deepEqual(uniqueBy(array, ({\n    id,\n    uid\n  }) => `${id}-${uid}`), array);\n  assert.deepEqual(uniqueBy([1, undefined, 2, undefined, null, 1]), [1, undefined, 2, null]);\n  assert.deepEqual(uniqueBy([0, -0]), [0]);\n  assert.deepEqual(uniqueBy([NaN, NaN]), [NaN]);\n  assert.deepEqual(uniqueBy({\n    length: 1,\n    0: 1\n  }), [1]);\n\n  if (STRICT) {\n    assert.throws(() => uniqueBy(null), TypeError);\n    assert.throws(() => uniqueBy(undefined), TypeError);\n  }\n});","file":"pure/esnext.array.unique-by.js","skipped":false,"dir":"tests"},{"name":"Array#with","suites":[],"line":4,"code":"QUnit.test('Array#with', assert => {\n  assert.isFunction(withAt);\n  let array = [1, 2, 3, 4, 5];\n  assert.notSame(withAt(array, 2, 1), array);\n  assert.deepEqual(withAt([1, 2, 3, 4, 5], 2, 6), [1, 2, 6, 4, 5]);\n  assert.deepEqual(withAt([1, 2, 3, 4, 5], -2, 6), [1, 2, 3, 6, 5]);\n  assert.deepEqual(withAt([1, 2, 3, 4, 5], '1', 6), [1, 6, 3, 4, 5]);\n  assert.throws(() => withAt([1, 2, 3, 4, 5], 5, 6), RangeError);\n  assert.throws(() => withAt([1, 2, 3, 4, 5], -6, 6), RangeError);\n\n  if (STRICT) {\n    assert.throws(() => withAt(null, 1, 2), TypeError);\n    assert.throws(() => withAt(undefined, 1, 2), TypeError);\n  }\n\n  array = [1, 2]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(withAt(array, 1, 2) instanceof Array, 'non-generic');\n});","file":"pure/esnext.array.with.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#asIndexedPairs","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#asIndexedPairs', assert => {\n  assert.expect(8);\n  const async = assert.async();\n  const {\n    asIndexedPairs\n  } = AsyncIterator.prototype;\n  assert.isFunction(asIndexedPairs);\n  assert.arity(asIndexedPairs, 0);\n  assert.nonEnumerable(AsyncIterator.prototype, 'asIndexedPairs');\n  asIndexedPairs.call(createIterator(['a', 'b', 'c'])).toArray().then(it => {\n    assert.same(it.toString(), '0,a,1,b,2,c', 'basic functionality');\n    async();\n  });\n  assert.throws(() => asIndexedPairs.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call([], () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.async-iterator.as-indexed-pairs.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator","suites":[],"line":3,"code":"QUnit.test('AsyncIterator', assert => {\n  assert.isFunction(AsyncIterator);\n  assert.arity(AsyncIterator, 0);\n  assert.true(AsyncIterator.from([1, 2, 3]) instanceof AsyncIterator, 'Async From Proxy');\n  assert.true(AsyncIterator.from([1, 2, 3]).drop(1) instanceof AsyncIterator, 'Async Drop Proxy');\n  assert.true(new AsyncIterator() instanceof AsyncIterator, 'constructor');\n  assert.throws(() => AsyncIterator(), 'throws w/o `new`');\n});","file":"pure/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#constructor","suites":[],"line":11,"code":"QUnit.test('AsyncIterator#constructor', assert => {\n  assert.same(AsyncIterator.prototype.constructor, AsyncIterator, 'AsyncIterator#constructor is AsyncIterator');\n});","file":"pure/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#@@toStringTag","suites":[],"line":14,"code":"QUnit.test('AsyncIterator#@@toStringTag', assert => {\n  assert.same(AsyncIterator.prototype[Symbol.toStringTag], 'AsyncIterator', 'AsyncIterator::@@toStringTag is `AsyncIterator`');\n});","file":"pure/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#drop","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#drop', assert => {\n  assert.expect(12);\n  const async = assert.async();\n  const {\n    drop\n  } = AsyncIterator.prototype;\n  assert.isFunction(drop);\n  assert.arity(drop, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'drop');\n  drop.call(createIterator([1, 2, 3]), 1).toArray().then(it => {\n    assert.arrayEqual(it, [2, 3], 'basic functionality');\n    return drop.call(createIterator([1, 2, 3]), 1.5).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [2, 3], 'float');\n    return drop.call(createIterator([1, 2, 3]), 4).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [], 'big');\n    return drop.call(createIterator([1, 2, 3]), 0).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'zero');\n  }).then(() => async());\n  assert.throws(() => drop.call(undefined, 1), TypeError);\n  assert.throws(() => drop.call(null, 1), TypeError);\n  assert.throws(() => drop.call({}, 1), TypeError);\n  assert.throws(() => drop.call([], 1), TypeError);\n  assert.throws(() => drop.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"pure/esnext.async-iterator.drop.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#every","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#every', assert => {\n  assert.expect(16);\n  const async = assert.async();\n  const {\n    every\n  } = AsyncIterator.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'every');\n  every.call(createIterator([1, 2, 3]), it => typeof it == 'number').then(result => {\n    assert.true(result, 'basic functionality, +');\n    return every.call(createIterator([1, 2, 3]), it => it === 2);\n  }).then(result => {\n    assert.false(result, 'basic functionality, -');\n    return every.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return every.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => every.call(createIterator([1]), null), TypeError);\n  assert.throws(() => every.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.every.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#filter","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#filter', assert => {\n  assert.expect(15);\n  const async = assert.async();\n  const {\n    filter\n  } = AsyncIterator.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'filter');\n  filter.call(createIterator([1, 2, 3]), it => it % 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 3], 'basic functionality');\n    return filter.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    }).toArray();\n  }).then(() => {\n    return filter.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), null), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.filter.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#find","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#find', assert => {\n  assert.expect(16);\n  const async = assert.async();\n  const {\n    find\n  } = AsyncIterator.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'find');\n  find.call(createIterator([2, 3, 4]), it => it % 2).then(result => {\n    assert.same(result, 3, 'basic functionality, +');\n    return find.call(createIterator([1, 2, 3]), it => it === 4);\n  }).then(result => {\n    assert.same(result, undefined, 'basic functionality, -');\n    return find.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return find.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => find.call(createIterator([1]), null), TypeError);\n  assert.throws(() => find.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.find.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#flatMap","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#flatMap', assert => {\n  assert.expect(15);\n  const async = assert.async();\n  const {\n    flatMap\n  } = AsyncIterator.prototype;\n  assert.isFunction(flatMap);\n  assert.arity(flatMap, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'flatMap');\n  flatMap.call(createIterator([1, [], 2, createIterable([3, 4]), [5, 6], 'ab']), it => typeof it == 'number' ? [-it] : it).toArray().then(it => {\n    assert.arrayEqual(it, [-1, -2, 3, 4, 5, 6, 'a', 'b'], 'basic functionality');\n    return flatMap.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      return [arg];\n    }).toArray();\n  }).then(() => {\n    return flatMap.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => flatMap.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), null), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.flat-map.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#forEach","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#forEach', assert => {\n  assert.expect(15);\n  const async = assert.async();\n  const {\n    forEach\n  } = AsyncIterator.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'forEach');\n  const array = [];\n  forEach.call(createIterator([1, 2, 3]), it => array.push(it)).then(() => {\n    assert.arrayEqual(array, [1, 2, 3], 'basic functionality');\n    return forEach.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return forEach.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => forEach.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), null), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.for-each.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator.from","suites":[],"line":5,"code":"QUnit.test('AsyncIterator.from', assert => {\n  assert.expect(9);\n  const async = assert.async();\n  const {\n    from\n  } = AsyncIterator;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(AsyncIterator.from(values([])) instanceof AsyncIterator, 'proxy, iterator');\n  assert.true(AsyncIterator.from([]) instanceof AsyncIterator, 'proxy, iterable');\n  AsyncIterator.from([1, Promise.resolve(2), 3]).toArray().then(result => {\n    assert.arrayEqual(result, [1, 2, 3], 'unwrap promises');\n    async();\n  });\n  const asyncIterator = assign(new AsyncIterator(), {\n    next: () => {\n      /* empty */\n    }\n  });\n  assert.same(AsyncIterator.from(asyncIterator), asyncIterator, 'does not wrap AsyncIterator instances');\n  assert.throws(() => from(undefined), TypeError);\n  assert.throws(() => from(null), TypeError);\n  assert.throws(() => from({}), TypeError);\n});","file":"pure/esnext.async-iterator.from.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#map","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#map', assert => {\n  assert.expect(15);\n  const async = assert.async();\n  const {\n    map\n  } = AsyncIterator.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'map');\n  map.call(createIterator([1, 2, 3]), it => it ** 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'basic functionality');\n    return map.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    }).toArray();\n  }).then(() => {\n    return map.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => map.call(createIterator([1]), null), TypeError);\n  assert.throws(() => map.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.map.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#reduce","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#reduce', assert => {\n  assert.expect(18);\n  const async = assert.async();\n  const {\n    reduce\n  } = AsyncIterator.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'reduce');\n  reduce.call(createIterator([1, 2, 3]), (a, b) => a + b, 1).then(it => {\n    assert.same(it, 7, 'basic functionality, initial');\n    return reduce.call(createIterator([2]), function (a, b) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(a, 1, 'argument 1');\n      assert.same(b, 2, 'argument 2');\n    }, 1);\n  }).then(() => {\n    return reduce.call(createIterator([1, 2, 3]), (a, b) => a + b);\n  }).then(it => {\n    assert.same(it, 6, 'basic functionality, no initial');\n    return reduce.call(createIterator([]), (a, b) => a + b);\n  }).catch(() => {\n    assert.true(true, 'reduce an empty interble with no initial');\n    return reduce.call(createIterator([1]), () => {\n      throw 42;\n    }, 1);\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call([], () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), undefined, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), null, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), {}, 1), TypeError);\n});","file":"pure/esnext.async-iterator.reduce.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#some","suites":[],"line":4,"code":"QUnit.test('AsyncIterator#some', assert => {\n  assert.expect(16);\n  const async = assert.async();\n  const {\n    some\n  } = AsyncIterator.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'some');\n  some.call(createIterator([1, 2, 3]), it => it === 2).then(result => {\n    assert.true(result, 'basic functionality, +');\n    return some.call(createIterator([1, 2, 3]), it => it === 4);\n  }).then(result => {\n    assert.false(result, 'basic functionality, -');\n    return some.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return some.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => some.call(createIterator([1]), null), TypeError);\n  assert.throws(() => some.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.async-iterator.some.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#take","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#take', assert => {\n  assert.expect(12);\n  const async = assert.async();\n  const {\n    take\n  } = AsyncIterator.prototype;\n  assert.isFunction(take);\n  assert.arity(take, 1);\n  assert.nonEnumerable(AsyncIterator.prototype, 'take');\n  take.call(createIterator([1, 2, 3]), 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 2], 'basic functionality');\n    return take.call(createIterator([1, 2, 3]), 1.5).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1], 'float');\n    return take.call(createIterator([1, 2, 3]), 4).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'big');\n    return take.call(createIterator([1, 2, 3]), 0).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [], 'zero');\n  }).then(() => async());\n  assert.throws(() => take.call(undefined, 1), TypeError);\n  assert.throws(() => take.call(null, 1), TypeError);\n  assert.throws(() => take.call({}, 1), TypeError);\n  assert.throws(() => take.call([], 1), TypeError);\n  assert.throws(() => take.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"pure/esnext.async-iterator.take.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#toArray","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#toArray', assert => {\n  assert.expect(8);\n  const async = assert.async();\n  const {\n    toArray\n  } = AsyncIterator.prototype;\n  assert.isFunction(toArray);\n  assert.arity(toArray, 0);\n  assert.nonEnumerable(AsyncIterator.prototype, 'toArray');\n  toArray.call(createIterator([1, 2, 3])).then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n    async();\n  });\n  assert.throws(() => toArray.call(undefined), TypeError);\n  assert.throws(() => toArray.call(null), TypeError);\n  assert.throws(() => toArray.call({}), TypeError);\n  assert.throws(() => toArray.call([]), TypeError);\n});","file":"pure/esnext.async-iterator.to-array.js","skipped":false,"dir":"tests"},{"name":"BigInt.range","suites":[],"line":4,"code":"if (typeof BigInt == 'function') QUnit.test('BigInt.range', assert => {\n  assert.isFunction(range);\n  assert.name(range, 'range');\n  assert.arity(range, 3);\n  let iterator = range(BigInt(1), BigInt(2));\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: BigInt(1),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.deepEqual(from(range(BigInt(-1), BigInt(5))), [BigInt(-1), BigInt(0), BigInt(1), BigInt(2), BigInt(3), BigInt(4)]);\n  assert.deepEqual(from(range(BigInt(-5), BigInt(1))), [BigInt(-5), BigInt(-4), BigInt(-3), BigInt(-2), BigInt(-1), BigInt(0)]);\n  assert.deepEqual(from(range(BigInt('9007199254740991'), BigInt('9007199254740992'), {\n    inclusive: true\n  })), [BigInt('9007199254740991'), BigInt('9007199254740992')]);\n  assert.deepEqual(from(range(BigInt(0), BigInt(0))), []);\n  assert.deepEqual(from(range(BigInt(0), BigInt(-5), BigInt(1))), []);\n  iterator = range(BigInt(1), BigInt(3));\n  assert.deepEqual(iterator.start, BigInt(1));\n  assert.deepEqual(iterator.end, BigInt(3));\n  assert.deepEqual(iterator.step, BigInt(1));\n  assert.false(iterator.inclusive);\n  iterator = range(BigInt(-1), BigInt(-3), {\n    inclusive: true\n  });\n  assert.deepEqual(iterator.start, BigInt(-1));\n  assert.deepEqual(iterator.end, BigInt(-3));\n  assert.same(iterator.step, BigInt(-1));\n  assert.true(iterator.inclusive);\n  iterator = range(BigInt(-1), BigInt(-3), {\n    step: BigInt(4),\n\n    inclusive() {\n      /* empty */\n    }\n\n  });\n  assert.same(iterator.start, BigInt(-1));\n  assert.same(iterator.end, BigInt(-3));\n  assert.same(iterator.step, BigInt(4));\n  assert.true(iterator.inclusive);\n  iterator = range(BigInt(0), BigInt(5)); // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\n  assert.throws(() => Object.getOwnPropertyDescriptor(iterator, 'start').call({}), TypeError);\n  assert.throws(() => range(Infinity, BigInt(10), BigInt(0)), TypeError);\n  assert.throws(() => range(-Infinity, BigInt(10), BigInt(0)), TypeError);\n  assert.throws(() => range(BigInt(0), BigInt(10), Infinity), TypeError);\n  assert.throws(() => range(BigInt(0), BigInt(10), {\n    step: Infinity\n  }), TypeError);\n  assert.throws(() => range({}, BigInt(1)), TypeError);\n  assert.throws(() => range(BigInt(1), {}), TypeError);\n});","file":"pure/esnext.bigint.range.js","skipped":false,"dir":"tests"},{"name":"compositeKey","suites":[],"line":4,"code":"QUnit.test('compositeKey', assert => {\n  assert.isFunction(compositeKey);\n  if (compositeKey.name) assert.name(compositeKey, 'compositeKey');\n  const key = compositeKey({});\n  assert.same(typeof key, 'object');\n  assert.same({}.toString.call(key), '[object Object]');\n  assert.same(getPrototypeOf(key), null);\n  if (FREEZING) assert.true(isFrozen(key));\n  const a = ['a'];\n  const b = ['b'];\n  const c = ['c'];\n  assert.same(compositeKey(a), compositeKey(a));\n  assert.notSame(compositeKey(a), compositeKey(['a']));\n  assert.notSame(compositeKey(a), compositeKey(a, 1));\n  assert.notSame(compositeKey(a), compositeKey(a, b));\n  assert.same(compositeKey(a, 1), compositeKey(a, 1));\n  assert.same(compositeKey(a, b), compositeKey(a, b));\n  assert.notSame(compositeKey(a, b), compositeKey(b, a));\n  assert.same(compositeKey(a, b, c), compositeKey(a, b, c));\n  assert.notSame(compositeKey(a, b, c), compositeKey(c, b, a));\n  assert.notSame(compositeKey(a, b, c), compositeKey(a, c, b));\n  assert.notSame(compositeKey(a, b, c, 1), compositeKey(a, b, c));\n  assert.same(compositeKey(a, b, c, 1), compositeKey(a, b, c, 1));\n  assert.same(compositeKey(1, a), compositeKey(1, a));\n  assert.notSame(compositeKey(1, a), compositeKey(a, 1));\n  assert.same(compositeKey(1, a, 2, b), compositeKey(1, a, 2, b));\n  assert.notSame(compositeKey(1, a, 2, b), compositeKey(1, a, b, 2));\n  assert.same(compositeKey(1, 2, a, b), compositeKey(1, 2, a, b));\n  assert.notSame(compositeKey(1, 2, a, b), compositeKey(1, a, b, 2));\n  assert.same(compositeKey(a, a), compositeKey(a, a));\n  assert.notSame(compositeKey(a, a), compositeKey(a, ['a']));\n  assert.notSame(compositeKey(a, a), compositeKey(a, b));\n  assert.throws(() => compositeKey(), TypeError);\n  assert.throws(() => compositeKey(1, 2), TypeError);\n  assert.throws(() => compositeKey('foo', null, true), TypeError);\n});","file":"pure/esnext.composite-key.js","skipped":false,"dir":"tests"},{"name":"compositeSymbol","suites":[],"line":3,"code":"QUnit.test('compositeSymbol', assert => {\n  assert.isFunction(compositeSymbol);\n  if (compositeSymbol.name) assert.name(compositeSymbol, 'compositeSymbol');\n  assert.true(Object(compositeSymbol({})) instanceof Symbol);\n  const a = ['a'];\n  const b = ['b'];\n  const c = ['c'];\n  assert.same(compositeSymbol(a), compositeSymbol(a));\n  assert.notSame(compositeSymbol(a), compositeSymbol(['a']));\n  assert.notSame(compositeSymbol(a), compositeSymbol(a, 1));\n  assert.notSame(compositeSymbol(a), compositeSymbol(a, b));\n  assert.same(compositeSymbol(a, 1), compositeSymbol(a, 1));\n  assert.same(compositeSymbol(a, b), compositeSymbol(a, b));\n  assert.notSame(compositeSymbol(a, b), compositeSymbol(b, a));\n  assert.same(compositeSymbol(a, b, c), compositeSymbol(a, b, c));\n  assert.notSame(compositeSymbol(a, b, c), compositeSymbol(c, b, a));\n  assert.notSame(compositeSymbol(a, b, c), compositeSymbol(a, c, b));\n  assert.notSame(compositeSymbol(a, b, c, 1), compositeSymbol(a, b, c));\n  assert.same(compositeSymbol(a, b, c, 1), compositeSymbol(a, b, c, 1));\n  assert.same(compositeSymbol(1, a), compositeSymbol(1, a));\n  assert.notSame(compositeSymbol(1, a), compositeSymbol(a, 1));\n  assert.same(compositeSymbol(1, a, 2, b), compositeSymbol(1, a, 2, b));\n  assert.notSame(compositeSymbol(1, a, 2, b), compositeSymbol(1, a, b, 2));\n  assert.same(compositeSymbol(1, 2, a, b), compositeSymbol(1, 2, a, b));\n  assert.notSame(compositeSymbol(1, 2, a, b), compositeSymbol(1, a, b, 2));\n  assert.same(compositeSymbol(a, a), compositeSymbol(a, a));\n  assert.notSame(compositeSymbol(a, a), compositeSymbol(a, ['a']));\n  assert.notSame(compositeSymbol(a, a), compositeSymbol(a, b));\n  assert.same(compositeSymbol(), compositeSymbol());\n  assert.same(compositeSymbol(1, 2), compositeSymbol(1, 2));\n  assert.notSame(compositeSymbol(1, 2), compositeSymbol(2, 1));\n  assert.same(compositeSymbol('foo', null, true), compositeSymbol('foo', null, true));\n  assert.same(compositeSymbol('string'), Symbol.for('string'));\n});","file":"pure/esnext.composite-symbol.js","skipped":false,"dir":"tests"},{"name":"Function.isCallable","suites":[],"line":3,"code":"QUnit.test('Function.isCallable', assert => {\n  assert.isFunction(isCallable);\n  assert.arity(isCallable, 1);\n  assert.name(isCallable, 'isCallable');\n  assert.false(isCallable({}), 'object');\n  assert.false(isCallable(function () {\n    return arguments;\n  }()), 'arguments');\n  assert.false(isCallable([]), 'array');\n  assert.false(isCallable(/./), 'regex');\n  assert.false(isCallable(1), 'number');\n  assert.false(isCallable(true), 'boolean');\n  assert.false(isCallable('1'), 'string');\n  assert.false(isCallable(null), 'null');\n  assert.false(isCallable(), 'undefined');\n  assert.true(isCallable(Function.call), 'native function'); // eslint-disable-next-line prefer-arrow-callback -- required\n\n  assert.true(isCallable(function () {\n    /* empty */\n  }), 'function');\n  const arrow = fromSource('it => it');\n  if (arrow) assert.true(isCallable(arrow), 'arrow');\n  const klass = fromSource('class {}'); // Safari 9 and Edge 13- bugs\n\n  if (klass && !/constructor|function/.test(klass)) assert.false(isCallable(klass), 'class');\n  const gen = fromSource('function * () {}');\n  if (gen) assert.true(isCallable(gen), 'gen');\n  const asyncFunc = fromSource('async function () {}');\n  if (asyncFunc) assert.true(isCallable(asyncFunc), 'asyncFunc');\n  const asyncGen = fromSource('async * function () {}');\n  if (asyncGen) assert.true(isCallable(asyncGen), 'asyncGen');\n  const method = fromSource('({f(){}}).f'); // Safari 9 bug\n\n  if (method && !/function/.test(method)) assert.true(isCallable(method), 'method');\n});","file":"pure/esnext.function.is-callable.js","skipped":false,"dir":"tests"},{"name":"Function.isConstructor","suites":[],"line":3,"code":"QUnit.test('Function.isConstructor', assert => {\n  assert.isFunction(isConstructor);\n  assert.arity(isConstructor, 1);\n  assert.name(isConstructor, 'isConstructor');\n  assert.false(isConstructor({}), 'object');\n  assert.false(isConstructor(function () {\n    return arguments;\n  }()), 'arguments');\n  assert.false(isConstructor([]), 'array');\n  assert.false(isConstructor(/./), 'regex');\n  assert.false(isConstructor(1), 'number');\n  assert.false(isConstructor(true), 'boolean');\n  assert.false(isConstructor('1'), 'string');\n  assert.false(isConstructor(null), 'null');\n  assert.false(isConstructor(), 'undefined'); // assert.false(isConstructor(Function.call), 'native function'); // fails in some old engines\n  // eslint-disable-next-line prefer-arrow-callback -- required\n\n  assert.true(isConstructor(function () {\n    /* empty */\n  }), 'function');\n  const arrow = fromSource('it => it');\n  if (arrow) assert.false(isConstructor(arrow), 'arrow');\n  const klass = fromSource('class {}'); // Safari 9 and Edge 13- bugs\n\n  if (klass && !/constructor|function/.test(klass)) assert.true(isConstructor(klass), 'class');\n  const Gen = fromSource('function * () {}'); // V8 ~ Chrome 49- bug\n\n  if (Gen) try {\n    new Gen();\n  } catch (error) {\n    assert.false(isConstructor(Gen), 'gen');\n  }\n  const asyncFunc = fromSource('async function () {}');\n  if (asyncFunc) assert.false(isConstructor(asyncFunc), 'asyncFunc');\n  const asyncGen = fromSource('async * function () {}');\n  if (asyncGen) assert.false(isConstructor(asyncGen), 'asyncGen');\n  const method = fromSource('({f(){}}).f'); // Safari 9 bug\n\n  if (method && !/function/.test(method)) assert.false(isConstructor(method), 'method');\n});","file":"pure/esnext.function.is-constructor.js","skipped":false,"dir":"tests"},{"name":"Function#unThis","suites":[],"line":2,"code":"QUnit.test('Function#unThis', assert => {\n  assert.isFunction(unThis); // eslint-disable-next-line prefer-arrow-callback -- required for testing\n\n  assert.same(unThis(function () {\n    return 42;\n  })(), 42);\n  assert.deepEqual(unThis(Array.prototype.slice)([1, 2, 3], 1), [2, 3]);\n});","file":"pure/esnext.function.un-this.js","skipped":false,"dir":"tests"},{"name":"Iterator#asIndexedPairs","suites":[],"line":3,"code":"QUnit.test('Iterator#asIndexedPairs', assert => {\n  const {\n    asIndexedPairs\n  } = Iterator.prototype;\n  assert.isFunction(asIndexedPairs);\n  assert.arity(asIndexedPairs, 0);\n  assert.nonEnumerable(Iterator.prototype, 'asIndexedPairs');\n  assert.arrayEqual(asIndexedPairs.call(createIterator(['a', 'b', 'c'])).toArray().toString(), '0,a,1,b,2,c', 'basic functionality');\n  assert.throws(() => asIndexedPairs.call(undefined, TypeError));\n  assert.throws(() => asIndexedPairs.call(null, TypeError));\n  assert.throws(() => asIndexedPairs.call({}, TypeError));\n  assert.throws(() => asIndexedPairs.call([], TypeError));\n});","file":"pure/esnext.iterator.as-indexed-pairs.js","skipped":false,"dir":"tests"},{"name":"Iterator","suites":[],"line":4,"code":"QUnit.test('Iterator', assert => {\n  assert.isFunction(Iterator);\n  assert.arity(Iterator, 0);\n  assert.true(Iterator.from(createIterator([1, 2, 3])) instanceof Iterator, 'From Proxy');\n  assert.true(new Iterator() instanceof Iterator, 'constructor');\n  assert.throws(() => Iterator(), 'throws w/o `new`');\n});","file":"pure/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#constructor","suites":[],"line":11,"code":"QUnit.test('Iterator#constructor', assert => {\n  assert.same(Iterator.prototype.constructor, Iterator, 'Iterator#constructor is Iterator');\n});","file":"pure/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#@@toStringTag","suites":[],"line":14,"code":"QUnit.test('Iterator#@@toStringTag', assert => {\n  assert.same(Iterator.prototype[Symbol.toStringTag], 'Iterator', 'Iterator::@@toStringTag is `Iterator`');\n});","file":"pure/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#drop","suites":[],"line":3,"code":"QUnit.test('Iterator#drop', assert => {\n  const {\n    drop\n  } = Iterator.prototype;\n  assert.isFunction(drop);\n  assert.arity(drop, 1);\n  assert.nonEnumerable(Iterator.prototype, 'drop');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 1).toArray(), [2, 3], 'basic functionality');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 1.5).toArray(), [2, 3], 'float');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 4).toArray(), [], 'big');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 0).toArray(), [1, 2, 3], 'zero');\n  assert.throws(() => drop.call(undefined, 1), TypeError);\n  assert.throws(() => drop.call(null, 1), TypeError);\n  assert.throws(() => drop.call({}, 1), TypeError);\n  assert.throws(() => drop.call([], 1), TypeError);\n  assert.throws(() => drop.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"pure/esnext.iterator.drop.js","skipped":false,"dir":"tests"},{"name":"Iterator#every","suites":[],"line":4,"code":"QUnit.test('Iterator#every', assert => {\n  const {\n    every\n  } = Iterator.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.nonEnumerable(Iterator.prototype, 'every');\n  assert.true(every.call(createIterator([1, 2, 3]), it => typeof it == 'number'), 'basic functionality #1');\n  assert.false(every.call(createIterator([1, 2, 3]), it => it % 2), 'basic functionality #2');\n  every.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => every.call(createIterator([1]), null), TypeError);\n  assert.throws(() => every.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.every.js","skipped":false,"dir":"tests"},{"name":"Iterator#filter","suites":[],"line":4,"code":"QUnit.test('Iterator#filter', assert => {\n  const {\n    filter\n  } = Iterator.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.nonEnumerable(Iterator.prototype, 'filter');\n  assert.arrayEqual(filter.call(createIterator([1, 2, 3]), it => it % 2).toArray(), [1, 3], 'basic functionality');\n  filter.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  }).toArray();\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), null), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.filter.js","skipped":false,"dir":"tests"},{"name":"Iterator#find","suites":[],"line":4,"code":"QUnit.test('Iterator#find', assert => {\n  const {\n    find\n  } = Iterator.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.nonEnumerable(Iterator.prototype, 'find');\n  assert.same(find.call(createIterator([1, 2, 3]), it => !(it % 2)), 2, 'basic functionality');\n  find.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => find.call(createIterator([1]), null), TypeError);\n  assert.throws(() => find.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.find.js","skipped":false,"dir":"tests"},{"name":"Iterator#flatMap","suites":[],"line":4,"code":"QUnit.test('Iterator#flatMap', assert => {\n  const {\n    flatMap\n  } = Iterator.prototype;\n  assert.isFunction(flatMap);\n  assert.arity(flatMap, 1);\n  assert.nonEnumerable(Iterator.prototype, 'flatMap');\n  assert.arrayEqual(flatMap.call(createIterator([1, [], 2, createIterable([3, 4]), [5, 6], 'ab']), it => typeof it == 'number' ? [-it] : it).toArray(), [-1, -2, 3, 4, 5, 6, 'a', 'b'], 'basic functionality');\n  flatMap.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n    return [arg];\n  }).toArray();\n  assert.throws(() => flatMap.call(createIterator([1]), it => it).next(), TypeError);\n  assert.throws(() => flatMap.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), null), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.flat-map.js","skipped":false,"dir":"tests"},{"name":"Iterator#forEach","suites":[],"line":4,"code":"QUnit.test('Iterator#forEach', assert => {\n  const {\n    forEach\n  } = Iterator.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.nonEnumerable(Iterator.prototype, 'forEach');\n  const array = [];\n  forEach.call(createIterator([1, 2, 3]), it => array.push(it));\n  assert.arrayEqual(array, [1, 2, 3], 'basic functionality');\n  forEach.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => forEach.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), null), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.for-each.js","skipped":false,"dir":"tests"},{"name":"Iterator.from","suites":[],"line":3,"code":"QUnit.test('Iterator.from', assert => {\n  const {\n    from\n  } = Iterator;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(Iterator.from(createIterator([1, 2, 3])) instanceof Iterator, 'proxy, iterator');\n  assert.true(Iterator.from(createIterable([1, 2, 3])) instanceof Iterator, 'proxy, iterable');\n  assert.arrayEqual(Iterator.from(createIterable([1, 2, 3])).toArray(), [1, 2, 3], 'just a proxy');\n  assert.throws(() => from(undefined), TypeError);\n  assert.throws(() => from(null), TypeError);\n  assert.throws(() => from({}), TypeError);\n});","file":"pure/esnext.iterator.from.js","skipped":false,"dir":"tests"},{"name":"Iterator#map","suites":[],"line":4,"code":"QUnit.test('Iterator#map', assert => {\n  const {\n    map\n  } = Iterator.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.nonEnumerable(Iterator.prototype, 'map');\n  assert.arrayEqual(map.call(createIterator([1, 2, 3]), it => it ** 2).toArray(), [1, 4, 9], 'basic functionality');\n  map.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  }).toArray();\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => map.call(createIterator([1]), null), TypeError);\n  assert.throws(() => map.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.map.js","skipped":false,"dir":"tests"},{"name":"Iterator#reduce","suites":[],"line":4,"code":"QUnit.test('Iterator#reduce', assert => {\n  const {\n    reduce\n  } = Iterator.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.nonEnumerable(Iterator.prototype, 'reduce');\n  assert.same(reduce.call(createIterator([1, 2, 3]), (a, b) => a + b, 1), 7, 'basic functionality');\n  assert.same(reduce.call(createIterator([1, 2, 3]), (a, b) => a + b), 6, 'basic functionality, no init');\n  reduce.call(createIterator([2]), function (a, b) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 2, 'arguments length');\n    assert.same(a, 1, 'argument 1');\n    assert.same(b, 2, 'argument 2');\n  }, 1);\n  assert.throws(() => reduce.call(undefined, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call(null, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call({}, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call([], (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), undefined, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), null, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), {}, 1), TypeError);\n});","file":"pure/esnext.iterator.reduce.js","skipped":false,"dir":"tests"},{"name":"Iterator#some","suites":[],"line":4,"code":"QUnit.test('Iterator#some', assert => {\n  const {\n    some\n  } = Iterator.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.nonEnumerable(Iterator.prototype, 'some');\n  assert.true(some.call(createIterator([1, 2, 3]), it => it % 2), 'basic functionality #1');\n  assert.false(some.call(createIterator([1, 2, 3]), it => typeof it == 'string'), 'basic functionality #2');\n  some.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => some.call(createIterator([1]), null), TypeError);\n  assert.throws(() => some.call(createIterator([1]), {}), TypeError);\n});","file":"pure/esnext.iterator.some.js","skipped":false,"dir":"tests"},{"name":"Iterator#take","suites":[],"line":3,"code":"QUnit.test('Iterator#take', assert => {\n  const {\n    take\n  } = Iterator.prototype;\n  assert.isFunction(take);\n  assert.arity(take, 1);\n  assert.nonEnumerable(Iterator.prototype, 'take');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 2).toArray(), [1, 2], 'basic functionality');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 1.5).toArray(), [1], 'float');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 4).toArray(), [1, 2, 3], 'big');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 0).toArray(), [], 'zero');\n  assert.throws(() => take.call(undefined, 1), TypeError);\n  assert.throws(() => take.call(null, 1), TypeError);\n  assert.throws(() => take.call({}, 1), TypeError);\n  assert.throws(() => take.call([], 1), TypeError);\n  assert.throws(() => take.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"pure/esnext.iterator.take.js","skipped":false,"dir":"tests"},{"name":"Iterator#toArray","suites":[],"line":3,"code":"QUnit.test('Iterator#toArray', assert => {\n  const {\n    toArray\n  } = Iterator.prototype;\n  assert.isFunction(toArray);\n  assert.arity(toArray, 0);\n  assert.nonEnumerable(Iterator.prototype, 'toArray');\n  assert.arrayEqual(Iterator.from('123').toArray(), ['1', '2', '3']);\n  assert.arrayEqual(Iterator.from(createIterable([1, 2, 3])).toArray(), [1, 2, 3]);\n  assert.arrayEqual(toArray.call(createIterator([1, 2, 3])), [1, 2, 3]);\n  assert.throws(() => toArray.call(undefined), TypeError);\n  assert.throws(() => toArray.call(null), TypeError);\n  assert.throws(() => toArray.call({}), TypeError);\n  assert.throws(() => toArray.call([]), TypeError);\n});","file":"pure/esnext.iterator.to-array.js","skipped":false,"dir":"tests"},{"name":"Iterator#toAsync","suites":[],"line":6,"code":"QUnit.test('Iterator#toAsync', assert => {\n  assert.expect(STRICT ? 6 : 4);\n  const async = assert.async();\n  const {\n    toAsync\n  } = Iterator.prototype;\n  assert.isFunction(toAsync);\n  assert.arity(toAsync, 0);\n\n  if (STRICT) {\n    assert.throws(() => toAsync.call(undefined), TypeError);\n    assert.throws(() => toAsync.call(null), TypeError);\n  }\n\n  Iterator.from([1, 2, 3]).toAsync().map(it => Promise.resolve(it)).toArray().then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n  }).then(() => {\n    return Iterator.from(new Set([1, 2, 3])).toAsync().map(it => Promise.resolve(it)).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n    async();\n  });\n});","file":"pure/esnext.iterator.to-async.js","skipped":false,"dir":"tests"},{"name":"Map#deleteAll","suites":[],"line":3,"code":"QUnit.test('Map#deleteAll', assert => {\n  const {\n    deleteAll\n  } = Map.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.nonEnumerable(Map.prototype, 'deleteAll');\n  let set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.true(set.deleteAll(1, 2));\n  assert.deepEqual(from(set), [[3, 4]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.false(set.deleteAll(3, 4));\n  assert.deepEqual(from(set), [[1, 2], [2, 3]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.false(set.deleteAll(4, 5));\n  assert.deepEqual(from(set), [[1, 2], [2, 3], [3, 4]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.true(set.deleteAll());\n  assert.deepEqual(from(set), [[1, 2], [2, 3], [3, 4]]);\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => deleteAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(null, 1, 2, 3), TypeError);\n});","file":"pure/esnext.map.delete-all.js","skipped":false,"dir":"tests"},{"name":"Map#emplace","suites":[],"line":2,"code":"QUnit.test('Map#emplace', assert => {\n  const {\n    emplace\n  } = Map.prototype;\n  assert.isFunction(emplace);\n  assert.arity(emplace, 2);\n  assert.name(emplace, 'emplace');\n  assert.nonEnumerable(Map.prototype, 'emplace');\n  const map = new Map([['a', 2]]);\n  let handler = {\n    update(value, key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 2, 'correct value in callback');\n      assert.same(key, 'a', 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return value ** 2;\n    },\n\n    insert() {\n      assert.avoid();\n    }\n\n  };\n  assert.same(map.emplace('a', handler), 4, 'returns a correct value');\n  handler = {\n    update() {\n      assert.avoid();\n    },\n\n    insert(key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 2, 'correct number of callback arguments');\n      assert.same(key, 'b', 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return 3;\n    }\n\n  };\n  assert.same(map.emplace('b', handler), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).emplace('b', {\n    insert: () => 3\n  }), 3);\n  assert.same(new Map([['a', 2]]).emplace('a', {\n    update: value => value ** 2\n  }), 4);\n  handler = {\n    update() {\n      /* empty */\n    },\n\n    insert() {\n      /* empty */\n    }\n\n  };\n  assert.throws(() => new Map().emplace('a'), TypeError);\n  assert.throws(() => emplace.call({}, 'a', handler), TypeError);\n  assert.throws(() => emplace.call([], 'a', handler), TypeError);\n  assert.throws(() => emplace.call(undefined, 'a', handler), TypeError);\n  assert.throws(() => emplace.call(null, 'a', handler), TypeError);\n});","file":"pure/esnext.map.emplace.js","skipped":false,"dir":"tests"},{"name":"Map#every","suites":[],"line":2,"code":"QUnit.test('Map#every', assert => {\n  const {\n    every\n  } = Map.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.nonEnumerable(Map.prototype, 'every');\n  let map = new Map([[9, 1]]);\n  const context = {};\n  map.every(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 9, 'correct index in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  map = new Map([[0, 1], [1, 2], [2, 3]]);\n  assert.true(map.every(it => typeof it == 'number'));\n  assert.true(map.every(it => it < 4));\n  assert.false(map.every(it => it < 3));\n  assert.false(map.every(it => typeof it == 'string'));\n  assert.true(map.every(function () {\n    return +this === 1;\n  }, 1));\n  let result = '';\n  map.every((value, key) => result += key);\n  assert.same(result, '012');\n  assert.true(map.every((value, key, that) => that === map));\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.every.js","skipped":false,"dir":"tests"},{"name":"Map#filter","suites":[],"line":3,"code":"QUnit.test('Map#filter', assert => {\n  const {\n    filter\n  } = Map.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.nonEnumerable(Map.prototype, 'filter');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.filter(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).filter(it => typeof it == 'number')), [['a', 1], [1, 2], ['b', 3], [3, 4], [4, 5]]);\n  assert.true(new Map().filter(it => it) instanceof Map);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.filter.js","skipped":false,"dir":"tests"},{"name":"Map#findKey","suites":[],"line":2,"code":"QUnit.test('Map#findKey', assert => {\n  const {\n    findKey\n  } = Map.prototype;\n  assert.isFunction(findKey);\n  assert.arity(findKey, 1);\n  assert.nonEnumerable(Map.prototype, 'findKey');\n  const set = new Map([[1, 2]]);\n  const context = {};\n  set.findKey(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Map([[1, 2], [2, 3], [3, 4]]).findKey(it => it % 2), 2);\n  assert.same(new Map().findKey(it => it === 42), undefined);\n  assert.throws(() => findKey.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.find-key.js","skipped":false,"dir":"tests"},{"name":"Map#find","suites":[],"line":2,"code":"QUnit.test('Map#find', assert => {\n  const {\n    find\n  } = Map.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.nonEnumerable(Map.prototype, 'find');\n  const set = new Map([[1, 2]]);\n  const context = {};\n  set.find(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Map([[1, 2], [2, 3], [3, 4]]).find(it => it % 2), 3);\n  assert.same(new Map().find(it => it === 42), undefined);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.find.js","skipped":false,"dir":"tests"},{"name":"Map.from","suites":[],"line":4,"code":"QUnit.test('Map.from', assert => {\n  const {\n    from\n  } = Map;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(Map.from() instanceof Map);\n  assert.deepEqual(toArray(Map.from([])), []);\n  assert.deepEqual(toArray(Map.from([[1, 2]])), [[1, 2]]);\n  assert.deepEqual(toArray(Map.from([[1, 2], [2, 3], [1, 4]])), [[1, 4], [2, 3]]);\n  assert.deepEqual(toArray(Map.from(createIterable([[1, 2], [2, 3], [1, 4]]))), [[1, 4], [2, 3]]);\n  const pair = [1, 2];\n  const context = {};\n  Map.from([pair], function (element, index) {\n    assert.same(element, pair);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from([1, 2]));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"pure/esnext.map.from.js","skipped":false,"dir":"tests"},{"name":"Map.groupBy","suites":[],"line":4,"code":"QUnit.test('Map.groupBy', assert => {\n  const {\n    groupBy\n  } = Map;\n  assert.isFunction(groupBy);\n  assert.arity(groupBy, 2);\n  assert.name(groupBy, 'groupBy');\n  assert.true(Map.groupBy([], it => it) instanceof Map);\n  assert.deepEqual(from(Map.groupBy([], it => it)), []);\n  assert.deepEqual(from(Map.groupBy([1, 2], it => it ** 2)), [[1, [1]], [4, [2]]]);\n  assert.deepEqual(from(Map.groupBy([1, 2, 1], it => it ** 2)), [[1, [1, 1]], [4, [2]]]);\n  assert.deepEqual(from(Map.groupBy(createIterable([1, 2]), it => it ** 2)), [[1, [1]], [4, [2]]]);\n  const element = {};\n  Map.groupBy([element], it => assert.same(it, element));\n  assert.throws(() => groupBy([1, 2], it => it));\n});","file":"pure/esnext.map.group-by.js","skipped":false,"dir":"tests"},{"name":"Map#includes","suites":[],"line":2,"code":"QUnit.test('Map#includes', assert => {\n  const {\n    includes\n  } = Map.prototype;\n  assert.isFunction(includes);\n  assert.name(includes, 'includes');\n  assert.arity(includes, 1);\n  assert.nonEnumerable(Map.prototype, 'includes');\n  const object = {};\n  const map = new Map([[1, 1], [2, 2], [3, 3], [4, -0], [5, object], [6, NaN]]);\n  assert.true(map.includes(1));\n  assert.true(map.includes(-0));\n  assert.true(map.includes(0));\n  assert.true(map.includes(object));\n  assert.false(map.includes(4));\n  assert.false(map.includes(-0.5));\n  assert.false(map.includes({}));\n  assert.true(map.includes(NaN));\n  assert.throws(() => includes.call({}, 1), TypeError);\n  assert.throws(() => includes.call(undefined, 1), TypeError);\n  assert.throws(() => includes.call(null, 1), TypeError);\n});","file":"pure/esnext.map.includes.js","skipped":false,"dir":"tests"},{"name":"Map.keyBy","suites":[],"line":4,"code":"QUnit.test('Map.keyBy', assert => {\n  const {\n    keyBy\n  } = Map;\n  assert.isFunction(keyBy);\n  assert.arity(keyBy, 2);\n  assert.name(keyBy, 'keyBy');\n  assert.true(Map.keyBy([], it => it) instanceof Map);\n  assert.deepEqual(from(Map.keyBy([], it => it)), []);\n  assert.deepEqual(from(Map.keyBy([1, 2], it => it ** 2)), [[1, 1], [4, 2]]);\n  assert.deepEqual(from(Map.keyBy([1, 2, 1], it => it ** 2)), [[1, 1], [4, 2]]);\n  assert.deepEqual(from(Map.keyBy(createIterable([1, 2]), it => it ** 2)), [[1, 1], [4, 2]]);\n  const element = {};\n  Map.keyBy([element], it => assert.same(it, element));\n  assert.throws(() => keyBy([1, 2], it => it));\n});","file":"pure/esnext.map.key-by.js","skipped":false,"dir":"tests"},{"name":"Map#keyOf","suites":[],"line":2,"code":"QUnit.test('Map#keyOf', assert => {\n  const {\n    keyOf\n  } = Map.prototype;\n  assert.isFunction(keyOf);\n  assert.arity(keyOf, 1);\n  assert.nonEnumerable(Map.prototype, 'keyOf');\n  const object = {};\n  const map = new Map([[1, 1], [2, 2], [3, 3], [4, -0], [5, object], [6, NaN]]);\n  assert.same(map.keyOf(1), 1);\n  assert.same(map.keyOf(-0), 4);\n  assert.same(map.keyOf(0), 4);\n  assert.same(map.keyOf(object), 5);\n  assert.same(map.keyOf(4), undefined);\n  assert.same(map.keyOf(-0.5), undefined);\n  assert.same(map.keyOf({}), undefined);\n  assert.same(map.keyOf(NaN), undefined);\n  assert.throws(() => keyOf.call({}, 1), TypeError);\n  assert.throws(() => keyOf.call(undefined, 1), TypeError);\n  assert.throws(() => keyOf.call(null, 1), TypeError);\n});","file":"pure/esnext.map.key-of.js","skipped":false,"dir":"tests"},{"name":"Map#mapKeys","suites":[],"line":3,"code":"QUnit.test('Map#mapKeys', assert => {\n  const {\n    mapKeys\n  } = Map.prototype;\n  assert.isFunction(mapKeys);\n  assert.arity(mapKeys, 1);\n  assert.name(mapKeys, 'mapKeys');\n  assert.nonEnumerable(Map.prototype, 'mapKeys');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.mapKeys(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Map().mapKeys(it => it) instanceof Map);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).mapKeys((value, key) => `${key}${value}`)), [['a1', 1], ['12', 2], ['b3', 3], ['2q', 'q'], ['c[object Object]', {}], ['34', 4], ['dtrue', true], ['45', 5]]);\n  assert.throws(() => mapKeys.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.map-keys.js","skipped":false,"dir":"tests"},{"name":"Map#mapValues","suites":[],"line":3,"code":"QUnit.test('Map#mapValues', assert => {\n  const {\n    mapValues\n  } = Map.prototype;\n  assert.isFunction(mapValues);\n  assert.arity(mapValues, 1);\n  assert.name(mapValues, 'mapValues');\n  assert.nonEnumerable(Map.prototype, 'mapValues');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.mapValues(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Map().mapValues(it => it) instanceof Map);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).mapValues((value, key) => `${key}${value}`)), [['a', 'a1'], [1, '12'], ['b', 'b3'], [2, '2q'], ['c', 'c[object Object]'], [3, '34'], ['d', 'dtrue'], [4, '45']]);\n  assert.throws(() => mapValues.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.map-values.js","skipped":false,"dir":"tests"},{"name":"Map#merge","suites":[],"line":3,"code":"QUnit.test('Map#merge', assert => {\n  const {\n    merge\n  } = Map.prototype;\n  assert.isFunction(merge);\n  assert.arity(merge, 1);\n  assert.name(merge, 'merge');\n  assert.nonEnumerable(Map.prototype, 'merge');\n  const map = new Map([[1, 2]]);\n  const result = map.merge([[3, 4]]);\n  assert.same(result, map);\n  assert.true(result instanceof Map);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[5, 6]])), [[1, 2], [3, 4], [5, 6]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[3, 5], [5, 6]])), [[1, 2], [3, 5], [5, 6]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([])), [[1, 2], [3, 4]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[3, 5]], [[5, 6]])), [[1, 2], [3, 5], [5, 6]]);\n  assert.throws(() => merge.call({}, [[1, 2]]), TypeError);\n  assert.throws(() => merge.call(undefined, [[1, 2]]), TypeError);\n  assert.throws(() => merge.call(null, [[1, 2]]), TypeError);\n});","file":"pure/esnext.map.merge.js","skipped":false,"dir":"tests"},{"name":"Map.of","suites":[],"line":3,"code":"QUnit.test('Map.of', assert => {\n  const {\n    of\n  } = Map;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.true(Map.of() instanceof Map);\n  assert.deepEqual(from(Map.of([1, 2])), [[1, 2]]);\n  assert.deepEqual(from(Map.of([1, 2], [2, 3], [1, 4])), [[1, 4], [2, 3]]);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"pure/esnext.map.of.js","skipped":false,"dir":"tests"},{"name":"Map#reduce","suites":[],"line":2,"code":"QUnit.test('Map#reduce', assert => {\n  const {\n    reduce\n  } = Map.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.nonEnumerable(Map.prototype, 'reduce');\n  const set = new Map([['a', 1]]);\n  const accumulator = {};\n  set.reduce(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 'a', 'correct index in callback');\n    assert.same(that, set, 'correct link to set in callback');\n  }, accumulator);\n  assert.same(new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  new Map([['a', 1], ['b', 2]]).reduce((memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 'b', 'correct start index without initial accumulator');\n  });\n  assert.same(new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((memo, value, key, s) => {\n    s.delete('b');\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '13', 'correct order #1');\n  assert.same(keys, 'ac', 'correct order #2');\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n});","file":"pure/esnext.map.reduce.js","skipped":false,"dir":"tests"},{"name":"Map#some","suites":[],"line":2,"code":"QUnit.test('Map#some', assert => {\n  const {\n    some\n  } = Map.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.nonEnumerable(Map.prototype, 'some');\n  let map = new Map([[9, 1]]);\n  const context = {};\n  map.some(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 9, 'correct index in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  map = new Map([[0, 1], [1, '2'], [2, 3]]);\n  assert.true(map.some(it => typeof it == 'number'));\n  assert.true(map.some(it => it < 3));\n  assert.false(map.some(it => it < 0));\n  assert.true(map.some(it => typeof it == 'string'));\n  assert.false(map.some(function () {\n    return +this !== 1;\n  }, 1));\n  let result = '';\n  map.some((value, key) => {\n    result += key;\n    return false;\n  });\n  assert.same(result, '012');\n  assert.true(map.some((value, key, that) => that === map));\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.some.js","skipped":false,"dir":"tests"},{"name":"Map#updateOrInsert","suites":[],"line":2,"code":"QUnit.test('Map#updateOrInsert', assert => {\n  const {\n    updateOrInsert\n  } = Map.prototype;\n  assert.isFunction(updateOrInsert);\n  assert.arity(updateOrInsert, 2);\n  assert.nonEnumerable(Map.prototype, 'updateOrInsert');\n  const map = new Map([['a', 2]]);\n  assert.same(map.updateOrInsert('a', function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.updateOrInsert('b', value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).updateOrInsert('b', null, () => 3), 3);\n  assert.same(new Map([['a', 2]]).updateOrInsert('a', value => value ** 2), 4);\n  assert.throws(() => new Map().updateOrInsert('a'), TypeError);\n  assert.throws(() => updateOrInsert.call({}, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call([], 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call(undefined, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call(null, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.update-or-insert.js","skipped":false,"dir":"tests"},{"name":"Map#update","suites":[],"line":2,"code":"QUnit.test('Map#update', assert => {\n  const {\n    update\n  } = Map.prototype;\n  assert.isFunction(update);\n  assert.arity(update, 2);\n  assert.name(update, 'update');\n  assert.nonEnumerable(Map.prototype, 'update');\n  let map = new Map([[9, 2]]);\n  assert.same(map.update(9, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 9, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    return value * 2;\n  }), map, 'returns this');\n  assert.same(map.size, 1, 'correct size');\n  assert.same(map.get(9), 4, 'correct result');\n  map = new Map([[4, 5]]);\n  map.update(9, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 9, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    return value * 2;\n  }, function (key, that) {\n    assert.same(arguments.length, 2, 'correct number of thunk arguments');\n    assert.same(key, 9, 'correct key in thunk');\n    assert.same(that, map, 'correct link to map in thunk');\n    return 2;\n  });\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get(4), 5, 'correct result #1');\n  assert.same(map.get(9), 4, 'correct result #2');\n  assert.throws(() => new Map([[9, 2]]).update(9), TypeError);\n  assert.throws(() => new Map().update(9, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.update.js","skipped":false,"dir":"tests"},{"name":"Map#upsert","suites":[],"line":2,"code":"QUnit.test('Map#upsert', assert => {\n  const {\n    upsert\n  } = Map.prototype;\n  assert.isFunction(upsert);\n  assert.arity(upsert, 2);\n  assert.nonEnumerable(Map.prototype, 'upsert');\n  const map = new Map([['a', 2]]);\n  assert.same(map.upsert('a', function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.upsert('b', value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).upsert('b', null, () => 3), 3);\n  assert.same(new Map([['a', 2]]).upsert('a', value => value ** 2), 4);\n  assert.throws(() => new Map().upsert('a'), TypeError);\n  assert.throws(() => upsert.call({}, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call([], 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(undefined, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(null, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.map.upsert.js","skipped":false,"dir":"tests"},{"name":"Math.clamp","suites":[],"line":2,"code":"QUnit.test('Math.clamp', assert => {\n  assert.isFunction(clamp);\n  assert.arity(clamp, 3);\n  assert.same(clamp(2, 4, 6), 4);\n  assert.same(clamp(4, 2, 6), 4);\n  assert.same(clamp(6, 2, 4), 4);\n});","file":"pure/esnext.math.clamp.js","skipped":false,"dir":"tests"},{"name":"Math.DEG_PER_RAD","suites":[],"line":2,"code":"QUnit.test('Math.DEG_PER_RAD', assert => {\n  assert.same(DEG_PER_RAD, Math.PI / 180, 'Is Math.PI / 180');\n});","file":"pure/esnext.math.deg-per-rad.js","skipped":false,"dir":"tests"},{"name":"Math.degrees","suites":[],"line":2,"code":"QUnit.test('Math.degrees', assert => {\n  assert.isFunction(degrees);\n  assert.arity(degrees, 1);\n  assert.same(degrees(0), 0);\n  assert.same(degrees(Math.PI / 2), 90);\n  assert.same(degrees(Math.PI), 180);\n  assert.same(degrees(3 * Math.PI / 2), 270);\n});","file":"pure/esnext.math.degrees.js","skipped":false,"dir":"tests"},{"name":"Math.fscale","suites":[],"line":2,"code":"QUnit.test('Math.fscale', assert => {\n  assert.isFunction(fscale);\n  assert.arity(fscale, 5);\n  assert.same(fscale(3, 1, 2, 1, 2), 3);\n  assert.same(fscale(0, 3, 5, 8, 10), 5);\n  assert.same(fscale(1, 1, 1, 1, 1), NaN);\n  assert.same(fscale(-1, -1, -1, -1, -1), NaN);\n});","file":"pure/esnext.math.fscale.js","skipped":false,"dir":"tests"},{"name":"Math.iaddh","suites":[],"line":2,"code":"QUnit.test('Math.iaddh', assert => {\n  assert.isFunction(iaddh);\n  assert.arity(iaddh, 4);\n  assert.same(iaddh(0, 2, 1, 0), 2);\n  assert.same(iaddh(0, 4, 1, 1), 5);\n  assert.same(iaddh(2, 4, 1, 1), 5);\n  assert.same(iaddh(0xFFFFFFFF, 4, 1, 1), 6);\n  assert.same(iaddh(1, 4, 0xFFFFFFFF, 1), 6);\n});","file":"pure/esnext.math.iaddh.js","skipped":false,"dir":"tests"},{"name":"Math.imulh","suites":[],"line":2,"code":"QUnit.test('Math.imulh', assert => {\n  assert.isFunction(imulh);\n  assert.arity(imulh, 2);\n  assert.same(imulh(0xFFFFFFFF, 7), -1);\n  assert.same(imulh(0xFFFFFFF, 77), 4);\n  assert.same(imulh(1, 7), 0);\n  assert.same(imulh(-1, 7), -1);\n});","file":"pure/esnext.math.imulh.js","skipped":false,"dir":"tests"},{"name":"Math.isubh","suites":[],"line":2,"code":"QUnit.test('Math.isubh', assert => {\n  assert.isFunction(isubh);\n  assert.arity(isubh, 4);\n  assert.same(isubh(0, 2, 1, 0), 1);\n  assert.same(isubh(0, 4, 1, 1), 2);\n  assert.same(isubh(2, 4, 1, 1), 3);\n  assert.same(isubh(0xFFFFFFFF, 4, 1, 1), 3);\n  assert.same(isubh(1, 4, 0xFFFFFFFF, 1), 2);\n});","file":"pure/esnext.math.isubh.js","skipped":false,"dir":"tests"},{"name":"Math.RAD_PER_DEG","suites":[],"line":2,"code":"QUnit.test('Math.RAD_PER_DEG', assert => {\n  assert.same(RAD_PER_DEG, 180 / Math.PI, 'Is 180 / Math.PI');\n});","file":"pure/esnext.math.rad-per-deg.js","skipped":false,"dir":"tests"},{"name":"Math.radians","suites":[],"line":2,"code":"QUnit.test('Math.radians', assert => {\n  assert.isFunction(radians);\n  assert.arity(radians, 1);\n  assert.same(radians(0), 0);\n  assert.same(radians(90), Math.PI / 2);\n  assert.same(radians(180), Math.PI);\n  assert.same(radians(270), 3 * Math.PI / 2);\n});","file":"pure/esnext.math.radians.js","skipped":false,"dir":"tests"},{"name":"Math.scale","suites":[],"line":2,"code":"QUnit.test('Math.scale', assert => {\n  assert.isFunction(scale);\n  assert.arity(scale, 5);\n  assert.same(scale(3, 1, 2, 1, 2), 3);\n  assert.same(scale(0, 3, 5, 8, 10), 5);\n  assert.same(scale(1, 1, 1, 1, 1), NaN);\n  assert.same(scale(-1, -1, -1, -1, -1), NaN);\n});","file":"pure/esnext.math.scale.js","skipped":false,"dir":"tests"},{"name":"Math.seededPRNG","suites":[],"line":2,"code":"QUnit.test('Math.seededPRNG', assert => {\n  assert.isFunction(seededPRNG);\n  assert.arity(seededPRNG, 1);\n\n  for (const gen of [seededPRNG({\n    seed: 42\n  }), seededPRNG({\n    seed: 42\n  })]) {\n    assert.deepEqual(gen.next(), {\n      value: 0.16461519912315087,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.2203933906000046,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.8249682894209105,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.10750079537509083,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.004673248161257476,\n      done: false\n    });\n  }\n\n  for (const gen of [seededPRNG({\n    seed: 43\n  }), seededPRNG({\n    seed: 43\n  })]) {\n    assert.deepEqual(gen.next(), {\n      value: 0.1923438591811283,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.7896811578326683,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.9518230761883996,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.1414634102410296,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.7379838030207752,\n      done: false\n    });\n  }\n\n  assert.throws(() => seededPRNG(), TypeError);\n  assert.throws(() => seededPRNG(5), TypeError);\n  assert.throws(() => seededPRNG({\n    seed: null\n  }), TypeError);\n});","file":"pure/esnext.math.seeded-prng.js","skipped":false,"dir":"tests"},{"name":"Math.signbit","suites":[],"line":2,"code":"QUnit.test('Math.signbit', assert => {\n  assert.isFunction(signbit);\n  assert.false(signbit(NaN));\n  assert.false(signbit());\n  assert.true(signbit(-0));\n  assert.false(signbit(0));\n  assert.false(signbit(Infinity));\n  assert.true(signbit(-Infinity));\n  assert.false(signbit(13510798882111488));\n  assert.true(signbit(-13510798882111488));\n  assert.false(signbit(42.5));\n  assert.true(signbit(-42.5));\n});","file":"pure/esnext.math.signbit.js","skipped":false,"dir":"tests"},{"name":"Math.umulh","suites":[],"line":2,"code":"QUnit.test('Math.umulh', assert => {\n  assert.isFunction(umulh);\n  assert.arity(umulh, 2);\n  assert.same(umulh(0xFFFFFFFF, 7), 6);\n  assert.same(umulh(0xFFFFFFF, 77), 4);\n  assert.same(umulh(1, 7), 0);\n  assert.same(umulh(-1, 7), 6);\n});","file":"pure/esnext.math.umulh.js","skipped":false,"dir":"tests"},{"name":"Number.fromString","suites":[],"line":2,"code":"QUnit.test('Number.fromString', assert => {\n  assert.isFunction(fromString);\n  assert.name(fromString, 'fromString');\n  assert.arity(fromString, 2);\n  assert.throws(() => fromString(undefined), TypeError, 'The first argument should be a string #1');\n  assert.throws(() => fromString(Object('10')), TypeError, 'The first argument should be a string #1');\n  assert.throws(() => fromString(''), SyntaxError, 'Empty string');\n  assert.same(fromString('-10', 2), -2, 'Works with negative numbers');\n  assert.throws(() => fromString('-'), SyntaxError, '-');\n  assert.same(fromString('10'), 10, 'Default radix is 10 #1');\n  assert.same(fromString('10', undefined), 10, 'Default radix is 10 #2');\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(fromString('10', radix), radix, `Radix ${radix}`);\n  }\n\n  assert.throws(() => fromString('10', -4294967294), RangeError, 'Radix uses ToInteger #1');\n  assert.same(fromString('10', 2.5), 2, 'Radix uses ToInteger #2');\n  assert.same(fromString('42'), 42);\n  assert.same(fromString('42', 10), 42);\n  assert.throws(() => fromString('0xc0ffee'), SyntaxError);\n  assert.throws(() => fromString('0o755'), SyntaxError);\n  assert.throws(() => fromString('0b00101010'), SyntaxError);\n  assert.throws(() => fromString('C0FFEE', 16), SyntaxError);\n  assert.same(fromString('c0ffee', 16), 12648430);\n  assert.same(fromString('755', 8), 493);\n  assert.throws(() => fromString(''), SyntaxError);\n  assert.throws(() => fromString(' '), SyntaxError);\n  assert.throws(() => fromString(' 1'), SyntaxError);\n  assert.throws(() => fromString(' \\n '), SyntaxError);\n  assert.throws(() => fromString('x'), SyntaxError);\n  assert.throws(() => fromString('1234', 0), RangeError);\n  assert.throws(() => fromString('1234', 1), RangeError);\n  assert.throws(() => fromString('1234', 37), RangeError);\n  assert.throws(() => fromString('010'), SyntaxError);\n  assert.throws(() => fromString('1_000_000_000'), SyntaxError);\n});","file":"pure/esnext.number.from-string.js","skipped":false,"dir":"tests"},{"name":"range","suites":[],"line":3,"code":"QUnit.test('range', assert => {\n  assert.isFunction(range);\n  assert.name(range, 'range');\n  assert.arity(range, 3);\n  let iterator = range(1, 2);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.deepEqual(from(range(-1, 5)), [-1, 0, 1, 2, 3, 4]);\n  assert.deepEqual(from(range(-5, 1)), [-5, -4, -3, -2, -1, 0]);\n  assert.deepEqual(from(range(0, 1, 0.1)), [0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]);\n  assert.deepEqual(from(range(2 ** 53 - 1, 2 ** 53, {\n    inclusive: true\n  })), [9007199254740991, 9007199254740992]);\n  assert.deepEqual(from(range(0, 0)), []);\n  assert.deepEqual(from(range(0, -5, 1)), []);\n  assert.deepEqual(from(range(NaN, 0)), []);\n  assert.deepEqual(from(range(0, NaN)), []);\n  assert.deepEqual(from(range(NaN, NaN)), []);\n  assert.deepEqual(from(range(0, 0, {\n    step: NaN\n  })), []);\n  assert.deepEqual(from(range(0, 5, NaN)), []);\n  iterator = range(1, 3);\n  assert.deepEqual(iterator.start, 1);\n  assert.deepEqual(iterator.end, 3);\n  assert.deepEqual(iterator.step, 1);\n  assert.false(iterator.inclusive);\n  iterator = range(-1, -3, {\n    inclusive: true\n  });\n  assert.deepEqual(iterator.start, -1);\n  assert.deepEqual(iterator.end, -3);\n  assert.same(iterator.step, -1);\n  assert.true(iterator.inclusive);\n  iterator = range(-1, -3, {\n    step: 4,\n\n    inclusive() {\n      /* empty */\n    }\n\n  });\n  assert.same(iterator.start, -1);\n  assert.same(iterator.end, -3);\n  assert.same(iterator.step, 4);\n  assert.true(iterator.inclusive);\n  iterator = range(0, 5); // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\n  assert.throws(() => Object.getOwnPropertyDescriptor(iterator, 'start').call({}), TypeError);\n  assert.throws(() => range(Infinity, 10, 0), RangeError);\n  assert.throws(() => range(-Infinity, 10, 0), RangeError);\n  assert.throws(() => range(0, 10, Infinity), RangeError);\n  assert.throws(() => range(0, 10, {\n    step: Infinity\n  }), RangeError);\n  assert.throws(() => range({}, 1), TypeError);\n  assert.throws(() => range(1, {}), TypeError);\n});","file":"pure/esnext.number.range.js","skipped":false,"dir":"tests"},{"name":"Object.iterateEntries","suites":[],"line":3,"code":"QUnit.test('Object.iterateEntries', assert => {\n  assert.isFunction(iterateEntries);\n  assert.name(iterateEntries, 'iterateEntries');\n  assert.arity(iterateEntries, 1);\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateEntries(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['q', 1],\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: ['e', 3],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/esnext.object.iterate-entries.js","skipped":false,"dir":"tests"},{"name":"Object.iterateKeys","suites":[],"line":3,"code":"QUnit.test('Object.iterateKeys', assert => {\n  assert.isFunction(iterateKeys);\n  assert.name(iterateKeys, 'iterateKeys');\n  assert.arity(iterateKeys, 1);\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateKeys(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/esnext.object.iterate-keys.js","skipped":false,"dir":"tests"},{"name":"Object.iterateValues","suites":[],"line":3,"code":"QUnit.test('Object.iterateValues', assert => {\n  assert.isFunction(iterateValues);\n  assert.name(iterateValues, 'iterateValues');\n  assert.arity(iterateValues, 1);\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateValues(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: 3,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"pure/esnext.object.iterate-values.js","skipped":false,"dir":"tests"},{"name":"Observable","suites":[],"line":4,"code":"QUnit.test('Observable', assert => {\n  assert.isFunction(Observable);\n  assert.arity(Observable, 1);\n  assert.throws(() => Observable(() => {\n    /* empty */\n  }), 'throws w/o `new`');\n  const observable = new Observable(function (subscriptionObserver) {\n    assert.same(typeof subscriptionObserver, 'object', 'Subscription observer is object');\n    assert.same(subscriptionObserver.constructor, Object);\n    const {\n      next,\n      error,\n      complete\n    } = subscriptionObserver;\n    assert.isFunction(next);\n    assert.isFunction(error);\n    assert.isFunction(complete);\n    assert.arity(next, 1);\n    assert.arity(error, 1);\n    assert.arity(complete, 0);\n\n    if (STRICT) {\n      assert.same(this, undefined, 'correct executor context');\n    }\n  });\n  observable.subscribe({});\n  assert.true(observable instanceof Observable);\n});","file":"pure/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#subscribe","suites":[],"line":32,"code":"QUnit.test('Observable#subscribe', assert => {\n  assert.isFunction(Observable.prototype.subscribe);\n  assert.arity(Observable.prototype.subscribe, 1);\n  const subscription = new Observable(() => {\n    /* empty */\n  }).subscribe({});\n  assert.same(typeof subscription, 'object', 'Subscription is object');\n  assert.same(subscription.constructor, Object);\n  assert.isFunction(subscription.unsubscribe);\n  assert.arity(subscription.unsubscribe, 0);\n});","file":"pure/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#constructor","suites":[],"line":43,"code":"QUnit.test('Observable#constructor', assert => {\n  assert.same(Observable.prototype.constructor, Observable);\n});","file":"pure/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#@@observable","suites":[],"line":46,"code":"QUnit.test('Observable#@@observable', assert => {\n  assert.isFunction(Observable.prototype[Symbol.observable]);\n  const observable = new Observable(() => {\n    /* empty*/\n  });\n  assert.same(observable[Symbol.observable](), observable);\n});","file":"pure/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable.from","suites":[],"line":2,"code":"QUnit.test('Observable.from', assert => {\n  assert.isFunction(Observable.from);\n  assert.arity(Observable.from, 1);\n});","file":"pure/esnext.observable.from.js","skipped":false,"dir":"tests"},{"name":"Observable.of","suites":[],"line":2,"code":"QUnit.test('Observable.of', assert => {\n  assert.isFunction(Observable.of);\n  assert.arity(Observable.of, 0);\n});","file":"pure/esnext.observable.of.js","skipped":false,"dir":"tests"},{"name":"Promise.try","suites":[],"line":2,"code":"QUnit.test('Promise.try', assert => {\n  assert.isFunction(Promise.try);\n  assert.arity(Promise.try, 1);\n  assert.true(Promise.try(() => 42) instanceof Promise, 'returns a promise');\n});","file":"pure/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Promise.try, resolved","suites":[],"line":7,"code":"QUnit.test('Promise.try, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.try(() => 42).then(it => {\n    assert.same(it, 42, 'resolved with a correct value');\n    async();\n  });\n});","file":"pure/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Promise.try, rejected","suites":[],"line":15,"code":"QUnit.test('Promise.try, rejected', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.try(() => {\n    throw new Error();\n  }).catch(() => {\n    assert.true(true, 'rejected as expected');\n    async();\n  });\n});","file":"pure/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineMetadata","suites":[],"line":2,"code":"QUnit.test('Reflect.defineMetadata', assert => {\n  assert.isFunction(defineMetadata);\n  assert.arity(defineMetadata, 3);\n  assert.throws(() => defineMetadata('key', 'value', undefined, undefined), TypeError);\n  assert.same(defineMetadata('key', 'value', {}, undefined), undefined);\n  assert.same(defineMetadata('key', 'value', {}, 'name'), undefined);\n});","file":"pure/esnext.reflect.define-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.deleteMetadata","suites":[],"line":5,"code":"QUnit.test('Reflect.deleteMetadata', assert => {\n  assert.isFunction(deleteMetadata);\n  assert.arity(deleteMetadata, 2);\n  assert.throws(() => deleteMetadata('key', undefined, undefined), TypeError);\n  assert.false(deleteMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(deleteMetadata('key', object, undefined));\n  const prototype = {};\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.false(deleteMetadata('key', create(prototype), undefined));\n  object = {};\n  defineMetadata('key', 'value', object, undefined);\n  deleteMetadata('key', object, undefined);\n  assert.false(hasOwnMetadata('key', object, undefined));\n});","file":"pure/esnext.reflect.delete-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getMetadataKeys","suites":[],"line":4,"code":"QUnit.test('Reflect.getMetadataKeys', assert => {\n  assert.isFunction(getMetadataKeys);\n  assert.arity(getMetadataKeys, 1);\n  assert.throws(() => getMetadataKeys(undefined, undefined), TypeError);\n  assert.deepEqual(getMetadataKeys({}, undefined), []);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key']);\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  defineMetadata('key0', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, undefined);\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1', 'key2']);\n  object = {};\n  assert.deepEqual(getMetadataKeys({}, 'name'), []);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key']);\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key']);\n  object = {};\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  defineMetadata('key0', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, 'name');\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key0', 'key1', 'key2']);\n});","file":"pure/esnext.reflect.get-metadata-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.getMetadata","suites":[],"line":4,"code":"QUnit.test('Reflect.getMetadata', assert => {\n  assert.isFunction(getMetadata);\n  assert.arity(getMetadata, 2);\n  assert.throws(() => getMetadata('key', undefined, undefined), TypeError);\n  assert.same(getMetadata('key', {}, undefined), undefined);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.same(getMetadata('key', object, undefined), 'value');\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.same(getMetadata('key', object, undefined), 'value');\n  assert.same(getMetadata('key', {}, 'name'), undefined);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.same(getMetadata('key', object, 'name'), 'value');\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.same(getMetadata('key', object, 'name'), 'value');\n});","file":"pure/esnext.reflect.get-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnMetadata","suites":[],"line":4,"code":"QUnit.test('Reflect.getOwnMetadata', assert => {\n  assert.isFunction(getOwnMetadata);\n  assert.arity(getOwnMetadata, 2);\n  assert.throws(() => getOwnMetadata('key', undefined, undefined), TypeError);\n  assert.same(getOwnMetadata('key', {}, undefined), undefined);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.same(getOwnMetadata('key', object, undefined), 'value');\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.same(getOwnMetadata('key', object, undefined), undefined);\n  assert.same(getOwnMetadata('key', {}, 'name'), undefined);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.same(getOwnMetadata('key', object, 'name'), 'value');\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.same(getOwnMetadata('key', object, 'name'), undefined);\n});","file":"pure/esnext.reflect.get-own-matadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnMetadataKeys","suites":[],"line":4,"code":"QUnit.test('Reflect.getOwnMetadataKeys', assert => {\n  assert.isFunction(getOwnMetadataKeys);\n  assert.arity(getOwnMetadataKeys, 1);\n  assert.throws(() => getOwnMetadataKeys(undefined, undefined), TypeError);\n  assert.deepEqual(getOwnMetadataKeys({}, undefined), []);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key']);\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), []);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  defineMetadata('key0', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, undefined);\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  assert.deepEqual(getOwnMetadataKeys({}, 'name'), []);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key']);\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), []);\n  object = {};\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  defineMetadata('key0', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, 'name');\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key0', 'key1']);\n});","file":"pure/esnext.reflect.get-own-metadata-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.hasMetadata","suites":[],"line":4,"code":"QUnit.test('Reflect.hasMetadata', assert => {\n  assert.isFunction(hasMetadata);\n  assert.arity(hasMetadata, 2);\n  assert.throws(() => hasMetadata('key', undefined, undefined), TypeError);\n  assert.false(hasMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(hasMetadata('key', object, undefined));\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.true(hasMetadata('key', object, undefined));\n  assert.false(hasMetadata('key', {}, 'name'));\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.true(hasMetadata('key', object, 'name'));\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.true(hasMetadata('key', object, 'name'));\n});","file":"pure/esnext.reflect.has-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.hasOwnMetadata","suites":[],"line":4,"code":"QUnit.test('Reflect.hasOwnMetadata', assert => {\n  assert.isFunction(hasOwnMetadata);\n  assert.arity(hasOwnMetadata, 2);\n  assert.throws(() => hasOwnMetadata('key', undefined, undefined), TypeError);\n  assert.false(hasOwnMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(hasOwnMetadata('key', object, undefined));\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.false(hasOwnMetadata('key', object, undefined));\n  assert.false(hasOwnMetadata('key', {}, 'name'));\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.true(hasOwnMetadata('key', object, 'name'));\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.false(hasOwnMetadata('key', object, 'name'));\n});","file":"pure/esnext.reflect.has-own-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.metadata","suites":[],"line":3,"code":"QUnit.test('Reflect.metadata', assert => {\n  assert.isFunction(metadata);\n  assert.arity(metadata, 2);\n  assert.isFunction(metadata('key', 'value'));\n  const decorator = metadata('key', 'value');\n  assert.throws(() => decorator(undefined, 'name'), TypeError);\n\n  let target = function () {\n    /* empty */\n  };\n\n  decorator(target);\n  assert.true(hasOwnMetadata('key', target, undefined));\n  target = {};\n  decorator(target, 'name');\n  assert.true(hasOwnMetadata('key', target, 'name'));\n});","file":"pure/esnext.reflect.metadata.js","skipped":false,"dir":"tests"},{"name":"Set#addAll","suites":[],"line":3,"code":"QUnit.test('Set#addAll', assert => {\n  const {\n    addAll\n  } = Set.prototype;\n  assert.isFunction(addAll);\n  assert.arity(addAll, 0);\n  assert.name(addAll, 'addAll');\n  assert.nonEnumerable(Set.prototype, 'addAll');\n  const set = new Set([1]);\n  assert.same(set.addAll(2), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll(4, 5)), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll(3, 4)), [1, 2, 3, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll()), [1, 2, 3]);\n  assert.notThrows(() => addAll.call({\n    add() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => addAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => addAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => addAll.call(null, 1, 2, 3), TypeError);\n});","file":"pure/esnext.set.add-all.js","skipped":false,"dir":"tests"},{"name":"Set#deleteAll","suites":[],"line":3,"code":"QUnit.test('Set#deleteAll', assert => {\n  const {\n    deleteAll\n  } = Set.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.nonEnumerable(Set.prototype, 'deleteAll');\n  let set = new Set([1, 2, 3]);\n  assert.true(set.deleteAll(1, 2));\n  assert.deepEqual(from(set), [3]);\n  set = new Set([1, 2, 3]);\n  assert.false(set.deleteAll(3, 4));\n  assert.deepEqual(from(set), [1, 2]);\n  set = new Set([1, 2, 3]);\n  assert.false(set.deleteAll(4, 5));\n  assert.deepEqual(from(set), [1, 2, 3]);\n  set = new Set([1, 2, 3]);\n  assert.true(set.deleteAll());\n  assert.deepEqual(from(set), [1, 2, 3]);\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => deleteAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(null, 1, 2, 3), TypeError);\n});","file":"pure/esnext.set.delete-all.js","skipped":false,"dir":"tests"},{"name":"Set#difference","suites":[],"line":4,"code":"QUnit.test('Set#difference', assert => {\n  const {\n    difference\n  } = Set.prototype;\n  assert.isFunction(difference);\n  assert.arity(difference, 1);\n  assert.name(difference, 'difference');\n  assert.nonEnumerable(Set.prototype, 'difference');\n  const set = new Set([1]);\n  assert.notSame(set.difference([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference([4, 5])), [1, 2, 3]);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference([3, 4])), [1, 2]);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference(createIterable([3, 4]))), [1, 2]);\n  assert.throws(() => new Set([1, 2, 3]).difference(), TypeError);\n  assert.throws(() => difference.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => difference.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => difference.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.difference.js","skipped":false,"dir":"tests"},{"name":"Set#every","suites":[],"line":2,"code":"QUnit.test('Set#every', assert => {\n  const {\n    every\n  } = Set.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.nonEnumerable(Set.prototype, 'every');\n  const set = new Set([1]);\n  const context = {};\n  set.every(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set([1, 2, 3]).every(it => typeof it == 'number'));\n  assert.false(new Set(['1', '2', '3']).some(it => typeof it == 'number'));\n  assert.false(new Set([1, '2', 3]).every(it => typeof it == 'number'));\n  assert.true(new Set().every(it => typeof it == 'number'));\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.set.every.js","skipped":false,"dir":"tests"},{"name":"Set#filter","suites":[],"line":3,"code":"QUnit.test('Set#filter', assert => {\n  const {\n    filter\n  } = Set.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.nonEnumerable(Set.prototype, 'filter');\n  const set = new Set([1]);\n  const context = {};\n  set.filter(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set().filter(it => it) instanceof Set);\n  assert.deepEqual(from(new Set([1, 2, 3, 'q', {}, 4, true, 5]).filter(it => typeof it == 'number')), [1, 2, 3, 4, 5]);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.set.filter.js","skipped":false,"dir":"tests"},{"name":"Set#find","suites":[],"line":2,"code":"QUnit.test('Set#find', assert => {\n  const {\n    find\n  } = Set.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.nonEnumerable(Set.prototype, 'find');\n  const set = new Set([1]);\n  const context = {};\n  set.find(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Set([2, 3, 4]).find(it => it % 2), 3);\n  assert.same(new Set().find(it => it === 42), undefined);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.set.find.js","skipped":false,"dir":"tests"},{"name":"Set.from","suites":[],"line":4,"code":"QUnit.test('Set.from', assert => {\n  const {\n    from\n  } = Set;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(Set.from() instanceof Set);\n  assert.deepEqual(toArray(Set.from([])), []);\n  assert.deepEqual(toArray(Set.from([1])), [1]);\n  assert.deepEqual(toArray(Set.from([1, 2, 3, 2, 1])), [1, 2, 3]);\n  assert.deepEqual(toArray(Set.from(createIterable([1, 2, 3, 2, 1]))), [1, 2, 3]);\n  const context = {};\n  Set.from([1], function (element, index) {\n    assert.same(element, 1);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"pure/esnext.set.from.js","skipped":false,"dir":"tests"},{"name":"Set#intersection","suites":[],"line":4,"code":"QUnit.test('Set#intersection', assert => {\n  const {\n    intersection\n  } = Set.prototype;\n  assert.isFunction(intersection);\n  assert.arity(intersection, 1);\n  assert.name(intersection, 'intersection');\n  assert.nonEnumerable(Set.prototype, 'intersection');\n  const set = new Set([1]);\n  assert.notSame(set.intersection([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection([4, 5])), []);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection([2, 3, 4])), [2, 3]);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection(createIterable([2, 3, 4]))), [2, 3]);\n  assert.throws(() => new Set([1, 2, 3]).intersection(), TypeError);\n  assert.throws(() => intersection.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => intersection.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => intersection.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.intersection.js","skipped":false,"dir":"tests"},{"name":"Set#isDisjointFrom","suites":[],"line":3,"code":"QUnit.test('Set#isDisjointFrom', assert => {\n  const {\n    isDisjointFrom\n  } = Set.prototype;\n  assert.isFunction(isDisjointFrom);\n  assert.arity(isDisjointFrom, 1);\n  assert.name(isDisjointFrom, 'isDisjointFrom');\n  assert.nonEnumerable(Set.prototype, 'isDisjointFrom');\n  assert.true(new Set([1]).isDisjointFrom([2]));\n  assert.false(new Set([1]).isDisjointFrom([1]));\n  assert.true(new Set([1, 2, 3]).isDisjointFrom([4, 5, 6]));\n  assert.false(new Set([1, 2, 3]).isDisjointFrom([5, 4, 3]));\n  assert.true(new Set([1]).isDisjointFrom(createIterable([2])));\n  assert.false(new Set([1]).isDisjointFrom(createIterable([1])));\n  assert.throws(() => new Set([1, 2, 3]).isDisjointFrom(), TypeError);\n  assert.throws(() => isDisjointFrom.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isDisjointFrom.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isDisjointFrom.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.is-disjoint-from.js","skipped":false,"dir":"tests"},{"name":"Set#isSubsetOf","suites":[],"line":3,"code":"QUnit.test('Set#isSubsetOf', assert => {\n  const {\n    isSubsetOf\n  } = Set.prototype;\n  assert.isFunction(isSubsetOf);\n  assert.arity(isSubsetOf, 1);\n  assert.name(isSubsetOf, 'isSubsetOf');\n  assert.nonEnumerable(Set.prototype, 'isSubsetOf');\n  assert.true(new Set([1]).isSubsetOf([1, 2, 3]));\n  assert.false(new Set([1]).isSubsetOf([2, 3, 4]));\n  assert.true(new Set([1, 2, 3]).isSubsetOf([5, 4, 3, 2, 1]));\n  assert.false(new Set([1, 2, 3]).isSubsetOf([5, 4, 3, 2]));\n  assert.true(new Set([1]).isSubsetOf(createIterable([1, 2, 3])));\n  assert.false(new Set([1]).isSubsetOf(createIterable([2, 3, 4])));\n  assert.true(new Set([1]).isSubsetOf({\n    has: () => true\n  }));\n  assert.false(new Set([1]).isSubsetOf({\n    has: () => false\n  }));\n  assert.true(isSubsetOf.call('ab', ['a', 'b', 'c']));\n  assert.false(isSubsetOf.call('ab', ['a']));\n  assert.throws(() => new Set([1, 2, 3]).isSubsetOf(), TypeError);\n  assert.throws(() => isSubsetOf.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isSubsetOf.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isSubsetOf.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.is-subset-of.js","skipped":false,"dir":"tests"},{"name":"Set#isSupersetOf","suites":[],"line":3,"code":"QUnit.test('Set#isSupersetOf', assert => {\n  const {\n    isSupersetOf\n  } = Set.prototype;\n  assert.isFunction(isSupersetOf);\n  assert.arity(isSupersetOf, 1);\n  assert.name(isSupersetOf, 'isSupersetOf');\n  assert.nonEnumerable(Set.prototype, 'isSupersetOf');\n  assert.true(new Set([1, 2, 3]).isSupersetOf([1]));\n  assert.false(new Set([2, 3, 4]).isSupersetOf([1]));\n  assert.true(new Set([5, 4, 3, 2, 1]).isSupersetOf([1, 2, 3]));\n  assert.false(new Set([5, 4, 3, 2]).isSupersetOf([1, 2, 3]));\n  assert.true(new Set([1, 2, 3]).isSupersetOf(createIterable([1])));\n  assert.false(new Set([2, 3, 4]).isSupersetOf(createIterable([1])));\n  assert.throws(() => new Set([1, 2, 3]).isSupersetOf(), TypeError);\n  assert.throws(() => isSupersetOf.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isSupersetOf.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isSupersetOf.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.is-superset-of.js","skipped":false,"dir":"tests"},{"name":"Set#join","suites":[],"line":3,"code":"QUnit.test('Set#join', assert => {\n  const {\n    join\n  } = Set.prototype;\n  assert.isFunction(join);\n  assert.arity(join, 1);\n  assert.name(join, 'join');\n  assert.nonEnumerable(Set.prototype, 'join');\n  assert.same(new Set([1, 2, 3]).join(), '1,2,3');\n  assert.same(new Set([1, 2, 3]).join(undefined), '1,2,3');\n  assert.same(new Set([1, 2, 3]).join('|'), '1|2|3');\n  assert.throws(() => join.call({}), TypeError);\n  assert.throws(() => join.call(undefined), TypeError);\n  assert.throws(() => join.call(null), TypeError);\n});","file":"pure/esnext.set.join.js","skipped":false,"dir":"tests"},{"name":"Set#map","suites":[],"line":3,"code":"QUnit.test('Set#map', assert => {\n  const {\n    map\n  } = Set.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.name(map, 'map');\n  assert.nonEnumerable(Set.prototype, 'map');\n  const set = new Set([1]);\n  const context = {};\n  set.map(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set().map(it => it) instanceof Set);\n  assert.deepEqual(from(new Set([1, 2, 3]).map(it => it ** 2)), [1, 4, 9]);\n  assert.deepEqual(from(new Set([1, 2, 3]).map(it => it % 2)), [1, 0]);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.set.map.js","skipped":false,"dir":"tests"},{"name":"Set.of","suites":[],"line":3,"code":"QUnit.test('Set.of', assert => {\n  const {\n    of\n  } = Set;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.true(Set.of() instanceof Set);\n  assert.deepEqual(from(Set.of(1)), [1]);\n  assert.deepEqual(from(Set.of(1, 2, 3, 2, 1)), [1, 2, 3]);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"pure/esnext.set.of.js","skipped":false,"dir":"tests"},{"name":"Set#reduce","suites":[],"line":2,"code":"QUnit.test('Set#reduce', assert => {\n  const {\n    reduce\n  } = Set.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.nonEnumerable(Set.prototype, 'reduce');\n  const set = new Set([1]);\n  const accumulator = {};\n  set.reduce(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct index in callback');\n    assert.same(that, set, 'correct link to set in callback');\n  }, accumulator);\n  assert.same(new Set([1, 2, 3]).reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  new Set([1, 2]).reduce((memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 2, 'correct start index without initial accumulator');\n  });\n  assert.same(new Set([1, 2, 3]).reduce((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  new Set([1, 2, 3]).reduce((memo, value, key, s) => {\n    s.delete(2);\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '13', 'correct order #1');\n  assert.same(keys, '13', 'correct order #2');\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n});","file":"pure/esnext.set.reduce.js","skipped":false,"dir":"tests"},{"name":"Set#some","suites":[],"line":2,"code":"QUnit.test('Set#some', assert => {\n  const {\n    some\n  } = Set.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.nonEnumerable(Set.prototype, 'some');\n  const set = new Set([1]);\n  const context = {};\n  set.some(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set([1, 2, 3]).some(it => typeof it == 'number'));\n  assert.false(new Set(['1', '2', '3']).some(it => typeof it == 'number'));\n  assert.true(new Set([1, '2', 3]).some(it => typeof it == 'number'));\n  assert.false(new Set().some(it => typeof it == 'number'));\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.set.some.js","skipped":false,"dir":"tests"},{"name":"Set#symmetricDifference","suites":[],"line":4,"code":"QUnit.test('Set#symmetricDifference', assert => {\n  const {\n    symmetricDifference\n  } = Set.prototype;\n  assert.isFunction(symmetricDifference);\n  assert.arity(symmetricDifference, 1);\n  assert.name(symmetricDifference, 'symmetricDifference');\n  assert.nonEnumerable(Set.prototype, 'symmetricDifference');\n  const set = new Set([1]);\n  assert.notSame(set.symmetricDifference([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference([4, 5])), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference([3, 4])), [1, 2, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference(createIterable([3, 4]))), [1, 2, 4]);\n  assert.throws(() => new Set([1, 2, 3]).symmetricDifference(), TypeError);\n  assert.throws(() => symmetricDifference.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => symmetricDifference.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => symmetricDifference.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.symmetric-difference.js","skipped":false,"dir":"tests"},{"name":"Set#union","suites":[],"line":4,"code":"QUnit.test('Set#union', assert => {\n  const {\n    union\n  } = Set.prototype;\n  assert.isFunction(union);\n  assert.arity(union, 1);\n  assert.name(union, 'union');\n  assert.nonEnumerable(Set.prototype, 'union');\n  const set = new Set([1]);\n  assert.notSame(set.union([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).union([4, 5])), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).union([3, 4])), [1, 2, 3, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).union(createIterable([3, 4]))), [1, 2, 3, 4]);\n  assert.throws(() => new Set([1, 2, 3]).union(), TypeError);\n  assert.throws(() => union.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => union.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => union.call(null, [1, 2, 3]), TypeError);\n});","file":"pure/esnext.set.union.js","skipped":false,"dir":"tests"},{"name":"String#at","suites":[],"line":3,"code":"QUnit.test('String#at', assert => {\n  assert.isFunction(at); // String that starts with a BMP symbol\n  // assert.same(at('abc\\uD834\\uDF06def', -Infinity), '');\n  // assert.same(at('abc\\uD834\\uDF06def', -1), '');\n\n  assert.same(at('abc\\uD834\\uDF06def', -0), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', +0), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', 1), 'b');\n  assert.same(at('abc\\uD834\\uDF06def', 3), '\\uD834\\uDF06');\n  assert.same(at('abc\\uD834\\uDF06def', 4), '\\uDF06');\n  assert.same(at('abc\\uD834\\uDF06def', 5), 'd'); // assert.same(at('abc\\uD834\\uDF06def', 42), '');\n  // assert.same(at('abc\\uD834\\uDF06def', Infinity), '');\n\n  assert.same(at('abc\\uD834\\uDF06def', null), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', undefined), 'a');\n  assert.same(at('abc\\uD834\\uDF06def'), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', false), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', NaN), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', ''), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', '_'), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', '1'), 'b');\n  assert.same(at('abc\\uD834\\uDF06def', []), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', {}), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', -0.9), 'a');\n  assert.same(at('abc\\uD834\\uDF06def', 1.9), 'b');\n  assert.same(at('abc\\uD834\\uDF06def', 7.9), 'f'); // assert.same(at('abc\\uD834\\uDF06def', 2 ** 32), '');\n  // String that starts with an astral symbol\n  // assert.same(at('\\uD834\\uDF06def', -Infinity), '');\n  // assert.same(at('\\uD834\\uDF06def', -1), '');\n\n  assert.same(at('\\uD834\\uDF06def', -0), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', 0), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', 1), '\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', 2), 'd');\n  assert.same(at('\\uD834\\uDF06def', 3), 'e');\n  assert.same(at('\\uD834\\uDF06def', 4), 'f'); // assert.same(at('\\uD834\\uDF06def', 42), '');\n  // assert.same(at('\\uD834\\uDF06def', Infinity), '');\n\n  assert.same(at('\\uD834\\uDF06def', null), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', undefined), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def'), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', false), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', NaN), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', ''), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', '_'), '\\uD834\\uDF06');\n  assert.same(at('\\uD834\\uDF06def', '1'), '\\uDF06'); // Lone high surrogates\n  // assert.same(at('\\uD834abc', -Infinity), '');\n  // assert.same(at('\\uD834abc', -1), '');\n\n  assert.same(at('\\uD834abc', -0), '\\uD834');\n  assert.same(at('\\uD834abc', 0), '\\uD834');\n  assert.same(at('\\uD834abc', 1), 'a'); // assert.same(at('\\uD834abc', 42), '');\n  // assert.same(at('\\uD834abc', Infinity), '');\n\n  assert.same(at('\\uD834abc', null), '\\uD834');\n  assert.same(at('\\uD834abc', undefined), '\\uD834');\n  assert.same(at('\\uD834abc'), '\\uD834');\n  assert.same(at('\\uD834abc', false), '\\uD834');\n  assert.same(at('\\uD834abc', NaN), '\\uD834');\n  assert.same(at('\\uD834abc', ''), '\\uD834');\n  assert.same(at('\\uD834abc', '_'), '\\uD834');\n  assert.same(at('\\uD834abc', '1'), 'a'); // Lone low surrogates\n  // assert.same(at('\\uDF06abc', -Infinity), '');\n  // assert.same(at('\\uDF06abc', -1), '');\n\n  assert.same(at('\\uDF06abc', -0), '\\uDF06');\n  assert.same(at('\\uDF06abc', 0), '\\uDF06');\n  assert.same(at('\\uDF06abc', 1), 'a'); // assert.same(at('\\uDF06abc', 42), '');\n  // assert.same(at('\\uDF06abc', Infinity), '');\n\n  assert.same(at('\\uDF06abc', null), '\\uDF06');\n  assert.same(at('\\uDF06abc', undefined), '\\uDF06');\n  assert.same(at('\\uDF06abc'), '\\uDF06');\n  assert.same(at('\\uDF06abc', false), '\\uDF06');\n  assert.same(at('\\uDF06abc', NaN), '\\uDF06');\n  assert.same(at('\\uDF06abc', ''), '\\uDF06');\n  assert.same(at('\\uDF06abc', '_'), '\\uDF06');\n  assert.same(at('\\uDF06abc', '1'), 'a');\n  assert.same(at(42, 0), '4');\n  assert.same(at(42, 1), '2');\n  assert.same(at({\n    toString() {\n      return 'abc';\n    }\n\n  }, 2), 'c');\n\n  if (STRICT) {\n    assert.throws(() => at(null, 0), TypeError);\n    assert.throws(() => at(undefined, 0), TypeError);\n  }\n});","file":"pure/esnext.string.at.js","skipped":false,"dir":"tests"},{"name":"String#codePoints","suites":[],"line":3,"code":"QUnit.test('String#codePoints', assert => {\n  assert.isFunction(codePoints);\n  let iterator = codePoints('qwe');\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'String Iterator');\n  assert.same(String(iterator), '[object String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 113,\n      position: 0\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 119,\n      position: 1\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 101,\n      position: 2\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  iterator = codePoints('𠮷𠮷𠮷');\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 0\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 2\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 4\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => codePoints(Symbol()), 'throws on symbol context');\n});","file":"pure/esnext.string.code-points.js","skipped":false,"dir":"tests"},{"name":"String.cooked","suites":[],"line":3,"code":"QUnit.test('String.cooked', assert => {\n  assert.isFunction(cooked);\n  assert.arity(cooked, 1);\n  assert.name(cooked, 'cooked');\n  assert.same(cooked(['Hi\\\\n', '!'], 'Bob'), 'Hi\\\\nBob!', 'template is an array');\n  assert.same(cooked('test', 0, 1, 2), 't0e1s2t', 'template is a string');\n  assert.same(cooked('test', 0), 't0est', 'lacks substituting');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => cooked([Symbol()]), TypeError, 'throws on symbol #1');\n    assert.throws(() => cooked('test', Symbol()), TypeError, 'throws on symbol #2');\n  }\n\n  assert.throws(() => cooked([undefined]), TypeError);\n  assert.throws(() => cooked(null), TypeError);\n});","file":"pure/esnext.string.cooked.js","skipped":false,"dir":"tests"},{"name":"Symbol.asyncDispose","suites":[],"line":2,"code":"QUnit.test('Symbol.asyncDispose', assert => {\n  assert.true('asyncDispose' in Symbol, 'Symbol.asyncDispose available');\n  assert.true(Object(Symbol.asyncDispose) instanceof Symbol, 'Symbol.asyncDispose is symbol');\n});","file":"pure/esnext.symbol.async-dispose.js","skipped":false,"dir":"tests"},{"name":"Symbol.dispose","suites":[],"line":2,"code":"QUnit.test('Symbol.dispose', assert => {\n  assert.true('dispose' in Symbol, 'Symbol.dispose available');\n  assert.true(Object(Symbol.dispose) instanceof Symbol, 'Symbol.dispose is symbol');\n});","file":"pure/esnext.symbol.dispose.js","skipped":false,"dir":"tests"},{"name":"Symbol.matcher","suites":[],"line":2,"code":"QUnit.test('Symbol.matcher', assert => {\n  assert.true('matcher' in Symbol, 'Symbol.matcher available');\n  assert.true(Object(Symbol.matcher) instanceof Symbol, 'Symbol.matcher is symbol');\n});","file":"pure/esnext.symbol.matcher.js","skipped":false,"dir":"tests"},{"name":"Symbol.metadata","suites":[],"line":2,"code":"QUnit.test('Symbol.metadata', assert => {\n  assert.true('metadata' in Symbol, 'Symbol.metadata available');\n  assert.true(Object(Symbol.metadata) instanceof Symbol, 'Symbol.metadata is symbol');\n});","file":"pure/esnext.symbol.metadata.js","skipped":false,"dir":"tests"},{"name":"Symbol.observable","suites":[],"line":2,"code":"QUnit.test('Symbol.observable', assert => {\n  assert.true('observable' in Symbol, 'Symbol.observable available');\n  assert.true(Object(Symbol.observable) instanceof Symbol, 'Symbol.observable is symbol');\n});","file":"pure/esnext.symbol.observable.js","skipped":false,"dir":"tests"},{"name":"Symbol.patternMatch","suites":[],"line":2,"code":"QUnit.test('Symbol.patternMatch', assert => {\n  assert.true('patternMatch' in Symbol, 'Symbol.patternMatch available');\n  assert.true(Object(Symbol.patternMatch) instanceof Symbol, 'Symbol.patternMatch is symbol');\n});","file":"pure/esnext.symbol.pattern-match.js","skipped":false,"dir":"tests"},{"name":"Symbol.replaceAll","suites":[],"line":2,"code":"QUnit.test('Symbol.replaceAll', assert => {\n  assert.true('replaceAll' in Symbol, 'Symbol.replaceAll is available');\n  assert.true(Object(Symbol.replaceAll) instanceof Symbol, 'Symbol.replaceAll is symbol');\n});","file":"pure/esnext.symbol.replace-all.js","skipped":false,"dir":"tests"},{"name":"WeakMap#deleteAll","suites":[],"line":2,"code":"QUnit.test('WeakMap#deleteAll', assert => {\n  const {\n    deleteAll\n  } = WeakMap.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.nonEnumerable(WeakMap.prototype, 'deleteAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  const d = [];\n  const e = [];\n  let set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.true(set.deleteAll(a, b));\n  assert.false(set.has(a));\n  assert.false(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.false(set.deleteAll(c, d));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.false(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.false(set.deleteAll(d, e));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.true(set.deleteAll());\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => deleteAll.call({}, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(null, a, b, c), TypeError);\n});","file":"pure/esnext.weak-map.delete-all.js","skipped":false,"dir":"tests"},{"name":"WeakMap#emplace","suites":[],"line":2,"code":"QUnit.test('WeakMap#emplace', assert => {\n  const {\n    emplace\n  } = WeakMap.prototype;\n  assert.isFunction(emplace);\n  assert.arity(emplace, 2);\n  assert.name(emplace, 'emplace');\n  assert.nonEnumerable(WeakMap.prototype, 'emplace');\n  const a = {};\n  const b = {};\n  const map = new WeakMap([[a, 2]]);\n  let handler = {\n    update(value, key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 2, 'correct value in callback');\n      assert.same(key, a, 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return value ** 2;\n    },\n\n    insert() {\n      assert.avoid();\n    }\n\n  };\n  assert.same(map.emplace(a, handler), 4, 'returns a correct value');\n  handler = {\n    update() {\n      assert.avoid();\n    },\n\n    insert(key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 2, 'correct number of callback arguments');\n      assert.same(key, b, 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return 3;\n    }\n\n  };\n  assert.same(map.emplace(b, handler), 3, 'returns a correct value');\n  assert.same(map.get(a), 4, 'correct result #1');\n  assert.same(map.get(b), 3, 'correct result #2');\n  assert.same(new WeakMap([[a, 2]]).emplace(b, {\n    insert: () => 3\n  }), 3);\n  assert.same(new WeakMap([[a, 2]]).emplace(a, {\n    update: value => value ** 2\n  }), 4);\n  handler = {\n    update() {\n      /* empty */\n    },\n\n    insert() {\n      /* empty */\n    }\n\n  };\n  assert.throws(() => new WeakMap().emplace(a), TypeError);\n  assert.throws(() => emplace.call({}, a, handler), TypeError);\n  assert.throws(() => emplace.call([], a, handler), TypeError);\n  assert.throws(() => emplace.call(undefined, a, handler), TypeError);\n  assert.throws(() => emplace.call(null, a, handler), TypeError);\n});","file":"pure/esnext.weak-map.emplace.js","skipped":false,"dir":"tests"},{"name":"WeakMap.from","suites":[],"line":3,"code":"QUnit.test('WeakMap.from', assert => {\n  const {\n    from\n  } = WeakMap;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(WeakMap.from() instanceof WeakMap);\n  const array = [];\n  assert.same(WeakMap.from([[array, 2]]).get(array), 2);\n  assert.same(WeakMap.from(createIterable([[array, 2]])).get(array), 2);\n  const pair = [{}, 1];\n  const context = {};\n  WeakMap.from([pair], function (element, index) {\n    assert.same(element, pair);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from([{}, 1]));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"pure/esnext.weak-map.from.js","skipped":false,"dir":"tests"},{"name":"WeakMap.of","suites":[],"line":2,"code":"QUnit.test('WeakMap.of', assert => {\n  const {\n    of\n  } = WeakMap;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  const array = [];\n  assert.true(WeakMap.of() instanceof WeakMap);\n  assert.same(WeakMap.of([array, 2]).get(array), 2);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"pure/esnext.weak-map.of.js","skipped":false,"dir":"tests"},{"name":"WeakMap#upsert","suites":[],"line":2,"code":"QUnit.test('WeakMap#upsert', assert => {\n  const {\n    upsert\n  } = WeakMap.prototype;\n  assert.isFunction(upsert);\n  assert.arity(upsert, 2);\n  assert.nonEnumerable(WeakMap.prototype, 'upsert');\n  const a = {};\n  const b = {};\n  const map = new WeakMap([[a, 2]]);\n  assert.same(map.upsert(a, function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.upsert(b, value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.get(a), 4, 'correct result #1');\n  assert.same(map.get(b), 3, 'correct result #2');\n  assert.same(new WeakMap([[a, 2]]).upsert(b, null, () => 3), 3);\n  assert.same(new WeakMap([[a, 2]]).upsert(a, value => value ** 2), 4);\n  assert.throws(() => new WeakMap().upsert(a), TypeError);\n  assert.throws(() => upsert.call({}, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call([], a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(undefined, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(null, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"pure/esnext.weak-map.upsert.js","skipped":false,"dir":"tests"},{"name":"WeakSet#addAll","suites":[],"line":2,"code":"QUnit.test('WeakSet#addAll', assert => {\n  const {\n    addAll\n  } = WeakSet.prototype;\n  assert.isFunction(addAll);\n  assert.arity(addAll, 0);\n  assert.name(addAll, 'addAll');\n  assert.nonEnumerable(WeakSet.prototype, 'addAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  let set = new WeakSet([a]);\n  assert.same(set.addAll(b), set);\n  set = new WeakSet([a]).addAll(b, c);\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  set = new WeakSet([a]).addAll(a, b);\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  set = new WeakSet([a]).addAll();\n  assert.true(set.has(a));\n  assert.notThrows(() => addAll.call({\n    add() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => addAll.call({}, a, b, c), TypeError);\n  assert.throws(() => addAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => addAll.call(null, a, b, c), TypeError);\n});","file":"pure/esnext.weak-set.add-all.js","skipped":false,"dir":"tests"},{"name":"WeakSet#deleteAll","suites":[],"line":2,"code":"QUnit.test('WeakSet#deleteAll', assert => {\n  const {\n    deleteAll\n  } = WeakSet.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.nonEnumerable(WeakSet.prototype, 'deleteAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  const d = [];\n  const e = [];\n  let set = new WeakSet([a, b, c]);\n  assert.true(set.deleteAll(a, b));\n  assert.false(set.has(a));\n  assert.false(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.false(set.deleteAll(c, d));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.false(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.false(set.deleteAll(d, e));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.true(set.deleteAll());\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => deleteAll.call({}, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(null, a, b, c), TypeError);\n});","file":"pure/esnext.weak-set.delete-all.js","skipped":false,"dir":"tests"},{"name":"WeakSet.from","suites":[],"line":3,"code":"QUnit.test('WeakSet.from', assert => {\n  const {\n    from\n  } = WeakSet;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.true(WeakSet.from() instanceof WeakSet);\n  const array = [];\n  assert.true(WeakSet.from([array]).has(array));\n  assert.true(WeakSet.from(createIterable([array])).has(array));\n  const object = {};\n  const context = {};\n  WeakSet.from([object], function (element, index) {\n    assert.same(element, object);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from({}));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"pure/esnext.weak-set.from.js","skipped":false,"dir":"tests"},{"name":"WeakSet.of","suites":[],"line":2,"code":"QUnit.test('WeakSet.of', assert => {\n  const {\n    of\n  } = WeakSet;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  const array = [];\n  assert.true(WeakSet.of() instanceof WeakSet);\n  assert.true(WeakSet.of(array).has(array));\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"pure/esnext.weak-set.of.js","skipped":false,"dir":"tests"},{"name":"getIteratorMethod helper","suites":[],"line":3,"code":"QUnit.test('getIteratorMethod helper', assert => {\n  assert.isFunction(getIteratorMethod);\n  const iterable = createIterable([]);\n  const iterFn = getIteratorMethod(iterable);\n  assert.isFunction(iterFn);\n  assert.isIterator(iterFn.call(iterable));\n  assert.isFunction(getIteratorMethod([]));\n  assert.isFunction(getIteratorMethod(function () {\n    return arguments;\n  }()));\n  assert.isFunction(getIteratorMethod(Array.prototype));\n  assert.same(getIteratorMethod({}), undefined);\n});","file":"pure/helpers.get-iterator-method.js","skipped":false,"dir":"tests"},{"name":"getIterator helper","suites":[],"line":3,"code":"QUnit.test('getIterator helper', assert => {\n  assert.isFunction(getIterator);\n  assert.isIterator(getIterator([]));\n  assert.isIterator(getIterator(function () {\n    return arguments;\n  }()));\n  assert.isIterator(getIterator(createIterable([])));\n  assert.throws(() => getIterator({}), TypeError);\n});","file":"pure/helpers.get-iterator.js","skipped":false,"dir":"tests"},{"name":"isIterable helper","suites":[],"line":3,"code":"QUnit.test('isIterable helper', assert => {\n  assert.isFunction(isIterable);\n  assert.true(isIterable(createIterable([])));\n  assert.true(isIterable([]));\n  assert.true(isIterable(function () {\n    return arguments;\n  }()));\n  assert.true(isIterable(Array.prototype));\n  assert.true(isIterable({}));\n});","file":"pure/helpers.is-iterable.js","skipped":false,"dir":"tests"},{"name":"atob","suites":[],"line":3,"code":"QUnit.test('atob', assert => {\n  assert.isFunction(atob);\n  assert.arity(atob, 1);\n  assert.same(atob(''), '');\n  assert.same(atob('Zg=='), 'f');\n  assert.same(atob('Zm8='), 'fo');\n  assert.same(atob('Zm9v'), 'foo');\n  assert.same(atob('cXV1eA=='), 'quux');\n  assert.same(atob('ISIjJCU='), '!\"#$%');\n  assert.same(atob('JicoKSor'), \"&'()*+\");\n  assert.same(atob('LC0uLzAxMg=='), ',-./012');\n  assert.same(atob('MzQ1Njc4OTo='), '3456789:');\n  assert.same(atob('Ozw9Pj9AQUJD'), ';<=>?@ABC');\n  assert.same(atob('REVGR0hJSktMTQ=='), 'DEFGHIJKLM');\n  assert.same(atob('Tk9QUVJTVFVWV1g='), 'NOPQRSTUVWX');\n  assert.same(atob('WVpbXF1eX2BhYmM='), 'YZ[\\\\]^_`abc');\n  assert.same(atob('ZGVmZ2hpamtsbW5vcA=='), 'defghijklmnop');\n  assert.same(atob('cXJzdHV2d3h5ent8fX4='), 'qrstuvwxyz{|}~');\n  assert.same(atob(' '), '');\n  assert.same(atob(42), atob('42'));\n  assert.same(atob(null), atob('null'));\n  assert.throws(() => atob(), TypeError, 'no args');\n  assert.throws(() => atob('a'), 'invalid #1');\n  assert.throws(() => atob('a '), 'invalid #2');\n  assert.throws(() => atob('aaaaa'), 'invalid #3');\n  assert.throws(() => atob('[object Object]'), 'invalid #4');\n});","file":"pure/web.atob.js","skipped":false,"dir":"tests"},{"name":"btoa","suites":[],"line":3,"code":"QUnit.test('btoa', assert => {\n  assert.isFunction(btoa);\n  assert.arity(btoa, 1);\n  assert.same(btoa(''), '');\n  assert.same(btoa('f'), 'Zg==');\n  assert.same(btoa('fo'), 'Zm8=');\n  assert.same(btoa('foo'), 'Zm9v');\n  assert.same(btoa('quux'), 'cXV1eA==');\n  assert.same(btoa('!\"#$%'), 'ISIjJCU=');\n  assert.same(btoa(\"&'()*+\"), 'JicoKSor');\n  assert.same(btoa(',-./012'), 'LC0uLzAxMg==');\n  assert.same(btoa('3456789:'), 'MzQ1Njc4OTo=');\n  assert.same(btoa(';<=>?@ABC'), 'Ozw9Pj9AQUJD');\n  assert.same(btoa('DEFGHIJKLM'), 'REVGR0hJSktMTQ==');\n  assert.same(btoa('NOPQRSTUVWX'), 'Tk9QUVJTVFVWV1g=');\n  assert.same(btoa('YZ[\\\\]^_`abc'), 'WVpbXF1eX2BhYmM=');\n  assert.same(btoa('defghijklmnop'), 'ZGVmZ2hpamtsbW5vcA==');\n  assert.same(btoa('qrstuvwxyz{|}~'), 'cXJzdHV2d3h5ent8fX4=');\n  assert.same(btoa('qrstuvwxyz{|}~'), 'cXJzdHV2d3h5ent8fX4=');\n  assert.same(btoa(42), btoa('42'));\n  assert.same(btoa(null), btoa('null'));\n  assert.same(btoa({\n    x: 1\n  }), btoa('[object Object]'));\n  assert.throws(() => btoa(), TypeError, 'no args');\n  assert.throws(() => btoa('✈'), 'non-ASCII');\n});","file":"pure/web.btoa.js","skipped":false,"dir":"tests"},{"name":"Iterable DOM collections","suites":[],"line":4,"code":"QUnit.test('Iterable DOM collections', assert => {\n  let absent = true;\n  const collections = ['CSSRuleList', 'CSSStyleDeclaration', 'CSSValueList', 'ClientRectList', 'DOMRectList', 'DOMStringList', 'DOMTokenList', 'DataTransferItemList', 'FileList', 'HTMLAllCollection', 'HTMLCollection', 'HTMLFormElement', 'HTMLSelectElement', 'MediaList', 'MimeTypeArray', 'NamedNodeMap', 'NodeList', 'PaintRequestList', 'Plugin', 'PluginArray', 'SVGLengthList', 'SVGNumberList', 'SVGPathSegList', 'SVGPointList', 'SVGStringList', 'SVGTransformList', 'SourceBufferList', 'StyleSheetList', 'TextTrackCueList', 'TextTrackList', 'TouchList'];\n\n  for (const name of collections) {\n    const Collection = GLOBAL[name];\n\n    if (Collection) {\n      absent = false;\n      assert.same(Collection.prototype[Symbol.toStringTag], name, `${name}::@@toStringTag is '${name}'`);\n\n      if (Object.prototype.toString.call(Collection.prototype).slice(8, -1) === name) {\n        assert.isFunction(getIteratorMethod(Collection.prototype), `${name}::@@iterator is function`);\n      }\n    }\n  }\n\n  if (GLOBAL.NodeList && GLOBAL.document && document.querySelectorAll && document.querySelectorAll('div') instanceof NodeList) {\n    assert.isFunction(getIteratorMethod(document.querySelectorAll('div')), 'works with document.querySelectorAll');\n  }\n\n  if (absent) {\n    assert.required('DOM collections are absent');\n  }\n});","file":"pure/web.dom-collections.iterator.js","skipped":false,"dir":"tests"},{"name":"DOMException","suites":[],"line":132,"code":"QUnit.test('DOMException', assert => {\n  assert.isFunction(DOMException);\n  assert.arity(DOMException, 0);\n  assert.name(DOMException, 'DOMException');\n  let error = new DOMException({}, 'Foo');\n  assert.true(error instanceof DOMException, 'new DOMException({}, \"Foo\") instanceof DOMException');\n  assert.same(error.message, '[object Object]', 'new DOMException({}, \"Foo\").message');\n  assert.same(error.name, 'Foo', 'new DOMException({}, \"Foo\").name');\n  assert.same(error.code, 0, 'new DOMException({}, \"Foo\").code');\n  assert.same(String(error), 'Foo: [object Object]', 'String(new DOMException({}, \"Foo\"))'); // Safari 10.1 bug\n  // assert.same(error.constructor, DOMException, 'new DOMException({}, \"Foo\").constructor');\n\n  assert.same(error[Symbol.toStringTag], 'DOMException', 'DOMException.prototype[Symbol.toStringTag]');\n  if (HAS_STACK) assert.true('stack' in error, \"'stack' in new DOMException()\");\n  assert.same(new DOMException().message, '', 'new DOMException().message');\n  assert.same(new DOMException(undefined).message, '', 'new DOMException(undefined).message');\n  assert.same(new DOMException(42).name, 'Error', 'new DOMException(42).name');\n  assert.same(new DOMException(42, undefined).name, 'Error', 'new DOMException(42, undefined).name');\n\n  for (const name in errors) {\n    error = new DOMException(42, name);\n    assert.true(error instanceof DOMException, `new DOMException({}, \"${name}\") instanceof DOMException`);\n    assert.same(error.message, '42', `new DOMException({}, \"${name}\").message`);\n    assert.same(error.name, name, `new DOMException({}, \"${name}\").name`);\n    if (errors[name].m) assert.same(error.code, errors[name].c, `new DOMException({}, \"${name}\").code`); // NodeJS and Deno set codes to deprecated errors\n    else if (!NODE) assert.same(error.code, 0, `new DOMException({}, \"${name}\").code`);\n    assert.same(String(error), `${name}: 42`, `String(new DOMException({}, \"${name}\"))`); // Safari 10.1 bug\n\n    if (HAS_STACK) assert.true('stack' in error, `'stack' in new DOMException({}, \"${name}\")`);\n    assert.same(DOMException[errors[name].s], errors[name].c, `DOMException.${errors[name].s}`);\n    assert.same(DOMException.prototype[errors[name].s], errors[name].c, `DOMException.prototype.${errors[name].s}`);\n  }\n\n  assert.throws(() => DOMException(42, 'DataCloneError'), \"DOMException(42, 'DataCloneError')\");\n  assert.throws(() => new DOMException(Symbol(), 'DataCloneError'), \"new DOMException(Symbol(), 'DataCloneError')\");\n  assert.throws(() => new DOMException(42, Symbol()), 'new DOMException(42, Symbol())');\n\n  if (DESCRIPTORS) {// assert.throws(() => DOMException.prototype.message, 'DOMException.prototype.message'); // FF55- , Safari 10.1 bug\n    // assert.throws(() => DOMException.prototype.name, 'DOMException.prototype.name'); // FF55-, Safari 10.1 bug bug\n    // assert.throws(() => DOMException.prototype.code, 'DOMException.prototype.code'); // Safari 10.1 bug\n    // assert.throws(() => DOMException.prototype.toString(), 'DOMException.prototype.toString()'); // FF55- bug\n  }\n});","file":"pure/web.dom-exception.constructor.js","skipped":false,"dir":"tests"},{"name":"setImmediate / clearImmediate","suites":[],"line":4,"code":"QUnit.test('setImmediate / clearImmediate', assert => {\n  let called = false;\n  assert.expect(6);\n  assert.isFunction(setImmediate, 'setImmediate is function');\n  assert.isFunction(clearImmediate, 'clearImmediate is function');\n  timeLimitedPromise(1e3, res => {\n    setImmediate(() => {\n      called = true;\n      res();\n    });\n  }).then(() => {\n    assert.required('setImmediate works');\n  }).catch(() => {\n    assert.avoid('setImmediate works');\n  }).then(assert.async());\n  assert.false(called, 'setImmediate is async');\n  timeLimitedPromise(1e3, res => {\n    setImmediate((a, b) => {\n      res(a + b);\n    }, 'a', 'b');\n  }).then(it => {\n    assert.same(it, 'ab', 'setImmediate works with additional args');\n  }).catch(() => {\n    assert.avoid('setImmediate works with additional args');\n  }).then(assert.async());\n  timeLimitedPromise(50, res => {\n    clearImmediate(setImmediate(res));\n  }).then(() => {\n    assert.avoid('clearImmediate works');\n  }).catch(() => {\n    assert.required('clearImmediate works');\n  }).then(assert.async());\n});","file":"pure/web.immediate.js","skipped":false,"dir":"tests"},{"name":"queueMicrotask","suites":[],"line":2,"code":"QUnit.test('queueMicrotask', assert => {\n  assert.expect(3);\n  assert.isFunction(queueMicrotask);\n  assert.arity(queueMicrotask, 1);\n  const async = assert.async();\n  let done = false;\n  let after = false;\n  queueMicrotask(() => {\n    if (!done) {\n      done = true;\n      assert.true(after, 'works');\n      async();\n    }\n  });\n  setTimeout(() => {\n    if (!done) {\n      done = true;\n      assert.avoid();\n      async();\n    }\n  }, 3e3);\n  after = true;\n});","file":"pure/web.queue-microtask.js","skipped":false,"dir":"tests"},{"name":"identity","suites":["structuredClone"],"line":18,"code":"  QUnit.test('identity', assert => {\n    assert.isFunction(structuredClone, 'structuredClone is a function');\n    assert.name(structuredClone, 'structuredClone');\n    assert.arity(structuredClone, 1);\n    assert.throws(() => structuredClone(), 'throws without arguments');\n  });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"primitives","suites":["structuredClone"],"line":52,"code":"  QUnit.test('primitives', assert => {\n    const primitives = [undefined, null].concat(booleans, numbers, bigints, strings);\n\n    for (const value of primitives) cloneTest(value, (orig, clone) => {\n      assert.same(orig, clone, 'primitives should be same after cloned');\n    });\n  }); // \"Primitive\" Objects (Boolean, Number, BigInt, String)","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"primitive objects","suites":["structuredClone"],"line":60,"code":"  QUnit.test('primitive objects', assert => {\n    const primitives = [].concat(booleans, numbers, bigints, strings);\n\n    for (const value of primitives) cloneObjectTest(assert, Object(value), (orig, clone) => {\n      assert.same(orig.valueOf(), clone.valueOf(), 'primitive wrappers should have same value');\n    });\n  }); // Dates","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Date","suites":["structuredClone"],"line":68,"code":"  QUnit.test('Date', assert => {\n    const dates = [new Date(-1e13), new Date(-1e12), new Date(-1e9), new Date(-1e6), new Date(-1e3), new Date(0), new Date(1e3), new Date(1e6), new Date(1e9), new Date(1e12), new Date(1e13)];\n\n    for (const date of dates) cloneTest(date, (orig, clone) => {\n      assert.notSame(orig, clone);\n      assert.same(typeof clone, 'object');\n      assert.same(getPrototypeOf(orig), getPrototypeOf(clone));\n      assert.same(orig.valueOf(), clone.valueOf());\n    });\n  }); // Regular Expressions","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"RegExp","suites":["structuredClone"],"line":79,"code":"  QUnit.test('RegExp', assert => {\n    const regexes = [new RegExp(), /abc/, /abc/g, /abc/i, /abc/gi, /abc/, /abc/g, /abc/i, /abc/gi];\n    const giuy = fromSource('/abc/giuy');\n    if (giuy) regexes.push(giuy);\n\n    for (const regex of regexes) cloneObjectTest(assert, regex, (orig, clone) => {\n      assert.same(orig.toString(), clone.toString(), `regex ${regex}`);\n    });\n  });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"ArrayBuffer","suites":["structuredClone"],"line":91,"code":"    if (typeof Uint8Array == 'function') QUnit.test('ArrayBuffer', assert => {\n      // Crashes\n      cloneObjectTest(assert, new Uint8Array([0, 1, 254, 255]).buffer, (orig, clone) => {\n        assert.arrayEqual(new Uint8Array(orig), new Uint8Array(clone));\n      });\n    }); // TODO SharedArrayBuffer","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"%TypedArray%","suites":["structuredClone"],"line":100,"code":"      QUnit.test('%TypedArray%', assert => {\n        const arrays = [new Uint8Array([]), new Uint8Array([0, 1, 254, 255]), new Uint16Array([0x0000, 0x0001, 0xFFFE, 0xFFFF]), new Uint32Array([0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF]), new Int8Array([0, 1, 254, 255]), new Int16Array([0x0000, 0x0001, 0xFFFE, 0xFFFF]), new Int32Array([0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF]), new Float32Array([-Infinity, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, Infinity, NaN]), new Float64Array([-Infinity, -Number.MAX_VALUE, -Number.MIN_VALUE, 0, Number.MIN_VALUE, Number.MAX_VALUE, Infinity, NaN])];\n\n        if (typeof Uint8ClampedArray != 'undefined') {\n          arrays.push(new Uint8ClampedArray([0, 1, 254, 255]));\n        }\n\n        for (const array of arrays) cloneObjectTest(assert, array, (orig, clone) => {\n          assert.arrayEqual(orig, clone);\n        });\n      });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"DataView","suites":["structuredClone"],"line":111,"code":"      if (typeof DataView != 'undefined') QUnit.test('DataView', assert => {\n        const array = new Int8Array([1, 2, 3, 4]);\n        const view = new DataView(array.buffer);\n        cloneObjectTest(assert, array, (orig, clone) => {\n          assert.same(orig.byteLength, clone.byteLength);\n          assert.same(orig.byteOffset, clone.byteOffset);\n          assert.arrayEqual(new Int8Array(view.buffer), array);\n        });\n      });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Map","suites":["structuredClone"],"line":124,"code":"  QUnit.test('Map', assert => {\n    cloneObjectTest(assert, new Map([[1, 2], [3, 4]]), (orig, clone) => {\n      assert.deepEqual(from(orig.keys()), from(clone.keys()));\n      assert.deepEqual(from(orig.values()), from(clone.values()));\n    });\n  }); // Set","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Set","suites":["structuredClone"],"line":131,"code":"  QUnit.test('Set', assert => {\n    cloneObjectTest(assert, new Set([1, 2, 3, 4]), (orig, clone) => {\n      assert.deepEqual(from(orig.values()), from(clone.values()));\n    });\n  }); // Error","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Error","suites":["structuredClone"],"line":137,"code":"  QUnit.test('Error', assert => {\n    const errors = [['Error', new Error()], ['Error', new Error('abc', 'def', {\n      cause: 42\n    })], ['EvalError', new EvalError()], ['EvalError', new EvalError('ghi', 'jkl', {\n      cause: 42\n    })], ['RangeError', new RangeError()], ['RangeError', new RangeError('ghi', 'jkl', {\n      cause: 42\n    })], ['ReferenceError', new ReferenceError()], ['ReferenceError', new ReferenceError('ghi', 'jkl', {\n      cause: 42\n    })], ['SyntaxError', new SyntaxError()], ['SyntaxError', new SyntaxError('ghi', 'jkl', {\n      cause: 42\n    })], ['TypeError', new TypeError()], ['TypeError', new TypeError('ghi', 'jkl', {\n      cause: 42\n    })], ['URIError', new URIError()], ['URIError', new URIError('ghi', 'jkl', {\n      cause: 42\n    })], ['AggregateError', new AggregateError([1, 2])], ['AggregateError', new AggregateError([1, 2], 42, {\n      cause: 42\n    })]];\n    const compile = fromSource('WebAssembly.CompileError()');\n    const link = fromSource('WebAssembly.LinkError()');\n    const runtime = fromSource('WebAssembly.RuntimeError()');\n    if (compile && compile.name === 'CompileError') errors.push(['CompileError', compile]);\n    if (link && link.name === 'LinkError') errors.push(['LinkError', link]);\n    if (runtime && runtime.name === 'RuntimeError') errors.push(['RuntimeError', runtime]);\n\n    for (const [name, error] of errors) cloneObjectTest(assert, error, (orig, clone) => {\n      assert.same(orig.constructor, clone.constructor, `${name}#constructor`);\n      assert.same(orig.name, clone.name, `${name}#name`);\n      assert.same(orig.message, clone.message, `${name}#message`);\n      assert.same(orig.stack, clone.stack, `${name}#stack`);\n      assert.same(orig.cause, clone.cause, `${name}#cause`);\n      assert.deepEqual(orig.errors, clone.errors, `${name}#errors`);\n    });\n  }); // Arrays","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Array","suites":["structuredClone"],"line":172,"code":"  QUnit.test('Array', assert => {\n    const arrays = [[], [1, 2, 3], assign(['foo', 'bar'], {\n      10: true,\n      11: false,\n      20: 123,\n      21: 456,\n      30: null\n    }), assign(['foo', 'bar'], {\n      a: true,\n      b: false,\n      foo: 123,\n      bar: 456,\n      '': null\n    })];\n\n    for (const array of arrays) cloneObjectTest(assert, array, (orig, clone) => {\n      assert.deepEqual(orig, clone, `array content should be same: ${array}`);\n      assert.deepEqual(keys(orig), keys(clone), `array key should be same: ${array}`);\n\n      for (const key of keys(orig)) {\n        assert.same(orig[key], clone[key], `Property ${key}`);\n      }\n    });\n  }); // Objects","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Object","suites":["structuredClone"],"line":197,"code":"  QUnit.test('Object', assert => {\n    cloneObjectTest(assert, {\n      foo: true,\n      bar: false\n    }, (orig, clone) => {\n      assert.deepEqual(keys(orig), keys(clone));\n\n      for (const key of keys(orig)) {\n        assert.same(orig[key], clone[key], `Property ${key}`);\n      }\n    });\n  }); // [Serializable] Platform objects","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMMatrix","suites":["structuredClone"],"line":212,"code":"    QUnit.test('Geometry types, DOMMatrix', assert => {\n      cloneObjectTest(assert, new DOMMatrix(), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMMatrixReadOnly","suites":["structuredClone"],"line":222,"code":"    QUnit.test('Geometry types, DOMMatrixReadOnly', assert => {\n      cloneObjectTest(assert, new DOMMatrixReadOnly(), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMPoint","suites":["structuredClone"],"line":232,"code":"    QUnit.test('Geometry types, DOMPoint', assert => {\n      cloneObjectTest(assert, new DOMPoint(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMPointReadOnly","suites":["structuredClone"],"line":242,"code":"    QUnit.test('Geometry types, DOMPointReadOnly', assert => {\n      cloneObjectTest(assert, new DOMPointReadOnly(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMQuad","suites":["structuredClone"],"line":252,"code":"    QUnit.test('Geometry types, DOMQuad', assert => {\n      cloneObjectTest(assert, new DOMQuad(new DOMPoint(1, 2, 3, 4), new DOMPoint(2, 2, 3, 4), new DOMPoint(1, 3, 3, 4), new DOMPoint(1, 2, 4, 4)), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.deepEqual(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMRect","suites":["structuredClone"],"line":262,"code":"    QUnit.test('Geometry types, DOMRect', assert => {\n      cloneObjectTest(assert, new DOMRect(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMRectReadOnly","suites":["structuredClone"],"line":272,"code":"    QUnit.test('Geometry types, DOMRectReadOnly', assert => {\n      cloneObjectTest(assert, new DOMRectReadOnly(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"ImageData","suites":["structuredClone"],"line":283,"code":"    QUnit.test('ImageData', assert => {\n      const imageData = new ImageData(8, 8);\n\n      for (let i = 0; i < 256; ++i) {\n        imageData.data[i] = i;\n      }\n\n      cloneObjectTest(assert, imageData, (orig, clone) => {\n        assert.same(orig.width, clone.width);\n        assert.same(orig.height, clone.height);\n        assert.same(orig.colorSpace, clone.colorSpace);\n        assert.arrayEqual(orig.data, clone.data);\n      });\n    });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Blob","suites":["structuredClone"],"line":299,"code":"  if (fromSource('new Blob([\"test\"])')) QUnit.test('Blob', assert => {\n    cloneObjectTest(assert, new Blob(['This is a test.'], {\n      type: 'a/b'\n    }), (orig, clone) => {\n      assert.same(orig.size, clone.size);\n      assert.same(orig.type, clone.type); // TODO: async\n      // assert.same(await orig.text(), await clone.text());\n    });\n  });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"DOMException","suites":["structuredClone"],"line":308,"code":"  QUnit.test('DOMException', assert => {\n    const errors = [new DOMException(), new DOMException('foo', 'DataCloneError')];\n\n    for (const error of errors) cloneObjectTest(assert, error, (orig, clone) => {\n      assert.same(orig.name, clone.name);\n      assert.same(orig.message, clone.message);\n      assert.same(orig.code, clone.code);\n      assert.same(orig.stack, clone.stack);\n    });\n  });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"File","suites":["structuredClone"],"line":318,"code":"  if (fromSource('new File([\"test\"], \"foo.txt\")')) QUnit.test('File', assert => {\n    cloneObjectTest(assert, new File(['This is a test.'], 'foo.txt', {\n      type: 'c/d'\n    }), (orig, clone) => {\n      assert.same(orig.size, clone.size);\n      assert.same(orig.type, clone.type);\n      assert.same(orig.name, clone.name);\n      assert.same(orig.lastModified, clone.lastModified); // TODO: async\n      // assert.same(await orig.text(), await clone.text());\n    });\n  }); // FileList","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"FileList","suites":["structuredClone"],"line":330,"code":"  if (fromSource('new File([\"test\"], \"foo.txt\")') && fromSource('new DataTransfer()')) QUnit.test('FileList', assert => {\n    const transfer = new DataTransfer();\n    transfer.items.add(new File(['test'], 'foo.txt'));\n    cloneObjectTest(assert, transfer.files, (orig, clone) => {\n      assert.same(1, clone.length);\n      assert.same(orig[0].size, clone[0].size);\n      assert.same(orig[0].type, clone[0].type);\n      assert.same(orig[0].name, clone[0].name);\n      assert.same(orig[0].lastModified, clone[0].lastModified);\n    });\n  }); // Non-serializable types","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Non-serializable types","suites":["structuredClone"],"line":342,"code":"  QUnit.test('Non-serializable types', assert => {\n    const nons = [function () {\n      return 1;\n    }, Symbol('desc'), GLOBAL];\n    const event = fromSource('new Event(\"\")');\n    const port = fromSource('new MessageChannel().port1'); // NodeJS events are simple objects\n\n    if (event && !NODE) nons.push(event);\n    if (port) nons.push(port);\n\n    for (const it of nons) {\n      // native NodeJS `structuredClone` throws a `TypeError` on transferable non-serializable instead of `DOMException`\n      // https://github.com/nodejs/node/issues/40841\n      assert.throws(() => structuredClone(it));\n    }\n  });","file":"pure/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"setTimeout / clearTimeout","suites":[],"line":4,"code":"QUnit.test('setTimeout / clearTimeout', assert => {\n  assert.expect(2);\n  timeLimitedPromise(1e3, resolve => {\n    setTimeout((a, b) => {\n      resolve(a + b);\n    }, 10, 'a', 'b');\n  }).then(it => {\n    assert.same(it, 'ab', 'setTimeout works with additional args');\n  }).catch(() => {\n    assert.avoid('setTimeout works with additional args');\n  }).then(assert.async());\n  timeLimitedPromise(50, resolve => {\n    clearTimeout(setTimeout(resolve, 10));\n  }).then(() => {\n    assert.avoid('clearImmediate works with wrapped setTimeout');\n  }).catch(() => {\n    assert.required('clearImmediate works with wrapped setTimeout');\n  }).then(assert.async());\n});","file":"pure/web.timers.js","skipped":false,"dir":"tests"},{"name":"setInterval / clearInterval","suites":[],"line":23,"code":"QUnit.test('setInterval / clearInterval', assert => {\n  assert.expect(1);\n  timeLimitedPromise(1e4, (resolve, reject) => {\n    let i = 0;\n    const interval = setInterval((a, b) => {\n      if (a + b !== 'ab' || i > 2) reject({\n        a,\n        b,\n        i\n      });\n\n      if (i++ === 2) {\n        clearInterval(interval);\n        setTimeout(resolve, 30);\n      }\n    }, 5, 'a', 'b');\n  }).then(() => {\n    assert.required('setInterval & clearInterval works with additional args');\n  }).catch(error => {\n    if (!error) error = {};\n    assert.avoid(`setInterval & clearInterval works with additional args: ${error.a}, ${error.b}, times: ${error.i}`);\n  }).then(assert.async());\n});","file":"pure/web.timers.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams","suites":[],"line":8,"code":"QUnit.test('URLSearchParams', assert => {\n  assert.isFunction(URLSearchParams);\n  assert.arity(URLSearchParams, 0);\n  assert.same(String(new URLSearchParams()), '');\n  assert.same(String(new URLSearchParams('')), '');\n  assert.same(String(new URLSearchParams('a=b')), 'a=b');\n  assert.same(String(new URLSearchParams(new URLSearchParams('a=b'))), 'a=b');\n  assert.same(String(new URLSearchParams([])), '');\n  assert.same(String(new URLSearchParams([[1, 2], ['a', 'b']])), '1=2&a=b');\n  assert.same(String(new URLSearchParams(createIterable([createIterable(['a', 'b']), createIterable(['c', 'd'])]))), 'a=b&c=d');\n  assert.same(String(new URLSearchParams({})), '');\n  assert.same(String(new URLSearchParams({\n    1: 2,\n    a: 'b'\n  })), '1=2&a=b');\n  assert.same(String(new URLSearchParams('?a=b')), 'a=b', 'leading ? should be ignored');\n  assert.same(String(new URLSearchParams('??a=b')), '%3Fa=b');\n  assert.same(String(new URLSearchParams('?')), '');\n  assert.same(String(new URLSearchParams('??')), '%3F=');\n  assert.same(String(new URLSearchParams('a=b c')), 'a=b+c');\n  assert.same(String(new URLSearchParams('a=b&b=c&a=d')), 'a=b&b=c&a=d');\n  assert.same(String(new URLSearchParams('a==')), 'a=%3D');\n  assert.same(String(new URLSearchParams('a=b=')), 'a=b%3D');\n  assert.same(String(new URLSearchParams('a=b=c')), 'a=b%3Dc');\n  assert.same(String(new URLSearchParams('a==b')), 'a=%3Db');\n  let params = new URLSearchParams('a=b');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.false(params.has('b'), 'search params object has not got name \"b\"');\n  params = new URLSearchParams('a=b&c');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('c'), 'search params object has name \"c\"');\n  params = new URLSearchParams('&a&&& &&&&&a+b=& c&m%c3%b8%c3%b8');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('a b'), 'search params object has name \"a b\"');\n  assert.true(params.has(' '), 'search params object has name \" \"');\n  assert.false(params.has('c'), 'search params object did not have the name \"c\"');\n  assert.true(params.has(' c'), 'search params object has name \" c\"');\n  assert.true(params.has('møø'), 'search params object has name \"møø\"');\n  params = new URLSearchParams('a=b+c');\n  assert.same(params.get('a'), 'b c', 'parse +');\n  params = new URLSearchParams('a+b=c');\n  assert.same(params.get('a b'), 'c', 'parse +');\n  params = new URLSearchParams('a=b c');\n  assert.same(params.get('a'), 'b c', 'parse \" \"');\n  params = new URLSearchParams('a b=c');\n  assert.same(params.get('a b'), 'c', 'parse \" \"');\n  params = new URLSearchParams('a=b%20c');\n  assert.same(params.get('a'), 'b c', 'parse %20');\n  params = new URLSearchParams('a%20b=c');\n  assert.same(params.get('a b'), 'c', 'parse %20');\n  params = new URLSearchParams('a=b\\0c');\n  assert.same(params.get('a'), 'b\\0c', 'parse \\\\0');\n  params = new URLSearchParams('a\\0b=c');\n  assert.same(params.get('a\\0b'), 'c', 'parse \\\\0');\n  params = new URLSearchParams('a=b%00c');\n  assert.same(params.get('a'), 'b\\0c', 'parse %00');\n  params = new URLSearchParams('a%00b=c');\n  assert.same(params.get('a\\0b'), 'c', 'parse %00');\n  params = new URLSearchParams('a=b\\u2384');\n  assert.same(params.get('a'), 'b\\u2384', 'parse \\u2384');\n  params = new URLSearchParams('a\\u2384b=c');\n  assert.same(params.get('a\\u2384b'), 'c', 'parse \\u2384');\n  params = new URLSearchParams('a=b%e2%8e%84');\n  assert.same(params.get('a'), 'b\\u2384', 'parse %e2%8e%84');\n  params = new URLSearchParams('a%e2%8e%84b=c');\n  assert.same(params.get('a\\u2384b'), 'c', 'parse %e2%8e%84');\n  params = new URLSearchParams('a=b\\uD83D\\uDCA9c');\n  assert.same(params.get('a'), 'b\\uD83D\\uDCA9c', 'parse \\uD83D\\uDCA9');\n  params = new URLSearchParams('a\\uD83D\\uDCA9b=c');\n  assert.same(params.get('a\\uD83D\\uDCA9b'), 'c', 'parse \\uD83D\\uDCA9');\n  params = new URLSearchParams('a=b%f0%9f%92%a9c');\n  assert.same(params.get('a'), 'b\\uD83D\\uDCA9c', 'parse %f0%9f%92%a9');\n  params = new URLSearchParams('a%f0%9f%92%a9b=c');\n  assert.same(params.get('a\\uD83D\\uDCA9b'), 'c', 'parse %f0%9f%92%a9');\n  params = new URLSearchParams();\n  params.set('query', '+15555555555');\n  assert.same(params.toString(), 'query=%2B15555555555');\n  assert.same(params.get('query'), '+15555555555', 'parse encoded +');\n  params = new URLSearchParams(params.toString());\n  assert.same(params.get('query'), '+15555555555', 'parse encoded +');\n  const testData = [{\n    input: '?a=%',\n    output: [['a', '%']],\n    name: 'handling %'\n  }, {\n    input: {\n      '+': '%C2'\n    },\n    output: [['+', '%C2']],\n    name: 'object with +'\n  }, {\n    input: {\n      c: 'x',\n      a: '?'\n    },\n    output: [['c', 'x'], ['a', '?']],\n    name: 'object with two keys'\n  }, {\n    input: [['c', 'x'], ['a', '?']],\n    output: [['c', 'x'], ['a', '?']],\n    name: 'array with two keys'\n  } // eslint-disable-next-line max-len -- ignore\n  // !!! { input: { 'a\\0b': '42', 'c\\uD83D': '23', dሴ: 'foo' }, output: [['a\\0b', '42'], ['c\\uFFFD', '23'], ['d\\u1234', 'foo']], name: 'object with NULL, non-ASCII, and surrogate keys' },\n  ];\n\n  for (const {\n    input,\n    output,\n    name\n  } of testData) {\n    params = new URLSearchParams(input);\n    let i = 0;\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey, `construct with ${name}`);\n      assert.same(value, reqValue, `construct with ${name}`);\n    });\n  }\n\n  assert.throws(() => {\n    URLSearchParams('');\n  }, 'throws w/o `new`');\n  assert.throws(() => {\n    new URLSearchParams([[1, 2, 3]]);\n  }, 'sequence elements must be pairs #1');\n  assert.throws(() => {\n    new URLSearchParams([createIterable([createIterable([1, 2, 3])])]);\n  }, 'sequence elements must be pairs #2');\n  assert.throws(() => {\n    new URLSearchParams([[1]]);\n  }, 'sequence elements must be pairs #3');\n  assert.throws(() => {\n    new URLSearchParams([createIterable([createIterable([1])])]);\n  }, 'sequence elements must be pairs #4');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#append","suites":[],"line":143,"code":"QUnit.test('URLSearchParams#append', assert => {\n  const {\n    append\n  } = URLSearchParams.prototype;\n  assert.isFunction(append);\n  assert.arity(append, 2);\n  assert.enumerable(URLSearchParams.prototype, 'append');\n  assert.same(new URLSearchParams().append('a', 'b'), undefined, 'void');\n  let params = new URLSearchParams();\n  params.append('a', 'b');\n  assert.same(String(params), 'a=b');\n  params.append('a', 'b');\n  assert.same(String(params), 'a=b&a=b');\n  params.append('a', 'c');\n  assert.same(String(params), 'a=b&a=b&a=c');\n  params = new URLSearchParams();\n  params.append('', '');\n  assert.same(String(params), '=');\n  params.append('', '');\n  assert.same(String(params), '=&=');\n  params = new URLSearchParams();\n  params.append(undefined, undefined);\n  assert.same(String(params), 'undefined=undefined');\n  params.append(undefined, undefined);\n  assert.same(String(params), 'undefined=undefined&undefined=undefined');\n  params = new URLSearchParams();\n  params.append(null, null);\n  assert.same(String(params), 'null=null');\n  params.append(null, null);\n  assert.same(String(params), 'null=null&null=null');\n  params = new URLSearchParams();\n  params.append('first', 1);\n  params.append('second', 2);\n  params.append('third', '');\n  params.append('first', 10);\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  assert.same(params.get('second'), '2', 'search params object has name \"second\" with value \"2\"');\n  assert.same(params.get('third'), '', 'search params object has name \"third\" with value \"\"');\n  params.append('first', 10);\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  assert.throws(() => {\n    return new URLSearchParams('').append();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#delete","suites":[],"line":188,"code":"QUnit.test('URLSearchParams#delete', assert => {\n  const $delete = URLSearchParams.prototype.delete;\n  assert.isFunction($delete);\n  assert.arity($delete, 1);\n  assert.enumerable(URLSearchParams.prototype, 'delete');\n  let params = new URLSearchParams('a=b&c=d');\n  params.delete('a');\n  assert.same(String(params), 'c=d');\n  params = new URLSearchParams('a=a&b=b&a=a&c=c');\n  params.delete('a');\n  assert.same(String(params), 'b=b&c=c');\n  params = new URLSearchParams('a=a&=&b=b&c=c');\n  params.delete('');\n  assert.same(String(params), 'a=a&b=b&c=c');\n  params = new URLSearchParams('a=a&null=null&b=b');\n  params.delete(null);\n  assert.same(String(params), 'a=a&b=b');\n  params = new URLSearchParams('a=a&undefined=undefined&b=b');\n  params.delete(undefined);\n  assert.same(String(params), 'a=a&b=b');\n  params = new URLSearchParams();\n  params.append('first', 1);\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no \"first\" name');\n  params.append('first', 1);\n  params.append('first', 10);\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no \"first\" name');\n\n  if (DESCRIPTORS) {\n    let url = new URL('http://example.com/?param1&param2');\n    url.searchParams.delete('param1');\n    url.searchParams.delete('param2');\n    assert.same(String(url), 'http://example.com/', 'url.href does not have ?');\n    assert.same(url.search, '', 'url.search does not have ?');\n    url = new URL('http://example.com/?');\n    url.searchParams.delete('param1'); // assert.same(String(url), 'http://example.com/', 'url.href does not have ?'); // Safari bug\n\n    assert.same(url.search, '', 'url.search does not have ?');\n  }\n\n  assert.throws(() => {\n    return new URLSearchParams('').delete();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#get","suites":[],"line":235,"code":"QUnit.test('URLSearchParams#get', assert => {\n  const {\n    get\n  } = URLSearchParams.prototype;\n  assert.isFunction(get);\n  assert.arity(get, 1);\n  assert.enumerable(URLSearchParams.prototype, 'get');\n  let params = new URLSearchParams('a=b&c=d');\n  assert.same(params.get('a'), 'b');\n  assert.same(params.get('c'), 'd');\n  assert.same(params.get('e'), null);\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.same(params.get('a'), 'b');\n  params = new URLSearchParams('=b&c=d');\n  assert.same(params.get(''), 'b');\n  params = new URLSearchParams('a=&c=d&a=e');\n  assert.same(params.get('a'), '');\n  params = new URLSearchParams('first=second&third&&');\n  assert.true(params.has('first'), 'Search params object has name \"first\"');\n  assert.same(params.get('first'), 'second', 'Search params object has name \"first\" with value \"second\"');\n  assert.same(params.get('third'), '', 'Search params object has name \"third\" with the empty value.');\n  assert.same(params.get('fourth'), null, 'Search params object has no \"fourth\" name and value.');\n  assert.same(new URLSearchParams('a=b c').get('a'), 'b c');\n  assert.same(new URLSearchParams('a b=c').get('a b'), 'c');\n  assert.same(new URLSearchParams('a=b%20c').get('a'), 'b c', 'parse %20');\n  assert.same(new URLSearchParams('a%20b=c').get('a b'), 'c', 'parse %20');\n  assert.same(new URLSearchParams('a=b\\0c').get('a'), 'b\\0c', 'parse \\\\0');\n  assert.same(new URLSearchParams('a\\0b=c').get('a\\0b'), 'c', 'parse \\\\0');\n  assert.same(new URLSearchParams('a=b%2Bc').get('a'), 'b+c', 'parse %2B');\n  assert.same(new URLSearchParams('a%2Bb=c').get('a+b'), 'c', 'parse %2B');\n  assert.same(new URLSearchParams('a=b%00c').get('a'), 'b\\0c', 'parse %00');\n  assert.same(new URLSearchParams('a%00b=c').get('a\\0b'), 'c', 'parse %00');\n  assert.same(new URLSearchParams('a==').get('a'), '=', 'parse =');\n  assert.same(new URLSearchParams('a=b=').get('a'), 'b=', 'parse =');\n  assert.same(new URLSearchParams('a=b=c').get('a'), 'b=c', 'parse =');\n  assert.same(new URLSearchParams('a==b').get('a'), '=b', 'parse =');\n  assert.same(new URLSearchParams('a=b\\u2384').get('a'), 'b\\u2384', 'parse \\\\u2384');\n  assert.same(new URLSearchParams('a\\u2384b=c').get('a\\u2384b'), 'c', 'parse \\\\u2384');\n  assert.same(new URLSearchParams('a=b%e2%8e%84').get('a'), 'b\\u2384', 'parse %e2%8e%84');\n  assert.same(new URLSearchParams('a%e2%8e%84b=c').get('a\\u2384b'), 'c', 'parse %e2%8e%84');\n  assert.same(new URLSearchParams('a=b\\uD83D\\uDCA9c').get('a'), 'b\\uD83D\\uDCA9c', 'parse \\\\uD83D\\\\uDCA9');\n  assert.same(new URLSearchParams('a\\uD83D\\uDCA9b=c').get('a\\uD83D\\uDCA9b'), 'c', 'parse \\\\uD83D\\\\uDCA9');\n  assert.same(new URLSearchParams('a=b%f0%9f%92%a9c').get('a'), 'b\\uD83D\\uDCA9c', 'parse %f0%9f%92%a9');\n  assert.same(new URLSearchParams('a%f0%9f%92%a9b=c').get('a\\uD83D\\uDCA9b'), 'c', 'parse %f0%9f%92%a9');\n  assert.same(new URLSearchParams('=').get(''), '', 'parse =');\n  assert.throws(() => {\n    return new URLSearchParams('').get();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#getAll","suites":[],"line":284,"code":"QUnit.test('URLSearchParams#getAll', assert => {\n  const {\n    getAll\n  } = URLSearchParams.prototype;\n  assert.isFunction(getAll);\n  assert.arity(getAll, 1);\n  assert.enumerable(URLSearchParams.prototype, 'getAll');\n  let params = new URLSearchParams('a=b&c=d');\n  assert.arrayEqual(params.getAll('a'), ['b']);\n  assert.arrayEqual(params.getAll('c'), ['d']);\n  assert.arrayEqual(params.getAll('e'), []);\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.arrayEqual(params.getAll('a'), ['b', 'e']);\n  params = new URLSearchParams('=b&c=d');\n  assert.arrayEqual(params.getAll(''), ['b']);\n  params = new URLSearchParams('a=&c=d&a=e');\n  assert.arrayEqual(params.getAll('a'), ['', 'e']);\n  params = new URLSearchParams('a=1&a=2&a=3&a');\n  assert.arrayEqual(params.getAll('a'), ['1', '2', '3', ''], 'search params object has expected name \"a\" values');\n  params.set('a', 'one');\n  assert.arrayEqual(params.getAll('a'), ['one'], 'search params object has expected name \"a\" values');\n  assert.throws(() => {\n    return new URLSearchParams('').getAll();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#has","suites":[],"line":309,"code":"QUnit.test('URLSearchParams#has', assert => {\n  const {\n    has\n  } = URLSearchParams.prototype;\n  assert.isFunction(has);\n  assert.arity(has, 1);\n  assert.enumerable(URLSearchParams.prototype, 'has');\n  let params = new URLSearchParams('a=b&c=d');\n  assert.true(params.has('a'));\n  assert.true(params.has('c'));\n  assert.false(params.has('e'));\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.true(params.has('a'));\n  params = new URLSearchParams('=b&c=d');\n  assert.true(params.has(''));\n  params = new URLSearchParams('null=a');\n  assert.true(params.has(null));\n  params = new URLSearchParams('a=b&c=d&&');\n  params.append('first', 1);\n  params.append('first', 2);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('c'), 'search params object has name \"c\"');\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.false(params.has('d'), 'search params object has no name \"d\"');\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no name \"first\"');\n  assert.throws(() => {\n    return new URLSearchParams('').has();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#set","suites":[],"line":339,"code":"QUnit.test('URLSearchParams#set', assert => {\n  const {\n    set\n  } = URLSearchParams.prototype;\n  assert.isFunction(set);\n  assert.arity(set, 2);\n  assert.enumerable(URLSearchParams.prototype, 'set');\n  let params = new URLSearchParams('a=b&c=d');\n  params.set('a', 'B');\n  assert.same(String(params), 'a=B&c=d');\n  params = new URLSearchParams('a=b&c=d&a=e');\n  params.set('a', 'B');\n  assert.same(String(params), 'a=B&c=d');\n  params.set('e', 'f');\n  assert.same(String(params), 'a=B&c=d&e=f');\n  params = new URLSearchParams('a=1&a=2&a=3');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '1', 'search params object has name \"a\" with value \"1\"');\n  params.set('first', 4);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '1', 'search params object has name \"a\" with value \"1\"');\n  assert.same(String(params), 'a=1&a=2&a=3&first=4');\n  params.set('a', 4);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '4', 'search params object has name \"a\" with value \"4\"');\n  assert.same(String(params), 'a=4&first=4');\n  assert.throws(() => {\n    return new URLSearchParams('').set();\n  }, 'throws w/o arguments');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#sort","suites":[],"line":369,"code":"QUnit.test('URLSearchParams#sort', assert => {\n  const {\n    sort\n  } = URLSearchParams.prototype;\n  assert.isFunction(sort);\n  assert.arity(sort, 0);\n  assert.enumerable(URLSearchParams.prototype, 'sort');\n  let params = new URLSearchParams('a=1&b=4&a=3&b=2');\n  params.sort();\n  assert.same(String(params), 'a=1&a=3&b=4&b=2');\n  params.delete('a');\n  params.append('a', '0');\n  params.append('b', '0');\n  params.sort();\n  assert.same(String(params), 'a=0&b=4&b=2&b=0');\n  const testData = [{\n    input: 'z=b&a=b&z=a&a=a',\n    output: [['a', 'b'], ['a', 'a'], ['z', 'b'], ['z', 'a']]\n  }, {\n    input: '\\uFFFD=x&\\uFFFC&\\uFFFD=a',\n    output: [['\\uFFFC', ''], ['\\uFFFD', 'x'], ['\\uFFFD', 'a']]\n  }, {\n    input: 'ﬃ&🌈',\n    // 🌈 > code point, but < code unit because two code units\n    output: [['🌈', ''], ['ﬃ', '']]\n  }, {\n    input: 'é&e\\uFFFD&e\\u0301',\n    output: [['e\\u0301', ''], ['e\\uFFFD', ''], ['é', '']]\n  }, {\n    input: 'z=z&a=a&z=y&a=b&z=x&a=c&z=w&a=d&z=v&a=e&z=u&a=f&z=t&a=g',\n    output: [['a', 'a'], ['a', 'b'], ['a', 'c'], ['a', 'd'], ['a', 'e'], ['a', 'f'], ['a', 'g'], ['z', 'z'], ['z', 'y'], ['z', 'x'], ['z', 'w'], ['z', 'v'], ['z', 'u'], ['z', 't']]\n  }, {\n    input: 'bbb&bb&aaa&aa=x&aa=y',\n    output: [['aa', 'x'], ['aa', 'y'], ['aaa', ''], ['bb', ''], ['bbb', '']]\n  }, {\n    input: 'z=z&=f&=t&=x',\n    output: [['', 'f'], ['', 't'], ['', 'x'], ['z', 'z']]\n  }, {\n    input: 'a🌈&a💩',\n    output: [['a🌈', ''], ['a💩', '']]\n  }];\n\n  for (const {\n    input,\n    output\n  } of testData) {\n    let i = 0;\n    params = new URLSearchParams(input);\n    params.sort();\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey);\n      assert.same(value, reqValue);\n    });\n    i = 0;\n    const url = new URL(`?${input}`, 'https://example/');\n    params = url.searchParams;\n    params.sort();\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey);\n      assert.same(value, reqValue);\n    });\n  }\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://example.com/?');\n    url.searchParams.sort();\n    assert.same(url.href, 'http://example.com/', 'Sorting non-existent params removes ? from URL');\n    assert.same(url.search, '', 'Sorting non-existent params removes ? from URL');\n  }\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#toString","suites":[],"line":441,"code":"QUnit.test('URLSearchParams#toString', assert => {\n  const {\n    toString\n  } = URLSearchParams.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  let params = new URLSearchParams();\n  params.append('a', 'b c');\n  assert.same(String(params), 'a=b+c');\n  params.delete('a');\n  params.append('a b', 'c');\n  assert.same(String(params), 'a+b=c');\n  params = new URLSearchParams();\n  params.append('a', '');\n  assert.same(String(params), 'a=');\n  params.append('a', '');\n  assert.same(String(params), 'a=&a=');\n  params.append('', 'b');\n  assert.same(String(params), 'a=&a=&=b');\n  params.append('', '');\n  assert.same(String(params), 'a=&a=&=b&=');\n  params.append('', '');\n  assert.same(String(params), 'a=&a=&=b&=&=');\n  params = new URLSearchParams();\n  params.append('', 'b');\n  assert.same(String(params), '=b');\n  params.append('', 'b');\n  assert.same(String(params), '=b&=b');\n  params = new URLSearchParams();\n  params.append('', '');\n  assert.same(String(params), '=');\n  params.append('', '');\n  assert.same(String(params), '=&=');\n  params = new URLSearchParams();\n  params.append('a', 'b+c');\n  assert.same(String(params), 'a=b%2Bc');\n  params.delete('a');\n  params.append('a+b', 'c');\n  assert.same(String(params), 'a%2Bb=c');\n  params = new URLSearchParams();\n  params.append('=', 'a');\n  assert.same(String(params), '%3D=a');\n  params.append('b', '=');\n  assert.same(String(params), '%3D=a&b=%3D');\n  params = new URLSearchParams();\n  params.append('&', 'a');\n  assert.same(String(params), '%26=a');\n  params.append('b', '&');\n  assert.same(String(params), '%26=a&b=%26');\n  params = new URLSearchParams();\n  params.append('a', '\\r');\n  assert.same(String(params), 'a=%0D');\n  params = new URLSearchParams();\n  params.append('a', '\\n');\n  assert.same(String(params), 'a=%0A');\n  params = new URLSearchParams();\n  params.append('a', '\\r\\n');\n  assert.same(String(params), 'a=%0D%0A');\n  params = new URLSearchParams();\n  params.append('a', 'b%c');\n  assert.same(String(params), 'a=b%25c');\n  params.delete('a');\n  params.append('a%b', 'c');\n  assert.same(String(params), 'a%25b=c');\n  params = new URLSearchParams();\n  params.append('a', 'b\\0c');\n  assert.same(String(params), 'a=b%00c');\n  params.delete('a');\n  params.append('a\\0b', 'c');\n  assert.same(String(params), 'a%00b=c');\n  params = new URLSearchParams();\n  params.append('a', 'b\\uD83D\\uDCA9c');\n  assert.same(String(params), 'a=b%F0%9F%92%A9c');\n  params.delete('a');\n  params.append('a\\uD83D\\uDCA9b', 'c');\n  assert.same(String(params), 'a%F0%9F%92%A9b=c');\n  params = new URLSearchParams('a=b&c=d&&e&&');\n  assert.same(String(params), 'a=b&c=d&e=');\n  params = new URLSearchParams('a = b &a=b&c=d%20');\n  assert.same(String(params), 'a+=+b+&a=b&c=d+');\n  params = new URLSearchParams('a=&a=b');\n  assert.same(String(params), 'a=&a=b');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#forEach","suites":[],"line":524,"code":"QUnit.test('URLSearchParams#forEach', assert => {\n  const {\n    forEach\n  } = URLSearchParams.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.enumerable(URLSearchParams.prototype, 'forEach');\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let result = '';\n  params.forEach((value, key, that) => {\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    assert.same(that, params);\n    result += key;\n  });\n  assert.same(result, 'abc');\n  new URL('http://a.b/c').searchParams.forEach(() => {\n    assert.avoid();\n  }); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    params = url.searchParams;\n    result = '';\n    params.forEach((val, key) => {\n      url.search = 'x=1&y=2&z=3';\n      result += key + val;\n    });\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  result = '';\n  params.forEach((value, key) => {\n    params.delete('b');\n    result += key + value;\n  });\n  assert.same(result, 'a1c3');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#entries","suites":[],"line":569,"code":"QUnit.test('URLSearchParams#entries', assert => {\n  const {\n    entries\n  } = URLSearchParams.prototype;\n  assert.isFunction(entries);\n  assert.arity(entries, 0);\n  assert.enumerable(URLSearchParams.prototype, 'entries');\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let iterator = params.entries();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    const [key, value] = entry.value;\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    result += key;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams.entries().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams.entries();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const [key, value] = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key + value;\n    }\n\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.entries();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const [key, value] = entry.value;\n    result += key + value;\n  }\n\n  assert.same(result, 'a1c3');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().entries()), 'next').enumerable, 'enumerable .next');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#keys","suites":[],"line":624,"code":"QUnit.test('URLSearchParams#keys', assert => {\n  const {\n    keys\n  } = URLSearchParams.prototype;\n  assert.isFunction(keys);\n  assert.arity(keys, 0);\n  assert.enumerable(URLSearchParams.prototype, 'keys');\n  let iterator = new URLSearchParams('a=1&b=2&c=3').keys();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    result += entry.value;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams.keys().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams.keys();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const key = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key;\n    }\n\n    assert.same(result, 'ayz');\n  } // fails in Chrome 66-\n\n\n  const params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.keys();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const key = entry.value;\n    result += key;\n  }\n\n  assert.same(result, 'ac');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().keys()), 'next').enumerable, 'enumerable .next');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#values","suites":[],"line":670,"code":"QUnit.test('URLSearchParams#values', assert => {\n  const {\n    values\n  } = URLSearchParams.prototype;\n  assert.isFunction(values);\n  assert.arity(values, 0);\n  assert.enumerable(URLSearchParams.prototype, 'values');\n  let iterator = new URLSearchParams('a=1&b=2&c=3').values();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    result += entry.value;\n  }\n\n  assert.same(result, '123');\n  assert.true(new URL('http://a.b/c').searchParams.values().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=a&b=b&c=c&d=d');\n    iterator = url.searchParams.keys();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const {\n        value\n      } = entry;\n      url.search = 'x=x&y=y&z=z';\n      result += value;\n    }\n\n    assert.same(result, 'ayz');\n  } // fails in Chrome 66-\n\n\n  const params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.values();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const key = entry.value;\n    result += key;\n  }\n\n  assert.same(result, '13');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().values()), 'next').enumerable, 'enumerable .next');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#@@iterator","suites":[],"line":718,"code":"QUnit.test('URLSearchParams#@@iterator', assert => {\n  const entries = URLSearchParams.prototype[Symbol.iterator];\n  assert.isFunction(entries);\n  assert.arity(entries, 0);\n  assert.same(entries, URLSearchParams.prototype.entries);\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let iterator = params[Symbol.iterator]();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    const [key, value] = entry.value;\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    result += key;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams[Symbol.iterator]().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams[Symbol.iterator]();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const [key, value] = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key + value;\n    }\n\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params[Symbol.iterator]();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const [key, value] = entry.value;\n    result += key + value;\n  }\n\n  assert.same(result, 'a1c3');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams()[Symbol.iterator]()), 'next').enumerable, 'enumerable .next');\n});","file":"pure/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URL constructor","suites":[],"line":11,"code":"QUnit.test('URL constructor', assert => {\n  assert.isFunction(URL);\n  if (!NODE) assert.arity(URL, 1);\n  assert.same(String(new URL('http://www.domain.com/a/b')), 'http://www.domain.com/a/b');\n  assert.same(String(new URL('/c/d', 'http://www.domain.com/a/b')), 'http://www.domain.com/c/d');\n  assert.same(String(new URL('b/c', 'http://www.domain.com/a/b')), 'http://www.domain.com/a/b/c');\n  assert.same(String(new URL('b/c', new URL('http://www.domain.com/a/b'))), 'http://www.domain.com/a/b/c');\n  assert.same(String(new URL({\n    toString: () => 'https://example.org/'\n  })), 'https://example.org/');\n  assert.same(String(new URL('nonspecial://example.com/')), 'nonspecial://example.com/');\n  assert.same(String(new URL('https://測試')), 'https://xn--g6w251d/', 'unicode parsing');\n  assert.same(String(new URL('https://xxпривет.тест')), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n  assert.same(String(new URL('https://xxПРИВЕТ.тест')), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n  assert.same(String(new URL('http://Example.com/', 'https://example.org/')), 'http://example.com/');\n  assert.same(String(new URL('https://Example.com/', 'https://example.org/')), 'https://example.com/');\n  assert.same(String(new URL('nonspecial://Example.com/', 'https://example.org/')), 'nonspecial://Example.com/');\n  assert.same(String(new URL('http:Example.com/', 'https://example.org/')), 'http://example.com/');\n  assert.same(String(new URL('https:Example.com/', 'https://example.org/')), 'https://example.org/Example.com/');\n  assert.same(String(new URL('nonspecial:Example.com/', 'https://example.org/')), 'nonspecial:Example.com/');\n  assert.same(String(new URL('http://0300.168.0xF0')), 'http://192.168.0.240/');\n  assert.same(String(new URL('http://[20:0:0:1:0:0:0:ff]')), 'http://[20:0:0:1::ff]/'); // assert.same(String(new URL('http://257.168.0xF0')), 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // TypeError in Chrome and Safari\n\n  assert.same(String(new URL('http://0300.168.0xG0')), 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n  assert.same(String(new URL('file:///var/log/system.log')), 'file:///var/log/system.log', 'file scheme'); // assert.same(String(new URL('file://nnsc.nsf.net/bar/baz')), 'file://nnsc.nsf.net/bar/baz', 'file scheme'); // 'file:///bar/baz' in FF\n  // assert.same(String(new URL('file://localhost/bar/baz')), 'file:///bar/baz', 'file scheme'); // 'file://localhost/bar/baz' in Chrome\n\n  assert.throws(() => new URL(), 'TypeError: Failed to construct \\'URL\\': 1 argument required, but only 0 present.');\n  assert.throws(() => new URL(''), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('', 'about:blank'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('abc'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('//abc'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('http:///www.domain.com/', 'abc'), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('http:///www.domain.com/', null), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('//abc', null), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('http://[20:0:0:1:0:0:0:ff'), 'incorrect IPv6');\n  assert.throws(() => new URL('http://[20:0:0:1:0:0:0:fg]'), 'incorrect IPv6'); // assert.throws(() => new URL('http://a%b'), 'forbidden host code point'); // no error in FF\n\n  assert.throws(() => new URL('1http://zloirock.ru'), 'incorrect scheme');\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#href","suites":[],"line":51,"code":"QUnit.test('URL#href', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'href'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'href');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.href, 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.href, 'http://zloirock.ru/?foo=bar');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://測試';\n    assert.same(url.href, 'https://xn--g6w251d/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--g6w251d/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://xxпривет.тест';\n    assert.same(url.href, 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://xxПРИВЕТ.тест';\n    assert.same(url.href, 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://0300.168.0xF0';\n    assert.same(url.href, 'http://192.168.0.240/');\n    assert.same(String(url), 'http://192.168.0.240/');\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://[20:0:0:1:0:0:0:ff]';\n    assert.same(url.href, 'http://[20:0:0:1::ff]/');\n    assert.same(String(url), 'http://[20:0:0:1::ff]/'); // url = new URL('http://zloirock.ru/');\n    // url.href = 'http://257.168.0xF0'; // TypeError and Safari\n    // assert.same(url.href, 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // `F` instead of `f` in Chrome\n    // assert.same(String(url), 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // `F` instead of `f` in Chrome\n\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://0300.168.0xG0';\n    assert.same(url.href, 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n    assert.same(String(url), 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n    url = new URL('http://192.168.0.240/');\n    url.href = 'file:///var/log/system.log';\n    assert.same(url.href, 'file:///var/log/system.log', 'file -> ip');\n    assert.same(String(url), 'file:///var/log/system.log', 'file -> ip');\n    url = new URL('file:///var/log/system.log');\n    url.href = 'http://0300.168.0xF0';\n    assert.same(url.href, 'http://192.168.0.240/', 'file -> http');\n    assert.same(String(url), 'http://192.168.0.240/', 'file -> http'); // assert.throws(() => new URL('http://zloirock.ru/').href = undefined, 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'abc', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '//abc', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://[20:0:0:1:0:0:0:ff', 'incorrect IPv6'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://[20:0:0:1:0:0:0:fg]', 'incorrect IPv6'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://a%b', 'forbidden host code point'); // no error in Chrome and FF\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '1http://zloirock.ru', 'incorrect scheme'); // no error in Chrome\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#origin","suites":[],"line":113,"code":"QUnit.test('URL#origin', assert => {\n  const url = new URL('http://es6.zloirock.ru/tests.html');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'origin'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'origin');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n  }\n\n  assert.same(url.origin, 'http://es6.zloirock.ru');\n  assert.same(new URL('https://測試/tests').origin, 'https://xn--g6w251d');\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#protocol","suites":[],"line":127,"code":"QUnit.test('URL#protocol', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'protocol'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'protocol');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.protocol, 'http:');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.protocol = 'https';\n    assert.same(url.protocol, 'https:');\n    assert.same(String(url), 'https://zloirock.ru/'); // https://nodejs.org/api/url.html#url_special_schemes\n    // url = new URL('http://zloirock.ru/');\n    // url.protocol = 'fish';\n    // assert.same(url.protocol, 'http:');\n    // assert.same(url.href, 'http://zloirock.ru/');\n    // assert.same(String(url), 'http://zloirock.ru/');\n\n    url = new URL('http://zloirock.ru/');\n    url.protocol = '1http';\n    assert.same(url.protocol, 'http:');\n    assert.same(url.href, 'http://zloirock.ru/', 'incorrect scheme');\n    assert.same(String(url), 'http://zloirock.ru/', 'incorrect scheme');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#username","suites":[],"line":159,"code":"QUnit.test('URL#username', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'username'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'username');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.username, '');\n  url = new URL('http://username@zloirock.ru/');\n  assert.same(url.username, 'username');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.username = 'username';\n    assert.same(url.username, 'username');\n    assert.same(String(url), 'http://username@zloirock.ru/');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#password","suites":[],"line":182,"code":"QUnit.test('URL#password', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'password'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'password');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.password, '');\n  url = new URL('http://username:password@zloirock.ru/');\n  assert.same(url.password, 'password'); // url = new URL('http://:password@zloirock.ru/'); // TypeError in FF\n  // assert.same(url.password, 'password');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.username = 'username';\n    url.password = 'password';\n    assert.same(url.password, 'password');\n    assert.same(String(url), 'http://username:password@zloirock.ru/'); // url = new URL('http://zloirock.ru/');\n    // url.password = 'password';\n    // assert.same(url.password, 'password'); // '' in FF\n    // assert.same(String(url), 'http://:password@zloirock.ru/'); // 'http://zloirock.ru/' in FF\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#host","suites":[],"line":210,"code":"QUnit.test('URL#host', assert => {\n  let url = new URL('http://zloirock.ru:81/path');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'host'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'host');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.host, 'zloirock.ru:81');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru:81/path');\n    url.host = 'example.com:82';\n    assert.same(url.host, 'example.com:82');\n    assert.same(String(url), 'http://example.com:82/path'); // url = new URL('http://zloirock.ru:81/path');\n    // url.host = 'other?domain.com';\n    // assert.same(String(url), 'http://other:81/path'); // 'http://other/?domain.com/path' in Safari\n\n    url = new URL('https://www.mydomain.com:8080/path/');\n    url.host = 'www.otherdomain.com:80';\n    assert.same(url.href, 'https://www.otherdomain.com:80/path/', 'set default port for another protocol'); // url = new URL('https://www.mydomain.com:8080/path/');\n    // url.host = 'www.otherdomain.com:443';\n    // assert.same(url.href, 'https://www.otherdomain.com/path/', 'set default port');\n\n    url = new URL('http://zloirock.ru/foo');\n    url.host = '測試';\n    assert.same(url.host, 'xn--g6w251d', 'unicode parsing');\n    assert.same(String(url), 'http://xn--g6w251d/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = 'xxпривет.тест';\n    assert.same(url.host, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = 'xxПРИВЕТ.тест';\n    assert.same(url.host, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = '0300.168.0xF0';\n    assert.same(url.host, '192.168.0.240');\n    assert.same(String(url), 'http://192.168.0.240/foo'); // url = new URL('http://zloirock.ru/foo');\n    // url.host = '[20:0:0:1:0:0:0:ff]';\n    // assert.same(url.host, '[20:0:0:1::ff]'); // ':0' in Chrome, 'zloirock.ru' in Safari\n    // assert.same(String(url), 'http://[20:0:0:1::ff]/foo'); // 'http://[20:0/foo' in Chrome, 'http://zloirock.ru/foo' in Safari\n    // url = new URL('file:///var/log/system.log');\n    // url.host = 'nnsc.nsf.net'; // does not work in FF\n    // assert.same(url.hostname, 'nnsc.nsf.net', 'file');\n    // assert.same(String(url), 'file://nnsc.nsf.net/var/log/system.log', 'file');\n    // url = new URL('http://zloirock.ru/');\n    // url.host = '[20:0:0:1:0:0:0:ff';\n    // assert.same(url.host, 'zloirock.ru', 'incorrect IPv6'); // ':0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.host = '[20:0:0:1:0:0:0:fg]';\n    // assert.same(url.host, 'zloirock.ru', 'incorrect IPv6'); // ':0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.host = 'a%b';\n    // assert.same(url.host, 'zloirock.ru', 'forbidden host code point'); // '' in Chrome, 'a%b' in FF\n    // assert.same(String(url), 'http://zloirock.ru/', 'forbidden host code point'); // 'http://a%25b/' in Chrome, 'http://a%b/' in FF\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#hostname","suites":[],"line":275,"code":"QUnit.test('URL#hostname', assert => {\n  let url = new URL('http://zloirock.ru:81/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'hostname'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'hostname');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.hostname, 'zloirock.ru');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru:81/');\n    url.hostname = 'example.com';\n    assert.same(url.hostname, 'example.com');\n    assert.same(String(url), 'http://example.com:81/'); // url = new URL('http://zloirock.ru:81/');\n    // url.hostname = 'example.com:82';\n    // assert.same(url.hostname, 'example.com'); // '' in Chrome\n    // assert.same(String(url), 'http://example.com:81/'); // 'http://example.com:82:81/' in Chrome\n\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = '測試';\n    assert.same(url.hostname, 'xn--g6w251d', 'unicode parsing');\n    assert.same(String(url), 'http://xn--g6w251d/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = 'xxпривет.тест';\n    assert.same(url.hostname, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = 'xxПРИВЕТ.тест';\n    assert.same(url.hostname, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = '0300.168.0xF0';\n    assert.same(url.hostname, '192.168.0.240');\n    assert.same(String(url), 'http://192.168.0.240/foo'); // url = new URL('http://zloirock.ru/foo');\n    // url.hostname = '[20:0:0:1:0:0:0:ff]';\n    // assert.same(url.hostname, '[20:0:0:1::ff]'); // 'zloirock.ru' in Safari\n    // assert.same(String(url), 'http://[20:0:0:1::ff]/foo'); // 'http://zloirock.ru/foo' in Safari\n    // url = new URL('file:///var/log/system.log');\n    // url.hostname = 'nnsc.nsf.net'; // does not work in FF\n    // assert.same(url.hostname, 'nnsc.nsf.net', 'file');\n    // assert.same(String(url), 'file://nnsc.nsf.net/var/log/system.log', 'file');\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = '[20:0:0:1:0:0:0:ff';\n    // assert.same(url.hostname, 'zloirock.ru', 'incorrect IPv6'); // '' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0:0:1:0:0:0:ff' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = '[20:0:0:1:0:0:0:fg]';\n    // assert.same(url.hostname, 'zloirock.ru', 'incorrect IPv6'); // '' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0:0:1:0:0:0:ff/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = 'a%b';\n    // assert.same(url.hostname, 'zloirock.ru', 'forbidden host code point'); // '' in Chrome, 'a%b' in FF\n    // assert.same(String(url), 'http://zloirock.ru/', 'forbidden host code point'); // 'http://a%25b/' in Chrome, 'http://a%b/' in FF\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#port","suites":[],"line":335,"code":"QUnit.test('URL#port', assert => {\n  let url = new URL('http://zloirock.ru:1337/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'port'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'port');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.port, '1337');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.port = 80;\n    assert.same(url.port, '');\n    assert.same(String(url), 'http://zloirock.ru/');\n    url.port = 1337;\n    assert.same(url.port, '1337');\n    assert.same(String(url), 'http://zloirock.ru:1337/'); // url.port = 'abcd';\n    // assert.same(url.port, '1337'); // '0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru:1337/'); // 'http://zloirock.ru:0/' in Chrome\n    // url.port = '5678abcd';\n    // assert.same(url.port, '5678'); // '1337' in FF\n    // assert.same(String(url), 'http://zloirock.ru:5678/'); // 'http://zloirock.ru:1337/\"' in FF\n\n    url.port = 1234.5678;\n    assert.same(url.port, '1234');\n    assert.same(String(url), 'http://zloirock.ru:1234/'); // url.port = 1e10;\n    // assert.same(url.port, '1234'); // '0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru:1234/'); // 'http://zloirock.ru:0/' in Chrome\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#pathname","suites":[],"line":370,"code":"QUnit.test('URL#pathname', assert => {\n  let url = new URL('http://zloirock.ru/foo/bar');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'pathname'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'pathname');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.pathname, '/foo/bar');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.pathname = 'bar/baz';\n    assert.same(url.pathname, '/bar/baz');\n    assert.same(String(url), 'http://zloirock.ru/bar/baz');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#search","suites":[],"line":391,"code":"QUnit.test('URL#search', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'search'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'search');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.search, '');\n  url = new URL('http://zloirock.ru/?foo=bar');\n  assert.same(url.search, '?foo=bar');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/?');\n    assert.same(url.search, '');\n    assert.same(String(url), 'http://zloirock.ru/?');\n    url.search = 'foo=bar';\n    assert.same(url.search, '?foo=bar');\n    assert.same(String(url), 'http://zloirock.ru/?foo=bar');\n    url.search = '?bar=baz';\n    assert.same(url.search, '?bar=baz');\n    assert.same(String(url), 'http://zloirock.ru/?bar=baz');\n    url.search = '';\n    assert.same(url.search, '');\n    assert.same(String(url), 'http://zloirock.ru/');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#searchParams","suites":[],"line":422,"code":"QUnit.test('URL#searchParams', assert => {\n  let url = new URL('http://zloirock.ru/?foo=bar&bar=baz');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'searchParams'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'searchParams');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n  }\n\n  assert.true(url.searchParams instanceof URLSearchParams);\n  assert.same(url.searchParams.get('foo'), 'bar');\n  assert.same(url.searchParams.get('bar'), 'baz');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.searchParams.append('foo', 'bar');\n    assert.same(String(url), 'http://zloirock.ru/?foo=bar');\n    url = new URL('http://zloirock.ru/');\n    url.search = 'foo=bar';\n    assert.same(url.searchParams.get('foo'), 'bar');\n    url = new URL('http://zloirock.ru/?foo=bar&bar=baz');\n    url.search = '';\n    assert.false(url.searchParams.has('foo'));\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#hash","suites":[],"line":449,"code":"QUnit.test('URL#hash', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'hash'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'hash');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.hash, '');\n  url = new URL('http://zloirock.ru/#foo');\n  assert.same(url.hash, '#foo');\n  url = new URL('http://zloirock.ru/#');\n  assert.same(url.hash, '');\n  assert.same(String(url), 'http://zloirock.ru/#');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/#');\n    url.hash = 'foo';\n    assert.same(url.hash, '#foo');\n    assert.same(String(url), 'http://zloirock.ru/#foo');\n    url.hash = '';\n    assert.same(url.hash, '');\n    assert.same(String(url), 'http://zloirock.ru/'); // url.hash = '#';\n    // assert.same(url.hash, '');\n    // assert.same(String(url), 'http://zloirock.ru/'); // 'http://zloirock.ru/#' in FF\n\n    url.hash = '#foo';\n    assert.same(url.hash, '#foo');\n    assert.same(String(url), 'http://zloirock.ru/#foo');\n    url.hash = '#foo#bar';\n    assert.same(url.hash, '#foo#bar');\n    assert.same(String(url), 'http://zloirock.ru/#foo#bar');\n    url = new URL('http://zloirock.ru/');\n    url.hash = 'абa';\n    assert.same(url.hash, '#%D0%B0%D0%B1a'); // url = new URL('http://zloirock.ru/');\n    // url.hash = '\\udc01\\ud802a';\n    // assert.same(url.hash, '#%EF%BF%BD%EF%BF%BDa', 'unmatched surrogates');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#toJSON","suites":[],"line":492,"code":"QUnit.test('URL#toJSON', assert => {\n  const {\n    toJSON\n  } = URL.prototype;\n  assert.isFunction(toJSON);\n  assert.arity(toJSON, 0);\n  assert.enumerable(URL.prototype, 'toJSON');\n  const url = new URL('http://zloirock.ru/');\n  assert.same(url.toJSON(), 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.toJSON(), 'http://zloirock.ru/?foo=bar');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#toString","suites":[],"line":507,"code":"QUnit.test('URL#toString', assert => {\n  const {\n    toString\n  } = URL.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.enumerable(URL.prototype, 'toString');\n  const url = new URL('http://zloirock.ru/');\n  assert.same(url.toString(), 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.toString(), 'http://zloirock.ru/?foo=bar');\n  }\n});","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"URL.sham","suites":[],"line":522,"code":"QUnit.test('URL.sham', assert => {\n  assert.same(URL.sham, DESCRIPTORS ? undefined : true);\n}); // `core-js` URL implementation pass all (exclude some encoding-related) tests","file":"pure/web.url.js","skipped":false,"dir":"tests"},{"name":"AggregateError","suites":[],"line":4,"code":"QUnit.test('AggregateError', assert => {\n  assert.isFunction(AggregateError);\n  assert.arity(AggregateError, 2);\n  assert.name(AggregateError, 'AggregateError');\n  assert.looksNative(AggregateError);\n  assert.true(new AggregateError([1]) instanceof AggregateError);\n  assert.true(new AggregateError([1]) instanceof Error);\n  assert.true(AggregateError([1]) instanceof AggregateError);\n  assert.true(AggregateError([1]) instanceof Error);\n  assert.same(AggregateError([1], 'foo').message, 'foo');\n  assert.same(AggregateError([1], 123).message, '123');\n  assert.same(AggregateError([1]).message, '');\n  assert.deepEqual(AggregateError([1, 2, 3]).errors, [1, 2, 3]);\n  assert.throws(() => AggregateError([1], Symbol()), 'throws on symbol as a message');\n  assert.same({}.toString.call(AggregateError([1])), '[object Error]', 'Object#toString');\n  assert.same(AggregateError.prototype.constructor, AggregateError, 'prototype constructor'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n  assert.false(AggregateError.prototype.hasOwnProperty('cause'), 'prototype hasn`t cause');\n  assert.true(AggregateError([1], 1) instanceof AggregateError, 'no cause, without new');\n  assert.true(new AggregateError([1], 1) instanceof AggregateError, 'no cause, with new');\n  assert.true(AggregateError([1], 1, {}) instanceof AggregateError, 'with options, without new');\n  assert.true(new AggregateError([1], 1, {}) instanceof AggregateError, 'with options, with new');\n  assert.true(AggregateError([1], 1, 'foo') instanceof AggregateError, 'non-object options, without new');\n  assert.true(new AggregateError([1], 1, 'foo') instanceof AggregateError, 'non-object options, with new');\n  assert.same(AggregateError([1], 1, {\n    cause: 7\n  }).cause, 7, 'cause, without new');\n  assert.same(new AggregateError([1], 1, {\n    cause: 7\n  }).cause, 7, 'cause, with new');\n  assert.same(AggregateError([1], 1, create({\n    cause: 7\n  })).cause, 7, 'prototype cause, without new');\n  assert.same(new AggregateError([1], 1, create({\n    cause: 7\n  })).cause, 7, 'prototype cause, with new');\n  let error = AggregateError([1], 1, {\n    cause: 7\n  });\n  assert.deepEqual(error.errors, [1]);\n  assert.same(error.name, 'AggregateError', 'instance name');\n  assert.same(error.message, '1', 'instance message');\n  assert.same(error.cause, 7, 'instance cause'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n  assert.true(error.hasOwnProperty('cause'), 'cause is own');\n  error = AggregateError([1]);\n  assert.deepEqual(error.errors, [1]);\n  assert.same(error.message, '', 'default instance message');\n  assert.same(error.cause, undefined, 'default instance cause undefined'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n  assert.false(error.hasOwnProperty('cause'), 'default instance cause missed');\n});","file":"tests/es.aggregate-error.js","skipped":false,"dir":"tests"},{"name":"ArrayBuffer","suites":[],"line":2,"code":"QUnit.test('ArrayBuffer', assert => {\n  const Symbol = GLOBAL.Symbol || {}; // in Safari 5 typeof ArrayBuffer is 'object'\n\n  assert.same(ArrayBuffer, Object(ArrayBuffer), 'is object'); // 0 in V8 ~ Chromium 27-\n\n  assert.arity(ArrayBuffer, 1); // Safari 5 bug\n\n  assert.name(ArrayBuffer, 'ArrayBuffer'); // Safari 5 bug\n\n  if (NATIVE) assert.looksNative(ArrayBuffer);\n  assert.same(new ArrayBuffer(123).byteLength, 123, 'length'); // fails in Safari\n\n  assert.throws(() => new ArrayBuffer(-1), RangeError, 'negative length');\n  assert.notThrows(() => new ArrayBuffer(0.5), 'fractional length');\n  assert.notThrows(() => new ArrayBuffer(), 'missed length');\n  if (DESCRIPTORS) assert.same(ArrayBuffer[Symbol.species], ArrayBuffer, '@@species');\n});","file":"tests/es.array-buffer.constructor.js","skipped":false,"dir":"tests"},{"name":"ArrayBuffer.isView","suites":[],"line":2,"code":"QUnit.test('ArrayBuffer.isView', assert => {\n  const {\n    isView\n  } = ArrayBuffer;\n  assert.isFunction(isView);\n  assert.arity(isView, 1);\n  assert.name(isView, 'isView');\n  assert.looksNative(isView);\n  assert.nonEnumerable(ArrayBuffer, 'isView');\n\n  for (const name in TYPED_ARRAYS) {\n    if (GLOBAL[name]) {\n      assert.true(isView(new GLOBAL[name]([1])), `${name} - true`);\n    }\n  }\n\n  assert.true(isView(new DataView(new ArrayBuffer(1))), 'DataView - true');\n  assert.false(isView(new ArrayBuffer(1)), 'ArrayBuffer - false');\n  const examples = [undefined, null, false, true, 0, 1, '', 'qwe', {}, [], function () {\n    /* empty */\n  }];\n\n  for (const example of examples) {\n    assert.false(isView(example), `${example} - false`);\n  }\n});","file":"tests/es.array-buffer.is-view.js","skipped":false,"dir":"tests"},{"name":"ArrayBuffer#slice","suites":[],"line":1,"code":"QUnit.test('ArrayBuffer#slice', assert => {\n  const {\n    slice\n  } = ArrayBuffer.prototype;\n\n  function arrayToBuffer(it) {\n    const buffer = new ArrayBuffer(it.length);\n    const view = new DataView(buffer);\n\n    for (let i = 0, {\n      length\n    } = it; i < length; ++i) {\n      view.setUint8(i, it[i]);\n    }\n\n    return buffer;\n  }\n\n  function bufferToArray(it) {\n    const results = [];\n    const view = new DataView(it);\n\n    for (let i = 0, {\n      byteLength\n    } = view; i < byteLength; ++i) {\n      results.push(view.getUint8(i));\n    }\n\n    return results;\n  }\n\n  assert.isFunction(slice);\n  assert.arity(slice, 2);\n  assert.name(slice, 'slice');\n  assert.looksNative(slice); // assert.nonEnumerable(ArrayBuffer.prototype, 'slice');\n\n  const buffer = arrayToBuffer([1, 2, 3, 4, 5]);\n  assert.true(buffer instanceof ArrayBuffer, 'correct buffer');\n  assert.notSame(buffer.slice(), buffer, 'returns new buffer');\n  assert.true(buffer.slice() instanceof ArrayBuffer, 'correct instance');\n  assert.arrayEqual(bufferToArray(buffer.slice()), [1, 2, 3, 4, 5]);\n  assert.arrayEqual(bufferToArray(buffer.slice(1, 3)), [2, 3]);\n  assert.arrayEqual(bufferToArray(buffer.slice(1, undefined)), [2, 3, 4, 5]);\n  assert.arrayEqual(bufferToArray(buffer.slice(1, -1)), [2, 3, 4]);\n  assert.arrayEqual(bufferToArray(buffer.slice(-2, -1)), [4]);\n  assert.arrayEqual(bufferToArray(buffer.slice(-2, -3)), []);\n});","file":"tests/es.array-buffer.slice.js","skipped":false,"dir":"tests"},{"name":"Array#at","suites":[],"line":2,"code":"QUnit.test('Array#at', assert => {\n  const {\n    at\n  } = Array.prototype;\n  assert.isFunction(at);\n  assert.arity(at, 1);\n  assert.name(at, 'at');\n  assert.looksNative(at);\n  assert.nonEnumerable(Array.prototype, 'at');\n  assert.same(1, [1, 2, 3].at(0));\n  assert.same(2, [1, 2, 3].at(1));\n  assert.same(3, [1, 2, 3].at(2));\n  assert.same(undefined, [1, 2, 3].at(3));\n  assert.same(3, [1, 2, 3].at(-1));\n  assert.same(2, [1, 2, 3].at(-2));\n  assert.same(1, [1, 2, 3].at(-3));\n  assert.same(undefined, [1, 2, 3].at(-4));\n  assert.same(1, [1, 2, 3].at(0.4));\n  assert.same(1, [1, 2, 3].at(0.5));\n  assert.same(1, [1, 2, 3].at(0.6));\n  assert.same(1, [1].at(NaN));\n  assert.same(1, [1].at());\n  assert.same(1, [1, 2, 3].at(-0));\n  assert.same(undefined, Array(1).at(0));\n  assert.same(1, at.call({\n    0: 1,\n    length: 1\n  }, 0));\n\n  if (STRICT) {\n    assert.throws(() => at.call(null, 0), TypeError);\n    assert.throws(() => at.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.array.at.js","skipped":false,"dir":"tests"},{"name":"Array#concat","suites":[],"line":2,"code":"QUnit.test('Array#concat', assert => {\n  const {\n    concat\n  } = Array.prototype;\n  assert.isFunction(concat);\n  assert.arity(concat, 1);\n  assert.name(concat, 'concat');\n  assert.looksNative(concat);\n  assert.nonEnumerable(Array.prototype, 'concat');\n  let array = [1, 2];\n  const sparseArray = [1,, 2];\n  const nonSpreadableArray = [1, 2];\n  nonSpreadableArray[Symbol.isConcatSpreadable] = false;\n  const arrayLike = {\n    0: 1,\n    1: 2,\n    length: 2\n  };\n  const spreadableArrayLike = {\n    0: 1,\n    1: 2,\n    length: 2,\n    [Symbol.isConcatSpreadable]: true\n  };\n  assert.deepEqual(array.concat(), [1, 2], '#1');\n  assert.deepEqual(sparseArray.concat(), [1,, 2], '#2');\n  assert.deepEqual(nonSpreadableArray.concat(), [[1, 2]], '#3');\n  assert.deepEqual(concat.call(arrayLike), [{\n    0: 1,\n    1: 2,\n    length: 2\n  }], '#4');\n  assert.deepEqual(concat.call(spreadableArrayLike), [1, 2], '#5');\n  assert.deepEqual([].concat(array), [1, 2], '#6');\n  assert.deepEqual([].concat(sparseArray), [1,, 2], '#7');\n  assert.deepEqual([].concat(nonSpreadableArray), [[1, 2]], '#8');\n  assert.deepEqual([].concat(arrayLike), [{\n    0: 1,\n    1: 2,\n    length: 2\n  }], '#9');\n  assert.deepEqual([].concat(spreadableArrayLike), [1, 2], '#10');\n  assert.deepEqual(array.concat(sparseArray, nonSpreadableArray, arrayLike, spreadableArrayLike), [1, 2, 1,, 2, [1, 2], {\n    0: 1,\n    1: 2,\n    length: 2\n  }, 1, 2], '#11');\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.concat().foo, 1, '@@species');\n});","file":"tests/es.array.concat.js","skipped":false,"dir":"tests"},{"name":"Array#copyWithin","suites":[],"line":2,"code":"QUnit.test('Array#copyWithin', assert => {\n  const {\n    copyWithin\n  } = Array.prototype;\n  assert.isFunction(copyWithin);\n  assert.arity(copyWithin, 2);\n  assert.name(copyWithin, 'copyWithin');\n  assert.looksNative(copyWithin);\n  const array = [1];\n  assert.same(array.copyWithin(0), array);\n  assert.nonEnumerable(Array.prototype, 'copyWithin');\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, 3), [4, 5, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 3), [1, 4, 5, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 2), [1, 3, 4, 5, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(2, 2), [1, 2, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, 3, 4), [4, 2, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 3, 4), [1, 4, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(1, 2, 4), [1, 3, 4, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, -2), [4, 5, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(0, -2, -1), [4, 2, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3, -2), [1, 3, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3, -1), [1, 3, 4, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].copyWithin(-4, -3), [1, 3, 4, 5, 5]);\n\n  if (STRICT) {\n    assert.throws(() => copyWithin.call(null, 0), TypeError);\n    assert.throws(() => copyWithin.call(undefined, 0), TypeError);\n  }\n\n  assert.true('copyWithin' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.copy-within.js","skipped":false,"dir":"tests"},{"name":"Array#every","suites":[],"line":2,"code":"QUnit.test('Array#every', assert => {\n  const {\n    every\n  } = Array.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.looksNative(every);\n  assert.nonEnumerable(Array.prototype, 'every');\n  let array = [1];\n  const context = {};\n  array.every(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true([1, 2, 3].every(it => typeof it == 'number'));\n  assert.true([1, 2, 3].every(it => it < 4));\n  assert.false([1, 2, 3].every(it => it < 3));\n  assert.false([1, 2, 3].every(it => typeof it == 'string'));\n  assert.true([1, 2, 3].every(function () {\n    return +this === 1;\n  }, 1));\n  let result = '';\n  [1, 2, 3].every((value, key) => result += key);\n  assert.same(result, '012');\n  array = [1, 2, 3];\n  assert.true(array.every((value, key, that) => that === array));\n\n  if (STRICT) {\n    assert.throws(() => every.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => every.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n});","file":"tests/es.array.every.js","skipped":false,"dir":"tests"},{"name":"Array#fill","suites":[],"line":2,"code":"QUnit.test('Array#fill', assert => {\n  const {\n    fill\n  } = Array.prototype;\n  assert.isFunction(fill);\n  assert.arity(fill, 1);\n  assert.name(fill, 'fill');\n  assert.looksNative(fill);\n  assert.nonEnumerable(Array.prototype, 'fill');\n  const array = new Array(5);\n  assert.same(array.fill(5), array);\n  assert.deepEqual(Array(5).fill(5), [5, 5, 5, 5, 5]);\n  assert.deepEqual(Array(5).fill(5, 1), [undefined, 5, 5, 5, 5]);\n  assert.deepEqual(Array(5).fill(5, 1, 4), [undefined, 5, 5, 5, undefined]);\n  assert.deepEqual(Array(5).fill(5, 6, 1), [undefined, undefined, undefined, undefined, undefined]);\n  assert.deepEqual(Array(5).fill(5, -3, 4), [undefined, undefined, 5, 5, undefined]);\n  assert.arrayEqual(fill.call({\n    length: 5\n  }, 5), [5, 5, 5, 5, 5]);\n\n  if (STRICT) {\n    assert.throws(() => fill.call(null, 0), TypeError);\n    assert.throws(() => fill.call(undefined, 0), TypeError);\n  }\n\n  if (NATIVE && DESCRIPTORS) {\n    assert.notThrows(() => fill.call(Object.defineProperty({\n      length: -1\n    }, 0, {\n      set() {\n        throw Error();\n      }\n\n    })), 'uses ToLength');\n  }\n\n  assert.true('fill' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.fill.js","skipped":false,"dir":"tests"},{"name":"Array#filter","suites":[],"line":2,"code":"QUnit.test('Array#filter', assert => {\n  const {\n    filter\n  } = Array.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.looksNative(filter);\n  assert.nonEnumerable(Array.prototype, 'filter');\n  let array = [1];\n  const context = {};\n  array.filter(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], [1, 2, 3, 'q', {}, 4, true, 5].filter(it => typeof it == 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filter.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filter.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.filter(Boolean).foo, 1, '@@species');\n});","file":"tests/es.array.filter.js","skipped":false,"dir":"tests"},{"name":"Array#findIndex","suites":[],"line":2,"code":"QUnit.test('Array#findIndex', assert => {\n  const {\n    findIndex\n  } = Array.prototype;\n  assert.isFunction(findIndex);\n  assert.arity(findIndex, 1);\n  assert.name(findIndex, 'findIndex');\n  assert.looksNative(findIndex);\n  assert.nonEnumerable(Array.prototype, 'findIndex');\n  const array = [1];\n  const context = {};\n  array.findIndex(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context); // eslint-disable-next-line unicorn/prefer-array-index-of -- ignore\n\n  assert.same([1, 3, NaN, 42, {}].findIndex(it => it === 42), 3); // eslint-disable-next-line unicorn/prefer-array-index-of -- ignore\n\n  assert.same([1, 3, NaN, 42, {}].findIndex(it => it === 43), -1);\n\n  if (STRICT) {\n    assert.throws(() => findIndex.call(null, 0), TypeError);\n    assert.throws(() => findIndex.call(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => findIndex.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === -1, 'uses ToLength');\n  assert.true('findIndex' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.find-index.js","skipped":false,"dir":"tests"},{"name":"Array#find","suites":[],"line":2,"code":"QUnit.test('Array#find', assert => {\n  const {\n    find\n  } = Array.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.looksNative(find);\n  assert.nonEnumerable(Array.prototype, 'find');\n  const array = [1];\n  const context = {};\n  array.find(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same([1, 3, NaN, 42, {}].find(it => it === 42), 42);\n  assert.same([1, 3, NaN, 42, {}].find(it => it === 43), undefined);\n\n  if (STRICT) {\n    assert.throws(() => find.call(null, 0), TypeError);\n    assert.throws(() => find.call(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => find.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === undefined, 'uses ToLength');\n  assert.true('find' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.find.js","skipped":false,"dir":"tests"},{"name":"Array#flatMap","suites":[],"line":3,"code":"QUnit.test('Array#flatMap', assert => {\n  const {\n    flatMap\n  } = Array.prototype;\n  assert.isFunction(flatMap);\n  assert.name(flatMap, 'flatMap');\n  assert.arity(flatMap, 1);\n  assert.looksNative(flatMap);\n  assert.nonEnumerable(Array.prototype, 'flatMap');\n  assert.deepEqual([].flatMap(it => it), []);\n  assert.deepEqual([1, 2, 3].flatMap(it => it), [1, 2, 3]);\n  assert.deepEqual([1, 2, 3].flatMap(it => [it, it]), [1, 1, 2, 2, 3, 3]);\n  assert.deepEqual([1, 2, 3].flatMap(it => [[it], [it]]), [[1], [1], [2], [2], [3], [3]]);\n  assert.deepEqual([1, [2, 3]].flatMap(() => 1), [1, 1]);\n  const array = [1];\n  const context = {};\n  array.flatMap(function (value, key, that) {\n    assert.same(value, 1);\n    assert.same(key, 0);\n    assert.same(that, array);\n    assert.same(this, context);\n    return value;\n  }, context);\n\n  if (STRICT) {\n    assert.throws(() => flatMap.call(null, it => it), TypeError);\n    assert.throws(() => flatMap.call(undefined, it => it), TypeError);\n  }\n\n  assert.notThrows(() => flatMap.call({\n    length: -1\n  }, () => {\n    throw new Error();\n  }).length === 0, 'uses ToLength');\n  assert.true('flatMap' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.flat-map.js","skipped":false,"dir":"tests"},{"name":"Array#flat","suites":[],"line":2,"code":"QUnit.test('Array#flat', assert => {\n  const {\n    flat\n  } = Array.prototype;\n  const {\n    defineProperty\n  } = Object;\n  assert.isFunction(flat);\n  assert.name(flat, 'flat');\n  assert.arity(flat, 0);\n  assert.looksNative(flat);\n  assert.nonEnumerable(Array.prototype, 'flat');\n  assert.deepEqual([].flat(), []);\n  const array = [1, [2, 3], [4, [5, 6]]];\n  assert.deepEqual(array.flat(0), array);\n  assert.deepEqual(array.flat(1), [1, 2, 3, 4, [5, 6]]);\n  assert.deepEqual(array.flat(), [1, 2, 3, 4, [5, 6]]);\n  assert.deepEqual(array.flat(2), [1, 2, 3, 4, 5, 6]);\n  assert.deepEqual(array.flat(3), [1, 2, 3, 4, 5, 6]);\n  assert.deepEqual(array.flat(-1), array);\n  assert.deepEqual(array.flat(Infinity), [1, 2, 3, 4, 5, 6]);\n\n  if (STRICT) {\n    assert.throws(() => flat.call(null), TypeError);\n    assert.throws(() => flat.call(undefined), TypeError);\n  }\n\n  if (DESCRIPTORS) {\n    assert.notThrows(() => flat.call(defineProperty({\n      length: -1\n    }, 0, {\n      enumerable: true,\n\n      get() {\n        throw new Error();\n      }\n\n    })).length === 0, 'uses ToLength');\n  }\n\n  assert.true('flat' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.flat.js","skipped":false,"dir":"tests"},{"name":"Array#forEach","suites":[],"line":2,"code":"QUnit.test('Array#forEach', assert => {\n  const {\n    forEach\n  } = Array.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.name(forEach, 'forEach');\n  assert.looksNative(forEach);\n  assert.nonEnumerable(Array.prototype, 'forEach');\n  let array = [1];\n  const context = {};\n  array.forEach(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  let result = '';\n  [1, 2, 3].forEach(value => {\n    result += value;\n  });\n  assert.same(result, '123');\n  result = '';\n  [1, 2, 3].forEach((value, key) => {\n    result += key;\n  });\n  assert.same(result, '012');\n  result = '';\n  [1, 2, 3].forEach((value, key, that) => {\n    result += that;\n  });\n  assert.same(result, '1,2,31,2,31,2,3');\n  result = '';\n  [1, 2, 3].forEach(function () {\n    result += this;\n  }, 1);\n  assert.same(result, '111');\n  result = '';\n  array = [];\n  array[5] = '';\n  array.forEach((value, key) => {\n    result += key;\n  });\n  assert.same(result, '5');\n\n  if (STRICT) {\n    assert.throws(() => {\n      forEach.call(null, () => {\n        /* empty */\n      });\n    }, TypeError);\n    assert.throws(() => {\n      forEach.call(undefined, () => {\n        /* empty */\n      });\n    }, TypeError);\n  }\n});","file":"tests/es.array.for-each.js","skipped":false,"dir":"tests"},{"name":"Array.from","suites":[],"line":3,"code":"QUnit.test('Array.from', assert => {\n  const Symbol = GLOBAL.Symbol || {};\n  const {\n    from\n  } = Array;\n  const {\n    defineProperty\n  } = Object;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(Array, 'from');\n  let types = {\n    'array-like': {\n      length: '3',\n      0: '1',\n      1: '2',\n      2: '3'\n    },\n    arguments: function () {\n      return arguments;\n    }('1', '2', '3'),\n    array: ['1', '2', '3'],\n    iterable: createIterable(['1', '2', '3']),\n    string: '123'\n  };\n\n  for (const type in types) {\n    const data = types[type];\n    assert.arrayEqual(from(data), ['1', '2', '3'], `Works with ${type}`);\n    assert.arrayEqual(from(data, it => it ** 2), [1, 4, 9], `Works with ${type} + mapFn`);\n  }\n\n  types = {\n    'array-like': {\n      length: 1,\n      0: 1\n    },\n    arguments: function () {\n      return arguments;\n    }(1),\n    array: [1],\n    iterable: createIterable([1]),\n    string: '1'\n  };\n\n  for (const type in types) {\n    const data = types[type];\n    const context = {};\n    assert.arrayEqual(from(data, function (value, key) {\n      assert.same(this, context, `Works with ${type}, correct callback context`);\n      assert.same(value, type === 'string' ? '1' : 1, `Works with ${type}, correct callback key`);\n      assert.same(key, 0, `Works with ${type}, correct callback value`);\n      assert.same(arguments.length, 2, `Works with ${type}, correct callback arguments number`);\n      return 42;\n    }, context), [42], `Works with ${type}, correct result`);\n  }\n\n  const primitives = [false, true, 0];\n\n  for (const primitive of primitives) {\n    assert.arrayEqual(from(primitive), [], `Works with ${primitive}`);\n  }\n\n  assert.throws(() => from(null), TypeError, 'Throws on null');\n  assert.throws(() => from(undefined), TypeError, 'Throws on undefined');\n  assert.arrayEqual(from('𠮷𠮷𠮷'), ['𠮷', '𠮷', '𠮷'], 'Uses correct string iterator');\n  let done = true;\n  from(createIterable([1, 2, 3], {\n    return() {\n      return done = false;\n    }\n\n  }), () => false);\n  assert.true(done, '.return #default');\n  done = false;\n\n  try {\n    from(createIterable([1, 2, 3], {\n      return() {\n        return done = true;\n      }\n\n    }), () => {\n      throw new Error();\n    });\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n\n  class C {\n    /* empty */\n  }\n\n  let instance = from.call(C, createIterable([1, 2]));\n  assert.true(instance instanceof C, 'generic, iterable case, instanceof');\n  assert.arrayEqual(instance, [1, 2], 'generic, iterable case, elements');\n  instance = from.call(C, {\n    0: 1,\n    1: 2,\n    length: 2\n  });\n  assert.true(instance instanceof C, 'generic, array-like case, instanceof');\n  assert.arrayEqual(instance, [1, 2], 'generic, array-like case, elements');\n  let array = [1, 2, 3];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  assert.arrayEqual(from(array), [1, 2, 3], 'Array with custom iterator, elements');\n  assert.true(done, 'call @@iterator in Array with custom iterator');\n  array = [1, 2, 3];\n  delete array[1];\n  assert.arrayEqual(from(array, String), ['1', 'undefined', '3'], 'Ignores holes');\n  assert.notThrows(() => from({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }).length === 0, 'Uses ToLength');\n  assert.arrayEqual(from([], undefined), [], 'Works with undefined as asecond argument');\n  assert.throws(() => from([], null), TypeError, 'Throws with null as second argument');\n  assert.throws(() => from([], 0), TypeError, 'Throws with 0 as second argument');\n  assert.throws(() => from([], ''), TypeError, 'Throws with \"\" as second argument');\n  assert.throws(() => from([], false), TypeError, 'Throws with false as second argument');\n  assert.throws(() => from([], {}), TypeError, 'Throws with {} as second argument');\n\n  if (DESCRIPTORS) {\n    let called = false;\n    defineProperty(C.prototype, 0, {\n      set() {\n        called = true;\n      }\n\n    });\n    from.call(C, [1, 2, 3]);\n    assert.false(called, 'Should not call prototype accessors');\n  }\n});","file":"tests/es.array.from.js","skipped":false,"dir":"tests"},{"name":"Array#includes","suites":[],"line":2,"code":"QUnit.test('Array#includes', assert => {\n  const {\n    includes\n  } = Array.prototype;\n  assert.isFunction(includes);\n  assert.name(includes, 'includes');\n  assert.arity(includes, 1);\n  assert.looksNative(includes);\n  assert.nonEnumerable(Array.prototype, 'includes');\n  const object = {};\n  const array = [1, 2, 3, -0, object];\n  assert.true(array.includes(1));\n  assert.true(array.includes(-0));\n  assert.true(array.includes(0));\n  assert.true(array.includes(object));\n  assert.false(array.includes(4));\n  assert.false(array.includes(-0.5));\n  assert.false(array.includes({}));\n  assert.true(Array(1).includes(undefined));\n  assert.true([NaN].includes(NaN));\n\n  if (STRICT) {\n    assert.throws(() => includes.call(null, 0), TypeError);\n    assert.throws(() => includes.call(undefined, 0), TypeError);\n  }\n\n  assert.true('includes' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.includes.js","skipped":false,"dir":"tests"},{"name":"Array#indexOf","suites":[],"line":2,"code":"QUnit.test('Array#indexOf', assert => {\n  const {\n    indexOf\n  } = Array.prototype;\n  assert.isFunction(indexOf);\n  assert.arity(indexOf, 1);\n  assert.name(indexOf, 'indexOf');\n  assert.looksNative(indexOf);\n  assert.nonEnumerable(Array.prototype, 'indexOf');\n  assert.same(0, [1, 1, 1].indexOf(1));\n  assert.same(-1, [1, 2, 3].indexOf(1, 1));\n  assert.same(1, [1, 2, 3].indexOf(2, 1));\n  assert.same(-1, [1, 2, 3].indexOf(2, -1));\n  assert.same(1, [1, 2, 3].indexOf(2, -2));\n  assert.same(-1, [NaN].indexOf(NaN));\n  assert.same(3, Array(2).concat([1, 2, 3]).indexOf(2));\n  assert.same(-1, Array(1).indexOf(undefined));\n  assert.same(0, [1].indexOf(1, -0), \"shouldn't return negative zero\");\n\n  if (STRICT) {\n    assert.throws(() => indexOf.call(null, 0), TypeError);\n    assert.throws(() => indexOf.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.array.index-of.js","skipped":false,"dir":"tests"},{"name":"Array.isArray","suites":[],"line":1,"code":"QUnit.test('Array.isArray', assert => {\n  const {\n    isArray\n  } = Array;\n  assert.isFunction(isArray);\n  assert.arity(isArray, 1);\n  assert.name(isArray, 'isArray');\n  assert.looksNative(isArray);\n  assert.nonEnumerable(Array, 'isArray');\n  assert.false(isArray({}));\n  assert.false(isArray(function () {\n    return arguments;\n  }()));\n  assert.true(isArray([]));\n});","file":"tests/es.array.is-array.js","skipped":false,"dir":"tests"},{"name":"Array#keys","suites":[],"line":3,"code":"QUnit.test('Array#keys', assert => {\n  const {\n    keys\n  } = Array.prototype;\n  assert.isFunction(keys);\n  assert.arity(keys, 0);\n  assert.name(keys, 'keys');\n  assert.looksNative(keys);\n  assert.nonEnumerable(Array.prototype, 'keys');\n  const iterator = ['q', 'w', 'e'].keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.same(String(iterator), '[object Array Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 0,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 2,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* still not fixed even in modern WebKit\n  assert.deepEqual(keys.call({\n    length: -1,\n  }).next(), {\n    value: undefined,\n    done: true,\n  }, 'uses ToLength');\n  */\n\n  assert.true('keys' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#values","suites":[],"line":44,"code":"QUnit.test('Array#values', assert => {\n  const {\n    values\n  } = Array.prototype;\n  assert.isFunction(values);\n  assert.arity(values, 0);\n  assert.name(values, 'values');\n  assert.looksNative(values);\n  assert.nonEnumerable(Array.prototype, 'values');\n  const iterator = ['q', 'w', 'e'].values();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* still not fixed even in modern WebKit\n  assert.deepEqual(values.call({\n    length: -1,\n  }).next(), {\n    value: undefined,\n    done: true,\n  }, 'uses ToLength');\n  */\n\n  assert.true('values' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#entries","suites":[],"line":84,"code":"QUnit.test('Array#entries', assert => {\n  const {\n    entries\n  } = Array.prototype;\n  assert.isFunction(entries);\n  assert.arity(entries, 0);\n  assert.name(entries, 'entries');\n  assert.looksNative(entries);\n  assert.nonEnumerable(Array.prototype, 'entries');\n  const iterator = ['q', 'w', 'e'].entries();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: [0, 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: [1, 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: [2, 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* still not fixed even in modern WebKit\n  assert.deepEqual(entries.call({\n    length: -1,\n  }).next(), {\n    value: undefined,\n    done: true,\n  }, 'uses ToLength');\n  */\n\n  assert.true('entries' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#@@iterator","suites":[],"line":124,"code":"QUnit.test('Array#@@iterator', assert => {\n  assert.isIterable(Array.prototype);\n  assert.arity(Array.prototype[Symbol.iterator], 0);\n  assert.name(Array.prototype[Symbol.iterator], 'values');\n  assert.looksNative(Array.prototype[Symbol.iterator]);\n  assert.nonEnumerable(Array.prototype, Symbol.iterator);\n  assert.same(Array.prototype[Symbol.iterator], Array.prototype.values);\n  const iterator = ['q', 'w', 'e'][Symbol.iterator]();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* still not fixed even in modern WebKit\n  assert.deepEqual(Array.prototype[Symbol.iterator].call({\n    length: -1,\n  }).next(), {\n    value: undefined,\n    done: true,\n  }, 'uses ToLength');\n  */\n});","file":"tests/es.array.iterator.js","skipped":false,"dir":"tests"},{"name":"Array#join","suites":[],"line":2,"code":"QUnit.test('Array#join', assert => {\n  const {\n    join\n  } = Array.prototype;\n  assert.isFunction(join);\n  assert.arity(join, 1);\n  assert.name(join, 'join');\n  assert.looksNative(join);\n  assert.nonEnumerable(Array.prototype, 'join');\n  assert.same(join.call([1, 2, 3], undefined), '1,2,3');\n  assert.same(join.call('123'), '1,2,3');\n  assert.same(join.call('123', '|'), '1|2|3');\n\n  if (STRICT) {\n    assert.throws(() => join.call(null, 0), TypeError);\n    assert.throws(() => join.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.array.join.js","skipped":false,"dir":"tests"},{"name":"Array#lastIndexOf","suites":[],"line":2,"code":"QUnit.test('Array#lastIndexOf', assert => {\n  const {\n    lastIndexOf\n  } = Array.prototype;\n  assert.isFunction(lastIndexOf);\n  assert.arity(lastIndexOf, 1);\n  assert.name(lastIndexOf, 'lastIndexOf');\n  assert.looksNative(lastIndexOf);\n  assert.nonEnumerable(Array.prototype, 'lastIndexOf');\n  assert.same(2, [1, 1, 1].lastIndexOf(1));\n  assert.same(-1, [1, 2, 3].lastIndexOf(3, 1));\n  assert.same(1, [1, 2, 3].lastIndexOf(2, 1));\n  assert.same(-1, [1, 2, 3].lastIndexOf(2, -3));\n  assert.same(-1, [1, 2, 3].lastIndexOf(1, -4));\n  assert.same(1, [1, 2, 3].lastIndexOf(2, -2));\n  assert.same(-1, [NaN].lastIndexOf(NaN));\n  assert.same(1, [1, 2, 3].concat(Array(2)).lastIndexOf(2));\n  assert.same(0, [1].lastIndexOf(1, -0), \"shouldn't return negative zero\");\n\n  if (STRICT) {\n    assert.throws(() => lastIndexOf.call(null, 0), TypeError);\n    assert.throws(() => lastIndexOf.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.array.last-index-of.js","skipped":false,"dir":"tests"},{"name":"Array#map","suites":[],"line":2,"code":"QUnit.test('Array#map', assert => {\n  const {\n    map\n  } = Array.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.name(map, 'map');\n  assert.looksNative(map);\n  assert.nonEnumerable(Array.prototype, 'map');\n  let array = [1];\n  const context = {};\n  array.map(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([2, 3, 4], [1, 2, 3].map(value => value + 1));\n  assert.deepEqual([1, 3, 5], [1, 2, 3].map((value, key) => value + key));\n  assert.deepEqual([2, 2, 2], [1, 2, 3].map(function () {\n    return +this;\n  }, 2));\n\n  if (STRICT) {\n    assert.throws(() => map.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => map.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.map(Boolean).foo, 1, '@@species');\n});","file":"tests/es.array.map.js","skipped":false,"dir":"tests"},{"name":"Array.of","suites":[],"line":2,"code":"QUnit.test('Array.of', assert => {\n  const {\n    defineProperty\n  } = Object;\n  assert.isFunction(Array.of);\n  assert.arity(Array.of, 0);\n  assert.name(Array.of, 'of');\n  assert.looksNative(Array.of);\n  assert.nonEnumerable(Array, 'of');\n  assert.deepEqual(Array.of(1), [1]);\n  assert.deepEqual(Array.of(1, 2, 3), [1, 2, 3]);\n\n  class C {\n    /* empty */\n  }\n\n  const instance = Array.of.call(C, 1, 2);\n  assert.true(instance instanceof C);\n  assert.same(instance[0], 1);\n  assert.same(instance[1], 2);\n  assert.same(instance.length, 2);\n\n  if (DESCRIPTORS) {\n    let called = false;\n    defineProperty(C.prototype, 0, {\n      set() {\n        called = true;\n      }\n\n    });\n    Array.of.call(C, 1, 2, 3);\n    assert.false(called, 'Should not call prototype accessors');\n  }\n});","file":"tests/es.array.of.js","skipped":false,"dir":"tests"},{"name":"Array#reduceRight","suites":[],"line":2,"code":"QUnit.test('Array#reduceRight', assert => {\n  const {\n    reduceRight\n  } = Array.prototype;\n  assert.isFunction(reduceRight);\n  assert.arity(reduceRight, 1);\n  assert.name(reduceRight, 'reduceRight');\n  assert.looksNative(reduceRight);\n  assert.nonEnumerable(Array.prototype, 'reduceRight');\n  const array = [1];\n  const accumulator = {};\n  array.reduceRight(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n  }, accumulator);\n  assert.same([1, 2, 3].reduceRight((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  [1, 2].reduceRight((memo, value, key) => {\n    assert.same(memo, 2, 'correct default accumulator');\n    assert.same(value, 1, 'correct start value without initial accumulator');\n    assert.same(key, 0, 'correct start index without initial accumulator');\n  });\n  assert.same([1, 2, 3].reduceRight((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  [1, 2, 3].reduceRight((memo, value, key) => {\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '321', 'correct order #1');\n  assert.same(keys, '210', 'correct order #2');\n  assert.same(reduceRight.call({\n    0: 1,\n    1: 2,\n    length: 2\n  }, (a, b) => a + b), 3, 'generic');\n\n  if (STRICT) {\n    assert.throws(() => reduceRight.call(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reduceRight.call(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"tests/es.array.reduce-right.js","skipped":false,"dir":"tests"},{"name":"Array#reduce","suites":[],"line":2,"code":"QUnit.test('Array#reduce', assert => {\n  const {\n    reduce\n  } = Array.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.looksNative(reduce);\n  assert.nonEnumerable(Array.prototype, 'reduce');\n  const array = [1];\n  const accumulator = {};\n  array.reduce(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n  }, accumulator);\n  assert.same([1, 2, 3].reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  [1, 2].reduce((memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 1, 'correct start index without initial accumulator');\n  });\n  assert.same([1, 2, 3].reduce((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  [1, 2, 3].reduce((memo, value, key) => {\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '123', 'correct order #1');\n  assert.same(keys, '012', 'correct order #2');\n  assert.same(reduce.call({\n    0: 1,\n    1: 2,\n    length: 2\n  }, (a, b) => a + b), 3, 'generic');\n\n  if (STRICT) {\n    assert.throws(() => reduce.call(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reduce.call(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"tests/es.array.reduce.js","skipped":false,"dir":"tests"},{"name":"Array#reverse","suites":[],"line":2,"code":"QUnit.test('Array#reverse', assert => {\n  const {\n    reverse\n  } = Array.prototype;\n  assert.isFunction(reverse);\n  assert.arity(reverse, 0);\n  assert.name(reverse, 'reverse');\n  assert.looksNative(reverse);\n  assert.nonEnumerable(Array.prototype, 'reverse');\n  const a = [1, 2.2, 3.3];\n\n  function fn() {\n    +a;\n    a.reverse();\n  }\n\n  fn();\n  assert.arrayEqual(a, [3.3, 2.2, 1]);\n\n  if (STRICT) {\n    assert.throws(() => reverse.call(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => reverse.call(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n});","file":"tests/es.array.reverse.js","skipped":false,"dir":"tests"},{"name":"Array#slice","suites":[],"line":2,"code":"QUnit.test('Array#slice', assert => {\n  const {\n    slice\n  } = Array.prototype;\n  const {\n    isArray\n  } = Array;\n  assert.isFunction(slice);\n  assert.arity(slice, 2);\n  assert.name(slice, 'slice');\n  assert.looksNative(slice);\n  assert.nonEnumerable(Array.prototype, 'slice');\n  let array = ['1', '2', '3', '4', '5'];\n  assert.deepEqual(array.slice(), array);\n  assert.deepEqual(array.slice(1, 3), ['2', '3']);\n  assert.deepEqual(array.slice(1, undefined), ['2', '3', '4', '5']);\n  assert.deepEqual(array.slice(1, -1), ['2', '3', '4']);\n  assert.deepEqual(array.slice(-2, -1), ['4']);\n  assert.deepEqual(array.slice(-2, -3), []);\n  const string = '12345';\n  assert.deepEqual(slice.call(string), array);\n  assert.deepEqual(slice.call(string, 1, 3), ['2', '3']);\n  assert.deepEqual(slice.call(string, 1, undefined), ['2', '3', '4', '5']);\n  assert.deepEqual(slice.call(string, 1, -1), ['2', '3', '4']);\n  assert.deepEqual(slice.call(string, -2, -1), ['4']);\n  assert.deepEqual(slice.call(string, -2, -3), []);\n  const list = GLOBAL.document && document.body && document.body.childNodes;\n\n  if (list) {\n    assert.notThrows(() => isArray(slice.call(list)), 'works on NodeList');\n  }\n\n  if (STRICT) {\n    assert.throws(() => slice.call(null), TypeError);\n    assert.throws(() => slice.call(undefined), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.slice().foo, 1, '@@species');\n});","file":"tests/es.array.slice.js","skipped":false,"dir":"tests"},{"name":"Array#some","suites":[],"line":2,"code":"QUnit.test('Array#some', assert => {\n  const {\n    some\n  } = Array.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.looksNative(some);\n  assert.nonEnumerable(Array.prototype, 'some');\n  let array = [1];\n  const context = {};\n  array.some(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true([1, '2', 3].some(value => typeof value == 'number'));\n  assert.true([1, 2, 3].some(value => value < 3));\n  assert.false([1, 2, 3].some(value => value < 0));\n  assert.false([1, 2, 3].some(value => typeof value == 'string'));\n  assert.false([1, 2, 3].some(function () {\n    return +this !== 1;\n  }, 1));\n  let result = '';\n  [1, 2, 3].some((value, key) => {\n    result += key;\n    return false;\n  });\n  assert.same(result, '012');\n  array = [1, 2, 3];\n  assert.false(array.some((value, key, that) => that !== array));\n\n  if (STRICT) {\n    assert.throws(() => some.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => some.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n});","file":"tests/es.array.some.js","skipped":false,"dir":"tests"},{"name":"Array#sort","suites":[],"line":2,"code":"QUnit.test('Array#sort', assert => {\n  const {\n    sort\n  } = Array.prototype;\n  assert.isFunction(sort);\n  assert.arity(sort, 1);\n  assert.name(sort, 'sort');\n  assert.looksNative(sort);\n  assert.nonEnumerable(Array.prototype, 'sort');\n  assert.deepEqual([1, 3, 2].sort(), [1, 2, 3], '#1');\n  assert.deepEqual([1, 3, 2, 11].sort(), [1, 11, 2, 3], '#2');\n  assert.deepEqual([1, -1, 3, NaN, 2, 0, 11, -0].sort(), [-1, 0, -0, 1, 11, 2, 3, NaN], '#1');\n  let array = Array(5);\n  array[0] = 1;\n  array[2] = 3;\n  array[4] = 2;\n  let expected = Array(5);\n  expected[0] = 1;\n  expected[1] = 2;\n  expected[2] = 3;\n  assert.deepEqual(array.sort(), expected, 'holes');\n  array = 'zyxwvutsrqponMLKJIHGFEDCBA'.split('');\n  expected = 'ABCDEFGHIJKLMnopqrstuvwxyz'.split('');\n  assert.deepEqual(array.sort(), expected, 'alpha #1');\n  array = 'ёяюэьыъщшчцхфутсрПОНМЛКЙИЗЖЕДГВБА'.split('');\n  expected = 'АБВГДЕЖЗИЙКЛМНОПрстуфхцчшщъыьэюяё'.split('');\n  assert.deepEqual(array.sort(), expected, 'alpha #2');\n  array = [undefined, 1];\n  assert.notThrows(() => array.sort(() => {\n    throw 1;\n  }), 'undefined #1');\n  assert.deepEqual(array, [1, undefined], 'undefined #2');\n  const object = {\n    valueOf: () => 1,\n    toString: () => -1\n  };\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  expected = {\n    0: -1,\n    1: object,\n    2: 1,\n    3: 2,\n    4: Infinity,\n    5: NaN,\n    6: 'X',\n    7: 'a',\n    8: true,\n    9: undefined,\n    length: 11\n  };\n  assert.deepEqual(sort.call(array), expected, 'custom generic');\n  let index, mod, code, chr, value;\n  expected = Array(516);\n  array = Array(516);\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  array.sort((a, b) => (a / 4 | 0) - (b / 4 | 0));\n  assert.true(1 / [0, -0].sort()[0] > 0, '-0');\n  assert.arrayEqual(array, expected, 'stable #1');\n  let result = '';\n  array = []; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n\n      case 68:\n      case 71:\n        value = 4;\n        break;\n\n      default:\n        value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      array.push({\n        k: chr + index,\n        v: value\n      });\n    }\n  }\n\n  array.sort((a, b) => b.v - a.v);\n\n  for (index = 0; index < array.length; index++) {\n    chr = array[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  assert.same(result, 'DGBEFHACIJK', 'stable #2');\n  assert.notThrows(() => [1, 2, 3].sort(undefined).length === 3, 'works with undefined');\n  assert.throws(() => [1, 2, 3].sort(null), 'throws on null');\n  assert.throws(() => [1, 2, 3].sort({}), 'throws on {}');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => [Symbol(1), Symbol(2)].sort(), 'w/o cmp throws on symbols');\n  }\n\n  if (STRICT) {\n    assert.throws(() => sort.call(null), TypeError, 'ToObject(this)');\n    assert.throws(() => sort.call(undefined), TypeError, 'ToObject(this)');\n  }\n});","file":"tests/es.array.sort.js","skipped":false,"dir":"tests"},{"name":"Array#splice","suites":[],"line":2,"code":"QUnit.test('Array#splice', assert => {\n  const {\n    splice\n  } = Array.prototype;\n  assert.isFunction(splice);\n  assert.arity(splice, 2);\n  assert.name(splice, 'splice');\n  assert.looksNative(splice);\n  assert.nonEnumerable(Array.prototype, 'splice');\n  let array = [1, 2, 3, 4, 5];\n  assert.deepEqual(array.splice(2), [3, 4, 5]);\n  assert.deepEqual(array, [1, 2]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(array.splice(-2), [4, 5]);\n  assert.deepEqual(array, [1, 2, 3]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(array.splice(2, 2), [3, 4]);\n  assert.deepEqual(array, [1, 2, 5]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(array.splice(2, -2), []);\n  assert.deepEqual(array, [1, 2, 3, 4, 5]);\n  array = [1, 2, 3, 4, 5];\n  assert.deepEqual(array.splice(2, 2, 6, 7), [3, 4]);\n  assert.deepEqual(array, [1, 2, 6, 7, 5]); // ES6 semantics\n\n  array = [0, 1, 2];\n  assert.deepEqual(array.splice(0), [0, 1, 2]);\n  array = [0, 1, 2];\n  assert.deepEqual(array.splice(1), [1, 2]);\n  array = [0, 1, 2];\n  assert.deepEqual(array.splice(2), [2]);\n\n  if (STRICT) {\n    assert.throws(() => splice.call(null), TypeError);\n    assert.throws(() => splice.call(undefined), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.splice().foo, 1, '@@species');\n});","file":"tests/es.array.splice.js","skipped":false,"dir":"tests"},{"name":"DataView","suites":[],"line":2,"code":"QUnit.test('DataView', assert => {\n  assert.same(DataView, Object(DataView), 'is object'); // in Safari 5 typeof DataView is 'object'\n\n  if (NATIVE) assert.arity(DataView, 3); // 1 in IE11\n\n  if (NATIVE) assert.name(DataView, 'DataView'); // Safari 5 bug\n\n  if (NATIVE) assert.looksNative(DataView); // Safari 5 bug\n\n  let dataview = new DataView(new ArrayBuffer(8));\n  assert.same(dataview.byteOffset, 0, '#byteOffset, passed buffer');\n  assert.same(dataview.byteLength, 8, '#byteLength, passed buffer');\n  dataview = new DataView(new ArrayBuffer(16), 8);\n  assert.same(dataview.byteOffset, 8, '#byteOffset, passed buffer and byteOffset');\n  assert.same(dataview.byteLength, 8, '#byteLength, passed buffer and byteOffset');\n  dataview = new DataView(new ArrayBuffer(24), 8, 8);\n  assert.same(dataview.byteOffset, 8, '#byteOffset, passed buffer, byteOffset and length');\n  assert.same(dataview.byteLength, 8, '#byteLength, passed buffer, byteOffset and length');\n\n  if (NATIVE) {\n    // fails in IE / MS Edge\n    dataview = new DataView(new ArrayBuffer(8), undefined);\n    assert.same(dataview.byteOffset, 0, '#byteOffset, passed buffer and undefined');\n    assert.same(dataview.byteLength, 8, '#byteLength, passed buffer and undefined'); // fails in IE / MS Edge\n\n    dataview = new DataView(new ArrayBuffer(16), 8, undefined);\n    assert.same(dataview.byteOffset, 8, '#byteOffset, passed buffer, byteOffset and undefined');\n    assert.same(dataview.byteLength, 8, '#byteLength, passed buffer, byteOffset and undefined'); // fails in IE10\n\n    dataview = new DataView(new ArrayBuffer(8), 8);\n    assert.same(dataview.byteOffset, 8, '#byteOffset, passed buffer and byteOffset with buffer length');\n    assert.same(dataview.byteLength, 0, '#byteLength, passed buffer and byteOffset with buffer length'); // TypeError in IE + FF bug - TypeError instead of RangeError\n\n    assert.throws(() => new DataView(new ArrayBuffer(8), -1), RangeError, 'If offset < 0, throw a RangeError exception');\n    assert.throws(() => new DataView(new ArrayBuffer(8), 16), RangeError, 'If newByteLength < 0, throw a RangeError exception');\n    assert.throws(() => new DataView(new ArrayBuffer(24), 8, 24), RangeError, 'If offset+newByteLength > bufferByteLength, throw a RangeError exception'); // Android ~ 4.0\n\n    assert.throws(() => DataView(1), TypeError, 'throws without `new`');\n    assert.throws(() => DataView(1), 'throws without `new`');\n  } else {\n    // FF bug - TypeError instead of RangeError\n    assert.throws(() => new DataView(new ArrayBuffer(8), -1), 'If offset < 0, throw a RangeError exception');\n    assert.throws(() => new DataView(new ArrayBuffer(8), 16), 'If newByteLength < 0, throw a RangeError exception');\n    assert.throws(() => new DataView(new ArrayBuffer(24), 8, 24), 'If offset+newByteLength > bufferByteLength, throw a RangeError exception');\n  }\n\n  dataview = new DataView(new ArrayBuffer(8));\n  dataview.setUint32(0, 0x12345678);\n  assert.same(dataview.getUint32(0), 0x12345678, 'big endian/big endian');\n  dataview.setUint32(0, 0x12345678, true);\n  assert.same(dataview.getUint32(0, true), 0x12345678, 'little endian/little endian');\n  dataview.setUint32(0, 0x12345678, true);\n  assert.same(dataview.getUint32(0), 0x78563412, 'little endian/big endian');\n  dataview.setUint32(0, 0x12345678);\n  assert.same(dataview.getUint32(0, true), 0x78563412, 'big endian/little endian');\n  assert.throws(() => new DataView({}), 'non-ArrayBuffer argument, object');\n  assert.throws(() => new DataView('foo'), 'non-ArrayBuffer argument, string');\n});","file":"tests/es.data-view.js","skipped":false,"dir":"tests"},{"name":"DataView accessors","suites":[],"line":62,"code":"  QUnit.test('DataView accessors', assert => {\n    const uint8array = new Uint8Array(8);\n    const dataview = new DataView(uint8array.buffer);\n    assert.arrayEqual(uint8array, [0, 0, 0, 0, 0, 0, 0, 0]);\n    dataview.setUint8(0, 255);\n    assert.arrayEqual(uint8array, [0xFF, 0, 0, 0, 0, 0, 0, 0]);\n    dataview.setInt8(1, -1);\n    assert.arrayEqual(uint8array, [0xFF, 0xFF, 0, 0, 0, 0, 0, 0]);\n    dataview.setUint16(2, 0x1234);\n    assert.arrayEqual(uint8array, [0xFF, 0xFF, 0x12, 0x34, 0, 0, 0, 0]);\n    dataview.setInt16(4, -1);\n    assert.arrayEqual(uint8array, [0xFF, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0, 0]);\n    dataview.setUint32(1, 0x12345678);\n    assert.arrayEqual(uint8array, [0xFF, 0x12, 0x34, 0x56, 0x78, 0xFF, 0, 0]);\n    dataview.setInt32(4, -2023406815);\n    assert.arrayEqual(uint8array, [0xFF, 0x12, 0x34, 0x56, 0x87, 0x65, 0x43, 0x21]);\n    dataview.setFloat32(2, 1.2e+38);\n    assert.arrayEqual(uint8array, [0xFF, 0x12, 0x7E, 0xB4, 0x8E, 0x52, 0x43, 0x21]);\n    dataview.setFloat64(0, -1.2345678e+301);\n    assert.arrayEqual(uint8array, [0xFE, 0x72, 0x6F, 0x51, 0x5F, 0x61, 0x77, 0xE5]);\n    const data = [0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87];\n\n    for (let i = 0, {\n      length\n    } = data; i < length; ++i) {\n      uint8array[i] = data[i];\n    }\n\n    assert.same(dataview.getUint8(0), 128);\n    assert.same(dataview.getInt8(1), -127);\n    assert.same(dataview.getUint16(2), 33411);\n    assert.same(dataview.getInt16(3), -31868);\n    assert.same(dataview.getUint32(4), 2223343239);\n    assert.same(dataview.getInt32(2), -2105310075);\n    assert.same(dataview.getFloat32(2), -1.932478247535851e-37);\n    assert.same(dataview.getFloat64(0), -3.116851295377095e-306);\n  });","file":"tests/es.data-view.js","skipped":false,"dir":"tests"},{"name":"DataView endian","suites":[],"line":99,"code":"  QUnit.test('DataView endian', assert => {\n    const {\n      buffer\n    } = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);\n    let dataview = new DataView(buffer);\n    assert.same(dataview.byteLength, 8, 'buffer');\n    assert.same(dataview.byteOffset, 0, 'buffer');\n    assert.throws(() => dataview.getUint8(-2));\n    assert.throws(() => dataview.getUint8(8), 'bounds for buffer');\n    assert.throws(() => dataview.setUint8(-2, 0), 'bounds for buffer');\n    assert.throws(() => dataview.setUint8(8, 0), 'bounds for buffer');\n    dataview = new DataView(buffer, 2);\n    assert.same(dataview.byteLength, 6, 'buffer, byteOffset');\n    assert.same(dataview.byteOffset, 2, 'buffer, byteOffset');\n    assert.same(dataview.getUint8(5), 7, 'buffer, byteOffset');\n    assert.throws(() => dataview.getUint8(-2), 'bounds for buffer, byteOffset');\n    assert.throws(() => dataview.getUint8(6), 'bounds for buffer, byteOffset');\n    assert.throws(() => dataview.setUint8(-2, 0), 'bounds for buffer, byteOffset');\n    assert.throws(() => dataview.setUint8(6, 0), 'bounds for buffer, byteOffset');\n    assert.throws(() => new DataView(buffer, -1), 'invalid byteOffset');\n    assert.throws(() => new DataView(buffer, 9), 'invalid byteOffset');\n    dataview = new DataView(buffer, 2, 4);\n    assert.same(dataview.byteLength, 4, 'buffer, byteOffset, length');\n    assert.same(dataview.byteOffset, 2, 'buffer, byteOffset, length');\n    assert.same(dataview.getUint8(3), 5, 'buffer, byteOffset, length');\n    assert.throws(() => dataview.getUint8(-2), 'bounds for buffer, byteOffset, length');\n    assert.throws(() => dataview.getUint8(4), 'bounds for buffer, byteOffset, length');\n    assert.throws(() => dataview.setUint8(-2, 0), 'bounds for buffer, byteOffset, length');\n    assert.throws(() => dataview.setUint8(4, 0), 'bounds for buffer, byteOffset, length');\n    assert.throws(() => new DataView(buffer, 0, 9), 'invalid byteOffset+length');\n    assert.throws(() => new DataView(buffer, 8, 1), 'invalid byteOffset+length');\n    assert.throws(() => new DataView(buffer, 9, -1), 'invalid byteOffset+length');\n  });","file":"tests/es.data-view.js","skipped":false,"dir":"tests"},{"name":"DataView#","suites":[],"line":139,"code":"  QUnit.test(`DataView#${GETTER}`, assert => {\n    assert.isFunction(DataView.prototype[GETTER]);\n    NATIVE && assert.arity(DataView.prototype[GETTER], 1);\n    assert.same(new DataView(new ArrayBuffer(8))[GETTER](0), 0, 'returns element');\n  });","file":"tests/es.data-view.js","skipped":false,"dir":"tests"},{"name":"DataView#","suites":[],"line":144,"code":"  QUnit.test(`DataView#${SETTER}`, assert => {\n    assert.isFunction(DataView.prototype[SETTER]);\n    NATIVE && assert.arity(DataView.prototype[SETTER], 2);\n    assert.same(new DataView(new ArrayBuffer(8))[SETTER](0, 0), undefined, 'void');\n  });","file":"tests/es.data-view.js","skipped":false,"dir":"tests"},{"name":"Date#getYear","suites":[],"line":1,"code":"QUnit.test('Date#getYear', assert => {\n  const {\n    getYear\n  } = Date.prototype;\n  assert.isFunction(getYear);\n  assert.arity(getYear, 0);\n  assert.name(getYear, 'getYear');\n  assert.looksNative(getYear);\n  assert.nonEnumerable(Date.prototype, 'getYear');\n  const date = new Date();\n  assert.same(date.getYear(), date.getFullYear() - 1900);\n});","file":"tests/es.date.get-year.js","skipped":false,"dir":"tests"},{"name":"Date.now","suites":[],"line":1,"code":"QUnit.test('Date.now', assert => {\n  const {\n    now\n  } = Date;\n  assert.isFunction(now);\n  assert.arity(now, 0);\n  assert.name(now, 'now');\n  assert.looksNative(now);\n  assert.nonEnumerable(Date, 'now');\n  assert.epsilon(+new Date(), now(), 10, 'Date.now() ~ +new Date');\n});","file":"tests/es.date.now.js","skipped":false,"dir":"tests"},{"name":"Date#setYear","suites":[],"line":1,"code":"QUnit.test('Date#setYear', assert => {\n  const {\n    setYear\n  } = Date.prototype;\n  assert.isFunction(setYear);\n  assert.arity(setYear, 1);\n  assert.name(setYear, 'setYear');\n  assert.looksNative(setYear);\n  assert.nonEnumerable(Date.prototype, 'setYear');\n  const date = new Date();\n  date.setYear(1);\n  assert.same(date.getFullYear(), 1901);\n});","file":"tests/es.date.set-year.js","skipped":false,"dir":"tests"},{"name":"Date#toGMTString","suites":[],"line":1,"code":"QUnit.test('Date#toGMTString', assert => {\n  const {\n    toGMTString\n  } = Date.prototype;\n  assert.isFunction(toGMTString);\n  assert.arity(toGMTString, 0); // assert.name(toGMTString, 'toUTCString'); // at least old WebKit\n\n  assert.looksNative(toGMTString);\n  assert.nonEnumerable(Date.prototype, 'toGMTString'); // assert.same(toGMTString, Date.prototype.toUTCString); // at least old WebKit\n\n  const date = new Date();\n  assert.same(date.toGMTString(), date.toUTCString());\n});","file":"tests/es.date.to-gmt-string.js","skipped":false,"dir":"tests"},{"name":"Date#toISOString","suites":[],"line":1,"code":"QUnit.test('Date#toISOString', assert => {\n  const {\n    toISOString\n  } = Date.prototype;\n  assert.isFunction(toISOString);\n  assert.arity(toISOString, 0);\n  assert.name(toISOString, 'toISOString');\n  assert.looksNative(toISOString);\n  assert.nonEnumerable(Date.prototype, 'toISOString');\n  assert.same(new Date(0).toISOString(), '1970-01-01T00:00:00.000Z');\n  assert.same(new Date(1e12 + 1).toISOString(), '2001-09-09T01:46:40.001Z');\n  assert.same(new Date(-5e13 - 1).toISOString(), '0385-07-25T07:06:39.999Z');\n  const future = new Date(1e15 + 1).toISOString();\n  const properFuture = future === '+033658-09-27T01:46:40.001Z' || future === '33658-09-27T01:46:40.001Z';\n  assert.true(properFuture);\n  const prehistoric = new Date(-1e15 + 1).toISOString();\n  const properPrehistoric = prehistoric === '-029719-04-05T22:13:20.001Z' || prehistoric === '-29719-04-05T22:13:20.001Z';\n  assert.true(properPrehistoric);\n  assert.throws(() => new Date(NaN).toISOString(), RangeError);\n});","file":"tests/es.date.to-iso-string.js","skipped":false,"dir":"tests"},{"name":"Date#toJSON","suites":[],"line":1,"code":"QUnit.test('Date#toJSON', assert => {\n  const {\n    toJSON\n  } = Date.prototype;\n  assert.isFunction(toJSON);\n  assert.arity(toJSON, 1);\n  assert.name(toJSON, 'toJSON');\n  assert.looksNative(toJSON);\n  assert.nonEnumerable(Date.prototype, 'toJSON');\n  const date = new Date();\n  assert.same(date.toJSON(), date.toISOString(), 'base');\n  assert.same(new Date(NaN).toJSON(), null, 'not finite');\n  assert.same(toJSON.call({\n    toISOString() {\n      return 42;\n    }\n\n  }), 42, 'generic');\n});","file":"tests/es.date.to-json.js","skipped":false,"dir":"tests"},{"name":"Date#@@toPrimitive","suites":[],"line":2,"code":"QUnit.test('Date#@@toPrimitive', assert => {\n  const toPrimitive = Date.prototype[Symbol.toPrimitive];\n  assert.isFunction(toPrimitive);\n  assert.arity(toPrimitive, 1);\n  assert.nonEnumerable(Date.prototype, Symbol.toPrimitive);\n  const date = new Date();\n  assert.same(date[Symbol.toPrimitive]('string'), date.toString(), 'generic, hint \"string\"');\n  assert.same(date[Symbol.toPrimitive]('number'), +date, 'generic, hint \"number\"');\n  assert.same(date[Symbol.toPrimitive]('default'), date.toString(), 'generic, hint \"default\"');\n  assert.same(toPrimitive.call(Object(2), 'string'), '2', 'generic, hint \"string\"');\n  assert.same(toPrimitive.call(Object(2), 'number'), 2, 'generic, hint \"number\"');\n  assert.same(toPrimitive.call(Object(2), 'default'), '2', 'generic, hint \"default\"');\n  let data = [undefined, '', 'foo', {\n    toString() {\n      return 'string';\n    }\n\n  }];\n\n  for (const value of data) {\n    assert.throws(() => new Date()[Symbol.toPrimitive](value), TypeError, `throws on ${value} as a hint`);\n  }\n\n  if (STRICT) {\n    data = [1, false, 'string', null, undefined];\n\n    for (const value of data) {\n      assert.throws(() => toPrimitive.call(value, 'string'), TypeError, `throws on ${value} as \\`this\\``);\n    }\n  }\n});","file":"tests/es.date.to-primitive.js","skipped":false,"dir":"tests"},{"name":"Date#toString","suites":[],"line":1,"code":"QUnit.test('Date#toString', assert => {\n  const {\n    toString\n  } = Date.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  assert.looksNative(toString);\n  assert.nonEnumerable(Date.prototype, 'toString');\n  assert.same(String(new Date(NaN)), 'Invalid Date');\n});","file":"tests/es.date.to-string.js","skipped":false,"dir":"tests"},{"name":" constructor with 'cause' param","suites":[],"line":7,"code":"  QUnit.test(`${ERROR_NAME} constructor with 'cause' param`, assert => {\n    assert.isFunction($Error);\n    assert.arity($Error, 1);\n    assert.name($Error, ERROR_NAME);\n    assert.looksNative($Error);\n\n    if (PROTO && $Error !== Error) {\n      // eslint-disable-next-line no-prototype-builtins -- safe\n      assert.true(Error.isPrototypeOf($Error), 'constructor has `Error` in the prototype chain');\n    }\n\n    assert.same($Error.prototype.constructor, $Error, 'prototype constructor'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n    assert.false($Error.prototype.hasOwnProperty('cause'), 'prototype hasn`t cause');\n    assert.true($Error(1) instanceof $Error, 'no cause, without new');\n    assert.true(new $Error(1) instanceof $Error, 'no cause, with new');\n    assert.true($Error(1, {}) instanceof $Error, 'with options, without new');\n    assert.true(new $Error(1, {}) instanceof $Error, 'with options, with new');\n    assert.true($Error(1, 'foo') instanceof $Error, 'non-object options, without new');\n    assert.true(new $Error(1, 'foo') instanceof $Error, 'non-object options, with new');\n    assert.same($Error(1, {\n      cause: 7\n    }).cause, 7, 'cause, without new');\n    assert.same(new $Error(1, {\n      cause: 7\n    }).cause, 7, 'cause, with new');\n    assert.same($Error(1, create({\n      cause: 7\n    })).cause, 7, 'prototype cause, without new');\n    assert.same(new $Error(1, create({\n      cause: 7\n    })).cause, 7, 'prototype cause, with new');\n    let error = $Error(1, {\n      cause: 7\n    });\n    assert.same(error.name, ERROR_NAME, 'instance name');\n    assert.same(error.message, '1', 'instance message');\n    assert.same(error.cause, 7, 'instance cause'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n    assert.true(error.hasOwnProperty('cause'), 'cause is own');\n    error = $Error();\n    assert.same(error.message, '', 'default instance message');\n    assert.same(error.cause, undefined, 'default instance cause undefined'); // eslint-disable-next-line no-prototype-builtins -- safe\n\n    assert.false(error.hasOwnProperty('cause'), 'default instance cause missed');\n  });","file":"tests/es.error.cause.js","skipped":false,"dir":"tests"},{"name":"Error#toString","suites":[],"line":2,"code":"QUnit.test('Error#toString', assert => {\n  const {\n    toString\n  } = Error.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  assert.looksNative(toString);\n  assert.nonEnumerable(Error.prototype, 'toString');\n  assert.same(String(new Error('something')), 'Error: something');\n  assert.same(String(new TypeError('something')), 'TypeError: something');\n  assert.same(String(new Error()), 'Error');\n  assert.same(toString.call({}), 'Error');\n  assert.same(toString.call({\n    name: 'foo'\n  }), 'foo');\n  assert.same(toString.call({\n    message: 'bar'\n  }), 'Error: bar');\n  assert.same(toString.call({\n    name: '',\n    message: 'bar'\n  }), 'bar');\n  assert.same(toString.call({\n    name: 'foo',\n    message: 'bar'\n  }), 'foo: bar');\n  assert.same(toString.call({\n    name: 1,\n    message: 2\n  }), '1: 2');\n\n  if (STRICT) {\n    assert.throws(() => toString.call(7));\n    assert.throws(() => toString.call('a'));\n    assert.throws(() => toString.call(false));\n    assert.throws(() => toString.call(null));\n    assert.throws(() => toString.call(undefined));\n  } // assert.throws(() => toString.call({ name: Symbol() }), 'throws on symbol #1');\n  // assert.throws(() => toString.call({ name: Symbol() }), 'throws on symbol #2');\n\n});","file":"tests/es.error.to-string.js","skipped":false,"dir":"tests"},{"name":"escape","suites":[],"line":1,"code":"QUnit.test('escape', assert => {\n  assert.isFunction(escape);\n  assert.name(escape, 'escape');\n  assert.arity(escape, 1);\n  assert.looksNative(escape);\n  assert.same(escape('!q2ф'), '%21q2%u0444');\n  assert.same(escape(null), 'null');\n  assert.same(escape(undefined), 'undefined');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => unescape(Symbol()), 'throws on symbol argument');\n  }\n});","file":"tests/es.escape.js","skipped":false,"dir":"tests"},{"name":"Function#bind","suites":[],"line":1,"code":"QUnit.test('Function#bind', assert => {\n  const {\n    bind\n  } = Function.prototype;\n  assert.isFunction(bind);\n  assert.arity(bind, 1);\n  assert.name(bind, 'bind');\n  assert.looksNative(bind);\n  assert.nonEnumerable(Function.prototype, 'bind');\n  assert.same(function () {\n    return this.a;\n  }.bind({\n    a: 42\n  })(), 42);\n  assert.same(new function () {\n    /* empty */\n  }().a, undefined);\n\n  function A(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  const instance = new (A.bind(null, 1))(2);\n  assert.true(instance instanceof A);\n  assert.same(instance.a, 1);\n  assert.same(instance.b, 2);\n  assert.same((it => it).bind(null, 42)(), 42);\n  const regExpTest = RegExp.prototype.test.bind(/a/);\n  assert.true(regExpTest('a'));\n  const Date2017 = Date.bind(null, 2017);\n  const date = new Date2017(11);\n  assert.true(date instanceof Date);\n  assert.same(date.getFullYear(), 2017);\n  assert.same(date.getMonth(), 11);\n});","file":"tests/es.function.bind.js","skipped":false,"dir":"tests"},{"name":"Function#@@hasInstance","suites":[],"line":1,"code":"QUnit.test('Function#@@hasInstance', assert => {\n  assert.true(Symbol.hasInstance in Function.prototype);\n  assert.nonEnumerable(Function.prototype, Symbol.hasInstance);\n  assert.true(Function[Symbol.hasInstance](() => {\n    /* empty */\n  }));\n  assert.false(Function[Symbol.hasInstance]({}));\n});","file":"tests/es.function.has-instance.js","skipped":false,"dir":"tests"},{"name":"Function#name","suites":[],"line":4,"code":"  QUnit.test('Function#name', assert => {\n    assert.true('name' in Function.prototype);\n    assert.nonEnumerable(Function.prototype, 'name');\n\n    function foo() {\n      /* empty */\n    }\n\n    assert.same(foo.name, 'foo');\n    assert.same(function () {\n      /* empty */\n    }.name, '');\n\n    if (Object.freeze) {\n      assert.same(Object.freeze(() => {\n        /* empty */\n      }).name, '');\n    }\n\n    function bar() {\n      /* empty */\n    }\n\n    bar.toString = function () {\n      throw new Error();\n    };\n\n    assert.notThrows(() => bar.name === 'bar', 'works with redefined `.toString`');\n    const baz = Object(() => {\n      /* empty */\n    });\n\n    baz.toString = function () {\n      return '';\n    };\n\n    assert.same(baz.name, '');\n    assert.same(function\n      /*\n      multi-line comment */\n    () {\n      /* empty */\n    }.name, '');\n\n    function\n    /*\n    multi-line comment */\n    foobar() {\n      /* empty */\n    }\n\n    assert.same(foobar.name, 'foobar');\n\n    function // simple-line comment\n    foobaz() {\n      /* empty */\n    }\n\n    assert.same(foobaz.name, 'foobaz');\n\n    function // simple-line comment\n\n    /* multi-line comment */\n    quux\n    /*\n    multi-line comment\n    */\n    () {\n      /* empty */\n    }\n\n    assert.same(quux.name, 'quux');\n  });","file":"tests/es.function.name.js","skipped":false,"dir":"tests"},{"name":"globalThis","suites":[],"line":1,"code":"QUnit.test('globalThis', assert => {\n  assert.same(globalThis, Object(globalThis), 'is object');\n  assert.same(globalThis.Math, Math, 'contains globals');\n});","file":"tests/es.global-this.js","skipped":false,"dir":"tests"},{"name":"Symbols & JSON.stringify","suites":[],"line":4,"code":"  QUnit.test('Symbols & JSON.stringify', assert => {\n    assert.same(JSON.stringify([1, Symbol('foo'), false, Symbol('bar'), {}]), '[1,null,false,null,{}]', 'array value');\n    assert.same(JSON.stringify({\n      symbol: Symbol('symbol')\n    }), '{}', 'object value');\n\n    if (DESCRIPTORS) {\n      const object = {\n        bar: 2\n      };\n      object[Symbol('symbol')] = 1;\n      assert.same(JSON.stringify(object), '{\"bar\":2}', 'object key');\n    }\n\n    assert.same(JSON.stringify(Symbol('symbol')), undefined, 'symbol value');\n\n    if (typeof Symbol() == 'symbol') {\n      assert.same(JSON.stringify(Object(Symbol('symbol'))), '{}', 'boxed symbol');\n    }\n\n    assert.same(JSON.stringify(undefined, () => 42), '42', 'replacer works with top-level undefined');\n  });","file":"tests/es.json.stringify.js","skipped":false,"dir":"tests"},{"name":"Well‑formed JSON.stringify","suites":[],"line":26,"code":"  QUnit.test('Well‑formed JSON.stringify', assert => {\n    const {\n      stringify\n    } = JSON;\n    assert.isFunction(stringify);\n    assert.arity(stringify, 3);\n    assert.name(stringify, 'stringify');\n    assert.looksNative(stringify);\n    assert.same(stringify({\n      foo: 'bar'\n    }), '{\"foo\":\"bar\"}', 'basic');\n    assert.same(stringify('\\uDEAD'), '\"\\\\udead\"', 'r1');\n    assert.same(stringify('\\uDF06\\uD834'), '\"\\\\udf06\\\\ud834\"', 'r2');\n    assert.same(stringify('\\uDF06ab\\uD834'), '\"\\\\udf06ab\\\\ud834\"', 'r3');\n    assert.same(stringify('𠮷'), '\"𠮷\"', 'r4');\n    assert.same(stringify('\\uD834\\uDF06'), '\"𝌆\"', 'r5');\n    assert.same(stringify('\\uD834\\uD834\\uDF06'), '\"\\\\ud834𝌆\"', 'r6');\n    assert.same(stringify('\\uD834\\uDF06\\uDF06'), '\"𝌆\\\\udf06\"', 'r7');\n    assert.same(stringify({\n      '𠮷': ['\\uDF06\\uD834']\n    }), '{\"𠮷\":[\"\\\\udf06\\\\ud834\"]}', 'r8');\n  });","file":"tests/es.json.stringify.js","skipped":false,"dir":"tests"},{"name":"Map","suites":[],"line":15,"code":"QUnit.test('Map', assert => {\n  assert.isFunction(Map);\n  assert.arity(Map, 0);\n  assert.name(Map, 'Map');\n  assert.looksNative(Map);\n  assert.true('clear' in Map.prototype, 'clear in Map.prototype');\n  assert.true('delete' in Map.prototype, 'delete in Map.prototype');\n  assert.true('forEach' in Map.prototype, 'forEach in Map.prototype');\n  assert.true('get' in Map.prototype, 'get in Map.prototype');\n  assert.true('has' in Map.prototype, 'has in Map.prototype');\n  assert.true('set' in Map.prototype, 'set in Map.prototype');\n  assert.true(new Map() instanceof Map, 'new Map instanceof Map');\n  assert.same(new Map(createIterable([[1, 1], [2, 2], [3, 3]])).size, 3, 'Init from iterable');\n  assert.same(new Map([[freeze({}), 1], [2, 3]]).size, 2, 'Support frozen objects');\n  let done = false;\n\n  try {\n    new Map(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  new Map(array);\n  assert.true(done);\n  const object = {};\n  new Map().set(object, 1);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(Map);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof Map, 'correct subclassing with native classes #2');\n    assert.same(new Subclass().set(1, 2).get(1), 2, 'correct subclassing with native classes #3');\n  }\n\n  const buffer = new ArrayBuffer(8);\n  const map = new Map([[buffer, 8]]);\n  assert.true(map.has(buffer), 'works with ArrayBuffer keys');\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#clear","suites":[],"line":81,"code":"QUnit.test('Map#clear', assert => {\n  assert.isFunction(Map.prototype.clear);\n  assert.arity(Map.prototype.clear, 0);\n  assert.name(Map.prototype.clear, 'clear');\n  assert.looksNative(Map.prototype.clear);\n  assert.nonEnumerable(Map.prototype, 'clear');\n  let map = new Map();\n  map.clear();\n  assert.same(map.size, 0);\n  map = new Map();\n  map.set(1, 2);\n  map.set(2, 3);\n  map.set(1, 4);\n  map.clear();\n  assert.same(map.size, 0);\n  assert.false(map.has(1));\n  assert.false(map.has(2));\n  const frozen = freeze({});\n  map = new Map();\n  map.set(1, 2);\n  map.set(frozen, 3);\n  map.clear();\n  assert.same(map.size, 0, 'Support frozen objects');\n  assert.false(map.has(1));\n  assert.false(map.has(frozen));\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#delete","suites":[],"line":107,"code":"QUnit.test('Map#delete', assert => {\n  assert.isFunction(Map.prototype.delete);\n  assert.arity(Map.prototype.delete, 1);\n  if (NATIVE) assert.name(Map.prototype.delete, 'delete');\n  assert.looksNative(Map.prototype.delete);\n  assert.nonEnumerable(Map.prototype, 'delete');\n  const object = {};\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 7);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, 9);\n  assert.same(map.size, 5);\n  assert.true(map.delete(NaN));\n  assert.same(map.size, 4);\n  assert.false(map.delete(4));\n  assert.same(map.size, 4);\n  map.delete([]);\n  assert.same(map.size, 4);\n  map.delete(object);\n  assert.same(map.size, 3);\n  const frozen = freeze({});\n  map.set(frozen, 42);\n  assert.same(map.size, 4);\n  map.delete(frozen);\n  assert.same(map.size, 3);\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#forEach","suites":[],"line":136,"code":"QUnit.test('Map#forEach', assert => {\n  assert.isFunction(Map.prototype.forEach);\n  assert.arity(Map.prototype.forEach, 1);\n  assert.name(Map.prototype.forEach, 'forEach');\n  assert.looksNative(Map.prototype.forEach);\n  assert.nonEnumerable(Map.prototype, 'forEach');\n  let result = {};\n  let count = 0;\n  const object = {};\n  let map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 7);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, 9);\n  map.forEach((value, key) => {\n    count++;\n    result[value] = key;\n  });\n  assert.same(count, 5);\n  assert.deepEqual(result, {\n    1: NaN,\n    7: 3,\n    5: 2,\n    4: 1,\n    9: object\n  });\n  map = new Map();\n  map.set('0', 9);\n  map.set('1', 9);\n  map.set('2', 9);\n  map.set('3', 9);\n  result = '';\n  map.forEach((value, key) => {\n    result += key;\n\n    if (key === '2') {\n      map.delete('2');\n      map.delete('3');\n      map.delete('1');\n      map.set('4', 9);\n    }\n  });\n  assert.same(result, '0124');\n  map = new Map([['0', 1]]);\n  result = '';\n  map.forEach(it => {\n    map.delete('0');\n    if (result !== '') throw new Error();\n    result += it;\n  });\n  assert.same(result, '1');\n  assert.throws(() => {\n    Map.prototype.forEach.call(new Set(), () => {\n      /* empty */\n    });\n  }, 'non-generic');\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#get","suites":[],"line":195,"code":"QUnit.test('Map#get', assert => {\n  assert.isFunction(Map.prototype.get);\n  assert.name(Map.prototype.get, 'get');\n  assert.arity(Map.prototype.get, 1);\n  assert.looksNative(Map.prototype.get);\n  assert.nonEnumerable(Map.prototype, 'get');\n  const object = {};\n  const frozen = freeze({});\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(frozen, 42);\n  map.set(object, object);\n  assert.same(map.get(NaN), 1);\n  assert.same(map.get(4), undefined);\n  assert.same(map.get({}), undefined);\n  assert.same(map.get(object), object);\n  assert.same(map.get(frozen), 42);\n  assert.same(map.get(2), 5);\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#has","suites":[],"line":218,"code":"QUnit.test('Map#has', assert => {\n  assert.isFunction(Map.prototype.has);\n  assert.name(Map.prototype.has, 'has');\n  assert.arity(Map.prototype.has, 1);\n  assert.looksNative(Map.prototype.has);\n  assert.nonEnumerable(Map.prototype, 'has');\n  const object = {};\n  const frozen = freeze({});\n  const map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(frozen, 42);\n  map.set(object, object);\n  assert.true(map.has(NaN));\n  assert.true(map.has(object));\n  assert.true(map.has(2));\n  assert.true(map.has(frozen));\n  assert.false(map.has(4));\n  assert.false(map.has({}));\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#set","suites":[],"line":241,"code":"QUnit.test('Map#set', assert => {\n  assert.isFunction(Map.prototype.set);\n  assert.name(Map.prototype.set, 'set');\n  assert.arity(Map.prototype.set, 2);\n  assert.looksNative(Map.prototype.set);\n  assert.nonEnumerable(Map.prototype, 'set');\n  const object = {};\n  let map = new Map();\n  map.set(NaN, 1);\n  map.set(2, 1);\n  map.set(3, 1);\n  map.set(2, 5);\n  map.set(1, 4);\n  map.set(object, object);\n  assert.same(map.size, 5);\n  const chain = map.set(7, 2);\n  assert.same(chain, map);\n  map.set(7, 2);\n  assert.same(map.size, 6);\n  assert.same(map.get(7), 2);\n  assert.same(map.get(NaN), 1);\n  map.set(NaN, 42);\n  assert.same(map.size, 6);\n  assert.same(map.get(NaN), 42);\n  map.set({}, 11);\n  assert.same(map.size, 7);\n  assert.same(map.get(object), object);\n  map.set(object, 27);\n  assert.same(map.size, 7);\n  assert.same(map.get(object), 27);\n  map = new Map();\n  map.set(NaN, 2);\n  map.set(NaN, 3);\n  map.set(NaN, 4);\n  assert.same(map.size, 1);\n  const frozen = freeze({});\n  map = new Map().set(frozen, 42);\n  assert.same(map.get(frozen), 42);\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#size","suites":[],"line":280,"code":"QUnit.test('Map#size', assert => {\n  assert.nonEnumerable(Map.prototype, 'size');\n  const map = new Map();\n  map.set(2, 1);\n  const {\n    size\n  } = map;\n  assert.same(typeof size, 'number', 'size is number');\n  assert.same(size, 1, 'size is correct');\n\n  if (DESCRIPTORS) {\n    const sizeDescriptor = getOwnPropertyDescriptor(Map.prototype, 'size');\n    const getter = sizeDescriptor && sizeDescriptor.get;\n    const setter = sizeDescriptor && sizeDescriptor.set;\n    assert.same(typeof getter, 'function', 'size is getter');\n    assert.same(typeof setter, 'undefined', 'size isnt setter');\n    assert.throws(() => Map.prototype.size, TypeError);\n  }\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map & -0","suites":[],"line":299,"code":"QUnit.test('Map & -0', assert => {\n  let map = new Map();\n  map.set(-0, 1);\n  assert.same(map.size, 1);\n  assert.true(map.has(0));\n  assert.true(map.has(-0));\n  assert.same(map.get(0), 1);\n  assert.same(map.get(-0), 1);\n  map.forEach((val, key) => {\n    assert.false(is(key, -0));\n  });\n  map.delete(-0);\n  assert.same(map.size, 0);\n  map = new Map([[-0, 1]]);\n  map.forEach((val, key) => {\n    assert.false(is(key, -0));\n  });\n  map = new Map();\n  map.set(4, 4);\n  map.set(3, 3);\n  map.set(2, 2);\n  map.set(1, 1);\n  map.set(0, 0);\n  assert.true(map.has(-0));\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#@@toStringTag","suites":[],"line":324,"code":"QUnit.test('Map#@@toStringTag', assert => {\n  assert.same(Map.prototype[Symbol.toStringTag], 'Map', 'Map::@@toStringTag is `Map`');\n  assert.same(String(new Map()), '[object Map]', 'correct stringification');\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map Iterator","suites":[],"line":328,"code":"QUnit.test('Map Iterator', assert => {\n  const map = new Map();\n  map.set('a', 1);\n  map.set('b', 2);\n  map.set('c', 3);\n  map.set('d', 4);\n  const results = [];\n  const iterator = map.keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.nonEnumerable(iterator, 'next');\n  assert.nonEnumerable(iterator, Symbol.iterator);\n  results.push(iterator.next().value);\n  assert.true(map.delete('a'));\n  assert.true(map.delete('b'));\n  assert.true(map.delete('c'));\n  map.set('e');\n  results.push(iterator.next().value, iterator.next().value);\n  assert.true(iterator.next().done);\n  map.set('f');\n  assert.true(iterator.next().done);\n  assert.deepEqual(results, ['a', 'd', 'e']);\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#keys","suites":[],"line":351,"code":"QUnit.test('Map#keys', assert => {\n  assert.isFunction(Map.prototype.keys);\n  assert.name(Map.prototype.keys, 'keys');\n  assert.arity(Map.prototype.keys, 0);\n  assert.looksNative(Map.prototype.keys);\n  assert.nonEnumerable(Map.prototype, 'keys');\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'a',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 's',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'd',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#values","suites":[],"line":382,"code":"QUnit.test('Map#values', assert => {\n  assert.isFunction(Map.prototype.values);\n  assert.name(Map.prototype.values, 'values');\n  assert.arity(Map.prototype.values, 0);\n  assert.looksNative(Map.prototype.values);\n  assert.nonEnumerable(Map.prototype, 'values');\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.values();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#entries","suites":[],"line":413,"code":"QUnit.test('Map#entries', assert => {\n  assert.isFunction(Map.prototype.entries);\n  assert.name(Map.prototype.entries, 'entries');\n  assert.arity(Map.prototype.entries, 0);\n  assert.looksNative(Map.prototype.entries);\n  assert.nonEnumerable(Map.prototype, 'entries');\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map.entries();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['a', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['s', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['d', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Map#@@iterator","suites":[],"line":444,"code":"QUnit.test('Map#@@iterator', assert => {\n  assert.isIterable(Map.prototype);\n  assert.name(Map.prototype.entries, 'entries');\n  assert.arity(Map.prototype.entries, 0);\n  assert.looksNative(Map.prototype[Symbol.iterator]);\n  assert.same(Map.prototype[Symbol.iterator], Map.prototype.entries);\n  const map = new Map();\n  map.set('a', 'q');\n  map.set('s', 'w');\n  map.set('d', 'e');\n  const iterator = map[Symbol.iterator]();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Map Iterator');\n  assert.same(String(iterator), '[object Map Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: ['a', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['s', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['d', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.map.js","skipped":false,"dir":"tests"},{"name":"Math.acosh","suites":[],"line":1,"code":"QUnit.test('Math.acosh', assert => {\n  const {\n    acosh\n  } = Math;\n  assert.isFunction(acosh);\n  assert.name(acosh, 'acosh');\n  assert.arity(acosh, 1);\n  assert.looksNative(acosh);\n  assert.nonEnumerable(Math, 'acosh');\n  assert.same(acosh(NaN), NaN);\n  assert.same(acosh(0.5), NaN);\n  assert.same(acosh(-1), NaN);\n  assert.same(acosh(-1e300), NaN);\n  assert.same(acosh(1), 0);\n  assert.same(acosh(Infinity), Infinity);\n  assert.epsilon(acosh(1234), 7.811163220849231);\n  assert.epsilon(acosh(8.88), 2.8737631531629235);\n  assert.epsilon(acosh(1e+160), 369.10676205960726);\n  assert.epsilon(acosh(Number.MAX_VALUE), 710.475860073944);\n  assert.epsilon(acosh(1 + Number.EPSILON), 2.1073424255447017e-8);\n});","file":"tests/es.math.acosh.js","skipped":false,"dir":"tests"},{"name":"Math.asinh","suites":[],"line":1,"code":"QUnit.test('Math.asinh', assert => {\n  const {\n    asinh\n  } = Math;\n  assert.isFunction(asinh);\n  assert.name(asinh, 'asinh');\n  assert.arity(asinh, 1);\n  assert.looksNative(asinh);\n  assert.nonEnumerable(Math, 'asinh');\n  assert.same(asinh(NaN), NaN);\n  assert.same(asinh(0), 0);\n  assert.same(asinh(-0), -0);\n  assert.same(asinh(Infinity), Infinity);\n  assert.same(asinh(-Infinity), -Infinity);\n  assert.epsilon(asinh(1234), 7.811163549201245);\n  assert.epsilon(asinh(9.99), 2.997227420191335);\n  assert.epsilon(asinh(1e150), 346.0809111296668);\n  assert.epsilon(asinh(1e7), 16.811242831518268);\n  assert.epsilon(asinh(-1e7), -16.811242831518268);\n});","file":"tests/es.math.asinh.js","skipped":false,"dir":"tests"},{"name":"Math.atanh","suites":[],"line":1,"code":"QUnit.test('Math.atanh', assert => {\n  const {\n    atanh\n  } = Math;\n  assert.isFunction(atanh);\n  assert.name(atanh, 'atanh');\n  assert.arity(atanh, 1);\n  assert.looksNative(atanh);\n  assert.nonEnumerable(Math, 'atanh');\n  assert.same(atanh(NaN), NaN);\n  assert.same(atanh(-2), NaN);\n  assert.same(atanh(-1.5), NaN);\n  assert.same(atanh(2), NaN);\n  assert.same(atanh(1.5), NaN);\n  assert.same(atanh(-1), -Infinity);\n  assert.same(atanh(1), Infinity);\n  assert.same(atanh(0), 0);\n  assert.same(atanh(-0), -0);\n  assert.same(atanh(-1e300), NaN);\n  assert.same(atanh(1e300), NaN);\n  assert.epsilon(atanh(0.5), 0.5493061443340549);\n  assert.epsilon(atanh(-0.5), -0.5493061443340549);\n  assert.epsilon(atanh(0.444), 0.47720201260109457);\n});","file":"tests/es.math.atanh.js","skipped":false,"dir":"tests"},{"name":"Math.cbrt","suites":[],"line":1,"code":"QUnit.test('Math.cbrt', assert => {\n  const {\n    cbrt\n  } = Math;\n  assert.isFunction(cbrt);\n  assert.name(cbrt, 'cbrt');\n  assert.arity(cbrt, 1);\n  assert.looksNative(cbrt);\n  assert.nonEnumerable(Math, 'cbrt');\n  assert.same(cbrt(NaN), NaN);\n  assert.same(cbrt(0), 0);\n  assert.same(cbrt(-0), -0);\n  assert.same(cbrt(Infinity), Infinity);\n  assert.same(cbrt(-Infinity), -Infinity);\n  assert.same(cbrt(-8), -2);\n  assert.same(cbrt(8), 2);\n  assert.epsilon(cbrt(-1000), -10);\n  assert.epsilon(cbrt(1000), 10);\n});","file":"tests/es.math.cbrt.js","skipped":false,"dir":"tests"},{"name":"Math.clz32","suites":[],"line":1,"code":"QUnit.test('Math.clz32', assert => {\n  const {\n    clz32\n  } = Math;\n  assert.isFunction(clz32);\n  assert.name(clz32, 'clz32');\n  assert.arity(clz32, 1);\n  assert.looksNative(clz32);\n  assert.nonEnumerable(Math, 'clz32');\n  assert.same(clz32(0), 32);\n  assert.same(clz32(1), 31);\n  assert.same(clz32(-1), 0);\n  assert.same(clz32(0.6), 32);\n  assert.same(clz32(2 ** 32 - 1), 0);\n  assert.same(clz32(2 ** 32), 32);\n});","file":"tests/es.math.clz32.js","skipped":false,"dir":"tests"},{"name":"Math.cosh","suites":[],"line":1,"code":"QUnit.test('Math.cosh', assert => {\n  const {\n    cosh\n  } = Math;\n  assert.isFunction(cosh);\n  assert.name(cosh, 'cosh');\n  assert.arity(cosh, 1);\n  assert.looksNative(cosh);\n  assert.nonEnumerable(Math, 'cosh');\n  assert.same(cosh(NaN), NaN);\n  assert.same(cosh(0), 1);\n  assert.same(cosh(-0), 1);\n  assert.same(cosh(Infinity), Infinity);\n  assert.same(cosh(-Infinity), Infinity);\n  assert.epsilon(cosh(12), 81377.395712574, 1e-9);\n  assert.epsilon(cosh(22), 1792456423.065795780980053377, 1e-5);\n  assert.epsilon(cosh(-10), 11013.23292010332313972137);\n  assert.epsilon(cosh(-23), 4872401723.1244513000, 1e-5);\n  assert.epsilon(cosh(710), 1.1169973830808557e+308, 1e+295);\n});","file":"tests/es.math.cosh.js","skipped":false,"dir":"tests"},{"name":"Math.expm1","suites":[],"line":1,"code":"QUnit.test('Math.expm1', assert => {\n  const {\n    expm1\n  } = Math;\n  assert.isFunction(expm1);\n  assert.name(expm1, 'expm1');\n  assert.arity(expm1, 1);\n  assert.looksNative(expm1);\n  assert.nonEnumerable(Math, 'expm1');\n  assert.same(expm1(NaN), NaN);\n  assert.same(expm1(0), 0);\n  assert.same(expm1(-0), -0);\n  assert.same(expm1(Infinity), Infinity);\n  assert.same(expm1(-Infinity), -1);\n  assert.epsilon(expm1(10), 22025.465794806718);\n  assert.epsilon(expm1(-10), -0.9999546000702375);\n});","file":"tests/es.math.expm1.js","skipped":false,"dir":"tests"},{"name":"Math.fround","suites":[],"line":1,"code":"QUnit.test('Math.fround', assert => {\n  const {\n    fround\n  } = Math;\n  assert.isFunction(fround);\n  assert.name(fround, 'fround');\n  assert.arity(fround, 1);\n  assert.looksNative(fround);\n  assert.nonEnumerable(Math, 'fround');\n  assert.same(fround(undefined), NaN);\n  assert.same(fround(NaN), NaN);\n  assert.same(fround(0), 0);\n  assert.same(fround(-0), -0);\n  assert.same(fround(Number.MIN_VALUE), 0);\n  assert.same(fround(-Number.MIN_VALUE), -0);\n  assert.same(fround(Infinity), Infinity);\n  assert.same(fround(-Infinity), -Infinity);\n  assert.same(fround(1.7976931348623157e+308), Infinity);\n  assert.same(fround(-1.7976931348623157e+308), -Infinity);\n  assert.same(fround(3.4028235677973366e+38), Infinity);\n  assert.same(fround(3), 3);\n  assert.same(fround(-3), -3);\n  const maxFloat32 = 3.4028234663852886e+38;\n  const minFloat32 = 1.401298464324817e-45;\n  assert.same(fround(maxFloat32), maxFloat32);\n  assert.same(fround(-maxFloat32), -maxFloat32);\n  assert.same(fround(maxFloat32 + 2 ** 102), maxFloat32);\n  assert.same(fround(minFloat32), minFloat32);\n  assert.same(fround(-minFloat32), -minFloat32);\n  assert.same(fround(minFloat32 / 2), 0);\n  assert.same(fround(-minFloat32 / 2), -0);\n  assert.same(fround(minFloat32 / 2 + 2 ** -202), minFloat32);\n  assert.same(fround(-minFloat32 / 2 - 2 ** -202), -minFloat32);\n  const maxSubnormal32 = 1.1754942106924411e-38;\n  const minNormal32 = 1.1754943508222875e-38;\n  assert.same(fround(1.1754942807573642e-38), maxSubnormal32, 'fround(1.1754942807573642e-38)');\n  assert.same(fround(1.1754942807573643e-38), minNormal32, 'fround(1.1754942807573643e-38)');\n  assert.same(fround(1.1754942807573644e-38), minNormal32, 'fround(1.1754942807573644e-38)');\n  assert.same(fround(-1.1754942807573642e-38), -maxSubnormal32, 'fround(-1.1754942807573642e-38)');\n  assert.same(fround(-1.1754942807573643e-38), -minNormal32, 'fround(-1.1754942807573643e-38)');\n  assert.same(fround(-1.1754942807573644e-38), -minNormal32, 'fround(-1.1754942807573644e-38)');\n});","file":"tests/es.math.fround.js","skipped":false,"dir":"tests"},{"name":"Math.hypot","suites":[],"line":1,"code":"QUnit.test('Math.hypot', assert => {\n  const {\n    hypot,\n    sqrt\n  } = Math;\n  assert.isFunction(hypot);\n  assert.name(hypot, 'hypot');\n  assert.arity(hypot, 2);\n  assert.looksNative(hypot);\n  assert.nonEnumerable(Math, 'hypot');\n  assert.same(hypot(), 0);\n  assert.same(hypot(1), 1);\n  assert.same(hypot('', 0), 0);\n  assert.same(hypot(0, ''), 0);\n  assert.same(hypot(Infinity, 0), Infinity, 'Infinity, 0');\n  assert.same(hypot(-Infinity, 0), Infinity, '-Infinity, 0');\n  assert.same(hypot(0, Infinity), Infinity, '0, Infinity');\n  assert.same(hypot(0, -Infinity), Infinity, '0, -Infinity');\n  assert.same(hypot(Infinity, NaN), Infinity, 'Infinity, NaN');\n  assert.same(hypot(NaN, -Infinity), Infinity, 'NaN, -Infinity');\n  assert.same(hypot(NaN, 0), NaN, 'NaN, 0');\n  assert.same(hypot(0, NaN), NaN, '0, NaN');\n  assert.same(hypot(0, -0), 0);\n  assert.same(hypot(0, 0), 0);\n  assert.same(hypot(-0, -0), 0);\n  assert.same(hypot(-0, 0), 0);\n  assert.same(hypot(0, 1), 1);\n  assert.same(hypot(0, -1), 1);\n  assert.same(hypot(-0, 1), 1);\n  assert.same(hypot(-0, -1), 1);\n  assert.same(hypot(0), 0);\n  assert.same(hypot(1), 1);\n  assert.same(hypot(2), 2);\n  assert.same(hypot(0, 0, 1), 1);\n  assert.same(hypot(0, 1, 0), 1);\n  assert.same(hypot(1, 0, 0), 1);\n  assert.same(hypot(2, 3, 4), sqrt(2 * 2 + 3 * 3 + 4 * 4));\n  assert.same(hypot(2, 3, 4, 5), sqrt(2 * 2 + 3 * 3 + 4 * 4 + 5 * 5));\n  assert.epsilon(hypot(66, 66), 93.33809511662427);\n  assert.epsilon(hypot(0.1, 100), 100.0000499999875);\n  assert.same(hypot(1e+300, 1e+300), 1.4142135623730952e+300);\n  assert.same(Math.floor(hypot(1e-300, 1e-300) * 1e308), 141421356);\n  assert.same(hypot(1e+300, 1e+300, 2, 3), 1.4142135623730952e+300);\n  assert.same(hypot(-3, 4), 5);\n  assert.same(hypot(3, -4), 5);\n});","file":"tests/es.math.hypot.js","skipped":false,"dir":"tests"},{"name":"Math.imul","suites":[],"line":1,"code":"QUnit.test('Math.imul', assert => {\n  const {\n    imul\n  } = Math;\n  assert.isFunction(imul);\n  assert.name(imul, 'imul');\n  assert.arity(imul, 2);\n  assert.looksNative(imul);\n  assert.nonEnumerable(Math, 'imul');\n  assert.same(imul(0, 0), 0);\n  assert.same(imul(123, 456), 56088);\n  assert.same(imul(-123, 456), -56088);\n  assert.same(imul(123, -456), -56088);\n  assert.same(imul(19088743, 4275878552), 602016552);\n  assert.same(imul(false, 7), 0);\n  assert.same(imul(7, false), 0);\n  assert.same(imul(false, false), 0);\n  assert.same(imul(true, 7), 7);\n  assert.same(imul(7, true), 7);\n  assert.same(imul(true, true), 1);\n  assert.same(imul(undefined, 7), 0);\n  assert.same(imul(7, undefined), 0);\n  assert.same(imul(undefined, undefined), 0);\n  assert.same(imul('str', 7), 0);\n  assert.same(imul(7, 'str'), 0);\n  assert.same(imul({}, 7), 0);\n  assert.same(imul(7, {}), 0);\n  assert.same(imul([], 7), 0);\n  assert.same(imul(7, []), 0);\n  assert.same(imul(0xFFFFFFFF, 5), -5);\n  assert.same(imul(0xFFFFFFFE, 5), -10);\n  assert.same(imul(2, 4), 8);\n  assert.same(imul(-1, 8), -8);\n  assert.same(imul(-2, -2), 4);\n  assert.same(imul(-0, 7), 0);\n  assert.same(imul(7, -0), 0);\n  assert.same(imul(0.1, 7), 0);\n  assert.same(imul(7, 0.1), 0);\n  assert.same(imul(0.9, 7), 0);\n  assert.same(imul(7, 0.9), 0);\n  assert.same(imul(1.1, 7), 7);\n  assert.same(imul(7, 1.1), 7);\n  assert.same(imul(1.9, 7), 7);\n  assert.same(imul(7, 1.9), 7);\n});","file":"tests/es.math.imul.js","skipped":false,"dir":"tests"},{"name":"Math.log10","suites":[],"line":1,"code":"QUnit.test('Math.log10', assert => {\n  const {\n    log10\n  } = Math;\n  assert.isFunction(log10);\n  assert.name(log10, 'log10');\n  assert.arity(log10, 1);\n  assert.looksNative(log10);\n  assert.nonEnumerable(Math, 'log10');\n  assert.same(log10(''), log10(0));\n  assert.same(log10(NaN), NaN);\n  assert.same(log10(-1), NaN);\n  assert.same(log10(0), -Infinity);\n  assert.same(log10(-0), -Infinity);\n  assert.same(log10(1), 0);\n  assert.same(log10(Infinity), Infinity);\n  assert.epsilon(log10(0.1), -1);\n  assert.epsilon(log10(0.5), -0.3010299956639812);\n  assert.epsilon(log10(1.5), 0.17609125905568124);\n  assert.epsilon(log10(5), 0.6989700043360189);\n  assert.epsilon(log10(50), 1.6989700043360187);\n  assert.epsilon(log10(1000), 3);\n});","file":"tests/es.math.log10.js","skipped":false,"dir":"tests"},{"name":"Math.log1p","suites":[],"line":1,"code":"QUnit.test('Math.log1p', assert => {\n  const {\n    log1p\n  } = Math;\n  assert.isFunction(log1p);\n  assert.name(log1p, 'log1p');\n  assert.arity(log1p, 1);\n  assert.looksNative(log1p);\n  assert.nonEnumerable(Math, 'log1p');\n  assert.same(log1p(''), log1p(0));\n  assert.same(log1p(NaN), NaN);\n  assert.same(log1p(-2), NaN);\n  assert.same(log1p(-1), -Infinity);\n  assert.same(log1p(0), 0);\n  assert.same(log1p(-0), -0);\n  assert.same(log1p(Infinity), Infinity);\n  assert.epsilon(log1p(5), 1.791759469228055);\n  assert.epsilon(log1p(50), 3.9318256327243257);\n});","file":"tests/es.math.log1p.js","skipped":false,"dir":"tests"},{"name":"Math.log2","suites":[],"line":1,"code":"QUnit.test('Math.log2', assert => {\n  const {\n    log2\n  } = Math;\n  assert.isFunction(log2);\n  assert.name(log2, 'log2');\n  assert.arity(log2, 1);\n  assert.looksNative(log2);\n  assert.nonEnumerable(Math, 'log2');\n  assert.same(log2(''), log2(0));\n  assert.same(log2(NaN), NaN);\n  assert.same(log2(-1), NaN);\n  assert.same(log2(0), -Infinity);\n  assert.same(log2(-0), -Infinity);\n  assert.same(log2(1), 0);\n  assert.same(log2(Infinity), Infinity);\n  assert.same(log2(0.5), -1);\n  assert.same(log2(32), 5);\n  assert.epsilon(log2(5), 2.321928094887362);\n});","file":"tests/es.math.log2.js","skipped":false,"dir":"tests"},{"name":"Math.sign","suites":[],"line":1,"code":"QUnit.test('Math.sign', assert => {\n  const {\n    sign\n  } = Math;\n  assert.isFunction(sign);\n  assert.name(sign, 'sign');\n  assert.arity(sign, 1);\n  assert.looksNative(sign);\n  assert.nonEnumerable(Math, 'sign');\n  assert.same(sign(NaN), NaN);\n  assert.same(sign(), NaN);\n  assert.same(sign(-0), -0);\n  assert.same(sign(0), 0);\n  assert.same(sign(Infinity), 1);\n  assert.same(sign(-Infinity), -1);\n  assert.same(sign(13510798882111488), 1);\n  assert.same(sign(-13510798882111488), -1);\n  assert.same(sign(42.5), 1);\n  assert.same(sign(-42.5), -1);\n});","file":"tests/es.math.sign.js","skipped":false,"dir":"tests"},{"name":"Math.sinh","suites":[],"line":1,"code":"QUnit.test('Math.sinh', assert => {\n  const {\n    sinh\n  } = Math;\n  assert.isFunction(sinh);\n  assert.name(sinh, 'sinh');\n  assert.arity(sinh, 1);\n  assert.looksNative(sinh);\n  assert.nonEnumerable(Math, 'sinh');\n  assert.same(sinh(NaN), NaN);\n  assert.same(sinh(0), 0);\n  assert.same(sinh(-0), -0);\n  assert.same(sinh(Infinity), Infinity);\n  assert.same(sinh(-Infinity), -Infinity);\n  assert.epsilon(sinh(-5), -74.20321057778875);\n  assert.epsilon(sinh(2), 3.6268604078470186);\n  assert.same(sinh(-2e-17), -2e-17);\n});","file":"tests/es.math.sinh.js","skipped":false,"dir":"tests"},{"name":"Math.tanh","suites":[],"line":2,"code":"QUnit.test('Math.tanh', assert => {\n  const {\n    tanh\n  } = Math;\n  assert.isFunction(tanh);\n  assert.name(tanh, 'tanh');\n  assert.arity(tanh, 1);\n  assert.looksNative(tanh);\n  assert.nonEnumerable(Math, 'tanh');\n  assert.same(tanh(NaN), NaN);\n  assert.same(tanh(0), 0);\n  assert.same(tanh(-0), -0);\n  assert.same(tanh(Infinity), 1);\n  assert.same(tanh(90), 1);\n  assert.epsilon(tanh(10), 0.9999999958776927);\n  if (NATIVE) assert.same(tanh(710), 1);\n});","file":"tests/es.math.tanh.js","skipped":false,"dir":"tests"},{"name":"Math[@@toStringTag]","suites":[],"line":1,"code":"QUnit.test('Math[@@toStringTag]', assert => {\n  assert.same(Math[Symbol.toStringTag], 'Math', 'Math[@@toStringTag] is `Math`');\n});","file":"tests/es.math.to-string-tag.js","skipped":false,"dir":"tests"},{"name":"Math.trunc","suites":[],"line":1,"code":"QUnit.test('Math.trunc', assert => {\n  const {\n    trunc\n  } = Math;\n  assert.isFunction(trunc);\n  assert.name(trunc, 'trunc');\n  assert.arity(trunc, 1);\n  assert.looksNative(trunc);\n  assert.nonEnumerable(Math, 'trunc');\n  assert.same(trunc(NaN), NaN, 'NaN -> NaN');\n  assert.same(trunc(-0), -0, '-0 -> -0');\n  assert.same(trunc(0), 0, '0 -> 0');\n  assert.same(trunc(Infinity), Infinity, 'Infinity -> Infinity');\n  assert.same(trunc(-Infinity), -Infinity, '-Infinity -> -Infinity');\n  assert.same(trunc(null), 0, 'null -> 0');\n  assert.same(trunc({}), NaN, '{} -> NaN');\n  assert.same(trunc([]), 0, '[] -> 0');\n  assert.same(trunc(1.01), 1, '1.01 -> 0');\n  assert.same(trunc(1.99), 1, '1.99 -> 0');\n  assert.same(trunc(-1), -1, '-1 -> -1');\n  assert.same(trunc(-1.99), -1, '-1.99 -> -1');\n  assert.same(trunc(-555.555), -555, '-555.555 -> -555');\n  assert.same(trunc(0x20000000000001), 0x20000000000001, '0x20000000000001 -> 0x20000000000001');\n  assert.same(trunc(-0x20000000000001), -0x20000000000001, '-0x20000000000001 -> -0x20000000000001');\n});","file":"tests/es.math.trunc.js","skipped":false,"dir":"tests"},{"name":"Number constructor: regression","suites":[],"line":14,"code":"QUnit.test('Number constructor: regression', assert => {\n  const check = getCheck(assert);\n  assert.isFunction(Number);\n  assert.arity(Number, 1);\n  assert.name(Number, 'Number');\n  assert.looksNative(Number);\n  assert.same(Number.prototype.constructor, Number);\n  assert.same(1.0.constructor, Number);\n  const constants = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY'];\n\n  for (const constant of constants) {\n    assert.true(constant in Number, `Number.${constant}`);\n    assert.nonEnumerable(Number, constant);\n  }\n\n  assert.same(Number(), 0);\n  assert.same(new Number().valueOf(), 0);\n  check(42, 42);\n  check(42.42, 42.42);\n  check(new Number(42), 42);\n  check(new Number(42.42), 42.42);\n  check('42', 42);\n  check('42.42', 42.42);\n  check('0x42', 66);\n  check('0X42', 66);\n  check('0xzzz', NaN);\n  check('0x1g', NaN);\n  check('+0x1', NaN);\n  check('-0x1', NaN);\n  check('+0X1', NaN);\n  check('-0X1', NaN);\n  check(new String('42'), 42);\n  check(new String('42.42'), 42.42);\n  check(new String('0x42'), 66);\n  check(null, 0);\n  check(undefined, NaN);\n  check(false, 0);\n  check(true, 1);\n  check(new Boolean(false), 0);\n  check(new Boolean(true), 1);\n  check({}, NaN);\n  check({\n    valueOf: '1.1'\n  }, NaN);\n  check({\n    valueOf: '1.1',\n\n    toString() {\n      return '2.2';\n    }\n\n  }, 2.2);\n  check({\n    valueOf() {\n      return '1.1';\n    }\n\n  }, 1.1);\n  check({\n    valueOf() {\n      return '1.1';\n    },\n\n    toString() {\n      return '2.2';\n    }\n\n  }, 1.1);\n  check({\n    valueOf() {\n      return '-0x1a2b3c';\n    }\n\n  }, NaN);\n  check({\n    toString() {\n      return '-0x1a2b3c';\n    }\n\n  }, NaN);\n  check({\n    valueOf() {\n      return 42;\n    }\n\n  }, 42);\n  check({\n    valueOf() {\n      return '42';\n    }\n\n  }, 42);\n  check({\n    valueOf() {\n      return null;\n    }\n\n  }, 0);\n  check({\n    toString() {\n      return 42;\n    }\n\n  }, 42);\n  check({\n    toString() {\n      return '42';\n    }\n\n  }, 42);\n  check({\n    valueOf() {\n      return 1;\n    },\n\n    toString() {\n      return 2;\n    }\n\n  }, 1);\n  check({\n    valueOf: 1,\n\n    toString() {\n      return 2;\n    }\n\n  }, 2);\n  let number = 1;\n  assert.same(Number({\n    valueOf() {\n      return ++number;\n    }\n\n  }), 2, 'Number call valueOf only once #1');\n  assert.same(number, 2, 'Number call valueOf only once #2');\n  number = 1;\n  assert.same(Number({\n    toString() {\n      return ++number;\n    }\n\n  }), 2, 'Number call toString only once #1');\n  assert.same(number, 2, 'Number call toString only once #2');\n  number = 1;\n  assert.same(new Number({\n    valueOf() {\n      return ++number;\n    }\n\n  }).valueOf(), 2, 'new Number call valueOf only once #1');\n  assert.same(number, 2, 'new Number call valueOf only once #2');\n  number = 1;\n  assert.same(new Number({\n    toString() {\n      return ++number;\n    }\n\n  }).valueOf(), 2, 'new Number call toString only once #1');\n  assert.same(number, 2, 'new Number call toString only once #2');\n  assert.throws(() => Number(Object.create(null)), TypeError, 'Number assert.throws on object w/o valueOf and toString');\n  assert.throws(() => Number({\n    valueOf: 1,\n    toString: 2\n  }), TypeError, 'Number assert.throws on object then valueOf and toString are not functions');\n  assert.throws(() => new Number(Object.create(null)), TypeError, 'new Number assert.throws on object w/o valueOf and toString');\n  assert.throws(() => new Number({\n    valueOf: 1,\n    toString: 2\n  }), TypeError, 'new Number assert.throws on object then valueOf and toString are not functions');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => Number(Symbol()), 'throws on symbol argument');\n    assert.throws(() => new Number(Symbol()), 'throws on symbol argument, new');\n  }\n\n  number = new Number(42);\n  assert.same(typeof number.constructor(number), 'number');\n  check(`${whitespaces}42`, 42);\n  check(`42${whitespaces}`, 42);\n  check(`${whitespaces}42${whitespaces}`, 42);\n  check(`${whitespaces}0x42`, 66);\n  check(`0x42${whitespaces}`, 66);\n  check(`${whitespaces}0x42${whitespaces}`, 66);\n  check(`${whitespaces}0X42`, 66);\n  check(`0X42${whitespaces}`, 66);\n  check(`${whitespaces}0X42${whitespaces}`, 66);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(Number);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof Number, 'correct subclassing with native classes #2');\n    assert.same(new Subclass(1).toFixed(2), '1.00', 'correct subclassing with native classes #3');\n  }\n});","file":"tests/es.number.constructor.js","skipped":false,"dir":"tests"},{"name":"Number constructor: binary","suites":[],"line":209,"code":"QUnit.test('Number constructor: binary', assert => {\n  const check = getCheck(assert);\n  check('0b1', 1);\n  check('0B1', 1);\n  check('0b12', NaN);\n  check('0b234', NaN);\n  check('0b1!', NaN);\n  check('+0b1', NaN);\n  check('-0b1', NaN);\n  check(' 0b1', 1);\n  check('0b1\\n', 1);\n  check('\\n 0b1\\n ', 1);\n  check(' 0B1', 1);\n  check('0B1\\n', 1);\n  check('\\n 0B1\\n ', 1);\n  check({\n    valueOf() {\n      return '0b11';\n    }\n\n  }, 3);\n  check({\n    toString() {\n      return '0b111';\n    }\n\n  }, 7);\n  check({\n    valueOf() {\n      return '0b101010';\n    }\n\n  }, 42);\n  check({\n    toString() {\n      return '0b101010';\n    }\n\n  }, 42);\n  check(`${whitespaces}0b11`, 3);\n  check(`0b11${whitespaces}`, 3);\n  check(`${whitespaces}0b11${whitespaces}`, 3);\n  check(`${whitespaces}0B11`, 3);\n  check(`0B11${whitespaces}`, 3);\n  check(`${whitespaces}0B11${whitespaces}`, 3);\n});","file":"tests/es.number.constructor.js","skipped":false,"dir":"tests"},{"name":"Number constructor: octal","suites":[],"line":255,"code":"QUnit.test('Number constructor: octal', assert => {\n  const check = getCheck(assert);\n  check('0o7', 7);\n  check('0O7', 7);\n  check('0o18', NaN);\n  check('0o89a', NaN);\n  check('0o1!', NaN);\n  check('+0o1', NaN);\n  check('-0o1', NaN);\n  check(' 0o1', 1);\n  check('0o1\\n', 1);\n  check('\\n 0o1\\n ', 1);\n  check(' 0O1', 1);\n  check('0O1\\n', 1);\n  check('\\n 0O1\\n ', 1);\n  check({\n    valueOf() {\n      return '0o77';\n    }\n\n  }, 63);\n  check({\n    toString() {\n      return '0o777';\n    }\n\n  }, 511);\n  check({\n    valueOf() {\n      return '0o12345';\n    }\n\n  }, 5349);\n  check({\n    toString() {\n      return '0o12345';\n    }\n\n  }, 5349);\n  check(`${whitespaces}0o11`, 9);\n  check(`0o11${whitespaces}`, 9);\n  check(`${whitespaces}0o11${whitespaces}`, 9);\n  check(`${whitespaces}0O11`, 9);\n  check(`0O11${whitespaces}`, 9);\n  check(`${whitespaces}0O11${whitespaces}`, 9);\n});","file":"tests/es.number.constructor.js","skipped":false,"dir":"tests"},{"name":"Number.EPSILON","suites":[],"line":1,"code":"QUnit.test('Number.EPSILON', assert => {\n  const {\n    EPSILON\n  } = Number;\n  assert.true('EPSILON' in Number, 'EPSILON in Number');\n  assert.nonEnumerable(Number, 'EPSILON');\n  assert.same(EPSILON, 2 ** -52, 'Is 2^-52');\n  assert.notSame(1, 1 + EPSILON, '1 isnt 1 + EPSILON');\n  assert.same(1, 1 + EPSILON / 2, '1 is 1 + EPSILON / 2');\n});","file":"tests/es.number.epsilon.js","skipped":false,"dir":"tests"},{"name":"Number.isFinite","suites":[],"line":1,"code":"QUnit.test('Number.isFinite', assert => {\n  const {\n    isFinite\n  } = Number;\n  const {\n    create\n  } = Object;\n  assert.isFunction(isFinite);\n  assert.name(isFinite, 'isFinite');\n  assert.arity(isFinite, 1);\n  assert.looksNative(isFinite);\n  assert.nonEnumerable(Number, 'isFinite');\n  const finite = [1, 0.1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0];\n\n  for (const value of finite) {\n    assert.true(isFinite(value), `isFinite ${typeof value} ${value}`);\n  }\n\n  const notFinite = [NaN, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notFinite) {\n    assert.false(isFinite(value), `not isFinite ${typeof value} ${value}`);\n  }\n\n  assert.false(isFinite(create(null)), 'Number.isFinite(Object.create(null)) -> false');\n});","file":"tests/es.number.is-finite.js","skipped":false,"dir":"tests"},{"name":"Number.isInteger","suites":[],"line":1,"code":"QUnit.test('Number.isInteger', assert => {\n  const {\n    isInteger\n  } = Number;\n  const {\n    create\n  } = Object;\n  assert.isFunction(isInteger);\n  assert.name(isInteger, 'isInteger');\n  assert.arity(isInteger, 1);\n  assert.looksNative(isInteger);\n  assert.nonEnumerable(Number, 'isInteger');\n  const integers = [1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0];\n\n  for (const value of integers) {\n    assert.true(isInteger(value), `isInteger ${typeof value} ${value}`);\n  }\n\n  const notIntegers = [NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notIntegers) {\n    assert.false(isInteger(value), `not isInteger ${typeof value} ${value}`);\n  }\n\n  assert.false(isInteger(create(null)), 'Number.isInteger(Object.create(null)) -> false');\n});","file":"tests/es.number.is-integer.js","skipped":false,"dir":"tests"},{"name":"Number.isNaN","suites":[],"line":1,"code":"QUnit.test('Number.isNaN', assert => {\n  const {\n    isNaN\n  } = Number;\n  const {\n    create\n  } = Object;\n  assert.isFunction(isNaN);\n  assert.name(isNaN, 'isNaN');\n  assert.arity(isNaN, 1);\n  assert.looksNative(isNaN);\n  assert.nonEnumerable(Number, 'isNaN');\n  assert.true(isNaN(NaN), 'Number.isNaN NaN');\n  const notNaNs = [1, 0.1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notNaNs) {\n    assert.false(isNaN(value), `not Number.isNaN ${typeof value} ${value}`);\n  }\n\n  assert.false(isNaN(create(null)), 'Number.isNaN(Object.create(null)) -> false');\n});","file":"tests/es.number.is-nan.js","skipped":false,"dir":"tests"},{"name":"Number.isSafeInteger","suites":[],"line":1,"code":"QUnit.test('Number.isSafeInteger', assert => {\n  const {\n    isSafeInteger\n  } = Number;\n  const {\n    create\n  } = Object;\n  assert.isFunction(isSafeInteger);\n  assert.name(isSafeInteger, 'isSafeInteger');\n  assert.arity(isSafeInteger, 1);\n  assert.looksNative(isSafeInteger);\n  assert.nonEnumerable(Number, 'isSafeInteger');\n  const safeIntegers = [1, -1, 2 ** 16, 2 ** 16 - 1, 2 ** 31, 2 ** 31 - 1, 2 ** 32, 2 ** 32 - 1, -0, 9007199254740991, -9007199254740991];\n\n  for (const value of safeIntegers) {\n    assert.true(isSafeInteger(value), `isSafeInteger ${typeof value} ${value}`);\n  }\n\n  const notSafeIntegers = [9007199254740992, -9007199254740992, NaN, 0.1, Infinity, 'NaN', '5', false, new Number(NaN), new Number(Infinity), new Number(5), new Number(0.1), undefined, null, {}, function () {\n    /* empty */\n  }];\n\n  for (const value of notSafeIntegers) {\n    assert.false(isSafeInteger(value), `not isSafeInteger ${typeof value} ${value}`);\n  }\n\n  assert.false(isSafeInteger(create(null)), 'Number.isSafeInteger(Object.create(null)) -> false');\n});","file":"tests/es.number.is-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.MAX_SAFE_INTEGER","suites":[],"line":1,"code":"QUnit.test('Number.MAX_SAFE_INTEGER', assert => {\n  assert.true('MAX_SAFE_INTEGER' in Number);\n  assert.nonEnumerable(Number, 'MAX_SAFE_INTEGER');\n  assert.same(Number.MAX_SAFE_INTEGER, 2 ** 53 - 1, 'Is 2^53 - 1');\n});","file":"tests/es.number.max-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.MIN_SAFE_INTEGER","suites":[],"line":1,"code":"QUnit.test('Number.MIN_SAFE_INTEGER', assert => {\n  assert.true('MIN_SAFE_INTEGER' in Number);\n  assert.nonEnumerable(Number, 'MIN_SAFE_INTEGER');\n  assert.same(Number.MIN_SAFE_INTEGER, -(2 ** 53) + 1, 'Is -2^53 + 1');\n});","file":"tests/es.number.min-safe-integer.js","skipped":false,"dir":"tests"},{"name":"Number.parseFloat","suites":[],"line":2,"code":"QUnit.test('Number.parseFloat', assert => {\n  const {\n    parseFloat\n  } = Number;\n  assert.isFunction(parseFloat);\n  assert.name(parseFloat, 'parseFloat');\n  assert.arity(parseFloat, 1);\n  assert.looksNative(parseFloat);\n  assert.nonEnumerable(Number, 'parseFloat');\n  assert.same(parseFloat, GLOBAL.parseFloat);\n  assert.same(parseFloat('0'), 0);\n  assert.same(parseFloat(' 0'), 0);\n  assert.same(parseFloat('+0'), 0);\n  assert.same(parseFloat(' +0'), 0);\n  assert.same(parseFloat('-0'), -0);\n  assert.same(parseFloat(' -0'), -0);\n  assert.same(parseFloat(`${WHITESPACES}+0`), 0);\n  assert.same(parseFloat(`${WHITESPACES}-0`), -0);\n  assert.same(parseFloat(null), NaN);\n  assert.same(parseFloat(undefined), NaN);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => parseFloat(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseFloat(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"tests/es.number.parse-float.js","skipped":false,"dir":"tests"},{"name":"Number.parseInt","suites":[],"line":2,"code":"QUnit.test('Number.parseInt', assert => {\n  const {\n    parseInt\n  } = Number;\n  assert.isFunction(parseInt);\n  assert.name(parseInt, 'parseInt');\n  assert.arity(parseInt, 2);\n  assert.looksNative(parseInt);\n  assert.nonEnumerable(Number, 'parseInt');\n  assert.same(parseInt, GLOBAL.parseInt);\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(parseInt('10', radix), radix, `radix ${radix}`);\n  }\n\n  const strings = ['01', '08', '10', '42'];\n\n  for (const string of strings) {\n    assert.same(parseInt(string), parseInt(string, 10), `default radix is 10: ${string}`);\n  }\n\n  assert.same(parseInt('0x16'), parseInt('0x16', 16), 'default radix is 16: 0x16');\n  assert.same(parseInt('  0x16'), parseInt('0x16', 16), 'ignores leading whitespace #1');\n  assert.same(parseInt('  42'), parseInt('42', 10), 'ignores leading whitespace #2');\n  assert.same(parseInt('  08'), parseInt('08', 10), 'ignores leading whitespace #3');\n  assert.same(parseInt(`${WHITESPACES}08`), parseInt('08', 10), 'ignores leading whitespace #4');\n  assert.same(parseInt(`${WHITESPACES}0x16`), parseInt('0x16', 16), 'ignores leading whitespace #5');\n  const fakeZero = {\n    valueOf() {\n      return 0;\n    }\n\n  };\n  assert.same(parseInt('08', fakeZero), parseInt('08', 10), 'valueOf #1');\n  assert.same(parseInt('0x16', fakeZero), parseInt('0x16', 16), 'valueOf #2');\n  assert.same(parseInt('-0xF'), -15, 'signed hex #1');\n  assert.same(parseInt('-0xF', 16), -15, 'signed hex #2');\n  assert.same(parseInt('+0xF'), 15, 'signed hex #3');\n  assert.same(parseInt('+0xF', 16), 15, 'signed hex #4');\n  assert.same(parseInt('10', -4294967294), 2, 'radix uses ToUint32');\n  assert.same(parseInt(null), NaN);\n  assert.same(parseInt(undefined), NaN);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => parseInt(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseInt(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"tests/es.number.parse-int.js","skipped":false,"dir":"tests"},{"name":"Number#toExponential","suites":[],"line":1,"code":"QUnit.test('Number#toExponential', assert => {\n  const {\n    toExponential\n  } = Number.prototype;\n  assert.isFunction(toExponential);\n  assert.name(toExponential, 'toExponential');\n  assert.arity(toExponential, 1);\n  assert.looksNative(toExponential);\n  assert.nonEnumerable(Number.prototype, 'toExponential');\n  assert.same(toExponential.call(0.00008, 3), '8.000e-5');\n  assert.same(toExponential.call(0.9, 0), '9e-1');\n  assert.same(toExponential.call(1.255, 2), '1.25e+0'); // Chakra Edge 14- / IE11- bug\n\n  assert.same(toExponential.call(1843654265.0774949, 5), '1.84365e+9');\n  assert.same(toExponential.call(1000000000000000128.0, 0), '1e+18');\n  assert.same(toExponential.call(1), '1e+0');\n  assert.same(toExponential.call(1, 0), '1e+0');\n  assert.same(toExponential.call(1, 1), '1.0e+0');\n  assert.same(toExponential.call(1, 1.1), '1.0e+0');\n  assert.same(toExponential.call(1, 0.9), '1e+0');\n  assert.same(toExponential.call(1, '0'), '1e+0');\n  assert.same(toExponential.call(1, '1'), '1.0e+0');\n  assert.same(toExponential.call(1, '1.1'), '1.0e+0');\n  assert.same(toExponential.call(1, '0.9'), '1e+0');\n  assert.same(toExponential.call(1, NaN), '1e+0');\n  assert.same(toExponential.call(1, 'some string'), '1e+0');\n  assert.notThrows(() => toExponential.call(1, -0.1) === '1e+0');\n  assert.same(toExponential.call(new Number(1)), '1e+0');\n  assert.same(toExponential.call(new Number(1), 0), '1e+0');\n  assert.same(toExponential.call(new Number(1), 1), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), 1.1), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), 0.9), '1e+0');\n  assert.same(toExponential.call(new Number(1), '0'), '1e+0');\n  assert.same(toExponential.call(new Number(1), '1'), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), '1.1'), '1.0e+0');\n  assert.same(toExponential.call(new Number(1), '0.9'), '1e+0');\n  assert.same(toExponential.call(new Number(1), NaN), '1e+0');\n  assert.same(toExponential.call(new Number(1), 'some string'), '1e+0');\n  assert.notThrows(() => toExponential.call(new Number(1), -0.1) === '1e+0');\n  assert.same(toExponential.call(NaN), 'NaN');\n  assert.same(toExponential.call(NaN, 0), 'NaN');\n  assert.same(toExponential.call(NaN, 1), 'NaN');\n  assert.same(toExponential.call(NaN, 1.1), 'NaN');\n  assert.same(toExponential.call(NaN, 0.9), 'NaN');\n  assert.same(toExponential.call(NaN, '0'), 'NaN');\n  assert.same(toExponential.call(NaN, '1'), 'NaN');\n  assert.same(toExponential.call(NaN, '1.1'), 'NaN');\n  assert.same(toExponential.call(NaN, '0.9'), 'NaN');\n  assert.same(toExponential.call(NaN, NaN), 'NaN');\n  assert.same(toExponential.call(NaN, 'some string'), 'NaN');\n  assert.notThrows(() => toExponential.call(NaN, -0.1) === 'NaN');\n  assert.same(toExponential.call(new Number(1e21)), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 0), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 1), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), 1.1), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), 0.9), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), '0'), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), '1'), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), '1.1'), '1.0e+21');\n  assert.same(toExponential.call(new Number(1e21), '0.9'), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), NaN), '1e+21');\n  assert.same(toExponential.call(new Number(1e21), 'some string'), '1e+21');\n  assert.same(toExponential.call(5, 19), '5.0000000000000000000e+0'); // ported from tests262, the license: https://github.com/tc39/test262/blob/main/LICENSE\n\n  assert.same(toExponential.call(123.456, 0), '1e+2');\n  assert.same(toExponential.call(123.456, 1), '1.2e+2');\n  assert.same(toExponential.call(123.456, 2), '1.23e+2');\n  assert.same(toExponential.call(123.456, 3), '1.235e+2');\n  assert.same(toExponential.call(123.456, 4), '1.2346e+2');\n  assert.same(toExponential.call(123.456, 5), '1.23456e+2');\n  assert.same(toExponential.call(123.456, 6), '1.234560e+2');\n  assert.same(toExponential.call(123.456, 7), '1.2345600e+2'); // assert.same(toExponential.call(123.456, 17), '1.23456000000000003e+2');\n  // assert.same(toExponential.call(123.456, 20), '1.23456000000000003070e+2');\n\n  assert.same(toExponential.call(-123.456, 0), '-1e+2');\n  assert.same(toExponential.call(-123.456, 1), '-1.2e+2');\n  assert.same(toExponential.call(-123.456, 2), '-1.23e+2');\n  assert.same(toExponential.call(-123.456, 3), '-1.235e+2');\n  assert.same(toExponential.call(-123.456, 4), '-1.2346e+2');\n  assert.same(toExponential.call(-123.456, 5), '-1.23456e+2');\n  assert.same(toExponential.call(-123.456, 6), '-1.234560e+2');\n  assert.same(toExponential.call(-123.456, 7), '-1.2345600e+2'); // assert.same(toExponential.call(-123.456, 17), '-1.23456000000000003e+2');\n  // assert.same(toExponential.call(-123.456, 20), '-1.23456000000000003070e+2');\n\n  assert.same(toExponential.call(0.0001, 0), '1e-4');\n  assert.same(toExponential.call(0.0001, 1), '1.0e-4');\n  assert.same(toExponential.call(0.0001, 2), '1.00e-4');\n  assert.same(toExponential.call(0.0001, 3), '1.000e-4');\n  assert.same(toExponential.call(0.0001, 4), '1.0000e-4'); // assert.same(toExponential.call(0.0001, 16), '1.0000000000000000e-4');\n  // assert.same(toExponential.call(0.0001, 17), '1.00000000000000005e-4');\n  // assert.same(toExponential.call(0.0001, 18), '1.000000000000000048e-4');\n  // assert.same(toExponential.call(0.0001, 19), '1.0000000000000000479e-4');\n  // assert.same(toExponential.call(0.0001, 20), '1.00000000000000004792e-4');\n\n  assert.same(toExponential.call(0.9999, 0), '1e+0');\n  assert.same(toExponential.call(0.9999, 1), '1.0e+0');\n  assert.same(toExponential.call(0.9999, 2), '1.00e+0');\n  assert.same(toExponential.call(0.9999, 3), '9.999e-1');\n  assert.same(toExponential.call(0.9999, 4), '9.9990e-1'); // assert.same(toExponential.call(0.9999, 16), '9.9990000000000001e-1');\n  // assert.same(toExponential.call(0.9999, 17), '9.99900000000000011e-1');\n  // assert.same(toExponential.call(0.9999, 18), '9.999000000000000110e-1');\n  // assert.same(toExponential.call(0.9999, 19), '9.9990000000000001101e-1');\n  // assert.same(toExponential.call(0.9999, 20), '9.99900000000000011013e-1');\n\n  assert.same(toExponential.call(25, 0), '3e+1'); // FF86- and Chrome 49-50 bugs\n\n  assert.same(toExponential.call(12345, 3), '1.235e+4'); // FF86- and Chrome 49-50 bugs\n\n  assert.same(toExponential.call(Number.prototype, 0), '0e+0', 'Number.prototype, 0');\n  assert.same(toExponential.call(0, 0), '0e+0', '0, 0');\n  assert.same(toExponential.call(-0, 0), '0e+0', '-0, 0');\n  assert.same(toExponential.call(0, -0), '0e+0', '0, -0');\n  assert.same(toExponential.call(-0, -0), '0e+0', '-0, -0');\n  assert.same(toExponential.call(0, 1), '0.0e+0', '0 and 1');\n  assert.same(toExponential.call(0, 2), '0.00e+0', '0 and 2');\n  assert.same(toExponential.call(0, 7), '0.0000000e+0', '0 and 7');\n  assert.same(toExponential.call(0, 20), '0.00000000000000000000e+0', '0 and 20');\n  assert.same(toExponential.call(-0, 1), '0.0e+0', '-0 and 1');\n  assert.same(toExponential.call(-0, 2), '0.00e+0', '-0 and 2');\n  assert.same(toExponential.call(-0, 7), '0.0000000e+0', '-0 and 7');\n  assert.same(toExponential.call(-0, 20), '0.00000000000000000000e+0', '-0 and 20');\n  assert.same(toExponential.call(NaN, 1000), 'NaN', 'NaN check before fractionDigits check');\n  assert.same(toExponential.call(Infinity, 1000), 'Infinity', 'Infinity check before fractionDigits check');\n  assert.notThrows(() => toExponential.call(new Number(1e21), -0.1) === '1e+21');\n  assert.throws(() => toExponential.call(1.0, -101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toExponential.call(1.0, 101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toExponential.call({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toExponential.call(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"tests/es.number.to-exponential.js","skipped":false,"dir":"tests"},{"name":"Number#toFixed","suites":[],"line":2,"code":"QUnit.test('Number#toFixed', assert => {\n  const {\n    toFixed\n  } = Number.prototype;\n  assert.isFunction(toFixed);\n  assert.name(toFixed, 'toFixed');\n  assert.arity(toFixed, 1);\n  assert.looksNative(toFixed);\n  assert.nonEnumerable(Number.prototype, 'toFixed');\n  assert.same(0.00008.toFixed(3), '0.000');\n  assert.same(0.9.toFixed(0), '1');\n  assert.same(1.255.toFixed(2), '1.25');\n  assert.same(1843654265.0774949.toFixed(5), '1843654265.07749');\n  assert.same(1000000000000000128.0.toFixed(0), '1000000000000000128');\n  assert.same(toFixed.call(1), '1');\n  assert.same(toFixed.call(1, 0), '1');\n  assert.same(toFixed.call(1, 1), '1.0');\n  assert.same(toFixed.call(1, 1.1), '1.0');\n  assert.same(toFixed.call(1, 0.9), '1');\n  assert.same(toFixed.call(1, '0'), '1');\n  assert.same(toFixed.call(1, '1'), '1.0');\n  assert.same(toFixed.call(1, '1.1'), '1.0');\n  assert.same(toFixed.call(1, '0.9'), '1');\n  assert.same(toFixed.call(1, NaN), '1');\n  assert.same(toFixed.call(1, 'some string'), '1');\n  assert.notThrows(() => toFixed.call(1, -0.1) === '1');\n  assert.same(new Number(1).toFixed(), '1');\n  assert.same(new Number(1).toFixed(0), '1');\n  assert.same(new Number(1).toFixed(1), '1.0');\n  assert.same(new Number(1).toFixed(1.1), '1.0');\n  assert.same(new Number(1).toFixed(0.9), '1');\n  assert.same(new Number(1).toFixed('0'), '1');\n  assert.same(new Number(1).toFixed('1'), '1.0');\n  assert.same(new Number(1).toFixed('1.1'), '1.0');\n  assert.same(new Number(1).toFixed('0.9'), '1');\n  assert.same(new Number(1).toFixed(NaN), '1');\n  assert.same(new Number(1).toFixed('some string'), '1');\n  assert.notThrows(() => new Number(1).toFixed(-0.1) === '1');\n  assert.same(NaN.toFixed(), 'NaN');\n  assert.same(NaN.toFixed(0), 'NaN');\n  assert.same(NaN.toFixed(1), 'NaN');\n  assert.same(NaN.toFixed(1.1), 'NaN');\n  assert.same(NaN.toFixed(0.9), 'NaN');\n  assert.same(NaN.toFixed('0'), 'NaN');\n  assert.same(NaN.toFixed('1'), 'NaN');\n  assert.same(NaN.toFixed('1.1'), 'NaN');\n  assert.same(NaN.toFixed('0.9'), 'NaN');\n  assert.same(NaN.toFixed(NaN), 'NaN');\n  assert.same(NaN.toFixed('some string'), 'NaN');\n  assert.notThrows(() => NaN.toFixed(-0.1) === 'NaN');\n  assert.same(new Number(1e21).toFixed(), String(1e21));\n  assert.same(new Number(1e21).toFixed(0), String(1e21));\n  assert.same(new Number(1e21).toFixed(1), String(1e21));\n  assert.same(new Number(1e21).toFixed(1.1), String(1e21));\n  assert.same(new Number(1e21).toFixed(0.9), String(1e21));\n  assert.same(new Number(1e21).toFixed('0'), String(1e21));\n  assert.same(new Number(1e21).toFixed('1'), String(1e21));\n  assert.same(new Number(1e21).toFixed('1.1'), String(1e21));\n  assert.same(new Number(1e21).toFixed('0.9'), String(1e21));\n  assert.same(new Number(1e21).toFixed(NaN), String(1e21));\n  assert.same(new Number(1e21).toFixed('some string'), String(1e21));\n  assert.notThrows(() => new Number(1e21).toFixed(-0.1) === String(1e21));\n  assert.throws(() => 1.0.toFixed(-101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => 1.0.toFixed(101), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => NaN.toFixed(Infinity), RangeError, 'If f < 0 or f > 20 (100), throw a RangeError exception.');\n  assert.throws(() => toFixed.call({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed.call('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed.call(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed.call(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toFixed.call(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"tests/es.number.to-fixed.js","skipped":false,"dir":"tests"},{"name":"Number#toPrecision","suites":[],"line":1,"code":"QUnit.test('Number#toPrecision', assert => {\n  const {\n    toPrecision\n  } = Number.prototype;\n  assert.isFunction(toPrecision);\n  assert.name(toPrecision, 'toPrecision');\n  assert.arity(toPrecision, 1);\n  assert.looksNative(toPrecision);\n  assert.nonEnumerable(Number.prototype, 'toPrecision');\n  assert.same(0.00008.toPrecision(3), '0.0000800', '0.00008.toPrecision(3)');\n  assert.same(1.255.toPrecision(2), '1.3', '1.255.toPrecision(2)');\n  assert.same(1843654265.0774949.toPrecision(13), '1843654265.077', '1843654265.0774949.toPrecision(13)');\n  assert.same(NaN.toPrecision(1), 'NaN', 'If x is NaN, return the String \"NaN\".');\n  assert.same(123.456.toPrecision(), '123.456', 'If precision is undefined, return ! ToString(x).');\n  assert.same(123.456.toPrecision(undefined), '123.456', 'If precision is undefined, return ! ToString(x).');\n  assert.throws(() => 0.9.toPrecision(0), RangeError, 'If p < 1 or p > 21, throw a RangeError exception.');\n  assert.throws(() => 0.9.toPrecision(101), RangeError, 'If p < 1 or p > 21, throw a RangeError exception.');\n  assert.throws(() => toPrecision.call({}, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision.call('123', 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision.call(false, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision.call(null, 1), TypeError, '? thisNumberValue(this value)');\n  assert.throws(() => toPrecision.call(undefined, 1), TypeError, '? thisNumberValue(this value)');\n});","file":"tests/es.number.to-precision.js","skipped":false,"dir":"tests"},{"name":"Object.assign","suites":[],"line":2,"code":"QUnit.test('Object.assign', assert => {\n  const {\n    assign,\n    keys,\n    defineProperty\n  } = Object;\n  assert.isFunction(assign);\n  assert.arity(assign, 2);\n  assert.name(assign, 'assign');\n  assert.looksNative(assign);\n  assert.nonEnumerable(Object, 'assign');\n  let object = {\n    q: 1\n  };\n  assert.same(object, assign(object, {\n    bar: 2\n  }), 'assign return target');\n  assert.same(object.bar, 2, 'assign define properties');\n  assert.deepEqual(assign({}, {\n    q: 1\n  }, {\n    w: 2\n  }), {\n    q: 1,\n    w: 2\n  });\n  assert.deepEqual(assign({}, 'qwe'), {\n    0: 'q',\n    1: 'w',\n    2: 'e'\n  });\n  assert.throws(() => assign(null, {\n    q: 1\n  }), TypeError);\n  assert.throws(() => assign(undefined, {\n    q: 1\n  }), TypeError);\n  let string = assign('qwe', {\n    q: 1\n  });\n  assert.same(typeof string, 'object');\n  assert.same(String(string), 'qwe');\n  assert.same(string.q, 1);\n  assert.same(assign({}, {\n    valueOf: 42\n  }).valueOf, 42, 'IE enum keys bug');\n\n  if (DESCRIPTORS) {\n    object = {\n      baz: 1\n    };\n    assign(object, defineProperty({}, 'bar', {\n      get() {\n        return this.baz + 1;\n      }\n\n    }));\n    assert.same(object.bar, undefined, \"assign don't copy descriptors\");\n    object = {\n      a: 'a'\n    };\n    const c = Symbol('c');\n    const d = Symbol('d');\n    object[c] = 'c';\n    defineProperty(object, 'b', {\n      value: 'b'\n    });\n    defineProperty(object, d, {\n      value: 'd'\n    });\n    const object2 = assign({}, object);\n    assert.same(object2.a, 'a', 'a');\n    assert.same(object2.b, undefined, 'b');\n    assert.same(object2[c], 'c', 'c');\n    assert.same(object2[d], undefined, 'd');\n\n    try {\n      assert.same(Function('assign', `\n        return assign({ b: 1 }, { get a() {\n          delete this.b;\n        }, b: 2 });\n      `)(assign).b, 1);\n    } catch {\n      /* empty */\n    }\n\n    try {\n      assert.same(Function('assign', `\n        return assign({ b: 1 }, { get a() {\n          Object.defineProperty(this, \"b\", {\n            value: 3,\n            enumerable: false\n          });\n        }, b: 2 });\n      `)(assign).b, 1);\n    } catch {\n      /* empty */\n    }\n  }\n\n  string = 'abcdefghijklmnopqrst';\n  const result = {};\n\n  for (let i = 0, {\n    length\n  } = string; i < length; ++i) {\n    const chr = string.charAt(i);\n    result[chr] = chr;\n  }\n\n  assert.same(keys(assign({}, result)).join(''), string);\n});","file":"tests/es.object.assign.js","skipped":false,"dir":"tests"},{"name":"Object.create","suites":[],"line":2,"code":"QUnit.test('Object.create', assert => {\n  const {\n    create,\n    getPrototypeOf,\n    getOwnPropertyNames\n  } = Object;\n\n  function getPropertyNames(object) {\n    let result = [];\n\n    do {\n      result = result.concat(getOwnPropertyNames(object));\n    } while (object = getPrototypeOf(object));\n\n    return result;\n  }\n\n  assert.isFunction(create);\n  assert.arity(create, 2);\n  assert.name(create, 'create');\n  assert.looksNative(create);\n  assert.nonEnumerable(Object, 'create');\n  let object = {\n    q: 1\n  };\n  assert.true({}.isPrototypeOf.call(object, create(object)));\n  assert.same(create(object).q, 1);\n\n  function F() {\n    return this.a = 1;\n  }\n\n  assert.true(create(new F()) instanceof F);\n  assert.same(F.prototype, getPrototypeOf(getPrototypeOf(create(new F()))));\n  assert.same(create(new F()).a, 1);\n  assert.same(create({}, {\n    a: {\n      value: 42\n    }\n  }).a, 42);\n  object = create(null, {\n    w: {\n      value: 2\n    }\n  });\n  assert.same(object, Object(object));\n  assert.false('toString' in object);\n  assert.same(object.w, 2);\n  assert.deepEqual(getPropertyNames(create(null)), []);\n});","file":"tests/es.object.create.js","skipped":false,"dir":"tests"},{"name":"Object.create.sham flag","suites":[],"line":52,"code":"QUnit.test('Object.create.sham flag', assert => {\n  assert.same(Object.create.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.object.create.js","skipped":false,"dir":"tests"},{"name":"Object#__defineGetter__","suites":[],"line":4,"code":"  QUnit.test('Object#__defineGetter__', assert => {\n    const {\n      __defineGetter__\n    } = Object.prototype;\n    assert.isFunction(__defineGetter__);\n    assert.arity(__defineGetter__, 2);\n    assert.name(__defineGetter__, '__defineGetter__');\n    assert.looksNative(__defineGetter__);\n    assert.nonEnumerable(Object.prototype, '__defineGetter__');\n    const object = {};\n    assert.same(object.__defineGetter__('key', () => 42), undefined, 'void');\n    assert.same(object.key, 42, 'works');\n\n    object.__defineSetter__('key', function () {\n      this.foo = 43;\n    });\n\n    object.key = 44;\n    assert.same(object.key, 42, 'works with getter #1');\n    assert.same(object.foo, 43, 'works with getter #2');\n\n    if (STRICT) {\n      assert.throws(() => __defineGetter__.call(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __defineGetter__.call(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"tests/es.object.define-getter.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperties","suites":[],"line":2,"code":"QUnit.test('Object.defineProperties', assert => {\n  const {\n    defineProperties\n  } = Object;\n  assert.isFunction(defineProperties);\n  assert.arity(defineProperties, 2);\n  assert.name(defineProperties, 'defineProperties');\n  assert.looksNative(defineProperties);\n  assert.nonEnumerable(Object, 'defineProperties');\n  const source = {};\n  const result = defineProperties(source, {\n    q: {\n      value: 42\n    },\n    w: {\n      value: 33\n    }\n  });\n  assert.same(result, source);\n  assert.same(result.q, 42);\n  assert.same(result.w, 33);\n\n  if (DESCRIPTORS) {\n    // eslint-disable-next-line prefer-arrow-callback -- required for testing\n    assert.same(defineProperties(function () {\n      /* empty */\n    }, {\n      prototype: {\n        value: 42,\n        writable: false\n      }\n    }).prototype, 42, 'function prototype with non-writable descriptor');\n  }\n});","file":"tests/es.object.define-properties.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperties.sham flag","suites":[],"line":36,"code":"QUnit.test('Object.defineProperties.sham flag', assert => {\n  assert.same(Object.defineProperties.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.object.define-properties.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperty","suites":[],"line":2,"code":"QUnit.test('Object.defineProperty', assert => {\n  const {\n    defineProperty,\n    create\n  } = Object;\n  assert.isFunction(defineProperty);\n  assert.arity(defineProperty, 3);\n  assert.name(defineProperty, 'defineProperty');\n  assert.looksNative(defineProperty);\n  assert.nonEnumerable(Object, 'defineProperty');\n  const source = {};\n  const result = defineProperty(source, 'q', {\n    value: 42\n  });\n  assert.same(result, source);\n  assert.same(result.q, 42);\n\n  if (DESCRIPTORS) {\n    // eslint-disable-next-line prefer-arrow-callback -- required for testing\n    assert.same(defineProperty(function () {\n      /* empty */\n    }, 'prototype', {\n      value: 42,\n      writable: false\n    }).prototype, 42, 'function prototype with non-writable descriptor');\n  }\n\n  assert.throws(() => defineProperty(42, 1, {}));\n  assert.throws(() => defineProperty({}, create(null), {}));\n  assert.throws(() => defineProperty({}, 1, 1));\n});","file":"tests/es.object.define-property.js","skipped":false,"dir":"tests"},{"name":"Object.defineProperty.sham flag","suites":[],"line":33,"code":"QUnit.test('Object.defineProperty.sham flag', assert => {\n  assert.same(Object.defineProperty.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.object.define-property.js","skipped":false,"dir":"tests"},{"name":"Object#__defineSetter__","suites":[],"line":4,"code":"  QUnit.test('Object#__defineSetter__', assert => {\n    const {\n      __defineSetter__\n    } = Object.prototype;\n    assert.isFunction(__defineSetter__);\n    assert.arity(__defineSetter__, 2);\n    assert.name(__defineSetter__, '__defineSetter__');\n    assert.looksNative(__defineSetter__);\n    assert.nonEnumerable(Object.prototype, '__defineSetter__');\n    let object = {};\n    assert.same(object.__defineSetter__('key', function () {\n      this.foo = 43;\n    }), undefined, 'void');\n    object.key = 44;\n    assert.same(object.foo, 43, 'works');\n    object = {};\n\n    object.__defineSetter__('key', function () {\n      this.foo = 43;\n    });\n\n    object.__defineGetter__('key', () => 42);\n\n    object.key = 44;\n    assert.same(object.key, 42, 'works with setter #1');\n    assert.same(object.foo, 43, 'works with setter #2');\n\n    if (STRICT) {\n      assert.throws(() => __defineSetter__.call(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __defineSetter__.call(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"tests/es.object.define-setter.js","skipped":false,"dir":"tests"},{"name":"Object.entries","suites":[],"line":1,"code":"QUnit.test('Object.entries', assert => {\n  const {\n    entries,\n    create,\n    assign\n  } = Object;\n  assert.isFunction(entries);\n  assert.arity(entries, 1);\n  assert.name(entries, 'entries');\n  assert.looksNative(entries);\n  assert.nonEnumerable(Object, 'entries');\n  assert.deepEqual(entries({\n    q: 1,\n    w: 2,\n    e: 3\n  }), [['q', 1], ['w', 2], ['e', 3]]);\n  assert.deepEqual(entries(new String('qwe')), [['0', 'q'], ['1', 'w'], ['2', 'e']]);\n  assert.deepEqual(entries(assign(create({\n    q: 1,\n    w: 2,\n    e: 3\n  }), {\n    a: 4,\n    s: 5,\n    d: 6\n  })), [['a', 4], ['s', 5], ['d', 6]]);\n  assert.deepEqual(entries({\n    valueOf: 42\n  }), [['valueOf', 42]], 'IE enum keys bug');\n\n  try {\n    assert.deepEqual(Function('entries', `\n      return entries({\n        a: 1,\n        get b() {\n          delete this.c;\n          return 2;\n        },\n        c: 3\n      });\n    `)(entries), [['a', 1], ['b', 2]]);\n  } catch {\n    /* empty */\n  }\n\n  try {\n    assert.deepEqual(Function('entries', `\n      return entries({\n        a: 1,\n        get b() {\n          Object.defineProperty(this, \"c\", {\n            value: 4,\n            enumerable: false\n          });\n          return 2;\n        },\n        c: 3\n      });\n    `)(entries), [['a', 1], ['b', 2]]);\n  } catch {\n    /* empty */\n  }\n});","file":"tests/es.object.entries.js","skipped":false,"dir":"tests"},{"name":"Object.freeze","suites":[],"line":2,"code":"QUnit.test('Object.freeze', assert => {\n  const {\n    freeze,\n    isFrozen,\n    keys,\n    getOwnPropertyNames,\n    getOwnPropertySymbols\n  } = Object;\n  const {\n    ownKeys\n  } = GLOBAL.Reflect || {};\n  assert.isFunction(freeze);\n  assert.arity(freeze, 1);\n  assert.name(freeze, 'freeze');\n  assert.looksNative(freeze);\n  assert.nonEnumerable(Object, 'freeze');\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => freeze(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(freeze(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  if (NATIVE) assert.true(isFrozen(freeze({})));\n  const results = [];\n\n  for (const key in freeze({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(freeze({})), []);\n  assert.arrayEqual(getOwnPropertyNames(freeze({})), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(freeze({})), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(freeze({})), []);\n});","file":"tests/es.object.freeze.js","skipped":false,"dir":"tests"},{"name":"Object.fromEntries","suites":[],"line":2,"code":"QUnit.test('Object.fromEntries', assert => {\n  const {\n    fromEntries\n  } = Object;\n  assert.isFunction(fromEntries);\n  assert.arity(fromEntries, 1);\n  assert.name(fromEntries, 'fromEntries');\n  assert.looksNative(fromEntries);\n  assert.nonEnumerable(Object, 'fromEntries');\n  assert.true(fromEntries([]) instanceof Object);\n  assert.same(fromEntries([['foo', 1]]).foo, 1);\n  assert.same(fromEntries(createIterable([['bar', 2]])).bar, 2);\n\n  class Unit {\n    constructor(id) {\n      this.id = id;\n    }\n\n    toString() {\n      return `unit${this.id}`;\n    }\n\n  }\n\n  const units = new Set([new Unit(101), new Unit(102), new Unit(103)]);\n  const object = fromEntries(units.entries());\n  assert.same(object.unit101.id, 101);\n  assert.same(object.unit102.id, 102);\n  assert.same(object.unit103.id, 103);\n});","file":"tests/es.object.from-entries.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptor","suites":[],"line":2,"code":"QUnit.test('Object.getOwnPropertyDescriptor', assert => {\n  const {\n    getOwnPropertyDescriptor\n  } = Object;\n  assert.isFunction(getOwnPropertyDescriptor);\n  assert.arity(getOwnPropertyDescriptor, 2);\n  assert.name(getOwnPropertyDescriptor, 'getOwnPropertyDescriptor');\n  assert.looksNative(getOwnPropertyDescriptor);\n  assert.nonEnumerable(Object, 'getOwnPropertyDescriptor');\n  assert.deepEqual(getOwnPropertyDescriptor({\n    q: 42\n  }, 'q'), {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value: 42\n  });\n  assert.same(getOwnPropertyDescriptor({}, 'toString'), undefined);\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertyDescriptor(value) || true, `accept ${typeof value}`);\n  }\n\n  assert.throws(() => getOwnPropertyDescriptor(null), TypeError, 'throws on null');\n  assert.throws(() => getOwnPropertyDescriptor(undefined), TypeError, 'throws on undefined');\n});","file":"tests/es.object.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptor.sham flag","suites":[],"line":29,"code":"QUnit.test('Object.getOwnPropertyDescriptor.sham flag', assert => {\n  assert.same(Object.getOwnPropertyDescriptor.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.object.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptors","suites":[],"line":2,"code":"QUnit.test('Object.getOwnPropertyDescriptors', assert => {\n  const {\n    create,\n    getOwnPropertyDescriptors\n  } = Object;\n  assert.isFunction(getOwnPropertyDescriptors);\n  assert.arity(getOwnPropertyDescriptors, 1);\n  assert.name(getOwnPropertyDescriptors, 'getOwnPropertyDescriptors');\n  assert.looksNative(getOwnPropertyDescriptors);\n  assert.nonEnumerable(Object, 'getOwnPropertyDescriptors');\n  const object = create({\n    q: 1\n  }, {\n    e: {\n      value: 3\n    }\n  });\n  object.w = 2;\n  const symbol = Symbol('4');\n  object[symbol] = 4;\n  const descriptors = getOwnPropertyDescriptors(object);\n  assert.same(descriptors.q, undefined);\n  assert.deepEqual(descriptors.w, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 2\n  });\n\n  if (DESCRIPTORS) {\n    assert.deepEqual(descriptors.e, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: 3\n    });\n  } else {\n    assert.deepEqual(descriptors.e, {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n  }\n\n  assert.same(descriptors[symbol].value, 4);\n});","file":"tests/es.object.get-own-property-descriptors.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyDescriptors.sham flag","suites":[],"line":49,"code":"QUnit.test('Object.getOwnPropertyDescriptors.sham flag', assert => {\n  assert.same(Object.getOwnPropertyDescriptors.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.object.get-own-property-descriptors.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertyNames","suites":[],"line":3,"code":"QUnit.test('Object.getOwnPropertyNames', assert => {\n  const {\n    freeze,\n    getOwnPropertyNames\n  } = Object;\n  assert.isFunction(getOwnPropertyNames);\n  assert.arity(getOwnPropertyNames, 1);\n  assert.name(getOwnPropertyNames, 'getOwnPropertyNames');\n  assert.looksNative(getOwnPropertyNames);\n  assert.nonEnumerable(Object, 'getOwnPropertyNames');\n\n  function F1() {\n    this.w = 1;\n  }\n\n  function F2() {\n    this.toString = 1;\n  }\n\n  F1.prototype.q = F2.prototype.q = 1;\n  const names = getOwnPropertyNames([1, 2, 3]);\n  assert.same(names.length, 4);\n  assert.true(includes(names, '0'));\n  assert.true(includes(names, '1'));\n  assert.true(includes(names, '2'));\n  assert.true(includes(names, 'length'));\n  assert.deepEqual(getOwnPropertyNames(new F1()), ['w']);\n  assert.deepEqual(getOwnPropertyNames(new F2()), ['toString']);\n  assert.true(includes(getOwnPropertyNames(Array.prototype), 'toString'));\n  assert.true(includes(getOwnPropertyNames(Object.prototype), 'toString'));\n  assert.true(includes(getOwnPropertyNames(Object.prototype), 'constructor'));\n  assert.deepEqual(getOwnPropertyNames(freeze({})), [], 'frozen');\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertyNames(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => {\n    getOwnPropertyNames(null);\n  }, TypeError, 'throws on null');\n  assert.throws(() => {\n    getOwnPropertyNames(undefined);\n  }, TypeError, 'throws on undefined');\n\n  if (GLOBAL.document) {\n    assert.notThrows(() => {\n      const iframe = document.createElement('iframe');\n      iframe.src = 'http://example.com';\n      document.documentElement.appendChild(iframe);\n      const window = iframe.contentWindow;\n      document.documentElement.removeChild(iframe);\n      return getOwnPropertyNames(window);\n    }, 'IE11 bug with iframe and window');\n  }\n});","file":"tests/es.object.get-own-property-names.js","skipped":false,"dir":"tests"},{"name":"Object.getOwnPropertySymbols","suites":[],"line":6,"code":"QUnit.test('Object.getOwnPropertySymbols', assert => {\n  assert.isFunction(getOwnPropertySymbols);\n  assert.nonEnumerable(Object, 'getOwnPropertySymbols');\n  assert.same(getOwnPropertySymbols.length, 1, 'arity is 1');\n  assert.name(getOwnPropertySymbols, 'getOwnPropertySymbols');\n  assert.looksNative(getOwnPropertySymbols);\n  const prototype = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  prototype[Symbol()] = 42;\n  prototype[Symbol()] = 43;\n  assert.deepEqual(getOwnPropertyNames(prototype).sort(), ['e', 'q', 'w']);\n  assert.same(getOwnPropertySymbols(prototype).length, 2);\n  const object = create(prototype);\n  object.a = 1;\n  object.s = 2;\n  object.d = 3;\n  object[Symbol()] = 44;\n  assert.deepEqual(getOwnPropertyNames(object).sort(), ['a', 'd', 's']);\n  assert.same(getOwnPropertySymbols(object).length, 1);\n  assert.same(getOwnPropertySymbols(Object.prototype).length, 0);\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getOwnPropertySymbols(value), `accept ${typeof value}`);\n  }\n});","file":"tests/es.object.get-own-property-symbols.js","skipped":false,"dir":"tests"},{"name":"Object.getPrototypeOf","suites":[],"line":2,"code":"QUnit.test('Object.getPrototypeOf', assert => {\n  const {\n    create,\n    getPrototypeOf\n  } = Object;\n  assert.isFunction(getPrototypeOf);\n  assert.arity(getPrototypeOf, 1);\n  assert.name(getPrototypeOf, 'getPrototypeOf');\n  assert.looksNative(getPrototypeOf);\n  assert.nonEnumerable(Object, 'getPrototypeOf');\n  assert.same(getPrototypeOf({}), Object.prototype);\n  assert.same(getPrototypeOf([]), Array.prototype);\n\n  function F() {\n    /* empty */\n  }\n\n  assert.same(getPrototypeOf(new F()), F.prototype);\n  const object = {\n    q: 1\n  };\n  assert.same(getPrototypeOf(create(object)), object);\n  assert.same(getPrototypeOf(create(null)), null);\n  assert.same(getPrototypeOf(getPrototypeOf({})), null);\n\n  function Foo() {\n    /* empty */\n  }\n\n  Foo.prototype.foo = 'foo';\n\n  function Bar() {\n    /* empty */\n  }\n\n  Bar.prototype = create(Foo.prototype);\n  Bar.prototype.constructor = Bar;\n  assert.same(getPrototypeOf(Bar.prototype).foo, 'foo');\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => getPrototypeOf(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => getPrototypeOf(null), TypeError, 'throws on null');\n  assert.throws(() => getPrototypeOf(undefined), TypeError, 'throws on undefined');\n  assert.same(getPrototypeOf('foo'), String.prototype);\n});","file":"tests/es.object.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object.getPrototypeOf.sham flag","suites":[],"line":50,"code":"QUnit.test('Object.getPrototypeOf.sham flag', assert => {\n  assert.same(Object.getPrototypeOf.sham, CORRECT_PROTOTYPE_GETTER ? undefined : true);\n});","file":"tests/es.object.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object.hasOwn","suites":[],"line":1,"code":"QUnit.test('Object.hasOwn', assert => {\n  const {\n    create,\n    hasOwn\n  } = Object;\n  assert.isFunction(hasOwn);\n  assert.arity(hasOwn, 2);\n  assert.name(hasOwn, 'hasOwn');\n  assert.looksNative(hasOwn);\n  assert.nonEnumerable(Object, 'hasOwn');\n  assert.true(hasOwn({\n    q: 42\n  }, 'q'));\n  assert.false(hasOwn({\n    q: 42\n  }, 'w'));\n  assert.false(hasOwn(create({\n    q: 42\n  }), 'q'));\n  assert.true(hasOwn(Object.prototype, 'hasOwnProperty'));\n  let called = false;\n\n  try {\n    hasOwn(null, {\n      toString() {\n        called = true;\n      }\n\n    });\n  } catch {\n    /* empty */\n  }\n\n  assert.false(called, 'modern behaviour');\n  assert.throws(() => hasOwn(null, 'foo'), TypeError, 'throws on null');\n  assert.throws(() => hasOwn(undefined, 'foo'), TypeError, 'throws on undefined');\n});","file":"tests/es.object.has-own.js","skipped":false,"dir":"tests"},{"name":"Object.isExtensible","suites":[],"line":2,"code":"QUnit.test('Object.isExtensible', assert => {\n  const {\n    preventExtensions,\n    isExtensible\n  } = Object;\n  assert.isFunction(isExtensible);\n  assert.arity(isExtensible, 1);\n  assert.name(isExtensible, 'isExtensible');\n  assert.nonEnumerable(Object, 'isExtensible');\n  assert.looksNative(isExtensible);\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isExtensible(value) || true, `accept ${value}`);\n    assert.false(isExtensible(value), `returns true on ${value}`);\n  }\n\n  assert.true(isExtensible({}));\n  if (NATIVE) assert.false(isExtensible(preventExtensions({})));\n});","file":"tests/es.object.is-extensible.js","skipped":false,"dir":"tests"},{"name":"Object.isFrozen","suites":[],"line":2,"code":"QUnit.test('Object.isFrozen', assert => {\n  const {\n    freeze,\n    isFrozen\n  } = Object;\n  assert.isFunction(isFrozen);\n  assert.arity(isFrozen, 1);\n  assert.name(isFrozen, 'isFrozen');\n  assert.looksNative(isFrozen);\n  assert.nonEnumerable(Object, 'isFrozen');\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isFrozen(value) || true, `accept ${value}`);\n    assert.true(isFrozen(value), `returns true on ${value}`);\n  }\n\n  assert.false(isFrozen({}));\n  if (NATIVE) assert.true(isFrozen(freeze({})));\n});","file":"tests/es.object.is-frozen.js","skipped":false,"dir":"tests"},{"name":"Object.isSealed","suites":[],"line":2,"code":"QUnit.test('Object.isSealed', assert => {\n  const {\n    seal,\n    isSealed\n  } = Object;\n  assert.isFunction(isSealed);\n  assert.arity(isSealed, 1);\n  assert.name(isSealed, 'isSealed');\n  assert.looksNative(isSealed);\n  assert.nonEnumerable(Object, 'isSealed');\n  const primitives = [42, 'string', false, null, undefined];\n\n  for (const value of primitives) {\n    assert.notThrows(() => isSealed(value) || true, `accept ${value}`);\n    assert.true(isSealed(value), `returns true on ${value}`);\n  }\n\n  assert.false(isSealed({}));\n  if (NATIVE) assert.true(isSealed(seal({})));\n});","file":"tests/es.object.is-sealed.js","skipped":false,"dir":"tests"},{"name":"Object.is","suites":[],"line":1,"code":"QUnit.test('Object.is', assert => {\n  const {\n    is\n  } = Object;\n  assert.isFunction(is);\n  assert.arity(is, 2);\n  assert.name(is, 'is');\n  assert.looksNative(is);\n  assert.nonEnumerable(Object, 'is');\n  assert.true(is(1, 1), '1 is 1');\n  assert.true(is(NaN, NaN), '1 is 1');\n  assert.false(is(0, -0), '0 isnt -0');\n  assert.false(is({}, {}), '{} isnt {}');\n});","file":"tests/es.object.is.js","skipped":false,"dir":"tests"},{"name":"Object.keys","suites":[],"line":2,"code":"QUnit.test('Object.keys', assert => {\n  const {\n    keys\n  } = Object;\n  assert.isFunction(keys);\n  assert.arity(keys, 1);\n  assert.name(keys, 'keys');\n  assert.looksNative(keys);\n  assert.nonEnumerable(Object, 'keys');\n\n  function F1() {\n    this.w = 1;\n  }\n\n  function F2() {\n    this.toString = 1;\n  }\n\n  F1.prototype.q = F2.prototype.q = 1;\n  assert.deepEqual(keys([1, 2, 3]), ['0', '1', '2']);\n  assert.deepEqual(keys(new F1()), ['w']);\n  assert.deepEqual(keys(new F2()), ['toString']);\n  assert.false(includes(keys(Array.prototype), 'push'));\n  const primitives = [42, 'foo', false];\n\n  for (const value of primitives) {\n    assert.notThrows(() => keys(value), `accept ${typeof value}`);\n  }\n\n  assert.throws(() => keys(null), TypeError, 'throws on null');\n  assert.throws(() => keys(undefined), TypeError, 'throws on undefined');\n});","file":"tests/es.object.keys.js","skipped":false,"dir":"tests"},{"name":"Object#__lookupGetter__","suites":[],"line":4,"code":"  QUnit.test('Object#__lookupGetter__', assert => {\n    const {\n      __lookupGetter__\n    } = Object.prototype;\n    const {\n      create\n    } = Object;\n    assert.isFunction(__lookupGetter__);\n    assert.arity(__lookupGetter__, 1);\n    assert.name(__lookupGetter__, '__lookupGetter__');\n    assert.looksNative(__lookupGetter__);\n    assert.nonEnumerable(Object.prototype, '__lookupGetter__');\n    assert.same({}.__lookupGetter__('key'), undefined, 'empty object');\n    assert.same({\n      key: 42\n    }.__lookupGetter__('key'), undefined, 'data descriptor');\n    const object = {};\n\n    function setter() {\n      /* empty */\n    }\n\n    object.__defineGetter__('key', setter);\n\n    assert.same(object.__lookupGetter__('key'), setter, 'own getter');\n    assert.same(create(object).__lookupGetter__('key'), setter, 'proto getter');\n    assert.same(create(object).__lookupGetter__('foo'), undefined, 'empty proto');\n\n    if (STRICT) {\n      assert.throws(() => __lookupGetter__.call(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __lookupGetter__.call(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"tests/es.object.lookup-getter.js","skipped":false,"dir":"tests"},{"name":"Object#__lookupSetter__","suites":[],"line":4,"code":"  QUnit.test('Object#__lookupSetter__', assert => {\n    const {\n      __lookupSetter__\n    } = Object.prototype;\n    const {\n      create\n    } = Object;\n    assert.isFunction(__lookupSetter__);\n    assert.arity(__lookupSetter__, 1);\n    assert.name(__lookupSetter__, '__lookupSetter__');\n    assert.looksNative(__lookupSetter__);\n    assert.nonEnumerable(Object.prototype, '__lookupSetter__');\n    assert.same({}.__lookupSetter__('key'), undefined, 'empty object');\n    assert.same({\n      key: 42\n    }.__lookupSetter__('key'), undefined, 'data descriptor');\n    const object = {};\n\n    function setter() {\n      /* empty */\n    }\n\n    object.__defineSetter__('key', setter);\n\n    assert.same(object.__lookupSetter__('key'), setter, 'own getter');\n    assert.same(create(object).__lookupSetter__('key'), setter, 'proto getter');\n    assert.same(create(object).__lookupSetter__('foo'), undefined, 'empty proto');\n\n    if (STRICT) {\n      assert.throws(() => __lookupSetter__.call(null, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on null as `this`');\n      assert.throws(() => __lookupSetter__.call(undefined, 1, () => {\n        /* empty */\n      }), TypeError, 'Throws on undefined as `this`');\n    }\n  });","file":"tests/es.object.lookup-setter.js","skipped":false,"dir":"tests"},{"name":"Object.preventExtensions","suites":[],"line":2,"code":"QUnit.test('Object.preventExtensions', assert => {\n  const {\n    preventExtensions,\n    keys,\n    isExtensible,\n    getOwnPropertyNames,\n    getOwnPropertySymbols\n  } = Object;\n  const {\n    ownKeys\n  } = GLOBAL.Reflect || {};\n  assert.isFunction(preventExtensions);\n  assert.arity(preventExtensions, 1);\n  assert.name(preventExtensions, 'preventExtensions');\n  assert.looksNative(preventExtensions);\n  assert.nonEnumerable(Object, 'preventExtensions');\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => preventExtensions(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(preventExtensions(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  if (NATIVE) assert.false(isExtensible(preventExtensions({})));\n  const results = [];\n\n  for (const key in preventExtensions({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(preventExtensions({})), []);\n  assert.arrayEqual(getOwnPropertyNames(preventExtensions({})), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(preventExtensions({})), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(preventExtensions({})), []);\n});","file":"tests/es.object.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Object.seal","suites":[],"line":2,"code":"QUnit.test('Object.seal', assert => {\n  const {\n    seal,\n    isSealed,\n    keys,\n    getOwnPropertyNames,\n    getOwnPropertySymbols\n  } = Object;\n  const {\n    ownKeys\n  } = GLOBAL.Reflect || {};\n  assert.isFunction(seal);\n  assert.arity(seal, 1);\n  assert.name(seal, 'seal');\n  assert.looksNative(seal);\n  assert.nonEnumerable(Object, 'seal');\n  const data = [42, 'foo', false, null, undefined, {}];\n\n  for (const value of data) {\n    assert.notThrows(() => seal(value) || true, `accept ${{}.toString.call(value).slice(8, -1)}`);\n    assert.same(seal(value), value, `returns target on ${{}.toString.call(value).slice(8, -1)}`);\n  }\n\n  if (NATIVE) assert.true(isSealed(seal({})));\n  const results = [];\n\n  for (const key in seal({})) results.push(key);\n\n  assert.arrayEqual(results, []);\n  assert.arrayEqual(keys(seal({})), []);\n  assert.arrayEqual(getOwnPropertyNames(seal({})), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(seal({})), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(seal({})), []);\n});","file":"tests/es.object.seal.js","skipped":false,"dir":"tests"},{"name":"Object.setPrototypeOf","suites":[],"line":2,"code":"if (PROTO) QUnit.test('Object.setPrototypeOf', assert => {\n  const {\n    setPrototypeOf\n  } = Object;\n  assert.isFunction(setPrototypeOf);\n  assert.arity(setPrototypeOf, 2);\n  assert.name(setPrototypeOf, 'setPrototypeOf');\n  assert.looksNative(setPrototypeOf);\n  assert.nonEnumerable(Object, 'setPrototypeOf');\n  assert.true('apply' in setPrototypeOf({}, Function.prototype), 'Parent properties in target');\n  assert.same(setPrototypeOf({\n    a: 2\n  }, {\n    b() {\n      return this.a ** 2;\n    }\n\n  }).b(), 4, 'Child and parent properties in target');\n  const object = {};\n  assert.same(setPrototypeOf(object, {\n    a: 1\n  }), object, 'setPrototypeOf return target');\n  assert.false('toString' in setPrototypeOf({}, null), 'Can set null as prototype');\n});","file":"tests/es.object.set-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Object#toString","suites":[],"line":2,"code":"QUnit.test('Object#toString', assert => {\n  const {\n    toString\n  } = Object.prototype;\n  const Symbol = GLOBAL.Symbol || {};\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  assert.looksNative(toString);\n  assert.nonEnumerable(Object.prototype, 'toString');\n\n  if (STRICT) {\n    assert.same(toString.call(null), '[object Null]', 'null -> `Null`');\n    assert.same(toString.call(undefined), '[object Undefined]', 'undefined -> `Undefined`');\n  }\n\n  assert.same(toString.call(true), '[object Boolean]', 'bool -> `Boolean`');\n  assert.same(toString.call('string'), '[object String]', 'string -> `String`');\n  assert.same(toString.call(7), '[object Number]', 'number -> `Number`');\n  assert.same(`${{}}`, '[object Object]', '{} -> `Object`');\n  assert.same(toString.call([]), '[object Array]', ' [] -> `Array`');\n  assert.same(toString.call(() => {\n    /* empty */\n  }), '[object Function]', 'function -> `Function`');\n  assert.same(toString.call(/./), '[object RegExp]', 'regexp -> `RegExp`');\n  assert.same(toString.call(new TypeError()), '[object Error]', 'new TypeError -> `Error`');\n  assert.same(toString.call(function () {\n    return arguments;\n  }()), '[object Arguments]', 'arguments -> `Arguments`');\n  const constructors = ['Array', 'RegExp', 'Boolean', 'String', 'Number', 'Error', 'Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array', 'ArrayBuffer'];\n\n  for (const name of constructors) {\n    const Constructor = GLOBAL[name];\n\n    if (Constructor) {\n      assert.same(toString.call(new Constructor(1)), `[object ${name}]`, `new ${name}(1) -> \\`${name}\\``);\n    }\n  }\n\n  if (GLOBAL.DataView) {\n    assert.same(`${new DataView(new ArrayBuffer(1))}`, '[object DataView]', 'dataview -> `DataView`');\n  }\n\n  if (GLOBAL.Set) {\n    assert.same(`${new Set()}`, '[object Set]', 'set -> `Set`');\n  }\n\n  if (GLOBAL.Map) {\n    assert.same(`${new Map()}`, '[object Map]', 'map -> `Map`');\n  }\n\n  if (GLOBAL.WeakSet) {\n    assert.same(`${new WeakSet()}`, '[object WeakSet]', 'weakset -> `WeakSet`');\n  }\n\n  if (GLOBAL.WeakMap) {\n    assert.same(`${new WeakMap()}`, '[object WeakMap]', 'weakmap -> `WeakMap`');\n  }\n\n  if (GLOBAL.Promise) {\n    assert.same(`${new Promise(() => {\n      /* empty */\n    })}`, '[object Promise]', 'promise -> `Promise`');\n  }\n\n  if (''[Symbol.iterator]) {\n    assert.same(`${''[Symbol.iterator]()}`, '[object String Iterator]', 'String Iterator -> `String Iterator`');\n  }\n\n  if ([].entries) {\n    assert.same(`${[].entries()}`, '[object Array Iterator]', 'Array Iterator -> `Array Iterator`');\n  }\n\n  if (GLOBAL.Set && Set.entries) {\n    assert.same(`${new Set().entries()}`, '[object Set Iterator]', 'Set Iterator -> `Set Iterator`');\n  }\n\n  if (GLOBAL.Map && Map.entries) {\n    assert.same(`${new Map().entries()}`, '[object Map Iterator]', 'Map Iterator -> `Map Iterator`');\n  }\n\n  assert.same(`${Math}`, '[object Math]', 'Math -> `Math`');\n\n  if (GLOBAL.JSON) {\n    assert.same(`${JSON}`, '[object JSON]', 'JSON -> `JSON`');\n  }\n\n  function Class() {\n    /* empty */\n  }\n\n  Class.prototype[Symbol.toStringTag] = 'Class';\n  assert.same(`${new Class()}`, '[object Class]', 'user class instance -> [Symbol.toStringTag]');\n});","file":"tests/es.object.to-string.js","skipped":false,"dir":"tests"},{"name":"Object.values","suites":[],"line":1,"code":"QUnit.test('Object.values', assert => {\n  const {\n    values,\n    create,\n    assign\n  } = Object;\n  assert.isFunction(values);\n  assert.arity(values, 1);\n  assert.name(values, 'values');\n  assert.looksNative(values);\n  assert.nonEnumerable(Object, 'values');\n  assert.deepEqual(values({\n    q: 1,\n    w: 2,\n    e: 3\n  }), [1, 2, 3]);\n  assert.deepEqual(values(new String('qwe')), ['q', 'w', 'e']);\n  assert.deepEqual(values(assign(create({\n    q: 1,\n    w: 2,\n    e: 3\n  }), {\n    a: 4,\n    s: 5,\n    d: 6\n  })), [4, 5, 6]);\n  assert.deepEqual(values({\n    valueOf: 42\n  }), [42], 'IE enum keys bug');\n\n  try {\n    assert.deepEqual(Function('values', `\n      return values({ a: 1, get b() {\n        delete this.c;\n        return 2;\n      }, c: 3 });\n    `)(values), [1, 2]);\n  } catch {\n    /* empty */\n  }\n\n  try {\n    assert.deepEqual(Function('values', `\n      return values({ a: 1, get b() {\n        Object.defineProperty(this, \"c\", {\n          value: 4,\n          enumerable: false\n        });\n        return 2;\n      }, c: 3 });\n    `)(values), [1, 2]);\n  } catch {\n    /* empty */\n  }\n});","file":"tests/es.object.values.js","skipped":false,"dir":"tests"},{"name":"parseFloat","suites":[],"line":2,"code":"QUnit.test('parseFloat', assert => {\n  assert.isFunction(parseFloat);\n  assert.name(parseFloat, 'parseFloat');\n  assert.arity(parseFloat, 1);\n  assert.looksNative(parseFloat);\n  assert.same(parseFloat('0'), 0);\n  assert.same(parseFloat(' 0'), 0);\n  assert.same(parseFloat('+0'), 0);\n  assert.same(parseFloat(' +0'), 0);\n  assert.same(parseFloat('-0'), -0);\n  assert.same(parseFloat(' -0'), -0);\n  assert.same(parseFloat(`${WHITESPACES}+0`), 0);\n  assert.same(parseFloat(`${WHITESPACES}-0`), -0);\n  assert.same(parseFloat(null), NaN);\n  assert.same(parseFloat(undefined), NaN);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => parseFloat(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseFloat(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"tests/es.parse-float.js","skipped":false,"dir":"tests"},{"name":"parseInt","suites":[],"line":4,"code":"QUnit.test('parseInt', assert => {\n  assert.isFunction(parseInt);\n  assert.name(parseInt, 'parseInt');\n  assert.arity(parseInt, 2);\n  assert.looksNative(parseInt);\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(parseInt('10', radix), radix, `radix ${radix}`);\n  }\n\n  const strings = ['01', '08', '10', '42'];\n\n  for (const string of strings) {\n    assert.same(parseInt(string), parseInt(string, 10), `default radix is 10: ${string}`);\n  }\n\n  assert.same(parseInt('0x16'), parseInt('0x16', 16), 'default radix is 16: 0x16');\n  assert.same(parseInt('  0x16'), parseInt('0x16', 16), 'ignores leading whitespace #1');\n  assert.same(parseInt('  42'), parseInt('42', 10), 'ignores leading whitespace #2');\n  assert.same(parseInt('  08'), parseInt('08', 10), 'ignores leading whitespace #3');\n  assert.same(parseInt(`${WHITESPACES}08`), parseInt('08', 10), 'ignores leading whitespace #4');\n  assert.same(parseInt(`${WHITESPACES}0x16`), parseInt('0x16', 16), 'ignores leading whitespace #5');\n  const fakeZero = {\n    valueOf() {\n      return 0;\n    }\n\n  };\n  assert.same(parseInt('08', fakeZero), parseInt('08', 10), 'valueOf #1');\n  assert.same(parseInt('0x16', fakeZero), parseInt('0x16', 16), 'valueOf #2');\n  assert.same(parseInt('-0xF'), -15, 'signed hex #1');\n  assert.same(parseInt('-0xF', 16), -15, 'signed hex #2');\n  assert.same(parseInt('+0xF'), 15, 'signed hex #3');\n  assert.same(parseInt('+0xF', 16), 15, 'signed hex #4');\n  assert.same(parseInt('10', -4294967294), 2, 'radix uses ToUint32');\n  assert.same(parseInt(null), NaN);\n  assert.same(parseInt(undefined), NaN);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => parseInt(Symbol()), 'throws on symbol argument');\n    assert.throws(() => parseInt(Object(Symbol())), 'throws on boxed symbol argument');\n  }\n});","file":"tests/es.parse-int.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled","suites":[],"line":1,"code":"QUnit.test('Promise.allSettled', assert => {\n  assert.isFunction(Promise.allSettled);\n  assert.arity(Promise.allSettled, 1);\n  assert.looksNative(Promise.allSettled);\n  assert.nonEnumerable(Promise, 'allSettled');\n  assert.true(Promise.allSettled([1, 2, 3]) instanceof Promise, 'returns a promise');\n});","file":"tests/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled, resolved","suites":[],"line":8,"code":"QUnit.test('Promise.allSettled, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.allSettled([Promise.resolve(1), Promise.reject(2), Promise.resolve(3)]).then(it => {\n    assert.deepEqual(it, [{\n      value: 1,\n      status: 'fulfilled'\n    }, {\n      reason: 2,\n      status: 'rejected'\n    }, {\n      value: 3,\n      status: 'fulfilled'\n    }], 'resolved with a correct value');\n    async();\n  });\n});","file":"tests/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.allSettled, rejected","suites":[],"line":25,"code":"QUnit.test('Promise.allSettled, rejected', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.allSettled().catch(() => {\n    assert.required('rejected as expected');\n    async();\n  });\n});","file":"tests/es.promise.all-settled.js","skipped":false,"dir":"tests"},{"name":"Promise.all","suites":[],"line":2,"code":"QUnit.test('Promise.all', assert => {\n  let FakePromise1, FakePromise2;\n  const {\n    all,\n    resolve\n  } = Promise;\n  assert.isFunction(all);\n  assert.arity(all, 1);\n  assert.name(all, 'all');\n  assert.looksNative(all);\n  assert.nonEnumerable(Promise, 'all');\n  const iterable = createIterable([1, 2, 3]);\n  Promise.all(iterable).catch(() => {\n    /* empty */\n  });\n  assert.true(iterable.received, 'works with iterables: iterator received');\n  assert.true(iterable.called, 'works with iterables: next called');\n  const array = [];\n  let done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  Promise.all(array);\n  assert.true(done);\n  assert.throws(() => {\n    all.call(null, []).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n  done = false;\n\n  try {\n    Promise.resolve = function () {\n      throw new Error();\n    };\n\n    Promise.all(createIterable([1, 2, 3], {\n      return() {\n        done = true;\n      }\n\n    })).catch(() => {\n      /* empty */\n    });\n  } catch (error) {\n    /* empty */\n  }\n\n  Promise.resolve = resolve;\n  assert.true(done, 'iteration closing');\n\n  FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = resolve.bind(Promise);\n  assert.true(all.call(FakePromise1, [1, 2, 3]) instanceof FakePromise1, 'subclassing, `this` pattern');\n\n  FakePromise1 = function () {\n    /* empty */\n  };\n\n  FakePromise2 = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise3 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = FakePromise3.resolve = resolve.bind(Promise);\n  assert.throws(() => {\n    all.call(FakePromise1, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    all.call(FakePromise2, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    all.call(FakePromise3, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"tests/es.promise.all.js","skipped":false,"dir":"tests"},{"name":"Promise.any","suites":[],"line":1,"code":"QUnit.test('Promise.any', assert => {\n  assert.isFunction(Promise.any);\n  assert.arity(Promise.any, 1);\n  assert.looksNative(Promise.any);\n  assert.nonEnumerable(Promise, 'any');\n  assert.true(Promise.any([1, 2, 3]) instanceof Promise, 'returns a promise');\n});","file":"tests/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, resolved","suites":[],"line":8,"code":"QUnit.test('Promise.any, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.any([Promise.resolve(1), Promise.reject(2), Promise.resolve(3)]).then(it => {\n    assert.same(it, 1, 'resolved with a correct value');\n    async();\n  });\n});","file":"tests/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #1","suites":[],"line":16,"code":"QUnit.test('Promise.any, rejected #1', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  Promise.any([Promise.reject(1), Promise.reject(2), Promise.reject(3)]).catch(error => {\n    assert.true(error instanceof AggregateError, 'instanceof AggregateError');\n    assert.deepEqual(error.errors, [1, 2, 3], 'rejected with a correct value');\n    async();\n  });\n});","file":"tests/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #2","suites":[],"line":25,"code":"QUnit.test('Promise.any, rejected #2', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.any().catch(() => {\n    assert.required('rejected as expected');\n    async();\n  });\n});","file":"tests/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise.any, rejected #3","suites":[],"line":33,"code":"QUnit.test('Promise.any, rejected #3', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  Promise.any([]).catch(error => {\n    assert.true(error instanceof AggregateError, 'instanceof AggregateError');\n    assert.deepEqual(error.errors, [], 'rejected with a correct value');\n    async();\n  });\n});","file":"tests/es.promise.any.js","skipped":false,"dir":"tests"},{"name":"Promise#catch","suites":[],"line":2,"code":"QUnit.test('Promise#catch', assert => {\n  assert.isFunction(Promise.prototype.catch);\n  if (NATIVE) assert.arity(Promise.prototype.catch, 1);\n  if (NATIVE) assert.name(Promise.prototype.catch, 'catch');\n  assert.looksNative(Promise.prototype.catch);\n  assert.nonEnumerable(Promise.prototype, 'catch');\n  let promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  let FakePromise1 = promise.constructor = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.catch(() => {\n    /* empty */\n  }) instanceof FakePromise2, 'subclassing, @@species pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.catch(() => {\n    /* empty */\n  }) instanceof Promise, 'subclassing, incorrect `this` pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1[Symbol.species] = function () {\n    /* empty */\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #1');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #2');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  assert.throws(() => {\n    promise.catch(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #3');\n  assert.same(Promise.prototype.catch.call({\n    // eslint-disable-next-line unicorn/no-thenable -- required for testing\n    then(x, y) {\n      return y;\n    }\n\n  }, 42), 42, 'calling `.then`');\n});","file":"tests/es.promise.catch.js","skipped":false,"dir":"tests"},{"name":"Promise","suites":[],"line":7,"code":"QUnit.test('Promise', assert => {\n  assert.isFunction(Promise);\n  assert.arity(Promise, 1);\n  assert.name(Promise, 'Promise');\n  assert.looksNative(Promise);\n  assert.throws(() => {\n    Promise();\n  }, 'throws w/o `new`');\n  new Promise(function (resolve, reject) {\n    assert.isFunction(resolve, 'resolver is function');\n    assert.isFunction(reject, 'rejector is function');\n    if (STRICT) assert.same(this, undefined, 'correct executor context');\n  });\n});","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise operations order","suites":[],"line":21,"code":"if (DESCRIPTORS) QUnit.test('Promise operations order', assert => {\n  let $resolve, $resolve2;\n  assert.expect(1);\n  const EXPECTED_ORDER = 'DEHAFGBC';\n  const async = assert.async();\n  let result = '';\n  const promise1 = new Promise(resolve => {\n    $resolve = resolve;\n  });\n  $resolve({\n    // eslint-disable-next-line unicorn/no-thenable -- required for testing\n    then() {\n      result += 'A';\n      throw Error();\n    }\n\n  });\n  promise1.catch(() => {\n    result += 'B';\n  });\n  promise1.catch(() => {\n    result += 'C';\n    assert.same(result, EXPECTED_ORDER);\n    async();\n  });\n  const promise2 = new Promise(resolve => {\n    $resolve2 = resolve;\n  }); // eslint-disable-next-line unicorn/no-thenable -- required for testing\n\n  $resolve2(Object.defineProperty({}, 'then', {\n    get() {\n      result += 'D';\n      throw Error();\n    }\n\n  }));\n  result += 'E';\n  promise2.catch(() => {\n    result += 'F';\n  });\n  promise2.catch(() => {\n    result += 'G';\n  });\n  result += 'H';\n  setTimeout(() => {\n    if (!~result.indexOf('C')) {\n      assert.same(result, EXPECTED_ORDER);\n      async();\n    }\n  }, 1e3);\n});","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#then","suites":[],"line":72,"code":"QUnit.test('Promise#then', assert => {\n  assert.isFunction(Promise.prototype.then);\n  if (NATIVE) assert.arity(Promise.prototype.then, 2);\n  assert.name(Promise.prototype.then, 'then');\n  assert.looksNative(Promise.prototype.then);\n  assert.nonEnumerable(Promise.prototype, 'then');\n  let promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  let FakePromise1 = promise.constructor = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.then(() => {\n    /* empty */\n  }) instanceof FakePromise2, 'subclassing, @@species pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(promise.then(() => {\n    /* empty */\n  }) instanceof Promise, 'subclassing, incorrect `this` pattern');\n  promise = new Promise(resolve => {\n    resolve(42);\n  });\n\n  promise.constructor = FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1[Symbol.species] = function () {\n    /* empty */\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #1');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #2');\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  assert.throws(() => {\n    promise.then(() => {\n      /* empty */\n    });\n  }, 'NewPromiseCapability validations, #3');\n});","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#@@toStringTag","suites":[],"line":162,"code":"QUnit.test('Promise#@@toStringTag', assert => {\n  assert.same(Promise.prototype[Symbol.toStringTag], 'Promise', 'Promise::@@toStringTag is `Promise`');\n  assert.same(String(new Promise(() => {\n    /* empty */\n  })), '[object Promise]', 'correct stringification');\n});","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise subclassing","suites":[],"line":168,"code":"if (PROTO) QUnit.test('Promise subclassing', assert => {\n  function SubPromise(executor) {\n    const self = new Promise(executor);\n    setPrototypeOf(self, SubPromise.prototype);\n    self.mine = 'subclass';\n    return self;\n  }\n\n  setPrototypeOf(SubPromise, Promise);\n  SubPromise.prototype = create(Promise.prototype);\n  SubPromise.prototype.constructor = SubPromise;\n  let promise1 = SubPromise.resolve(5);\n  assert.same(promise1.mine, 'subclass');\n  promise1 = promise1.then(it => {\n    assert.same(it, 5);\n  });\n  assert.same(promise1.mine, 'subclass');\n  let promise2 = new SubPromise(resolve => {\n    resolve(6);\n  });\n  assert.same(promise2.mine, 'subclass');\n  promise2 = promise2.then(it => {\n    assert.same(it, 6);\n  });\n  assert.same(promise2.mine, 'subclass');\n  const promise3 = SubPromise.all([promise1, promise2]);\n  assert.same(promise3.mine, 'subclass');\n  assert.true(promise3 instanceof Promise);\n  assert.true(promise3 instanceof SubPromise);\n  promise3.then(assert.async(), error => {\n    assert.avoid(error);\n  });\n}); // qunit@2.5 strange bug","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Native Promise, patched","suites":[],"line":283,"code":"if (promise && promise.constructor !== Promise) QUnit.test('Native Promise, patched', assert => {\n  assert.isFunction(promise.then);\n  assert.arity(promise.then, 2);\n  assert.looksNative(promise.then);\n  assert.nonEnumerable(promise.constructor.prototype, 'then');\n\n  function empty() {\n    /* empty */\n  }\n\n  assert.true(promise.then(empty) instanceof Promise, '`.then` returns `Promise` instance #1');\n  assert.true(new promise.constructor(empty).then(empty) instanceof Promise, '`.then` returns `Promise` instance #2');\n  assert.true(promise.catch(empty) instanceof Promise, '`.catch` returns `Promise` instance #1');\n  assert.true(new promise.constructor(empty).catch(empty) instanceof Promise, '`.catch` returns `Promise` instance #2');\n  assert.true(promise.finally(empty) instanceof Promise, '`.finally` returns `Promise` instance #1');\n  assert.true(new promise.constructor(empty).finally(empty) instanceof Promise, '`.finally` returns `Promise` instance #2');\n});","file":"tests/es.promise.constructor.js","skipped":false,"dir":"tests"},{"name":"Promise#finally","suites":[],"line":1,"code":"QUnit.test('Promise#finally', assert => {\n  assert.isFunction(Promise.prototype.finally);\n  assert.arity(Promise.prototype.finally, 1);\n  assert.looksNative(Promise.prototype.finally);\n  assert.nonEnumerable(Promise.prototype, 'finally');\n  assert.true(Promise.resolve(42).finally(() => {\n    /* empty */\n  }) instanceof Promise, 'returns a promise');\n});","file":"tests/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise#finally, resolved","suites":[],"line":10,"code":"QUnit.test('Promise#finally, resolved', assert => {\n  assert.expect(3);\n  const async = assert.async();\n  let called = 0;\n  let argument = null;\n  Promise.resolve(42).finally(it => {\n    called++;\n    argument = it;\n  }).then(it => {\n    assert.same(it, 42, 'resolved with a correct value');\n    assert.same(called, 1, 'onFinally function called one time');\n    assert.same(argument, undefined, 'onFinally function called with a correct argument');\n    async();\n  });\n});","file":"tests/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise#finally, rejected","suites":[],"line":25,"code":"QUnit.test('Promise#finally, rejected', assert => {\n  assert.expect(2);\n  const async = assert.async();\n  let called = 0;\n  let argument = null;\n  Promise.reject(42).finally(it => {\n    called++;\n    argument = it;\n  }).catch(() => {\n    assert.same(called, 1, 'onFinally function called one time');\n    assert.same(argument, undefined, 'onFinally function called with a correct argument');\n    async();\n  });\n});","file":"tests/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Native Promise, patched","suites":[],"line":48,"code":"if (promise && promise.constructor !== Promise) QUnit.test('Native Promise, patched', assert => {\n  assert.isFunction(promise.finally);\n  assert.arity(promise.finally, 1);\n  assert.looksNative(promise.finally);\n  assert.nonEnumerable(promise.constructor.prototype, 'finally');\n\n  function empty() {\n    /* empty */\n  }\n\n  assert.true(promise.finally(empty) instanceof Promise, '`.finally` returns `Promise` instance #1');\n  assert.true(new promise.constructor(empty).finally(empty) instanceof Promise, '`.finally` returns `Promise` instance #2');\n});","file":"tests/es.promise.finally.js","skipped":false,"dir":"tests"},{"name":"Promise.race","suites":[],"line":2,"code":"QUnit.test('Promise.race', assert => {\n  let FakePromise1, FakePromise2;\n  const {\n    race,\n    resolve\n  } = Promise;\n  assert.isFunction(race);\n  assert.arity(race, 1);\n  assert.name(race, 'race');\n  assert.looksNative(race);\n  assert.nonEnumerable(Promise, 'race');\n  const iterable = createIterable([1, 2, 3]);\n  Promise.race(iterable).catch(() => {\n    /* empty */\n  });\n  assert.true(iterable.received, 'works with iterables: iterator received');\n  assert.true(iterable.called, 'works with iterables: next called');\n  const array = [];\n  let done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  Promise.race(array);\n  assert.true(done);\n  assert.throws(() => {\n    race.call(null, []).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n  done = false;\n\n  try {\n    Promise.resolve = function () {\n      throw new Error();\n    };\n\n    Promise.race(createIterable([1, 2, 3], {\n      return() {\n        done = true;\n      }\n\n    })).catch(() => {\n      /* empty */\n    });\n  } catch (error) {\n    /* empty */\n  }\n\n  Promise.resolve = resolve;\n  assert.true(done, 'iteration closing');\n\n  FakePromise1 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise2 = FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = resolve.bind(Promise);\n  assert.true(race.call(FakePromise1, [1, 2, 3]) instanceof FakePromise1, 'subclassing, `this` pattern');\n\n  FakePromise1 = function () {\n    /* empty */\n  };\n\n  FakePromise2 = function (executor) {\n    executor(null, () => {\n      /* empty */\n    });\n  };\n\n  const FakePromise3 = function (executor) {\n    executor(() => {\n      /* empty */\n    }, null);\n  };\n\n  FakePromise1.resolve = FakePromise2.resolve = FakePromise3.resolve = resolve.bind(Promise);\n  assert.throws(() => {\n    race.call(FakePromise1, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    race.call(FakePromise2, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    race.call(FakePromise3, [1, 2, 3]);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"tests/es.promise.race.js","skipped":false,"dir":"tests"},{"name":"Promise.reject","suites":[],"line":2,"code":"QUnit.test('Promise.reject', assert => {\n  const {\n    reject\n  } = Promise;\n  assert.isFunction(reject);\n  if (NATIVE) assert.arity(reject, 1);\n  assert.name(reject, 'reject');\n  assert.looksNative(reject);\n  assert.nonEnumerable(Promise, 'reject');\n  assert.throws(() => {\n    reject.call(null, 1).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n\n  function FakePromise1(executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  }\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(reject.call(FakePromise1, 42) instanceof FakePromise1, 'subclassing, `this` pattern');\n  assert.throws(() => {\n    reject.call(() => {\n      /* empty */\n    }, 42);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    reject.call(executor => {\n      executor(null, () => {\n        /* empty */\n      });\n    }, 42);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    reject.call(executor => {\n      executor(() => {\n        /* empty */\n      }, null);\n    }, 42);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"tests/es.promise.reject.js","skipped":false,"dir":"tests"},{"name":"Promise.resolve","suites":[],"line":2,"code":"QUnit.test('Promise.resolve', assert => {\n  const {\n    resolve\n  } = Promise;\n  assert.isFunction(resolve);\n  if (NATIVE) assert.arity(resolve, 1);\n  assert.name(resolve, 'resolve');\n  assert.looksNative(resolve);\n  assert.nonEnumerable(Promise, 'resolve');\n  assert.throws(() => {\n    resolve.call(null, 1).catch(() => {\n      /* empty */\n    });\n  }, TypeError, 'throws without context');\n\n  function FakePromise1(executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  }\n\n  FakePromise1[Symbol.species] = function (executor) {\n    executor(() => {\n      /* empty */\n    }, () => {\n      /* empty */\n    });\n  };\n\n  assert.true(resolve.call(FakePromise1, 42) instanceof FakePromise1, 'subclassing, `this` pattern');\n  assert.throws(() => {\n    resolve.call(() => {\n      /* empty */\n    }, 42);\n  }, 'NewPromiseCapability validations, #1');\n  assert.throws(() => {\n    resolve.call(executor => {\n      executor(null, () => {\n        /* empty */\n      });\n    }, 42);\n  }, 'NewPromiseCapability validations, #2');\n  assert.throws(() => {\n    resolve.call(executor => {\n      executor(() => {\n        /* empty */\n      }, null);\n    }, 42);\n  }, 'NewPromiseCapability validations, #3');\n});","file":"tests/es.promise.resolve.js","skipped":false,"dir":"tests"},{"name":"Reflect.apply","suites":[],"line":1,"code":"QUnit.test('Reflect.apply', assert => {\n  const {\n    apply\n  } = Reflect;\n  assert.isFunction(apply);\n  assert.arity(apply, 3);\n  assert.name(apply, 'apply');\n  assert.looksNative(apply);\n  assert.nonEnumerable(Reflect, 'apply');\n  assert.same(apply(Array.prototype.push, [1, 2], [3, 4, 5]), 5);\n\n  function f(a, b, c) {\n    return a + b + c;\n  }\n\n  f.apply = 42;\n  assert.same(apply(f, null, ['foo', 'bar', 'baz']), 'foobarbaz', 'works with redefined apply');\n  assert.throws(() => apply(42, null, []), TypeError, 'throws on primitive');\n  assert.throws(() => apply(() => {\n    /* empty */\n  }, null), TypeError, 'throws without third argument');\n  assert.throws(() => apply(() => {\n    /* empty */\n  }, null, '123'), TypeError, 'throws on primitive as third argument');\n});","file":"tests/es.reflect.apply.js","skipped":false,"dir":"tests"},{"name":"Reflect.construct","suites":[],"line":1,"code":"QUnit.test('Reflect.construct', assert => {\n  const {\n    construct\n  } = Reflect;\n  const {\n    getPrototypeOf\n  } = Object;\n  assert.isFunction(construct);\n  assert.arity(construct, 2);\n  assert.name(construct, 'construct');\n  assert.looksNative(construct);\n  assert.nonEnumerable(Reflect, 'construct');\n\n  function A(a, b, c) {\n    this.qux = a + b + c;\n  }\n\n  assert.same(construct(A, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'basic');\n  A.apply = 42;\n  assert.same(construct(A, ['foo', 'bar', 'baz']).qux, 'foobarbaz', 'works with redefined apply');\n  const instance = construct(function () {\n    this.x = 42;\n  }, [], Array);\n  assert.same(instance.x, 42, 'constructor with newTarget');\n  assert.true(instance instanceof Array, 'prototype with newTarget');\n  assert.throws(() => construct(42, []), TypeError, 'throws on primitive');\n\n  function B() {\n    /* empty */\n  }\n\n  B.prototype = 42;\n  assert.notThrows(() => getPrototypeOf(construct(B, [])) === Object.prototype);\n  assert.notThrows(() => typeof construct(Date, []).getTime() == 'number', 'works with native constructors with 2 arguments');\n  assert.throws(() => construct(() => {\n    /* empty */\n  }), 'throws when the second argument is not an object');\n});","file":"tests/es.reflect.construct.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineProperty","suites":[],"line":2,"code":"QUnit.test('Reflect.defineProperty', assert => {\n  const {\n    defineProperty\n  } = Reflect;\n  const {\n    getOwnPropertyDescriptor,\n    create\n  } = Object;\n  assert.isFunction(defineProperty);\n  assert.arity(defineProperty, 3);\n  assert.name(defineProperty, 'defineProperty');\n  assert.looksNative(defineProperty);\n  assert.nonEnumerable(Reflect, 'defineProperty');\n  let object = {};\n  assert.true(defineProperty(object, 'foo', {\n    value: 123\n  }));\n  assert.same(object.foo, 123);\n\n  if (DESCRIPTORS) {\n    object = {};\n    defineProperty(object, 'foo', {\n      value: 123,\n      enumerable: true\n    });\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'foo'), {\n      value: 123,\n      enumerable: true,\n      configurable: false,\n      writable: false\n    });\n    assert.false(defineProperty(object, 'foo', {\n      value: 42\n    }));\n  }\n\n  assert.throws(() => defineProperty(42, 'foo', {\n    value: 42\n  }), TypeError, 'throws on primitive');\n  assert.throws(() => defineProperty(42, 1, {}));\n  assert.throws(() => defineProperty({}, create(null), {}));\n  assert.throws(() => defineProperty({}, 1, 1));\n});","file":"tests/es.reflect.define-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineProperty.sham flag","suites":[],"line":45,"code":"QUnit.test('Reflect.defineProperty.sham flag', assert => {\n  assert.same(Reflect.defineProperty.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.reflect.define-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.deleteProperty","suites":[],"line":2,"code":"QUnit.test('Reflect.deleteProperty', assert => {\n  const {\n    deleteProperty\n  } = Reflect;\n  const {\n    defineProperty,\n    keys\n  } = Object;\n  assert.isFunction(deleteProperty);\n  assert.arity(deleteProperty, 2);\n  assert.name(deleteProperty, 'deleteProperty');\n  assert.looksNative(deleteProperty);\n  assert.nonEnumerable(Reflect, 'deleteProperty');\n  const object = {\n    bar: 456\n  };\n  assert.true(deleteProperty(object, 'bar'));\n  assert.same(keys(object).length, 0);\n\n  if (DESCRIPTORS) {\n    assert.false(deleteProperty(defineProperty({}, 'foo', {\n      value: 42\n    }), 'foo'));\n  }\n\n  assert.throws(() => deleteProperty(42, 'foo'), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.delete-property.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnPropertyDescriptor","suites":[],"line":2,"code":"QUnit.test('Reflect.getOwnPropertyDescriptor', assert => {\n  const {\n    getOwnPropertyDescriptor\n  } = Reflect;\n  assert.isFunction(getOwnPropertyDescriptor);\n  assert.arity(getOwnPropertyDescriptor, 2);\n  assert.name(getOwnPropertyDescriptor, 'getOwnPropertyDescriptor');\n  assert.looksNative(getOwnPropertyDescriptor);\n  assert.nonEnumerable(Reflect, 'getOwnPropertyDescriptor');\n  const object = {\n    baz: 789\n  };\n  const descriptor = getOwnPropertyDescriptor(object, 'baz');\n  assert.same(descriptor.value, 789);\n  assert.throws(() => getOwnPropertyDescriptor(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnPropertyDescriptor.sham flag","suites":[],"line":18,"code":"QUnit.test('Reflect.getOwnPropertyDescriptor.sham flag', assert => {\n  assert.same(Reflect.getOwnPropertyDescriptor.sham, DESCRIPTORS ? undefined : true);\n});","file":"tests/es.reflect.get-own-property-descriptor.js","skipped":false,"dir":"tests"},{"name":"Reflect.getPrototypeOf","suites":[],"line":2,"code":"QUnit.test('Reflect.getPrototypeOf', assert => {\n  const {\n    getPrototypeOf\n  } = Reflect;\n  assert.isFunction(getPrototypeOf);\n  assert.arity(getPrototypeOf, 1);\n  assert.name(getPrototypeOf, 'getPrototypeOf');\n  assert.looksNative(getPrototypeOf);\n  assert.nonEnumerable(Reflect, 'getPrototypeOf');\n  assert.same(getPrototypeOf([]), Array.prototype);\n  assert.throws(() => getPrototypeOf(42), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.getPrototypeOf.sham flag","suites":[],"line":14,"code":"QUnit.test('Reflect.getPrototypeOf.sham flag', assert => {\n  assert.same(Reflect.getPrototypeOf.sham, CORRECT_PROTOTYPE_GETTER ? undefined : true);\n});","file":"tests/es.reflect.get-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.get","suites":[],"line":2,"code":"QUnit.test('Reflect.get', assert => {\n  const {\n    defineProperty,\n    create\n  } = Object;\n  const {\n    get\n  } = Reflect;\n  assert.isFunction(get);\n  if (NATIVE) assert.arity(get, 2);\n  assert.name(get, 'get');\n  assert.looksNative(get);\n  assert.nonEnumerable(Reflect, 'get');\n  assert.same(get({\n    qux: 987\n  }, 'qux'), 987);\n\n  if (DESCRIPTORS) {\n    const target = create(defineProperty({\n      z: 3\n    }, 'w', {\n      get() {\n        return this;\n      }\n\n    }), {\n      x: {\n        value: 1\n      },\n      y: {\n        get() {\n          return this;\n        }\n\n      }\n    });\n    const receiver = {};\n    assert.same(get(target, 'x', receiver), 1, 'get x');\n    assert.same(get(target, 'y', receiver), receiver, 'get y');\n    assert.same(get(target, 'z', receiver), 3, 'get z');\n    assert.same(get(target, 'w', receiver), receiver, 'get w');\n    assert.same(get(target, 'u', receiver), undefined, 'get u');\n  }\n\n  assert.throws(() => get(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.get.js","skipped":false,"dir":"tests"},{"name":"Reflect.has","suites":[],"line":1,"code":"QUnit.test('Reflect.has', assert => {\n  const {\n    has\n  } = Reflect;\n  assert.isFunction(has);\n  assert.arity(has, 2);\n  assert.name(has, 'has');\n  assert.looksNative(has);\n  assert.nonEnumerable(Reflect, 'has');\n  const object = {\n    qux: 987\n  };\n  assert.true(has(object, 'qux'));\n  assert.false(has(object, 'qwe'));\n  assert.true(has(object, 'toString'));\n  assert.throws(() => has(42, 'constructor'), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.has.js","skipped":false,"dir":"tests"},{"name":"Reflect.isExtensible","suites":[],"line":2,"code":"QUnit.test('Reflect.isExtensible', assert => {\n  const {\n    isExtensible\n  } = Reflect;\n  const {\n    preventExtensions\n  } = Object;\n  assert.isFunction(isExtensible);\n  assert.arity(isExtensible, 1);\n  assert.name(isExtensible, 'isExtensible');\n  assert.looksNative(isExtensible);\n  assert.nonEnumerable(Reflect, 'isExtensible');\n  assert.true(isExtensible({}));\n\n  if (DESCRIPTORS) {\n    assert.false(isExtensible(preventExtensions({})));\n  }\n\n  assert.throws(() => isExtensible(42), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.is-extensible.js","skipped":false,"dir":"tests"},{"name":"Reflect.ownKeys","suites":[],"line":2,"code":"QUnit.test('Reflect.ownKeys', assert => {\n  const {\n    ownKeys\n  } = Reflect;\n  const {\n    defineProperty,\n    create\n  } = Object;\n  const symbol = Symbol('c');\n  assert.isFunction(ownKeys);\n  assert.arity(ownKeys, 1);\n  assert.name(ownKeys, 'ownKeys');\n  assert.looksNative(ownKeys);\n  assert.nonEnumerable(Reflect, 'ownKeys');\n  const object = {\n    a: 1\n  };\n  defineProperty(object, 'b', {\n    value: 2\n  });\n  object[symbol] = 3;\n  let keys = ownKeys(object);\n  assert.same(keys.length, 3, 'ownKeys return all own keys');\n  assert.true(includes(keys, 'a'), 'ownKeys return all own keys: simple');\n  assert.true(includes(keys, 'b'), 'ownKeys return all own keys: hidden');\n  assert.same(object[keys[2]], 3, 'ownKeys return all own keys: symbol');\n  keys = ownKeys(create(object));\n  assert.same(keys.length, 0, 'ownKeys return only own keys');\n  assert.throws(() => ownKeys(42), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.own-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.preventExtensions","suites":[],"line":2,"code":"QUnit.test('Reflect.preventExtensions', assert => {\n  const {\n    preventExtensions\n  } = Reflect;\n  const {\n    isExtensible\n  } = Object;\n  assert.isFunction(preventExtensions);\n  assert.arity(preventExtensions, 1);\n  assert.name(preventExtensions, 'preventExtensions');\n  assert.looksNative(preventExtensions);\n  assert.nonEnumerable(Reflect, 'preventExtensions');\n  const object = {};\n  assert.true(preventExtensions(object));\n\n  if (DESCRIPTORS) {\n    assert.false(isExtensible(object));\n  }\n\n  assert.throws(() => preventExtensions(42), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Reflect.preventExtensions.sham flag","suites":[],"line":23,"code":"QUnit.test('Reflect.preventExtensions.sham flag', assert => {\n  assert.same(Reflect.preventExtensions.sham, FREEZING ? undefined : true);\n});","file":"tests/es.reflect.prevent-extensions.js","skipped":false,"dir":"tests"},{"name":"Reflect.setPrototypeOf","suites":[],"line":2,"code":"if (PROTO) QUnit.test('Reflect.setPrototypeOf', assert => {\n  const {\n    setPrototypeOf\n  } = Reflect;\n  assert.isFunction(setPrototypeOf);\n  if (NATIVE) assert.arity(setPrototypeOf, 2);\n  assert.name(setPrototypeOf, 'setPrototypeOf');\n  assert.looksNative(setPrototypeOf);\n  assert.nonEnumerable(Reflect, 'setPrototypeOf');\n  let object = {};\n  assert.true(setPrototypeOf(object, Array.prototype));\n  assert.true(object instanceof Array);\n  assert.throws(() => setPrototypeOf({}, 42), TypeError);\n  assert.throws(() => setPrototypeOf(42, {}), TypeError, 'throws on primitive');\n  object = {};\n  assert.false(setPrototypeOf(object, object), 'false on recursive __proto__');\n});","file":"tests/es.reflect.set-prototype-of.js","skipped":false,"dir":"tests"},{"name":"Reflect.set","suites":[],"line":2,"code":"QUnit.test('Reflect.set', assert => {\n  const {\n    set\n  } = Reflect;\n  const {\n    defineProperty,\n    getOwnPropertyDescriptor,\n    create,\n    getPrototypeOf\n  } = Object;\n  assert.isFunction(set);\n  if (NATIVE) assert.arity(set, 3);\n  assert.name(set, 'set');\n  assert.looksNative(set);\n  assert.nonEnumerable(Reflect, 'set');\n  const object = {};\n  assert.true(set(object, 'quux', 654));\n  assert.same(object.quux, 654);\n  let target = {};\n  const receiver = {};\n  set(target, 'foo', 1, receiver);\n  assert.same(target.foo, undefined, 'target.foo === undefined');\n  assert.same(receiver.foo, 1, 'receiver.foo === 1');\n\n  if (DESCRIPTORS) {\n    defineProperty(receiver, 'bar', {\n      value: 0,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    set(target, 'bar', 1, receiver);\n    assert.same(receiver.bar, 1, 'receiver.bar === 1');\n    assert.false(getOwnPropertyDescriptor(receiver, 'bar').enumerable, 'enumerability not overridden');\n    let out = null;\n    target = create(defineProperty({\n      z: 3\n    }, 'w', {\n      set() {\n        out = this;\n      }\n\n    }), {\n      x: {\n        value: 1,\n        writable: true,\n        configurable: true\n      },\n      y: {\n        set() {\n          out = this;\n        }\n\n      },\n      c: {\n        value: 1,\n        writable: false,\n        configurable: false\n      }\n    });\n    assert.true(set(target, 'x', 2, target), 'set x');\n    assert.same(target.x, 2, 'set x');\n    out = null;\n    assert.true(set(target, 'y', 2, target), 'set y');\n    assert.same(out, target, 'set y');\n    assert.true(set(target, 'z', 4, target));\n    assert.same(target.z, 4, 'set z');\n    out = null;\n    assert.true(set(target, 'w', 1, target), 'set w');\n    assert.same(out, target, 'set w');\n    assert.true(set(target, 'u', 0, target), 'set u');\n    assert.same(target.u, 0, 'set u');\n    assert.false(set(target, 'c', 2, target), 'set c');\n    assert.same(target.c, 1, 'set c'); // https://github.com/zloirock/core-js/issues/392\n\n    let o = defineProperty({}, 'test', {\n      writable: false,\n      configurable: true\n    });\n    assert.false(set(getPrototypeOf(o), 'test', 1, o)); // https://github.com/zloirock/core-js/issues/393\n\n    o = defineProperty({}, 'test', {\n      get() {\n        /* empty */\n      }\n\n    });\n    assert.notThrows(() => !set(getPrototypeOf(o), 'test', 1, o));\n    o = defineProperty({}, 'test', {\n      // eslint-disable-next-line no-unused-vars -- required for testing\n      set(v) {\n        /* empty */\n      }\n\n    });\n    assert.notThrows(() => !set(getPrototypeOf(o), 'test', 1, o));\n  }\n\n  assert.throws(() => set(42, 'q', 42), TypeError, 'throws on primitive');\n});","file":"tests/es.reflect.set.js","skipped":false,"dir":"tests"},{"name":"Reflect[@@toStringTag]","suites":[],"line":1,"code":"QUnit.test('Reflect[@@toStringTag]', assert => {\n  assert.same(Reflect[Symbol.toStringTag], 'Reflect', 'Reflect[@@toStringTag] is `Reflect`');\n});","file":"tests/es.reflect.to-string-tag.js","skipped":false,"dir":"tests"},{"name":"RegExp constructor","suites":[],"line":8,"code":"  QUnit.test('RegExp constructor', assert => {\n    const Symbol = GLOBAL.Symbol || {};\n    assert.isFunction(RegExp);\n    assert.arity(RegExp, 2);\n    assert.name(RegExp, 'RegExp');\n    assert.looksNative(RegExp);\n    assert.same({}.toString.call(RegExp()).slice(8, -1), 'RegExp');\n    assert.same({}.toString.call(new RegExp()).slice(8, -1), 'RegExp');\n    let regexp = /a/g;\n    assert.notSame(regexp, new RegExp(regexp), 'new RegExp(regexp) isnt regexp');\n    assert.same(regexp, RegExp(regexp), 'RegExp(regexp) is regexp');\n    regexp[Symbol.match] = false;\n    assert.notSame(regexp, RegExp(regexp), 'RegExp(regexp) isnt regexp, changed Symbol.match');\n    const object = {};\n    assert.notSame(object, RegExp(object), 'RegExp(O) isnt O');\n    object[Symbol.match] = true;\n    object.constructor = RegExp;\n    assert.same(object, RegExp(object), 'RegExp(O) is O, changed Symbol.match');\n    assert.same(String(regexp), '/a/g', 'b is /a/g');\n    assert.same(String(new RegExp(/a/g, 'mi')), '/a/im', 'Allows a regex with flags');\n    assert.true(new RegExp(/a/g, 'im') instanceof RegExp, 'Works with instanceof');\n    assert.same(new RegExp(/a/g, 'im').constructor, RegExp, 'Has the right constructor');\n    const orig = /^https?:\\/\\//i;\n    regexp = new RegExp(orig);\n    assert.notSame(regexp, orig, 'new + re + no flags #1');\n    assert.same(String(regexp), '/^https?:\\\\/\\\\//i', 'new + re + no flags #2');\n    let result = regexp.exec('http://github.com');\n    assert.deepEqual(result, ['http://'], 'new + re + no flags #3');\n    /(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)(o)(p)/.exec('abcdefghijklmnopq');\n    result = true;\n    const characters = 'bcdefghij';\n\n    for (let i = 0, {\n      length\n    } = characters; i < length; ++i) {\n      const chr = characters[i];\n\n      if (RegExp[`$${i + 1}`] !== chr) {\n        result = false;\n      }\n    }\n\n    assert.true(result, 'Updates RegExp globals');\n\n    if (nativeSubclass) {\n      const Subclass = nativeSubclass(RegExp);\n      assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n      assert.true(new Subclass() instanceof RegExp, 'correct subclassing with native classes #2');\n      assert.true(new Subclass('^abc$').test('abc'), 'correct subclassing with native classes #3');\n    }\n\n    assert.throws(() => RegExp(Symbol(1)), 'throws on symbol argument');\n  });","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"abc","suites":[],"line":56,"code":"      assert.true(new Subclass('^abc$').test('abc'), 'correct subclassing with native classes #3');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"RegExp dotAll","suites":[],"line":61,"code":"  QUnit.test('RegExp dotAll', assert => {\n    assert.false(RegExp('.', '').test('\\n'), 'dotAll missed');\n    assert.true(RegExp('.', 's').test('\\n'), 'dotAll basic');\n    assert.false(RegExp('[.]', 's').test('\\n'), 'dotAll brackets #1');\n    assert.false(RegExp('[.].', '').test('.\\n'), 'dotAll brackets #2');\n    assert.true(RegExp('[.].', 's').test('.\\n'), 'dotAll brackets #3');\n    assert.true(RegExp('[[].', 's').test('[\\n'), 'dotAll brackets #4');\n    assert.same(RegExp('.[.[].\\\\..', 's').source, '.[.[].\\\\..', 'dotAll correct source');\n    const string = '123\\n456789\\n012';\n    const re = RegExp('(\\\\d{3}).\\\\d{3}', 'sy');\n    let match = re.exec(string);\n    assert.same(match[1], '123', 's with y #1');\n    assert.same(re.lastIndex, 7, 's with y #2');\n    match = re.exec(string);\n    assert.same(match[1], '789', 's with y #3');\n    assert.same(re.lastIndex, 14, 's with y #4');\n  });","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"\n","suites":[],"line":62,"code":"    assert.false(RegExp('.', '').test('\\n'), 'dotAll missed');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"\n","suites":[],"line":63,"code":"    assert.true(RegExp('.', 's').test('\\n'), 'dotAll basic');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"\n","suites":[],"line":64,"code":"    assert.false(RegExp('[.]', 's').test('\\n'), 'dotAll brackets #1');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":".\n","suites":[],"line":65,"code":"    assert.false(RegExp('[.].', '').test('.\\n'), 'dotAll brackets #2');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":".\n","suites":[],"line":66,"code":"    assert.true(RegExp('[.].', 's').test('.\\n'), 'dotAll brackets #3');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"[\n","suites":[],"line":67,"code":"    assert.true(RegExp('[[].', 's').test('[\\n'), 'dotAll brackets #4');","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"RegExp NCG","suites":[],"line":78,"code":"  QUnit.test('RegExp NCG', assert => {\n    assert.same(RegExp('(?<a>b)').exec('b').groups?.a, 'b', 'NCG #1'); // eslint-disable-next-line regexp/no-unused-capturing-group -- required for testing\n\n    assert.same(RegExp('(b)').exec('b').groups, undefined, 'NCG #2');\n    const {\n      groups\n    } = RegExp('foo:(?<foo>\\\\w+),bar:(?<bar>\\\\w+)').exec('foo:abc,bar:def');\n    assert.deepEqual(groups, {\n      foo: 'abc',\n      bar: 'def'\n    }, 'NCG #3'); // fails in Safari\n    // assert.same(Object.getPrototypeOf(groups), null, 'NCG #4');\n\n    assert.same('foo:abc,bar:def'.replace(RegExp('foo:(?<foo>\\\\w+),bar:(?<bar>\\\\w+)'), '$<bar>,$<foo>'), 'def,abc', 'replace #1');\n    assert.same('foo:abc,bar:def'.replace(RegExp('foo:(?<foo>\\\\w+),bar:(?<bar>\\\\w+)'), (...args) => {\n      const {\n        foo,\n        bar\n      } = args.pop();\n      return `${bar},${foo}`;\n    }), 'def,abc', 'replace #2');\n    assert.same('12345'.replaceAll(RegExp('(?<d>[2-4])', 'g'), '$<d>$<d>'), '12233445', 'replaceAll');\n    assert.throws(() => RegExp('(?<1a>b)'), SyntaxError, 'incorrect group name #1');\n    assert.throws(() => RegExp('(?<a#>b)'), SyntaxError, 'incorrect group name #2');\n    assert.throws(() => RegExp('(?< a >b)'), SyntaxError, 'incorrect group name #3');\n  });","file":"tests/es.regexp.constructor.js","skipped":false,"dir":"tests"},{"name":"RegExp#dotAll","suites":[],"line":4,"code":"  QUnit.test('RegExp#dotAll', assert => {\n    const re = RegExp('.', 's');\n    assert.true(re.dotAll, '.dotAll is true');\n    assert.same(re.flags, 's', '.flags contains s');\n    assert.false(RegExp('.').dotAll, 'no');\n    assert.false(/a/.dotAll, 'no in literal');\n    const dotAllGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'dotAll').get;\n\n    if (typeof dotAllGetter == 'function') {\n      assert.throws(() => {\n        dotAllGetter.call({});\n      }, undefined, '.dotAll getter can only be called on RegExp instances');\n\n      try {\n        dotAllGetter.call(/a/);\n        assert.required('.dotAll getter works on literals');\n      } catch (error) {\n        assert.avoid('.dotAll getter works on literals');\n      }\n\n      try {\n        dotAllGetter.call(new RegExp('a'));\n        assert.required('.dotAll getter works on instances');\n      } catch (error) {\n        assert.avoid('.dotAll getter works on instances');\n      }\n\n      assert.true(Object.hasOwn(RegExp.prototype, 'dotAll'), 'prototype has .dotAll property');\n    }\n  });","file":"tests/es.regexp.dot-all.js","skipped":false,"dir":"tests"},{"name":"RegExp#exec lastIndex updating","suites":[],"line":2,"code":"QUnit.test('RegExp#exec lastIndex updating', assert => {\n  let re = /b/;\n  assert.same(re.lastIndex, 0, '.lastIndex starts at 0 for non-global regexps');\n  re.exec('abc');\n  assert.same(re.lastIndex, 0, '.lastIndex isn\\'t updated for non-global regexps');\n  re = /b/g;\n  assert.same(re.lastIndex, 0, '.lastIndex starts at 0 for global regexps');\n  re.exec('abc');\n  assert.same(re.lastIndex, 2, '.lastIndex is updated for global regexps');\n  re = /b*/;\n  re.exec('a');\n  assert.same(re.lastIndex, 0, '.lastIndex isn\\'t updated for non-global regexps if the match is empty');\n  re = /b*/g;\n  re.exec('a');\n  assert.same(re.lastIndex, 0, '.lastIndex isn\\'t updated for global regexps if the match is empty');\n});","file":"tests/es.regexp.exec.js","skipped":false,"dir":"tests"},{"name":"RegExp#exec capturing groups","suites":[],"line":18,"code":"QUnit.test('RegExp#exec capturing groups', assert => {\n  assert.deepEqual(/(a?)/.exec('x'), ['', ''], '/(a?)/.exec(\"x\") returns [\"\", \"\"]');\n  assert.deepEqual(/(a)?/.exec('x'), ['', undefined], '/(a)?/.exec(\"x\") returns [\"\", undefined]'); // @nicolo-ribaudo: I don't know how to fix this in IE8. For the `/(a)?/` case it is fixed using\n  // #replace, but here also #replace is buggy :(\n  // assert.deepEqual(/(a?)?/.exec('x'), ['', undefined], '/(a?)?/.exec(\"x\") returns [\"\", undefined]');\n});","file":"tests/es.regexp.exec.js","skipped":false,"dir":"tests"},{"name":"RegExp#exec regression","suites":[],"line":26,"code":"  QUnit.test('RegExp#exec regression', assert => {\n    assert.throws(() => /l/.exec(Symbol()), 'throws on symbol argument');\n  });","file":"tests/es.regexp.exec.js","skipped":false,"dir":"tests"},{"name":"RegExp#exec sticky","suites":[],"line":29,"code":"  QUnit.test('RegExp#exec sticky', assert => {\n    const re = new RegExp('a', 'y');\n    const str = 'bbabaab';\n    assert.same(re.lastIndex, 0, '#1');\n    assert.same(re.exec(str), null, '#2');\n    assert.same(re.lastIndex, 0, '#3');\n    re.lastIndex = 1;\n    assert.same(re.exec(str), null, '#4');\n    assert.same(re.lastIndex, 0, '#5');\n    re.lastIndex = 2;\n    const result = re.exec(str);\n    assert.deepEqual(result, ['a'], '#6');\n    assert.same(result.index, 2, '#7');\n    assert.same(re.lastIndex, 3, '#8');\n    assert.same(re.exec(str), null, '#9');\n    assert.same(re.lastIndex, 0, '#10');\n    re.lastIndex = 4;\n    assert.deepEqual(re.exec(str), ['a'], '#11');\n    assert.same(re.lastIndex, 5, '#12');\n    assert.deepEqual(re.exec(str), ['a'], '#13');\n    assert.same(re.lastIndex, 6, '#14');\n    assert.same(re.exec(str), null, '#15');\n    assert.same(re.lastIndex, 0, '#16');\n  });","file":"tests/es.regexp.exec.js","skipped":false,"dir":"tests"},{"name":"RegExp#exec sticky anchored","suites":[],"line":53,"code":"  QUnit.test('RegExp#exec sticky anchored', assert => {\n    const regex = new RegExp('^foo', 'y');\n    assert.deepEqual(regex.exec('foo'), ['foo'], '#1');\n    regex.lastIndex = 2;\n    assert.same(regex.exec('..foo'), null, '#2');\n    regex.lastIndex = 2;\n    assert.same(regex.exec('.\\nfoo'), null, '#3');\n    const regex2 = new RegExp('^foo', 'my');\n    regex2.lastIndex = 2;\n    assert.same(regex2.exec('..foo'), null, '#4');\n    regex2.lastIndex = 2;\n    assert.deepEqual(regex2.exec('.\\nfoo'), ['foo'], '#5');\n    assert.same(regex2.lastIndex, 5, '#6');\n  });","file":"tests/es.regexp.exec.js","skipped":false,"dir":"tests"},{"name":"RegExp#flags","suites":[],"line":5,"code":"  QUnit.test('RegExp#flags', assert => {\n    assert.nonEnumerable(RegExp.prototype, 'flags');\n    assert.same(/./g.flags, 'g', '/./g.flags is \"g\"');\n    assert.same(/./.flags, '', '/./.flags is \"\"');\n    assert.same(RegExp('.', 'gim').flags, 'gim', 'RegExp(\".\", \"gim\").flags is \"gim\"');\n    assert.same(RegExp('.').flags, '', 'RegExp(\".\").flags is \"\"');\n    assert.same(/./gim.flags, 'gim', '/./gim.flags is \"gim\"');\n    assert.same(/./gmi.flags, 'gim', '/./gmi.flags is \"gim\"');\n    assert.same(/./mig.flags, 'gim', '/./mig.flags is \"gim\"');\n    assert.same(/./mgi.flags, 'gim', '/./mgi.flags is \"gim\"');\n  });","file":"tests/es.regexp.flags.js","skipped":false,"dir":"tests"},{"name":"RegExp#sticky","suites":[],"line":4,"code":"  QUnit.test('RegExp#sticky', assert => {\n    const re = new RegExp('a', 'y');\n    assert.true(re.sticky, '.sticky is true');\n    assert.same(re.flags, 'y', '.flags contains y');\n    assert.false(/a/.sticky);\n    const stickyGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'sticky').get;\n\n    if (typeof stickyGetter == 'function') {\n      // Old firefox versions set a non-configurable non-writable .sticky property\n      // It works correctly, but it isn't a getter and it can't be polyfilled.\n      // We need to skip these tests.\n      assert.throws(() => {\n        stickyGetter.call({});\n      }, undefined, '.sticky getter can only be called on RegExp instances');\n\n      try {\n        stickyGetter.call(/a/);\n        assert.required('.sticky getter works on literals');\n      } catch (error) {\n        assert.avoid('.sticky getter works on literals');\n      }\n\n      try {\n        stickyGetter.call(new RegExp('a'));\n        assert.required('.sticky getter works on instances');\n      } catch (error) {\n        assert.avoid('.sticky getter works on instances');\n      }\n\n      assert.true(Object.hasOwn(RegExp.prototype, 'sticky'), 'prototype has .sticky property'); // relaxed for early implementations\n      // assert.same(RegExp.prototype.sticky, undefined, '.sticky is undefined on prototype');\n    }\n  });","file":"tests/es.regexp.sticky.js","skipped":false,"dir":"tests"},{"name":"RegExp#test delegates to exec","suites":[],"line":1,"code":"QUnit.test('RegExp#test delegates to exec', assert => {\n  const exec = function () {\n    execCalled = true;\n    return /./.exec.apply(this, arguments);\n  };\n\n  let execCalled = false;\n  let re = /[ac]/;\n  re.exec = exec;\n  assert.true(re.test('abc'), '#1');\n  assert.true(execCalled, '#2');\n  re = /a/; // Not a function, should be ignored\n\n  re.exec = 3;\n  assert.true(re.test('abc'), '#3');\n  re = /a/; // Does not return an object, should throw\n\n  re.exec = () => 3;\n\n  assert.throws(() => re.test('abc', '#4'));\n});","file":"tests/es.regexp.test.js","skipped":false,"dir":"tests"},{"name":"abc","suites":[],"line":10,"code":"  assert.true(re.test('abc'), '#1');","file":"tests/es.regexp.test.js","skipped":false,"dir":"tests"},{"name":"abc","suites":[],"line":15,"code":"  assert.true(re.test('abc'), '#3');","file":"tests/es.regexp.test.js","skipped":false,"dir":"tests"},{"name":"abc","suites":[],"line":20,"code":"  assert.throws(() => re.test('abc', '#4'));","file":"tests/es.regexp.test.js","skipped":false,"dir":"tests"},{"name":"RegExp#toString","suites":[],"line":3,"code":"QUnit.test('RegExp#toString', assert => {\n  const {\n    toString\n  } = RegExp.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  assert.looksNative(toString);\n  assert.nonEnumerable(RegExp.prototype, 'toString');\n  assert.same(String(/pattern/), '/pattern/');\n  assert.same(String(/pattern/i), '/pattern/i');\n  assert.same(String(/pattern/mi), '/pattern/im');\n  assert.same(String(/pattern/im), '/pattern/im');\n  assert.same(String(/pattern/mgi), '/pattern/gim');\n  assert.same(String(new RegExp('pattern')), '/pattern/');\n  assert.same(String(new RegExp('pattern', 'i')), '/pattern/i');\n  assert.same(String(new RegExp('pattern', 'mi')), '/pattern/im');\n  assert.same(String(new RegExp('pattern', 'im')), '/pattern/im');\n  assert.same(String(new RegExp('pattern', 'mgi')), '/pattern/gim');\n  assert.same(toString.call({\n    source: 'foo',\n    flags: 'bar'\n  }), '/foo/bar');\n  assert.same(toString.call({}), '/undefined/undefined');\n\n  if (STRICT) {\n    assert.throws(() => toString.call(7));\n    assert.throws(() => toString.call('a'));\n    assert.throws(() => toString.call(false));\n    assert.throws(() => toString.call(null));\n    assert.throws(() => toString.call(undefined));\n  }\n\n  assert.throws(() => toString.call({\n    source: Symbol(),\n    flags: 'g'\n  }), 'throws on symbol');\n});","file":"tests/es.regexp.to-string.js","skipped":false,"dir":"tests"},{"name":"Set","suites":[],"line":18,"code":"QUnit.test('Set', assert => {\n  assert.isFunction(Set);\n  assert.name(Set, 'Set');\n  assert.arity(Set, 0);\n  assert.looksNative(Set);\n  assert.true('add' in Set.prototype, 'add in Set.prototype');\n  assert.true('clear' in Set.prototype, 'clear in Set.prototype');\n  assert.true('delete' in Set.prototype, 'delete in Set.prototype');\n  assert.true('forEach' in Set.prototype, 'forEach in Set.prototype');\n  assert.true('has' in Set.prototype, 'has in Set.prototype');\n  assert.true(new Set() instanceof Set, 'new Set instanceof Set');\n  let set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  assert.same(set.size, 3);\n  const result = [];\n  set.forEach(val => {\n    result.push(val);\n  });\n  assert.deepEqual(result, [1, 2, 3]);\n  assert.same(new Set(createIterable([1, 2, 3])).size, 3, 'Init from iterable');\n  assert.same(new Set([freeze({}), 1]).size, 2, 'Support frozen objects');\n  assert.same(new Set([NaN, NaN, NaN]).size, 1);\n  assert.deepEqual(from(new Set([3, 4]).add(2).add(1)), [3, 4, 2, 1]);\n  let done = false;\n  const {\n    add\n  } = Set.prototype; // eslint-disable-next-line no-extend-native -- required for testing\n\n  Set.prototype.add = function () {\n    throw new Error();\n  };\n\n  try {\n    new Set(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  } // eslint-disable-next-line no-extend-native -- required for testing\n\n\n  Set.prototype.add = add;\n  assert.true(done, '.return #throw');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  new Set(array);\n  assert.true(done);\n  const object = {};\n  new Set().add(object);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in results) keys.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(Set);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof Set, 'correct subclassing with native classes #2');\n    assert.true(new Subclass().add(2).has(2), 'correct subclassing with native classes #3');\n  }\n\n  const buffer = new ArrayBuffer(8);\n  set = new Set([buffer]);\n  assert.true(set.has(buffer), 'works with ArrayBuffer keys');\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#add","suites":[],"line":106,"code":"QUnit.test('Set#add', assert => {\n  assert.isFunction(Set.prototype.add);\n  assert.name(Set.prototype.add, 'add');\n  assert.arity(Set.prototype.add, 1);\n  assert.looksNative(Set.prototype.add);\n  assert.nonEnumerable(Set.prototype, 'add');\n  const array = [];\n  let set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(array);\n  assert.same(set.size, 5);\n  const chain = set.add(NaN);\n  assert.same(chain, set);\n  assert.same(set.size, 5);\n  set.add(2);\n  assert.same(set.size, 5);\n  set.add(array);\n  assert.same(set.size, 5);\n  set.add([]);\n  assert.same(set.size, 6);\n  set.add(4);\n  assert.same(set.size, 7);\n  const frozen = freeze({});\n  set = new Set();\n  set.add(frozen);\n  assert.true(set.has(frozen));\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#clear","suites":[],"line":137,"code":"QUnit.test('Set#clear', assert => {\n  assert.isFunction(Set.prototype.clear);\n  assert.name(Set.prototype.clear, 'clear');\n  assert.arity(Set.prototype.clear, 0);\n  assert.looksNative(Set.prototype.clear);\n  assert.nonEnumerable(Set.prototype, 'clear');\n  let set = new Set();\n  set.clear();\n  assert.same(set.size, 0);\n  set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.clear();\n  assert.same(set.size, 0);\n  assert.false(set.has(1));\n  assert.false(set.has(2));\n  assert.false(set.has(3));\n  const frozen = freeze({});\n  set = new Set();\n  set.add(1);\n  set.add(frozen);\n  set.clear();\n  assert.same(set.size, 0, 'Support frozen objects');\n  assert.false(set.has(1));\n  assert.false(set.has(frozen));\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#delete","suites":[],"line":166,"code":"QUnit.test('Set#delete', assert => {\n  assert.isFunction(Set.prototype.delete);\n  if (NATIVE) assert.name(Set.prototype.delete, 'delete');\n  assert.arity(Set.prototype.delete, 1);\n  assert.looksNative(Set.prototype.delete);\n  assert.nonEnumerable(Set.prototype, 'delete');\n  const array = [];\n  const set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(array);\n  assert.same(set.size, 5);\n  assert.true(set.delete(NaN));\n  assert.same(set.size, 4);\n  assert.false(set.delete(4));\n  assert.same(set.size, 4);\n  set.delete([]);\n  assert.same(set.size, 4);\n  set.delete(array);\n  assert.same(set.size, 3);\n  const frozen = freeze({});\n  set.add(frozen);\n  assert.same(set.size, 4);\n  set.delete(frozen);\n  assert.same(set.size, 3);\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#forEach","suites":[],"line":195,"code":"QUnit.test('Set#forEach', assert => {\n  assert.isFunction(Set.prototype.forEach);\n  assert.name(Set.prototype.forEach, 'forEach');\n  assert.arity(Set.prototype.forEach, 1);\n  assert.looksNative(Set.prototype.forEach);\n  assert.nonEnumerable(Set.prototype, 'forEach');\n  let result = [];\n  let count = 0;\n  let set = new Set();\n  set.add(1);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.forEach(value => {\n    count++;\n    result.push(value);\n  });\n  assert.same(count, 3);\n  assert.deepEqual(result, [1, 2, 3]);\n  set = new Set();\n  set.add('0');\n  set.add('1');\n  set.add('2');\n  set.add('3');\n  result = '';\n  set.forEach(it => {\n    result += it;\n\n    if (it === '2') {\n      set.delete('2');\n      set.delete('3');\n      set.delete('1');\n      set.add('4');\n    }\n  });\n  assert.same(result, '0124');\n  set = new Set();\n  set.add('0');\n  result = '';\n  set.forEach(it => {\n    set.delete('0');\n    if (result !== '') throw new Error();\n    result += it;\n  });\n  assert.same(result, '0');\n  assert.throws(() => {\n    Set.prototype.forEach.call(new Map(), () => {\n      /* empty */\n    });\n  }, 'non-generic');\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#has","suites":[],"line":247,"code":"QUnit.test('Set#has', assert => {\n  assert.isFunction(Set.prototype.has);\n  assert.name(Set.prototype.has, 'has');\n  assert.arity(Set.prototype.has, 1);\n  assert.looksNative(Set.prototype.has);\n  assert.nonEnumerable(Set.prototype, 'has');\n  const array = [];\n  const frozen = freeze({});\n  const set = new Set();\n  set.add(NaN);\n  set.add(2);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(frozen);\n  set.add(array);\n  assert.true(set.has(NaN));\n  assert.true(set.has(array));\n  assert.true(set.has(frozen));\n  assert.true(set.has(2));\n  assert.false(set.has(4));\n  assert.false(set.has([]));\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#size","suites":[],"line":270,"code":"QUnit.test('Set#size', assert => {\n  assert.nonEnumerable(Set.prototype, 'size');\n  const set = new Set();\n  set.add(1);\n  const {\n    size\n  } = set;\n  assert.same(typeof size, 'number', 'size is number');\n  assert.same(size, 1, 'size is correct');\n\n  if (DESCRIPTORS) {\n    const sizeDescriptor = getOwnPropertyDescriptor(Set.prototype, 'size');\n    const getter = sizeDescriptor && sizeDescriptor.get;\n    const setter = sizeDescriptor && sizeDescriptor.set;\n    assert.same(typeof getter, 'function', 'size is getter');\n    assert.same(typeof setter, 'undefined', 'size isnt setter');\n    assert.throws(() => Set.prototype.size, TypeError);\n  }\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set & -0","suites":[],"line":289,"code":"QUnit.test('Set & -0', assert => {\n  let set = new Set();\n  set.add(-0);\n  assert.same(set.size, 1);\n  assert.true(set.has(0));\n  assert.true(set.has(-0));\n  set.forEach(it => {\n    assert.false(is(it, -0));\n  });\n  set.delete(-0);\n  assert.same(set.size, 0);\n  set = new Set([-0]);\n  set.forEach(key => {\n    assert.false(is(key, -0));\n  });\n  set = new Set();\n  set.add(4);\n  set.add(3);\n  set.add(2);\n  set.add(1);\n  set.add(0);\n  assert.true(set.has(-0));\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#@@toStringTag","suites":[],"line":312,"code":"QUnit.test('Set#@@toStringTag', assert => {\n  assert.same(Set.prototype[Symbol.toStringTag], 'Set', 'Set::@@toStringTag is `Set`');\n  assert.same(String(new Set()), '[object Set]', 'correct stringification');\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set Iterator","suites":[],"line":316,"code":"QUnit.test('Set Iterator', assert => {\n  const set = new Set();\n  set.add('a');\n  set.add('b');\n  set.add('c');\n  set.add('d');\n  const results = [];\n  const iterator = set.keys();\n  results.push(iterator.next().value);\n  assert.true(set.delete('a'));\n  assert.true(set.delete('b'));\n  assert.true(set.delete('c'));\n  set.add('e');\n  results.push(iterator.next().value, iterator.next().value);\n  assert.true(iterator.next().done);\n  set.add('f');\n  assert.true(iterator.next().done);\n  assert.deepEqual(results, ['a', 'd', 'e']);\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#keys","suites":[],"line":335,"code":"QUnit.test('Set#keys', assert => {\n  assert.isFunction(Set.prototype.keys);\n  assert.name(Set.prototype.keys, 'values');\n  assert.arity(Set.prototype.keys, 0);\n  assert.looksNative(Set.prototype.keys);\n  assert.same(Set.prototype.keys, Set.prototype.values);\n  assert.nonEnumerable(Set.prototype, 'keys');\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.keys();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#values","suites":[],"line":367,"code":"QUnit.test('Set#values', assert => {\n  assert.isFunction(Set.prototype.values);\n  assert.name(Set.prototype.values, 'values');\n  assert.arity(Set.prototype.values, 0);\n  assert.looksNative(Set.prototype.values);\n  assert.nonEnumerable(Set.prototype, 'values');\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.values();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#entries","suites":[],"line":398,"code":"QUnit.test('Set#entries', assert => {\n  assert.isFunction(Set.prototype.entries);\n  assert.name(Set.prototype.entries, 'entries');\n  assert.arity(Set.prototype.entries, 0);\n  assert.looksNative(Set.prototype.entries);\n  assert.nonEnumerable(Set.prototype, 'entries');\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set.entries();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['q', 'q'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['w', 'w'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: ['e', 'e'],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"Set#@@iterator","suites":[],"line":429,"code":"QUnit.test('Set#@@iterator', assert => {\n  assert.isIterable(Set.prototype);\n  assert.name(Set.prototype[Symbol.iterator], 'values');\n  assert.arity(Set.prototype[Symbol.iterator], 0);\n  assert.looksNative(Set.prototype[Symbol.iterator]);\n  assert.same(Set.prototype[Symbol.iterator], Set.prototype.values);\n  assert.nonEnumerable(Set.prototype, 'values');\n  const set = new Set();\n  set.add('q');\n  set.add('w');\n  set.add('e');\n  const iterator = set[Symbol.iterator]();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Set Iterator');\n  assert.same(String(iterator), '[object Set Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/es.set.js","skipped":false,"dir":"tests"},{"name":"String#anchor","suites":[],"line":1,"code":"QUnit.test('String#anchor', assert => {\n  const {\n    anchor\n  } = String.prototype;\n  assert.isFunction(anchor);\n  assert.arity(anchor, 1);\n  assert.name(anchor, 'anchor');\n  assert.looksNative(anchor);\n  assert.nonEnumerable(String.prototype, 'anchor');\n  assert.same('a'.anchor('b'), '<a name=\"b\">a</a>', 'lower case');\n  assert.same('a'.anchor('\"'), '<a name=\"&quot;\">a</a>', 'escape quotes');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => anchor.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => anchor.call('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"tests/es.string.anchor.js","skipped":false,"dir":"tests"},{"name":"String#at","suites":[],"line":2,"code":"QUnit.test('String#at', assert => {\n  const {\n    at\n  } = String.prototype;\n  assert.isFunction(at);\n  assert.arity(at, 1);\n  assert.name(at, 'at');\n  assert.looksNative(at);\n  assert.nonEnumerable(String.prototype, 'at');\n  assert.same('1', '123'.at(0));\n  assert.same('2', '123'.at(1));\n  assert.same('3', '123'.at(2));\n  assert.same(undefined, '123'.at(3));\n  assert.same('3', '123'.at(-1));\n  assert.same('2', '123'.at(-2));\n  assert.same('1', '123'.at(-3));\n  assert.same(undefined, '123'.at(-4));\n  assert.same('1', '123'.at(0.4));\n  assert.same('1', '123'.at(0.5));\n  assert.same('1', '123'.at(0.6));\n  assert.same('1', '1'.at(NaN));\n  assert.same('1', '1'.at());\n  assert.same('1', '123'.at(-0)); // TODO: disabled by default because of the conflict with old proposal\n  // assert.same('\\uD842', '𠮷'.at());\n\n  assert.same('1', at.call({\n    toString() {\n      return '123';\n    }\n\n  }, 0));\n  assert.throws(() => at.call(Symbol(), 0), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => at.call(null, 0), TypeError);\n    assert.throws(() => at.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.at-alternative.js","skipped":false,"dir":"tests"},{"name":"String#big","suites":[],"line":1,"code":"QUnit.test('String#big', assert => {\n  const {\n    big\n  } = String.prototype;\n  assert.isFunction(big);\n  assert.arity(big, 0);\n  assert.name(big, 'big');\n  assert.looksNative(big);\n  assert.nonEnumerable(String.prototype, 'big');\n  assert.same('a'.big(), '<big>a</big>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => big.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.big.js","skipped":false,"dir":"tests"},{"name":"String#blink","suites":[],"line":1,"code":"QUnit.test('String#blink', assert => {\n  const {\n    blink\n  } = String.prototype;\n  assert.isFunction(blink);\n  assert.arity(blink, 0);\n  assert.name(blink, 'blink');\n  assert.looksNative(blink);\n  assert.nonEnumerable(String.prototype, 'blink');\n  assert.same('a'.blink(), '<blink>a</blink>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => blink.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.blink.js","skipped":false,"dir":"tests"},{"name":"String#bold","suites":[],"line":1,"code":"QUnit.test('String#bold', assert => {\n  const {\n    bold\n  } = String.prototype;\n  assert.isFunction(bold);\n  assert.arity(bold, 0);\n  assert.name(bold, 'bold');\n  assert.looksNative(bold);\n  assert.nonEnumerable(String.prototype, 'bold');\n  assert.same('a'.bold(), '<b>a</b>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => bold.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.bold.js","skipped":false,"dir":"tests"},{"name":"String#codePointAt","suites":[],"line":2,"code":"QUnit.test('String#codePointAt', assert => {\n  const {\n    codePointAt\n  } = String.prototype;\n  assert.isFunction(codePointAt);\n  assert.arity(codePointAt, 1);\n  assert.name(codePointAt, 'codePointAt');\n  assert.looksNative(codePointAt);\n  assert.nonEnumerable(String.prototype, 'codePointAt');\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(''), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt('_'), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(-Infinity), undefined);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(-1), undefined);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(-0), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(0), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(3), 0x1D306);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(4), 0xDF06);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(5), 0x64);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(42), undefined);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(Infinity), undefined);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(Infinity), undefined);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(NaN), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(false), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(null), 0x61);\n  assert.same('abc\\uD834\\uDF06def'.codePointAt(undefined), 0x61);\n  assert.same('\\uD834\\uDF06def'.codePointAt(''), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt('1'), 0xDF06);\n  assert.same('\\uD834\\uDF06def'.codePointAt('_'), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(-1), undefined);\n  assert.same('\\uD834\\uDF06def'.codePointAt(-0), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(0), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(1), 0xDF06);\n  assert.same('\\uD834\\uDF06def'.codePointAt(42), undefined);\n  assert.same('\\uD834\\uDF06def'.codePointAt(false), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(null), 0x1D306);\n  assert.same('\\uD834\\uDF06def'.codePointAt(undefined), 0x1D306);\n  assert.same('\\uD834abc'.codePointAt(''), 0xD834);\n  assert.same('\\uD834abc'.codePointAt('_'), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(-1), undefined);\n  assert.same('\\uD834abc'.codePointAt(-0), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(0), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(false), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(NaN), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(null), 0xD834);\n  assert.same('\\uD834abc'.codePointAt(undefined), 0xD834);\n  assert.same('\\uDF06abc'.codePointAt(''), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt('_'), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(-1), undefined);\n  assert.same('\\uDF06abc'.codePointAt(-0), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(0), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(false), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(NaN), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(null), 0xDF06);\n  assert.same('\\uDF06abc'.codePointAt(undefined), 0xDF06);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => codePointAt.call(Symbol(), 1), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => codePointAt.call(null, 0), TypeError);\n    assert.throws(() => codePointAt.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.code-point-at.js","skipped":false,"dir":"tests"},{"name":"String#endsWith","suites":[],"line":3,"code":"QUnit.test('String#endsWith', assert => {\n  const {\n    endsWith\n  } = String.prototype;\n  assert.isFunction(endsWith);\n  assert.arity(endsWith, 1);\n  assert.name(endsWith, 'endsWith');\n  assert.looksNative(endsWith);\n  assert.nonEnumerable(String.prototype, 'endsWith');\n  assert.true('undefined'.endsWith());\n  assert.false('undefined'.endsWith(null));\n  assert.true('abc'.endsWith(''));\n  assert.true('abc'.endsWith('c'));\n  assert.true('abc'.endsWith('bc'));\n  assert.false('abc'.endsWith('ab'));\n  assert.true('abc'.endsWith('', NaN));\n  assert.false('abc'.endsWith('c', -1));\n  assert.true('abc'.endsWith('a', 1));\n  assert.true('abc'.endsWith('c', Infinity));\n  assert.true('abc'.endsWith('a', true));\n  assert.false('abc'.endsWith('c', 'x'));\n  assert.false('abc'.endsWith('a', 'x'));\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => endsWith.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => endsWith.call('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => endsWith.call(null, '.'), TypeError);\n    assert.throws(() => endsWith.call(undefined, '.'), TypeError);\n  }\n\n  const regexp = /./;\n  assert.throws(() => '/./'.endsWith(regexp), TypeError);\n  regexp[Symbol.match] = false;\n  assert.notThrows(() => '/./'.endsWith(regexp));\n  const object = {};\n  assert.notThrows(() => '[object Object]'.endsWith(object));\n  object[Symbol.match] = true;\n  assert.throws(() => '[object Object]'.endsWith(object), TypeError);\n});","file":"tests/es.string.ends-with.js","skipped":false,"dir":"tests"},{"name":"String#fixed","suites":[],"line":1,"code":"QUnit.test('String#fixed', assert => {\n  const {\n    fixed\n  } = String.prototype;\n  assert.isFunction(fixed);\n  assert.arity(fixed, 0);\n  assert.name(fixed, 'fixed');\n  assert.looksNative(fixed);\n  assert.nonEnumerable(String.prototype, 'fixed');\n  assert.same('a'.fixed(), '<tt>a</tt>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => fixed.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.fixed.js","skipped":false,"dir":"tests"},{"name":"String#fontcolor","suites":[],"line":1,"code":"QUnit.test('String#fontcolor', assert => {\n  const {\n    fontcolor\n  } = String.prototype;\n  assert.isFunction(fontcolor);\n  assert.arity(fontcolor, 1);\n  assert.name(fontcolor, 'fontcolor');\n  assert.looksNative(fontcolor);\n  assert.nonEnumerable(String.prototype, 'fontcolor');\n  assert.same('a'.fontcolor('b'), '<font color=\"b\">a</font>', 'lower case');\n  assert.same('a'.fontcolor('\"'), '<font color=\"&quot;\">a</font>', 'escape quotes');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => fontcolor.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.fontcolor.js","skipped":false,"dir":"tests"},{"name":"String#fontsize","suites":[],"line":1,"code":"QUnit.test('String#fontsize', assert => {\n  const {\n    fontsize\n  } = String.prototype;\n  assert.isFunction(fontsize);\n  assert.arity(fontsize, 1);\n  assert.name(fontsize, 'fontsize');\n  assert.looksNative(fontsize);\n  assert.nonEnumerable(String.prototype, 'fontsize');\n  assert.same('a'.fontsize('b'), '<font size=\"b\">a</font>', 'lower case');\n  assert.same('a'.fontsize('\"'), '<font size=\"&quot;\">a</font>', 'escape quotes');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => fontsize.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => fontsize.call('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"tests/es.string.fontsize.js","skipped":false,"dir":"tests"},{"name":"String.fromCodePoint","suites":[],"line":1,"code":"QUnit.test('String.fromCodePoint', assert => {\n  const {\n    fromCodePoint\n  } = String;\n  assert.isFunction(fromCodePoint);\n  assert.arity(fromCodePoint, 1);\n  assert.name(fromCodePoint, 'fromCodePoint');\n  assert.looksNative(fromCodePoint);\n  assert.nonEnumerable(String, 'fromCodePoint');\n  assert.same(fromCodePoint(''), '\\0');\n  assert.same(fromCodePoint(), '');\n  assert.same(fromCodePoint(-0), '\\0');\n  assert.same(fromCodePoint(0), '\\0');\n  assert.same(fromCodePoint(0x1D306), '\\uD834\\uDF06');\n  assert.same(fromCodePoint(0x1D306, 0x61, 0x1D307), '\\uD834\\uDF06a\\uD834\\uDF07');\n  assert.same(fromCodePoint(0x61, 0x62, 0x1D307), 'ab\\uD834\\uDF07');\n  assert.same(fromCodePoint(false), '\\0');\n  assert.same(fromCodePoint(null), '\\0');\n  assert.throws(() => fromCodePoint('_'), RangeError);\n  assert.throws(() => fromCodePoint('+Infinity'), RangeError);\n  assert.throws(() => fromCodePoint('-Infinity'), RangeError);\n  assert.throws(() => fromCodePoint(-1), RangeError);\n  assert.throws(() => fromCodePoint(0x10FFFF + 1), RangeError);\n  assert.throws(() => fromCodePoint(3.14), RangeError);\n  assert.throws(() => fromCodePoint(3e-2), RangeError);\n  assert.throws(() => fromCodePoint(-Infinity), RangeError);\n  assert.throws(() => fromCodePoint(Infinity), RangeError);\n  assert.throws(() => fromCodePoint(NaN), RangeError);\n  assert.throws(() => fromCodePoint(undefined), RangeError);\n  assert.throws(() => fromCodePoint({}), RangeError);\n  assert.throws(() => fromCodePoint(/./), RangeError);\n  let number = 0x60;\n  assert.same(fromCodePoint({\n    valueOf() {\n      return ++number;\n    }\n\n  }), 'a');\n  assert.same(number, 0x61); // one code unit per symbol\n\n  let counter = 2 ** 15 * 3 / 2;\n  let result = [];\n\n  while (--counter >= 0) result.push(0); // should not throw\n\n\n  fromCodePoint.apply(null, result);\n  counter = 2 ** 15 * 3 / 2;\n  result = [];\n\n  while (--counter >= 0) result.push(0xFFFF + 1); // should not throw\n\n\n  fromCodePoint.apply(null, result);\n});","file":"tests/es.string.from-code-point.js","skipped":false,"dir":"tests"},{"name":"String#includes","suites":[],"line":3,"code":"QUnit.test('String#includes', assert => {\n  const {\n    includes\n  } = String.prototype;\n  assert.isFunction(includes);\n  assert.arity(includes, 1);\n  assert.name(includes, 'includes');\n  assert.looksNative(includes);\n  assert.nonEnumerable(String.prototype, 'includes');\n  assert.false('abc'.includes());\n  assert.true('aundefinedb'.includes());\n  assert.true('abcd'.includes('b', 1));\n  assert.false('abcd'.includes('b', 2));\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => includes.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => includes.call('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => includes.call(null, '.'), TypeError);\n    assert.throws(() => includes.call(undefined, '.'), TypeError);\n  }\n\n  const regexp = /./;\n  assert.throws(() => '/./'.includes(regexp), TypeError);\n  regexp[Symbol.match] = false;\n  assert.notThrows(() => '/./'.includes(regexp));\n  const object = {};\n  assert.notThrows(() => '[object Object]'.includes(object));\n  object[Symbol.match] = true;\n  assert.throws(() => '[object Object]'.includes(object), TypeError);\n});","file":"tests/es.string.includes.js","skipped":false,"dir":"tests"},{"name":"String#italics","suites":[],"line":1,"code":"QUnit.test('String#italics', assert => {\n  const {\n    italics\n  } = String.prototype;\n  assert.isFunction(italics);\n  assert.arity(italics, 0);\n  assert.name(italics, 'italics');\n  assert.looksNative(italics);\n  assert.nonEnumerable(String.prototype, 'italics');\n  assert.same('a'.italics(), '<i>a</i>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => italics.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.italics.js","skipped":false,"dir":"tests"},{"name":"String#@@iterator","suites":[],"line":3,"code":"QUnit.test('String#@@iterator', assert => {\n  assert.isIterable(String.prototype);\n  let iterator = 'qwe'[Symbol.iterator]();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'String Iterator');\n  assert.same(String(iterator), '[object String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'w',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.same(Array.from('𠮷𠮷𠮷').length, 3);\n  iterator = '𠮷𠮷𠮷'[Symbol.iterator]();\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: '𠮷',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => ''[Symbol.iterator].call(Symbol()), 'throws on symbol context');\n});","file":"tests/es.string.iterator.js","skipped":false,"dir":"tests"},{"name":"String#link","suites":[],"line":1,"code":"QUnit.test('String#link', assert => {\n  const {\n    link\n  } = String.prototype;\n  assert.isFunction(link);\n  assert.arity(link, 1);\n  assert.name(link, 'link');\n  assert.looksNative(link);\n  assert.nonEnumerable(String.prototype, 'link');\n  assert.same('a'.link('b'), '<a href=\"b\">a</a>', 'lower case');\n  assert.same('a'.link('\"'), '<a href=\"&quot;\">a</a>', 'escape quotes');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => link.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => link.call('a', Symbol()), 'throws on symbol argument');\n  }\n});","file":"tests/es.string.link.js","skipped":false,"dir":"tests"},{"name":"String#matchAll","suites":[],"line":2,"code":"QUnit.test('String#matchAll', assert => {\n  const {\n    matchAll\n  } = String.prototype;\n  const {\n    assign\n  } = Object;\n  assert.isFunction(matchAll);\n  assert.arity(matchAll, 1);\n  assert.name(matchAll, 'matchAll');\n  assert.looksNative(matchAll);\n  assert.nonEnumerable(String.prototype, 'matchAll');\n  let data = ['aabc', {\n    toString() {\n      return 'aabc';\n    }\n\n  }];\n\n  for (const target of data) {\n    const iterator = matchAll.call(target, /[ac]/g);\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.deepEqual(iterator.next(), {\n      value: assign(['a'], {\n        input: 'aabc',\n        index: 0\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: assign(['a'], {\n        input: 'aabc',\n        index: 1\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: assign(['c'], {\n        input: 'aabc',\n        index: 3\n      }),\n      done: false\n    });\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    });\n  }\n\n  let iterator = '1111a2b3cccc'.matchAll(/(\\d)(\\D)/g);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'RegExp String Iterator');\n  assert.same(String(iterator), '[object RegExp String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: assign(['1a', '1', 'a'], {\n      input: '1111a2b3cccc',\n      index: 3\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['2b', '2', 'b'], {\n      input: '1111a2b3cccc',\n      index: 5\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['3c', '3', 'c'], {\n      input: '1111a2b3cccc',\n      index: 7\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => '1111a2b3cccc'.matchAll(/(\\d)(\\D)/), TypeError);\n  iterator = '1111a2b3cccc'.matchAll('(\\\\d)(\\\\D)');\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: assign(['1a', '1', 'a'], {\n      input: '1111a2b3cccc',\n      index: 3\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['2b', '2', 'b'], {\n      input: '1111a2b3cccc',\n      index: 5\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign(['3c', '3', 'c'], {\n      input: '1111a2b3cccc',\n      index: 7\n    }),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  /* IE8- issue\n  iterator = 'abc'.matchAll(/\\B/g);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: assign([''], {\n      input: 'abc',\n      index: 1,\n    }),\n    done: false,\n  });\n  assert.deepEqual(iterator.next(), {\n    value: assign([''], {\n      input: 'abc',\n      index: 2,\n    }),\n    done: false,\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true,\n  });\n  */\n\n  data = [null, undefined, NaN, 42, {}, []];\n\n  for (const target of data) {\n    assert.notThrows(() => ''.matchAll(target), `Not throws on ${target} as the first argument`);\n  }\n\n  if (DESCRIPTORS && typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => matchAll.call(Symbol(), /./), 'throws on symbol context');\n    assert.throws(() => matchAll.call('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => matchAll.call(null, /./g), TypeError, 'Throws on null as `this`');\n    assert.throws(() => matchAll.call(undefined, /./g), TypeError, 'Throws on undefined as `this`');\n  }\n});","file":"tests/es.string.match-all.js","skipped":false,"dir":"tests"},{"name":"String#match regression","suites":[],"line":232,"code":"QUnit.test('String#match regression', run);","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@match appearance","suites":[],"line":233,"code":"QUnit.test('RegExp#@@match appearance', assert => {\n  const match = /./[Symbol.match];\n  assert.isFunction(match); // assert.name(match, '[Symbol.match]');\n\n  assert.arity(match, 1);\n  assert.looksNative(match);\n  assert.nonEnumerable(RegExp.prototype, Symbol.match);\n});","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@match basic behavior","suites":[],"line":241,"code":"QUnit.test('RegExp#@@match basic behavior', assert => {\n  const string = '123456abcde7890';\n  const matches = ['12', '34', '56', '78', '90'];\n  assert.same(/\\d{2}/g[Symbol.match](string).length, 5);\n\n  for (let i = 0, {\n    length\n  } = matches; i < length; ++i) {\n    assert.same(/\\d{2}/g[Symbol.match](string)[i], matches[i]);\n  }\n});","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"String#match delegates to @@match","suites":[],"line":252,"code":"QUnit.test('String#match delegates to @@match', assert => {\n  const string = STRICT ? 'string' : Object('string');\n  const number = STRICT ? 42 : Object(42);\n  const object = {};\n\n  object[Symbol.match] = function (it) {\n    return {\n      value: it\n    };\n  };\n\n  assert.same(string.match(object).value, string);\n  assert.same(''.match.call(number, object).value, number);\n  const regexp = /./;\n\n  regexp[Symbol.match] = function (it) {\n    return {\n      value: it\n    };\n  };\n\n  assert.same(string.match(regexp).value, string);\n  assert.same(''.match.call(number, regexp).value, number);\n});","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@match delegates to exec","suites":[],"line":276,"code":"QUnit.test('RegExp#@@match delegates to exec', assert => {\n  const exec = function () {\n    execCalled = true;\n    return /./.exec.apply(this, arguments);\n  };\n\n  let execCalled = false;\n  let re = /[ac]/;\n  re.exec = exec;\n  assert.deepEqual(re[Symbol.match]('abc'), ['a']);\n  assert.true(execCalled);\n  re = /a/; // Not a function, should be ignored\n\n  re.exec = 3;\n  assert.deepEqual(re[Symbol.match]('abc'), ['a']);\n  re = /a/; // Does not return an object, should throw\n\n  re.exec = () => 3;\n\n  assert.throws(() => re[Symbol.match]('abc'));\n});","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@match implementation","suites":[],"line":297,"code":"QUnit.test('RegExp#@@match implementation', patchRegExp$exec(run));","file":"tests/es.string.match.js","skipped":false,"dir":"tests"},{"name":"String#padEnd","suites":[],"line":2,"code":"QUnit.test('String#padEnd', assert => {\n  const {\n    padEnd\n  } = String.prototype;\n  assert.isFunction(padEnd);\n  assert.arity(padEnd, 1);\n  assert.name(padEnd, 'padEnd');\n  assert.looksNative(padEnd);\n  assert.nonEnumerable(String.prototype, 'padEnd');\n  assert.same('abc'.padEnd(5), 'abc  ');\n  assert.same('abc'.padEnd(4, 'de'), 'abcd');\n  assert.same('abc'.padEnd(), 'abc');\n  assert.same('abc'.padEnd(5, '_'), 'abc__');\n  assert.same(''.padEnd(0), '');\n  assert.same('foo'.padEnd(1), 'foo');\n  assert.same('foo'.padEnd(5, ''), 'foo');\n  assert.throws(() => padEnd.call(Symbol(), 10, 'a'), 'throws on symbol context');\n  assert.throws(() => padEnd.call('a', 10, Symbol()), 'throws on symbol argument');\n\n  if (STRICT) {\n    assert.throws(() => padEnd.call(null, 0), TypeError);\n    assert.throws(() => padEnd.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.pad-end.js","skipped":false,"dir":"tests"},{"name":"String#padStart","suites":[],"line":2,"code":"QUnit.test('String#padStart', assert => {\n  const {\n    padStart\n  } = String.prototype;\n  assert.isFunction(padStart);\n  assert.arity(padStart, 1);\n  assert.name(padStart, 'padStart');\n  assert.looksNative(padStart);\n  assert.nonEnumerable(String.prototype, 'padStart');\n  assert.same('abc'.padStart(5), '  abc');\n  assert.same('abc'.padStart(4, 'de'), 'dabc');\n  assert.same('abc'.padStart(), 'abc');\n  assert.same('abc'.padStart(5, '_'), '__abc');\n  assert.same(''.padStart(0), '');\n  assert.same('foo'.padStart(1), 'foo');\n  assert.same('foo'.padStart(5, ''), 'foo');\n  assert.throws(() => padStart.call(Symbol(), 10, 'a'), 'throws on symbol context');\n  assert.throws(() => padStart.call('a', 10, Symbol()), 'throws on symbol argument');\n\n  if (STRICT) {\n    assert.throws(() => padStart.call(null, 0), TypeError);\n    assert.throws(() => padStart.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.pad-start.js","skipped":false,"dir":"tests"},{"name":"String.raw","suites":[],"line":1,"code":"QUnit.test('String.raw', assert => {\n  const {\n    raw\n  } = String;\n  assert.isFunction(raw);\n  assert.arity(raw, 1);\n  assert.name(raw, 'raw');\n  assert.looksNative(raw);\n  assert.nonEnumerable(String, 'raw');\n  assert.same(raw({\n    raw: ['Hi\\\\n', '!']\n  }, 'Bob'), 'Hi\\\\nBob!', 'raw is array');\n  assert.same(raw({\n    raw: 'test'\n  }, 0, 1, 2), 't0e1s2t', 'raw is string');\n  assert.same(raw({\n    raw: 'test'\n  }, 0), 't0est', 'lacks substituting');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => raw({\n      raw: [Symbol()]\n    }, 0), TypeError, 'throws on symbol #1');\n    assert.throws(() => raw({\n      raw: 'test'\n    }, Symbol()), TypeError, 'throws on symbol #2');\n  }\n\n  assert.throws(() => raw({}), TypeError);\n  assert.throws(() => raw({\n    raw: null\n  }), TypeError);\n});","file":"tests/es.string.raw.js","skipped":false,"dir":"tests"},{"name":"String#repeat","suites":[],"line":2,"code":"QUnit.test('String#repeat', assert => {\n  const {\n    repeat\n  } = String.prototype;\n  assert.isFunction(repeat);\n  assert.arity(repeat, 1);\n  assert.name(repeat, 'repeat');\n  assert.looksNative(repeat);\n  assert.nonEnumerable(String.prototype, 'repeat');\n  assert.same('qwe'.repeat(3), 'qweqweqwe');\n  assert.same('qwe'.repeat(2.5), 'qweqwe');\n  assert.throws(() => 'qwe'.repeat(-1), RangeError);\n  assert.throws(() => 'qwe'.repeat(Infinity), RangeError);\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => repeat.call(Symbol()), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => repeat.call(null, 1), TypeError);\n    assert.throws(() => repeat.call(undefined, 1), TypeError);\n  }\n});","file":"tests/es.string.repeat.js","skipped":false,"dir":"tests"},{"name":"String#replaceAll","suites":[],"line":2,"code":"QUnit.test('String#replaceAll', assert => {\n  const {\n    replaceAll\n  } = String.prototype;\n  assert.isFunction(replaceAll);\n  assert.arity(replaceAll, 2);\n  assert.name(replaceAll, 'replaceAll');\n  assert.looksNative(replaceAll);\n  assert.nonEnumerable(String.prototype, 'replaceAll');\n  assert.same('q=query+string+parameters'.replaceAll('+', ' '), 'q=query string parameters');\n  assert.same('foo'.replaceAll('o', {}), 'f[object Object][object Object]');\n  assert.same('[object Object]x[object Object]'.replaceAll({}, 'y'), 'yxy');\n  assert.same(replaceAll.call({}, 'bject', 'lolo'), '[ololo Ololo]');\n  assert.same('aba'.replaceAll('b', (search, i, string) => {\n    assert.same(search, 'b', '`search` is `b`');\n    assert.same(i, 1, '`i` is 1');\n    assert.same(string, 'aba', '`string` is `aba`');\n    return 'c';\n  }), 'aca');\n  const searcher = {\n    [Symbol.replace](O, replaceValue) {\n      assert.same(this, searcher, '`this` is `searcher`');\n      assert.same(String(O), 'aba', '`O` is `aba`');\n      assert.same(String(replaceValue), 'c', '`replaceValue` is `c`');\n      return 'foo';\n    }\n\n  };\n  assert.same('aba'.replaceAll(searcher, 'c'), 'foo');\n  assert.same('aba'.replaceAll('b'), 'aundefineda');\n  assert.same('xxx'.replaceAll('', '_'), '_x_x_x_');\n  assert.same('121314'.replaceAll('1', '$$'), '$2$3$4', '$$');\n  assert.same('121314'.replaceAll('1', '$&'), '121314', '$&');\n  assert.same('121314'.replaceAll('1', '$`'), '212312134', '$`');\n  assert.same('121314'.replaceAll('1', '$\\''), '213142314344', '$\\'');\n  assert.throws(() => replaceAll.call(Symbol(), 'a', 'b'), 'throws on symbol context');\n  assert.throws(() => replaceAll.call('a', Symbol(), 'b'), 'throws on symbol argument 1');\n  assert.throws(() => replaceAll.call('a', 'b', Symbol()), 'throws on symbol argument 2');\n\n  if (STRICT) {\n    assert.throws(() => replaceAll.call(null, 'a', 'b'), TypeError);\n    assert.throws(() => replaceAll.call(undefined, 'a', 'b'), TypeError);\n  }\n\n  assert.throws(() => 'b.b.b.b.b'.replaceAll(/\\./, 'a'), TypeError);\n  assert.same('b.b.b.b.b'.replaceAll(/\\./g, 'a'), 'babababab');\n  const object = {};\n  assert.same('[object Object]'.replaceAll(object, 'a'), 'a');\n});","file":"tests/es.string.replace-all.js","skipped":false,"dir":"tests"},{"name":"String#replace regression","suites":[],"line":163,"code":"QUnit.test('String#replace regression', run);","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@replace appearance","suites":[],"line":164,"code":"QUnit.test('RegExp#@@replace appearance', assert => {\n  const replace = /./[Symbol.replace];\n  assert.isFunction(replace); // assert.name(replace, '[Symbol.replace]');\n\n  assert.arity(replace, 2);\n  assert.looksNative(replace);\n  assert.nonEnumerable(RegExp.prototype, Symbol.replace);\n});","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@replace basic behavior","suites":[],"line":172,"code":"QUnit.test('RegExp#@@replace basic behavior', assert => {\n  assert.same(/([a-z]+)(\\d+)/[Symbol.replace]('abc12 def34', (a, b, c) => c + b), '12abc def34');\n});","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"String.replace delegates to @@replace","suites":[],"line":175,"code":"QUnit.test('String.replace delegates to @@replace', assert => {\n  const string = STRICT ? 'string' : Object('string');\n  const number = STRICT ? 42 : Object(42);\n  const object = {};\n\n  object[Symbol.replace] = function (a, b) {\n    return {\n      a,\n      b\n    };\n  };\n\n  assert.same(string.replace(object, 42).a, string);\n  assert.same(string.replace(object, 42).b, 42);\n  assert.same(''.replace.call(number, object, 42).a, number);\n  assert.same(''.replace.call(number, object, 42).b, 42);\n  const regexp = /./;\n\n  regexp[Symbol.replace] = function (a, b) {\n    return {\n      a,\n      b\n    };\n  };\n\n  assert.same(string.replace(regexp, 42).a, string);\n  assert.same(string.replace(regexp, 42).b, 42);\n  assert.same(''.replace.call(number, regexp, 42).a, number);\n  assert.same(''.replace.call(number, regexp, 42).b, 42);\n});","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@replace delegates to exec","suites":[],"line":205,"code":"QUnit.test('RegExp#@@replace delegates to exec', assert => {\n  const exec = function () {\n    execCalled = true;\n    return /./.exec.apply(this, arguments);\n  };\n\n  let execCalled = false;\n  let re = /[ac]/;\n  re.exec = exec;\n  assert.deepEqual(re[Symbol.replace]('abc', 'f'), 'fbc');\n  assert.true(execCalled);\n  assert.same(re.lastIndex, 0);\n  execCalled = false;\n  re = /[ac]/g;\n  re.exec = exec;\n  assert.deepEqual(re[Symbol.replace]('abc', 'f'), 'fbf');\n  assert.true(execCalled);\n  assert.same(re.lastIndex, 0);\n  re = /a/; // Not a function, should be ignored\n\n  re.exec = 3;\n  assert.deepEqual(re[Symbol.replace]('abc', 'f'), 'fbc');\n  re = /a/; // Does not return an object, should throw\n\n  re.exec = () => 3;\n\n  assert.throws(() => re[Symbol.replace]('abc', 'f'));\n});","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@replace correctly handles substitutions","suites":[],"line":233,"code":"QUnit.test('RegExp#@@replace correctly handles substitutions', assert => {\n  const re = /./;\n\n  re.exec = function () {\n    const result = ['23', '7'];\n    result.groups = {\n      '!!!': '7'\n    };\n    result.index = 1;\n    return result;\n  }; // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n\n\n  assert.same('1234'.replace(re, '$1'), '174'); // eslint-disable-next-line regexp/no-useless-dollar-replacements -- required for testing\n\n  assert.same('1234'.replace(re, '$<!!!>'), '174');\n  assert.same('1234'.replace(re, '$`'), '114');\n  assert.same('1234'.replace(re, '$\\''), '144');\n  assert.same('1234'.replace(re, '$$'), '1$4');\n  assert.same('1234'.replace(re, '$&'), '1234'); // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n\n  assert.same('1234'.replace(re, '$x'), '1$x4');\n  let args;\n  assert.same('1234'.replace(re, (..._args) => {\n    args = _args;\n    return 'x';\n  }), '1x4');\n  assert.deepEqual(args, ['23', '7', 1, '1234', {\n    '!!!': '7'\n  }]);\n});","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@replace implementation","suites":[],"line":264,"code":"QUnit.test('RegExp#@@replace implementation', patchRegExp$exec(run));","file":"tests/es.string.replace.js","skipped":false,"dir":"tests"},{"name":"String#search regression","suites":[],"line":88,"code":"QUnit.test('String#search regression', run);","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@search appearance","suites":[],"line":89,"code":"QUnit.test('RegExp#@@search appearance', assert => {\n  const search = /./[Symbol.search];\n  assert.isFunction(search); // assert.name(search, '[Symbol.search]');\n\n  assert.arity(search, 1);\n  assert.looksNative(search);\n  assert.nonEnumerable(RegExp.prototype, Symbol.search);\n});","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@search basic behavior","suites":[],"line":97,"code":"QUnit.test('RegExp#@@search basic behavior', assert => {\n  assert.same(/four/[Symbol.search]('one two three four five'), 14);\n  assert.same(/Four/[Symbol.search]('one two three four five'), -1);\n});","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"String#search delegates to @@search","suites":[],"line":101,"code":"QUnit.test('String#search delegates to @@search', assert => {\n  const string = STRICT ? 'string' : Object('string');\n  const number = STRICT ? 42 : Object(42);\n  const object = {};\n\n  object[Symbol.search] = function (it) {\n    return {\n      value: it\n    };\n  };\n\n  assert.same(string.search(object).value, string);\n  assert.same(''.search.call(number, object).value, number);\n  const regexp = /./;\n\n  regexp[Symbol.search] = function (it) {\n    return {\n      value: it\n    };\n  };\n\n  assert.same(string.search(regexp).value, string);\n  assert.same(''.search.call(number, regexp).value, number);\n});","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@search delegates to exec","suites":[],"line":125,"code":"QUnit.test('RegExp#@@search delegates to exec', assert => {\n  let execCalled = false;\n  let re = /b/;\n  re.lastIndex = 7;\n\n  re.exec = function () {\n    execCalled = true;\n    return /./.exec.apply(this, arguments);\n  };\n\n  assert.deepEqual(re[Symbol.search]('abc'), 1);\n  assert.true(execCalled);\n  assert.same(re.lastIndex, 7);\n  re = /b/; // Not a function, should be ignored\n\n  re.exec = 3;\n  assert.deepEqual(re[Symbol.search]('abc'), 1);\n  re = /b/; // Does not return an object, should throw\n\n  re.exec = () => 3;\n\n  assert.throws(() => re[Symbol.search]('abc'));\n});","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@search implementation","suites":[],"line":148,"code":"QUnit.test('RegExp#@@search implementation', patchRegExp$exec(run));","file":"tests/es.string.search.js","skipped":false,"dir":"tests"},{"name":"String#small","suites":[],"line":1,"code":"QUnit.test('String#small', assert => {\n  const {\n    small\n  } = String.prototype;\n  assert.isFunction(small);\n  assert.arity(small, 0);\n  assert.name(small, 'small');\n  assert.looksNative(small);\n  assert.nonEnumerable(String.prototype, 'small');\n  assert.same('a'.small(), '<small>a</small>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => small.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.small.js","skipped":false,"dir":"tests"},{"name":"String#split regression","suites":[],"line":828,"code":"QUnit.test('String#split regression', run);","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@split appearance","suites":[],"line":829,"code":"QUnit.test('RegExp#@@split appearance', assert => {\n  const split = /./[Symbol.split];\n  assert.isFunction(split); // assert.name(split, '[Symbol.split]');\n\n  assert.arity(split, 2);\n  assert.looksNative(split);\n  assert.nonEnumerable(RegExp.prototype, Symbol.split);\n});","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@split basic behavior","suites":[],"line":837,"code":"QUnit.test('RegExp#@@split basic behavior', assert => {\n  assert.same(/\\s/[Symbol.split]('a b c de f').length, 5);\n  assert.same(/\\s/[Symbol.split]('a b c de f', undefined).length, 5);\n  assert.same(/\\s/[Symbol.split]('a b c de f', 1).length, 1);\n  assert.same(/\\s/[Symbol.split]('a b c de f', 10).length, 5);\n});","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"String#split delegates to @@split","suites":[],"line":843,"code":"QUnit.test('String#split delegates to @@split', assert => {\n  const string = STRICT ? 'string' : Object('string');\n  const number = STRICT ? 42 : Object(42);\n  const object = {};\n\n  object[Symbol.split] = function (a, b) {\n    return {\n      a,\n      b\n    };\n  };\n\n  assert.same(string.split(object, 42).a, string);\n  assert.same(string.split(object, 42).b, 42);\n  assert.same(''.split.call(number, object, 42).a, number);\n  assert.same(''.split.call(number, object, 42).b, 42);\n  const regexp = /./;\n\n  regexp[Symbol.split] = function (a, b) {\n    return {\n      a,\n      b\n    };\n  };\n\n  assert.same(string.split(regexp, 42).a, string);\n  assert.same(string.split(regexp, 42).b, 42);\n  assert.same(''.split.call(number, regexp, 42).a, number);\n  assert.same(''.split.call(number, regexp, 42).b, 42);\n});","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@split delegates to exec","suites":[],"line":873,"code":"QUnit.test('RegExp#@@split delegates to exec', assert => {\n  let execCalled = false;\n  let speciesCalled = false;\n  let execSpeciesCalled = false;\n  const re = /[24]/;\n\n  re.exec = function () {\n    execCalled = true;\n    return /./.exec.apply(this, arguments);\n  };\n\n  re.constructor = {\n    // eslint-disable-next-line object-shorthand -- constructor\n    [Symbol.species]: function (source, flags) {\n      const re2 = new RegExp(source, flags);\n      speciesCalled = true;\n\n      re2.exec = function () {\n        execSpeciesCalled = true;\n        return /./.exec.apply(this, arguments);\n      };\n\n      return re2;\n    }\n  };\n  assert.deepEqual(re[Symbol.split]('123451234'), ['1', '3', '51', '3', '']);\n  assert.false(execCalled);\n  assert.true(speciesCalled);\n  assert.true(execSpeciesCalled);\n  re.constructor = {\n    // eslint-disable-next-line object-shorthand -- constructor\n    [Symbol.species]: function (source, flags) {\n      const re2 = new RegExp(source, flags); // Not a function, should be ignored\n\n      re2.exec = 3;\n      return re2;\n    }\n  };\n  assert.deepEqual(re[Symbol.split]('123451234'), ['1', '3', '51', '3', '']);\n  re.constructor = {\n    // eslint-disable-next-line object-shorthand -- constructor\n    [Symbol.species]: function (source, flags) {\n      const re2 = new RegExp(source, flags); // Does not return an object, should throw\n\n      re2.exec = () => 3;\n\n      return re2;\n    }\n  };\n  assert.throws(() => re[Symbol.split]('123451234'));\n});","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"RegExp#@@split implementation","suites":[],"line":924,"code":"QUnit.test('RegExp#@@split implementation', patchRegExp$exec(run));","file":"tests/es.string.split.js","skipped":false,"dir":"tests"},{"name":"String#startsWith","suites":[],"line":3,"code":"QUnit.test('String#startsWith', assert => {\n  const {\n    startsWith\n  } = String.prototype;\n  assert.isFunction(startsWith);\n  assert.arity(startsWith, 1);\n  assert.name(startsWith, 'startsWith');\n  assert.looksNative(startsWith);\n  assert.nonEnumerable(String.prototype, 'startsWith');\n  assert.true('undefined'.startsWith());\n  assert.false('undefined'.startsWith(null));\n  assert.true('abc'.startsWith(''));\n  assert.true('abc'.startsWith('a'));\n  assert.true('abc'.startsWith('ab'));\n  assert.false('abc'.startsWith('bc'));\n  assert.true('abc'.startsWith('', NaN));\n  assert.true('abc'.startsWith('a', -1));\n  assert.false('abc'.startsWith('a', 1));\n  assert.false('abc'.startsWith('a', Infinity));\n  assert.true('abc'.startsWith('b', true));\n  assert.true('abc'.startsWith('a', 'x'));\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => startsWith.call(Symbol(), 'b'), 'throws on symbol context');\n    assert.throws(() => startsWith.call('a', Symbol()), 'throws on symbol argument');\n  }\n\n  if (STRICT) {\n    assert.throws(() => startsWith.call(null, '.'), TypeError);\n    assert.throws(() => startsWith.call(undefined, '.'), TypeError);\n  }\n\n  const regexp = /./;\n  assert.throws(() => '/./'.startsWith(regexp), TypeError);\n  regexp[Symbol.match] = false;\n  assert.notThrows(() => '/./'.startsWith(regexp));\n  const object = {};\n  assert.notThrows(() => '[object Object]'.startsWith(object));\n  object[Symbol.match] = true;\n  assert.throws(() => '[object Object]'.startsWith(object), TypeError);\n});","file":"tests/es.string.starts-with.js","skipped":false,"dir":"tests"},{"name":"String#strike","suites":[],"line":1,"code":"QUnit.test('String#strike', assert => {\n  const {\n    strike\n  } = String.prototype;\n  assert.isFunction(strike);\n  assert.arity(strike, 0);\n  assert.name(strike, 'strike');\n  assert.looksNative(strike);\n  assert.nonEnumerable(String.prototype, 'strike');\n  assert.same('a'.strike(), '<strike>a</strike>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => strike.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.strike.js","skipped":false,"dir":"tests"},{"name":"String#sub","suites":[],"line":1,"code":"QUnit.test('String#sub', assert => {\n  const {\n    sub\n  } = String.prototype;\n  assert.isFunction(sub);\n  assert.arity(sub, 0);\n  assert.name(sub, 'sub');\n  assert.looksNative(sub);\n  assert.nonEnumerable(String.prototype, 'sub');\n  assert.same('a'.sub(), '<sub>a</sub>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => sub.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.sub.js","skipped":false,"dir":"tests"},{"name":"String#substr","suites":[],"line":3,"code":"QUnit.test('String#substr', assert => {\n  const {\n    substr\n  } = String.prototype;\n  assert.isFunction(substr);\n  assert.arity(substr, 2);\n  assert.name(substr, 'substr');\n  assert.looksNative(substr);\n  assert.nonEnumerable(String.prototype, 'substr');\n  assert.same('12345'.substr(1, 3), '234');\n  assert.same('ab'.substr(-1), 'b');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => substr.call(Symbol(), 1, 3), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => substr.call(null, 1, 3), TypeError, 'Throws on null as `this`');\n    assert.throws(() => substr.call(undefined, 1, 3), TypeError, 'Throws on undefined as `this`');\n  }\n});","file":"tests/es.string.substr.js","skipped":false,"dir":"tests"},{"name":"String#sup","suites":[],"line":1,"code":"QUnit.test('String#sup', assert => {\n  const {\n    sup\n  } = String.prototype;\n  assert.isFunction(sup);\n  assert.arity(sup, 0);\n  assert.name(sup, 'sup');\n  assert.looksNative(sup);\n  assert.nonEnumerable(String.prototype, 'sup');\n  assert.same('a'.sup(), '<sup>a</sup>', 'lower case');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => sup.call(Symbol()), 'throws on symbol context');\n  }\n});","file":"tests/es.string.sup.js","skipped":false,"dir":"tests"},{"name":"String#trimRight","suites":[],"line":2,"code":"QUnit.test('String#trimRight', assert => {\n  const {\n    trimRight\n  } = String.prototype;\n  assert.isFunction(trimRight);\n  assert.arity(trimRight, 0);\n  assert.name(trimRight, 'trimEnd');\n  assert.looksNative(trimRight);\n  assert.nonEnumerable(String.prototype, 'trimRight');\n  assert.same(' \\n  q w e \\n  '.trimRight(), ' \\n  q w e', 'removes whitespaces at right side of string');\n  assert.same(WHITESPACES.trimRight(), '', 'removes all whitespaces');\n  assert.same('\\u200B\\u0085'.trimRight(), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimRight.call(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimRight.call(null, 0), TypeError);\n    assert.throws(() => trimRight.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.trim-end.js","skipped":false,"dir":"tests"},{"name":"String#trimEnd","suites":[],"line":21,"code":"QUnit.test('String#trimEnd', assert => {\n  const {\n    trimEnd,\n    trimRight\n  } = String.prototype;\n  assert.isFunction(trimEnd);\n  assert.arity(trimEnd, 0);\n  assert.name(trimEnd, 'trimEnd');\n  assert.looksNative(trimEnd);\n  assert.nonEnumerable(String.prototype, 'trimEnd');\n  assert.same(trimEnd, trimRight, 'same #trimRight');\n  assert.same(' \\n  q w e \\n  '.trimEnd(), ' \\n  q w e', 'removes whitespaces at right side of string');\n  assert.same(WHITESPACES.trimEnd(), '', 'removes all whitespaces');\n  assert.same('\\u200B\\u0085'.trimEnd(), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimEnd.call(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimEnd.call(null, 0), TypeError);\n    assert.throws(() => trimEnd.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.trim-end.js","skipped":false,"dir":"tests"},{"name":"String#trimLeft","suites":[],"line":2,"code":"QUnit.test('String#trimLeft', assert => {\n  const {\n    trimLeft\n  } = String.prototype;\n  assert.isFunction(trimLeft);\n  assert.arity(trimLeft, 0);\n  assert.name(trimLeft, 'trimStart');\n  assert.looksNative(trimLeft);\n  assert.nonEnumerable(String.prototype, 'trimLeft');\n  assert.same(' \\n  q w e \\n  '.trimLeft(), 'q w e \\n  ', 'removes whitespaces at left side of string');\n  assert.same(WHITESPACES.trimLeft(), '', 'removes all whitespaces');\n  assert.same('\\u200B\\u0085'.trimLeft(), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimLeft.call(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimLeft.call(null, 0), TypeError);\n    assert.throws(() => trimLeft.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.trim-start.js","skipped":false,"dir":"tests"},{"name":"String#trimStart","suites":[],"line":21,"code":"QUnit.test('String#trimStart', assert => {\n  const {\n    trimStart,\n    trimLeft\n  } = String.prototype;\n  assert.isFunction(trimStart);\n  assert.arity(trimStart, 0);\n  assert.name(trimStart, 'trimStart');\n  assert.looksNative(trimStart);\n  assert.nonEnumerable(String.prototype, 'trimStart');\n  assert.same(trimStart, trimLeft, 'same #trimLeft');\n  assert.same(' \\n  q w e \\n  '.trimStart(), 'q w e \\n  ', 'removes whitespaces at left side of string');\n  assert.same(WHITESPACES.trimStart(), '', 'removes all whitespaces');\n  assert.same('\\u200B\\u0085'.trimStart(), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n  assert.throws(() => trimStart.call(Symbol()), 'throws on symbol context');\n\n  if (STRICT) {\n    assert.throws(() => trimStart.call(null, 0), TypeError);\n    assert.throws(() => trimStart.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.trim-start.js","skipped":false,"dir":"tests"},{"name":"String#trim","suites":[],"line":2,"code":"QUnit.test('String#trim', assert => {\n  const {\n    trim\n  } = String.prototype;\n  assert.isFunction(''.trim);\n  assert.arity(trim, 0);\n  assert.name(trim, 'trim');\n  assert.looksNative(trim);\n  assert.nonEnumerable(String.prototype, 'trim');\n  assert.same(' \\n  q w e \\n  '.trim(), 'q w e', 'removes whitespaces at left & right side of string');\n  assert.same(WHITESPACES.trim(), '', 'removes all whitespaces');\n  assert.same('\\u200B\\u0085'.trim(), '\\u200B\\u0085', \"shouldn't remove this symbols\");\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => trim.call(Symbol()), 'throws on symbol context');\n  }\n\n  if (STRICT) {\n    assert.throws(() => trim.call(null, 0), TypeError);\n    assert.throws(() => trim.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.string.trim.js","skipped":false,"dir":"tests"},{"name":"Symbol.asyncIterator","suites":[],"line":2,"code":"QUnit.test('Symbol.asyncIterator', assert => {\n  assert.true('asyncIterator' in Symbol, 'Symbol.asyncIterator available');\n  assert.nonEnumerable(Symbol, 'asyncIterator');\n  assert.true(Object(Symbol.asyncIterator) instanceof Symbol, 'Symbol.asyncIterator is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'asyncIterator');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/es.symbol.async-iterator.js","skipped":false,"dir":"tests"},{"name":"Symbol","suites":[],"line":14,"code":"QUnit.test('Symbol', assert => {\n  assert.isFunction(Symbol);\n  if (NATIVE) assert.same(Symbol.length, 0, 'arity is 0');\n  assert.name(Symbol, 'Symbol');\n  assert.looksNative(Symbol);\n  const symbol1 = Symbol('symbol');\n  const symbol2 = Symbol('symbol');\n  assert.notSame(symbol1, symbol2, 'Symbol(\"symbol\") !== Symbol(\"symbol\")');\n  const object = {};\n  object[symbol1] = 42;\n  assert.same(object[symbol1], 42, 'Symbol() work as key');\n  assert.notSame(object[symbol2], 42, 'Various symbols from one description are various keys'); // assert.throws(() => Symbol(Symbol('foo')), 'throws on symbol argument');\n\n  if (DESCRIPTORS) {\n    let count = 0; // eslint-disable-next-line no-unused-vars -- required for testing\n\n    for (const key in object) count++;\n\n    assert.same(count, 0, 'object[Symbol()] is not enumerable');\n  }\n});","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Well-known Symbols","suites":[],"line":35,"code":"QUnit.test('Well-known Symbols', assert => {\n  const wks = ['hasInstance', 'isConcatSpreadable', 'iterator', 'match', 'matchAll', 'replace', 'search', 'species', 'split', 'toPrimitive', 'toStringTag', 'unscopables'];\n\n  for (const name of wks) {\n    assert.true(name in Symbol, `Symbol.${name} available`);\n    assert.true(Object(Symbol[name]) instanceof Symbol, `Symbol.${name} is symbol`);\n\n    if (DESCRIPTORS) {\n      const descriptor = getOwnPropertyDescriptor(Symbol, name);\n      assert.false(descriptor.enumerable, 'non-enumerable');\n      assert.false(descriptor.writable, 'non-writable');\n      assert.false(descriptor.configurable, 'non-configurable');\n    }\n  }\n});","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol#@@toPrimitive","suites":[],"line":50,"code":"QUnit.test('Symbol#@@toPrimitive', assert => {\n  const symbol = Symbol();\n  assert.isFunction(Symbol.prototype[Symbol.toPrimitive]);\n  assert.same(symbol, symbol[Symbol.toPrimitive](), 'works');\n});","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol#@@toStringTag","suites":[],"line":55,"code":"QUnit.test('Symbol#@@toStringTag', assert => {\n  assert.same(Symbol.prototype[Symbol.toStringTag], 'Symbol', 'Symbol::@@toStringTag is `Symbol`');\n});","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & descriptors","suites":[],"line":60,"code":"  QUnit.test('Symbols & descriptors', assert => {\n    const d = Symbol('d');\n    const e = Symbol('e');\n    const f = Symbol('f');\n    const i = Symbol('i');\n    const j = Symbol('j');\n    const prototype = {\n      g: 'g'\n    };\n    prototype[i] = 'i';\n    defineProperty(prototype, 'h', {\n      value: 'h'\n    });\n    defineProperty(prototype, 'j', {\n      value: 'j'\n    });\n    const object = create(prototype);\n    object.a = 'a';\n    object[d] = 'd';\n    defineProperty(object, 'b', {\n      value: 'b'\n    });\n    defineProperty(object, 'c', {\n      value: 'c',\n      enumerable: true\n    });\n    defineProperty(object, e, {\n      configurable: true,\n      writable: true,\n      value: 'e'\n    });\n    const descriptor = {\n      value: 'f',\n      enumerable: true\n    };\n    defineProperty(object, f, descriptor);\n    assert.true(descriptor.enumerable, 'defineProperty not changes descriptor object');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'a'), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'a'\n    }, 'getOwnPropertyDescriptor a');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'b'), {\n      configurable: false,\n      writable: false,\n      enumerable: false,\n      value: 'b'\n    }, 'getOwnPropertyDescriptor b');\n    assert.deepEqual(getOwnPropertyDescriptor(object, 'c'), {\n      configurable: false,\n      writable: false,\n      enumerable: true,\n      value: 'c'\n    }, 'getOwnPropertyDescriptor c');\n    assert.deepEqual(getOwnPropertyDescriptor(object, d), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'd'\n    }, 'getOwnPropertyDescriptor d');\n    assert.deepEqual(getOwnPropertyDescriptor(object, e), {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: 'e'\n    }, 'getOwnPropertyDescriptor e');\n    assert.deepEqual(getOwnPropertyDescriptor(object, f), {\n      configurable: false,\n      writable: false,\n      enumerable: true,\n      value: 'f'\n    }, 'getOwnPropertyDescriptor f');\n    assert.same(getOwnPropertyDescriptor(object, 'g'), undefined, 'getOwnPropertyDescriptor g');\n    assert.same(getOwnPropertyDescriptor(object, 'h'), undefined, 'getOwnPropertyDescriptor h');\n    assert.same(getOwnPropertyDescriptor(object, i), undefined, 'getOwnPropertyDescriptor i');\n    assert.same(getOwnPropertyDescriptor(object, j), undefined, 'getOwnPropertyDescriptor j');\n    assert.same(getOwnPropertyDescriptor(object, 'k'), undefined, 'getOwnPropertyDescriptor k');\n    assert.false(getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable, 'getOwnPropertyDescriptor on Object.prototype');\n    assert.same(getOwnPropertyDescriptor(Object.prototype, d), undefined, 'getOwnPropertyDescriptor on Object.prototype missed symbol');\n    assert.same(keys(object).length, 2, 'Object.keys');\n    assert.same(getOwnPropertyNames(object).length, 3, 'Object.getOwnPropertyNames');\n    assert.same(getOwnPropertySymbols(object).length, 3, 'Object.getOwnPropertySymbols');\n    assert.same(ownKeys(object).length, 6, 'Reflect.ownKeys');\n    delete object[e];\n    object[e] = 'e';\n    assert.deepEqual(getOwnPropertyDescriptor(object, e), {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: 'e'\n    }, 'redefined non-enum key');\n  });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & Object.defineProperties","suites":[],"line":153,"code":"  QUnit.test('Symbols & Object.defineProperties', assert => {\n    const c = Symbol('c');\n    const d = Symbol('d');\n    const descriptors = {\n      a: {\n        value: 'a'\n      }\n    };\n    descriptors[c] = {\n      value: 'c'\n    };\n    defineProperty(descriptors, 'b', {\n      value: {\n        value: 'b'\n      }\n    });\n    defineProperty(descriptors, d, {\n      value: {\n        value: 'd'\n      }\n    });\n    const object = defineProperties({}, descriptors);\n    assert.same(object.a, 'a', 'a');\n    assert.same(object.b, undefined, 'b');\n    assert.same(object[c], 'c', 'c');\n    assert.same(object[d], undefined, 'd');\n  });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbols & Object.create","suites":[],"line":180,"code":"  QUnit.test('Symbols & Object.create', assert => {\n    const c = Symbol('c');\n    const d = Symbol('d');\n    const descriptors = {\n      a: {\n        value: 'a'\n      }\n    };\n    descriptors[c] = {\n      value: 'c'\n    };\n    defineProperty(descriptors, 'b', {\n      value: {\n        value: 'b'\n      }\n    });\n    defineProperty(descriptors, d, {\n      value: {\n        value: 'd'\n      }\n    });\n    const object = create(null, descriptors);\n    assert.same(object.a, 'a', 'a');\n    assert.same(object.b, undefined, 'b');\n    assert.same(object[c], 'c', 'c');\n    assert.same(object[d], undefined, 'd');\n  });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"@@species","suites":[],"line":210,"code":"    QUnit.test(`${name}@@species`, assert => {\n      assert.same(GLOBAL[name][Symbol.species], GLOBAL[name], `${name}@@species === ${name}`);\n      const Subclass = create(GLOBAL[name]);\n      assert.same(Subclass[Symbol.species], Subclass, `${name} subclass`);\n    });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Array@@species","suites":[],"line":217,"code":"  QUnit.test('Array@@species', assert => {\n    assert.same(Array[Symbol.species], Array, 'Array@@species === Array');\n    const Subclass = create(Array);\n    assert.same(Subclass[Symbol.species], Subclass, 'Array subclass');\n  });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol.sham flag","suites":[],"line":222,"code":"  QUnit.test('Symbol.sham flag', assert => {\n    assert.same(Symbol.sham, typeof Symbol() == 'symbol' ? undefined : true);\n  });","file":"tests/es.symbol.constructor.js","skipped":false,"dir":"tests"},{"name":"Symbol#description","suites":[],"line":2,"code":"QUnit.test('Symbol#description', assert => {\n  assert.same(Symbol('foo').description, 'foo');\n  assert.same(Symbol('').description, '');\n  assert.same(Symbol(')').description, ')');\n  assert.same(Symbol({}).description, '[object Object]');\n  assert.same(Symbol(null).description, 'null');\n  assert.same(Symbol(undefined).description, undefined);\n  assert.same(Symbol().description, undefined);\n  assert.same(Object(Symbol('foo')).description, 'foo');\n  assert.same(Object(Symbol()).description, undefined);\n\n  if (DESCRIPTORS) {\n    assert.false(Object.hasOwn(Symbol('foo'), 'description'));\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol.prototype, 'description');\n    assert.false(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n  }\n\n  if (typeof Symbol() == 'symbol') {\n    assert.same(Symbol('foo').toString(), 'Symbol(foo)');\n    assert.same(String(Symbol('foo')), 'Symbol(foo)');\n    assert.same(Symbol('').toString(), 'Symbol()');\n    assert.same(String(Symbol('')), 'Symbol()');\n    assert.same(Symbol().toString(), 'Symbol()');\n    assert.same(String(Symbol()), 'Symbol()');\n  }\n});","file":"tests/es.symbol.description.js","skipped":false,"dir":"tests"},{"name":"Symbol.for","suites":[],"line":2,"code":"QUnit.test('Symbol.for', assert => {\n  assert.isFunction(Symbol.for, 'Symbol.for is function');\n  assert.nonEnumerable(Symbol, 'for');\n  assert.strictEqual(Symbol.for.length, 1, 'Symbol.for arity is 1');\n  if (NATIVE) assert.strictEqual(Symbol.for.name, 'for', 'Symbol.for.name is \"for\"');\n  assert.looksNative(Symbol.for, 'Symbol.for looks like native');\n  const symbol = Symbol.for('foo');\n  assert.strictEqual(Symbol.for('foo'), symbol, 'registry');\n  assert.true(Object(symbol) instanceof Symbol, 'returns symbol');\n  assert.throws(() => Symbol.for(Symbol('foo')), 'throws on symbol argument');\n});","file":"tests/es.symbol.for.js","skipped":false,"dir":"tests"},{"name":"Symbol.keyFor","suites":[],"line":1,"code":"QUnit.test('Symbol.keyFor', assert => {\n  assert.isFunction(Symbol.keyFor, 'Symbol.keyFor is function');\n  assert.nonEnumerable(Symbol, 'keyFor');\n  assert.strictEqual(Symbol.keyFor.length, 1, 'Symbol.keyFor arity is 1');\n  assert.strictEqual(Symbol.keyFor.name, 'keyFor', 'Symbol.keyFor.name is \"keyFor\"');\n  assert.looksNative(Symbol.keyFor, 'Symbol.keyFor looks like native');\n  assert.strictEqual(Symbol.keyFor(Symbol.for('foo')), 'foo');\n  assert.strictEqual(Symbol.keyFor(Symbol('foo')), undefined);\n  assert.throws(() => Symbol.keyFor('foo'), 'throws on non-symbol');\n});","file":"tests/es.symbol.key-for.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.indexOf","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.indexOf', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      at\n    } = TypedArray.prototype;\n    assert.isFunction(at);\n    assert.arity(at, 1);\n    assert.name(at, 'at');\n    assert.looksNative(at);\n    assert.same(1, new TypedArray([1, 2, 3]).at(0));\n    assert.same(2, new TypedArray([1, 2, 3]).at(1));\n    assert.same(3, new TypedArray([1, 2, 3]).at(2));\n    assert.same(undefined, new TypedArray([1, 2, 3]).at(3));\n    assert.same(3, new TypedArray([1, 2, 3]).at(-1));\n    assert.same(2, new TypedArray([1, 2, 3]).at(-2));\n    assert.same(1, new TypedArray([1, 2, 3]).at(-3));\n    assert.same(undefined, new TypedArray([1, 2, 3]).at(-4));\n    assert.same(1, new TypedArray([1, 2, 3]).at(0.4));\n    assert.same(1, new TypedArray([1, 2, 3]).at(0.5));\n    assert.same(1, new TypedArray([1, 2, 3]).at(0.6));\n    assert.same(1, new TypedArray([1]).at(NaN));\n    assert.same(1, new TypedArray([1]).at());\n    assert.same(1, new TypedArray([1, 2, 3]).at(-0));\n    assert.throws(() => at.call({\n      0: 1,\n      length: 1\n    }, 0), TypeError);\n    assert.throws(() => at.call(null, 0), TypeError);\n    assert.throws(() => at.call(undefined, 0), TypeError);\n  }\n});","file":"tests/es.typed-array.at.js","skipped":false,"dir":"tests"},{"name":" constructor","suites":[],"line":16,"code":"    QUnit.test(`${name} constructor`, assert => {\n      assert.isFunction(TypedArray);\n      assert.arity(TypedArray, 3);\n      assert.name(TypedArray, name); // Safari 5 bug\n\n      if (NATIVE) assert.looksNative(TypedArray);\n      assert.same(TypedArray.BYTES_PER_ELEMENT, bytes, `${name}.BYTES_PER_ELEMENT`);\n      let array = new TypedArray(4);\n      assert.same(array.BYTES_PER_ELEMENT, bytes, '#BYTES_PER_ELEMENT');\n      assert.same(array.byteOffset, 0, `${name}#byteOffset, passed number`);\n      assert.same(array.byteLength, 4 * bytes, '#byteLength, passed number');\n      assert.arrayEqual(array, [0, 0, 0, 0], 'correct values, passed number');\n      assert.notThrows(() => {\n        // throws in IE / Edge / FF\n        array = new TypedArray('0x4');\n        assert.same(array.byteOffset, 0, '#byteOffset, passed string');\n        assert.same(array.byteLength, 4 * bytes, '#byteLength, passed string');\n        assert.arrayEqual(array, [0, 0, 0, 0], 'correct values, passed string');\n        return true;\n      }, 'passed string');\n      assert.notThrows(() => {\n        // throws in IE / Edge / FF\n        array = new TypedArray(true);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed boolean');\n        assert.same(array.byteLength, 1 * bytes, '#byteLength, passed boolean');\n        assert.arrayEqual(array, [0], 'correct values, passed boolean');\n        return true;\n      }, 'passed boolean');\n      assert.notThrows(() => {\n        array = new TypedArray();\n        assert.same(array.byteOffset, 0, '#byteOffset, without arguments');\n        assert.same(array.byteLength, 0, '#byteLength, without arguments');\n        assert.arrayEqual(array, [], 'correct values, without arguments');\n        return true;\n      }, 'without arguments');\n      assert.notThrows(() => {\n        array = new TypedArray(undefined);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed undefined');\n        assert.same(array.byteLength, 0, '#byteLength, passed undefined');\n        assert.arrayEqual(array, [], 'correct values, passed undefined');\n        return true;\n      }, 'passed undefined');\n      assert.notThrows(() => {\n        array = new TypedArray(-0);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed -0');\n        assert.same(array.byteLength, 0, '#byteLength, passed -0');\n        assert.arrayEqual(array, [], 'correct values, passed -0');\n        return true;\n      }, 'passed -0');\n      assert.notThrows(() => {\n        array = new TypedArray(NaN);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed NaN');\n        assert.same(array.byteLength, 0, '#byteLength, passed NaN');\n        assert.arrayEqual(array, [], 'correct values, passed NaN');\n        return true;\n      }, 'passed NaN');\n      assert.notThrows(() => {\n        array = new TypedArray(1.5);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed 1.5');\n        assert.same(array.byteLength, 1 * bytes, '#byteLength, passed 1.5');\n        assert.arrayEqual(array, [0], 'correct values, passed 1.5');\n        return true;\n      }, 'passed 1.5');\n      if (NATIVE) assert.throws(() => new TypedArray(-1), RangeError, 'throws on -1');\n      assert.notThrows(() => {\n        array = new TypedArray(null);\n        assert.same(array.byteOffset, 0, '#byteOffset, passed null');\n        assert.same(array.byteLength, 0, '#byteLength, passed null');\n        assert.arrayEqual(array, [], 'correct values, passed null');\n        return true;\n      }, 'passed null');\n      array = new TypedArray([1, 2, 3, 4]);\n      assert.same(array.byteOffset, 0, '#byteOffset, passed array');\n      assert.same(array.byteLength, 4 * bytes, '#byteLength, passed array');\n      assert.arrayEqual(array, [1, 2, 3, 4], 'correct values, passed array');\n      array = new TypedArray({\n        0: 1,\n        1: 2,\n        2: 3,\n        3: 4,\n        length: 4\n      });\n      assert.same(array.byteOffset, 0, '#byteOffset, passed array-like');\n      assert.same(array.byteLength, 4 * bytes, '#byteLength, passed array-like');\n      assert.arrayEqual(array, [1, 2, 3, 4], 'correct values, passed array-like');\n      assert.notThrows(() => {\n        // throws in IE / Edge\n        array = new TypedArray({});\n        assert.same(array.byteOffset, 0, '#byteOffset, passed empty object (also array-like case)');\n        assert.same(array.byteLength, 0, '#byteLength, passed empty object (also array-like case)');\n        assert.arrayEqual(array, [], 'correct values, passed empty object (also array-like case)');\n        return true;\n      }, 'passed empty object (also array-like case)');\n      assert.notThrows(() => {\n        array = new TypedArray(createIterable([1, 2, 3, 4]));\n        assert.same(array.byteOffset, 0, '#byteOffset, passed iterable');\n        assert.same(array.byteLength, 4 * bytes, '#byteLength, passed iterable');\n        assert.arrayEqual(array, [1, 2, 3, 4], 'correct values, passed iterable');\n        return true;\n      }, 'passed iterable');\n      array = new TypedArray(new TypedArray([1, 2, 3, 4]));\n      assert.same(array.byteOffset, 0, '#byteOffset, passed typed array');\n      assert.same(array.byteLength, 4 * bytes, '#byteLength, passed typed array');\n      assert.arrayEqual(array, [1, 2, 3, 4], 'correct values, passed typed array');\n      const fake = new TypedArray([1, 2, 3, 4]);\n\n      fake[Symbol.iterator] = function () {\n        return createIterable([4, 3, 2, 1])[Symbol.iterator]();\n      };\n\n      array = new TypedArray(fake);\n      assert.same(array.byteOffset, 0, '#byteOffset, passed typed array with custom iterator');\n      assert.same(array.byteLength, 4 * bytes, '#byteLength, passed typed array with custom iterator'); // https://code.google.com/p/v8/issues/detail?id=4552\n\n      assert.arrayEqual(array, [1, 2, 3, 4], 'correct values, passed typed array with custom iterator');\n      array = new TypedArray(new ArrayBuffer(8));\n      assert.same(array.byteOffset, 0, '#byteOffset, passed buffer');\n      assert.same(array.byteLength, 8, '#byteLength, passed buffer');\n      assert.same(array.length, 8 / bytes, 'correct length, passed buffer');\n      array = new TypedArray(new ArrayBuffer(16), 8);\n      assert.same(array.byteOffset, 8, '#byteOffset, passed buffer and byteOffset');\n      assert.same(array.byteLength, 8, '#byteLength, passed buffer and byteOffset');\n      assert.same(array.length, 8 / bytes, 'correct length, passed buffer and byteOffset');\n      array = new TypedArray(new ArrayBuffer(24), 8, 8 / bytes);\n      assert.same(array.byteOffset, 8, '#byteOffset, passed buffer, byteOffset and length');\n      assert.same(array.byteLength, 8, '#byteLength, passed buffer, byteOffset and length');\n      assert.same(array.length, 8 / bytes, 'correct length, passed buffer, byteOffset and length');\n      array = new TypedArray(new ArrayBuffer(8), undefined);\n      assert.same(array.byteOffset, 0, '#byteOffset, passed buffer and undefined');\n      assert.same(array.byteLength, 8, '#byteLength, passed buffer and undefined');\n      assert.same(array.length, 8 / bytes, 'correct length, passed buffer and undefined');\n      array = new TypedArray(new ArrayBuffer(16), 8, undefined);\n      assert.same(array.byteOffset, 8, '#byteOffset, passed buffer, byteOffset and undefined');\n      assert.same(array.byteLength, 8, '#byteLength, passed buffer, byteOffset and undefined');\n      assert.same(array.length, 8 / bytes, 'correct length, passed buffer, byteOffset and undefined');\n      array = new TypedArray(new ArrayBuffer(8), 8);\n      assert.same(array.byteOffset, 8, '#byteOffset, passed buffer and byteOffset with buffer length');\n      assert.same(array.byteLength, 0, '#byteLength, passed buffer and byteOffset with buffer length');\n      assert.arrayEqual(array, [], 'correct values, passed buffer and byteOffset with buffer length'); // FF bug - TypeError instead of RangeError\n\n      assert.throws(() => new TypedArray(new ArrayBuffer(8), -1), RangeError, 'If offset < 0, throw a RangeError exception');\n\n      if (bytes !== 1) {\n        // FF bug - TypeError instead of RangeError\n        assert.throws(() => new TypedArray(new ArrayBuffer(8), 3), RangeError, 'If offset modulo elementSize ≠ 0, throw a RangeError exception');\n      }\n\n      if (NATIVE) {\n        if (bytes !== 1) {\n          // fails in Opera 12\n          assert.throws(() => new TypedArray(new ArrayBuffer(9)), RangeError, 'If bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception');\n        }\n\n        assert.throws(() => new TypedArray(new ArrayBuffer(8), 16), RangeError, 'If newByteLength < 0, throw a RangeError exception');\n        assert.throws(() => new TypedArray(new ArrayBuffer(24), 8, 24), RangeError, 'If offset+newByteLength > bufferByteLength, throw a RangeError exception');\n      } else {\n        // FF bug - TypeError instead of RangeError\n        assert.throws(() => new TypedArray(new ArrayBuffer(8), 16), 'If newByteLength < 0, throw a RangeError exception');\n        assert.throws(() => new TypedArray(new ArrayBuffer(24), 8, 24), 'If offset+newByteLength > bufferByteLength, throw a RangeError exception');\n      }\n\n      assert.throws(() => TypedArray(1), TypeError, 'throws without `new`');\n      assert.same(TypedArray[Symbol.species], TypedArray, '@@species');\n    });","file":"tests/es.typed-array.constructors.js","skipped":false,"dir":"tests"},{"name":" descriptors","suites":[],"line":180,"code":"    QUnit.test(`${name} descriptors`, assert => {\n      const array = new TypedArray(2);\n      const descriptor = getOwnPropertyDescriptor(array, 0);\n      const base = NATIVE ? {\n        writable: true,\n        enumerable: true,\n        configurable: false\n      } : {\n        writable: descriptor.writable,\n        enumerable: true,\n        configurable: descriptor.configurable\n      };\n      assert.deepEqual(getOwnPropertyDescriptor(array, 0), assign({\n        value: 0\n      }, base), 'Object.getOwnPropertyDescriptor');\n\n      if (NATIVE) {\n        // fails in old WebKit\n        assert.arrayEqual(keys(array), ['0', '1'], 'Object.keys');\n        const results = [];\n\n        for (const key in array) results.push(key); // fails in old WebKit\n\n\n        assert.arrayEqual(results, ['0', '1'], 'for-in');\n        defineProperty(array, 0, {\n          value: 1,\n          writable: true,\n          enumerable: true,\n          configurable: false\n        });\n        array[0] = array[1] = 2.5;\n        assert.deepEqual(getOwnPropertyDescriptor(array, 0), assign({\n          value: array[1]\n        }, base), 'Object.defineProperty, valid descriptor #1');\n        defineProperty(array, 0, {\n          value: 1\n        });\n        array[0] = array[1] = 3.5;\n        assert.deepEqual(getOwnPropertyDescriptor(array, 0), assign({\n          value: array[1]\n        }, base), 'Object.defineProperty, valid descriptor #2');\n        assert.throws(() => defineProperty(array, 0, {\n          value: 2,\n          writable: false,\n          enumerable: true,\n          configurable: false\n        }), 'Object.defineProperty, invalid descriptor #1');\n        assert.throws(() => defineProperty(array, 0, {\n          value: 2,\n          writable: true,\n          enumerable: false,\n          configurable: false\n        }), 'Object.defineProperty, invalid descriptor #2');\n        assert.throws(() => defineProperty(array, 0, {\n          get() {\n            return 2;\n          }\n\n        }), 'Object.defineProperty, invalid descriptor #3');\n      }\n\n      assert.throws(() => defineProperty(array, 0, {\n        value: 2,\n\n        get() {\n          return 2;\n        }\n\n      }), 'Object.defineProperty, invalid descriptor #4');\n    });","file":"tests/es.typed-array.constructors.js","skipped":false,"dir":"tests"},{"name":" @@toStringTag","suites":[],"line":251,"code":"    QUnit.test(`${name} @@toStringTag`, assert => {\n      const TypedArrayPrototype = getPrototypeOf(TypedArray.prototype);\n      const descriptor = getOwnPropertyDescriptor(TypedArrayPrototype, Symbol.toStringTag);\n      const getter = descriptor.get;\n      assert.isFunction(getter);\n      assert.same(getter.call(new Int8Array(1)), 'Int8Array');\n      assert.same(getter.call(new TypedArray(1)), name);\n      assert.same(getter.call([]), undefined);\n      assert.same(getter.call({}), undefined);\n      assert.same(getter.call(), undefined);\n    });","file":"tests/es.typed-array.constructors.js","skipped":false,"dir":"tests"},{"name":".sham","suites":[],"line":262,"code":"    QUnit.test(`${name}.sham`, assert => {\n      if (TypedArray.sham) assert.required(`${name}.sham flag exists`);else assert.required(`${name}.sham flag missed`);\n    });","file":"tests/es.typed-array.constructors.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.copyWithin","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.copyWithin', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      copyWithin\n    } = TypedArray.prototype;\n    assert.isFunction(copyWithin, `${name}::copyWithin is function`);\n    assert.arity(copyWithin, 2, `${name}::copyWithin arity is 2`);\n    assert.name(copyWithin, 'copyWithin', `${name}::copyWithin name is 'copyWithin'`);\n    assert.looksNative(copyWithin, `${name}::copyWithin looks native`);\n    const array = new TypedArray(5);\n    assert.same(array.copyWithin(0), array, 'return this');\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(0, 3), [4, 5, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(1, 3), [1, 4, 5, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(1, 2), [1, 3, 4, 5, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(2, 2), [1, 2, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(0, 3, 4), [4, 2, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(1, 3, 4), [1, 4, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(1, 2, 4), [1, 3, 4, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(0, -2), [4, 5, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(0, -2, -1), [4, 2, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(-4, -3, -2), [1, 3, 3, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(-4, -3, -1), [1, 3, 4, 4, 5]);\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4, 5]).copyWithin(-4, -3), [1, 3, 4, 5, 5]);\n    assert.throws(() => copyWithin.call([0], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.copy-within.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.every","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.every', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      every\n    } = TypedArray.prototype;\n    assert.isFunction(every, `${name}::every is function`);\n    assert.arity(every, 1, `${name}::every arity is 1`);\n    assert.name(every, 'every', `${name}::every name is 'every'`);\n    assert.looksNative(every, `${name}::every looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.every(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.true(new TypedArray([1, 2, 3]).every(it => typeof it == 'number'));\n    assert.true(new TypedArray([1, 2, 3]).every(it => it < 4));\n    assert.false(new TypedArray([1, 2, 3]).every(it => it < 3));\n    assert.false(new TypedArray([1, 2, 3]).every(it => typeof it == 'string'));\n    assert.true(new TypedArray([1, 2, 3]).every(function () {\n      return +this === 1;\n    }, 1));\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).every((value, key) => {\n      values += value;\n      keys += key;\n      return true;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => every.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.every.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.fill","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.fill', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      fill\n    } = TypedArray.prototype;\n    assert.isFunction(fill, `${name}::fill is function`);\n    assert.arity(fill, 1, `${name}::fill arity is 1`);\n    assert.name(fill, 'fill', `${name}::fill name is 'fill'`);\n    assert.looksNative(fill, `${name}::fill looks native`);\n    const array = new TypedArray(5);\n    assert.same(array.fill(5), array, 'return this');\n    assert.arrayEqual(new TypedArray(5).fill(5), [5, 5, 5, 5, 5], 'basic');\n    assert.arrayEqual(new TypedArray(5).fill(5, 1), [0, 5, 5, 5, 5], 'start index');\n    assert.arrayEqual(new TypedArray(5).fill(5, 1, 4), [0, 5, 5, 5, 0], 'end index');\n    assert.arrayEqual(new TypedArray(5).fill(5, 6, 1), [0, 0, 0, 0, 0], 'start > end');\n    assert.arrayEqual(new TypedArray(5).fill(5, -3, 4), [0, 0, 5, 5, 0], 'negative start index');\n    assert.throws(() => fill.call([0], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.fill.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.filter","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.filter', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      filter\n    } = TypedArray.prototype;\n    assert.isFunction(filter, `${name}::filter is function`);\n    assert.arity(filter, 1, `${name}::filter arity is 1`);\n    assert.name(filter, 'filter', `${name}::filter name is 'filter'`);\n    assert.looksNative(filter, `${name}::filter looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.filter(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    const instance = new TypedArray([1, 2, 3, 4, 5, 6, 7, 8, 9]).filter(it => it % 2);\n    assert.true(instance instanceof TypedArray, 'correct instance');\n    assert.arrayEqual(instance, [1, 3, 5, 7, 9], 'works');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).filter((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => filter.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.filter.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.findIndex","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.findIndex', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      findIndex\n    } = TypedArray.prototype;\n    assert.isFunction(findIndex, `${name}::findIndex is function`);\n    assert.arity(findIndex, 1, `${name}::findIndex arity is 1`);\n    assert.name(findIndex, 'findIndex', `${name}::findIndex name is 'findIndex'`);\n    assert.looksNative(findIndex, `${name}::findIndex looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.findIndex(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(new TypedArray([1, 2, 3]).findIndex(it => !(it % 2)), 1); // eslint-disable-next-line unicorn/prefer-array-index-of -- ignore\n\n    assert.same(new TypedArray([1, 2, 3]).findIndex(it => it === 4), -1);\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).findIndex((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => findIndex.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.find-index.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.find","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.find', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      find\n    } = TypedArray.prototype;\n    assert.isFunction(find, `${name}::find is function`);\n    assert.arity(find, 1, `${name}::find arity is 1`);\n    assert.name(find, 'find', `${name}::find name is 'find'`);\n    assert.looksNative(find, `${name}::find looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.find(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(new TypedArray([1, 2, 3]).find(it => !(it % 2)), 2);\n    assert.same(new TypedArray([1, 2, 3]).find(it => it === 4), undefined);\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).find((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => find.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.find.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.forEach","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.forEach', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      forEach\n    } = TypedArray.prototype;\n    assert.isFunction(forEach, `${name}::forEach is function`);\n    assert.arity(forEach, 1, `${name}::forEach arity is 1`);\n    assert.name(forEach, 'forEach', `${name}::forEach name is 'forEach'`);\n    assert.looksNative(forEach, `${name}::forEach looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.forEach(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(new TypedArray([1, 2, 3]).forEach(it => it % 2), undefined);\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).forEach((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => forEach.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.for-each.js","skipped":false,"dir":"tests"},{"name":"%TypedArray%.from","suites":[],"line":3,"code":"if (DESCRIPTORS) QUnit.test('%TypedArray%.from', assert => {\n  // we can't implement %TypedArray% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    assert.isFunction(TypedArray.from, `${name}.from is function`);\n    assert.arity(TypedArray.from, 1, `${name}.from arity is 1`);\n    assert.name(TypedArray.from, 'from', `${name}.from name is 'from'`);\n    assert.looksNative(TypedArray.from, `${name}.from looks native`);\n    let instance = TypedArray.from([1, 2, 3]);\n    assert.true(instance instanceof TypedArray, 'correct instance with array');\n    assert.arrayEqual(instance, [1, 2, 3], 'correct elements with array');\n    instance = TypedArray.from({\n      0: 1,\n      1: 2,\n      2: 3,\n      length: 3\n    });\n    assert.true(instance instanceof TypedArray, 'correct instance with array-like');\n    assert.arrayEqual(instance, [1, 2, 3], 'correct elements with array-like');\n    instance = TypedArray.from(createIterable([1, 2, 3]));\n    assert.true(instance instanceof TypedArray, 'correct instance with iterable');\n    assert.arrayEqual(instance, [1, 2, 3], 'correct elements with iterable');\n    assert.arrayEqual(TypedArray.from([1, 2, 3], it => it * it), [1, 4, 9], 'accept callback');\n    const context = {};\n    TypedArray.from([1], function (value, key) {\n      assert.same(arguments.length, 2, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.throws(() => TypedArray.from.call(undefined, []), \"isn't generic #1\");\n\n    if (NATIVE) {\n      assert.throws(() => TypedArray.from.call(Array, []), \"isn't generic #2\");\n      assert.notThrows(() => TypedArray.from({\n        length: -1,\n        0: 1\n      }, () => {\n        throw new Error();\n      }), 'uses ToLength');\n    }\n  }\n});","file":"tests/es.typed-array.from.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.includes","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.includes', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      includes\n    } = TypedArray.prototype;\n    assert.isFunction(includes, `${name}::includes is function`);\n    assert.arity(includes, 1, `${name}::includes arity is 1`);\n    assert.name(includes, 'includes', `${name}::includes name is 'includes'`);\n    assert.looksNative(includes, `${name}::includes looks native`);\n    assert.true(new TypedArray([1, 1, 1]).includes(1));\n    assert.false(new TypedArray([1, 2, 3]).includes(1, 1));\n    assert.true(new TypedArray([1, 2, 3]).includes(2, 1));\n    assert.false(new TypedArray([1, 2, 3]).includes(2, -1));\n    assert.true(new TypedArray([1, 2, 3]).includes(2, -2));\n    assert.throws(() => includes.call([1], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.includes.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.indexOf","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.indexOf', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      indexOf\n    } = TypedArray.prototype;\n    assert.isFunction(indexOf, `${name}::indexOf is function`);\n    assert.arity(indexOf, 1, `${name}::indexOf arity is 1`);\n    assert.name(indexOf, 'indexOf', `${name}::indexOf name is 'indexOf'`);\n    assert.looksNative(indexOf, `${name}::indexOf looks native`);\n    assert.same(new TypedArray([1, 1, 1]).indexOf(1), 0);\n    assert.same(new TypedArray([1, 2, 3]).indexOf(1, 1), -1);\n    assert.same(new TypedArray([1, 2, 3]).indexOf(2, 1), 1);\n    assert.same(new TypedArray([1, 2, 3]).indexOf(2, -1), -1);\n    assert.same(new TypedArray([1, 2, 3]).indexOf(2, -2), 1);\n    assert.throws(() => indexOf.call([1], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.index-of.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.keys","suites":[],"line":3,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.keys', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      keys\n    } = TypedArray.prototype;\n    assert.isFunction(keys, `${name}::keys is function`);\n    assert.arity(keys, 0, `${name}::keys arity is 0`);\n    assert.name(keys, 'keys', `${name}::keys name is 'keys'`);\n    assert.looksNative(keys, `${name}::keys looks native`);\n    const iterator = new TypedArray([1, 2, 3]).keys();\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n    assert.deepEqual(iterator.next(), {\n      value: 0,\n      done: false\n    }, 'step 1');\n    assert.deepEqual(iterator.next(), {\n      value: 1,\n      done: false\n    }, 'step 2');\n    assert.deepEqual(iterator.next(), {\n      value: 2,\n      done: false\n    }, 'step 3');\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    }, 'done');\n    if (NATIVE) assert.throws(() => keys.call([1, 2]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.iterator.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.values","suites":[],"line":37,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.values', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      values\n    } = TypedArray.prototype;\n    assert.isFunction(values, `${name}::values is function`);\n    assert.arity(values, 0, `${name}::values arity is 0`);\n    assert.name(values, 'values', `${name}::values name is 'values'`);\n    assert.looksNative(values, `${name}::values looks native`);\n    const iterator = new TypedArray([1, 2, 3]).values();\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n    assert.deepEqual(iterator.next(), {\n      value: 1,\n      done: false\n    }, 'step 1');\n    assert.deepEqual(iterator.next(), {\n      value: 2,\n      done: false\n    }, 'step 2');\n    assert.deepEqual(iterator.next(), {\n      value: 3,\n      done: false\n    }, 'step 3');\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    }, 'done');\n    if (NATIVE) assert.throws(() => values.call([1, 2]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.iterator.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.entries","suites":[],"line":71,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.entries', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      entries\n    } = TypedArray.prototype;\n    assert.isFunction(entries, `${name}::entries is function`);\n    assert.arity(entries, 0, `${name}::entries arity is 0`);\n    assert.name(entries, 'entries', `${name}::entries name is 'entries'`);\n    assert.looksNative(entries, `${name}::entries looks native`);\n    const iterator = new TypedArray([1, 2, 3]).entries();\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n    assert.deepEqual(iterator.next(), {\n      value: [0, 1],\n      done: false\n    }, 'step 1');\n    assert.deepEqual(iterator.next(), {\n      value: [1, 2],\n      done: false\n    }, 'step 2');\n    assert.deepEqual(iterator.next(), {\n      value: [2, 3],\n      done: false\n    }, 'step 3');\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    }, 'done');\n    if (NATIVE) assert.throws(() => entries.call([1, 2]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.iterator.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.@@iterator","suites":[],"line":105,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.@@iterator', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    assert.isIterable(TypedArray.prototype, `${name} is itrable`);\n    assert.arity(TypedArray.prototype[Symbol.iterator], 0, `${name}::@@iterator arity is 0`);\n    assert.name(TypedArray.prototype[Symbol.iterator], 'values', `${name}::@@iterator name is 'values'`);\n    assert.looksNative(TypedArray.prototype[Symbol.iterator], `${name}::@@iterator looks native`);\n    assert.same(TypedArray.prototype[Symbol.iterator], TypedArray.prototype.values);\n    const iterator = new TypedArray([1, 2, 3])[Symbol.iterator]();\n    assert.isIterator(iterator);\n    assert.isIterable(iterator);\n    assert.same(iterator[Symbol.toStringTag], 'Array Iterator');\n    assert.deepEqual(iterator.next(), {\n      value: 1,\n      done: false\n    }, 'step 1');\n    assert.deepEqual(iterator.next(), {\n      value: 2,\n      done: false\n    }, 'step 2');\n    assert.deepEqual(iterator.next(), {\n      value: 3,\n      done: false\n    }, 'step 3');\n    assert.deepEqual(iterator.next(), {\n      value: undefined,\n      done: true\n    }, 'done');\n    if (NATIVE) assert.throws(() => TypedArray.prototype[Symbol.iterator].call([1, 2]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.iterator.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.join","suites":[],"line":3,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.join', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      join\n    } = TypedArray.prototype;\n    assert.isFunction(join, `${name}::join is function`);\n    assert.arity(join, 1, `${name}::join arity is 1`);\n    assert.name(join, 'join', `${name}::join name is 'join'`);\n    assert.looksNative(join, `${name}::join looks native`);\n    assert.same(new TypedArray([1, 2, 3]).join('|'), '1|2|3', 'works #1');\n    assert.same(new TypedArray([1, 2, 3]).join(), '1,2,3', 'works #2');\n    assert.throws(() => join.call([1, 2, 3]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.join.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.lastIndexOf","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.lastIndexOf', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      lastIndexOf\n    } = TypedArray.prototype;\n    assert.isFunction(lastIndexOf, `${name}::lastIndexOf is function`);\n    assert.arity(lastIndexOf, 1, `${name}::lastIndexOf arity is 1`);\n    assert.name(lastIndexOf, 'lastIndexOf', `${name}::lastIndexOf name is 'lastIndexOf'`);\n    assert.looksNative(lastIndexOf, `${name}::lastIndexOf looks native`);\n    assert.same(new TypedArray([1, 1, 1]).lastIndexOf(1), 2);\n    assert.same(new TypedArray([1, 2, 3]).lastIndexOf(3, 1), -1);\n    assert.same(new TypedArray([1, 2, 3]).lastIndexOf(2, 1), 1);\n    assert.same(new TypedArray([1, 2, 3]).lastIndexOf(2, -3), -1);\n    assert.same(new TypedArray([1, 2, 3]).lastIndexOf(2, -2), 1);\n    assert.throws(() => lastIndexOf.call([1], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.last-index-of.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.map","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.map', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      map\n    } = TypedArray.prototype;\n    assert.isFunction(map, `${name}::map is function`);\n    assert.arity(map, 1, `${name}::map arity is 1`);\n    assert.name(map, 'map', `${name}::map name is 'map'`);\n    assert.looksNative(map, `${name}::map looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.map(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    const instance = new TypedArray([1, 2, 3, 4, 5]).map(it => it * 2);\n    assert.true(instance instanceof TypedArray, 'correct instance');\n    assert.arrayEqual(instance, [2, 4, 6, 8, 10], 'works');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).map((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => map.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.map.js","skipped":false,"dir":"tests"},{"name":"%TypedArray%.of","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArray%.of', assert => {\n  // we can't implement %TypedArray% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    assert.isFunction(TypedArray.of, `${name}.of is function`);\n    assert.arity(TypedArray.of, 0, `${name}.of arity is 0`);\n    assert.name(TypedArray.of, 'of', `${name}.of name is 'of'`);\n    assert.looksNative(TypedArray.of, `${name}.of looks native`);\n    let instance = TypedArray.of();\n    assert.true(instance instanceof TypedArray, 'correct instance with 0 arguments');\n    assert.arrayEqual(instance, [], 'correct elements with 0 arguments');\n    instance = TypedArray.of(1);\n    assert.true(instance instanceof TypedArray, 'correct instance with 1 argument');\n    assert.arrayEqual(instance, [1], 'correct elements with 1 argument');\n    instance = TypedArray.of(1, 2, 3);\n    assert.true(instance instanceof TypedArray, 'correct instance with several arguments');\n    assert.arrayEqual(instance, [1, 2, 3], 'correct elements with several arguments');\n    assert.throws(() => TypedArray.of.call(undefined, 1), \"isn't generic #1\");\n    if (NATIVE) assert.throws(() => TypedArray.of.call(Array, 1), \"isn't generic #2\");\n  }\n});","file":"tests/es.typed-array.of.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.reduceRight","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.reduceRight', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      reduceRight\n    } = TypedArray.prototype;\n    assert.isFunction(reduceRight, `${name}::reduceRight is function`);\n    assert.arity(reduceRight, 1, `${name}::reduceRight arity is 1`);\n    assert.name(reduceRight, 'reduceRight', `${name}::reduceRight name is 'reduceRight'`);\n    assert.looksNative(reduceRight, `${name}::reduceRight looks native`);\n    const array = new TypedArray([1]);\n    const accumulator = {};\n    array.reduceRight(function (memo, value, key, that) {\n      assert.same(arguments.length, 4, 'correct number of callback arguments');\n      assert.same(memo, accumulator, 'correct callback accumulator');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n    }, accumulator);\n    assert.same(new TypedArray([1, 2, 3]).reduceRight((a, b) => a + b, 1), 7, 'works with initial accumulator');\n    new TypedArray([1, 2]).reduceRight((memo, value, key) => {\n      assert.same(memo, 2, 'correct default accumulator');\n      assert.same(value, 1, 'correct start value without initial accumulator');\n      assert.same(key, 0, 'correct start index without initial accumulator');\n    });\n    assert.same(new TypedArray([1, 2, 3]).reduceRight((a, b) => a + b), 6, 'works without initial accumulator');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).reduceRight((memo, value, key) => {\n      values += value;\n      keys += key;\n    }, 0);\n    assert.same(values, '321', 'correct order #1');\n    assert.same(keys, '210', 'correct order #2');\n    assert.throws(() => reduceRight.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.reduce-right.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.reduce","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.reduce', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      reduce\n    } = TypedArray.prototype;\n    assert.isFunction(reduce, `${name}::reduce is function`);\n    assert.arity(reduce, 1, `${name}::reduce arity is 1`);\n    assert.name(reduce, 'reduce', `${name}::reduce name is 'reduce'`);\n    assert.looksNative(reduce, `${name}::reduce looks native`);\n    const array = new TypedArray([1]);\n    const accumulator = {};\n    array.reduce(function (memo, value, key, that) {\n      assert.same(arguments.length, 4, 'correct number of callback arguments');\n      assert.same(memo, accumulator, 'correct callback accumulator');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n    }, accumulator);\n    assert.same(new TypedArray([1, 2, 3]).reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n    new TypedArray([1, 2]).reduce((memo, value, key) => {\n      assert.same(memo, 1, 'correct default accumulator');\n      assert.same(value, 2, 'correct start value without initial accumulator');\n      assert.same(key, 1, 'correct start index without initial accumulator');\n    });\n    assert.same(new TypedArray([1, 2, 3]).reduce((a, b) => a + b), 6, 'works without initial accumulator');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).reduce((memo, value, key) => {\n      values += value;\n      keys += key;\n    }, 0);\n    assert.same(values, '123', 'correct order #1');\n    assert.same(keys, '012', 'correct order #2');\n    assert.throws(() => reduce.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.reduce.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.reverse","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.reverse', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      reverse\n    } = TypedArray.prototype;\n    assert.isFunction(reverse, `${name}::reverse is function`);\n    assert.arity(reverse, 0, `${name}::reverse arity is 0`);\n    assert.name(reverse, 'reverse', `${name}::reverse name is 'reverse'`);\n    assert.looksNative(reverse, `${name}::reverse looks native`);\n    const array = new TypedArray([1, 2]);\n    assert.same(array.reverse(), array, 'return this');\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4]).reverse(), [4, 3, 2, 1], 'works #1');\n    assert.arrayEqual(new TypedArray([1, 2, 3]).reverse(), [3, 2, 1], 'works #2');\n    assert.throws(() => reverse.call([1, 2]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.reverse.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.set","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.set', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      set\n    } = TypedArray.prototype;\n    assert.isFunction(set, `${name}::set is function`);\n    if (NATIVE) assert.arity(set, 1, `${name}::set arity is 1`);\n    assert.name(set, 'set', `${name}::set name is 'set'`);\n    assert.looksNative(set, `${name}::set looks native`);\n    assert.same(new TypedArray(1).set([1]), undefined, 'void');\n    const array1 = new TypedArray([1, 2, 3, 4, 5]);\n    const array2 = new TypedArray(5);\n    array2.set(array1);\n    assert.arrayEqual(array2, [1, 2, 3, 4, 5]);\n    assert.throws(() => array2.set(array1, 1));\n    assert.throws(() => array2.set(array1, -1));\n    array2.set(new TypedArray([99, 98]), 2);\n    assert.arrayEqual(array2, [1, 2, 99, 98, 5]);\n    array2.set(new TypedArray([99, 98, 97]), 2);\n    assert.arrayEqual(array2, [1, 2, 99, 98, 97]);\n    assert.throws(() => array2.set(new TypedArray([99, 98, 97, 96]), 2));\n    assert.throws(() => array2.set([101, 102, 103, 104], 4));\n    const array3 = new TypedArray(2);\n    assert.notThrows(() => array3.set({\n      length: 2,\n      0: 1,\n      1: 2\n    }), 'set array-like #1');\n    assert.arrayEqual(array3, [1, 2], 'set array-like #2');\n    assert.notThrows(() => array3.set('34'), 'set string #1');\n    assert.arrayEqual(array3, [3, 4], 'set string #2');\n    assert.notThrows(() => array3.set(1), 'set number #1');\n    assert.arrayEqual(array3, [3, 4], 'set number #2');\n    assert.throws(() => set.call([1, 2, 3], [1]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.set.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.slice","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.slice', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      slice\n    } = TypedArray.prototype;\n    assert.isFunction(slice, `${name}::slice is function`);\n    assert.arity(slice, 2, `${name}::slice arity is 0`);\n    assert.name(slice, 'slice', `${name}::slice name is 'slice'`);\n    assert.looksNative(slice, `${name}::slice looks native`);\n    const array = new TypedArray([1, 2, 3, 4, 5]);\n    assert.notSame(array.slice(), array, 'returns new array');\n    assert.true(array.slice() instanceof TypedArray, 'correct instance');\n    assert.notSame(array.slice().buffer, array.buffer, 'with new buffer');\n    assert.arrayEqual(array.slice(), array);\n    assert.arrayEqual(array.slice(1, 3), [2, 3]);\n    assert.arrayEqual(array.slice(1, undefined), [2, 3, 4, 5]);\n    assert.arrayEqual(array.slice(1, -1), [2, 3, 4]);\n    assert.arrayEqual(array.slice(-2, -1), [4]);\n    assert.arrayEqual(array.slice(-2, -3), []);\n    assert.throws(() => slice.call([1, 2], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.slice.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.some","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.some', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      some\n    } = TypedArray.prototype;\n    assert.isFunction(some, `${name}::some is function`);\n    assert.arity(some, 1, `${name}::some arity is 1`);\n    assert.name(some, 'some', `${name}::some name is 'some'`);\n    assert.looksNative(some, `${name}::some looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.some(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.true(new TypedArray([1, 2, 3]).some(it => typeof it == 'number'));\n    assert.true(new TypedArray([1, 2, 3]).some(it => it < 3));\n    assert.false(new TypedArray([1, 2, 3]).some(it => it < 0));\n    assert.false(new TypedArray([1, 2, 3]).some(it => typeof it == 'string'));\n    assert.true(new TypedArray([1, 2, 3]).some(function () {\n      return +this === 1;\n    }, 1));\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).some((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => some.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.some.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.sort","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.sort', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      sort\n    } = TypedArray.prototype;\n    assert.isFunction(sort, `${name}::sort is function`);\n    assert.arity(sort, 1, `${name}::sort arity is 1`);\n    assert.name(sort, 'sort', `${name}::sort name is 'sort'`);\n    assert.looksNative(sort, `${name}::sort looks native`);\n\n    if (name.indexOf('Float') === 0) {\n      assert.deepEqual(new TypedArray([1, -1, 3, NaN, 2, 0, 11, -0]).sort(), new TypedArray([-1, -0, 0, 1, 2, 3, 11, NaN]), '#1');\n      assert.true(1 / new TypedArray([0, -0]).sort()[0] < 0, '-0');\n      assert.deepEqual(new TypedArray([NaN, 1, NaN]).sort(), new TypedArray([1, NaN, NaN]), 'NaN');\n    }\n\n    if (name.indexOf('8') === -1) {\n      const expected = Array(516);\n      let array = new TypedArray(516);\n      let index, mod, j, k, postfix;\n\n      for (index = 0; index < 516; index++) {\n        mod = index % 4;\n        array[index] = 515 - index;\n        expected[index] = index - 2 * mod + 3;\n      }\n\n      array.sort((a, b) => (a / 4 | 0) - (b / 4 | 0));\n      assert.same(String(array), String(expected), 'stable #1');\n      let result = '';\n      array = new TypedArray(520);\n      index = 0;\n\n      for (j = 0; j < 10; j++) {\n        switch (j) {\n          case 1:\n          case 4:\n          case 5:\n          case 7:\n            postfix = 3;\n            break;\n\n          case 3:\n          case 6:\n            postfix = 4;\n            break;\n\n          default:\n            postfix = 2;\n        }\n\n        for (k = 0; k < 52; k++) {\n          array[index] = 10 * index++ + postfix;\n        }\n      }\n\n      array.sort((a, b) => b % 10 - a % 10);\n\n      for (index = 0; index < array.length; index++) {\n        j = String(array[index] / 520 | 0);\n        if (result.charAt(result.length - 1) !== j) result += j;\n      }\n\n      assert.same(result, '3614570289', 'stable #2');\n    }\n\n    assert.throws(() => sort.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n    assert.notThrows(() => new TypedArray([1, 2, 3]).sort(undefined).length === 3, 'works with undefined');\n    assert.throws(() => new TypedArray([1, 2, 3]).sort(null), 'throws on null');\n    assert.throws(() => new TypedArray([1, 2, 3]).sort({}), 'throws on {}');\n\n    if (STRICT) {\n      assert.throws(() => sort.call(null), TypeError, 'ToObject(this)');\n      assert.throws(() => sort.call(undefined), TypeError, 'ToObject(this)');\n    }\n  }\n});","file":"tests/es.typed-array.sort.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.subarray","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.subarray', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      subarray\n    } = TypedArray.prototype;\n    assert.isFunction(subarray, `${name}::subarray is function`);\n    if (NATIVE) assert.arity(subarray, 2, `${name}::subarray arity is 2`);\n    assert.name(subarray, 'subarray', `${name}::subarray name is 'subarray'`);\n    assert.looksNative(subarray, `${name}::subarray looks native`);\n    const array1 = new TypedArray([1, 2, 3, 4, 5]);\n    const array2 = array1.subarray(3);\n    assert.notSame(array1, array2, 'creates new array');\n    assert.true(array2 instanceof TypedArray, `instance ${name}`);\n    assert.same(array1.buffer, array2.buffer, 'with the same buffer');\n    assert.arrayEqual(array2, [4, 5]);\n    assert.arrayEqual(array1.subarray(1, 3), [2, 3]);\n    assert.arrayEqual(array1.subarray(-3), [3, 4, 5]);\n    assert.arrayEqual(array1.subarray(-3, -1), [3, 4]);\n    assert.arrayEqual(array1.subarray(3, 2), []);\n    assert.arrayEqual(array1.subarray(-2, -3), []);\n    assert.arrayEqual(array1.subarray(4, 1), []);\n    assert.arrayEqual(array1.subarray(-1, -4), []);\n    assert.arrayEqual(array1.subarray(1).subarray(1), [3, 4, 5]);\n    assert.arrayEqual(array1.subarray(1, 4).subarray(1, 2), [3]);\n    assert.throws(() => subarray.call([1, 2, 3], 1), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.subarray.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.toLocaleString","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.toLocaleString', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      toLocaleString\n    } = TypedArray.prototype;\n    assert.isFunction(toLocaleString, `${name}::toLocaleString is function`);\n    assert.arity(toLocaleString, 0, `${name}::toLocaleString arity is 0`);\n    assert.name(toLocaleString, 'toLocaleString', `${name}::toLocaleString name is 'toLocaleString'`);\n    assert.looksNative(toLocaleString, `${name}::toLocaleString looks native`);\n    assert.same(new TypedArray([1, 2, 3]).toLocaleString(), [1, 2, 3].toLocaleString(), 'works');\n    assert.throws(() => toLocaleString.call([1, 2, 3]), \"isn't generic\");\n  }\n});","file":"tests/es.typed-array.to-locale-string.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.toString","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.toString', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      toString\n    } = TypedArray.prototype;\n    assert.isFunction(toString, `${name}::toString is function`);\n    assert.arity(toString, 0, `${name}::toString arity is 0`);\n    assert.name(toString, 'toString', `${name}::toString name is 'toString'`);\n    assert.looksNative(toString, `${name}::toString looks native`);\n    assert.same(new TypedArray([1, 2, 3]).toString(), '1,2,3', 'works');\n    assert.same(toString.call([1, 2, 3]), '1,2,3', 'generic');\n  }\n});","file":"tests/es.typed-array.to-string.js","skipped":false,"dir":"tests"},{"name":"Float32 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Float32 conversions', assert => {\n  const float32array = new Float32Array(1);\n  const uint8array = new Uint8Array(float32array.buffer);\n  const dataview = new DataView(float32array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  const data = [[0, 0, [0, 0, 0, 0]], [-0, -0, [0, 0, 0, 128]], [1, 1, [0, 0, 128, 63]], [-1, -1, [0, 0, 128, 191]], [1.1, 1.100000023841858, [205, 204, 140, 63]], [-1.1, -1.100000023841858, [205, 204, 140, 191]], [1.9, 1.899999976158142, [51, 51, 243, 63]], [-1.9, -1.899999976158142, [51, 51, 243, 191]], [127, 127, [0, 0, 254, 66]], [-127, -127, [0, 0, 254, 194]], [128, 128, [0, 0, 0, 67]], [-128, -128, [0, 0, 0, 195]], [255, 255, [0, 0, 127, 67]], [-255, -255, [0, 0, 127, 195]], [255.1, 255.10000610351562, [154, 25, 127, 67]], [255.9, 255.89999389648438, [102, 230, 127, 67]], [256, 256, [0, 0, 128, 67]], [32767, 32767, [0, 254, 255, 70]], [-32767, -32767, [0, 254, 255, 198]], [32768, 32768, [0, 0, 0, 71]], [-32768, -32768, [0, 0, 0, 199]], [65535, 65535, [0, 255, 127, 71]], [65536, 65536, [0, 0, 128, 71]], [65537, 65537, [128, 0, 128, 71]], [65536.54321, 65536.546875, [70, 0, 128, 71]], [-65536.54321, -65536.546875, [70, 0, 128, 199]], [2147483647, 2147483648, [0, 0, 0, 79]], [-2147483647, -2147483648, [0, 0, 0, 207]], [2147483648, 2147483648, [0, 0, 0, 79]], [-2147483648, -2147483648, [0, 0, 0, 207]], [2147483649, 2147483648, [0, 0, 0, 79]], [-2147483649, -2147483648, [0, 0, 0, 207]], [4294967295, 4294967296, [0, 0, 128, 79]], [4294967296, 4294967296, [0, 0, 128, 79]], [4294967297, 4294967296, [0, 0, 128, 79]], [9007199254740991, 9007199254740992, [0, 0, 0, 90]], [-9007199254740991, -9007199254740992, [0, 0, 0, 218]], [9007199254740992, 9007199254740992, [0, 0, 0, 90]], [-9007199254740992, -9007199254740992, [0, 0, 0, 218]], [9007199254740994, 9007199254740992, [0, 0, 0, 90]], [-9007199254740994, -9007199254740992, [0, 0, 0, 218]], [Infinity, Infinity, [0, 0, 128, 127]], [-Infinity, -Infinity, [0, 0, 128, 255]], [1.7976931348623157e+308, Infinity, [0, 0, 128, 127]], [-1.7976931348623157e+308, -Infinity, [0, 0, 128, 255]], [5e-324, 0, [0, 0, 0, 0]], [-5e-324, -0, [0, 0, 0, 128]]];\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    float32array[0] = value;\n    assert.same(float32array[0], conversion, `Float32Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Float32Array ${toString(value)} -> [${representation}]`);\n    dataview.setFloat32(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setFloat32(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getFloat32(0), conversion, `dataview{${big}}.getFloat32(0) -> ${toString(conversion)}`);\n    dataview.setFloat32(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setFloat32(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getFloat32(0, false), conversion, `dataview{${big}}.getFloat32(0, false) -> ${toString(conversion)}`);\n    dataview.setFloat32(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setFloat32(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getFloat32(0, true), conversion, `dataview{${little}}.getFloat32(0, true) -> ${toString(conversion)}`);\n  }\n\n  float32array[0] = NaN;\n  assert.same(float32array[0], NaN, 'NaN -> NaN');\n});","file":"tests/es.typed.conversions.float32.js","skipped":false,"dir":"tests"},{"name":"Float64 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Float64 conversions', assert => {\n  const float64array = new Float64Array(1);\n  const uint8array = new Uint8Array(float64array.buffer);\n  const dataview = new DataView(float64array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  const data = [[0, 0, [0, 0, 0, 0, 0, 0, 0, 0]], [-0, -0, [0, 0, 0, 0, 0, 0, 0, 128]], [1, 1, [0, 0, 0, 0, 0, 0, 240, 63]], [-1, -1, [0, 0, 0, 0, 0, 0, 240, 191]], [1.1, 1.1, [154, 153, 153, 153, 153, 153, 241, 63]], [-1.1, -1.1, [154, 153, 153, 153, 153, 153, 241, 191]], [1.9, 1.9, [102, 102, 102, 102, 102, 102, 254, 63]], [-1.9, -1.9, [102, 102, 102, 102, 102, 102, 254, 191]], [127, 127, [0, 0, 0, 0, 0, 192, 95, 64]], [-127, -127, [0, 0, 0, 0, 0, 192, 95, 192]], [128, 128, [0, 0, 0, 0, 0, 0, 96, 64]], [-128, -128, [0, 0, 0, 0, 0, 0, 96, 192]], [255, 255, [0, 0, 0, 0, 0, 224, 111, 64]], [-255, -255, [0, 0, 0, 0, 0, 224, 111, 192]], [255.1, 255.1, [51, 51, 51, 51, 51, 227, 111, 64]], [255.9, 255.9, [205, 204, 204, 204, 204, 252, 111, 64]], [256, 256, [0, 0, 0, 0, 0, 0, 112, 64]], [32767, 32767, [0, 0, 0, 0, 192, 255, 223, 64]], [-32767, -32767, [0, 0, 0, 0, 192, 255, 223, 192]], [32768, 32768, [0, 0, 0, 0, 0, 0, 224, 64]], [-32768, -32768, [0, 0, 0, 0, 0, 0, 224, 192]], [65535, 65535, [0, 0, 0, 0, 224, 255, 239, 64]], [65536, 65536, [0, 0, 0, 0, 0, 0, 240, 64]], [65537, 65537, [0, 0, 0, 0, 16, 0, 240, 64]], [65536.54321, 65536.54321, [14, 248, 252, 176, 8, 0, 240, 64]], [-65536.54321, -65536.54321, [14, 248, 252, 176, 8, 0, 240, 192]], [2147483647, 2147483647, [0, 0, 192, 255, 255, 255, 223, 65]], [-2147483647, -2147483647, [0, 0, 192, 255, 255, 255, 223, 193]], [2147483648, 2147483648, [0, 0, 0, 0, 0, 0, 224, 65]], [-2147483648, -2147483648, [0, 0, 0, 0, 0, 0, 224, 193]], [2147483649, 2147483649, [0, 0, 32, 0, 0, 0, 224, 65]], [-2147483649, -2147483649, [0, 0, 32, 0, 0, 0, 224, 193]], [4294967295, 4294967295, [0, 0, 224, 255, 255, 255, 239, 65]], [4294967296, 4294967296, [0, 0, 0, 0, 0, 0, 240, 65]], [4294967297, 4294967297, [0, 0, 16, 0, 0, 0, 240, 65]], [9007199254740991, 9007199254740991, [255, 255, 255, 255, 255, 255, 63, 67]], [-9007199254740991, -9007199254740991, [255, 255, 255, 255, 255, 255, 63, 195]], [9007199254740992, 9007199254740992, [0, 0, 0, 0, 0, 0, 64, 67]], [-9007199254740992, -9007199254740992, [0, 0, 0, 0, 0, 0, 64, 195]], [9007199254740994, 9007199254740994, [1, 0, 0, 0, 0, 0, 64, 67]], [-9007199254740994, -9007199254740994, [1, 0, 0, 0, 0, 0, 64, 195]], [Infinity, Infinity, [0, 0, 0, 0, 0, 0, 240, 127]], [-Infinity, -Infinity, [0, 0, 0, 0, 0, 0, 240, 255]], [-1.7976931348623157e+308, -1.7976931348623157e+308, [255, 255, 255, 255, 255, 255, 239, 255]], [1.7976931348623157e+308, 1.7976931348623157e+308, [255, 255, 255, 255, 255, 255, 239, 127]], [5e-324, 5e-324, [1, 0, 0, 0, 0, 0, 0, 0]], [-5e-324, -5e-324, [1, 0, 0, 0, 0, 0, 0, 128]]];\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    float64array[0] = value;\n    assert.same(float64array[0], conversion, `Float64Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Float64Array ${toString(value)} -> [${representation}]`);\n    dataview.setFloat64(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setFloat64(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getFloat64(0), conversion, `dataview{${big}}.getFloat64(0) -> ${toString(conversion)}`);\n    dataview.setFloat64(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setFloat64(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getFloat64(0, false), conversion, `dataview{${big}}.getFloat64(0, false) -> ${toString(conversion)}`);\n    dataview.setFloat64(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setFloat64(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getFloat64(0, true), conversion, `dataview{${little}}.getFloat64(0, true) -> ${toString(conversion)}`);\n  }\n\n  float64array[0] = NaN;\n  assert.same(float64array[0], NaN, 'NaN -> NaN');\n});","file":"tests/es.typed.conversions.float64.js","skipped":false,"dir":"tests"},{"name":"Int16 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Int16 conversions', assert => {\n  const int16array = new Int16Array(1);\n  const uint8array = new Uint8Array(int16array.buffer);\n  const dataview = new DataView(int16array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  let data = [[0, 0, [0, 0]], [-0, 0, [0, 0]], [1, 1, [1, 0]], [-1, -1, [255, 255]], [1.1, 1, [1, 0]], [-1.1, -1, [255, 255]], [1.9, 1, [1, 0]], [-1.9, -1, [255, 255]], [127, 127, [127, 0]], [-127, -127, [129, 255]], [128, 128, [128, 0]], [-128, -128, [128, 255]], [255, 255, [255, 0]], [-255, -255, [1, 255]], [255.1, 255, [255, 0]], [255.9, 255, [255, 0]], [256, 256, [0, 1]], [32767, 32767, [255, 127]], [-32767, -32767, [1, 128]], [32768, -32768, [0, 128]], [-32768, -32768, [0, 128]], [65535, -1, [255, 255]], [65536, 0, [0, 0]], [65537, 1, [1, 0]], [65536.54321, 0, [0, 0]], [-65536.54321, 0, [0, 0]], [2147483647, -1, [255, 255]], [-2147483647, 1, [1, 0]], [2147483648, 0, [0, 0]], [-2147483648, 0, [0, 0]], [4294967296, 0, [0, 0]], [9007199254740992, 0, [0, 0]], [-9007199254740992, 0, [0, 0]], [Infinity, 0, [0, 0]], [-Infinity, 0, [0, 0]], [-1.7976931348623157e+308, 0, [0, 0]], [1.7976931348623157e+308, 0, [0, 0]], [5e-324, 0, [0, 0]], [-5e-324, 0, [0, 0]], [NaN, 0, [0, 0]]]; // Android 4.3- bug\n\n  if (NATIVE || !/Android [2-4]/.test(GLOBAL.navigator && navigator.userAgent)) {\n    data = data.concat([[2147483649, 1, [1, 0]], [-2147483649, -1, [255, 255]], [4294967295, -1, [255, 255]], [4294967297, 1, [1, 0]], [9007199254740991, -1, [255, 255]], [-9007199254740991, 1, [1, 0]], [9007199254740994, 2, [2, 0]], [-9007199254740994, -2, [254, 255]]]);\n  }\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    int16array[0] = value;\n    assert.same(int16array[0], conversion, `Int16Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Int16Array ${toString(value)} -> [${representation}]`);\n    dataview.setInt16(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setInt16(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getInt16(0), conversion, `dataview{${big}}.getInt16(0) -> ${toString(conversion)}`);\n    dataview.setInt16(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setInt16(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getInt16(0, false), conversion, `dataview{${big}}.getInt16(0, false) -> ${toString(conversion)}`);\n    dataview.setInt16(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setInt16(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getInt16(0, true), conversion, `dataview{${little}}.getInt16(0, true) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.int16.js","skipped":false,"dir":"tests"},{"name":"Int32 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Int32 conversions', assert => {\n  const int32array = new Int32Array(1);\n  const uint8array = new Uint8Array(int32array.buffer);\n  const dataview = new DataView(int32array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  const data = [[0, 0, [0, 0, 0, 0]], [-0, 0, [0, 0, 0, 0]], [1, 1, [1, 0, 0, 0]], [-1, -1, [255, 255, 255, 255]], [1.1, 1, [1, 0, 0, 0]], [-1.1, -1, [255, 255, 255, 255]], [1.9, 1, [1, 0, 0, 0]], [-1.9, -1, [255, 255, 255, 255]], [127, 127, [127, 0, 0, 0]], [-127, -127, [129, 255, 255, 255]], [128, 128, [128, 0, 0, 0]], [-128, -128, [128, 255, 255, 255]], [255, 255, [255, 0, 0, 0]], [-255, -255, [1, 255, 255, 255]], [255.1, 255, [255, 0, 0, 0]], [255.9, 255, [255, 0, 0, 0]], [256, 256, [0, 1, 0, 0]], [32767, 32767, [255, 127, 0, 0]], [-32767, -32767, [1, 128, 255, 255]], [32768, 32768, [0, 128, 0, 0]], [-32768, -32768, [0, 128, 255, 255]], [65535, 65535, [255, 255, 0, 0]], [65536, 65536, [0, 0, 1, 0]], [65537, 65537, [1, 0, 1, 0]], [65536.54321, 65536, [0, 0, 1, 0]], [-65536.54321, -65536, [0, 0, 255, 255]], [2147483647, 2147483647, [255, 255, 255, 127]], [-2147483647, -2147483647, [1, 0, 0, 128]], [2147483648, -2147483648, [0, 0, 0, 128]], [-2147483648, -2147483648, [0, 0, 0, 128]], [2147483649, -2147483647, [1, 0, 0, 128]], [-2147483649, 2147483647, [255, 255, 255, 127]], [4294967295, -1, [255, 255, 255, 255]], [4294967296, 0, [0, 0, 0, 0]], [4294967297, 1, [1, 0, 0, 0]], [9007199254740991, -1, [255, 255, 255, 255]], [-9007199254740991, 1, [1, 0, 0, 0]], [9007199254740992, 0, [0, 0, 0, 0]], [-9007199254740992, 0, [0, 0, 0, 0]], [9007199254740994, 2, [2, 0, 0, 0]], [-9007199254740994, -2, [254, 255, 255, 255]], [Infinity, 0, [0, 0, 0, 0]], [-Infinity, 0, [0, 0, 0, 0]], [-1.7976931348623157e+308, 0, [0, 0, 0, 0]], [1.7976931348623157e+308, 0, [0, 0, 0, 0]], [5e-324, 0, [0, 0, 0, 0]], [-5e-324, 0, [0, 0, 0, 0]], [NaN, 0, [0, 0, 0, 0]]];\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    int32array[0] = value;\n    assert.same(int32array[0], conversion, `Int32Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Int32Array ${toString(value)} -> [${representation}]`);\n    dataview.setInt32(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setInt32(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getInt32(0), conversion, `dataview{${big}}.getInt32(0) -> ${toString(conversion)}`);\n    dataview.setInt32(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setInt32(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getInt32(0, false), conversion, `dataview{${big}}.getInt32(0, false) -> ${toString(conversion)}`);\n    dataview.setInt32(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setInt32(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getInt32(0, true), conversion, `dataview{${little}}.getInt32(0, true) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.int32.js","skipped":false,"dir":"tests"},{"name":"Int8 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Int8 conversions', assert => {\n  const int8array = new Int8Array(1);\n  const uint8array = new Uint8Array(int8array.buffer);\n  const dataview = new DataView(int8array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  let data = [[0, 0, [0]], [-0, 0, [0]], [1, 1, [1]], [-1, -1, [255]], [1.1, 1, [1]], [-1.1, -1, [255]], [1.9, 1, [1]], [-1.9, -1, [255]], [127, 127, [127]], [-127, -127, [129]], [128, -128, [128]], [-128, -128, [128]], [255, -1, [255]], [-255, 1, [1]], [255.1, -1, [255]], [255.9, -1, [255]], [256, 0, [0]], [32767, -1, [255]], [-32767, 1, [1]], [32768, 0, [0]], [-32768, 0, [0]], [65535, -1, [255]], [65536, 0, [0]], [65537, 1, [1]], [65536.54321, 0, [0]], [-65536.54321, 0, [0]], [2147483647, -1, [255]], [-2147483647, 1, [1]], [2147483648, 0, [0]], [-2147483648, 0, [0]], [4294967296, 0, [0]], [9007199254740992, 0, [0]], [-9007199254740992, 0, [0]], [Infinity, 0, [0]], [-Infinity, 0, [0]], [-1.7976931348623157e+308, 0, [0]], [1.7976931348623157e+308, 0, [0]], [5e-324, 0, [0]], [-5e-324, 0, [0]], [NaN, 0, [0]]]; // Android 4.3- bug\n\n  if (NATIVE || !/Android [2-4]/.test(GLOBAL.navigator && navigator.userAgent)) {\n    data = data.concat([[2147483649, 1, [1]], [-2147483649, -1, [255]], [4294967295, -1, [255]], [4294967297, 1, [1]], [9007199254740991, -1, [255]], [-9007199254740991, 1, [1]], [9007199254740994, 2, [2]], [-9007199254740994, -2, [254]]]);\n  }\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    int8array[0] = value;\n    assert.same(int8array[0], conversion, `Int8Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Int8Array ${toString(value)} -> [${representation}]`);\n    dataview.setInt8(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setInt8(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getInt8(0), conversion, `dataview{${big}}.getInt8(0) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.int8.js","skipped":false,"dir":"tests"},{"name":"Uint16 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Uint16 conversions', assert => {\n  const uint16array = new Uint16Array(1);\n  const uint8array = new Uint8Array(uint16array.buffer);\n  const dataview = new DataView(uint16array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  let data = [[0, 0, [0, 0]], [-0, 0, [0, 0]], [1, 1, [1, 0]], [-1, 65535, [255, 255]], [1.1, 1, [1, 0]], [-1.1, 65535, [255, 255]], [1.9, 1, [1, 0]], [-1.9, 65535, [255, 255]], [127, 127, [127, 0]], [-127, 65409, [129, 255]], [128, 128, [128, 0]], [-128, 65408, [128, 255]], [255, 255, [255, 0]], [-255, 65281, [1, 255]], [255.1, 255, [255, 0]], [255.9, 255, [255, 0]], [256, 256, [0, 1]], [32767, 32767, [255, 127]], [-32767, 32769, [1, 128]], [32768, 32768, [0, 128]], [-32768, 32768, [0, 128]], [65535, 65535, [255, 255]], [65536, 0, [0, 0]], [65537, 1, [1, 0]], [65536.54321, 0, [0, 0]], [-65536.54321, 0, [0, 0]], [2147483647, 65535, [255, 255]], [-2147483647, 1, [1, 0]], [2147483648, 0, [0, 0]], [-2147483648, 0, [0, 0]], [4294967296, 0, [0, 0]], [9007199254740992, 0, [0, 0]], [-9007199254740992, 0, [0, 0]], [Infinity, 0, [0, 0]], [-Infinity, 0, [0, 0]], [-1.7976931348623157e+308, 0, [0, 0]], [1.7976931348623157e+308, 0, [0, 0]], [5e-324, 0, [0, 0]], [-5e-324, 0, [0, 0]], [NaN, 0, [0, 0]]]; // Android 4.3- bug\n\n  if (NATIVE || !/Android [2-4]/.test(GLOBAL.navigator && navigator.userAgent)) {\n    data = data.concat([[2147483649, 1, [1, 0]], [-2147483649, 65535, [255, 255]], [4294967295, 65535, [255, 255]], [4294967297, 1, [1, 0]], [9007199254740991, 65535, [255, 255]], [-9007199254740991, 1, [1, 0]], [9007199254740994, 2, [2, 0]], [-9007199254740994, 65534, [254, 255]]]);\n  }\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    uint16array[0] = value;\n    assert.same(uint16array[0], conversion, `Uint16Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Uint16Array ${toString(value)} -> [${representation}]`);\n    dataview.setUint16(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setUint16(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getUint16(0), conversion, `dataview{${big}}.getUint16(0) -> ${toString(conversion)}`);\n    dataview.setUint16(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setUint16(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getUint16(0, false), conversion, `dataview{${big}}.getUint16(0, false) -> ${toString(conversion)}`);\n    dataview.setUint16(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setUint16(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getUint16(0, true), conversion, `dataview{${little}}.getUint16(0, true) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.uint16.js","skipped":false,"dir":"tests"},{"name":"Uint32 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Uint32 conversions', assert => {\n  const uint32array = new Uint32Array(1);\n  const uint8array = new Uint8Array(uint32array.buffer);\n  const dataview = new DataView(uint32array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  const data = [[0, 0, [0, 0, 0, 0]], [-0, 0, [0, 0, 0, 0]], [1, 1, [1, 0, 0, 0]], [-1, 4294967295, [255, 255, 255, 255]], [1.1, 1, [1, 0, 0, 0]], [-1.1, 4294967295, [255, 255, 255, 255]], [1.9, 1, [1, 0, 0, 0]], [-1.9, 4294967295, [255, 255, 255, 255]], [127, 127, [127, 0, 0, 0]], [-127, 4294967169, [129, 255, 255, 255]], [128, 128, [128, 0, 0, 0]], [-128, 4294967168, [128, 255, 255, 255]], [255, 255, [255, 0, 0, 0]], [-255, 4294967041, [1, 255, 255, 255]], [255.1, 255, [255, 0, 0, 0]], [255.9, 255, [255, 0, 0, 0]], [256, 256, [0, 1, 0, 0]], [32767, 32767, [255, 127, 0, 0]], [-32767, 4294934529, [1, 128, 255, 255]], [32768, 32768, [0, 128, 0, 0]], [-32768, 4294934528, [0, 128, 255, 255]], [65535, 65535, [255, 255, 0, 0]], [65536, 65536, [0, 0, 1, 0]], [65537, 65537, [1, 0, 1, 0]], [65536.54321, 65536, [0, 0, 1, 0]], [-65536.54321, 4294901760, [0, 0, 255, 255]], [2147483647, 2147483647, [255, 255, 255, 127]], [-2147483647, 2147483649, [1, 0, 0, 128]], [2147483648, 2147483648, [0, 0, 0, 128]], [-2147483648, 2147483648, [0, 0, 0, 128]], [2147483649, 2147483649, [1, 0, 0, 128]], [-2147483649, 2147483647, [255, 255, 255, 127]], [4294967295, 4294967295, [255, 255, 255, 255]], [4294967296, 0, [0, 0, 0, 0]], [4294967297, 1, [1, 0, 0, 0]], [9007199254740991, 4294967295, [255, 255, 255, 255]], [-9007199254740991, 1, [1, 0, 0, 0]], [9007199254740992, 0, [0, 0, 0, 0]], [-9007199254740992, 0, [0, 0, 0, 0]], [9007199254740994, 2, [2, 0, 0, 0]], [-9007199254740994, 4294967294, [254, 255, 255, 255]], [Infinity, 0, [0, 0, 0, 0]], [-Infinity, 0, [0, 0, 0, 0]], [-1.7976931348623157e+308, 0, [0, 0, 0, 0]], [1.7976931348623157e+308, 0, [0, 0, 0, 0]], [5e-324, 0, [0, 0, 0, 0]], [-5e-324, 0, [0, 0, 0, 0]], [NaN, 0, [0, 0, 0, 0]]];\n\n  for (const [value, conversion, little] of data) {\n    const big = little.slice().reverse();\n    const representation = LITTLE_ENDIAN ? little : big;\n    uint32array[0] = value;\n    assert.same(uint32array[0], conversion, `Uint32Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, representation, `Uint32Array ${toString(value)} -> [${representation}]`);\n    dataview.setUint32(0, value);\n    assert.arrayEqual(uint8array, big, `dataview.setUint32(0, ${toString(value)}) -> [${big}]`);\n    assert.same(viewFrom(big).getUint32(0), conversion, `dataview{${big}}.getUint32(0) -> ${toString(conversion)}`);\n    dataview.setUint32(0, value, false);\n    assert.arrayEqual(uint8array, big, `dataview.setUint32(0, ${toString(value)}, false) -> [${big}]`);\n    assert.same(viewFrom(big).getUint32(0, false), conversion, `dataview{${big}}.getUint32(0, false) -> ${toString(conversion)}`);\n    dataview.setUint32(0, value, true);\n    assert.arrayEqual(uint8array, little, `dataview.setUint32(0, ${toString(value)}, true) -> [${little}]`);\n    assert.same(viewFrom(little).getUint32(0, true), conversion, `dataview{${little}}.getUint32(0, true) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.uint32.js","skipped":false,"dir":"tests"},{"name":"Uint8Clamped conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Uint8Clamped conversions', assert => {\n  const uint8clamped = new Uint8ClampedArray(1);\n  const uint8array = new Uint8Array(uint8clamped.buffer);\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  const data = [[0, 0, [0]], [-0, 0, [0]], [1, 1, [1]], [-1, 0, [0]], [1.1, 1, [1]], [-1.1, 0, [0]], [1.9, 2, [2]], [-1.9, 0, [0]], [127, 127, [127]], [-127, 0, [0]], [128, 128, [128]], [-128, 0, [0]], [255, 255, [255]], [-255, 0, [0]], [255.1, 255, [255]], [255.9, 255, [255]], [256, 255, [255]], [32767, 255, [255]], [-32767, 0, [0]], [32768, 255, [255]], [-32768, 0, [0]], [65535, 255, [255]], [65536, 255, [255]], [65537, 255, [255]], [65536.54321, 255, [255]], [-65536.54321, 0, [0]], [2147483647, 255, [255]], [-2147483647, 0, [0]], [2147483648, 255, [255]], [-2147483648, 0, [0]], [2147483649, 255, [255]], [-2147483649, 0, [0]], [4294967295, 255, [255]], [4294967296, 255, [255]], [4294967297, 255, [255]], [9007199254740991, 255, [255]], [-9007199254740991, 0, [0]], [9007199254740992, 255, [255]], [-9007199254740992, 0, [0]], [9007199254740994, 255, [255]], [-9007199254740994, 0, [0]], [Infinity, 255, [255]], [-Infinity, 0, [0]], [-1.7976931348623157e+308, 0, [0]], [1.7976931348623157e+308, 255, [255]], [5e-324, 0, [0]], [-5e-324, 0, [0]], [NaN, 0, [0]]];\n\n  for (const [value, conversion, little] of data) {\n    uint8clamped[0] = value;\n    assert.same(uint8clamped[0], conversion, `Uint8ClampedArray ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, little, `Uint8ClampedArray ${toString(value)} -> [${little}]`);\n  }\n});","file":"tests/es.typed.conversions.uint8-clamped.js","skipped":false,"dir":"tests"},{"name":"Uint8 conversions","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Uint8 conversions', assert => {\n  const uint8array = new Uint8Array(1);\n  const dataview = new DataView(uint8array.buffer);\n\n  function viewFrom(it) {\n    return new DataView(new Uint8Array(it).buffer);\n  }\n\n  function toString(it) {\n    return it === 0 && 1 / it === -Infinity ? '-0' : it;\n  }\n\n  let data = [[0, 0, [0]], [-0, 0, [0]], [1, 1, [1]], [-1, 255, [255]], [1.1, 1, [1]], [-1.1, 255, [255]], [1.9, 1, [1]], [-1.9, 255, [255]], [127, 127, [127]], [-127, 129, [129]], [128, 128, [128]], [-128, 128, [128]], [255, 255, [255]], [-255, 1, [1]], [255.1, 255, [255]], [255.9, 255, [255]], [256, 0, [0]], [32767, 255, [255]], [-32767, 1, [1]], [32768, 0, [0]], [-32768, 0, [0]], [65535, 255, [255]], [65536, 0, [0]], [65537, 1, [1]], [65536.54321, 0, [0]], [-65536.54321, 0, [0]], [2147483647, 255, [255]], [-2147483647, 1, [1]], [2147483648, 0, [0]], [-2147483648, 0, [0]], [4294967296, 0, [0]], [9007199254740992, 0, [0]], [-9007199254740992, 0, [0]], [Infinity, 0, [0]], [-Infinity, 0, [0]], [-1.7976931348623157e+308, 0, [0]], [1.7976931348623157e+308, 0, [0]], [5e-324, 0, [0]], [-5e-324, 0, [0]], [NaN, 0, [0]]]; // Android 4.3- bug\n\n  if (NATIVE || !/Android [2-4]/.test(GLOBAL.navigator && navigator.userAgent)) {\n    data = data.concat([[2147483649, 1, [1]], [-2147483649, 255, [255]], [4294967295, 255, [255]], [4294967297, 1, [1]], [9007199254740991, 255, [255]], [-9007199254740991, 1, [1]], [9007199254740994, 2, [2]], [-9007199254740994, 254, [254]]]);\n  }\n\n  for (const [value, conversion, little] of data) {\n    uint8array[0] = value;\n    assert.same(uint8array[0], conversion, `Uint8Array ${toString(value)} -> ${toString(conversion)}`);\n    assert.arrayEqual(uint8array, little, `Uint8Array ${toString(value)} -> [${little}]`);\n    dataview.setUint8(0, value);\n    assert.arrayEqual(uint8array, little, `dataview.setUint8(0, ${toString(value)}) -> [${little}]`);\n    assert.same(viewFrom(little).getUint8(0), conversion, `dataview{${little}}.getUint8(0) -> ${toString(conversion)}`);\n  }\n});","file":"tests/es.typed.conversions.uint8.js","skipped":false,"dir":"tests"},{"name":"unescape","suites":[],"line":1,"code":"QUnit.test('unescape', assert => {\n  assert.isFunction(unescape);\n  assert.name(unescape, 'unescape');\n  assert.arity(unescape, 1);\n  assert.looksNative(unescape);\n  assert.same(unescape('%21q2%u0444'), '!q2ф');\n  assert.same(unescape('%u044q2%21'), '%u044q2!');\n  assert.same(unescape(null), 'null');\n  assert.same(unescape(undefined), 'undefined');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => unescape(Symbol()), 'throws on symbol argument');\n  }\n});","file":"tests/es.unescape.js","skipped":false,"dir":"tests"},{"name":"WeakMap","suites":[],"line":13,"code":"QUnit.test('WeakMap', assert => {\n  assert.isFunction(WeakMap);\n  assert.name(WeakMap, 'WeakMap');\n  assert.arity(WeakMap, 0);\n  assert.looksNative(WeakMap);\n  assert.true('delete' in WeakMap.prototype, 'delete in WeakMap.prototype');\n  assert.true('get' in WeakMap.prototype, 'get in WeakMap.prototype');\n  assert.true('has' in WeakMap.prototype, 'has in WeakMap.prototype');\n  assert.true('set' in WeakMap.prototype, 'set in WeakMap.prototype');\n  assert.true(new WeakMap() instanceof WeakMap, 'new WeakMap instanceof WeakMap');\n  let object = {};\n  assert.same(new WeakMap(createIterable([[object, 42]])).get(object), 42, 'Init from iterable');\n  let weakmap = new WeakMap();\n  const frozen = freeze({});\n  weakmap.set(frozen, 42);\n  assert.same(weakmap.get(frozen), 42, 'Support frozen objects');\n  weakmap = new WeakMap();\n  weakmap.set(frozen, 42);\n  assert.true(weakmap.has(frozen), 'works with frozen objects, #1');\n  assert.same(weakmap.get(frozen), 42, 'works with frozen objects, #2');\n  weakmap.delete(frozen);\n  assert.false(weakmap.has(frozen), 'works with frozen objects, #3');\n  assert.same(weakmap.get(frozen), undefined, 'works with frozen objects, #4');\n  let done = false;\n\n  try {\n    new WeakMap(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  assert.false('clear' in WeakMap.prototype, 'should not contains `.clear` method');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  new WeakMap(array);\n  assert.true(done);\n  object = {};\n  new WeakMap().set(object, 1);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(WeakMap);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof WeakMap, 'correct subclassing with native classes #2');\n    object = {};\n    assert.same(new Subclass().set(object, 2).get(object), 2, 'correct subclassing with native classes #3');\n  }\n\n  const buffer = new ArrayBuffer(8);\n  const map = new WeakMap([[buffer, 8]]);\n  assert.true(map.has(buffer), 'works with ArrayBuffer keys');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#delete","suites":[],"line":90,"code":"QUnit.test('WeakMap#delete', assert => {\n  assert.isFunction(WeakMap.prototype.delete);\n  if (NATIVE) assert.name(WeakMap.prototype.delete, 'delete');\n  if (NATIVE) assert.arity(WeakMap.prototype.delete, 1);\n  assert.looksNative(WeakMap.prototype.delete);\n  assert.nonEnumerable(WeakMap.prototype, 'delete');\n  const a = {};\n  const b = {};\n  const weakmap = new WeakMap();\n  weakmap.set(a, 42);\n  weakmap.set(b, 21);\n  assert.true(weakmap.has(a), 'WeakMap has values before .delete() #1');\n  assert.true(weakmap.has(b), 'WeakMap has values before .delete() #2');\n  weakmap.delete(a);\n  assert.false(weakmap.has(a), 'WeakMap hasn`t value after .delete() #1');\n  assert.true(weakmap.has(b), 'WeakMap hasn`t value after .delete() #2');\n  assert.notThrows(() => !weakmap.delete(1), 'return false on primitive');\n  const object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.true(weakmap.has(object), 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'works with frozen objects #2');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#get","suites":[],"line":114,"code":"QUnit.test('WeakMap#get', assert => {\n  assert.isFunction(WeakMap.prototype.get);\n  assert.name(WeakMap.prototype.get, 'get');\n  if (NATIVE) assert.arity(WeakMap.prototype.get, 1);\n  assert.looksNative(WeakMap.prototype.get);\n  assert.nonEnumerable(WeakMap.prototype, 'get');\n  const weakmap = new WeakMap();\n  assert.same(weakmap.get({}), undefined, 'WeakMap .get() before .set() return undefined');\n  let object = {};\n  weakmap.set(object, 42);\n  assert.same(weakmap.get(object), 42, 'WeakMap .get() return value');\n  weakmap.delete(object);\n  assert.same(weakmap.get(object), undefined, 'WeakMap .get() after .delete() return undefined');\n  assert.notThrows(() => weakmap.get(1) === undefined, 'return undefined on primitive');\n  object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.same(weakmap.get(object), 42, 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.same(weakmap.get(object), undefined, 'works with frozen objects #2');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#has","suites":[],"line":135,"code":"QUnit.test('WeakMap#has', assert => {\n  assert.isFunction(WeakMap.prototype.has);\n  assert.name(WeakMap.prototype.has, 'has');\n  if (NATIVE) assert.arity(WeakMap.prototype.has, 1);\n  assert.looksNative(WeakMap.prototype.has);\n  assert.nonEnumerable(WeakMap.prototype, 'has');\n  const weakmap = new WeakMap();\n  assert.false(weakmap.has({}), 'WeakMap .has() before .set() return false');\n  let object = {};\n  weakmap.set(object, 42);\n  assert.true(weakmap.has(object), 'WeakMap .has() return true');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'WeakMap .has() after .delete() return false');\n  assert.notThrows(() => !weakmap.has(1), 'return false on primitive');\n  object = {};\n  weakmap.set(object, 42);\n  freeze(object);\n  assert.true(weakmap.has(object), 'works with frozen objects #1');\n  weakmap.delete(object);\n  assert.false(weakmap.has(object), 'works with frozen objects #2');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#set","suites":[],"line":156,"code":"QUnit.test('WeakMap#set', assert => {\n  assert.isFunction(WeakMap.prototype.set);\n  assert.name(WeakMap.prototype.set, 'set');\n  assert.arity(WeakMap.prototype.set, 2);\n  assert.looksNative(WeakMap.prototype.set);\n  assert.nonEnumerable(WeakMap.prototype, 'set');\n  const weakmap = new WeakMap();\n  const object = {};\n  weakmap.set(object, 33);\n  assert.same(weakmap.get(object), 33, 'works with object as keys');\n  assert.same(weakmap.set({}, 42), weakmap, 'chaining');\n  assert.throws(() => new WeakMap().set(42, 42), 'throws with primitive keys');\n  const object1 = freeze({});\n  const object2 = {};\n  weakmap.set(object1, 42);\n  weakmap.set(object2, 42);\n  freeze(object);\n  assert.same(weakmap.get(object1), 42, 'works with frozen objects #1');\n  assert.same(weakmap.get(object2), 42, 'works with frozen objects #2');\n  weakmap.delete(object1);\n  weakmap.delete(object2);\n  assert.same(weakmap.get(object1), undefined, 'works with frozen objects #3');\n  assert.same(weakmap.get(object2), undefined, 'works with frozen objects #4');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakMap#@@toStringTag","suites":[],"line":180,"code":"QUnit.test('WeakMap#@@toStringTag', assert => {\n  assert.same(WeakMap.prototype[Symbol.toStringTag], 'WeakMap', 'WeakMap::@@toStringTag is `WeakMap`');\n  assert.same(String(new WeakMap()), '[object WeakMap]', 'correct stringification');\n});","file":"tests/es.weak-map.js","skipped":false,"dir":"tests"},{"name":"WeakSet","suites":[],"line":13,"code":"QUnit.test('WeakSet', assert => {\n  assert.isFunction(WeakSet);\n  assert.name(WeakSet, 'WeakSet');\n  assert.arity(WeakSet, 0);\n  assert.looksNative(WeakSet);\n  assert.true('add' in WeakSet.prototype, 'add in WeakSet.prototype');\n  assert.true('delete' in WeakSet.prototype, 'delete in WeakSet.prototype');\n  assert.true('has' in WeakSet.prototype, 'has in WeakSet.prototype');\n  assert.true(new WeakSet() instanceof WeakSet, 'new WeakSet instanceof WeakSet');\n  let object = {};\n  assert.true(new WeakSet(createIterable([object])).has(object), 'Init from iterable');\n  const weakset = new WeakSet();\n  const frozen = freeze({});\n  weakset.add(frozen);\n  assert.true(weakset.has(frozen), 'works with frozen objects, #1');\n  weakset.delete(frozen);\n  assert.false(weakset.has(frozen), 'works with frozen objects, #2');\n  let done = false;\n\n  try {\n    new WeakSet(createIterable([null, 1, 2], {\n      return() {\n        return done = true;\n      }\n\n    }));\n  } catch {\n    /* empty */\n  }\n\n  assert.true(done, '.return #throw');\n  assert.false('clear' in WeakSet.prototype, 'should not contains `.clear` method');\n  const array = [];\n  done = false;\n  array['@@iterator'] = undefined;\n\n  array[Symbol.iterator] = function () {\n    done = true;\n    return [][Symbol.iterator].call(this);\n  };\n\n  new WeakSet(array);\n  assert.true(done);\n  object = {};\n  new WeakSet().add(object);\n\n  if (DESCRIPTORS) {\n    const results = [];\n\n    for (const key in object) results.push(key);\n\n    assert.arrayEqual(results, []);\n    assert.arrayEqual(keys(object), []);\n  }\n\n  assert.arrayEqual(getOwnPropertyNames(object), []);\n  if (getOwnPropertySymbols) assert.arrayEqual(getOwnPropertySymbols(object), []);\n  if (ownKeys) assert.arrayEqual(ownKeys(object), []);\n\n  if (nativeSubclass) {\n    const Subclass = nativeSubclass(WeakSet);\n    assert.true(new Subclass() instanceof Subclass, 'correct subclassing with native classes #1');\n    assert.true(new Subclass() instanceof WeakSet, 'correct subclassing with native classes #2');\n    object = {};\n    assert.true(new Subclass().add(object).has(object), 'correct subclassing with native classes #3');\n  }\n\n  const buffer = new ArrayBuffer(8);\n  const set = new WeakSet([buffer]);\n  assert.true(set.has(buffer), 'works with ArrayBuffer keys');\n});","file":"tests/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#add","suites":[],"line":84,"code":"QUnit.test('WeakSet#add', assert => {\n  assert.isFunction(WeakSet.prototype.add);\n  assert.name(WeakSet.prototype.add, 'add');\n  assert.arity(WeakSet.prototype.add, 1);\n  assert.looksNative(WeakSet.prototype.add);\n  assert.nonEnumerable(WeakSet.prototype, 'add');\n  const weakset = new WeakSet();\n  assert.same(weakset.add({}), weakset, 'chaining');\n  assert.throws(() => new WeakSet().add(42), 'throws with primitive keys');\n});","file":"tests/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#delete","suites":[],"line":94,"code":"QUnit.test('WeakSet#delete', assert => {\n  assert.isFunction(WeakSet.prototype.delete);\n  if (NATIVE) assert.arity(WeakSet.prototype.delete, 1);\n  assert.looksNative(WeakSet.prototype.delete);\n  assert.nonEnumerable(WeakSet.prototype, 'delete');\n  const a = {};\n  const b = {};\n  const weakset = new WeakSet().add(a).add(b);\n  assert.true(weakset.has(a), 'WeakSet has values before .delete() #1');\n  assert.true(weakset.has(b), 'WeakSet has values before .delete() #2');\n  weakset.delete(a);\n  assert.false(weakset.has(a), 'WeakSet hasn`t value after .delete() #1');\n  assert.true(weakset.has(b), 'WeakSet hasn`t value after .delete() #2');\n  assert.notThrows(() => !weakset.delete(1), 'return false on primitive');\n});","file":"tests/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet#has","suites":[],"line":109,"code":"QUnit.test('WeakSet#has', assert => {\n  assert.isFunction(WeakSet.prototype.has);\n  assert.name(WeakSet.prototype.has, 'has');\n  assert.arity(WeakSet.prototype.has, 1);\n  assert.looksNative(WeakSet.prototype.has);\n  assert.nonEnumerable(WeakSet.prototype, 'has');\n  const weakset = new WeakSet();\n  assert.false(weakset.has({}), 'WeakSet has`nt value');\n  const object = {};\n  weakset.add(object);\n  assert.true(weakset.has(object), 'WeakSet has value after .add()');\n  weakset.delete(object);\n  assert.false(weakset.has(object), 'WeakSet hasn`t value after .delete()');\n  assert.notThrows(() => !weakset.has(1), 'return false on primitive');\n});","file":"tests/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"WeakSet::@@toStringTag","suites":[],"line":124,"code":"QUnit.test('WeakSet::@@toStringTag', assert => {\n  assert.same(WeakSet.prototype[Symbol.toStringTag], 'WeakSet', 'WeakSet::@@toStringTag is `WeakSet`');\n  assert.same(String(new WeakSet()), '[object WeakSet]', 'correct stringification');\n});","file":"tests/es.weak-set.js","skipped":false,"dir":"tests"},{"name":"Array#filterOut","suites":[],"line":3,"code":"QUnit.test('Array#filterOut', assert => {\n  const {\n    filterOut\n  } = Array.prototype;\n  assert.isFunction(filterOut);\n  assert.arity(filterOut, 1);\n  assert.name(filterOut, 'filterOut');\n  assert.looksNative(filterOut);\n  assert.nonEnumerable(Array.prototype, 'filterOut');\n  let array = [1];\n  const context = {};\n  array.filterOut(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], [1, 2, 3, 'q', {}, 4, true, 5].filterOut(it => typeof it != 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filterOut.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filterOut.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  assert.notThrows(() => filterOut.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }), 'uses ToLength');\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.filterOut(Boolean).foo, 1, '@@species');\n});","file":"tests/esnext.array.filter-out.js","skipped":false,"dir":"tests"},{"name":"Array#filterReject","suites":[],"line":2,"code":"QUnit.test('Array#filterReject', assert => {\n  const {\n    filterReject\n  } = Array.prototype;\n  assert.isFunction(filterReject);\n  assert.arity(filterReject, 1);\n  assert.name(filterReject, 'filterReject');\n  assert.looksNative(filterReject);\n  assert.nonEnumerable(Array.prototype, 'filterReject');\n  let array = [1];\n  const context = {};\n  array.filterReject(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.deepEqual([1, 2, 3, 4, 5], [1, 2, 3, 'q', {}, 4, true, 5].filterReject(it => typeof it != 'number'));\n\n  if (STRICT) {\n    assert.throws(() => filterReject.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => filterReject.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n  }\n\n  assert.notThrows(() => filterReject.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }), 'uses ToLength');\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.filterReject(Boolean).foo, 1, '@@species');\n});","file":"tests/esnext.array.filter-reject.js","skipped":false,"dir":"tests"},{"name":"Array#findLastIndex","suites":[],"line":2,"code":"QUnit.test('Array#findLastIndex', assert => {\n  const {\n    findLastIndex\n  } = Array.prototype;\n  assert.isFunction(findLastIndex);\n  assert.arity(findLastIndex, 1);\n  assert.name(findLastIndex, 'findLastIndex');\n  assert.looksNative(findLastIndex);\n  assert.nonEnumerable(Array.prototype, 'findLastIndex');\n  const array = [1];\n  const context = {};\n  array.findLastIndex(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same([{}, 2, NaN, 42, 1].findLastIndex(it => !(it % 2)), 3);\n  assert.same([{}, 2, NaN, 42, 1].findLastIndex(it => it === 43), -1);\n  let values = '';\n  let keys = '';\n  [1, 2, 3].findLastIndex((value, key) => {\n    values += value;\n    keys += key;\n  });\n  assert.same(values, '321');\n  assert.same(keys, '210');\n\n  if (STRICT) {\n    assert.throws(() => findLastIndex.call(null, 0), TypeError);\n    assert.throws(() => findLastIndex.call(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => findLastIndex.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === -1, 'uses ToLength');\n  assert.true('findLastIndex' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.find-last-index.js","skipped":false,"dir":"tests"},{"name":"Array#findLast","suites":[],"line":2,"code":"QUnit.test('Array#findLast', assert => {\n  const {\n    findLast\n  } = Array.prototype;\n  assert.isFunction(findLast);\n  assert.arity(findLast, 1);\n  assert.name(findLast, 'findLast');\n  assert.looksNative(findLast);\n  assert.nonEnumerable(Array.prototype, 'findLast');\n  const array = [1];\n  const context = {};\n  array.findLast(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same([{}, 2, NaN, 42, 1].findLast(it => !(it % 2)), 42);\n  assert.same([{}, 2, NaN, 42, 1].findLast(it => it === 43), undefined);\n  let values = '';\n  let keys = '';\n  [1, 2, 3].findLast((value, key) => {\n    values += value;\n    keys += key;\n  });\n  assert.same(values, '321');\n  assert.same(keys, '210');\n\n  if (STRICT) {\n    assert.throws(() => findLast.call(null, 0), TypeError);\n    assert.throws(() => findLast.call(undefined, 0), TypeError);\n  }\n\n  assert.notThrows(() => findLast.call({\n    length: -1,\n    0: 1\n  }, () => {\n    throw new Error();\n  }) === undefined, 'uses ToLength');\n  assert.true('find' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.find-last.js","skipped":false,"dir":"tests"},{"name":"Array.fromAsync","suites":[],"line":3,"code":"QUnit.test('Array.fromAsync', assert => {\n  assert.expect(27);\n  const async = assert.async();\n  const {\n    fromAsync\n  } = Array;\n  assert.isFunction(fromAsync);\n  assert.arity(fromAsync, 1);\n  assert.name(fromAsync, 'fromAsync');\n  assert.looksNative(fromAsync);\n  assert.nonEnumerable(Array, 'fromAsync');\n\n  function C() {\n    /* empty */\n  }\n\n  fromAsync(createAsyncIterable([1, 2, 3]), it => it ** 2).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'async iterable and mapfn');\n    return fromAsync(createAsyncIterable([1]), function (arg, index) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      assert.same(index, 0, 'index');\n    });\n  }).then(() => {\n    return fromAsync(createAsyncIterable([1, 2, 3]));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'async iterable without mapfn');\n    return fromAsync(createIterable([1, 2, 3]), arg => arg ** 2);\n  }).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'iterable and mapfn');\n    return fromAsync(createIterable([1, 2, 3]), arg => Promise.resolve(arg ** 2));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'iterable and async mapfn');\n    return fromAsync(createIterable([1]), function (arg, index) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      assert.same(index, 0, 'index');\n    });\n  }).then(() => {\n    return fromAsync(createIterable([1, 2, 3]));\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'iterable and without mapfn');\n    return fromAsync([1, Promise.resolve(2), 3]);\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'array');\n    return fromAsync('123');\n  }).then(it => {\n    assert.arrayEqual(it, ['1', '2', '3'], 'string');\n    return fromAsync.call(C, [1]);\n  }).then(it => {\n    assert.true(it instanceof C, 'subclassable');\n    return fromAsync({\n      length: 1,\n      0: 1\n    });\n  }).then(it => {\n    assert.arrayEqual(it, [1], 'non-iterable');\n    return fromAsync(createIterable([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n    return fromAsync(undefined, () => {\n      /* empty */\n    });\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync(null, () => {\n      /* empty */\n    });\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync([1], null);\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    return fromAsync([1], {});\n  }).catch(error => {\n    assert.true(error instanceof TypeError);\n    async();\n  });\n});","file":"tests/esnext.array.from-async.js","skipped":false,"dir":"tests"},{"name":"Array#groupByToMap","suites":[],"line":5,"code":"QUnit.test('Array#groupByToMap', assert => {\n  const {\n    groupByToMap\n  } = Array.prototype;\n  assert.isFunction(groupByToMap);\n  assert.arity(groupByToMap, 1);\n  assert.name(groupByToMap, 'groupByToMap');\n  assert.looksNative(groupByToMap);\n  assert.nonEnumerable(Array.prototype, 'groupByToMap');\n  let array = [1];\n  const context = {};\n  array.groupByToMap(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true([].groupByToMap(it => it) instanceof Map, 'returns Map');\n  assert.deepEqual(from([1, 2, 3].groupByToMap(it => it % 2)), [[1, [1, 3]], [0, [2]]], '#1');\n  assert.deepEqual(from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].groupByToMap(it => `i${it % 5}`)), [['i1', [1, 6, 11]], ['i2', [2, 7, 12]], ['i3', [3, 8]], ['i4', [4, 9]], ['i0', [5, 10]]], '#2');\n  assert.deepEqual(from(Array(3).groupByToMap(it => it)), [[undefined, [undefined, undefined, undefined]]], '#3');\n\n  if (STRICT) {\n    assert.throws(() => groupByToMap.call(null, () => {\n      /* empty */\n    }), TypeError, 'null this -> TypeError');\n    assert.throws(() => groupByToMap.call(undefined, () => {\n      /* empty */\n    }), TypeError, 'undefined this -> TypeError');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.groupByToMap(Boolean).get(true).foo, undefined, 'no @@species');\n});","file":"tests/esnext.array.group-by-to-map.js","skipped":false,"dir":"tests"},{"name":"Array#groupBy","suites":[],"line":5,"code":"QUnit.test('Array#groupBy', assert => {\n  const {\n    groupBy\n  } = Array.prototype;\n  assert.isFunction(groupBy);\n  assert.arity(groupBy, 1);\n  assert.name(groupBy, 'groupBy');\n  assert.looksNative(groupBy);\n  assert.nonEnumerable(Array.prototype, 'groupBy');\n  let array = [1];\n  const context = {};\n  array.groupBy(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 0, 'correct index in callback');\n    assert.same(that, array, 'correct link to array in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(getPrototypeOf([].groupBy(it => it)), null, 'null proto');\n  assert.deepEqual([1, 2, 3].groupBy(it => it % 2), {\n    1: [1, 3],\n    0: [2]\n  }, '#1');\n  assert.deepEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].groupBy(it => `i${it % 5}`), {\n    i1: [1, 6, 11],\n    i2: [2, 7, 12],\n    i3: [3, 8],\n    i4: [4, 9],\n    i0: [5, 10]\n  }, '#2');\n  assert.deepEqual(Array(3).groupBy(it => it), {\n    undefined: [undefined, undefined, undefined]\n  }, '#3');\n\n  if (STRICT) {\n    assert.throws(() => groupBy.call(null, () => {\n      /* empty */\n    }), TypeError, 'null this -> TypeError');\n    assert.throws(() => groupBy.call(undefined, () => {\n      /* empty */\n    }), TypeError, 'undefined this -> TypeError');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.same(array.groupBy(Boolean).true.foo, undefined, 'no @@species');\n});","file":"tests/esnext.array.group-by.js","skipped":false,"dir":"tests"},{"name":"Array.isTemplateObject","suites":[],"line":1,"code":"QUnit.test('Array.isTemplateObject', assert => {\n  const {\n    isTemplateObject\n  } = Array;\n  const {\n    freeze\n  } = Object;\n  assert.isFunction(isTemplateObject);\n  assert.arity(isTemplateObject, 1);\n  assert.name(isTemplateObject, 'isTemplateObject');\n  assert.looksNative(isTemplateObject);\n  assert.nonEnumerable(Array, 'isTemplateObject');\n  assert.false(isTemplateObject(undefined));\n  assert.false(isTemplateObject(null));\n  assert.false(isTemplateObject({}));\n  assert.false(isTemplateObject(function () {\n    return arguments;\n  }()));\n  assert.false(isTemplateObject([]));\n  assert.false(isTemplateObject(freeze([])));\n\n  const template = (() => {\n    try {\n      // eslint-disable-next-line no-template-curly-in-string -- safe\n      return Function('return (it => it)`qwe${ 123 }asd`')();\n    } catch {\n      /* empty */\n    }\n  })();\n\n  if (template) assert.true(isTemplateObject(template));\n});","file":"tests/esnext.array.is-template-object.js","skipped":false,"dir":"tests"},{"name":"Array#lastIndex","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Array#lastIndex', assert => {\n  const descriptor = Object.getOwnPropertyDescriptor(Array.prototype, 'lastIndex');\n  assert.isFunction(descriptor.get);\n  assert.false(descriptor.enumerable);\n  assert.true(descriptor.configurable);\n  assert.same([1, 2, 3].lastIndex, 2);\n  assert.same([].lastIndex, 0);\n});","file":"tests/esnext.array.last-index.js","skipped":false,"dir":"tests"},{"name":"Array#lastItem","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('Array#lastItem', assert => {\n  const descriptor = Object.getOwnPropertyDescriptor(Array.prototype, 'lastItem');\n  assert.isFunction(descriptor.get);\n  assert.isFunction(descriptor.set);\n  assert.false(descriptor.enumerable);\n  assert.true(descriptor.configurable);\n  assert.same([1, 2, 3].lastItem, 3);\n  assert.same([].lastItem, undefined);\n  let array = [1, 2, 3];\n  array.lastItem = 4;\n  assert.deepEqual(array, [1, 2, 4]);\n  array = [];\n  array.lastItem = 5;\n  assert.deepEqual(array, [5]);\n});","file":"tests/esnext.array.last-item.js","skipped":false,"dir":"tests"},{"name":"Array#toReversed","suites":[],"line":2,"code":"QUnit.test('Array#toReversed', assert => {\n  const {\n    toReversed\n  } = Array.prototype;\n  assert.isFunction(toReversed);\n  assert.arity(toReversed, 0);\n  assert.name(toReversed, 'toReversed');\n  assert.looksNative(toReversed);\n  assert.nonEnumerable(Array.prototype, 'toReversed');\n  let array = [1, 2];\n  assert.notSame(array.toReversed(), array, 'immutable');\n  assert.deepEqual([1, 2.2, 3.3].toReversed(), [3.3, 2.2, 1], 'basic');\n  const object = {};\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  const expected = [Infinity, undefined, NaN, object, true, 'a', -1, 'X', 1, 2, undefined];\n  assert.deepEqual(toReversed.call(array), expected, 'non-array target');\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(array.toReversed() instanceof Array, 'non-generic');\n\n  if (STRICT) {\n    assert.throws(() => toReversed.call(null, () => {\n      /* empty */\n    }, 1), TypeError);\n    assert.throws(() => toReversed.call(undefined, () => {\n      /* empty */\n    }, 1), TypeError);\n  }\n\n  assert.true('toReversed' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.to-reversed.js","skipped":false,"dir":"tests"},{"name":"Array#toSorted","suites":[],"line":2,"code":"QUnit.test('Array#toSorted', assert => {\n  const {\n    toSorted\n  } = Array.prototype;\n  assert.isFunction(toSorted);\n  assert.arity(toSorted, 1);\n  assert.name(toSorted, 'toSorted');\n  assert.looksNative(toSorted);\n  assert.nonEnumerable(Array.prototype, 'toSorted');\n  let array = [1];\n  assert.notSame(array.toSorted(), array, 'immutable');\n  assert.deepEqual([1, 3, 2].toSorted(), [1, 2, 3], '#1');\n  assert.deepEqual([1, 3, 2, 11].toSorted(), [1, 11, 2, 3], '#2');\n  assert.deepEqual([1, -1, 3, NaN, 2, 0, 11, -0].toSorted(), [-1, 0, -0, 1, 11, 2, 3, NaN], '#1');\n  array = Array(5);\n  array[0] = 1;\n  array[2] = 3;\n  array[4] = 2;\n  let expected = Array(5);\n  expected[0] = 1;\n  expected[1] = 2;\n  expected[2] = 3;\n  assert.deepEqual(array.toSorted(), expected, 'holes');\n  array = 'zyxwvutsrqponMLKJIHGFEDCBA'.split('');\n  expected = 'ABCDEFGHIJKLMnopqrstuvwxyz'.split('');\n  assert.deepEqual(array.toSorted(), expected, 'alpha #1');\n  array = 'ёяюэьыъщшчцхфутсрПОНМЛКЙИЗЖЕДГВБА'.split('');\n  expected = 'АБВГДЕЖЗИЙКЛМНОПрстуфхцчшщъыьэюяё'.split('');\n  assert.deepEqual(array.toSorted(), expected, 'alpha #2');\n  array = [undefined, 1];\n  assert.notThrows(() => array = array.toSorted(() => {\n    throw 1;\n  }), 'undefined #1');\n  assert.deepEqual(array, [1, undefined], 'undefined #2');\n  const object = {\n    valueOf: () => 1,\n    toString: () => -1\n  };\n  array = {\n    0: undefined,\n    1: 2,\n    2: 1,\n    3: 'X',\n    4: -1,\n    5: 'a',\n    6: true,\n    7: object,\n    8: NaN,\n    10: Infinity,\n    length: 11\n  };\n  expected = [-1, object, 1, 2, Infinity, NaN, 'X', 'a', true, undefined, undefined];\n  assert.deepEqual(toSorted.call(array), expected, 'non-array target');\n  let index, mod, code, chr, value;\n  expected = Array(516);\n  array = Array(516);\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  assert.arrayEqual(array.toSorted((a, b) => (a / 4 | 0) - (b / 4 | 0)), expected, 'stable #1');\n  assert.true(1 / [0, -0].toSorted()[0] > 0, '-0');\n  let result = '';\n  array = []; // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n\n      case 68:\n      case 71:\n        value = 4;\n        break;\n\n      default:\n        value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      array.push({\n        k: chr + index,\n        v: value\n      });\n    }\n  }\n\n  array = array.toSorted((a, b) => b.v - a.v);\n\n  for (index = 0; index < array.length; index++) {\n    chr = array[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  assert.same(result, 'DGBEFHACIJK', 'stable #2');\n  assert.notThrows(() => [1, 2, 3].toSorted(undefined).length === 3, 'works with undefined');\n  assert.throws(() => [1, 2, 3].toSorted(null), 'throws on null');\n  assert.throws(() => [1, 2, 3].toSorted({}), 'throws on {}');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => [Symbol(1), Symbol(2)].toSorted(), 'w/o cmp throws on symbols');\n  }\n\n  array = [1]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(array.toSorted() instanceof Array, 'non-generic');\n\n  if (STRICT) {\n    assert.throws(() => toSorted.call(null), TypeError, 'ToObject(this)');\n    assert.throws(() => toSorted.call(undefined), TypeError, 'ToObject(this)');\n  }\n\n  assert.true('toSorted' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.to-sorted.js","skipped":false,"dir":"tests"},{"name":"Array#toSpliced","suites":[],"line":2,"code":"QUnit.test('Array#toSpliced', assert => {\n  const {\n    toSpliced\n  } = Array.prototype;\n  assert.isFunction(toSpliced);\n  assert.arity(toSpliced, 2);\n  assert.name(toSpliced, 'toSpliced');\n  assert.looksNative(toSpliced);\n  assert.nonEnumerable(Array.prototype, 'toSpliced');\n  let array = [1, 2, 3, 4, 5];\n  assert.notSame(array.toSpliced(2), array, 'immutable');\n  assert.deepEqual([1, 2, 3, 4, 5].toSpliced(2), [1, 2]);\n  assert.deepEqual([1, 2, 3, 4, 5].toSpliced(-2), [1, 2, 3]);\n  assert.deepEqual([1, 2, 3, 4, 5].toSpliced(2, 2), [1, 2, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].toSpliced(2, -2), [1, 2, 3, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].toSpliced(2, 2, 6, 7), [1, 2, 6, 7, 5]);\n\n  if (STRICT) {\n    assert.throws(() => toSpliced.call(null), TypeError);\n    assert.throws(() => toSpliced.call(undefined), TypeError);\n  }\n\n  array = []; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(array.toSpliced() instanceof Array, 'non-generic');\n  assert.true('toSpliced' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.to-spliced.js","skipped":false,"dir":"tests"},{"name":"Array#uniqueBy","suites":[],"line":2,"code":"QUnit.test('Array#uniqueBy', assert => {\n  const {\n    uniqueBy\n  } = Array.prototype;\n  assert.isFunction(uniqueBy);\n  assert.arity(uniqueBy, 1);\n  assert.name(uniqueBy, 'uniqueBy');\n  assert.looksNative(uniqueBy);\n  assert.nonEnumerable(Array.prototype, 'uniqueBy');\n  let array = [1, 2, 3, 2, 1];\n  assert.notSame(array.uniqueBy(), array);\n  assert.deepEqual(array.uniqueBy(), [1, 2, 3]);\n  array = [{\n    id: 1,\n    uid: 10000\n  }, {\n    id: 2,\n    uid: 10000\n  }, {\n    id: 3,\n    uid: 10001\n  }];\n  assert.deepEqual(array.uniqueBy(it => it.uid), [{\n    id: 1,\n    uid: 10000\n  }, {\n    id: 3,\n    uid: 10001\n  }]);\n  assert.deepEqual(array.uniqueBy(({\n    id,\n    uid\n  }) => `${id}-${uid}`), array);\n  assert.deepEqual([1, undefined, 2, undefined, null, 1].uniqueBy(), [1, undefined, 2, null]);\n  assert.deepEqual([0, -0].uniqueBy(), [0]);\n  assert.deepEqual([NaN, NaN].uniqueBy(), [NaN]);\n  assert.deepEqual(uniqueBy.call({\n    length: 1,\n    0: 1\n  }), [1]);\n\n  if (STRICT) {\n    assert.throws(() => uniqueBy.call(null), TypeError);\n    assert.throws(() => uniqueBy.call(undefined), TypeError);\n  }\n\n  assert.true('uniqueBy' in Array.prototype[Symbol.unscopables], 'In Array#@@unscopables');\n});","file":"tests/esnext.array.unique-by.js","skipped":false,"dir":"tests"},{"name":"Array#with","suites":[],"line":2,"code":"QUnit.test('Array#with', assert => {\n  const {\n    with: withAt\n  } = Array.prototype;\n  assert.isFunction(withAt);\n  assert.arity(withAt, 2); // assert.name(withAt, 'with');\n\n  assert.looksNative(withAt);\n  assert.nonEnumerable(Array.prototype, 'with');\n  let array = [1, 2, 3, 4, 5];\n  assert.notSame(array.with(2, 1), array, 'immutable');\n  assert.deepEqual([1, 2, 3, 4, 5].with(2, 6), [1, 2, 6, 4, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].with(-2, 6), [1, 2, 3, 6, 5]);\n  assert.deepEqual([1, 2, 3, 4, 5].with('1', 6), [1, 6, 3, 4, 5]);\n  assert.throws(() => [1, 2, 3, 4, 5].with(5, 6), RangeError);\n  assert.throws(() => [1, 2, 3, 4, 5].with(-6, 6), RangeError);\n\n  if (STRICT) {\n    assert.throws(() => withAt.call(null, 1, 2), TypeError);\n    assert.throws(() => withAt.call(undefined, 1, 2), TypeError);\n  }\n\n  array = [1, 2]; // eslint-disable-next-line object-shorthand -- constructor\n\n  array.constructor = {\n    [Symbol.species]: function () {\n      return {\n        foo: 1\n      };\n    }\n  };\n  assert.true(array.with(1, 2) instanceof Array, 'non-generic');\n});","file":"tests/esnext.array.with.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#asIndexedPairs","suites":[],"line":2,"code":"QUnit.test('AsyncIterator#asIndexedPairs', assert => {\n  assert.expect(10);\n  const async = assert.async();\n  const {\n    asIndexedPairs\n  } = AsyncIterator.prototype;\n  assert.isFunction(asIndexedPairs);\n  assert.arity(asIndexedPairs, 0);\n  assert.name(asIndexedPairs, 'asIndexedPairs');\n  assert.looksNative(asIndexedPairs);\n  assert.nonEnumerable(AsyncIterator.prototype, 'asIndexedPairs');\n  asIndexedPairs.call(createIterator(['a', 'b', 'c'])).toArray().then(it => {\n    assert.same(it.toString(), '0,a,1,b,2,c', 'basic functionality');\n    async();\n  });\n  assert.throws(() => asIndexedPairs.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => asIndexedPairs.call([], () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.async-iterator.as-indexed-pairs.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator","suites":[],"line":4,"code":"QUnit.test('AsyncIterator', assert => {\n  assert.isFunction(AsyncIterator);\n  assert.arity(AsyncIterator, 0);\n  assert.name(AsyncIterator, 'AsyncIterator');\n  assert.looksNative(AsyncIterator);\n\n  const asyncGenerator = (() => {\n    try {\n      return Function('return async function*(){}()')();\n    } catch {\n      /* empty */\n    }\n  })();\n\n  if (asyncGenerator && globalThis.USE_FUNCTION_CONSTRUCTOR) {\n    const proto = getPrototypeOf(getPrototypeOf(getPrototypeOf(asyncGenerator)));\n\n    if (proto !== Object.prototype && proto !== null) {\n      assert.true(asyncGenerator instanceof AsyncIterator, 'AsyncGenerator');\n    }\n  }\n\n  assert.true(AsyncIterator.from([1, 2, 3]) instanceof AsyncIterator, 'Async From Proxy');\n  assert.true(AsyncIterator.from([1, 2, 3]).drop(1) instanceof AsyncIterator, 'Async Drop Proxy');\n  assert.true(new AsyncIterator() instanceof AsyncIterator, 'constructor');\n  assert.throws(() => AsyncIterator(), 'throws w/o `new`');\n});","file":"tests/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#constructor","suites":[],"line":31,"code":"QUnit.test('AsyncIterator#constructor', assert => {\n  assert.same(AsyncIterator.prototype.constructor, AsyncIterator, 'AsyncIterator#constructor is AsyncIterator');\n});","file":"tests/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#@@toStringTag","suites":[],"line":34,"code":"QUnit.test('AsyncIterator#@@toStringTag', assert => {\n  assert.same(AsyncIterator.prototype[Symbol.toStringTag], 'AsyncIterator', 'AsyncIterator::@@toStringTag is `AsyncIterator`');\n  assert.same(String(AsyncIterator.from([1, 2, 3])), '[object AsyncIterator]', 'correct stringification');\n});","file":"tests/esnext.async-iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#drop","suites":[],"line":2,"code":"QUnit.test('AsyncIterator#drop', assert => {\n  assert.expect(14);\n  const async = assert.async();\n  const {\n    drop\n  } = AsyncIterator.prototype;\n  assert.isFunction(drop);\n  assert.arity(drop, 1);\n  assert.name(drop, 'drop');\n  assert.looksNative(drop);\n  assert.nonEnumerable(AsyncIterator.prototype, 'drop');\n  drop.call(createIterator([1, 2, 3]), 1).toArray().then(it => {\n    assert.arrayEqual(it, [2, 3], 'basic functionality');\n    return drop.call(createIterator([1, 2, 3]), 1.5).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [2, 3], 'float');\n    return drop.call(createIterator([1, 2, 3]), 4).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [], 'big');\n    return drop.call(createIterator([1, 2, 3]), 0).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'zero');\n  }).then(() => async());\n  assert.throws(() => drop.call(undefined, 1), TypeError);\n  assert.throws(() => drop.call(null, 1), TypeError);\n  assert.throws(() => drop.call({}, 1), TypeError);\n  assert.throws(() => drop.call([], 1), TypeError);\n  assert.throws(() => drop.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"tests/esnext.async-iterator.drop.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#every","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#every', assert => {\n  assert.expect(18);\n  const async = assert.async();\n  const {\n    every\n  } = AsyncIterator.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.looksNative(every);\n  assert.nonEnumerable(AsyncIterator.prototype, 'every');\n  every.call(createIterator([1, 2, 3]), it => typeof it == 'number').then(result => {\n    assert.true(result, 'basic functionality, +');\n    return every.call(createIterator([1, 2, 3]), it => it === 2);\n  }).then(result => {\n    assert.false(result, 'basic functionality, -');\n    return every.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return every.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => every.call(createIterator([1]), null), TypeError);\n  assert.throws(() => every.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.every.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#filter","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#filter', assert => {\n  assert.expect(17);\n  const async = assert.async();\n  const {\n    filter\n  } = AsyncIterator.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.looksNative(filter);\n  assert.nonEnumerable(AsyncIterator.prototype, 'filter');\n  filter.call(createIterator([1, 2, 3]), it => it % 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 3], 'basic functionality');\n    return filter.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    }).toArray();\n  }).then(() => {\n    return filter.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), null), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.filter.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#find","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#find', assert => {\n  assert.expect(18);\n  const async = assert.async();\n  const {\n    find\n  } = AsyncIterator.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.looksNative(find);\n  assert.nonEnumerable(AsyncIterator.prototype, 'find');\n  find.call(createIterator([2, 3, 4]), it => it % 2).then(result => {\n    assert.same(result, 3, 'basic functionality, +');\n    return find.call(createIterator([1, 2, 3]), it => it === 4);\n  }).then(result => {\n    assert.same(result, undefined, 'basic functionality, -');\n    return find.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return find.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => find.call(createIterator([1]), null), TypeError);\n  assert.throws(() => find.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.find.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#flatMap","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#flatMap', assert => {\n  assert.expect(17);\n  const async = assert.async();\n  const {\n    flatMap\n  } = AsyncIterator.prototype;\n  assert.isFunction(flatMap);\n  assert.arity(flatMap, 1);\n  assert.name(flatMap, 'flatMap');\n  assert.looksNative(flatMap);\n  assert.nonEnumerable(AsyncIterator.prototype, 'flatMap');\n  flatMap.call(createIterator([1, [], 2, createIterable([3, 4]), [5, 6], 'ab']), it => typeof it == 'number' ? [-it] : it).toArray().then(it => {\n    assert.arrayEqual(it, [-1, -2, 3, 4, 5, 6, 'a', 'b'], 'basic functionality');\n    return flatMap.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n      return [arg];\n    }).toArray();\n  }).then(() => {\n    return flatMap.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => flatMap.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), null), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.flat-map.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#forEach","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#forEach', assert => {\n  assert.expect(17);\n  const async = assert.async();\n  const {\n    forEach\n  } = AsyncIterator.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.name(forEach, 'forEach');\n  assert.looksNative(forEach);\n  assert.nonEnumerable(AsyncIterator.prototype, 'forEach');\n  const array = [];\n  forEach.call(createIterator([1, 2, 3]), it => array.push(it)).then(() => {\n    assert.arrayEqual(array, [1, 2, 3], 'basic functionality');\n    return forEach.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return forEach.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => forEach.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), null), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.for-each.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator.from","suites":[],"line":1,"code":"QUnit.test('AsyncIterator.from', assert => {\n  assert.expect(12);\n  const async = assert.async();\n  const {\n    from\n  } = AsyncIterator;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(AsyncIterator, 'from');\n  assert.true(AsyncIterator.from([].values()) instanceof AsyncIterator, 'proxy, iterator');\n  assert.true(AsyncIterator.from([]) instanceof AsyncIterator, 'proxy, iterable');\n  AsyncIterator.from([1, Promise.resolve(2), 3]).toArray().then(result => {\n    assert.arrayEqual(result, [1, 2, 3], 'unwrap promises');\n    async();\n  });\n  const asyncIterator = Object.assign(new AsyncIterator(), {\n    next: () => {\n      /* empty */\n    }\n  });\n  assert.same(AsyncIterator.from(asyncIterator), asyncIterator, 'does not wrap AsyncIterator instances');\n  assert.throws(() => from(undefined), TypeError);\n  assert.throws(() => from(null), TypeError);\n  assert.throws(() => from({}), TypeError);\n});","file":"tests/esnext.async-iterator.from.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#map","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#map', assert => {\n  assert.expect(17);\n  const async = assert.async();\n  const {\n    map\n  } = AsyncIterator.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.name(map, 'map');\n  assert.looksNative(map);\n  assert.nonEnumerable(AsyncIterator.prototype, 'map');\n  map.call(createIterator([1, 2, 3]), it => it ** 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 4, 9], 'basic functionality');\n    return map.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    }).toArray();\n  }).then(() => {\n    return map.call(createIterator([1]), () => {\n      throw 42;\n    }).toArray();\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => map.call(createIterator([1]), null), TypeError);\n  assert.throws(() => map.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.map.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#reduce","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#reduce', assert => {\n  assert.expect(20);\n  const async = assert.async();\n  const {\n    reduce\n  } = AsyncIterator.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.looksNative(reduce);\n  assert.nonEnumerable(AsyncIterator.prototype, 'reduce');\n  reduce.call(createIterator([1, 2, 3]), (a, b) => a + b, 1).then(it => {\n    assert.same(it, 7, 'basic functionality, initial');\n    return reduce.call(createIterator([2]), function (a, b) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 2, 'arguments length');\n      assert.same(a, 1, 'argument 1');\n      assert.same(b, 2, 'argument 2');\n    }, 1);\n  }).then(() => {\n    return reduce.call(createIterator([1, 2, 3]), (a, b) => a + b);\n  }).then(it => {\n    assert.same(it, 6, 'basic functionality, no initial');\n    return reduce.call(createIterator([]), (a, b) => a + b);\n  }).catch(() => {\n    assert.required('reduce an empty interble with no initial');\n    return reduce.call(createIterator([1]), () => {\n      throw 42;\n    }, 1);\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call([], () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), undefined, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), null, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), {}, 1), TypeError);\n});","file":"tests/esnext.async-iterator.reduce.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#some","suites":[],"line":3,"code":"QUnit.test('AsyncIterator#some', assert => {\n  assert.expect(18);\n  const async = assert.async();\n  const {\n    some\n  } = AsyncIterator.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.looksNative(some);\n  assert.nonEnumerable(AsyncIterator.prototype, 'some');\n  some.call(createIterator([1, 2, 3]), it => it === 2).then(result => {\n    assert.true(result, 'basic functionality, +');\n    return some.call(createIterator([1, 2, 3]), it => it === 4);\n  }).then(result => {\n    assert.false(result, 'basic functionality, -');\n    return some.call(createIterator([1]), function (arg) {\n      assert.same(this, STRICT_THIS, 'this');\n      assert.same(arguments.length, 1, 'arguments length');\n      assert.same(arg, 1, 'argument');\n    });\n  }).then(() => {\n    return some.call(createIterator([1]), () => {\n      throw 42;\n    });\n  }).catch(error => {\n    assert.same(error, 42, 'rejection on a callback error');\n  }).then(() => async());\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => some.call(createIterator([1]), null), TypeError);\n  assert.throws(() => some.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.async-iterator.some.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#take","suites":[],"line":2,"code":"QUnit.test('AsyncIterator#take', assert => {\n  assert.expect(14);\n  const async = assert.async();\n  const {\n    take\n  } = AsyncIterator.prototype;\n  assert.isFunction(take);\n  assert.arity(take, 1);\n  assert.name(take, 'take');\n  assert.looksNative(take);\n  assert.nonEnumerable(AsyncIterator.prototype, 'take');\n  take.call(createIterator([1, 2, 3]), 2).toArray().then(it => {\n    assert.arrayEqual(it, [1, 2], 'basic functionality');\n    return take.call(createIterator([1, 2, 3]), 1.5).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1], 'float');\n    return take.call(createIterator([1, 2, 3]), 4).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3], 'big');\n    return take.call(createIterator([1, 2, 3]), 0).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [], 'zero');\n  }).then(() => async());\n  assert.throws(() => take.call(undefined, 1), TypeError);\n  assert.throws(() => take.call(null, 1), TypeError);\n  assert.throws(() => take.call({}, 1), TypeError);\n  assert.throws(() => take.call([], 1), TypeError);\n  assert.throws(() => take.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"tests/esnext.async-iterator.take.js","skipped":false,"dir":"tests"},{"name":"AsyncIterator#toArray","suites":[],"line":2,"code":"QUnit.test('AsyncIterator#toArray', assert => {\n  assert.expect(10);\n  const async = assert.async();\n  const {\n    toArray\n  } = AsyncIterator.prototype;\n  assert.isFunction(toArray);\n  assert.arity(toArray, 0);\n  assert.name(toArray, 'toArray');\n  assert.looksNative(toArray);\n  assert.nonEnumerable(AsyncIterator.prototype, 'toArray');\n  toArray.call(createIterator([1, 2, 3])).then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n    async();\n  });\n  assert.throws(() => toArray.call(undefined), TypeError);\n  assert.throws(() => toArray.call(null), TypeError);\n  assert.throws(() => toArray.call({}), TypeError);\n  assert.throws(() => toArray.call([]), TypeError);\n});","file":"tests/esnext.async-iterator.to-array.js","skipped":false,"dir":"tests"},{"name":"BigInt.range","suites":[],"line":2,"code":"if (typeof BigInt == 'function') QUnit.test('BigInt.range', assert => {\n  const {\n    range\n  } = BigInt;\n  const {\n    from\n  } = Array;\n  assert.isFunction(range);\n  assert.name(range, 'range');\n  assert.arity(range, 3);\n  assert.looksNative(range);\n  assert.nonEnumerable(BigInt, 'range');\n  let iterator = range(BigInt(1), BigInt(2));\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: BigInt(1),\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.deepEqual(from(range(BigInt(-1), BigInt(5))), [BigInt(-1), BigInt(0), BigInt(1), BigInt(2), BigInt(3), BigInt(4)]);\n  assert.deepEqual(from(range(BigInt(-5), BigInt(1))), [BigInt(-5), BigInt(-4), BigInt(-3), BigInt(-2), BigInt(-1), BigInt(0)]);\n  assert.deepEqual(from(range(BigInt('9007199254740991'), BigInt('9007199254740992'), {\n    inclusive: true\n  })), [BigInt('9007199254740991'), BigInt('9007199254740992')]);\n  assert.deepEqual(from(range(BigInt(0), BigInt(0))), []);\n  assert.deepEqual(from(range(BigInt(0), BigInt(-5), BigInt(1))), []);\n  iterator = range(BigInt(1), BigInt(3));\n  assert.deepEqual(iterator.start, BigInt(1));\n  assert.deepEqual(iterator.end, BigInt(3));\n  assert.deepEqual(iterator.step, BigInt(1));\n  assert.false(iterator.inclusive);\n  iterator = range(BigInt(-1), BigInt(-3), {\n    inclusive: true\n  });\n  assert.deepEqual(iterator.start, BigInt(-1));\n  assert.deepEqual(iterator.end, BigInt(-3));\n  assert.same(iterator.step, BigInt(-1));\n  assert.true(iterator.inclusive);\n  iterator = range(BigInt(-1), BigInt(-3), {\n    step: BigInt(4),\n\n    inclusive() {\n      /* empty */\n    }\n\n  });\n  assert.same(iterator.start, BigInt(-1));\n  assert.same(iterator.end, BigInt(-3));\n  assert.same(iterator.step, BigInt(4));\n  assert.true(iterator.inclusive);\n  iterator = range(BigInt(0), BigInt(5));\n  assert.throws(() => Object.getOwnPropertyDescriptor(iterator, 'start').call({}), TypeError);\n  assert.throws(() => range(Infinity, BigInt(10), BigInt(0)), TypeError);\n  assert.throws(() => range(-Infinity, BigInt(10), BigInt(0)), TypeError);\n  assert.throws(() => range(BigInt(0), BigInt(10), Infinity), TypeError);\n  assert.throws(() => range(BigInt(0), BigInt(10), {\n    step: Infinity\n  }), TypeError);\n  assert.throws(() => range({}, BigInt(1)), TypeError);\n  assert.throws(() => range(BigInt(1), {}), TypeError);\n});","file":"tests/esnext.bigint.range.js","skipped":false,"dir":"tests"},{"name":"compositeKey","suites":[],"line":6,"code":"QUnit.test('compositeKey', assert => {\n  assert.isFunction(compositeKey);\n  assert.name(compositeKey, 'compositeKey');\n  assert.looksNative(compositeKey);\n  const key = compositeKey({});\n  assert.same(typeof key, 'object');\n  assert.same({}.toString.call(key), '[object Object]');\n  assert.same(getPrototypeOf(key), null);\n  if (FREEZING) assert.true(isFrozen(key));\n  const a = ['a'];\n  const b = ['b'];\n  const c = ['c'];\n  assert.same(compositeKey(a), compositeKey(a));\n  assert.notSame(compositeKey(a), compositeKey(['a']));\n  assert.notSame(compositeKey(a), compositeKey(a, 1));\n  assert.notSame(compositeKey(a), compositeKey(a, b));\n  assert.same(compositeKey(a, 1), compositeKey(a, 1));\n  assert.same(compositeKey(a, b), compositeKey(a, b));\n  assert.notSame(compositeKey(a, b), compositeKey(b, a));\n  assert.same(compositeKey(a, b, c), compositeKey(a, b, c));\n  assert.notSame(compositeKey(a, b, c), compositeKey(c, b, a));\n  assert.notSame(compositeKey(a, b, c), compositeKey(a, c, b));\n  assert.notSame(compositeKey(a, b, c, 1), compositeKey(a, b, c));\n  assert.same(compositeKey(a, b, c, 1), compositeKey(a, b, c, 1));\n  assert.same(compositeKey(1, a), compositeKey(1, a));\n  assert.notSame(compositeKey(1, a), compositeKey(a, 1));\n  assert.same(compositeKey(1, a, 2, b), compositeKey(1, a, 2, b));\n  assert.notSame(compositeKey(1, a, 2, b), compositeKey(1, a, b, 2));\n  assert.same(compositeKey(1, 2, a, b), compositeKey(1, 2, a, b));\n  assert.notSame(compositeKey(1, 2, a, b), compositeKey(1, a, b, 2));\n  assert.same(compositeKey(a, a), compositeKey(a, a));\n  assert.notSame(compositeKey(a, a), compositeKey(a, ['a']));\n  assert.notSame(compositeKey(a, a), compositeKey(a, b));\n  assert.throws(() => compositeKey(), TypeError);\n  assert.throws(() => compositeKey(1, 2), TypeError);\n  assert.throws(() => compositeKey('foo', null, true), TypeError);\n});","file":"tests/esnext.composite-key.js","skipped":false,"dir":"tests"},{"name":"compositeSymbol","suites":[],"line":1,"code":"QUnit.test('compositeSymbol', assert => {\n  assert.isFunction(compositeSymbol);\n  assert.name(compositeSymbol, 'compositeSymbol');\n  assert.looksNative(compositeSymbol);\n  assert.true(Object(compositeSymbol({})) instanceof Symbol);\n  const a = ['a'];\n  const b = ['b'];\n  const c = ['c'];\n  assert.same(compositeSymbol(a), compositeSymbol(a));\n  assert.notSame(compositeSymbol(a), compositeSymbol(['a']));\n  assert.notSame(compositeSymbol(a), compositeSymbol(a, 1));\n  assert.notSame(compositeSymbol(a), compositeSymbol(a, b));\n  assert.same(compositeSymbol(a, 1), compositeSymbol(a, 1));\n  assert.same(compositeSymbol(a, b), compositeSymbol(a, b));\n  assert.notSame(compositeSymbol(a, b), compositeSymbol(b, a));\n  assert.same(compositeSymbol(a, b, c), compositeSymbol(a, b, c));\n  assert.notSame(compositeSymbol(a, b, c), compositeSymbol(c, b, a));\n  assert.notSame(compositeSymbol(a, b, c), compositeSymbol(a, c, b));\n  assert.notSame(compositeSymbol(a, b, c, 1), compositeSymbol(a, b, c));\n  assert.same(compositeSymbol(a, b, c, 1), compositeSymbol(a, b, c, 1));\n  assert.same(compositeSymbol(1, a), compositeSymbol(1, a));\n  assert.notSame(compositeSymbol(1, a), compositeSymbol(a, 1));\n  assert.same(compositeSymbol(1, a, 2, b), compositeSymbol(1, a, 2, b));\n  assert.notSame(compositeSymbol(1, a, 2, b), compositeSymbol(1, a, b, 2));\n  assert.same(compositeSymbol(1, 2, a, b), compositeSymbol(1, 2, a, b));\n  assert.notSame(compositeSymbol(1, 2, a, b), compositeSymbol(1, a, b, 2));\n  assert.same(compositeSymbol(a, a), compositeSymbol(a, a));\n  assert.notSame(compositeSymbol(a, a), compositeSymbol(a, ['a']));\n  assert.notSame(compositeSymbol(a, a), compositeSymbol(a, b));\n  assert.same(compositeSymbol(), compositeSymbol());\n  assert.same(compositeSymbol(1, 2), compositeSymbol(1, 2));\n  assert.notSame(compositeSymbol(1, 2), compositeSymbol(2, 1));\n  assert.same(compositeSymbol('foo', null, true), compositeSymbol('foo', null, true));\n  assert.same(compositeSymbol('string'), Symbol.for('string'));\n});","file":"tests/esnext.composite-symbol.js","skipped":false,"dir":"tests"},{"name":"Function.isCallable","suites":[],"line":2,"code":"QUnit.test('Function.isCallable', assert => {\n  const {\n    isCallable\n  } = Function;\n  assert.isFunction(isCallable);\n  assert.arity(isCallable, 1);\n  assert.name(isCallable, 'isCallable');\n  assert.looksNative(isCallable);\n  assert.nonEnumerable(Function, 'isCallable');\n  assert.false(isCallable({}), 'object');\n  assert.false(isCallable(function () {\n    return arguments;\n  }()), 'arguments');\n  assert.false(isCallable([]), 'array');\n  assert.false(isCallable(/./), 'regex');\n  assert.false(isCallable(1), 'number');\n  assert.false(isCallable(true), 'boolean');\n  assert.false(isCallable('1'), 'string');\n  assert.false(isCallable(null), 'null');\n  assert.false(isCallable(), 'undefined');\n  assert.true(isCallable(Function.call), 'native function'); // eslint-disable-next-line prefer-arrow-callback -- required\n\n  assert.true(isCallable(function () {\n    /* empty */\n  }), 'function');\n  const arrow = fromSource('it => it');\n  if (arrow) assert.true(isCallable(arrow), 'arrow');\n  const klass = fromSource('class {}'); // Safari 9 and Edge 13- bugs\n\n  if (klass && !/constructor|function/.test(klass)) assert.false(isCallable(klass), 'class');\n  const gen = fromSource('function * () {}');\n  if (gen) assert.true(isCallable(gen), 'gen');\n  const asyncFunc = fromSource('async function () {}');\n  if (asyncFunc) assert.true(isCallable(asyncFunc), 'asyncFunc');\n  const asyncGen = fromSource('async * function () {}');\n  if (asyncGen) assert.true(isCallable(asyncGen), 'asyncGen');\n  const method = fromSource('({f(){}}).f'); // Safari 9 bug\n\n  if (method && !/function/.test(method)) assert.true(isCallable(method), 'method');\n});","file":"tests/esnext.function.is-callable.js","skipped":false,"dir":"tests"},{"name":"Function.isConstructor","suites":[],"line":2,"code":"QUnit.test('Function.isConstructor', assert => {\n  const {\n    isConstructor\n  } = Function;\n  assert.isFunction(isConstructor);\n  assert.arity(isConstructor, 1);\n  assert.name(isConstructor, 'isConstructor');\n  assert.looksNative(isConstructor);\n  assert.nonEnumerable(Function, 'isConstructor');\n  assert.false(isConstructor({}), 'object');\n  assert.false(isConstructor(function () {\n    return arguments;\n  }()), 'arguments');\n  assert.false(isConstructor([]), 'array');\n  assert.false(isConstructor(/./), 'regex');\n  assert.false(isConstructor(1), 'number');\n  assert.false(isConstructor(true), 'boolean');\n  assert.false(isConstructor('1'), 'string');\n  assert.false(isConstructor(null), 'null');\n  assert.false(isConstructor(), 'undefined'); // assert.false(isConstructor(Function.call), 'native function'); // fails in some old engines\n  // eslint-disable-next-line prefer-arrow-callback -- required\n\n  assert.true(isConstructor(function () {\n    /* empty */\n  }), 'function');\n  const arrow = fromSource('it => it');\n  if (arrow) assert.false(isConstructor(arrow), 'arrow');\n  const klass = fromSource('class {}'); // Safari 9 and Edge 13- bugs\n\n  if (klass && !/constructor|function/.test(klass)) assert.true(isConstructor(klass), 'class');\n  const Gen = fromSource('function * () {}'); // V8 ~ Chrome 49- bug\n\n  if (Gen) try {\n    new Gen();\n  } catch (error) {\n    assert.false(isConstructor(Gen), 'gen');\n  }\n  const asyncFunc = fromSource('async function () {}');\n  if (asyncFunc) assert.false(isConstructor(asyncFunc), 'asyncFunc');\n  const asyncGen = fromSource('async * function () {}');\n  if (asyncGen) assert.false(isConstructor(asyncGen), 'asyncGen');\n  const method = fromSource('({f(){}}).f'); // Safari 9 bug\n\n  if (method && !/function/.test(method)) assert.false(isConstructor(method), 'method');\n});","file":"tests/esnext.function.is-constructor.js","skipped":false,"dir":"tests"},{"name":"Function#unThis","suites":[],"line":1,"code":"QUnit.test('Function#unThis', assert => {\n  const {\n    unThis\n  } = Function.prototype;\n  assert.isFunction(unThis);\n  assert.arity(unThis, 0);\n  assert.name(unThis, 'unThis');\n  assert.looksNative(unThis);\n  assert.nonEnumerable(Function.prototype, 'unThis');\n  assert.same(function () {\n    return 42;\n  }.unThis()(), 42);\n  assert.deepEqual(Array.prototype.slice.unThis()([1, 2, 3], 1), [2, 3]);\n});","file":"tests/esnext.function.un-this.js","skipped":false,"dir":"tests"},{"name":"Iterator#asIndexedPairs","suites":[],"line":2,"code":"QUnit.test('Iterator#asIndexedPairs', assert => {\n  const {\n    asIndexedPairs\n  } = Iterator.prototype;\n  assert.isFunction(asIndexedPairs);\n  assert.arity(asIndexedPairs, 0);\n  assert.name(asIndexedPairs, 'asIndexedPairs');\n  assert.looksNative(asIndexedPairs);\n  assert.nonEnumerable(Iterator.prototype, 'asIndexedPairs');\n  assert.arrayEqual(asIndexedPairs.call(createIterator(['a', 'b', 'c'])).toArray().toString(), '0,a,1,b,2,c', 'basic functionality');\n  assert.throws(() => asIndexedPairs.call(undefined, TypeError));\n  assert.throws(() => asIndexedPairs.call(null, TypeError));\n  assert.throws(() => asIndexedPairs.call({}, TypeError));\n  assert.throws(() => asIndexedPairs.call([], TypeError));\n});","file":"tests/esnext.iterator.as-indexed-pairs.js","skipped":false,"dir":"tests"},{"name":"Iterator","suites":[],"line":5,"code":"QUnit.test('Iterator', assert => {\n  assert.isFunction(Iterator);\n  assert.arity(Iterator, 0);\n  assert.name(Iterator, 'Iterator');\n  assert.looksNative(Iterator);\n\n  const generator = (() => {\n    try {\n      return Function('return function*(){}()')();\n    } catch {\n      /* empty */\n    }\n  })();\n\n  if (generator) {\n    const proto = getPrototypeOf(getPrototypeOf(getPrototypeOf(generator)));\n\n    if (proto !== Object.prototype && proto !== null) {\n      assert.true(generator instanceof Iterator, 'Generator');\n    }\n  }\n\n  assert.true(''[Symbol.iterator]() instanceof Iterator, 'String Iterator');\n  assert.true([].values() instanceof Iterator, 'Array Iterator');\n  assert.true(new Set().values() instanceof Iterator, 'Set Iterator');\n  assert.true('abc'.matchAll(/./g) instanceof Iterator, 'MatchAll Iterator');\n  assert.true(Iterator.from(createIterator([1, 2, 3])) instanceof Iterator, 'From Proxy');\n  assert.true([].values().drop(1) instanceof Iterator, 'Drop Proxy');\n  assert.true(new Iterator() instanceof Iterator, 'constructor');\n  assert.throws(() => Iterator(), 'throws w/o `new`');\n});","file":"tests/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#constructor","suites":[],"line":36,"code":"QUnit.test('Iterator#constructor', assert => {\n  assert.same(Iterator.prototype.constructor, Iterator, 'Iterator#constructor is Iterator');\n});","file":"tests/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#@@toStringTag","suites":[],"line":39,"code":"QUnit.test('Iterator#@@toStringTag', assert => {\n  assert.same(Iterator.prototype[Symbol.toStringTag], 'Iterator', 'Iterator::@@toStringTag is `Iterator`');\n  assert.same(String(Iterator.from({\n    next: () => ({\n      done: Math.random() > 0.9,\n      value: Math.random() * 10 | 0\n    })\n  })), '[object Iterator]', 'correct stringification');\n});","file":"tests/esnext.iterator.constructor.js","skipped":false,"dir":"tests"},{"name":"Iterator#drop","suites":[],"line":2,"code":"QUnit.test('Iterator#drop', assert => {\n  const {\n    drop\n  } = Iterator.prototype;\n  assert.isFunction(drop);\n  assert.arity(drop, 1);\n  assert.name(drop, 'drop');\n  assert.looksNative(drop);\n  assert.nonEnumerable(Iterator.prototype, 'drop');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 1).toArray(), [2, 3], 'basic functionality');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 1.5).toArray(), [2, 3], 'float');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 4).toArray(), [], 'big');\n  assert.arrayEqual(drop.call(createIterator([1, 2, 3]), 0).toArray(), [1, 2, 3], 'zero');\n  assert.throws(() => drop.call(undefined, 1), TypeError);\n  assert.throws(() => drop.call(null, 1), TypeError);\n  assert.throws(() => drop.call({}, 1), TypeError);\n  assert.throws(() => drop.call([], 1), TypeError);\n  assert.throws(() => drop.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"tests/esnext.iterator.drop.js","skipped":false,"dir":"tests"},{"name":"Iterator#every","suites":[],"line":3,"code":"QUnit.test('Iterator#every', assert => {\n  const {\n    every\n  } = Iterator.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.looksNative(every);\n  assert.nonEnumerable(Iterator.prototype, 'every');\n  assert.true(every.call(createIterator([1, 2, 3]), it => typeof it == 'number'), 'basic functionality #1');\n  assert.false(every.call(createIterator([1, 2, 3]), it => it % 2), 'basic functionality #2');\n  every.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => every.call(createIterator([1]), null), TypeError);\n  assert.throws(() => every.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.every.js","skipped":false,"dir":"tests"},{"name":"Iterator#filter","suites":[],"line":3,"code":"QUnit.test('Iterator#filter', assert => {\n  const {\n    filter\n  } = Iterator.prototype;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.looksNative(filter);\n  assert.nonEnumerable(Iterator.prototype, 'filter');\n  assert.arrayEqual(filter.call(createIterator([1, 2, 3]), it => it % 2).toArray(), [1, 3], 'basic functionality');\n  filter.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), null), TypeError);\n  assert.throws(() => filter.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.filter.js","skipped":false,"dir":"tests"},{"name":"Iterator#find","suites":[],"line":3,"code":"QUnit.test('Iterator#find', assert => {\n  const {\n    find\n  } = Iterator.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.looksNative(find);\n  assert.nonEnumerable(Iterator.prototype, 'find');\n  assert.same(find.call(createIterator([1, 2, 3]), it => !(it % 2)), 2, 'basic functionality');\n  find.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => find.call(createIterator([1]), null), TypeError);\n  assert.throws(() => find.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.find.js","skipped":false,"dir":"tests"},{"name":"Iterator#flatMap","suites":[],"line":3,"code":"QUnit.test('Iterator#flatMap', assert => {\n  const {\n    flatMap\n  } = Iterator.prototype;\n  assert.isFunction(flatMap);\n  assert.arity(flatMap, 1);\n  assert.name(flatMap, 'flatMap');\n  assert.looksNative(flatMap);\n  assert.nonEnumerable(Iterator.prototype, 'flatMap');\n  assert.arrayEqual(flatMap.call(createIterator([1, [], 2, createIterable([3, 4]), [5, 6], 'ab']), it => typeof it == 'number' ? [-it] : it).toArray(), [-1, -2, 3, 4, 5, 6, 'a', 'b'], 'basic functionality');\n  flatMap.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n    return [arg];\n  }).toArray();\n  assert.throws(() => flatMap.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), it => it).next(), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), null), TypeError);\n  assert.throws(() => flatMap.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.flat-map.js","skipped":false,"dir":"tests"},{"name":"Iterator#forEach","suites":[],"line":3,"code":"QUnit.test('Iterator#forEach', assert => {\n  const {\n    forEach\n  } = Iterator.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.name(forEach, 'forEach');\n  assert.looksNative(forEach);\n  assert.nonEnumerable(Iterator.prototype, 'forEach');\n  const array = [];\n  forEach.call(createIterator([1, 2, 3]), it => array.push(it));\n  assert.arrayEqual(array, [1, 2, 3], 'basic functionality');\n  forEach.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => forEach.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), null), TypeError);\n  assert.throws(() => forEach.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.for-each.js","skipped":false,"dir":"tests"},{"name":"Iterator.from","suites":[],"line":2,"code":"QUnit.test('Iterator.from', assert => {\n  const {\n    from\n  } = Iterator;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(Iterator, 'from');\n  assert.true(Iterator.from(createIterator([1, 2, 3])) instanceof Iterator, 'proxy, iterator');\n  assert.true(Iterator.from(createIterable([1, 2, 3])) instanceof Iterator, 'proxy, iterable');\n  assert.arrayEqual(Iterator.from(createIterable([1, 2, 3])).toArray(), [1, 2, 3], 'just a proxy');\n  assert.throws(() => from(undefined), TypeError);\n  assert.throws(() => from(null), TypeError);\n  assert.throws(() => from({}), TypeError);\n});","file":"tests/esnext.iterator.from.js","skipped":false,"dir":"tests"},{"name":"Iterator#map","suites":[],"line":3,"code":"QUnit.test('Iterator#map', assert => {\n  const {\n    map\n  } = Iterator.prototype;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.name(map, 'map');\n  assert.looksNative(map);\n  assert.nonEnumerable(Iterator.prototype, 'map');\n  assert.arrayEqual(map.call(createIterator([1, 2, 3]), it => it ** 2).toArray(), [1, 4, 9], 'basic functionality');\n  map.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  }).toArray();\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => map.call(createIterator([1]), null), TypeError);\n  assert.throws(() => map.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.map.js","skipped":false,"dir":"tests"},{"name":"Iterator#reduce","suites":[],"line":3,"code":"QUnit.test('Iterator#reduce', assert => {\n  const {\n    reduce\n  } = Iterator.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.looksNative(reduce);\n  assert.nonEnumerable(Iterator.prototype, 'reduce');\n  assert.same(reduce.call(createIterator([1, 2, 3]), (a, b) => a + b, 1), 7, 'basic functionality');\n  assert.same(reduce.call(createIterator([1, 2, 3]), (a, b) => a + b), 6, 'basic functionality, no init');\n  reduce.call(createIterator([2]), function (a, b) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 2, 'arguments length');\n    assert.same(a, 1, 'argument 1');\n    assert.same(b, 2, 'argument 2');\n  }, 1);\n  assert.throws(() => reduce.call(undefined, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call(null, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call({}, (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call([], (a, b) => a + b, 0), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), undefined, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), null, 1), TypeError);\n  assert.throws(() => reduce.call(createIterator([1]), {}, 1), TypeError);\n});","file":"tests/esnext.iterator.reduce.js","skipped":false,"dir":"tests"},{"name":"Iterator#some","suites":[],"line":3,"code":"QUnit.test('Iterator#some', assert => {\n  const {\n    some\n  } = Iterator.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.looksNative(some);\n  assert.nonEnumerable(Iterator.prototype, 'some');\n  assert.true(some.call(createIterator([1, 2, 3]), it => it % 2), 'basic functionality #1');\n  assert.false(some.call(createIterator([1, 2, 3]), it => typeof it == 'string'), 'basic functionality #2');\n  some.call(createIterator([1]), function (arg) {\n    assert.same(this, STRICT_THIS, 'this');\n    assert.same(arguments.length, 1, 'arguments length');\n    assert.same(arg, 1, 'argument');\n  });\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(createIterator([1]), undefined), TypeError);\n  assert.throws(() => some.call(createIterator([1]), null), TypeError);\n  assert.throws(() => some.call(createIterator([1]), {}), TypeError);\n});","file":"tests/esnext.iterator.some.js","skipped":false,"dir":"tests"},{"name":"Iterator#take","suites":[],"line":2,"code":"QUnit.test('Iterator#take', assert => {\n  const {\n    take\n  } = Iterator.prototype;\n  assert.isFunction(take);\n  assert.arity(take, 1);\n  assert.name(take, 'take');\n  assert.looksNative(take);\n  assert.nonEnumerable(Iterator.prototype, 'take');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 2).toArray(), [1, 2], 'basic functionality');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 1.5).toArray(), [1], 'float');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 4).toArray(), [1, 2, 3], 'big');\n  assert.arrayEqual(take.call(createIterator([1, 2, 3]), 0).toArray(), [], 'zero');\n  assert.throws(() => take.call(undefined, 1), TypeError);\n  assert.throws(() => take.call(null, 1), TypeError);\n  assert.throws(() => take.call({}, 1), TypeError);\n  assert.throws(() => take.call([], 1), TypeError);\n  assert.throws(() => take.call(createIterator([1, 2, 3]), -1), RangeError, 'negative');\n});","file":"tests/esnext.iterator.take.js","skipped":false,"dir":"tests"},{"name":"Iterator#toArray","suites":[],"line":2,"code":"QUnit.test('Iterator#toArray', assert => {\n  const {\n    toArray\n  } = Iterator.prototype;\n  assert.isFunction(toArray);\n  assert.arity(toArray, 0);\n  assert.name(toArray, 'toArray');\n  assert.looksNative(toArray);\n  assert.nonEnumerable(Iterator.prototype, 'toArray');\n  assert.arrayEqual([1, 2, 3].values().toArray(), [1, 2, 3]);\n  assert.arrayEqual(new Set([1, 2, 3]).values().toArray(), [1, 2, 3]);\n  assert.arrayEqual(Iterator.from('123').toArray(), ['1', '2', '3']);\n  assert.arrayEqual(Iterator.from(createIterable([1, 2, 3])).toArray(), [1, 2, 3]);\n  assert.arrayEqual(toArray.call(createIterator([1, 2, 3])), [1, 2, 3]);\n  assert.throws(() => toArray.call(undefined), TypeError);\n  assert.throws(() => toArray.call(null), TypeError);\n  assert.throws(() => toArray.call({}), TypeError);\n  assert.throws(() => toArray.call([]), TypeError);\n});","file":"tests/esnext.iterator.to-array.js","skipped":false,"dir":"tests"},{"name":"Iterator#toAsync","suites":[],"line":2,"code":"QUnit.test('Iterator#toAsync', assert => {\n  assert.expect(STRICT ? 9 : 7);\n  const async = assert.async();\n  const {\n    toAsync\n  } = Iterator.prototype;\n  assert.isFunction(toAsync);\n  assert.arity(toAsync, 0);\n  assert.name(toAsync, 'toAsync');\n  assert.looksNative(toAsync);\n  assert.nonEnumerable(Iterator.prototype, 'toAsync');\n\n  if (STRICT) {\n    assert.throws(() => toAsync.call(undefined), TypeError);\n    assert.throws(() => toAsync.call(null), TypeError);\n  }\n\n  [1, 2, 3].values().toAsync().map(it => Promise.resolve(it)).toArray().then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n  }).then(() => {\n    return new Set([1, 2, 3]).values().toAsync().map(it => Promise.resolve(it)).toArray();\n  }).then(it => {\n    assert.arrayEqual(it, [1, 2, 3]);\n    async();\n  });\n});","file":"tests/esnext.iterator.to-async.js","skipped":false,"dir":"tests"},{"name":"Map#deleteAll","suites":[],"line":1,"code":"QUnit.test('Map#deleteAll', assert => {\n  const {\n    deleteAll\n  } = Map.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.looksNative(deleteAll);\n  assert.nonEnumerable(Map.prototype, 'deleteAll');\n  let set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.true(set.deleteAll(1, 2));\n  assert.deepEqual(from(set), [[3, 4]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.false(set.deleteAll(3, 4));\n  assert.deepEqual(from(set), [[1, 2], [2, 3]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.false(set.deleteAll(4, 5));\n  assert.deepEqual(from(set), [[1, 2], [2, 3], [3, 4]]);\n  set = new Map([[1, 2], [2, 3], [3, 4]]);\n  assert.true(set.deleteAll());\n  assert.deepEqual(from(set), [[1, 2], [2, 3], [3, 4]]);\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => deleteAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(null, 1, 2, 3), TypeError);\n});","file":"tests/esnext.map.delete-all.js","skipped":false,"dir":"tests"},{"name":"Map#emplace","suites":[],"line":1,"code":"QUnit.test('Map#emplace', assert => {\n  const {\n    emplace\n  } = Map.prototype;\n  assert.isFunction(emplace);\n  assert.arity(emplace, 2);\n  assert.name(emplace, 'emplace');\n  assert.looksNative(emplace);\n  assert.nonEnumerable(Map.prototype, 'emplace');\n  const map = new Map([['a', 2]]);\n  let handler = {\n    update(value, key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 2, 'correct value in callback');\n      assert.same(key, 'a', 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return value ** 2;\n    },\n\n    insert() {\n      assert.avoid();\n    }\n\n  };\n  assert.same(map.emplace('a', handler), 4, 'returns a correct value');\n  handler = {\n    update() {\n      assert.avoid();\n    },\n\n    insert(key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 2, 'correct number of callback arguments');\n      assert.same(key, 'b', 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return 3;\n    }\n\n  };\n  assert.same(map.emplace('b', handler), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).emplace('b', {\n    insert: () => 3\n  }), 3);\n  assert.same(new Map([['a', 2]]).emplace('a', {\n    update: value => value ** 2\n  }), 4);\n  handler = {\n    update() {\n      /* empty */\n    },\n\n    insert() {\n      /* empty */\n    }\n\n  };\n  assert.throws(() => new Map().emplace('a'), TypeError);\n  assert.throws(() => emplace.call({}, 'a', handler), TypeError);\n  assert.throws(() => emplace.call([], 'a', handler), TypeError);\n  assert.throws(() => emplace.call(undefined, 'a', handler), TypeError);\n  assert.throws(() => emplace.call(null, 'a', handler), TypeError);\n});","file":"tests/esnext.map.emplace.js","skipped":false,"dir":"tests"},{"name":"Map#every","suites":[],"line":1,"code":"QUnit.test('Map#every', assert => {\n  const {\n    every\n  } = Map.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.looksNative(every);\n  assert.nonEnumerable(Map.prototype, 'every');\n  let map = new Map([[9, 1]]);\n  const context = {};\n  map.every(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 9, 'correct index in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  map = new Map([[0, 1], [1, 2], [2, 3]]);\n  assert.true(map.every(it => typeof it == 'number'));\n  assert.true(map.every(it => it < 4));\n  assert.false(map.every(it => it < 3));\n  assert.false(map.every(it => typeof it == 'string'));\n  assert.true(map.every(function () {\n    return +this === 1;\n  }, 1));\n  let result = '';\n  map.every((value, key) => result += key);\n  assert.same(result, '012');\n  assert.true(map.every((value, key, that) => that === map));\n  assert.throws(() => every.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.every.js","skipped":false,"dir":"tests"},{"name":"Map#filter","suites":[],"line":1,"code":"QUnit.test('Map#filter', assert => {\n  const {\n    filter\n  } = Map.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.looksNative(filter);\n  assert.nonEnumerable(Map.prototype, 'filter');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.filter(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Map().filter(it => it) instanceof Map);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).filter(it => typeof it == 'number')), [['a', 1], [1, 2], ['b', 3], [3, 4], [4, 5]]);\n  assert.throws(() => filter.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.filter.js","skipped":false,"dir":"tests"},{"name":"Map#findKey","suites":[],"line":1,"code":"QUnit.test('Map#findKey', assert => {\n  const {\n    findKey\n  } = Map.prototype;\n  assert.isFunction(findKey);\n  assert.arity(findKey, 1);\n  assert.name(findKey, 'findKey');\n  assert.looksNative(findKey);\n  assert.nonEnumerable(Map.prototype, 'findKey');\n  const set = new Map([[1, 2]]);\n  const context = {};\n  set.findKey(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Map([[1, 2], [2, 3], [3, 4]]).findKey(it => it % 2), 2);\n  assert.same(new Map().findKey(it => it === 42), undefined);\n  assert.throws(() => findKey.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => findKey.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.find-key.js","skipped":false,"dir":"tests"},{"name":"Map#find","suites":[],"line":1,"code":"QUnit.test('Map#find', assert => {\n  const {\n    find\n  } = Map.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.looksNative(find);\n  assert.nonEnumerable(Map.prototype, 'find');\n  const set = new Map([[1, 2]]);\n  const context = {};\n  set.find(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Map([[1, 2], [2, 3], [3, 4]]).find(it => it % 2), 3);\n  assert.same(new Map().find(it => it === 42), undefined);\n  assert.throws(() => find.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.find.js","skipped":false,"dir":"tests"},{"name":"Map.from","suites":[],"line":2,"code":"QUnit.test('Map.from', assert => {\n  const {\n    from\n  } = Map;\n  const toArray = Array.from;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(Map, 'from');\n  assert.true(Map.from() instanceof Map);\n  assert.deepEqual(toArray(Map.from([])), []);\n  assert.deepEqual(toArray(Map.from([[1, 2]])), [[1, 2]]);\n  assert.deepEqual(toArray(Map.from([[1, 2], [2, 3], [1, 4]])), [[1, 4], [2, 3]]);\n  assert.deepEqual(toArray(Map.from(createIterable([[1, 2], [2, 3], [1, 4]]))), [[1, 4], [2, 3]]);\n  const pair = [1, 2];\n  const context = {};\n  Map.from([pair], function (element, index) {\n    assert.same(element, pair);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from([1, 2]));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"tests/esnext.map.from.js","skipped":false,"dir":"tests"},{"name":"Map.groupBy","suites":[],"line":2,"code":"QUnit.test('Map.groupBy', assert => {\n  const {\n    groupBy\n  } = Map;\n  const toArray = Array.from;\n  assert.isFunction(groupBy);\n  assert.arity(groupBy, 2);\n  assert.name(groupBy, 'groupBy');\n  assert.looksNative(groupBy);\n  assert.nonEnumerable(Map, 'groupBy');\n  assert.true(Map.groupBy([], it => it) instanceof Map);\n  assert.deepEqual(toArray(Map.groupBy([], it => it)), []);\n  assert.deepEqual(toArray(Map.groupBy([1, 2], it => it ** 2)), [[1, [1]], [4, [2]]]);\n  assert.deepEqual(toArray(Map.groupBy([1, 2, 1], it => it ** 2)), [[1, [1, 1]], [4, [2]]]);\n  assert.deepEqual(toArray(Map.groupBy(createIterable([1, 2]), it => it ** 2)), [[1, [1]], [4, [2]]]);\n  const element = {};\n  Map.groupBy([element], it => assert.same(it, element));\n  assert.throws(() => groupBy([1, 2], it => it));\n});","file":"tests/esnext.map.group-by.js","skipped":false,"dir":"tests"},{"name":"Map#includes","suites":[],"line":1,"code":"QUnit.test('Map#includes', assert => {\n  const {\n    includes\n  } = Map.prototype;\n  assert.isFunction(includes);\n  assert.name(includes, 'includes');\n  assert.arity(includes, 1);\n  assert.looksNative(includes);\n  assert.nonEnumerable(Map.prototype, 'includes');\n  const object = {};\n  const map = new Map([[1, 1], [2, 2], [3, 3], [4, -0], [5, object], [6, NaN]]);\n  assert.true(map.includes(1));\n  assert.true(map.includes(-0));\n  assert.true(map.includes(0));\n  assert.true(map.includes(object));\n  assert.false(map.includes(4));\n  assert.false(map.includes(-0.5));\n  assert.false(map.includes({}));\n  assert.true(map.includes(NaN));\n  assert.throws(() => includes.call(new Set(), 1), TypeError);\n  assert.throws(() => includes.call({}, 1), TypeError);\n  assert.throws(() => includes.call([], 1), TypeError);\n  assert.throws(() => includes.call(undefined, 1), TypeError);\n  assert.throws(() => includes.call(null, 1), TypeError);\n});","file":"tests/esnext.map.includes.js","skipped":false,"dir":"tests"},{"name":"Map.keyBy","suites":[],"line":2,"code":"QUnit.test('Map.keyBy', assert => {\n  const {\n    keyBy\n  } = Map;\n  const toArray = Array.from;\n  assert.isFunction(keyBy);\n  assert.arity(keyBy, 2);\n  assert.name(keyBy, 'keyBy');\n  assert.looksNative(keyBy);\n  assert.nonEnumerable(Map, 'keyBy');\n  assert.true(Map.keyBy([], it => it) instanceof Map);\n  assert.deepEqual(toArray(Map.keyBy([], it => it)), []);\n  assert.deepEqual(toArray(Map.keyBy([1, 2], it => it ** 2)), [[1, 1], [4, 2]]);\n  assert.deepEqual(toArray(Map.keyBy([1, 2, 1], it => it ** 2)), [[1, 1], [4, 2]]);\n  assert.deepEqual(toArray(Map.keyBy(createIterable([1, 2]), it => it ** 2)), [[1, 1], [4, 2]]);\n  const element = {};\n  Map.keyBy([element], it => assert.same(it, element));\n  assert.throws(() => keyBy([1, 2], it => it));\n});","file":"tests/esnext.map.key-by.js","skipped":false,"dir":"tests"},{"name":"Map#keyOf","suites":[],"line":1,"code":"QUnit.test('Map#keyOf', assert => {\n  const {\n    keyOf\n  } = Map.prototype;\n  assert.isFunction(keyOf);\n  assert.name(keyOf, 'keyOf');\n  assert.arity(keyOf, 1);\n  assert.looksNative(keyOf);\n  assert.nonEnumerable(Map.prototype, 'keyOf');\n  const object = {};\n  const map = new Map([[1, 1], [2, 2], [3, 3], [4, -0], [5, object], [6, NaN]]);\n  assert.same(map.keyOf(1), 1);\n  assert.same(map.keyOf(-0), 4);\n  assert.same(map.keyOf(0), 4);\n  assert.same(map.keyOf(object), 5);\n  assert.same(map.keyOf(4), undefined);\n  assert.same(map.keyOf(-0.5), undefined);\n  assert.same(map.keyOf({}), undefined);\n  assert.same(map.keyOf(NaN), undefined);\n  assert.throws(() => keyOf.call(new Set(), 1), TypeError);\n  assert.throws(() => keyOf.call({}, 1), TypeError);\n  assert.throws(() => keyOf.call([], 1), TypeError);\n  assert.throws(() => keyOf.call(undefined, 1), TypeError);\n  assert.throws(() => keyOf.call(null, 1), TypeError);\n});","file":"tests/esnext.map.key-of.js","skipped":false,"dir":"tests"},{"name":"Map#mapKeys","suites":[],"line":1,"code":"QUnit.test('Map#mapKeys', assert => {\n  const {\n    mapKeys\n  } = Map.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(mapKeys);\n  assert.arity(mapKeys, 1);\n  assert.name(mapKeys, 'mapKeys');\n  assert.looksNative(mapKeys);\n  assert.nonEnumerable(Map.prototype, 'mapKeys');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.mapKeys(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Map().mapKeys(it => it) instanceof Map);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).mapKeys((value, key) => `${key}${value}`)), [['a1', 1], ['12', 2], ['b3', 3], ['2q', 'q'], ['c[object Object]', {}], ['34', 4], ['dtrue', true], ['45', 5]]);\n  assert.throws(() => mapKeys.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapKeys.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.map-keys.js","skipped":false,"dir":"tests"},{"name":"Map#mapValues","suites":[],"line":1,"code":"QUnit.test('Map#mapValues', assert => {\n  const {\n    mapValues\n  } = Map.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(mapValues);\n  assert.arity(mapValues, 1);\n  assert.name(mapValues, 'mapValues');\n  assert.looksNative(mapValues);\n  assert.nonEnumerable(Map.prototype, 'mapValues');\n  const map = new Map([[1, 2]]);\n  const context = {};\n  map.mapValues(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Map().mapValues(it => it) instanceof Map);\n  assert.deepEqual(from(new Map([['a', 1], [1, 2], ['b', 3], [2, 'q'], ['c', {}], [3, 4], ['d', true], [4, 5]]).mapValues((value, key) => `${key}${value}`)), [['a', 'a1'], [1, '12'], ['b', 'b3'], [2, '2q'], ['c', 'c[object Object]'], [3, '34'], ['d', 'dtrue'], [4, '45']]);\n  assert.throws(() => mapValues.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => mapValues.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.map-values.js","skipped":false,"dir":"tests"},{"name":"Map#merge","suites":[],"line":1,"code":"QUnit.test('Map#merge', assert => {\n  const {\n    merge\n  } = Map.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(merge);\n  assert.arity(merge, 1);\n  assert.name(merge, 'merge');\n  assert.looksNative(merge);\n  assert.nonEnumerable(Map.prototype, 'merge');\n  const map = new Map([[1, 2]]);\n  const result = map.merge([[3, 4]]);\n  assert.same(result, map);\n  assert.true(result instanceof Map);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[5, 6]])), [[1, 2], [3, 4], [5, 6]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[3, 5], [5, 6]])), [[1, 2], [3, 5], [5, 6]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([])), [[1, 2], [3, 4]]);\n  assert.deepEqual(from(new Map([[1, 2], [3, 4]]).merge([[3, 5]], [[5, 6]])), [[1, 2], [3, 5], [5, 6]]);\n  assert.throws(() => merge.call({}, [[1, 2]]), TypeError);\n  assert.throws(() => merge.call(undefined, [[1, 2]]), TypeError);\n  assert.throws(() => merge.call(null, [[1, 2]]), TypeError);\n});","file":"tests/esnext.map.merge.js","skipped":false,"dir":"tests"},{"name":"Map.of","suites":[],"line":1,"code":"QUnit.test('Map.of', assert => {\n  const {\n    of\n  } = Map;\n  const toArray = Array.from;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.name(of, 'of');\n  assert.looksNative(of);\n  assert.nonEnumerable(Map, 'of');\n  assert.true(Map.of() instanceof Map);\n  assert.deepEqual(toArray(Map.of([1, 2])), [[1, 2]]);\n  assert.deepEqual(toArray(Map.of([1, 2], [2, 3], [1, 4])), [[1, 4], [2, 3]]);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"tests/esnext.map.of.js","skipped":false,"dir":"tests"},{"name":"Map#reduce","suites":[],"line":1,"code":"QUnit.test('Map#reduce', assert => {\n  const {\n    reduce\n  } = Map.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.looksNative(reduce);\n  assert.nonEnumerable(Map.prototype, 'reduce');\n  const set = new Map([['a', 1]]);\n  const accumulator = {};\n  set.reduce(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 'a', 'correct index in callback');\n    assert.same(that, set, 'correct link to set in callback');\n  }, accumulator);\n  assert.same(new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  new Map([['a', 1], ['b', 2]]).reduce((memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 'b', 'correct start index without initial accumulator');\n  });\n  assert.same(new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  new Map([['a', 1], ['b', 2], ['c', 3]]).reduce((memo, value, key, s) => {\n    s.delete('b');\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '13', 'correct order #1');\n  assert.same(keys, 'ac', 'correct order #2');\n  assert.throws(() => reduce.call(new Set(), () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call([], () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n});","file":"tests/esnext.map.reduce.js","skipped":false,"dir":"tests"},{"name":"Map#some","suites":[],"line":1,"code":"QUnit.test('Map#some', assert => {\n  const {\n    some\n  } = Map.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.looksNative(some);\n  assert.nonEnumerable(Map.prototype, 'some');\n  let map = new Map([[9, 1]]);\n  const context = {};\n  map.some(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 9, 'correct index in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  map = new Map([[0, 1], [1, '2'], [2, 3]]);\n  assert.true(map.some(it => typeof it == 'number'));\n  assert.true(map.some(it => it < 3));\n  assert.false(map.some(it => it < 0));\n  assert.true(map.some(it => typeof it == 'string'));\n  assert.false(map.some(function () {\n    return +this !== 1;\n  }, 1));\n  let result = '';\n  map.some((value, key) => {\n    result += key;\n    return false;\n  });\n  assert.same(result, '012');\n  assert.true(map.some((value, key, that) => that === map));\n  assert.throws(() => some.call(new Set(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.some.js","skipped":false,"dir":"tests"},{"name":"Map#updateOrInsert","suites":[],"line":1,"code":"QUnit.test('Map#updateOrInsert', assert => {\n  const {\n    updateOrInsert\n  } = Map.prototype;\n  assert.isFunction(updateOrInsert);\n  assert.arity(updateOrInsert, 2);\n  assert.looksNative(updateOrInsert);\n  assert.nonEnumerable(Map.prototype, 'updateOrInsert');\n  const map = new Map([['a', 2]]);\n  assert.same(map.updateOrInsert('a', function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.updateOrInsert('b', value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).updateOrInsert('b', null, () => 3), 3);\n  assert.same(new Map([['a', 2]]).updateOrInsert('a', value => value ** 2), 4);\n  assert.throws(() => new Map().updateOrInsert('a'), TypeError);\n  assert.throws(() => updateOrInsert.call({}, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call([], 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call(undefined, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => updateOrInsert.call(null, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.update-or-insert.js","skipped":false,"dir":"tests"},{"name":"Map#update","suites":[],"line":1,"code":"QUnit.test('Map#update', assert => {\n  const {\n    update\n  } = Map.prototype;\n  assert.isFunction(update);\n  assert.arity(update, 2);\n  assert.name(update, 'update');\n  assert.looksNative(update);\n  assert.nonEnumerable(Map.prototype, 'update');\n  let map = new Map([[9, 2]]);\n  assert.same(map.update(9, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 9, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    return value * 2;\n  }), map, 'returns this');\n  assert.same(map.size, 1, 'correct size');\n  assert.same(map.get(9), 4, 'correct result');\n  map = new Map([[4, 5]]);\n  map.update(9, function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    assert.same(key, 9, 'correct key in callback');\n    assert.same(that, map, 'correct link to map in callback');\n    return value * 2;\n  }, function (key, that) {\n    assert.same(arguments.length, 2, 'correct number of thunk arguments');\n    assert.same(key, 9, 'correct key in thunk');\n    assert.same(that, map, 'correct link to map in thunk');\n    return 2;\n  });\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get(4), 5, 'correct result #1');\n  assert.same(map.get(9), 4, 'correct result #2');\n  assert.throws(() => new Map([[9, 2]]).update(9), TypeError);\n  assert.throws(() => new Map().update(9, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => update.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.update.js","skipped":false,"dir":"tests"},{"name":"Map#upsert","suites":[],"line":1,"code":"QUnit.test('Map#upsert', assert => {\n  const {\n    upsert\n  } = Map.prototype;\n  assert.isFunction(upsert);\n  assert.arity(upsert, 2);\n  assert.looksNative(upsert);\n  assert.nonEnumerable(Map.prototype, 'upsert');\n  const map = new Map([['a', 2]]);\n  assert.same(map.upsert('a', function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.upsert('b', value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.size, 2, 'correct size');\n  assert.same(map.get('a'), 4, 'correct result #1');\n  assert.same(map.get('b'), 3, 'correct result #2');\n  assert.same(new Map([['a', 2]]).upsert('b', null, () => 3), 3);\n  assert.same(new Map([['a', 2]]).upsert('a', value => value ** 2), 4);\n  assert.throws(() => new Map().upsert('a'), TypeError);\n  assert.throws(() => upsert.call({}, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call([], 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(undefined, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(null, 'a', () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.map.upsert.js","skipped":false,"dir":"tests"},{"name":"Math.clamp","suites":[],"line":1,"code":"QUnit.test('Math.clamp', assert => {\n  const {\n    clamp\n  } = Math;\n  assert.isFunction(clamp);\n  assert.name(clamp, 'clamp');\n  assert.arity(clamp, 3);\n  assert.looksNative(clamp);\n  assert.nonEnumerable(Math, 'clamp');\n  assert.same(clamp(2, 4, 6), 4);\n  assert.same(clamp(4, 2, 6), 4);\n  assert.same(clamp(6, 2, 4), 4);\n});","file":"tests/esnext.math.clamp.js","skipped":false,"dir":"tests"},{"name":"Math.DEG_PER_RAD","suites":[],"line":1,"code":"QUnit.test('Math.DEG_PER_RAD', assert => {\n  const {\n    DEG_PER_RAD,\n    PI\n  } = Math;\n  assert.true('DEG_PER_RAD' in Math, 'DEG_PER_RAD in Math');\n  assert.nonEnumerable(Math, 'DEG_PER_RAD');\n  assert.same(DEG_PER_RAD, PI / 180, 'Is Math.PI / 180');\n});","file":"tests/esnext.math.deg-per-rad.js","skipped":false,"dir":"tests"},{"name":"Math.degrees","suites":[],"line":1,"code":"QUnit.test('Math.degrees', assert => {\n  const {\n    degrees,\n    PI\n  } = Math;\n  assert.isFunction(degrees);\n  assert.name(degrees, 'degrees');\n  assert.arity(degrees, 1);\n  assert.looksNative(degrees);\n  assert.nonEnumerable(Math, 'degrees');\n  assert.same(degrees(0), 0);\n  assert.same(degrees(PI / 2), 90);\n  assert.same(degrees(PI), 180);\n  assert.same(degrees(3 * PI / 2), 270);\n});","file":"tests/esnext.math.degrees.js","skipped":false,"dir":"tests"},{"name":"Math.fscale","suites":[],"line":1,"code":"QUnit.test('Math.fscale', assert => {\n  const {\n    fscale,\n    fround,\n    PI\n  } = Math;\n  assert.isFunction(fscale);\n  assert.name(fscale, 'fscale');\n  assert.arity(fscale, 5);\n  assert.looksNative(fscale);\n  assert.nonEnumerable(Math, 'fscale');\n  assert.same(fscale(3, 1, 2, 1, 2), 3);\n  assert.same(fscale(0, 3, 5, 8, 10), 5);\n  assert.same(fscale(1, 1, 1, 1, 1), NaN);\n  assert.same(fscale(-1, -1, -1, -1, -1), NaN);\n  assert.same(fscale(3, 1, 2, 1, PI), fround((3 - 1) * (PI - 1) / (2 - 1) + 1));\n});","file":"tests/esnext.math.fscale.js","skipped":false,"dir":"tests"},{"name":"Math.iaddh","suites":[],"line":1,"code":"QUnit.test('Math.iaddh', assert => {\n  const {\n    iaddh\n  } = Math;\n  assert.isFunction(iaddh);\n  assert.name(iaddh, 'iaddh');\n  assert.arity(iaddh, 4);\n  assert.looksNative(iaddh);\n  assert.nonEnumerable(Math, 'iaddh');\n  assert.same(iaddh(0, 2, 1, 0), 2);\n  assert.same(iaddh(0, 4, 1, 1), 5);\n  assert.same(iaddh(2, 4, 1, 1), 5);\n  assert.same(iaddh(0xFFFFFFFF, 4, 1, 1), 6);\n  assert.same(iaddh(1, 4, 0xFFFFFFFF, 1), 6);\n});","file":"tests/esnext.math.iaddh.js","skipped":false,"dir":"tests"},{"name":"Math.imulh","suites":[],"line":1,"code":"QUnit.test('Math.imulh', assert => {\n  const {\n    imulh\n  } = Math;\n  assert.isFunction(imulh);\n  assert.name(imulh, 'imulh');\n  assert.arity(imulh, 2);\n  assert.looksNative(imulh);\n  assert.nonEnumerable(Math, 'imulh');\n  assert.same(imulh(0xFFFFFFFF, 7), -1);\n  assert.same(imulh(0xFFFFFFF, 77), 4);\n  assert.same(imulh(1, 7), 0);\n  assert.same(imulh(-1, 7), -1);\n});","file":"tests/esnext.math.imulh.js","skipped":false,"dir":"tests"},{"name":"Math.isubh","suites":[],"line":1,"code":"QUnit.test('Math.isubh', assert => {\n  const {\n    isubh\n  } = Math;\n  assert.isFunction(isubh);\n  assert.name(isubh, 'isubh');\n  assert.arity(isubh, 4);\n  assert.looksNative(isubh);\n  assert.nonEnumerable(Math, 'isubh');\n  assert.same(isubh(0, 2, 1, 0), 1);\n  assert.same(isubh(0, 4, 1, 1), 2);\n  assert.same(isubh(2, 4, 1, 1), 3);\n  assert.same(isubh(0xFFFFFFFF, 4, 1, 1), 3);\n  assert.same(isubh(1, 4, 0xFFFFFFFF, 1), 2);\n});","file":"tests/esnext.math.isubh.js","skipped":false,"dir":"tests"},{"name":"Math.RAD_PER_DEG","suites":[],"line":1,"code":"QUnit.test('Math.RAD_PER_DEG', assert => {\n  const {\n    RAD_PER_DEG,\n    PI\n  } = Math;\n  assert.true('RAD_PER_DEG' in Math, 'RAD_PER_DEG in Math');\n  assert.nonEnumerable(Math, 'RAD_PER_DEG');\n  assert.same(RAD_PER_DEG, 180 / PI, 'Is 180 / Math.PI');\n});","file":"tests/esnext.math.rad-per-deg.js","skipped":false,"dir":"tests"},{"name":"Math.radians","suites":[],"line":1,"code":"QUnit.test('Math.radians', assert => {\n  const {\n    radians,\n    PI\n  } = Math;\n  assert.isFunction(radians);\n  assert.name(radians, 'radians');\n  assert.arity(radians, 1);\n  assert.looksNative(radians);\n  assert.nonEnumerable(Math, 'radians');\n  assert.same(radians(0), 0);\n  assert.same(radians(90), PI / 2);\n  assert.same(radians(180), PI);\n  assert.same(radians(270), 3 * PI / 2);\n});","file":"tests/esnext.math.radians.js","skipped":false,"dir":"tests"},{"name":"Math.scale","suites":[],"line":1,"code":"QUnit.test('Math.scale', assert => {\n  const {\n    scale\n  } = Math;\n  assert.isFunction(scale);\n  assert.name(scale, 'scale');\n  assert.arity(scale, 5);\n  assert.looksNative(scale);\n  assert.nonEnumerable(Math, 'scale');\n  assert.same(scale(3, 1, 2, 1, 2), 3);\n  assert.same(scale(0, 3, 5, 8, 10), 5);\n  assert.same(scale(1, 1, 1, 1, 1), NaN);\n  assert.same(scale(-1, -1, -1, -1, -1), NaN);\n});","file":"tests/esnext.math.scale.js","skipped":false,"dir":"tests"},{"name":"Math.seededPRNG","suites":[],"line":1,"code":"QUnit.test('Math.seededPRNG', assert => {\n  const {\n    seededPRNG\n  } = Math;\n  assert.isFunction(seededPRNG);\n  assert.name(seededPRNG, 'seededPRNG');\n  assert.arity(seededPRNG, 1);\n  assert.looksNative(seededPRNG);\n  assert.nonEnumerable(Math, 'seededPRNG');\n\n  for (const gen of [seededPRNG({\n    seed: 42\n  }), seededPRNG({\n    seed: 42\n  })]) {\n    assert.deepEqual(gen.next(), {\n      value: 0.16461519912315087,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.2203933906000046,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.8249682894209105,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.10750079537509083,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.004673248161257476,\n      done: false\n    });\n  }\n\n  for (const gen of [seededPRNG({\n    seed: 43\n  }), seededPRNG({\n    seed: 43\n  })]) {\n    assert.deepEqual(gen.next(), {\n      value: 0.1923438591811283,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.7896811578326683,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.9518230761883996,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.1414634102410296,\n      done: false\n    });\n    assert.deepEqual(gen.next(), {\n      value: 0.7379838030207752,\n      done: false\n    });\n  }\n\n  assert.throws(() => seededPRNG(), TypeError);\n  assert.throws(() => seededPRNG(5), TypeError);\n  assert.throws(() => seededPRNG({\n    seed: null\n  }), TypeError);\n});","file":"tests/esnext.math.seeded-prng.js","skipped":false,"dir":"tests"},{"name":"Math.signbit","suites":[],"line":1,"code":"QUnit.test('Math.signbit', assert => {\n  const {\n    signbit\n  } = Math;\n  assert.isFunction(signbit);\n  assert.name(signbit, 'signbit');\n  assert.arity(signbit, 1);\n  assert.looksNative(signbit);\n  assert.nonEnumerable(Math, 'signbit');\n  assert.false(signbit(NaN));\n  assert.false(signbit());\n  assert.true(signbit(-0));\n  assert.false(signbit(0));\n  assert.false(signbit(Infinity));\n  assert.true(signbit(-Infinity));\n  assert.false(signbit(13510798882111488));\n  assert.true(signbit(-13510798882111488));\n  assert.false(signbit(42.5));\n  assert.true(signbit(-42.5));\n});","file":"tests/esnext.math.signbit.js","skipped":false,"dir":"tests"},{"name":"Math.umulh","suites":[],"line":1,"code":"QUnit.test('Math.umulh', assert => {\n  const {\n    umulh\n  } = Math;\n  assert.isFunction(umulh);\n  assert.name(umulh, 'umulh');\n  assert.arity(umulh, 2);\n  assert.looksNative(umulh);\n  assert.nonEnumerable(Math, 'umulh');\n  assert.same(umulh(0xFFFFFFFF, 7), 6);\n  assert.same(umulh(0xFFFFFFF, 77), 4);\n  assert.same(umulh(1, 7), 0);\n  assert.same(umulh(-1, 7), 6);\n});","file":"tests/esnext.math.umulh.js","skipped":false,"dir":"tests"},{"name":"Number.fromString","suites":[],"line":1,"code":"QUnit.test('Number.fromString', assert => {\n  const {\n    fromString\n  } = Number;\n  assert.isFunction(fromString);\n  assert.name(fromString, 'fromString');\n  assert.arity(fromString, 2);\n  assert.looksNative(fromString);\n  assert.nonEnumerable(Number, 'fromString');\n  assert.throws(() => fromString(undefined), TypeError, 'The first argument should be a string #1');\n  assert.throws(() => fromString(Object('10')), TypeError, 'The first argument should be a string #1');\n  assert.throws(() => fromString(''), SyntaxError, 'Empty string');\n  assert.same(fromString('-10', 2), -2, 'Works with negative numbers');\n  assert.throws(() => fromString('-'), SyntaxError, '-');\n  assert.same(fromString('10'), 10, 'Default radix is 10 #1');\n  assert.same(fromString('10', undefined), 10, 'Default radix is 10 #2');\n\n  for (let radix = 2; radix <= 36; ++radix) {\n    assert.same(fromString('10', radix), radix, `Radix ${radix}`);\n  }\n\n  assert.throws(() => fromString('10', -4294967294), RangeError, 'Radix uses ToInteger #1');\n  assert.same(fromString('10', 2.5), 2, 'Radix uses ToInteger #2');\n  assert.same(fromString('42'), 42);\n  assert.same(fromString('42', 10), 42);\n  assert.throws(() => fromString('0xc0ffee'), SyntaxError);\n  assert.throws(() => fromString('0o755'), SyntaxError);\n  assert.throws(() => fromString('0b00101010'), SyntaxError);\n  assert.throws(() => fromString('C0FFEE', 16), SyntaxError);\n  assert.same(fromString('c0ffee', 16), 12648430);\n  assert.same(fromString('755', 8), 493);\n  assert.throws(() => fromString(''), SyntaxError);\n  assert.throws(() => fromString(' '), SyntaxError);\n  assert.throws(() => fromString(' 1'), SyntaxError);\n  assert.throws(() => fromString(' \\n '), SyntaxError);\n  assert.throws(() => fromString('x'), SyntaxError);\n  assert.throws(() => fromString('1234', 0), RangeError);\n  assert.throws(() => fromString('1234', 1), RangeError);\n  assert.throws(() => fromString('1234', 37), RangeError);\n  assert.throws(() => fromString('010'), SyntaxError);\n  assert.throws(() => fromString('1_000_000_000'), SyntaxError);\n});","file":"tests/esnext.number.from-string.js","skipped":false,"dir":"tests"},{"name":"Number.range","suites":[],"line":1,"code":"QUnit.test('Number.range', assert => {\n  const {\n    range\n  } = Number;\n  const {\n    from\n  } = Array;\n  assert.isFunction(range);\n  assert.name(range, 'range');\n  assert.arity(range, 3);\n  assert.looksNative(range);\n  assert.nonEnumerable(Number, 'range');\n  let iterator = range(1, 2);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.deepEqual(from(range(-1, 5)), [-1, 0, 1, 2, 3, 4]);\n  assert.deepEqual(from(range(-5, 1)), [-5, -4, -3, -2, -1, 0]);\n  assert.deepEqual(from(range(0, 1, 0.1)), [0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]);\n  assert.deepEqual(from(range(2 ** 53 - 1, 2 ** 53, {\n    inclusive: true\n  })), [9007199254740991, 9007199254740992]);\n  assert.deepEqual(from(range(0, 0)), []);\n  assert.deepEqual(from(range(0, -5, 1)), []);\n  assert.deepEqual(from(range(NaN, 0)), []);\n  assert.deepEqual(from(range(0, NaN)), []);\n  assert.deepEqual(from(range(NaN, NaN)), []);\n  assert.deepEqual(from(range(0, 0, {\n    step: NaN\n  })), []);\n  assert.deepEqual(from(range(0, 5, NaN)), []);\n  iterator = range(1, 3);\n  assert.deepEqual(iterator.start, 1);\n  assert.deepEqual(iterator.end, 3);\n  assert.deepEqual(iterator.step, 1);\n  assert.false(iterator.inclusive);\n  iterator = range(-1, -3, {\n    inclusive: true\n  });\n  assert.deepEqual(iterator.start, -1);\n  assert.deepEqual(iterator.end, -3);\n  assert.same(iterator.step, -1);\n  assert.true(iterator.inclusive);\n  iterator = range(-1, -3, {\n    step: 4,\n\n    inclusive() {\n      /* empty */\n    }\n\n  });\n  assert.same(iterator.start, -1);\n  assert.same(iterator.end, -3);\n  assert.same(iterator.step, 4);\n  assert.true(iterator.inclusive);\n  iterator = range(0, 5);\n  assert.throws(() => Object.getOwnPropertyDescriptor(iterator, 'start').call({}), TypeError);\n  assert.throws(() => range(Infinity, 10, 0), RangeError);\n  assert.throws(() => range(-Infinity, 10, 0), RangeError);\n  assert.throws(() => range(0, 10, Infinity), RangeError);\n  assert.throws(() => range(0, 10, {\n    step: Infinity\n  }), RangeError);\n  assert.throws(() => range({}, 1), TypeError);\n  assert.throws(() => range(1, {}), TypeError);\n});","file":"tests/esnext.number.range.js","skipped":false,"dir":"tests"},{"name":"Object.iterateEntries","suites":[],"line":1,"code":"QUnit.test('Object.iterateEntries', assert => {\n  const {\n    iterateEntries\n  } = Object;\n  assert.isFunction(iterateEntries);\n  assert.name(iterateEntries, 'iterateEntries');\n  assert.arity(iterateEntries, 1);\n  assert.looksNative(iterateEntries);\n  assert.nonEnumerable(Object, 'iterateEntries');\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateEntries(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: ['q', 1],\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: ['e', 3],\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/esnext.object.iterate-entries.js","skipped":false,"dir":"tests"},{"name":"Object.iterateKeys","suites":[],"line":1,"code":"QUnit.test('Object.iterateKeys', assert => {\n  const {\n    iterateKeys\n  } = Object;\n  assert.isFunction(iterateKeys);\n  assert.name(iterateKeys, 'iterateKeys');\n  assert.arity(iterateKeys, 1);\n  assert.looksNative(iterateKeys);\n  assert.nonEnumerable(Object, 'iterateKeys');\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateKeys(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 'q',\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: 'e',\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/esnext.object.iterate-keys.js","skipped":false,"dir":"tests"},{"name":"Object.iterateValues","suites":[],"line":1,"code":"QUnit.test('Object.iterateValues', assert => {\n  const {\n    iterateValues\n  } = Object;\n  assert.isFunction(iterateValues);\n  assert.name(iterateValues, 'iterateValues');\n  assert.arity(iterateValues, 1);\n  assert.looksNative(iterateValues);\n  assert.nonEnumerable(Object, 'iterateValues');\n  const object = {\n    q: 1,\n    w: 2,\n    e: 3\n  };\n  const iterator = iterateValues(object);\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'Object Iterator');\n  assert.deepEqual(iterator.next(), {\n    value: 1,\n    done: false\n  });\n  delete object.w;\n  assert.deepEqual(iterator.next(), {\n    value: 3,\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n});","file":"tests/esnext.object.iterate-values.js","skipped":false,"dir":"tests"},{"name":"Observable","suites":[],"line":2,"code":"QUnit.test('Observable', assert => {\n  assert.isFunction(Observable);\n  assert.arity(Observable, 1);\n  assert.name(Observable, 'Observable');\n  assert.looksNative(Observable);\n  assert.throws(() => Observable(() => {\n    /* empty */\n  }), 'throws w/o `new`');\n  const observable = new Observable(function (subscriptionObserver) {\n    assert.same(typeof subscriptionObserver, 'object', 'Subscription observer is object');\n    assert.same(subscriptionObserver.constructor, Object);\n    const {\n      next,\n      error,\n      complete\n    } = subscriptionObserver;\n    assert.isFunction(next);\n    assert.isFunction(error);\n    assert.isFunction(complete);\n    assert.arity(next, 1);\n    assert.arity(error, 1);\n    assert.arity(complete, 0);\n\n    if (STRICT) {\n      assert.same(this, undefined, 'correct executor context');\n    }\n  });\n  observable.subscribe({});\n  assert.true(observable instanceof Observable);\n});","file":"tests/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#subscribe","suites":[],"line":32,"code":"QUnit.test('Observable#subscribe', assert => {\n  assert.isFunction(Observable.prototype.subscribe);\n  assert.arity(Observable.prototype.subscribe, 1);\n  assert.name(Observable.prototype.subscribe, 'subscribe');\n  assert.looksNative(Observable.prototype.subscribe);\n  const subscription = new Observable(() => {\n    /* empty */\n  }).subscribe({});\n  assert.same(typeof subscription, 'object', 'Subscription is object');\n  assert.same(subscription.constructor, Object);\n  assert.isFunction(subscription.unsubscribe);\n  assert.arity(subscription.unsubscribe, 0);\n});","file":"tests/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#constructor","suites":[],"line":45,"code":"QUnit.test('Observable#constructor', assert => {\n  assert.same(Observable.prototype.constructor, Observable);\n});","file":"tests/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable#@@observable","suites":[],"line":48,"code":"QUnit.test('Observable#@@observable', assert => {\n  assert.isFunction(Observable.prototype[Symbol.observable]);\n  const observable = new Observable(() => {\n    /* empty*/\n  });\n  assert.same(observable[Symbol.observable](), observable);\n});","file":"tests/esnext.observable.constructor.js","skipped":false,"dir":"tests"},{"name":"Observable.from","suites":[],"line":1,"code":"QUnit.test('Observable.from', assert => {\n  assert.isFunction(Observable.from);\n  assert.arity(Observable.from, 1);\n  assert.name(Observable.from, 'from');\n  assert.looksNative(Observable.from);\n});","file":"tests/esnext.observable.from.js","skipped":false,"dir":"tests"},{"name":"Observable.of","suites":[],"line":1,"code":"QUnit.test('Observable.of', assert => {\n  assert.isFunction(Observable.of);\n  assert.arity(Observable.of, 0);\n  assert.name(Observable.of, 'of');\n  assert.looksNative(Observable.of);\n});","file":"tests/esnext.observable.of.js","skipped":false,"dir":"tests"},{"name":"Promise.try","suites":[],"line":1,"code":"QUnit.test('Promise.try', assert => {\n  assert.isFunction(Promise.try);\n  assert.arity(Promise.try, 1);\n  assert.looksNative(Promise.try);\n  assert.nonEnumerable(Promise, 'try');\n  assert.true(Promise.try(() => 42) instanceof Promise, 'returns a promise');\n});","file":"tests/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Promise.try, resolved","suites":[],"line":8,"code":"QUnit.test('Promise.try, resolved', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.try(() => 42).then(it => {\n    assert.same(it, 42, 'resolved with a correct value');\n    async();\n  });\n});","file":"tests/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Promise.try, rejected","suites":[],"line":16,"code":"QUnit.test('Promise.try, rejected', assert => {\n  assert.expect(1);\n  const async = assert.async();\n  Promise.try(() => {\n    throw new Error();\n  }).catch(() => {\n    assert.required('rejected as expected');\n    async();\n  });\n});","file":"tests/esnext.promise.try.js","skipped":false,"dir":"tests"},{"name":"Reflect.defineMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.defineMetadata', assert => {\n  const {\n    defineMetadata\n  } = Reflect;\n  assert.isFunction(defineMetadata);\n  assert.arity(defineMetadata, 3);\n  assert.name(defineMetadata, 'defineMetadata');\n  assert.looksNative(defineMetadata);\n  assert.nonEnumerable(Reflect, 'defineMetadata');\n  assert.throws(() => defineMetadata('key', 'value', undefined, undefined), TypeError);\n  assert.same(defineMetadata('key', 'value', {}, undefined), undefined);\n  assert.same(defineMetadata('key', 'value', {}, 'name'), undefined);\n});","file":"tests/esnext.reflect.define-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.deleteMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.deleteMetadata', assert => {\n  const {\n    defineMetadata,\n    hasOwnMetadata,\n    deleteMetadata\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(deleteMetadata);\n  assert.arity(deleteMetadata, 2);\n  assert.name(deleteMetadata, 'deleteMetadata');\n  assert.looksNative(deleteMetadata);\n  assert.nonEnumerable(Reflect, 'deleteMetadata');\n  assert.throws(() => deleteMetadata('key', undefined, undefined), TypeError);\n  assert.false(deleteMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(deleteMetadata('key', object, undefined));\n  const prototype = {};\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.false(deleteMetadata('key', create(prototype), undefined));\n  object = {};\n  defineMetadata('key', 'value', object, undefined);\n  deleteMetadata('key', object, undefined);\n  assert.false(hasOwnMetadata('key', object, undefined));\n});","file":"tests/esnext.reflect.delete-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getMetadataKeys","suites":[],"line":1,"code":"QUnit.test('Reflect.getMetadataKeys', assert => {\n  const {\n    defineMetadata,\n    getMetadataKeys\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(getMetadataKeys);\n  assert.arity(getMetadataKeys, 1);\n  assert.name(getMetadataKeys, 'getMetadataKeys');\n  assert.looksNative(getMetadataKeys);\n  assert.nonEnumerable(Reflect, 'getMetadataKeys');\n  assert.throws(() => getMetadataKeys(undefined, undefined), TypeError);\n  assert.deepEqual(getMetadataKeys({}, undefined), []);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key']);\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  defineMetadata('key0', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, undefined);\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getMetadataKeys(object, undefined), ['key0', 'key1', 'key2']);\n  object = {};\n  assert.deepEqual(getMetadataKeys({}, 'name'), []);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key']);\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key']);\n  object = {};\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  defineMetadata('key0', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, 'name');\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  assert.deepEqual(getMetadataKeys(object, 'name'), ['key0', 'key1', 'key2']);\n});","file":"tests/esnext.reflect.get-metadata-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.getMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.getMetadata', assert => {\n  const {\n    defineMetadata,\n    getMetadata\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(getMetadata);\n  assert.arity(getMetadata, 2);\n  assert.name(getMetadata, 'getMetadata');\n  assert.looksNative(getMetadata);\n  assert.nonEnumerable(Reflect, 'getMetadata');\n  assert.throws(() => getMetadata('key', undefined, undefined), TypeError);\n  assert.same(getMetadata('key', {}, undefined), undefined);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.same(getMetadata('key', object, undefined), 'value');\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.same(getMetadata('key', object, undefined), 'value');\n  assert.same(getMetadata('key', {}, 'name'), undefined);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.same(getMetadata('key', object, 'name'), 'value');\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.same(getMetadata('key', object, 'name'), 'value');\n});","file":"tests/esnext.reflect.get-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.getOwnMetadata', assert => {\n  const {\n    defineMetadata,\n    getOwnMetadata\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(getOwnMetadata);\n  assert.arity(getOwnMetadata, 2);\n  assert.name(getOwnMetadata, 'getOwnMetadata');\n  assert.looksNative(getOwnMetadata);\n  assert.nonEnumerable(Reflect, 'getOwnMetadata');\n  assert.throws(() => getOwnMetadata('key', undefined, undefined), TypeError);\n  assert.same(getOwnMetadata('key', {}, undefined), undefined);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.same(getOwnMetadata('key', object, undefined), 'value');\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.same(getOwnMetadata('key', object, undefined), undefined);\n  assert.same(getOwnMetadata('key', {}, 'name'), undefined);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.same(getOwnMetadata('key', object, 'name'), 'value');\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.same(getOwnMetadata('key', object, 'name'), undefined);\n});","file":"tests/esnext.reflect.get-own-matadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.getOwnMetadataKeys","suites":[],"line":1,"code":"QUnit.test('Reflect.getOwnMetadataKeys', assert => {\n  const {\n    defineMetadata,\n    getOwnMetadataKeys\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(getOwnMetadataKeys);\n  assert.arity(getOwnMetadataKeys, 1);\n  assert.name(getOwnMetadataKeys, 'getOwnMetadataKeys');\n  assert.looksNative(getOwnMetadataKeys);\n  assert.nonEnumerable(Reflect, 'getOwnMetadataKeys');\n  assert.throws(() => getOwnMetadataKeys(undefined, undefined), TypeError);\n  assert.deepEqual(getOwnMetadataKeys({}, undefined), []);\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key']);\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), []);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  defineMetadata('key0', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, undefined);\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, undefined);\n  defineMetadata('key1', 'value', object, undefined);\n  assert.deepEqual(getOwnMetadataKeys(object, undefined), ['key0', 'key1']);\n  object = {};\n  assert.deepEqual(getOwnMetadataKeys({}, 'name'), []);\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key']);\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), []);\n  object = {};\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  defineMetadata('key0', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key0', 'key1']);\n  prototype = {};\n  defineMetadata('key2', 'value', prototype, 'name');\n  object = create(prototype);\n  defineMetadata('key0', 'value', object, 'name');\n  defineMetadata('key1', 'value', object, 'name');\n  assert.deepEqual(getOwnMetadataKeys(object, 'name'), ['key0', 'key1']);\n});","file":"tests/esnext.reflect.get-own-metadata-keys.js","skipped":false,"dir":"tests"},{"name":"Reflect.hasMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.hasMetadata', assert => {\n  const {\n    defineMetadata,\n    hasMetadata\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(hasMetadata);\n  assert.arity(hasMetadata, 2);\n  assert.name(hasMetadata, 'hasMetadata');\n  assert.looksNative(hasMetadata);\n  assert.nonEnumerable(Reflect, 'hasMetadata');\n  assert.throws(() => hasMetadata('key', undefined, undefined), TypeError);\n  assert.false(hasMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(hasMetadata('key', object, undefined));\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.true(hasMetadata('key', object, undefined));\n  assert.false(hasMetadata('key', {}, 'name'));\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.true(hasMetadata('key', object, 'name'));\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.true(hasMetadata('key', object, 'name'));\n});","file":"tests/esnext.reflect.has-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.hasOwnMetadata","suites":[],"line":1,"code":"QUnit.test('Reflect.hasOwnMetadata', assert => {\n  const {\n    defineMetadata,\n    hasOwnMetadata\n  } = Reflect;\n  const {\n    create\n  } = Object;\n  assert.isFunction(hasOwnMetadata);\n  assert.arity(hasOwnMetadata, 2);\n  assert.name(hasOwnMetadata, 'hasOwnMetadata');\n  assert.looksNative(hasOwnMetadata);\n  assert.nonEnumerable(Reflect, 'hasOwnMetadata');\n  assert.throws(() => hasOwnMetadata('key', undefined, undefined), TypeError);\n  assert.false(hasOwnMetadata('key', {}, undefined));\n  let object = {};\n  defineMetadata('key', 'value', object, undefined);\n  assert.true(hasOwnMetadata('key', object, undefined));\n  let prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, undefined);\n  assert.false(hasOwnMetadata('key', object, undefined));\n  assert.false(hasOwnMetadata('key', {}, 'name'));\n  object = {};\n  defineMetadata('key', 'value', object, 'name');\n  assert.true(hasOwnMetadata('key', object, 'name'));\n  prototype = {};\n  object = create(prototype);\n  defineMetadata('key', 'value', prototype, 'name');\n  assert.false(hasOwnMetadata('key', object, 'name'));\n});","file":"tests/esnext.reflect.has-own-metadata.js","skipped":false,"dir":"tests"},{"name":"Reflect.metadata","suites":[],"line":1,"code":"QUnit.test('Reflect.metadata', assert => {\n  const {\n    metadata,\n    hasOwnMetadata\n  } = Reflect;\n  assert.isFunction(metadata);\n  assert.arity(metadata, 2);\n  assert.name(metadata, 'metadata');\n  assert.looksNative(metadata);\n  assert.isFunction(metadata('key', 'value'));\n  assert.nonEnumerable(Reflect, 'metadata');\n  const decorator = metadata('key', 'value');\n  assert.throws(() => decorator(undefined, 'name'), TypeError);\n\n  let target = function () {\n    /* empty */\n  };\n\n  decorator(target);\n  assert.true(hasOwnMetadata('key', target, undefined));\n  target = {};\n  decorator(target, 'name');\n  assert.true(hasOwnMetadata('key', target, 'name'));\n});","file":"tests/esnext.reflect.metadata.js","skipped":false,"dir":"tests"},{"name":"Set#addAll","suites":[],"line":1,"code":"QUnit.test('Set#addAll', assert => {\n  const {\n    addAll\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(addAll);\n  assert.arity(addAll, 0);\n  assert.name(addAll, 'addAll');\n  assert.looksNative(addAll);\n  assert.nonEnumerable(Set.prototype, 'addAll');\n  const set = new Set([1]);\n  assert.same(set.addAll(2), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll(4, 5)), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll(3, 4)), [1, 2, 3, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).addAll()), [1, 2, 3]);\n  assert.notThrows(() => addAll.call({\n    add() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => addAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => addAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => addAll.call(null, 1, 2, 3), TypeError);\n});","file":"tests/esnext.set.add-all.js","skipped":false,"dir":"tests"},{"name":"Set#deleteAll","suites":[],"line":1,"code":"QUnit.test('Set#deleteAll', assert => {\n  const {\n    deleteAll\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.looksNative(deleteAll);\n  assert.nonEnumerable(Set.prototype, 'deleteAll');\n  let set = new Set([1, 2, 3]);\n  assert.true(set.deleteAll(1, 2));\n  assert.deepEqual(from(set), [3]);\n  set = new Set([1, 2, 3]);\n  assert.false(set.deleteAll(3, 4));\n  assert.deepEqual(from(set), [1, 2]);\n  set = new Set([1, 2, 3]);\n  assert.false(set.deleteAll(4, 5));\n  assert.deepEqual(from(set), [1, 2, 3]);\n  set = new Set([1, 2, 3]);\n  assert.true(set.deleteAll());\n  assert.deepEqual(from(set), [1, 2, 3]);\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, 1, 2, 3));\n  assert.throws(() => deleteAll.call({}, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(undefined, 1, 2, 3), TypeError);\n  assert.throws(() => deleteAll.call(null, 1, 2, 3), TypeError);\n});","file":"tests/esnext.set.delete-all.js","skipped":false,"dir":"tests"},{"name":"Set#difference","suites":[],"line":2,"code":"QUnit.test('Set#difference', assert => {\n  const {\n    difference\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(difference);\n  assert.arity(difference, 1);\n  assert.name(difference, 'difference');\n  assert.looksNative(difference);\n  assert.nonEnumerable(Set.prototype, 'difference');\n  const set = new Set([1]);\n  assert.notSame(set.difference([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference([4, 5])), [1, 2, 3]);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference([3, 4])), [1, 2]);\n  assert.deepEqual(from(new Set([1, 2, 3]).difference(createIterable([3, 4]))), [1, 2]);\n  assert.throws(() => new Set([1, 2, 3]).difference(), TypeError);\n  assert.throws(() => difference.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => difference.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => difference.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.difference.js","skipped":false,"dir":"tests"},{"name":"Set#every","suites":[],"line":1,"code":"QUnit.test('Set#every', assert => {\n  const {\n    every\n  } = Set.prototype;\n  assert.isFunction(every);\n  assert.arity(every, 1);\n  assert.name(every, 'every');\n  assert.looksNative(every);\n  assert.nonEnumerable(Set.prototype, 'every');\n  const set = new Set([1]);\n  const context = {};\n  set.every(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set([1, 2, 3]).every(it => typeof it == 'number'));\n  assert.false(new Set(['1', '2', '3']).some(it => typeof it == 'number'));\n  assert.false(new Set([1, '2', 3]).every(it => typeof it == 'number'));\n  assert.true(new Set().every(it => typeof it == 'number'));\n  assert.throws(() => every.call(new Map(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => every.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.set.every.js","skipped":false,"dir":"tests"},{"name":"Set#filter","suites":[],"line":1,"code":"QUnit.test('Set#filter', assert => {\n  const {\n    filter\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(filter);\n  assert.arity(filter, 1);\n  assert.name(filter, 'filter');\n  assert.looksNative(filter);\n  assert.nonEnumerable(Set.prototype, 'filter');\n  const set = new Set([1]);\n  const context = {};\n  set.filter(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set().filter(it => it) instanceof Set);\n  assert.deepEqual(from(new Set([1, 2, 3, 'q', {}, 4, true, 5]).filter(it => typeof it == 'number')), [1, 2, 3, 4, 5]);\n  assert.throws(() => filter.call(new Map(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => filter.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.set.filter.js","skipped":false,"dir":"tests"},{"name":"Set#find","suites":[],"line":1,"code":"QUnit.test('Set#find', assert => {\n  const {\n    find\n  } = Set.prototype;\n  assert.isFunction(find);\n  assert.arity(find, 1);\n  assert.name(find, 'find');\n  assert.looksNative(find);\n  assert.nonEnumerable(Set.prototype, 'find');\n  const set = new Set([1]);\n  const context = {};\n  set.find(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.same(new Set([2, 3, 4]).find(it => it % 2), 3);\n  assert.same(new Set().find(it => it === 42), undefined);\n  assert.throws(() => find.call(new Map(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => find.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.set.find.js","skipped":false,"dir":"tests"},{"name":"Set.from","suites":[],"line":2,"code":"QUnit.test('Set.from', assert => {\n  const {\n    from\n  } = Set;\n  const toArray = Array.from;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(Set, 'from');\n  assert.true(Set.from() instanceof Set);\n  assert.deepEqual(toArray(Set.from([])), []);\n  assert.deepEqual(toArray(Set.from([1])), [1]);\n  assert.deepEqual(toArray(Set.from([1, 2, 3, 2, 1])), [1, 2, 3]);\n  assert.deepEqual(toArray(Set.from(createIterable([1, 2, 3, 2, 1]))), [1, 2, 3]);\n  const context = {};\n  Set.from([1], function (element, index) {\n    assert.same(element, 1);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"tests/esnext.set.from.js","skipped":false,"dir":"tests"},{"name":"Set#intersection","suites":[],"line":2,"code":"QUnit.test('Set#intersection', assert => {\n  const {\n    intersection\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(intersection);\n  assert.arity(intersection, 1);\n  assert.name(intersection, 'intersection');\n  assert.looksNative(intersection);\n  assert.nonEnumerable(Set.prototype, 'intersection');\n  const set = new Set([1]);\n  assert.notSame(set.intersection([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection([4, 5])), []);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection([2, 3, 4])), [2, 3]);\n  assert.deepEqual(from(new Set([1, 2, 3]).intersection(createIterable([2, 3, 4]))), [2, 3]);\n  assert.throws(() => new Set([1, 2, 3]).intersection(), TypeError);\n  assert.throws(() => intersection.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => intersection.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => intersection.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.intersection.js","skipped":false,"dir":"tests"},{"name":"Set#isDisjointFrom","suites":[],"line":2,"code":"QUnit.test('Set#isDisjointFrom', assert => {\n  const {\n    isDisjointFrom\n  } = Set.prototype;\n  assert.isFunction(isDisjointFrom);\n  assert.arity(isDisjointFrom, 1);\n  assert.name(isDisjointFrom, 'isDisjointFrom');\n  assert.looksNative(isDisjointFrom);\n  assert.nonEnumerable(Set.prototype, 'isDisjointFrom');\n  assert.true(new Set([1]).isDisjointFrom([2]));\n  assert.false(new Set([1]).isDisjointFrom([1]));\n  assert.true(new Set([1, 2, 3]).isDisjointFrom([4, 5, 6]));\n  assert.false(new Set([1, 2, 3]).isDisjointFrom([5, 4, 3]));\n  assert.true(new Set([1]).isDisjointFrom(createIterable([2])));\n  assert.false(new Set([1]).isDisjointFrom(createIterable([1])));\n  assert.throws(() => new Set([1, 2, 3]).isDisjointFrom(), TypeError);\n  assert.throws(() => isDisjointFrom.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isDisjointFrom.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isDisjointFrom.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.is-disjoint-from.js","skipped":false,"dir":"tests"},{"name":"Set#isSubsetOf","suites":[],"line":2,"code":"QUnit.test('Set#isSubsetOf', assert => {\n  const {\n    isSubsetOf\n  } = Set.prototype;\n  assert.isFunction(isSubsetOf);\n  assert.arity(isSubsetOf, 1);\n  assert.name(isSubsetOf, 'isSubsetOf');\n  assert.looksNative(isSubsetOf);\n  assert.nonEnumerable(Set.prototype, 'isSubsetOf');\n  assert.true(new Set([1]).isSubsetOf([1, 2, 3]));\n  assert.false(new Set([1]).isSubsetOf([2, 3, 4]));\n  assert.true(new Set([1, 2, 3]).isSubsetOf([5, 4, 3, 2, 1]));\n  assert.false(new Set([1, 2, 3]).isSubsetOf([5, 4, 3, 2]));\n  assert.true(new Set([1]).isSubsetOf(createIterable([1, 2, 3])));\n  assert.false(new Set([1]).isSubsetOf(createIterable([2, 3, 4])));\n  assert.true(new Set([1]).isSubsetOf({\n    has: () => true\n  }));\n  assert.false(new Set([1]).isSubsetOf({\n    has: () => false\n  }));\n  assert.true(isSubsetOf.call('ab', ['a', 'b', 'c']));\n  assert.false(isSubsetOf.call('ab', ['a']));\n  assert.throws(() => new Set([1, 2, 3]).isSubsetOf(), TypeError);\n  assert.throws(() => isSubsetOf.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isSubsetOf.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isSubsetOf.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.is-subset-of.js","skipped":false,"dir":"tests"},{"name":"Set#isSupersetOf","suites":[],"line":2,"code":"QUnit.test('Set#isSupersetOf', assert => {\n  const {\n    isSupersetOf\n  } = Set.prototype;\n  assert.isFunction(isSupersetOf);\n  assert.arity(isSupersetOf, 1);\n  assert.name(isSupersetOf, 'isSupersetOf');\n  assert.looksNative(isSupersetOf);\n  assert.nonEnumerable(Set.prototype, 'isSupersetOf');\n  assert.true(new Set([1, 2, 3]).isSupersetOf([1]));\n  assert.false(new Set([2, 3, 4]).isSupersetOf([1]));\n  assert.true(new Set([5, 4, 3, 2, 1]).isSupersetOf([1, 2, 3]));\n  assert.false(new Set([5, 4, 3, 2]).isSupersetOf([1, 2, 3]));\n  assert.true(new Set([1, 2, 3]).isSupersetOf(createIterable([1])));\n  assert.false(new Set([2, 3, 4]).isSupersetOf(createIterable([1])));\n  assert.throws(() => new Set([1, 2, 3]).isSupersetOf(), TypeError);\n  assert.throws(() => isSupersetOf.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => isSupersetOf.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => isSupersetOf.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.is-superset-of.js","skipped":false,"dir":"tests"},{"name":"Set#join","suites":[],"line":2,"code":"QUnit.test('Set#join', assert => {\n  const {\n    join\n  } = Set.prototype;\n  assert.isFunction(join);\n  assert.arity(join, 1);\n  assert.name(join, 'join');\n  assert.looksNative(join);\n  assert.nonEnumerable(Set.prototype, 'join');\n  assert.same(new Set([1, 2, 3]).join(), '1,2,3');\n  assert.same(new Set([1, 2, 3]).join(undefined), '1,2,3');\n  assert.same(new Set([1, 2, 3]).join('|'), '1|2|3');\n  assert.throws(() => join.call(new Map()), TypeError);\n  assert.throws(() => join.call({}), TypeError);\n  assert.throws(() => join.call([]), TypeError);\n  assert.throws(() => join.call(undefined), TypeError);\n  assert.throws(() => join.call(null), TypeError);\n});","file":"tests/esnext.set.join.js","skipped":false,"dir":"tests"},{"name":"Set#map","suites":[],"line":1,"code":"QUnit.test('Set#map', assert => {\n  const {\n    map\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(map);\n  assert.arity(map, 1);\n  assert.name(map, 'map');\n  assert.looksNative(map);\n  assert.nonEnumerable(Set.prototype, 'map');\n  const set = new Set([1]);\n  const context = {};\n  set.map(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set().map(it => it) instanceof Set);\n  assert.deepEqual(from(new Set([1, 2, 3]).map(it => it ** 2)), [1, 4, 9]);\n  assert.deepEqual(from(new Set([1, 2, 3]).map(it => it % 2)), [1, 0]);\n  assert.throws(() => map.call(new Map(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => map.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.set.map.js","skipped":false,"dir":"tests"},{"name":"Set.of","suites":[],"line":1,"code":"QUnit.test('Set.of', assert => {\n  const {\n    of\n  } = Set;\n  const toArray = Array.from;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.name(of, 'of');\n  assert.looksNative(of);\n  assert.nonEnumerable(Set, 'of');\n  assert.true(Set.of() instanceof Set);\n  assert.deepEqual(toArray(Set.of(1)), [1]);\n  assert.deepEqual(toArray(Set.of(1, 2, 3, 2, 1)), [1, 2, 3]);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"tests/esnext.set.of.js","skipped":false,"dir":"tests"},{"name":"Set#reduce","suites":[],"line":1,"code":"QUnit.test('Set#reduce', assert => {\n  const {\n    reduce\n  } = Set.prototype;\n  assert.isFunction(reduce);\n  assert.arity(reduce, 1);\n  assert.name(reduce, 'reduce');\n  assert.looksNative(reduce);\n  assert.nonEnumerable(Set.prototype, 'reduce');\n  const set = new Set([1]);\n  const accumulator = {};\n  set.reduce(function (memo, value, key, that) {\n    assert.same(arguments.length, 4, 'correct number of callback arguments');\n    assert.same(memo, accumulator, 'correct callback accumulator');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct index in callback');\n    assert.same(that, set, 'correct link to set in callback');\n  }, accumulator);\n  assert.same(new Set([1, 2, 3]).reduce((a, b) => a + b, 1), 7, 'works with initial accumulator');\n  new Set([1, 2]).reduce((memo, value, key) => {\n    assert.same(memo, 1, 'correct default accumulator');\n    assert.same(value, 2, 'correct start value without initial accumulator');\n    assert.same(key, 2, 'correct start index without initial accumulator');\n  });\n  assert.same(new Set([1, 2, 3]).reduce((a, b) => a + b), 6, 'works without initial accumulator');\n  let values = '';\n  let keys = '';\n  new Set([1, 2, 3]).reduce((memo, value, key, s) => {\n    s.delete(2);\n    values += value;\n    keys += key;\n  }, 0);\n  assert.same(values, '13', 'correct order #1');\n  assert.same(keys, '13', 'correct order #2');\n  assert.throws(() => reduce.call(new Map(), () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call({}, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call([], () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(undefined, () => {\n    /* empty */\n  }, 1), TypeError);\n  assert.throws(() => reduce.call(null, () => {\n    /* empty */\n  }, 1), TypeError);\n});","file":"tests/esnext.set.reduce.js","skipped":false,"dir":"tests"},{"name":"Set#some","suites":[],"line":1,"code":"QUnit.test('Set#some', assert => {\n  const {\n    some\n  } = Set.prototype;\n  assert.isFunction(some);\n  assert.arity(some, 1);\n  assert.name(some, 'some');\n  assert.looksNative(some);\n  assert.nonEnumerable(Set.prototype, 'some');\n  const set = new Set([1]);\n  const context = {};\n  set.some(function (value, key, that) {\n    assert.same(arguments.length, 3, 'correct number of callback arguments');\n    assert.same(value, 1, 'correct value in callback');\n    assert.same(key, 1, 'correct key in callback');\n    assert.same(that, set, 'correct link to set in callback');\n    assert.same(this, context, 'correct callback context');\n  }, context);\n  assert.true(new Set([1, 2, 3]).some(it => typeof it == 'number'));\n  assert.false(new Set(['1', '2', '3']).some(it => typeof it == 'number'));\n  assert.true(new Set([1, '2', 3]).some(it => typeof it == 'number'));\n  assert.false(new Set().some(it => typeof it == 'number'));\n  assert.throws(() => some.call(new Map(), () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call({}, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call([], () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(undefined, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => some.call(null, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.set.some.js","skipped":false,"dir":"tests"},{"name":"Set#symmetricDifference","suites":[],"line":2,"code":"QUnit.test('Set#symmetricDifference', assert => {\n  const {\n    symmetricDifference\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(symmetricDifference);\n  assert.arity(symmetricDifference, 1);\n  assert.name(symmetricDifference, 'symmetricDifference');\n  assert.looksNative(symmetricDifference);\n  assert.nonEnumerable(Set.prototype, 'symmetricDifference');\n  const set = new Set([1]);\n  assert.notSame(set.symmetricDifference([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference([4, 5])), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference([3, 4])), [1, 2, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).symmetricDifference(createIterable([3, 4]))), [1, 2, 4]);\n  assert.throws(() => new Set([1, 2, 3]).symmetricDifference(), TypeError);\n  assert.throws(() => symmetricDifference.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => symmetricDifference.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => symmetricDifference.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.symmetric-difference.js","skipped":false,"dir":"tests"},{"name":"Set#union","suites":[],"line":2,"code":"QUnit.test('Set#union', assert => {\n  const {\n    union\n  } = Set.prototype;\n  const {\n    from\n  } = Array;\n  assert.isFunction(union);\n  assert.arity(union, 1);\n  assert.name(union, 'union');\n  assert.looksNative(union);\n  assert.nonEnumerable(Set.prototype, 'union');\n  const set = new Set([1]);\n  assert.notSame(set.union([2]), set);\n  assert.deepEqual(from(new Set([1, 2, 3]).union([4, 5])), [1, 2, 3, 4, 5]);\n  assert.deepEqual(from(new Set([1, 2, 3]).union([3, 4])), [1, 2, 3, 4]);\n  assert.deepEqual(from(new Set([1, 2, 3]).union(createIterable([3, 4]))), [1, 2, 3, 4]);\n  assert.throws(() => new Set([1, 2, 3]).union(), TypeError);\n  assert.throws(() => union.call({}, [1, 2, 3]), TypeError);\n  assert.throws(() => union.call(undefined, [1, 2, 3]), TypeError);\n  assert.throws(() => union.call(null, [1, 2, 3]), TypeError);\n});","file":"tests/esnext.set.union.js","skipped":false,"dir":"tests"},{"name":"String#at","suites":[],"line":2,"code":"QUnit.test('String#at', assert => {\n  const {\n    at\n  } = String.prototype;\n  assert.isFunction(at);\n  assert.arity(at, 1);\n  assert.name(at, 'at');\n  assert.looksNative(at);\n  assert.nonEnumerable(String.prototype, 'at'); // String that starts with a BMP symbol\n  // assert.same('abc\\uD834\\uDF06def'.at(-Infinity), '');\n  // assert.same('abc\\uD834\\uDF06def'.at(-1), '');\n\n  assert.same('abc\\uD834\\uDF06def'.at(-0), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(+0), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(1), 'b');\n  assert.same('abc\\uD834\\uDF06def'.at(3), '\\uD834\\uDF06');\n  assert.same('abc\\uD834\\uDF06def'.at(4), '\\uDF06');\n  assert.same('abc\\uD834\\uDF06def'.at(5), 'd'); // assert.same('abc\\uD834\\uDF06def'.at(42), '');\n  // assert.same('abc\\uD834\\uDF06def'.at(Infinity), '');\n\n  assert.same('abc\\uD834\\uDF06def'.at(null), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(undefined), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(false), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(NaN), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(''), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at('_'), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at('1'), 'b');\n  assert.same('abc\\uD834\\uDF06def'.at([]), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at({}), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(-0.9), 'a');\n  assert.same('abc\\uD834\\uDF06def'.at(1.9), 'b');\n  assert.same('abc\\uD834\\uDF06def'.at(7.9), 'f'); // assert.same('abc\\uD834\\uDF06def'.at(2 ** 32), '');\n  // String that starts with an astral symbol\n  // assert.same('\\uD834\\uDF06def'.at(-Infinity), '');\n  // assert.same('\\uD834\\uDF06def'.at(-1), '');\n\n  assert.same('\\uD834\\uDF06def'.at(-0), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(0), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(1), '\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(2), 'd');\n  assert.same('\\uD834\\uDF06def'.at(3), 'e');\n  assert.same('\\uD834\\uDF06def'.at(4), 'f'); // assert.same('\\uD834\\uDF06def'.at(42), '');\n  // assert.same('\\uD834\\uDF06def'.at(Infinity), '');\n\n  assert.same('\\uD834\\uDF06def'.at(null), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(undefined), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(false), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(NaN), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at(''), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at('_'), '\\uD834\\uDF06');\n  assert.same('\\uD834\\uDF06def'.at('1'), '\\uDF06'); // Lone high surrogates\n  // assert.same('\\uD834abc'.at(-Infinity), '');\n  // assert.same('\\uD834abc'.at(-1), '');\n\n  assert.same('\\uD834abc'.at(-0), '\\uD834');\n  assert.same('\\uD834abc'.at(0), '\\uD834');\n  assert.same('\\uD834abc'.at(1), 'a'); // assert.same('\\uD834abc'.at(42), '');\n  // assert.same('\\uD834abc'.at(Infinity), '');\n\n  assert.same('\\uD834abc'.at(null), '\\uD834');\n  assert.same('\\uD834abc'.at(undefined), '\\uD834');\n  assert.same('\\uD834abc'.at(), '\\uD834');\n  assert.same('\\uD834abc'.at(false), '\\uD834');\n  assert.same('\\uD834abc'.at(NaN), '\\uD834');\n  assert.same('\\uD834abc'.at(''), '\\uD834');\n  assert.same('\\uD834abc'.at('_'), '\\uD834');\n  assert.same('\\uD834abc'.at('1'), 'a'); // Lone low surrogates\n  // assert.same('\\uDF06abc'.at(-Infinity), '');\n  // assert.same('\\uDF06abc'.at(-1), '');\n\n  assert.same('\\uDF06abc'.at(-0), '\\uDF06');\n  assert.same('\\uDF06abc'.at(0), '\\uDF06');\n  assert.same('\\uDF06abc'.at(1), 'a'); // assert.same('\\uDF06abc'.at(42), '');\n  // assert.same('\\uDF06abc'.at(Infinity), '');\n\n  assert.same('\\uDF06abc'.at(null), '\\uDF06');\n  assert.same('\\uDF06abc'.at(undefined), '\\uDF06');\n  assert.same('\\uDF06abc'.at(), '\\uDF06');\n  assert.same('\\uDF06abc'.at(false), '\\uDF06');\n  assert.same('\\uDF06abc'.at(NaN), '\\uDF06');\n  assert.same('\\uDF06abc'.at(''), '\\uDF06');\n  assert.same('\\uDF06abc'.at('_'), '\\uDF06');\n  assert.same('\\uDF06abc'.at('1'), 'a');\n  assert.same(at.call(42, 0), '4');\n  assert.same(at.call(42, 1), '2');\n  assert.same(at.call({\n    toString() {\n      return 'abc';\n    }\n\n  }, 2), 'c');\n\n  if (STRICT) {\n    assert.throws(() => at.call(null, 0), TypeError);\n    assert.throws(() => at.call(undefined, 0), TypeError);\n  }\n});","file":"tests/esnext.string.at.js","skipped":false,"dir":"tests"},{"name":"String#codePoints","suites":[],"line":3,"code":"QUnit.test('String#codePoints', assert => {\n  const {\n    codePoints\n  } = String.prototype;\n  assert.isFunction(codePoints);\n  assert.arity(codePoints, 0);\n  assert.name(codePoints, 'codePoints');\n  assert.looksNative(codePoints);\n  assert.nonEnumerable(String.prototype, 'codePoints');\n  let iterator = 'qwe'.codePoints();\n  assert.isIterator(iterator);\n  assert.isIterable(iterator);\n  assert.same(iterator[Symbol.toStringTag], 'String Iterator');\n  assert.same(String(iterator), '[object String Iterator]');\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 113,\n      position: 0\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 119,\n      position: 1\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 101,\n      position: 2\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  iterator = '𠮷𠮷𠮷'.codePoints();\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 0\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 2\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: {\n      codePoint: 134071,\n      position: 4\n    },\n    done: false\n  });\n  assert.deepEqual(iterator.next(), {\n    value: undefined,\n    done: true\n  });\n  assert.throws(() => codePoints.call(Symbol()), 'throws on symbol context');\n});","file":"tests/esnext.string.code-points.js","skipped":false,"dir":"tests"},{"name":"String.cooked","suites":[],"line":1,"code":"QUnit.test('String.cooked', assert => {\n  const {\n    cooked\n  } = String;\n  assert.isFunction(cooked);\n  assert.arity(cooked, 1);\n  assert.name(cooked, 'cooked');\n  assert.looksNative(cooked);\n  assert.nonEnumerable(String, 'cooked');\n  assert.same(cooked(['Hi\\\\n', '!'], 'Bob'), 'Hi\\\\nBob!', 'template is an array');\n  assert.same(cooked('test', 0, 1, 2), 't0e1s2t', 'template is a string');\n  assert.same(cooked('test', 0), 't0est', 'lacks substituting');\n\n  if (typeof Symbol == 'function' && !Symbol.sham) {\n    assert.throws(() => cooked([Symbol()]), TypeError, 'throws on symbol #1');\n    assert.throws(() => cooked('test', Symbol()), TypeError, 'throws on symbol #2');\n  }\n\n  assert.throws(() => cooked([undefined]), TypeError);\n  assert.throws(() => cooked(null), TypeError);\n});","file":"tests/esnext.string.cooked.js","skipped":false,"dir":"tests"},{"name":"Symbol.asyncDispose","suites":[],"line":2,"code":"QUnit.test('Symbol.asyncDispose', assert => {\n  assert.true('asyncDispose' in Symbol, 'Symbol.asyncDispose available');\n  assert.nonEnumerable(Symbol, 'asyncDispose');\n  assert.true(Object(Symbol.asyncDispose) instanceof Symbol, 'Symbol.asyncDispose is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'asyncDispose');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.async-dispose.js","skipped":false,"dir":"tests"},{"name":"Symbol.dispose","suites":[],"line":2,"code":"QUnit.test('Symbol.dispose', assert => {\n  assert.true('dispose' in Symbol, 'Symbol.dispose available');\n  assert.nonEnumerable(Symbol, 'dispose');\n  assert.true(Object(Symbol.dispose) instanceof Symbol, 'Symbol.dispose is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'dispose');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.dispose.js","skipped":false,"dir":"tests"},{"name":"Symbol.matcher","suites":[],"line":2,"code":"QUnit.test('Symbol.matcher', assert => {\n  assert.true('matcher' in Symbol, 'Symbol.matcher available');\n  assert.nonEnumerable(Symbol, 'matcher');\n  assert.true(Object(Symbol.matcher) instanceof Symbol, 'Symbol.matcher is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'matcher');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.matcher.js","skipped":false,"dir":"tests"},{"name":"Symbol.metadata","suites":[],"line":2,"code":"QUnit.test('Symbol.metadata', assert => {\n  assert.true('metadata' in Symbol, 'Symbol.metadata available');\n  assert.nonEnumerable(Symbol, 'metadata');\n  assert.true(Object(Symbol.metadata) instanceof Symbol, 'Symbol.metadata is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'metadata');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.metadata.js","skipped":false,"dir":"tests"},{"name":"Symbol.observable","suites":[],"line":2,"code":"QUnit.test('Symbol.observable', assert => {\n  assert.true('observable' in Symbol, 'Symbol.observable available');\n  assert.nonEnumerable(Symbol, 'observable');\n  assert.true(Object(Symbol.observable) instanceof Symbol, 'Symbol.observable is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'observable');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.observable.js","skipped":false,"dir":"tests"},{"name":"Symbol.patternMatch","suites":[],"line":2,"code":"QUnit.test('Symbol.patternMatch', assert => {\n  assert.true('patternMatch' in Symbol, 'Symbol.patternMatch available');\n  assert.nonEnumerable(Symbol, 'patternMatch');\n  assert.true(Object(Symbol.patternMatch) instanceof Symbol, 'Symbol.patternMatch is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'patternMatch');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.pattern-match.js","skipped":false,"dir":"tests"},{"name":"Symbol.replaceAll","suites":[],"line":2,"code":"QUnit.test('Symbol.replaceAll', assert => {\n  assert.true('replaceAll' in Symbol, 'Symbol.replaceAll is available');\n  assert.nonEnumerable(Symbol, 'replaceAll');\n  assert.true(Object(Symbol.replaceAll) instanceof Symbol, 'Symbol.replaceAll is symbol');\n\n  if (DESCRIPTORS) {\n    const descriptor = Object.getOwnPropertyDescriptor(Symbol, 'replaceAll');\n    assert.false(descriptor.enumerable, 'non-enumerable');\n    assert.false(descriptor.writable, 'non-writable');\n    assert.false(descriptor.configurable, 'non-configurable');\n  }\n});","file":"tests/esnext.symbol.replace-all.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.filterOut","suites":[],"line":3,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.filterOut', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      filterOut\n    } = TypedArray.prototype;\n    assert.isFunction(filterOut, `${name}::filterOut is function`);\n    assert.arity(filterOut, 1, `${name}::filterOut arity is 1`);\n    assert.name(filterOut, 'filterOut', `${name}::filterOut name is 'filterOut'`);\n    assert.looksNative(filterOut, `${name}::filterOut looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.filterOut(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    const instance = new TypedArray([1, 2, 3, 4, 5, 6, 7, 8, 9]).filterOut(it => it % 2);\n    assert.true(instance instanceof TypedArray, 'correct instance');\n    assert.arrayEqual(instance, [2, 4, 6, 8], 'works');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).filterOut((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => filterOut.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.filter-out.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.filterReject","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.filterReject', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      filterReject\n    } = TypedArray.prototype;\n    assert.isFunction(filterReject, `${name}::filterReject is function`);\n    assert.arity(filterReject, 1, `${name}::filterReject arity is 1`);\n    assert.name(filterReject, 'filterReject', `${name}::filterReject name is 'filterReject'`);\n    assert.looksNative(filterReject, `${name}::filterReject looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.filterReject(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    const instance = new TypedArray([1, 2, 3, 4, 5, 6, 7, 8, 9]).filterReject(it => it % 2);\n    assert.true(instance instanceof TypedArray, 'correct instance');\n    assert.arrayEqual(instance, [2, 4, 6, 8], 'works');\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).filterReject((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '123');\n    assert.same(keys, '012');\n    assert.throws(() => filterReject.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.filter-reject.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.findLastIndex","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.findLastIndex', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      findLastIndex\n    } = TypedArray.prototype;\n    assert.isFunction(findLastIndex, `${name}::findLastIndex is function`);\n    assert.arity(findLastIndex, 1, `${name}::findLastIndex arity is 1`);\n    assert.name(findLastIndex, 'findLastIndex', `${name}::findLastIndex name is 'findLastIndex'`);\n    assert.looksNative(findLastIndex, `${name}::findLastIndex looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.findLastIndex(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(new TypedArray([1, 2, 3, 2, 1]).findLastIndex(it => !(it % 2)), 3);\n    assert.same(new TypedArray([1, 2, 3, 2, 1]).findLastIndex(it => it === 4), -1);\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).findLastIndex((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '321');\n    assert.same(keys, '210');\n    assert.throws(() => findLastIndex.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.find-last-index.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.findLast","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.findLast', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      findLast\n    } = TypedArray.prototype;\n    assert.isFunction(findLast, `${name}::findLast is function`);\n    assert.arity(findLast, 1, `${name}::findLast arity is 1`);\n    assert.name(findLast, 'findLast', `${name}::findLast name is 'findLast'`);\n    assert.looksNative(findLast, `${name}::findLast looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.findLast(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(new TypedArray([1, 2, 3, 4, 5]).findLast(it => !(it % 2)), 4);\n    assert.same(new TypedArray([1, 2, 3, 4, 5]).findLast(it => it === 6), undefined);\n    let values = '';\n    let keys = '';\n    new TypedArray([1, 2, 3]).findLast((value, key) => {\n      values += value;\n      keys += key;\n    });\n    assert.same(values, '321');\n    assert.same(keys, '210');\n    assert.throws(() => findLast.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.find-last.js","skipped":false,"dir":"tests"},{"name":"%TypedArray%.fromAsync, ","suites":[],"line":6,"code":"  for (const name in TYPED_ARRAYS) QUnit.test(`%TypedArray%.fromAsync, ${name}`, assert => {\n    assert.expect(26); // eslint-disable-next-line qunit/no-async-in-loops -- safe\n\n    const async = assert.async();\n    const TypedArray = GLOBAL[name];\n    const {\n      fromAsync\n    } = TypedArray;\n    assert.isFunction(fromAsync);\n    assert.arity(fromAsync, 1);\n    assert.name(fromAsync, 'fromAsync');\n    assert.looksNative(fromAsync);\n    TypedArray.fromAsync(createAsyncIterable([1, 2, 3]), it => it ** 2).then(it => {\n      assert.arrayEqual(it, [1, 4, 9], 'async iterable and mapfn');\n      return TypedArray.fromAsync(createAsyncIterable([1]), function (arg, index) {\n        assert.same(this, STRICT_THIS, 'this');\n        assert.same(arguments.length, 2, 'arguments length');\n        assert.same(arg, 1, 'argument');\n        assert.same(index, 0, 'index');\n      });\n    }).then(() => {\n      return TypedArray.fromAsync(createAsyncIterable([1, 2, 3]));\n    }).then(it => {\n      assert.arrayEqual(it, [1, 2, 3], 'async iterable without mapfn');\n      return TypedArray.fromAsync(createIterable([1, 2, 3]), arg => arg ** 2);\n    }).then(it => {\n      assert.arrayEqual(it, [1, 4, 9], 'iterable and mapfn');\n      return TypedArray.fromAsync(createIterable([1, 2, 3]), arg => Promise.resolve(arg ** 2));\n    }).then(it => {\n      assert.arrayEqual(it, [1, 4, 9], 'iterable and async mapfn');\n      return TypedArray.fromAsync(createIterable([1]), function (arg, index) {\n        assert.same(this, STRICT_THIS, 'this');\n        assert.same(arguments.length, 2, 'arguments length');\n        assert.same(arg, 1, 'argument');\n        assert.same(index, 0, 'index');\n      });\n    }).then(() => {\n      return TypedArray.fromAsync(createIterable([1, 2, 3]));\n    }).then(it => {\n      assert.arrayEqual(it, [1, 2, 3], 'iterable and without mapfn');\n      return TypedArray.fromAsync([1, Promise.resolve(2), 3]);\n    }).then(it => {\n      assert.arrayEqual(it, [1, 2, 3], 'array');\n      return TypedArray.fromAsync('123');\n    }).then(it => {\n      assert.arrayEqual(it, [1, 2, 3], 'string');\n      return TypedArray.fromAsync({\n        length: 1,\n        0: 1\n      });\n    }).then(it => {\n      assert.arrayEqual(it, [1], 'non-iterable');\n      return TypedArray.fromAsync(createIterable([1]), () => {\n        throw 42;\n      });\n    }).catch(error => {\n      assert.same(error, 42, 'rejection on a callback error');\n\n      function C() {\n        /* empty */\n      }\n\n      return TypedArray.fromAsync.call(C, [1], {});\n    }).catch(error => {\n      assert.true(error instanceof TypeError);\n      return TypedArray.fromAsync(undefined, () => {\n        /* empty */\n      });\n    }).catch(error => {\n      assert.true(error instanceof TypeError);\n      return TypedArray.fromAsync(null, () => {\n        /* empty */\n      });\n    }).catch(error => {\n      assert.true(error instanceof TypeError);\n      return TypedArray.fromAsync([1], null);\n    }).catch(error => {\n      assert.true(error instanceof TypeError);\n      return TypedArray.fromAsync([1], {});\n    }).catch(error => {\n      assert.true(error instanceof TypeError);\n      async();\n    });\n  });","file":"tests/esnext.typed-array.from-async.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.groupBy","suites":[],"line":5,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.groupBy', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      groupBy\n    } = TypedArray.prototype;\n    assert.isFunction(groupBy, `${name}::groupBy is function`);\n    assert.arity(groupBy, 1, `${name}::groupBy arity is 1`);\n    assert.name(groupBy, 'groupBy', `${name}::groupBy name is 'groupBy'`);\n    assert.looksNative(groupBy, `${name}::groupBy looks native`);\n    const array = new TypedArray([1]);\n    const context = {};\n    array.groupBy(function (value, key, that) {\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 1, 'correct value in callback');\n      assert.same(key, 0, 'correct index in callback');\n      assert.same(that, array, 'correct link to array in callback');\n      assert.same(this, context, 'correct callback context');\n    }, context);\n    assert.same(getPrototypeOf(new TypedArray([1]).groupBy(it => it)), null, 'null proto');\n    assert.true(new TypedArray([1]).groupBy(it => it)[1] instanceof TypedArray, 'instance');\n    assert.deepEqual(new TypedArray([1, 2, 3]).groupBy(it => it % 2), {\n      1: new TypedArray([1, 3]),\n      0: new TypedArray([2])\n    }, '#1');\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]).groupBy(it => `i${it % 5}`), {\n      i1: new TypedArray([1, 6, 11]),\n      i2: new TypedArray([2, 7, 12]),\n      i3: new TypedArray([3, 8]),\n      i4: new TypedArray([4, 9]),\n      i0: new TypedArray([5, 10])\n    }, '#2');\n    assert.throws(() => groupBy.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.group-by.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.toReversed","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.toReversed', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      toReversed\n    } = TypedArray.prototype;\n    assert.isFunction(toReversed, `${name}::toReversed is function`);\n    assert.arity(toReversed, 0, `${name}::toReversed arity is 0`);\n    assert.name(toReversed, 'toReversed', `${name}::toReversed name is 'toReversed'`);\n    assert.looksNative(toReversed, `${name}::toReversed looks native`);\n    const array = new TypedArray([1, 2]);\n    assert.notSame(array.toReversed(), array, 'immutable');\n    assert.arrayEqual(new TypedArray([1, 2, 3, 4]).toReversed(), [4, 3, 2, 1], 'works #1');\n    assert.arrayEqual(new TypedArray([1, 2, 3]).toReversed(), [3, 2, 1], 'works #2');\n    assert.throws(() => toReversed.call(null), TypeError, \"isn't generic #1\");\n    assert.throws(() => toReversed.call(undefined), TypeError, \"isn't generic #2\");\n    assert.throws(() => toReversed.call([1, 2]), TypeError, \"isn't generic #3\");\n  }\n});","file":"tests/esnext.typed-array.to-reversed.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.toSorted","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.toSorted', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      toSorted\n    } = TypedArray.prototype;\n    assert.isFunction(toSorted, `${name}::toSorted is function`);\n    assert.arity(toSorted, 1, `${name}::toSorted arity is 1`);\n    assert.name(toSorted, 'toSorted', `${name}::toSorted name is 'toSorted'`);\n    assert.looksNative(toSorted, `${name}::toSorted looks native`);\n    let array = new TypedArray([1]);\n    assert.notSame(array.toSorted(), array, 'immutable');\n\n    if (name.indexOf('Float') === 0) {\n      assert.deepEqual(new TypedArray([1, -1, 3, NaN, 2, 0, 11, -0]).toSorted(), new TypedArray([-1, -0, 0, 1, 2, 3, 11, NaN]), '#1');\n      assert.true(1 / new TypedArray([0, -0]).toSorted()[0] < 0, '-0');\n      assert.deepEqual(new TypedArray([NaN, 1, NaN]).toSorted(), new TypedArray([1, NaN, NaN]), 'NaN');\n    }\n\n    if (name.indexOf('8') === -1) {\n      const expected = Array(516);\n      array = new TypedArray(516);\n      let index, mod, j, k, postfix;\n\n      for (index = 0; index < 516; index++) {\n        mod = index % 4;\n        array[index] = 515 - index;\n        expected[index] = index - 2 * mod + 3;\n      }\n\n      array = array.toSorted((a, b) => (a / 4 | 0) - (b / 4 | 0));\n      assert.arrayEqual(array, expected, 'stable #1');\n      let result = '';\n      array = new TypedArray(520);\n      index = 0;\n\n      for (j = 0; j < 10; j++) {\n        switch (j) {\n          case 1:\n          case 4:\n          case 5:\n          case 7:\n            postfix = 3;\n            break;\n\n          case 3:\n          case 6:\n            postfix = 4;\n            break;\n\n          default:\n            postfix = 2;\n        }\n\n        for (k = 0; k < 52; k++) {\n          array[index] = 10 * index++ + postfix;\n        }\n      }\n\n      array = array.toSorted((a, b) => b % 10 - a % 10);\n\n      for (index = 0; index < array.length; index++) {\n        j = String(array[index] / 520 | 0);\n        if (result.charAt(result.length - 1) !== j) result += j;\n      }\n\n      assert.same(result, '3614570289', 'stable #2');\n    }\n\n    assert.notThrows(() => new TypedArray([1, 2, 3]).toSorted(undefined).length === 3, 'works with undefined');\n    assert.throws(() => new TypedArray([1, 2, 3]).toSorted(null), 'throws on null');\n    assert.throws(() => new TypedArray([1, 2, 3]).toSorted({}), 'throws on {}');\n    assert.throws(() => toSorted.call(null), TypeError, \"isn't generic #1\");\n    assert.throws(() => toSorted.call(undefined), TypeError, \"isn't generic #2\");\n    assert.throws(() => toSorted.call([1, 2]), TypeError, \"isn't generic #3\");\n  }\n});","file":"tests/esnext.typed-array.to-sorted.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.toSpliced","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.toSpliced', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      toSpliced\n    } = TypedArray.prototype;\n    assert.isFunction(toSpliced, `${name}::toSpliced is function`);\n    assert.arity(toSpliced, 2, `${name}::toSpliced arity is 1`);\n    assert.name(toSpliced, 'toSpliced', `${name}::toSpliced name is 'toSpliced'`);\n    assert.looksNative(toSpliced, `${name}::toSpliced looks native`);\n    const array = new TypedArray([1, 2, 3, 4, 5]);\n    assert.notSame(array.toSpliced(2), array, 'immutable');\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).toSpliced(2), new TypedArray([1, 2]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).toSpliced(-2), new TypedArray([1, 2, 3]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).toSpliced(2, 2), new TypedArray([1, 2, 5]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).toSpliced(2, -2), new TypedArray([1, 2, 3, 4, 5]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).toSpliced(2, 2, 6, 7), new TypedArray([1, 2, 6, 7, 5]));\n    assert.throws(() => toSpliced.call(null), TypeError, \"isn't generic #1\");\n    assert.throws(() => toSpliced.call(undefined), TypeError, \"isn't generic #2\");\n    assert.throws(() => toSpliced.call([1, 2]), TypeError, \"isn't generic #3\");\n  }\n});","file":"tests/esnext.typed-array.to-spliced.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.uniqueBy","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.uniqueBy', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      uniqueBy\n    } = TypedArray.prototype;\n    assert.isFunction(uniqueBy, `${name}::uniqueBy is function`);\n    assert.arity(uniqueBy, 1, `${name}::uniqueBy arity is 1`);\n    assert.name(uniqueBy, 'uniqueBy', `${name}::uniqueBy name is 'uniqueBy'`);\n    assert.looksNative(uniqueBy, `${name}::uniqueBy looks native`);\n    const array = new TypedArray([1, 2, 3, 2, 1]);\n    assert.notSame(array.uniqueBy(), array);\n    assert.deepEqual(array.uniqueBy(), new TypedArray([1, 2, 3]));\n    let values = '';\n    new TypedArray([1, 2, 3]).uniqueBy(value => {\n      values += value;\n    });\n    assert.same(values, '123');\n    assert.throws(() => uniqueBy.call(null, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => uniqueBy.call(undefined, () => {\n      /* empty */\n    }), TypeError);\n    assert.throws(() => uniqueBy.call([0], () => {\n      /* empty */\n    }), \"isn't generic\");\n  }\n});","file":"tests/esnext.typed-array.unique-by.js","skipped":false,"dir":"tests"},{"name":"%TypedArrayPrototype%.with","suites":[],"line":2,"code":"if (DESCRIPTORS) QUnit.test('%TypedArrayPrototype%.with', assert => {\n  // we can't implement %TypedArrayPrototype% in all engines, so run all tests for each typed array constructor\n  for (const name in TYPED_ARRAYS) {\n    const TypedArray = GLOBAL[name];\n    const {\n      with: withAt\n    } = TypedArray.prototype;\n    assert.isFunction(withAt, `${name}::with is function`);\n    assert.arity(withAt, 2, `${name}::with arity is 0`); // assert.name(withAt, 'with', `${ name }::with name is 'with'`);\n\n    assert.looksNative(withAt, `${name}::with looks native`);\n    const array = new TypedArray([1, 2, 3, 4, 5]);\n    assert.notSame(array.with(2, 1), array, 'immutable');\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).with(2, 6), new TypedArray([1, 2, 6, 4, 5]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).with(-2, 6), new TypedArray([1, 2, 3, 6, 5]));\n    assert.deepEqual(new TypedArray([1, 2, 3, 4, 5]).with('1', 6), new TypedArray([1, 6, 3, 4, 5]));\n    assert.throws(() => new TypedArray([1, 2, 3, 4, 5]).with(5, 6), RangeError);\n    assert.throws(() => new TypedArray([1, 2, 3, 4, 5]).with(-6, 6), RangeError);\n    assert.throws(() => withAt.call(null, 1, 2), TypeError, \"isn't generic #1\");\n    assert.throws(() => withAt.call(undefined, 1, 2), TypeError, \"isn't generic #2\");\n    assert.throws(() => withAt.call([1, 2], 1, 3), TypeError, \"isn't generic #3\");\n  }\n});","file":"tests/esnext.typed-array.with.js","skipped":false,"dir":"tests"},{"name":"WeakMap#deleteAll","suites":[],"line":1,"code":"QUnit.test('WeakMap#deleteAll', assert => {\n  const {\n    deleteAll\n  } = WeakMap.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.looksNative(deleteAll);\n  assert.nonEnumerable(WeakMap.prototype, 'deleteAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  const d = [];\n  const e = [];\n  let set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.true(set.deleteAll(a, b));\n  assert.false(set.has(a));\n  assert.false(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.false(set.deleteAll(c, d));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.false(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.false(set.deleteAll(d, e));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakMap([[a, 1], [b, 2], [c, 3]]);\n  assert.true(set.deleteAll());\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => deleteAll.call({}, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(null, a, b, c), TypeError);\n});","file":"tests/esnext.weak-map.delete-all.js","skipped":false,"dir":"tests"},{"name":"WeakMap#emplace","suites":[],"line":1,"code":"QUnit.test('WeakMap#emplace', assert => {\n  const {\n    emplace\n  } = WeakMap.prototype;\n  assert.isFunction(emplace);\n  assert.arity(emplace, 2);\n  assert.name(emplace, 'emplace');\n  assert.looksNative(emplace);\n  assert.nonEnumerable(WeakMap.prototype, 'emplace');\n  const a = {};\n  const b = {};\n  const map = new WeakMap([[a, 2]]);\n  let handler = {\n    update(value, key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 3, 'correct number of callback arguments');\n      assert.same(value, 2, 'correct value in callback');\n      assert.same(key, a, 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return value ** 2;\n    },\n\n    insert() {\n      assert.avoid();\n    }\n\n  };\n  assert.same(map.emplace(a, handler), 4, 'returns a correct value');\n  handler = {\n    update() {\n      assert.avoid();\n    },\n\n    insert(key, that) {\n      assert.same(this, handler, 'correct handler in callback');\n      assert.same(arguments.length, 2, 'correct number of callback arguments');\n      assert.same(key, b, 'correct key in callback');\n      assert.same(that, map, 'correct map in callback');\n      return 3;\n    }\n\n  };\n  assert.same(map.emplace(b, handler), 3, 'returns a correct value');\n  assert.same(map.get(a), 4, 'correct result #1');\n  assert.same(map.get(b), 3, 'correct result #2');\n  assert.same(new WeakMap([[a, 2]]).emplace(b, {\n    insert: () => 3\n  }), 3);\n  assert.same(new WeakMap([[a, 2]]).emplace(a, {\n    update: value => value ** 2\n  }), 4);\n  handler = {\n    update() {\n      /* empty */\n    },\n\n    insert() {\n      /* empty */\n    }\n\n  };\n  assert.throws(() => new WeakMap().emplace(a), TypeError);\n  assert.throws(() => emplace.call({}, a, handler), TypeError);\n  assert.throws(() => emplace.call([], a, handler), TypeError);\n  assert.throws(() => emplace.call(undefined, a, handler), TypeError);\n  assert.throws(() => emplace.call(null, a, handler), TypeError);\n});","file":"tests/esnext.weak-map.emplace.js","skipped":false,"dir":"tests"},{"name":"WeakMap.from","suites":[],"line":2,"code":"QUnit.test('WeakMap.from', assert => {\n  const {\n    from\n  } = WeakMap;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(WeakMap, 'from');\n  assert.true(WeakMap.from() instanceof WeakMap);\n  const array = [];\n  assert.same(WeakMap.from([[array, 2]]).get(array), 2);\n  assert.same(WeakMap.from(createIterable([[array, 2]])).get(array), 2);\n  const pair = [{}, 1];\n  const context = {};\n  WeakMap.from([pair], function (element, index) {\n    assert.same(element, pair);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from([{}, 1]));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"tests/esnext.weak-map.from.js","skipped":false,"dir":"tests"},{"name":"WeakMap.of","suites":[],"line":1,"code":"QUnit.test('WeakMap.of', assert => {\n  const {\n    of\n  } = WeakMap;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.name(of, 'of');\n  assert.looksNative(of);\n  assert.nonEnumerable(WeakMap, 'of');\n  const array = [];\n  assert.true(WeakMap.of() instanceof WeakMap);\n  assert.same(WeakMap.of([array, 2]).get(array), 2);\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"tests/esnext.weak-map.of.js","skipped":false,"dir":"tests"},{"name":"WeakMap#upsert","suites":[],"line":1,"code":"QUnit.test('WeakMap#upsert', assert => {\n  const {\n    upsert\n  } = WeakMap.prototype;\n  assert.isFunction(upsert);\n  assert.arity(upsert, 2);\n  assert.looksNative(upsert);\n  assert.nonEnumerable(WeakMap.prototype, 'upsert');\n  const a = {};\n  const b = {};\n  const map = new WeakMap([[a, 2]]);\n  assert.same(map.upsert(a, function (value) {\n    assert.same(arguments.length, 1, 'correct number of callback arguments');\n    assert.same(value, 2, 'correct value in callback');\n    return value ** 2;\n  }, () => {\n    assert.avoid();\n    return 3;\n  }), 4, 'returns a correct value');\n  assert.same(map.upsert(b, value => {\n    assert.avoid();\n    return value ** 2;\n  }, function () {\n    assert.same(arguments.length, 0, 'correct number of callback arguments');\n    return 3;\n  }), 3, 'returns a correct value');\n  assert.same(map.get(a), 4, 'correct result #1');\n  assert.same(map.get(b), 3, 'correct result #2');\n  assert.same(new WeakMap([[a, 2]]).upsert(b, null, () => 3), 3);\n  assert.same(new WeakMap([[a, 2]]).upsert(a, value => value ** 2), 4);\n  assert.throws(() => new WeakMap().upsert(a), TypeError);\n  assert.throws(() => upsert.call({}, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call([], a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(undefined, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n  assert.throws(() => upsert.call(null, a, () => {\n    /* empty */\n  }, () => {\n    /* empty */\n  }), TypeError);\n});","file":"tests/esnext.weak-map.upsert.js","skipped":false,"dir":"tests"},{"name":"WeakSet#addAll","suites":[],"line":1,"code":"QUnit.test('WeakSet#addAll', assert => {\n  const {\n    addAll\n  } = WeakSet.prototype;\n  assert.isFunction(addAll);\n  assert.arity(addAll, 0);\n  assert.name(addAll, 'addAll');\n  assert.looksNative(addAll);\n  assert.nonEnumerable(WeakSet.prototype, 'addAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  let set = new WeakSet([a]);\n  assert.same(set.addAll(b), set);\n  set = new WeakSet([a]).addAll(b, c);\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  set = new WeakSet([a]).addAll(a, b);\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  set = new WeakSet([a]).addAll();\n  assert.true(set.has(a));\n  assert.notThrows(() => addAll.call({\n    add() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => addAll.call({}, a, b, c), TypeError);\n  assert.throws(() => addAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => addAll.call(null, a, b, c), TypeError);\n});","file":"tests/esnext.weak-set.add-all.js","skipped":false,"dir":"tests"},{"name":"WeakSet#deleteAll","suites":[],"line":1,"code":"QUnit.test('WeakSet#deleteAll', assert => {\n  const {\n    deleteAll\n  } = WeakSet.prototype;\n  assert.isFunction(deleteAll);\n  assert.arity(deleteAll, 0);\n  assert.name(deleteAll, 'deleteAll');\n  assert.looksNative(deleteAll);\n  assert.nonEnumerable(WeakSet.prototype, 'deleteAll');\n  const a = [];\n  const b = [];\n  const c = [];\n  const d = [];\n  const e = [];\n  let set = new WeakSet([a, b, c]);\n  assert.true(set.deleteAll(a, b));\n  assert.false(set.has(a));\n  assert.false(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.false(set.deleteAll(c, d));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.false(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.false(set.deleteAll(d, e));\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  set = new WeakSet([a, b, c]);\n  assert.true(set.deleteAll());\n  assert.true(set.has(a));\n  assert.true(set.has(b));\n  assert.true(set.has(c));\n  assert.false(set.has(d));\n  assert.false(set.has(e));\n  assert.notThrows(() => !deleteAll.call({\n    delete() {\n      /* empty */\n    }\n\n  }, a, b, c));\n  assert.throws(() => deleteAll.call({}, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(undefined, a, b, c), TypeError);\n  assert.throws(() => deleteAll.call(null, a, b, c), TypeError);\n});","file":"tests/esnext.weak-set.delete-all.js","skipped":false,"dir":"tests"},{"name":"WeakSet.from","suites":[],"line":2,"code":"QUnit.test('WeakSet.from', assert => {\n  const {\n    from\n  } = WeakSet;\n  assert.isFunction(from);\n  assert.arity(from, 1);\n  assert.name(from, 'from');\n  assert.looksNative(from);\n  assert.nonEnumerable(WeakSet, 'from');\n  assert.true(WeakSet.from() instanceof WeakSet);\n  const array = [];\n  assert.true(WeakSet.from([array]).has(array));\n  assert.true(WeakSet.from(createIterable([array])).has(array));\n  const object = {};\n  const context = {};\n  WeakSet.from([object], function (element, index) {\n    assert.same(element, object);\n    assert.same(index, 0);\n    assert.same(this, context);\n    return element;\n  }, context);\n  assert.throws(() => from({}));\n  let arg = null;\n\n  function F(it) {\n    return arg = it;\n  }\n\n  from.call(F, createIterable([1, 2, 3]), it => it ** 2);\n  assert.deepEqual(arg, [1, 4, 9]);\n});","file":"tests/esnext.weak-set.from.js","skipped":false,"dir":"tests"},{"name":"WeakSet.of","suites":[],"line":1,"code":"QUnit.test('WeakSet.of', assert => {\n  const {\n    of\n  } = WeakSet;\n  assert.isFunction(of);\n  assert.arity(of, 0);\n  assert.name(of, 'of');\n  assert.looksNative(of);\n  assert.nonEnumerable(WeakSet, 'of');\n  const array = [];\n  assert.true(WeakSet.of() instanceof WeakSet);\n  assert.true(WeakSet.of(array).has(array));\n  assert.throws(() => of(1));\n  let arg = null;\n\n  function F(it) {\n    arg = it;\n  }\n\n  of.call(F, 1, 2, 3);\n  assert.deepEqual(arg, [1, 2, 3]);\n});","file":"tests/esnext.weak-set.of.js","skipped":false,"dir":"tests"},{"name":"atob","suites":[],"line":3,"code":"QUnit.test('atob', assert => {\n  assert.isFunction(atob);\n  assert.arity(atob, 1);\n  assert.name(atob, 'atob');\n  if (!NODE) assert.looksNative(atob);\n  assert.same(atob(''), '');\n  assert.same(atob('Zg=='), 'f');\n  assert.same(atob('Zm8='), 'fo');\n  assert.same(atob('Zm9v'), 'foo');\n  assert.same(atob('cXV1eA=='), 'quux');\n  assert.same(atob('ISIjJCU='), '!\"#$%');\n  assert.same(atob('JicoKSor'), \"&'()*+\");\n  assert.same(atob('LC0uLzAxMg=='), ',-./012');\n  assert.same(atob('MzQ1Njc4OTo='), '3456789:');\n  assert.same(atob('Ozw9Pj9AQUJD'), ';<=>?@ABC');\n  assert.same(atob('REVGR0hJSktMTQ=='), 'DEFGHIJKLM');\n  assert.same(atob('Tk9QUVJTVFVWV1g='), 'NOPQRSTUVWX');\n  assert.same(atob('WVpbXF1eX2BhYmM='), 'YZ[\\\\]^_`abc');\n  assert.same(atob('ZGVmZ2hpamtsbW5vcA=='), 'defghijklmnop');\n  assert.same(atob('cXJzdHV2d3h5ent8fX4='), 'qrstuvwxyz{|}~');\n  assert.same(atob(' '), '');\n  assert.same(atob(42), atob('42'));\n  assert.same(atob(null), atob('null'));\n  assert.throws(() => atob(), TypeError, 'no args');\n  assert.throws(() => atob('a'), 'invalid #1');\n  assert.throws(() => atob('a '), 'invalid #2');\n  assert.throws(() => atob('aaaaa'), 'invalid #3');\n  assert.throws(() => atob('[object Object]'), 'invalid #4');\n});","file":"tests/web.atob.js","skipped":false,"dir":"tests"},{"name":"btoa","suites":[],"line":3,"code":"QUnit.test('btoa', assert => {\n  assert.isFunction(btoa);\n  assert.arity(btoa, 1);\n  assert.name(btoa, 'btoa');\n  if (!NODE) assert.looksNative(btoa);\n  assert.same(btoa(''), '');\n  assert.same(btoa('f'), 'Zg==');\n  assert.same(btoa('fo'), 'Zm8=');\n  assert.same(btoa('foo'), 'Zm9v');\n  assert.same(btoa('quux'), 'cXV1eA==');\n  assert.same(btoa('!\"#$%'), 'ISIjJCU=');\n  assert.same(btoa(\"&'()*+\"), 'JicoKSor');\n  assert.same(btoa(',-./012'), 'LC0uLzAxMg==');\n  assert.same(btoa('3456789:'), 'MzQ1Njc4OTo=');\n  assert.same(btoa(';<=>?@ABC'), 'Ozw9Pj9AQUJD');\n  assert.same(btoa('DEFGHIJKLM'), 'REVGR0hJSktMTQ==');\n  assert.same(btoa('NOPQRSTUVWX'), 'Tk9QUVJTVFVWV1g=');\n  assert.same(btoa('YZ[\\\\]^_`abc'), 'WVpbXF1eX2BhYmM=');\n  assert.same(btoa('defghijklmnop'), 'ZGVmZ2hpamtsbW5vcA==');\n  assert.same(btoa('qrstuvwxyz{|}~'), 'cXJzdHV2d3h5ent8fX4=');\n  assert.same(btoa('qrstuvwxyz{|}~'), 'cXJzdHV2d3h5ent8fX4=');\n  assert.same(btoa(42), btoa('42'));\n  assert.same(btoa(null), btoa('null'));\n  assert.same(btoa({\n    x: 1\n  }), btoa('[object Object]'));\n  assert.throws(() => btoa(), TypeError, 'no args');\n  assert.throws(() => btoa('✈'), 'non-ASCII');\n});","file":"tests/web.btoa.js","skipped":false,"dir":"tests"},{"name":"forEach method on iterable DOM collections","suites":[],"line":2,"code":"QUnit.test('forEach method on iterable DOM collections', assert => {\n  let absent = true;\n  const collections = ['NodeList', 'DOMTokenList'];\n\n  for (const name of collections) {\n    const Collection = GLOBAL[name];\n\n    if (Collection) {\n      absent = false;\n      assert.isFunction(Collection.prototype.forEach, `${name}::forEach is a function`);\n      assert.same(Collection.prototype.forEach, Array.prototype.forEach, `${name}::forEach is equal of Array::forEach`);\n    }\n  }\n\n  if (absent) {\n    assert.required('DOM collections are absent');\n  }\n});","file":"tests/web.dom-collections.for-each.js","skipped":false,"dir":"tests"},{"name":"Iterable DOM collections","suites":[],"line":3,"code":"QUnit.test('Iterable DOM collections', assert => {\n  let absent = true;\n  let collections = ['CSSRuleList', 'CSSStyleDeclaration', 'CSSValueList', 'ClientRectList', 'DOMRectList', 'DOMStringList', 'DOMTokenList', 'DataTransferItemList', 'FileList', 'HTMLAllCollection', 'HTMLCollection', 'HTMLFormElement', 'HTMLSelectElement', 'MediaList', 'MimeTypeArray', 'NamedNodeMap', 'NodeList', 'PaintRequestList', 'Plugin', 'PluginArray', 'SVGLengthList', 'SVGNumberList', 'SVGPathSegList', 'SVGPointList', 'SVGStringList', 'SVGTransformList', 'SourceBufferList', 'StyleSheetList', 'TextTrackCueList', 'TextTrackList', 'TouchList'];\n\n  for (const name of collections) {\n    const Collection = GLOBAL[name];\n\n    if (Collection) {\n      assert.same(Collection.prototype[Symbol.toStringTag], name, `${name}::@@toStringTag is '${name}'`);\n      assert.isFunction(Collection.prototype[Symbol.iterator], `${name}::@@iterator is function`);\n      absent = false;\n    }\n  }\n\n  if (GLOBAL.NodeList && GLOBAL.document && document.querySelectorAll && document.querySelectorAll('div') instanceof NodeList) {\n    assert.isFunction(document.querySelectorAll('div')[Symbol.iterator], 'works with document.querySelectorAll');\n  }\n\n  collections = ['NodeList', 'DOMTokenList'];\n\n  for (const name of collections) {\n    const Collection = GLOBAL[name];\n\n    if (Collection) {\n      assert.isFunction(Collection.prototype.values, `${name}::values is function`);\n      assert.same(Collection.prototype.values, Array.prototype.values, `${name}::values is equal of Array::values`);\n      assert.isFunction(Collection.prototype.keys, `${name}::keys is function`);\n      assert.same(Collection.prototype.keys, Array.prototype.keys, `${name}::keys is equal of Array::keys`);\n      assert.isFunction(Collection.prototype.entries, `${name}::entries is function`);\n      assert.same(Collection.prototype.entries, Array.prototype.entries, `${name}::entries is equal of Array::entries`);\n    }\n  }\n\n  if (absent) {\n    assert.required('DOM collections are absent');\n  }\n});","file":"tests/web.dom-collections.iterator.js","skipped":false,"dir":"tests"},{"name":"DOMException","suites":[],"line":130,"code":"QUnit.test('DOMException', assert => {\n  assert.isFunction(DOMException);\n  assert.arity(DOMException, 0);\n  assert.name(DOMException, 'DOMException'); // assert.looksNative(DOMException); // FF43- bug\n\n  let error = new DOMException({}, 'Foo');\n  assert.true(error instanceof DOMException, 'new DOMException({}, \"Foo\") instanceof DOMException');\n  assert.same(error.message, '[object Object]', 'new DOMException({}, \"Foo\").message');\n  assert.same(error.name, 'Foo', 'new DOMException({}, \"Foo\").name');\n  assert.same(error.code, 0, 'new DOMException({}, \"Foo\").code');\n  assert.same(String(error), 'Foo: [object Object]', 'String(new DOMException({}, \"Foo\"))'); // Safari 10.1 bug\n\n  assert.same(error.constructor, DOMException, 'new DOMException({}, \"Foo\").constructor');\n  assert.same(error[Symbol.toStringTag], 'DOMException', 'DOMException.prototype[Symbol.toStringTag]');\n  if (HAS_STACK) assert.true('stack' in error, \"'stack' in new DOMException()\");\n  assert.same(new DOMException().message, '', 'new DOMException().message');\n  assert.same(new DOMException(undefined).message, '', 'new DOMException(undefined).message');\n  assert.same(new DOMException(42).name, 'Error', 'new DOMException(42).name');\n  assert.same(new DOMException(42, undefined).name, 'Error', 'new DOMException(42, undefined).name');\n\n  for (const name in errors) {\n    error = new DOMException(42, name);\n    assert.true(error instanceof DOMException, `new DOMException({}, \"${name}\") instanceof DOMException`);\n    assert.same(error.message, '42', `new DOMException({}, \"${name}\").message`);\n    assert.same(error.name, name, `new DOMException({}, \"${name}\").name`);\n    if (errors[name].m) assert.same(error.code, errors[name].c, `new DOMException({}, \"${name}\").code`); // NodeJS and Deno set codes to deprecated errors\n    else if (!NODE) assert.same(error.code, 0, `new DOMException({}, \"${name}\").code`);\n    assert.same(String(error), `${name}: 42`, `String(new DOMException({}, \"${name}\"))`); // Safari 10.1 bug\n\n    if (HAS_STACK) assert.true('stack' in error, `'stack' in new DOMException({}, \"${name}\")`);\n    assert.same(DOMException[errors[name].s], errors[name].c, `DOMException.${errors[name].s}`);\n    assert.same(DOMException.prototype[errors[name].s], errors[name].c, `DOMException.prototype.${errors[name].s}`);\n  }\n\n  assert.throws(() => DOMException(42, 'DataCloneError'), \"DOMException(42, 'DataCloneError')\");\n  assert.throws(() => new DOMException(Symbol(), 'DataCloneError'), \"new DOMException(Symbol(), 'DataCloneError')\");\n  assert.throws(() => new DOMException(42, Symbol()), 'new DOMException(42, Symbol())');\n\n  if (DESCRIPTORS) {// assert.throws(() => DOMException.prototype.message, 'DOMException.prototype.message'); // FF55- , Safari 10.1 bug\n    // assert.throws(() => DOMException.prototype.name, 'DOMException.prototype.name'); // FF55-, Safari 10.1 bug bug\n    // assert.throws(() => DOMException.prototype.code, 'DOMException.prototype.code'); // Safari 10.1 bug\n    // assert.throws(() => DOMException.prototype.toString(), 'DOMException.prototype.toString()'); // FF55- bug\n  }\n});","file":"tests/web.dom-exception.constructor.js","skipped":false,"dir":"tests"},{"name":"setImmediate / clearImmediate","suites":[],"line":2,"code":"QUnit.test('setImmediate / clearImmediate', assert => {\n  let called = false;\n  assert.expect(8);\n  assert.isFunction(setImmediate, 'setImmediate is function');\n  assert.isFunction(clearImmediate, 'clearImmediate is function');\n  assert.name(setImmediate, 'setImmediate');\n  assert.name(clearImmediate, 'clearImmediate');\n  timeLimitedPromise(1e3, resolve => {\n    setImmediate(() => {\n      called = true;\n      resolve();\n    });\n  }).then(() => {\n    assert.required('setImmediate works');\n  }).catch(() => {\n    assert.avoid('setImmediate works');\n  }).then(assert.async());\n  assert.false(called, 'setImmediate is async');\n  timeLimitedPromise(1e3, resolve => {\n    setImmediate((a, b) => {\n      resolve(a + b);\n    }, 'a', 'b');\n  }).then(it => {\n    assert.same(it, 'ab', 'setImmediate works with additional args');\n  }).catch(() => {\n    assert.avoid('setImmediate works with additional args');\n  }).then(assert.async());\n  timeLimitedPromise(50, resolve => {\n    clearImmediate(setImmediate(resolve));\n  }).then(() => {\n    assert.avoid('clearImmediate works');\n  }).catch(() => {\n    assert.required('clearImmediate works');\n  }).then(assert.async());\n});","file":"tests/web.immediate.js","skipped":false,"dir":"tests"},{"name":"queueMicrotask","suites":[],"line":2,"code":"QUnit.test('queueMicrotask', assert => {\n  assert.expect(5 - NODE);\n  assert.isFunction(queueMicrotask);\n  assert.arity(queueMicrotask, 1);\n  assert.name(queueMicrotask, 'queueMicrotask');\n  if (!NODE) assert.looksNative(queueMicrotask);\n  const async = assert.async();\n  let done = false;\n  let after = false;\n  queueMicrotask(() => {\n    if (!done) {\n      done = true;\n      assert.true(after, 'works');\n      async();\n    }\n  });\n  setTimeout(() => {\n    if (!done) {\n      done = true;\n      assert.avoid();\n      async();\n    }\n  }, 3e3);\n  after = true;\n});","file":"tests/web.queue-microtask.js","skipped":false,"dir":"tests"},{"name":"identity","suites":["structuredClone"],"line":14,"code":"  QUnit.test('identity', assert => {\n    assert.isFunction(structuredClone, 'structuredClone is a function');\n    assert.name(structuredClone, 'structuredClone');\n    assert.arity(structuredClone, 1);\n    if (!NODE) assert.looksNative(structuredClone);\n    assert.throws(() => structuredClone(), 'throws without arguments');\n  });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"primitives","suites":["structuredClone"],"line":49,"code":"  QUnit.test('primitives', assert => {\n    const primitives = [undefined, null].concat(booleans, numbers, bigints, strings);\n\n    for (const value of primitives) cloneTest(value, (orig, clone) => {\n      assert.same(orig, clone, 'primitives should be same after cloned');\n    });\n  }); // \"Primitive\" Objects (Boolean, Number, BigInt, String)","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"primitive objects","suites":["structuredClone"],"line":57,"code":"  QUnit.test('primitive objects', assert => {\n    const primitives = [].concat(booleans, numbers, bigints, strings);\n\n    for (const value of primitives) cloneObjectTest(assert, Object(value), (orig, clone) => {\n      assert.same(orig.valueOf(), clone.valueOf(), 'primitive wrappers should have same value');\n    });\n  }); // Dates","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Date","suites":["structuredClone"],"line":65,"code":"  QUnit.test('Date', assert => {\n    const dates = [new Date(-1e13), new Date(-1e12), new Date(-1e9), new Date(-1e6), new Date(-1e3), new Date(0), new Date(1e3), new Date(1e6), new Date(1e9), new Date(1e12), new Date(1e13)];\n\n    for (const date of dates) cloneTest(date, (orig, clone) => {\n      assert.notSame(orig, clone);\n      assert.same(typeof clone, 'object');\n      assert.same(getPrototypeOf(orig), getPrototypeOf(clone));\n      assert.same(orig.valueOf(), clone.valueOf());\n    });\n  }); // Regular Expressions","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"RegExp","suites":["structuredClone"],"line":76,"code":"  QUnit.test('RegExp', assert => {\n    const regexes = [new RegExp(), /abc/, /abc/g, /abc/i, /abc/gi, /abc/, /abc/g, /abc/i, /abc/gi];\n    const giuy = fromSource('/abc/giuy');\n    if (giuy) regexes.push(giuy);\n\n    for (const regex of regexes) cloneObjectTest(assert, regex, (orig, clone) => {\n      assert.same(orig.toString(), clone.toString(), `regex ${regex}`);\n    });\n  });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"ArrayBuffer","suites":["structuredClone"],"line":88,"code":"    if (typeof Uint8Array == 'function') QUnit.test('ArrayBuffer', assert => {\n      // Crashes\n      cloneObjectTest(assert, new Uint8Array([0, 1, 254, 255]).buffer, (orig, clone) => {\n        assert.arrayEqual(new Uint8Array(orig), new Uint8Array(clone));\n      });\n    }); // TODO SharedArrayBuffer","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"%TypedArray%","suites":["structuredClone"],"line":97,"code":"      QUnit.test('%TypedArray%', assert => {\n        const arrays = [new Uint8Array([]), new Uint8Array([0, 1, 254, 255]), new Uint16Array([0x0000, 0x0001, 0xFFFE, 0xFFFF]), new Uint32Array([0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF]), new Int8Array([0, 1, 254, 255]), new Int16Array([0x0000, 0x0001, 0xFFFE, 0xFFFF]), new Int32Array([0x00000000, 0x00000001, 0xFFFFFFFE, 0xFFFFFFFF]), new Float32Array([-Infinity, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, Infinity, NaN]), new Float64Array([-Infinity, -Number.MAX_VALUE, -Number.MIN_VALUE, 0, Number.MIN_VALUE, Number.MAX_VALUE, Infinity, NaN])];\n\n        if (typeof Uint8ClampedArray != 'undefined') {\n          arrays.push(new Uint8ClampedArray([0, 1, 254, 255]));\n        }\n\n        for (const array of arrays) cloneObjectTest(assert, array, (orig, clone) => {\n          assert.arrayEqual(orig, clone);\n        });\n      });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"DataView","suites":["structuredClone"],"line":108,"code":"      if (typeof DataView != 'undefined') QUnit.test('DataView', assert => {\n        const array = new Int8Array([1, 2, 3, 4]);\n        const view = new DataView(array.buffer);\n        cloneObjectTest(assert, array, (orig, clone) => {\n          assert.same(orig.byteLength, clone.byteLength);\n          assert.same(orig.byteOffset, clone.byteOffset);\n          assert.arrayEqual(new Int8Array(view.buffer), array);\n        });\n      });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Map","suites":["structuredClone"],"line":121,"code":"  QUnit.test('Map', assert => {\n    cloneObjectTest(assert, new Map([[1, 2], [3, 4]]), (orig, clone) => {\n      assert.deepEqual(from(orig.keys()), from(clone.keys()));\n      assert.deepEqual(from(orig.values()), from(clone.values()));\n    });\n  }); // Set","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Set","suites":["structuredClone"],"line":128,"code":"  QUnit.test('Set', assert => {\n    cloneObjectTest(assert, new Set([1, 2, 3, 4]), (orig, clone) => {\n      assert.deepEqual(from(orig.values()), from(clone.values()));\n    });\n  }); // Error","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Error","suites":["structuredClone"],"line":134,"code":"  QUnit.test('Error', assert => {\n    const errors = [['Error', new Error()], ['Error', new Error('abc', 'def', {\n      cause: 42\n    })], ['EvalError', new EvalError()], ['EvalError', new EvalError('ghi', 'jkl', {\n      cause: 42\n    })], ['RangeError', new RangeError()], ['RangeError', new RangeError('ghi', 'jkl', {\n      cause: 42\n    })], ['ReferenceError', new ReferenceError()], ['ReferenceError', new ReferenceError('ghi', 'jkl', {\n      cause: 42\n    })], ['SyntaxError', new SyntaxError()], ['SyntaxError', new SyntaxError('ghi', 'jkl', {\n      cause: 42\n    })], ['TypeError', new TypeError()], ['TypeError', new TypeError('ghi', 'jkl', {\n      cause: 42\n    })], ['URIError', new URIError()], ['URIError', new URIError('ghi', 'jkl', {\n      cause: 42\n    })], ['AggregateError', new AggregateError([1, 2])], ['AggregateError', new AggregateError([1, 2], 42, {\n      cause: 42\n    })]];\n    const compile = fromSource('WebAssembly.CompileError()');\n    const link = fromSource('WebAssembly.LinkError()');\n    const runtime = fromSource('WebAssembly.RuntimeError()');\n    if (compile && compile.name === 'CompileError') errors.push(['CompileError', compile]);\n    if (link && link.name === 'LinkError') errors.push(['LinkError', link]);\n    if (runtime && runtime.name === 'RuntimeError') errors.push(['RuntimeError', runtime]);\n\n    for (const [name, error] of errors) cloneObjectTest(assert, error, (orig, clone) => {\n      assert.same(orig.constructor, clone.constructor, `${name}#constructor`);\n      assert.same(orig.name, clone.name, `${name}#name`);\n      assert.same(orig.message, clone.message, `${name}#message`);\n      assert.same(orig.stack, clone.stack, `${name}#stack`);\n      assert.same(orig.cause, clone.cause, `${name}#cause`);\n      assert.deepEqual(orig.errors, clone.errors, `${name}#errors`);\n    });\n  }); // Arrays","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Array","suites":["structuredClone"],"line":169,"code":"  QUnit.test('Array', assert => {\n    const arrays = [[], [1, 2, 3], assign(['foo', 'bar'], {\n      10: true,\n      11: false,\n      20: 123,\n      21: 456,\n      30: null\n    }), assign(['foo', 'bar'], {\n      a: true,\n      b: false,\n      foo: 123,\n      bar: 456,\n      '': null\n    })];\n\n    for (const array of arrays) cloneObjectTest(assert, array, (orig, clone) => {\n      assert.deepEqual(orig, clone, `array content should be same: ${array}`);\n      assert.deepEqual(keys(orig), keys(clone), `array key should be same: ${array}`);\n\n      for (const key of keys(orig)) {\n        assert.same(orig[key], clone[key], `Property ${key}`);\n      }\n    });\n  }); // Objects","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Object","suites":["structuredClone"],"line":194,"code":"  QUnit.test('Object', assert => {\n    cloneObjectTest(assert, {\n      foo: true,\n      bar: false\n    }, (orig, clone) => {\n      assert.deepEqual(keys(orig), keys(clone));\n\n      for (const key of keys(orig)) {\n        assert.same(orig[key], clone[key], `Property ${key}`);\n      }\n    });\n  }); // [Serializable] Platform objects","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMMatrix","suites":["structuredClone"],"line":209,"code":"    QUnit.test('Geometry types, DOMMatrix', assert => {\n      cloneObjectTest(assert, new DOMMatrix(), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMMatrixReadOnly","suites":["structuredClone"],"line":219,"code":"    QUnit.test('Geometry types, DOMMatrixReadOnly', assert => {\n      cloneObjectTest(assert, new DOMMatrixReadOnly(), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMPoint","suites":["structuredClone"],"line":229,"code":"    QUnit.test('Geometry types, DOMPoint', assert => {\n      cloneObjectTest(assert, new DOMPoint(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMPointReadOnly","suites":["structuredClone"],"line":239,"code":"    QUnit.test('Geometry types, DOMPointReadOnly', assert => {\n      cloneObjectTest(assert, new DOMPointReadOnly(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMQuad","suites":["structuredClone"],"line":249,"code":"    QUnit.test('Geometry types, DOMQuad', assert => {\n      cloneObjectTest(assert, new DOMQuad(new DOMPoint(1, 2, 3, 4), new DOMPoint(2, 2, 3, 4), new DOMPoint(1, 3, 3, 4), new DOMPoint(1, 2, 4, 4)), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.deepEqual(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMRect","suites":["structuredClone"],"line":259,"code":"    QUnit.test('Geometry types, DOMRect', assert => {\n      cloneObjectTest(assert, new DOMRect(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Geometry types, DOMRectReadOnly","suites":["structuredClone"],"line":269,"code":"    QUnit.test('Geometry types, DOMRectReadOnly', assert => {\n      cloneObjectTest(assert, new DOMRectReadOnly(1, 2, 3, 4), (orig, clone) => {\n        for (const key of keys(getPrototypeOf(orig))) {\n          assert.same(orig[key], clone[key], `Property ${key}`);\n        }\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"ImageData","suites":["structuredClone"],"line":280,"code":"    QUnit.test('ImageData', assert => {\n      const imageData = new ImageData(8, 8);\n\n      for (let i = 0; i < 256; ++i) {\n        imageData.data[i] = i;\n      }\n\n      cloneObjectTest(assert, imageData, (orig, clone) => {\n        assert.same(orig.width, clone.width);\n        assert.same(orig.height, clone.height);\n        assert.same(orig.colorSpace, clone.colorSpace);\n        assert.arrayEqual(orig.data, clone.data);\n      });\n    });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Blob","suites":["structuredClone"],"line":296,"code":"  if (fromSource('new Blob([\"test\"])')) QUnit.test('Blob', assert => {\n    cloneObjectTest(assert, new Blob(['This is a test.'], {\n      type: 'a/b'\n    }), (orig, clone) => {\n      assert.same(orig.size, clone.size);\n      assert.same(orig.type, clone.type); // TODO: async\n      // assert.same(await orig.text(), await clone.text());\n    });\n  });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"DOMException","suites":["structuredClone"],"line":305,"code":"  QUnit.test('DOMException', assert => {\n    const errors = [new DOMException(), new DOMException('foo', 'DataCloneError')];\n\n    for (const error of errors) cloneObjectTest(assert, error, (orig, clone) => {\n      assert.same(orig.name, clone.name);\n      assert.same(orig.message, clone.message);\n      assert.same(orig.code, clone.code);\n      assert.same(orig.stack, clone.stack);\n    });\n  });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"File","suites":["structuredClone"],"line":315,"code":"  if (fromSource('new File([\"test\"], \"foo.txt\")')) QUnit.test('File', assert => {\n    cloneObjectTest(assert, new File(['This is a test.'], 'foo.txt', {\n      type: 'c/d'\n    }), (orig, clone) => {\n      assert.same(orig.size, clone.size);\n      assert.same(orig.type, clone.type);\n      assert.same(orig.name, clone.name);\n      assert.same(orig.lastModified, clone.lastModified); // TODO: async\n      // assert.same(await orig.text(), await clone.text());\n    });\n  }); // FileList","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"FileList","suites":["structuredClone"],"line":327,"code":"  if (fromSource('new File([\"test\"], \"foo.txt\")') && fromSource('new DataTransfer()')) QUnit.test('FileList', assert => {\n    const transfer = new DataTransfer();\n    transfer.items.add(new File(['test'], 'foo.txt'));\n    cloneObjectTest(assert, transfer.files, (orig, clone) => {\n      assert.same(1, clone.length);\n      assert.same(orig[0].size, clone[0].size);\n      assert.same(orig[0].type, clone[0].type);\n      assert.same(orig[0].name, clone[0].name);\n      assert.same(orig[0].lastModified, clone[0].lastModified);\n    });\n  }); // Non-serializable types","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"Non-serializable types","suites":["structuredClone"],"line":339,"code":"  QUnit.test('Non-serializable types', assert => {\n    const nons = [function () {\n      return 1;\n    }, Symbol('desc'), GLOBAL];\n    const event = fromSource('new Event(\"\")');\n    const port = fromSource('new MessageChannel().port1'); // NodeJS events are simple objects\n\n    if (event && !NODE) nons.push(event);\n    if (port) nons.push(port);\n\n    for (const it of nons) {\n      // native NodeJS `structuredClone` throws a `TypeError` on transferable non-serializable instead of `DOMException`\n      // https://github.com/nodejs/node/issues/40841\n      assert.throws(() => structuredClone(it));\n    }\n  });","file":"tests/web.structured-clone.js","skipped":false,"dir":"tests"},{"name":"setTimeout / clearTimeout","suites":[],"line":2,"code":"QUnit.test('setTimeout / clearTimeout', assert => {\n  assert.expect(2);\n  timeLimitedPromise(1e3, resolve => {\n    setTimeout((a, b) => {\n      resolve(a + b);\n    }, 10, 'a', 'b');\n  }).then(it => {\n    assert.same(it, 'ab', 'setTimeout works with additional args');\n  }).catch(() => {\n    assert.avoid('setTimeout works with additional args');\n  }).then(assert.async());\n  timeLimitedPromise(50, resolve => {\n    clearTimeout(setTimeout(resolve, 10));\n  }).then(() => {\n    assert.avoid('clearImmediate works with wrapped setTimeout');\n  }).catch(() => {\n    assert.required('clearImmediate works with wrapped setTimeout');\n  }).then(assert.async());\n});","file":"tests/web.timers.js","skipped":false,"dir":"tests"},{"name":"setInterval / clearInterval","suites":[],"line":21,"code":"QUnit.test('setInterval / clearInterval', assert => {\n  assert.expect(1);\n  timeLimitedPromise(1e4, (resolve, reject) => {\n    let i = 0;\n    const interval = setInterval((a, b) => {\n      if (a + b !== 'ab' || i > 2) reject({\n        a,\n        b,\n        i\n      });\n\n      if (i++ === 2) {\n        clearInterval(interval);\n        setTimeout(resolve, 30);\n      }\n    }, 5, 'a', 'b');\n  }).then(() => {\n    assert.required('setInterval & clearInterval works with additional args');\n  }).catch(error => {\n    if (!error) error = {};\n    assert.avoid(`setInterval & clearInterval works with additional args: ${error.a}, ${error.b}, times: ${error.i}`);\n  }).then(assert.async());\n});","file":"tests/web.timers.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams","suites":[],"line":7,"code":"QUnit.test('URLSearchParams', assert => {\n  assert.isFunction(URLSearchParams);\n  assert.arity(URLSearchParams, 0);\n  assert.name(URLSearchParams, 'URLSearchParams');\n  if (!NODE) assert.looksNative(URLSearchParams);\n  assert.same(String(new URLSearchParams()), '');\n  assert.same(String(new URLSearchParams('')), '');\n  assert.same(String(new URLSearchParams('a=b')), 'a=b');\n  assert.same(String(new URLSearchParams(new URLSearchParams('a=b'))), 'a=b');\n  assert.same(String(new URLSearchParams([])), '');\n  assert.same(String(new URLSearchParams([[1, 2], ['a', 'b']])), '1=2&a=b');\n  assert.same(String(new URLSearchParams(createIterable([createIterable(['a', 'b']), createIterable(['c', 'd'])]))), 'a=b&c=d');\n  assert.same(String(new URLSearchParams({})), '');\n  assert.same(String(new URLSearchParams({\n    1: 2,\n    a: 'b'\n  })), '1=2&a=b');\n  assert.same(String(new URLSearchParams('?a=b')), 'a=b', 'leading ? should be ignored');\n  assert.same(String(new URLSearchParams('??a=b')), '%3Fa=b');\n  assert.same(String(new URLSearchParams('?')), '');\n  assert.same(String(new URLSearchParams('??')), '%3F=');\n  assert.same(String(new URLSearchParams('a=b c')), 'a=b+c');\n  assert.same(String(new URLSearchParams('a=b&b=c&a=d')), 'a=b&b=c&a=d');\n  assert.same(String(new URLSearchParams('a==')), 'a=%3D');\n  assert.same(String(new URLSearchParams('a=b=')), 'a=b%3D');\n  assert.same(String(new URLSearchParams('a=b=c')), 'a=b%3Dc');\n  assert.same(String(new URLSearchParams('a==b')), 'a=%3Db');\n  let params = new URLSearchParams('a=b');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.false(params.has('b'), 'search params object has not got name \"b\"');\n  params = new URLSearchParams('a=b&c');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('c'), 'search params object has name \"c\"');\n  params = new URLSearchParams('&a&&& &&&&&a+b=& c&m%c3%b8%c3%b8');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('a b'), 'search params object has name \"a b\"');\n  assert.true(params.has(' '), 'search params object has name \" \"');\n  assert.false(params.has('c'), 'search params object did not have the name \"c\"');\n  assert.true(params.has(' c'), 'search params object has name \" c\"');\n  assert.true(params.has('møø'), 'search params object has name \"møø\"');\n  params = new URLSearchParams('a=b+c');\n  assert.same(params.get('a'), 'b c', 'parse +');\n  params = new URLSearchParams('a+b=c');\n  assert.same(params.get('a b'), 'c', 'parse +');\n  params = new URLSearchParams('a=b c');\n  assert.same(params.get('a'), 'b c', 'parse \" \"');\n  params = new URLSearchParams('a b=c');\n  assert.same(params.get('a b'), 'c', 'parse \" \"');\n  params = new URLSearchParams('a=b%20c');\n  assert.same(params.get('a'), 'b c', 'parse %20');\n  params = new URLSearchParams('a%20b=c');\n  assert.same(params.get('a b'), 'c', 'parse %20');\n  params = new URLSearchParams('a=b\\0c');\n  assert.same(params.get('a'), 'b\\0c', 'parse \\\\0');\n  params = new URLSearchParams('a\\0b=c');\n  assert.same(params.get('a\\0b'), 'c', 'parse \\\\0');\n  params = new URLSearchParams('a=b%00c');\n  assert.same(params.get('a'), 'b\\0c', 'parse %00');\n  params = new URLSearchParams('a%00b=c');\n  assert.same(params.get('a\\0b'), 'c', 'parse %00');\n  params = new URLSearchParams('a=b\\u2384');\n  assert.same(params.get('a'), 'b\\u2384', 'parse \\u2384');\n  params = new URLSearchParams('a\\u2384b=c');\n  assert.same(params.get('a\\u2384b'), 'c', 'parse \\u2384');\n  params = new URLSearchParams('a=b%e2%8e%84');\n  assert.same(params.get('a'), 'b\\u2384', 'parse %e2%8e%84');\n  params = new URLSearchParams('a%e2%8e%84b=c');\n  assert.same(params.get('a\\u2384b'), 'c', 'parse %e2%8e%84');\n  params = new URLSearchParams('a=b\\uD83D\\uDCA9c');\n  assert.same(params.get('a'), 'b\\uD83D\\uDCA9c', 'parse \\uD83D\\uDCA9');\n  params = new URLSearchParams('a\\uD83D\\uDCA9b=c');\n  assert.same(params.get('a\\uD83D\\uDCA9b'), 'c', 'parse \\uD83D\\uDCA9');\n  params = new URLSearchParams('a=b%f0%9f%92%a9c');\n  assert.same(params.get('a'), 'b\\uD83D\\uDCA9c', 'parse %f0%9f%92%a9');\n  params = new URLSearchParams('a%f0%9f%92%a9b=c');\n  assert.same(params.get('a\\uD83D\\uDCA9b'), 'c', 'parse %f0%9f%92%a9');\n  params = new URLSearchParams();\n  params.set('query', '+15555555555');\n  assert.same(params.toString(), 'query=%2B15555555555');\n  assert.same(params.get('query'), '+15555555555', 'parse encoded +');\n  params = new URLSearchParams(params.toString());\n  assert.same(params.get('query'), '+15555555555', 'parse encoded +');\n  const testData = [{\n    input: '?a=%',\n    output: [['a', '%']],\n    name: 'handling %'\n  }, {\n    input: {\n      '+': '%C2'\n    },\n    output: [['+', '%C2']],\n    name: 'object with +'\n  }, {\n    input: {\n      c: 'x',\n      a: '?'\n    },\n    output: [['c', 'x'], ['a', '?']],\n    name: 'object with two keys'\n  }, {\n    input: [['c', 'x'], ['a', '?']],\n    output: [['c', 'x'], ['a', '?']],\n    name: 'array with two keys'\n  } // eslint-disable-next-line max-len -- ignore\n  // !!! { input: { 'a\\0b': '42', 'c\\uD83D': '23', dሴ: 'foo' }, output: [['a\\0b', '42'], ['c\\uFFFD', '23'], ['d\\u1234', 'foo']], name: 'object with NULL, non-ASCII, and surrogate keys' },\n  ];\n\n  for (const {\n    input,\n    output,\n    name\n  } of testData) {\n    params = new URLSearchParams(input);\n    let i = 0;\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey, `construct with ${name}`);\n      assert.same(value, reqValue, `construct with ${name}`);\n    });\n  }\n\n  assert.throws(() => {\n    URLSearchParams('');\n  }, 'throws w/o `new`');\n  assert.throws(() => {\n    new URLSearchParams([[1, 2, 3]]);\n  }, 'sequence elements must be pairs #1');\n  assert.throws(() => {\n    new URLSearchParams([createIterable([createIterable([1, 2, 3])])]);\n  }, 'sequence elements must be pairs #2');\n  assert.throws(() => {\n    new URLSearchParams([[1]]);\n  }, 'sequence elements must be pairs #3');\n  assert.throws(() => {\n    new URLSearchParams([createIterable([createIterable([1])])]);\n  }, 'sequence elements must be pairs #4');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#append","suites":[],"line":144,"code":"QUnit.test('URLSearchParams#append', assert => {\n  const {\n    append\n  } = URLSearchParams.prototype;\n  assert.isFunction(append);\n  assert.arity(append, 2);\n  assert.name(append, 'append');\n  assert.enumerable(URLSearchParams.prototype, 'append');\n  if (!NODE) assert.looksNative(append);\n  assert.same(new URLSearchParams().append('a', 'b'), undefined, 'void');\n  let params = new URLSearchParams();\n  params.append('a', 'b');\n  assert.same(String(params), 'a=b');\n  params.append('a', 'b');\n  assert.same(String(params), 'a=b&a=b');\n  params.append('a', 'c');\n  assert.same(String(params), 'a=b&a=b&a=c');\n  params = new URLSearchParams();\n  params.append('', '');\n  assert.same(String(params), '=');\n  params.append('', '');\n  assert.same(String(params), '=&=');\n  params = new URLSearchParams();\n  params.append(undefined, undefined);\n  assert.same(String(params), 'undefined=undefined');\n  params.append(undefined, undefined);\n  assert.same(String(params), 'undefined=undefined&undefined=undefined');\n  params = new URLSearchParams();\n  params.append(null, null);\n  assert.same(String(params), 'null=null');\n  params.append(null, null);\n  assert.same(String(params), 'null=null&null=null');\n  params = new URLSearchParams();\n  params.append('first', 1);\n  params.append('second', 2);\n  params.append('third', '');\n  params.append('first', 10);\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  assert.same(params.get('second'), '2', 'search params object has name \"second\" with value \"2\"');\n  assert.same(params.get('third'), '', 'search params object has name \"third\" with value \"\"');\n  params.append('first', 10);\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  assert.throws(() => {\n    return new URLSearchParams('').append();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#delete","suites":[],"line":191,"code":"QUnit.test('URLSearchParams#delete', assert => {\n  const $delete = URLSearchParams.prototype.delete;\n  assert.isFunction($delete);\n  assert.arity($delete, 1);\n  assert.enumerable(URLSearchParams.prototype, 'delete');\n  if (!NODE) assert.looksNative($delete);\n  let params = new URLSearchParams('a=b&c=d');\n  params.delete('a');\n  assert.same(String(params), 'c=d');\n  params = new URLSearchParams('a=a&b=b&a=a&c=c');\n  params.delete('a');\n  assert.same(String(params), 'b=b&c=c');\n  params = new URLSearchParams('a=a&=&b=b&c=c');\n  params.delete('');\n  assert.same(String(params), 'a=a&b=b&c=c');\n  params = new URLSearchParams('a=a&null=null&b=b');\n  params.delete(null);\n  assert.same(String(params), 'a=a&b=b');\n  params = new URLSearchParams('a=a&undefined=undefined&b=b');\n  params.delete(undefined);\n  assert.same(String(params), 'a=a&b=b');\n  params = new URLSearchParams();\n  params.append('first', 1);\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.same(params.get('first'), '1', 'search params object has name \"first\" with value \"1\"');\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no \"first\" name');\n  params.append('first', 1);\n  params.append('first', 10);\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no \"first\" name');\n\n  if (DESCRIPTORS) {\n    let url = new URL('http://example.com/?param1&param2');\n    url.searchParams.delete('param1');\n    url.searchParams.delete('param2');\n    assert.same(String(url), 'http://example.com/', 'url.href does not have ?');\n    assert.same(url.search, '', 'url.search does not have ?');\n    url = new URL('http://example.com/?');\n    url.searchParams.delete('param1'); // assert.same(String(url), 'http://example.com/', 'url.href does not have ?'); // Safari bug\n\n    assert.same(url.search, '', 'url.search does not have ?');\n  }\n\n  assert.throws(() => {\n    return new URLSearchParams('').delete();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#get","suites":[],"line":239,"code":"QUnit.test('URLSearchParams#get', assert => {\n  const {\n    get\n  } = URLSearchParams.prototype;\n  assert.isFunction(get);\n  assert.arity(get, 1);\n  assert.name(get, 'get');\n  assert.enumerable(URLSearchParams.prototype, 'get');\n  if (!NODE) assert.looksNative(get);\n  let params = new URLSearchParams('a=b&c=d');\n  assert.same(params.get('a'), 'b');\n  assert.same(params.get('c'), 'd');\n  assert.same(params.get('e'), null);\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.same(params.get('a'), 'b');\n  params = new URLSearchParams('=b&c=d');\n  assert.same(params.get(''), 'b');\n  params = new URLSearchParams('a=&c=d&a=e');\n  assert.same(params.get('a'), '');\n  params = new URLSearchParams('first=second&third&&');\n  assert.true(params.has('first'), 'Search params object has name \"first\"');\n  assert.same(params.get('first'), 'second', 'Search params object has name \"first\" with value \"second\"');\n  assert.same(params.get('third'), '', 'Search params object has name \"third\" with the empty value.');\n  assert.same(params.get('fourth'), null, 'Search params object has no \"fourth\" name and value.');\n  assert.same(new URLSearchParams('a=b c').get('a'), 'b c');\n  assert.same(new URLSearchParams('a b=c').get('a b'), 'c');\n  assert.same(new URLSearchParams('a=b%20c').get('a'), 'b c', 'parse %20');\n  assert.same(new URLSearchParams('a%20b=c').get('a b'), 'c', 'parse %20');\n  assert.same(new URLSearchParams('a=b\\0c').get('a'), 'b\\0c', 'parse \\\\0');\n  assert.same(new URLSearchParams('a\\0b=c').get('a\\0b'), 'c', 'parse \\\\0');\n  assert.same(new URLSearchParams('a=b%2Bc').get('a'), 'b+c', 'parse %2B');\n  assert.same(new URLSearchParams('a%2Bb=c').get('a+b'), 'c', 'parse %2B');\n  assert.same(new URLSearchParams('a=b%00c').get('a'), 'b\\0c', 'parse %00');\n  assert.same(new URLSearchParams('a%00b=c').get('a\\0b'), 'c', 'parse %00');\n  assert.same(new URLSearchParams('a==').get('a'), '=', 'parse =');\n  assert.same(new URLSearchParams('a=b=').get('a'), 'b=', 'parse =');\n  assert.same(new URLSearchParams('a=b=c').get('a'), 'b=c', 'parse =');\n  assert.same(new URLSearchParams('a==b').get('a'), '=b', 'parse =');\n  assert.same(new URLSearchParams('a=b\\u2384').get('a'), 'b\\u2384', 'parse \\\\u2384');\n  assert.same(new URLSearchParams('a\\u2384b=c').get('a\\u2384b'), 'c', 'parse \\\\u2384');\n  assert.same(new URLSearchParams('a=b%e2%8e%84').get('a'), 'b\\u2384', 'parse %e2%8e%84');\n  assert.same(new URLSearchParams('a%e2%8e%84b=c').get('a\\u2384b'), 'c', 'parse %e2%8e%84');\n  assert.same(new URLSearchParams('a=b\\uD83D\\uDCA9c').get('a'), 'b\\uD83D\\uDCA9c', 'parse \\\\uD83D\\\\uDCA9');\n  assert.same(new URLSearchParams('a\\uD83D\\uDCA9b=c').get('a\\uD83D\\uDCA9b'), 'c', 'parse \\\\uD83D\\\\uDCA9');\n  assert.same(new URLSearchParams('a=b%f0%9f%92%a9c').get('a'), 'b\\uD83D\\uDCA9c', 'parse %f0%9f%92%a9');\n  assert.same(new URLSearchParams('a%f0%9f%92%a9b=c').get('a\\uD83D\\uDCA9b'), 'c', 'parse %f0%9f%92%a9');\n  assert.same(new URLSearchParams('=').get(''), '', 'parse =');\n  assert.throws(() => {\n    return new URLSearchParams('').get();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#getAll","suites":[],"line":290,"code":"QUnit.test('URLSearchParams#getAll', assert => {\n  const {\n    getAll\n  } = URLSearchParams.prototype;\n  assert.isFunction(getAll);\n  assert.arity(getAll, 1);\n  assert.name(getAll, 'getAll');\n  assert.enumerable(URLSearchParams.prototype, 'getAll');\n  if (!NODE) assert.looksNative(getAll);\n  let params = new URLSearchParams('a=b&c=d');\n  assert.arrayEqual(params.getAll('a'), ['b']);\n  assert.arrayEqual(params.getAll('c'), ['d']);\n  assert.arrayEqual(params.getAll('e'), []);\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.arrayEqual(params.getAll('a'), ['b', 'e']);\n  params = new URLSearchParams('=b&c=d');\n  assert.arrayEqual(params.getAll(''), ['b']);\n  params = new URLSearchParams('a=&c=d&a=e');\n  assert.arrayEqual(params.getAll('a'), ['', 'e']);\n  params = new URLSearchParams('a=1&a=2&a=3&a');\n  assert.arrayEqual(params.getAll('a'), ['1', '2', '3', ''], 'search params object has expected name \"a\" values');\n  params.set('a', 'one');\n  assert.arrayEqual(params.getAll('a'), ['one'], 'search params object has expected name \"a\" values');\n  assert.throws(() => {\n    return new URLSearchParams('').getAll();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#has","suites":[],"line":317,"code":"QUnit.test('URLSearchParams#has', assert => {\n  const {\n    has\n  } = URLSearchParams.prototype;\n  assert.isFunction(has);\n  assert.arity(has, 1);\n  assert.name(has, 'has');\n  assert.enumerable(URLSearchParams.prototype, 'has');\n  if (!NODE) assert.looksNative(has);\n  let params = new URLSearchParams('a=b&c=d');\n  assert.true(params.has('a'));\n  assert.true(params.has('c'));\n  assert.false(params.has('e'));\n  params = new URLSearchParams('a=b&c=d&a=e');\n  assert.true(params.has('a'));\n  params = new URLSearchParams('=b&c=d');\n  assert.true(params.has(''));\n  params = new URLSearchParams('null=a');\n  assert.true(params.has(null));\n  params = new URLSearchParams('a=b&c=d&&');\n  params.append('first', 1);\n  params.append('first', 2);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.true(params.has('c'), 'search params object has name \"c\"');\n  assert.true(params.has('first'), 'search params object has name \"first\"');\n  assert.false(params.has('d'), 'search params object has no name \"d\"');\n  params.delete('first');\n  assert.false(params.has('first'), 'search params object has no name \"first\"');\n  assert.throws(() => {\n    return new URLSearchParams('').has();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#set","suites":[],"line":349,"code":"QUnit.test('URLSearchParams#set', assert => {\n  const {\n    set\n  } = URLSearchParams.prototype;\n  assert.isFunction(set);\n  assert.arity(set, 2);\n  assert.name(set, 'set');\n  assert.enumerable(URLSearchParams.prototype, 'set');\n  if (!NODE) assert.looksNative(set);\n  let params = new URLSearchParams('a=b&c=d');\n  params.set('a', 'B');\n  assert.same(String(params), 'a=B&c=d');\n  params = new URLSearchParams('a=b&c=d&a=e');\n  params.set('a', 'B');\n  assert.same(String(params), 'a=B&c=d');\n  params.set('e', 'f');\n  assert.same(String(params), 'a=B&c=d&e=f');\n  params = new URLSearchParams('a=1&a=2&a=3');\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '1', 'search params object has name \"a\" with value \"1\"');\n  params.set('first', 4);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '1', 'search params object has name \"a\" with value \"1\"');\n  assert.same(String(params), 'a=1&a=2&a=3&first=4');\n  params.set('a', 4);\n  assert.true(params.has('a'), 'search params object has name \"a\"');\n  assert.same(params.get('a'), '4', 'search params object has name \"a\" with value \"4\"');\n  assert.same(String(params), 'a=4&first=4');\n  assert.throws(() => {\n    return new URLSearchParams('').set();\n  }, 'throws w/o arguments');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#sort","suites":[],"line":381,"code":"QUnit.test('URLSearchParams#sort', assert => {\n  const {\n    sort\n  } = URLSearchParams.prototype;\n  assert.isFunction(sort);\n  assert.arity(sort, 0);\n  assert.name(sort, 'sort');\n  assert.enumerable(URLSearchParams.prototype, 'sort');\n  if (!NODE) assert.looksNative(sort);\n  let params = new URLSearchParams('a=1&b=4&a=3&b=2');\n  params.sort();\n  assert.same(String(params), 'a=1&a=3&b=4&b=2');\n  params.delete('a');\n  params.append('a', '0');\n  params.append('b', '0');\n  params.sort();\n  assert.same(String(params), 'a=0&b=4&b=2&b=0');\n  const testData = [{\n    input: 'z=b&a=b&z=a&a=a',\n    output: [['a', 'b'], ['a', 'a'], ['z', 'b'], ['z', 'a']]\n  }, {\n    input: '\\uFFFD=x&\\uFFFC&\\uFFFD=a',\n    output: [['\\uFFFC', ''], ['\\uFFFD', 'x'], ['\\uFFFD', 'a']]\n  }, {\n    input: 'ﬃ&🌈',\n    // 🌈 > code point, but < code unit because two code units\n    output: [['🌈', ''], ['ﬃ', '']]\n  }, {\n    input: 'é&e\\uFFFD&e\\u0301',\n    output: [['e\\u0301', ''], ['e\\uFFFD', ''], ['é', '']]\n  }, {\n    input: 'z=z&a=a&z=y&a=b&z=x&a=c&z=w&a=d&z=v&a=e&z=u&a=f&z=t&a=g',\n    output: [['a', 'a'], ['a', 'b'], ['a', 'c'], ['a', 'd'], ['a', 'e'], ['a', 'f'], ['a', 'g'], ['z', 'z'], ['z', 'y'], ['z', 'x'], ['z', 'w'], ['z', 'v'], ['z', 'u'], ['z', 't']]\n  }, {\n    input: 'bbb&bb&aaa&aa=x&aa=y',\n    output: [['aa', 'x'], ['aa', 'y'], ['aaa', ''], ['bb', ''], ['bbb', '']]\n  }, {\n    input: 'z=z&=f&=t&=x',\n    output: [['', 'f'], ['', 't'], ['', 'x'], ['z', 'z']]\n  }, {\n    input: 'a🌈&a💩',\n    output: [['a🌈', ''], ['a💩', '']]\n  }];\n\n  for (const {\n    input,\n    output\n  } of testData) {\n    let i = 0;\n    params = new URLSearchParams(input);\n    params.sort();\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey);\n      assert.same(value, reqValue);\n    });\n    i = 0;\n    const url = new URL(`?${input}`, 'https://example/');\n    params = url.searchParams;\n    params.sort();\n    params.forEach((value, key) => {\n      const [reqKey, reqValue] = output[i++];\n      assert.same(key, reqKey);\n      assert.same(value, reqValue);\n    });\n  }\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://example.com/?');\n    url.searchParams.sort();\n    assert.same(url.href, 'http://example.com/', 'Sorting non-existent params removes ? from URL');\n    assert.same(url.search, '', 'Sorting non-existent params removes ? from URL');\n  }\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#toString","suites":[],"line":455,"code":"QUnit.test('URLSearchParams#toString', assert => {\n  const {\n    toString\n  } = URLSearchParams.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  if (!NODE) assert.looksNative(toString);\n  let params = new URLSearchParams();\n  params.append('a', 'b c');\n  assert.same(String(params), 'a=b+c');\n  params.delete('a');\n  params.append('a b', 'c');\n  assert.same(String(params), 'a+b=c');\n  params = new URLSearchParams();\n  params.append('a', '');\n  assert.same(String(params), 'a=');\n  params.append('a', '');\n  assert.same(String(params), 'a=&a=');\n  params.append('', 'b');\n  assert.same(String(params), 'a=&a=&=b');\n  params.append('', '');\n  assert.same(String(params), 'a=&a=&=b&=');\n  params.append('', '');\n  assert.same(String(params), 'a=&a=&=b&=&=');\n  params = new URLSearchParams();\n  params.append('', 'b');\n  assert.same(String(params), '=b');\n  params.append('', 'b');\n  assert.same(String(params), '=b&=b');\n  params = new URLSearchParams();\n  params.append('', '');\n  assert.same(String(params), '=');\n  params.append('', '');\n  assert.same(String(params), '=&=');\n  params = new URLSearchParams();\n  params.append('a', 'b+c');\n  assert.same(String(params), 'a=b%2Bc');\n  params.delete('a');\n  params.append('a+b', 'c');\n  assert.same(String(params), 'a%2Bb=c');\n  params = new URLSearchParams();\n  params.append('=', 'a');\n  assert.same(String(params), '%3D=a');\n  params.append('b', '=');\n  assert.same(String(params), '%3D=a&b=%3D');\n  params = new URLSearchParams();\n  params.append('&', 'a');\n  assert.same(String(params), '%26=a');\n  params.append('b', '&');\n  assert.same(String(params), '%26=a&b=%26');\n  params = new URLSearchParams();\n  params.append('a', '\\r');\n  assert.same(String(params), 'a=%0D');\n  params = new URLSearchParams();\n  params.append('a', '\\n');\n  assert.same(String(params), 'a=%0A');\n  params = new URLSearchParams();\n  params.append('a', '\\r\\n');\n  assert.same(String(params), 'a=%0D%0A');\n  params = new URLSearchParams();\n  params.append('a', 'b%c');\n  assert.same(String(params), 'a=b%25c');\n  params.delete('a');\n  params.append('a%b', 'c');\n  assert.same(String(params), 'a%25b=c');\n  params = new URLSearchParams();\n  params.append('a', 'b\\0c');\n  assert.same(String(params), 'a=b%00c');\n  params.delete('a');\n  params.append('a\\0b', 'c');\n  assert.same(String(params), 'a%00b=c');\n  params = new URLSearchParams();\n  params.append('a', 'b\\uD83D\\uDCA9c');\n  assert.same(String(params), 'a=b%F0%9F%92%A9c');\n  params.delete('a');\n  params.append('a\\uD83D\\uDCA9b', 'c');\n  assert.same(String(params), 'a%F0%9F%92%A9b=c');\n  params = new URLSearchParams('a=b&c=d&&e&&');\n  assert.same(String(params), 'a=b&c=d&e=');\n  params = new URLSearchParams('a = b &a=b&c=d%20');\n  assert.same(String(params), 'a+=+b+&a=b&c=d+');\n  params = new URLSearchParams('a=&a=b');\n  assert.same(String(params), 'a=&a=b');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#forEach","suites":[],"line":540,"code":"QUnit.test('URLSearchParams#forEach', assert => {\n  const {\n    forEach\n  } = URLSearchParams.prototype;\n  assert.isFunction(forEach);\n  assert.arity(forEach, 1);\n  assert.name(forEach, 'forEach');\n  assert.enumerable(URLSearchParams.prototype, 'forEach');\n  if (!NODE) assert.looksNative(forEach);\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let result = '';\n  params.forEach((value, key, that) => {\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    assert.same(that, params);\n    result += key;\n  });\n  assert.same(result, 'abc');\n  new URL('http://a.b/c').searchParams.forEach(() => {\n    assert.avoid();\n  }); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    params = url.searchParams;\n    result = '';\n    params.forEach((val, key) => {\n      url.search = 'x=1&y=2&z=3';\n      result += key + val;\n    });\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  result = '';\n  params.forEach((value, key) => {\n    params.delete('b');\n    result += key + value;\n  });\n  assert.same(result, 'a1c3');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#entries","suites":[],"line":587,"code":"QUnit.test('URLSearchParams#entries', assert => {\n  const {\n    entries\n  } = URLSearchParams.prototype;\n  assert.isFunction(entries);\n  assert.arity(entries, 0);\n  assert.name(entries, 'entries');\n  assert.enumerable(URLSearchParams.prototype, 'entries');\n  if (!NODE) assert.looksNative(entries);\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let iterator = params.entries();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    const [key, value] = entry.value;\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    result += key;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams.entries().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams.entries();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const [key, value] = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key + value;\n    }\n\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.entries();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const [key, value] = entry.value;\n    result += key + value;\n  }\n\n  assert.same(result, 'a1c3');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().entries()), 'next').enumerable, 'enumerable .next');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#keys","suites":[],"line":644,"code":"QUnit.test('URLSearchParams#keys', assert => {\n  const {\n    keys\n  } = URLSearchParams.prototype;\n  assert.isFunction(keys);\n  assert.arity(keys, 0);\n  assert.name(keys, 'keys');\n  assert.enumerable(URLSearchParams.prototype, 'keys');\n  if (!NODE) assert.looksNative(keys);\n  let iterator = new URLSearchParams('a=1&b=2&c=3').keys();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    result += entry.value;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams.keys().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams.keys();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const key = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key;\n    }\n\n    assert.same(result, 'ayz');\n  } // fails in Chrome 66-\n\n\n  const params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.keys();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const key = entry.value;\n    result += key;\n  }\n\n  assert.same(result, 'ac');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().keys()), 'next').enumerable, 'enumerable .next');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#values","suites":[],"line":692,"code":"QUnit.test('URLSearchParams#values', assert => {\n  const {\n    values\n  } = URLSearchParams.prototype;\n  assert.isFunction(values);\n  assert.arity(values, 0);\n  assert.name(values, 'values');\n  assert.enumerable(URLSearchParams.prototype, 'values');\n  if (!NODE) assert.looksNative(values);\n  let iterator = new URLSearchParams('a=1&b=2&c=3').values();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    result += entry.value;\n  }\n\n  assert.same(result, '123');\n  assert.true(new URL('http://a.b/c').searchParams.values().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=a&b=b&c=c&d=d');\n    iterator = url.searchParams.keys();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const {\n        value\n      } = entry;\n      url.search = 'x=x&y=y&z=z';\n      result += value;\n    }\n\n    assert.same(result, 'ayz');\n  } // fails in Chrome 66-\n\n\n  const params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params.values();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const key = entry.value;\n    result += key;\n  }\n\n  assert.same(result, '13');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams().values()), 'next').enumerable, 'enumerable .next');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#@@iterator","suites":[],"line":742,"code":"QUnit.test('URLSearchParams#@@iterator', assert => {\n  const entries = URLSearchParams.prototype[Symbol.iterator];\n  assert.isFunction(entries);\n  assert.arity(entries, 0);\n  assert.name(entries, 'entries');\n  if (!NODE) assert.looksNative(entries);\n  assert.same(entries, URLSearchParams.prototype.entries);\n  const expectedValues = {\n    a: '1',\n    b: '2',\n    c: '3'\n  };\n  let params = new URLSearchParams('a=1&b=2&c=3');\n  let iterator = params[Symbol.iterator]();\n  let result = '';\n  let entry;\n\n  while (!(entry = iterator.next()).done) {\n    const [key, value] = entry.value;\n    assert.same(params.get(key), expectedValues[key]);\n    assert.same(value, expectedValues[key]);\n    result += key;\n  }\n\n  assert.same(result, 'abc');\n  assert.true(new URL('http://a.b/c').searchParams[Symbol.iterator]().next().done, 'should be finished'); // fails in Chrome 66-\n\n  if (DESCRIPTORS) {\n    const url = new URL('http://a.b/c?a=1&b=2&c=3&d=4');\n    iterator = url.searchParams[Symbol.iterator]();\n    result = '';\n\n    while (!(entry = iterator.next()).done) {\n      const [key, value] = entry.value;\n      url.search = 'x=1&y=2&z=3';\n      result += key + value;\n    }\n\n    assert.same(result, 'a1y2z3');\n  } // fails in Chrome 66-\n\n\n  params = new URLSearchParams('a=1&b=2&c=3');\n  iterator = params[Symbol.iterator]();\n  result = '';\n\n  while (!(entry = iterator.next()).done) {\n    params.delete('b');\n    const [key, value] = entry.value;\n    result += key + value;\n  }\n\n  assert.same(result, 'a1c3');\n  if (DESCRIPTORS) assert.true(getOwnPropertyDescriptor(getPrototypeOf(new URLSearchParams()[Symbol.iterator]()), 'next').enumerable, 'enumerable .next');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams#@@toStringTag","suites":[],"line":797,"code":"QUnit.test('URLSearchParams#@@toStringTag', assert => {\n  const params = new URLSearchParams('a=b');\n  assert.same({}.toString.call(params), '[object URLSearchParams]');\n});","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URLSearchParams with Request","suites":[],"line":803,"code":"  QUnit.test('URLSearchParams with Request', assert => {\n    new Request('#', {\n      body: new URLSearchParams({\n        foo: 'baz'\n      }),\n      method: 'POST'\n    }).text().then(text => {\n      assert.same(text, 'foo=baz');\n    }).then(assert.async());\n  });","file":"tests/web.url-search-params.js","skipped":false,"dir":"tests"},{"name":"URL constructor","suites":[],"line":9,"code":"QUnit.test('URL constructor', assert => {\n  assert.isFunction(URL);\n  if (!NODE) assert.arity(URL, 1);\n  assert.name(URL, 'URL');\n  if (!NODE) assert.looksNative(URL);\n  assert.same(String(new URL('http://www.domain.com/a/b')), 'http://www.domain.com/a/b');\n  assert.same(String(new URL('/c/d', 'http://www.domain.com/a/b')), 'http://www.domain.com/c/d');\n  assert.same(String(new URL('b/c', 'http://www.domain.com/a/b')), 'http://www.domain.com/a/b/c');\n  assert.same(String(new URL('b/c', new URL('http://www.domain.com/a/b'))), 'http://www.domain.com/a/b/c');\n  assert.same(String(new URL({\n    toString: () => 'https://example.org/'\n  })), 'https://example.org/');\n  assert.same(String(new URL('nonspecial://example.com/')), 'nonspecial://example.com/');\n  assert.same(String(new URL('https://測試')), 'https://xn--g6w251d/', 'unicode parsing');\n  assert.same(String(new URL('https://xxпривет.тест')), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n  assert.same(String(new URL('https://xxПРИВЕТ.тест')), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n  assert.same(String(new URL('http://Example.com/', 'https://example.org/')), 'http://example.com/');\n  assert.same(String(new URL('https://Example.com/', 'https://example.org/')), 'https://example.com/');\n  assert.same(String(new URL('nonspecial://Example.com/', 'https://example.org/')), 'nonspecial://Example.com/');\n  assert.same(String(new URL('http:Example.com/', 'https://example.org/')), 'http://example.com/');\n  assert.same(String(new URL('https:Example.com/', 'https://example.org/')), 'https://example.org/Example.com/');\n  assert.same(String(new URL('nonspecial:Example.com/', 'https://example.org/')), 'nonspecial:Example.com/');\n  assert.same(String(new URL('http://0300.168.0xF0')), 'http://192.168.0.240/');\n  assert.same(String(new URL('http://[20:0:0:1:0:0:0:ff]')), 'http://[20:0:0:1::ff]/'); // assert.same(String(new URL('http://257.168.0xF0')), 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // TypeError in Chrome and Safari\n\n  assert.same(String(new URL('http://0300.168.0xG0')), 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n  assert.same(String(new URL('file:///var/log/system.log')), 'file:///var/log/system.log', 'file scheme'); // assert.same(String(new URL('file://nnsc.nsf.net/bar/baz')), 'file://nnsc.nsf.net/bar/baz', 'file scheme'); // 'file:///bar/baz' in FF\n  // assert.same(String(new URL('file://localhost/bar/baz')), 'file:///bar/baz', 'file scheme'); // 'file://localhost/bar/baz' in Chrome\n\n  assert.throws(() => new URL(), 'TypeError: Failed to construct \\'URL\\': 1 argument required, but only 0 present.');\n  assert.throws(() => new URL(''), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('', 'about:blank'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('abc'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('//abc'), 'TypeError: Failed to construct \\'URL\\': Invalid URL');\n  assert.throws(() => new URL('http:///www.domain.com/', 'abc'), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('http:///www.domain.com/', null), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('//abc', null), 'TypeError: Failed to construct \\'URL\\': Invalid base URL');\n  assert.throws(() => new URL('http://[20:0:0:1:0:0:0:ff'), 'incorrect IPv6');\n  assert.throws(() => new URL('http://[20:0:0:1:0:0:0:fg]'), 'incorrect IPv6'); // assert.throws(() => new URL('http://a%b'), 'forbidden host code point'); // no error in FF\n\n  assert.throws(() => new URL('1http://zloirock.ru'), 'incorrect scheme');\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#href","suites":[],"line":51,"code":"QUnit.test('URL#href', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'href'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'href');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.href, 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.href, 'http://zloirock.ru/?foo=bar');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://測試';\n    assert.same(url.href, 'https://xn--g6w251d/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--g6w251d/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://xxпривет.тест';\n    assert.same(url.href, 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.href = 'https://xxПРИВЕТ.тест';\n    assert.same(url.href, 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    assert.same(String(url), 'https://xn--xx-flcmn5bht.xn--e1aybc/', 'unicode parsing');\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://0300.168.0xF0';\n    assert.same(url.href, 'http://192.168.0.240/');\n    assert.same(String(url), 'http://192.168.0.240/');\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://[20:0:0:1:0:0:0:ff]';\n    assert.same(url.href, 'http://[20:0:0:1::ff]/');\n    assert.same(String(url), 'http://[20:0:0:1::ff]/'); // url = new URL('http://zloirock.ru/');\n    // url.href = 'http://257.168.0xF0'; // TypeError and Safari\n    // assert.same(url.href, 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // `F` instead of `f` in Chrome\n    // assert.same(String(url), 'http://257.168.0xf0/', 'incorrect IPv4 parsed as host'); // `F` instead of `f` in Chrome\n\n    url = new URL('http://zloirock.ru/');\n    url.href = 'http://0300.168.0xG0';\n    assert.same(url.href, 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n    assert.same(String(url), 'http://0300.168.0xg0/', 'incorrect IPv4 parsed as host');\n    url = new URL('http://192.168.0.240/');\n    url.href = 'file:///var/log/system.log';\n    assert.same(url.href, 'file:///var/log/system.log', 'file -> ip');\n    assert.same(String(url), 'file:///var/log/system.log', 'file -> ip');\n    url = new URL('file:///var/log/system.log');\n    url.href = 'http://0300.168.0xF0';\n    assert.same(url.href, 'http://192.168.0.240/', 'file -> http');\n    assert.same(String(url), 'http://192.168.0.240/', 'file -> http'); // assert.throws(() => new URL('http://zloirock.ru/').href = undefined, 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'abc', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '//abc', 'incorrect URL'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://[20:0:0:1:0:0:0:ff', 'incorrect IPv6'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://[20:0:0:1:0:0:0:fg]', 'incorrect IPv6'); // no error in Chrome\n    // assert.throws(() => new URL('http://zloirock.ru/').href = 'http://a%b', 'forbidden host code point'); // no error in Chrome and FF\n    // assert.throws(() => new URL('http://zloirock.ru/').href = '1http://zloirock.ru', 'incorrect scheme'); // no error in Chrome\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#origin","suites":[],"line":113,"code":"QUnit.test('URL#origin', assert => {\n  const url = new URL('http://es6.zloirock.ru/tests.html');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'origin'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'origin');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n  }\n\n  assert.same(url.origin, 'http://es6.zloirock.ru');\n  assert.same(new URL('https://測試/tests').origin, 'https://xn--g6w251d');\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#protocol","suites":[],"line":127,"code":"QUnit.test('URL#protocol', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'protocol'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'protocol');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.protocol, 'http:');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.protocol = 'https';\n    assert.same(url.protocol, 'https:');\n    assert.same(String(url), 'https://zloirock.ru/'); // https://nodejs.org/api/url.html#url_special_schemes\n    // url = new URL('http://zloirock.ru/');\n    // url.protocol = 'fish';\n    // assert.same(url.protocol, 'http:');\n    // assert.same(url.href, 'http://zloirock.ru/');\n    // assert.same(String(url), 'http://zloirock.ru/');\n\n    url = new URL('http://zloirock.ru/');\n    url.protocol = '1http';\n    assert.same(url.protocol, 'http:');\n    assert.same(url.href, 'http://zloirock.ru/', 'incorrect scheme');\n    assert.same(String(url), 'http://zloirock.ru/', 'incorrect scheme');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#username","suites":[],"line":159,"code":"QUnit.test('URL#username', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'username'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'username');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.username, '');\n  url = new URL('http://username@zloirock.ru/');\n  assert.same(url.username, 'username');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.username = 'username';\n    assert.same(url.username, 'username');\n    assert.same(String(url), 'http://username@zloirock.ru/');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#password","suites":[],"line":182,"code":"QUnit.test('URL#password', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'password'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'password');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.password, '');\n  url = new URL('http://username:password@zloirock.ru/');\n  assert.same(url.password, 'password'); // url = new URL('http://:password@zloirock.ru/'); // TypeError in FF\n  // assert.same(url.password, 'password');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.username = 'username';\n    url.password = 'password';\n    assert.same(url.password, 'password');\n    assert.same(String(url), 'http://username:password@zloirock.ru/'); // url = new URL('http://zloirock.ru/');\n    // url.password = 'password';\n    // assert.same(url.password, 'password'); // '' in FF\n    // assert.same(String(url), 'http://:password@zloirock.ru/'); // 'http://zloirock.ru/' in FF\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#host","suites":[],"line":210,"code":"QUnit.test('URL#host', assert => {\n  let url = new URL('http://zloirock.ru:81/path');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'host'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'host');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.host, 'zloirock.ru:81');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru:81/path');\n    url.host = 'example.com:82';\n    assert.same(url.host, 'example.com:82');\n    assert.same(String(url), 'http://example.com:82/path'); // url = new URL('http://zloirock.ru:81/path');\n    // url.host = 'other?domain.com';\n    // assert.same(String(url), 'http://other:81/path'); // 'http://other/?domain.com/path' in Safari\n\n    url = new URL('https://www.mydomain.com:8080/path/');\n    url.host = 'www.otherdomain.com:80';\n    assert.same(url.href, 'https://www.otherdomain.com:80/path/', 'set default port for another protocol'); // url = new URL('https://www.mydomain.com:8080/path/');\n    // url.host = 'www.otherdomain.com:443';\n    // assert.same(url.href, 'https://www.otherdomain.com/path/', 'set default port');\n\n    url = new URL('http://zloirock.ru/foo');\n    url.host = '測試';\n    assert.same(url.host, 'xn--g6w251d', 'unicode parsing');\n    assert.same(String(url), 'http://xn--g6w251d/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = 'xxпривет.тест';\n    assert.same(url.host, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = 'xxПРИВЕТ.тест';\n    assert.same(url.host, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.host = '0300.168.0xF0';\n    assert.same(url.host, '192.168.0.240');\n    assert.same(String(url), 'http://192.168.0.240/foo'); // url = new URL('http://zloirock.ru/foo');\n    // url.host = '[20:0:0:1:0:0:0:ff]';\n    // assert.same(url.host, '[20:0:0:1::ff]'); // ':0' in Chrome, 'zloirock.ru' in Safari\n    // assert.same(String(url), 'http://[20:0:0:1::ff]/foo'); // 'http://[20:0/foo' in Chrome, 'http://zloirock.ru/foo' in Safari\n    // url = new URL('file:///var/log/system.log');\n    // url.host = 'nnsc.nsf.net'; // does not work in FF\n    // assert.same(url.hostname, 'nnsc.nsf.net', 'file');\n    // assert.same(String(url), 'file://nnsc.nsf.net/var/log/system.log', 'file');\n    // url = new URL('http://zloirock.ru/');\n    // url.host = '[20:0:0:1:0:0:0:ff';\n    // assert.same(url.host, 'zloirock.ru', 'incorrect IPv6'); // ':0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.host = '[20:0:0:1:0:0:0:fg]';\n    // assert.same(url.host, 'zloirock.ru', 'incorrect IPv6'); // ':0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.host = 'a%b';\n    // assert.same(url.host, 'zloirock.ru', 'forbidden host code point'); // '' in Chrome, 'a%b' in FF\n    // assert.same(String(url), 'http://zloirock.ru/', 'forbidden host code point'); // 'http://a%25b/' in Chrome, 'http://a%b/' in FF\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#hostname","suites":[],"line":275,"code":"QUnit.test('URL#hostname', assert => {\n  let url = new URL('http://zloirock.ru:81/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'hostname'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'hostname');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.hostname, 'zloirock.ru');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru:81/');\n    url.hostname = 'example.com';\n    assert.same(url.hostname, 'example.com');\n    assert.same(String(url), 'http://example.com:81/'); // url = new URL('http://zloirock.ru:81/');\n    // url.hostname = 'example.com:82';\n    // assert.same(url.hostname, 'example.com'); // '' in Chrome\n    // assert.same(String(url), 'http://example.com:81/'); // 'http://example.com:82:81/' in Chrome\n\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = '測試';\n    assert.same(url.hostname, 'xn--g6w251d', 'unicode parsing');\n    assert.same(String(url), 'http://xn--g6w251d/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = 'xxпривет.тест';\n    assert.same(url.hostname, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = 'xxПРИВЕТ.тест';\n    assert.same(url.hostname, 'xn--xx-flcmn5bht.xn--e1aybc', 'unicode parsing');\n    assert.same(String(url), 'http://xn--xx-flcmn5bht.xn--e1aybc/foo', 'unicode parsing');\n    url = new URL('http://zloirock.ru/foo');\n    url.hostname = '0300.168.0xF0';\n    assert.same(url.hostname, '192.168.0.240');\n    assert.same(String(url), 'http://192.168.0.240/foo'); // url = new URL('http://zloirock.ru/foo');\n    // url.hostname = '[20:0:0:1:0:0:0:ff]';\n    // assert.same(url.hostname, '[20:0:0:1::ff]'); // 'zloirock.ru' in Safari\n    // assert.same(String(url), 'http://[20:0:0:1::ff]/foo'); // 'http://zloirock.ru/foo' in Safari\n    // url = new URL('file:///var/log/system.log');\n    // url.hostname = 'nnsc.nsf.net'; // does not work in FF\n    // assert.same(url.hostname, 'nnsc.nsf.net', 'file');\n    // assert.same(String(url), 'file://nnsc.nsf.net/var/log/system.log', 'file');\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = '[20:0:0:1:0:0:0:ff';\n    // assert.same(url.hostname, 'zloirock.ru', 'incorrect IPv6'); // '' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0:0:1:0:0:0:ff' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = '[20:0:0:1:0:0:0:fg]';\n    // assert.same(url.hostname, 'zloirock.ru', 'incorrect IPv6'); // '' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru/', 'incorrect IPv6'); // 'http://[20:0:0:1:0:0:0:ff/' in Chrome\n    // url = new URL('http://zloirock.ru/');\n    // url.hostname = 'a%b';\n    // assert.same(url.hostname, 'zloirock.ru', 'forbidden host code point'); // '' in Chrome, 'a%b' in FF\n    // assert.same(String(url), 'http://zloirock.ru/', 'forbidden host code point'); // 'http://a%25b/' in Chrome, 'http://a%b/' in FF\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#port","suites":[],"line":335,"code":"QUnit.test('URL#port', assert => {\n  let url = new URL('http://zloirock.ru:1337/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'port'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'port');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.port, '1337');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.port = 80;\n    assert.same(url.port, '');\n    assert.same(String(url), 'http://zloirock.ru/');\n    url.port = 1337;\n    assert.same(url.port, '1337');\n    assert.same(String(url), 'http://zloirock.ru:1337/'); // url.port = 'abcd';\n    // assert.same(url.port, '1337'); // '0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru:1337/'); // 'http://zloirock.ru:0/' in Chrome\n    // url.port = '5678abcd';\n    // assert.same(url.port, '5678'); // '1337' in FF\n    // assert.same(String(url), 'http://zloirock.ru:5678/'); // 'http://zloirock.ru:1337/\"' in FF\n\n    url.port = 1234.5678;\n    assert.same(url.port, '1234');\n    assert.same(String(url), 'http://zloirock.ru:1234/'); // url.port = 1e10;\n    // assert.same(url.port, '1234'); // '0' in Chrome\n    // assert.same(String(url), 'http://zloirock.ru:1234/'); // 'http://zloirock.ru:0/' in Chrome\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#pathname","suites":[],"line":370,"code":"QUnit.test('URL#pathname', assert => {\n  let url = new URL('http://zloirock.ru/foo/bar');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'pathname'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'pathname');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.pathname, '/foo/bar');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.pathname = 'bar/baz';\n    assert.same(url.pathname, '/bar/baz');\n    assert.same(String(url), 'http://zloirock.ru/bar/baz');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#search","suites":[],"line":391,"code":"QUnit.test('URL#search', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'search'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'search');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.search, '');\n  url = new URL('http://zloirock.ru/?foo=bar');\n  assert.same(url.search, '?foo=bar');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/?');\n    assert.same(url.search, '');\n    assert.same(String(url), 'http://zloirock.ru/?');\n    url.search = 'foo=bar';\n    assert.same(url.search, '?foo=bar');\n    assert.same(String(url), 'http://zloirock.ru/?foo=bar');\n    url.search = '?bar=baz';\n    assert.same(url.search, '?bar=baz');\n    assert.same(String(url), 'http://zloirock.ru/?bar=baz');\n    url.search = '';\n    assert.same(url.search, '');\n    assert.same(String(url), 'http://zloirock.ru/');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#searchParams","suites":[],"line":422,"code":"QUnit.test('URL#searchParams', assert => {\n  let url = new URL('http://zloirock.ru/?foo=bar&bar=baz');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'searchParams'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'searchParams');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n  }\n\n  assert.true(url.searchParams instanceof URLSearchParams);\n  assert.same(url.searchParams.get('foo'), 'bar');\n  assert.same(url.searchParams.get('bar'), 'baz');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/');\n    url.searchParams.append('foo', 'bar');\n    assert.same(String(url), 'http://zloirock.ru/?foo=bar');\n    url = new URL('http://zloirock.ru/');\n    url.search = 'foo=bar';\n    assert.same(url.searchParams.get('foo'), 'bar');\n    url = new URL('http://zloirock.ru/?foo=bar&bar=baz');\n    url.search = '';\n    assert.false(url.searchParams.has('foo'));\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#hash","suites":[],"line":449,"code":"QUnit.test('URL#hash', assert => {\n  let url = new URL('http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    assert.false(hasOwnProperty.call(url, 'hash'));\n    const descriptor = Object.getOwnPropertyDescriptor(URL.prototype, 'hash');\n    assert.true(descriptor.enumerable);\n    assert.true(descriptor.configurable);\n    assert.same(typeof descriptor.get, 'function');\n    assert.same(typeof descriptor.set, 'function');\n  }\n\n  assert.same(url.hash, '');\n  url = new URL('http://zloirock.ru/#foo');\n  assert.same(url.hash, '#foo');\n  url = new URL('http://zloirock.ru/#');\n  assert.same(url.hash, '');\n  assert.same(String(url), 'http://zloirock.ru/#');\n\n  if (DESCRIPTORS) {\n    url = new URL('http://zloirock.ru/#');\n    url.hash = 'foo';\n    assert.same(url.hash, '#foo');\n    assert.same(String(url), 'http://zloirock.ru/#foo');\n    url.hash = '';\n    assert.same(url.hash, '');\n    assert.same(String(url), 'http://zloirock.ru/'); // url.hash = '#';\n    // assert.same(url.hash, '');\n    // assert.same(String(url), 'http://zloirock.ru/'); // 'http://zloirock.ru/#' in FF\n\n    url.hash = '#foo';\n    assert.same(url.hash, '#foo');\n    assert.same(String(url), 'http://zloirock.ru/#foo');\n    url.hash = '#foo#bar';\n    assert.same(url.hash, '#foo#bar');\n    assert.same(String(url), 'http://zloirock.ru/#foo#bar');\n    url = new URL('http://zloirock.ru/');\n    url.hash = 'абa';\n    assert.same(url.hash, '#%D0%B0%D0%B1a'); // url = new URL('http://zloirock.ru/');\n    // url.hash = '\\udc01\\ud802a';\n    // assert.same(url.hash, '#%EF%BF%BD%EF%BF%BDa', 'unmatched surrogates');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#toJSON","suites":[],"line":492,"code":"QUnit.test('URL#toJSON', assert => {\n  const {\n    toJSON\n  } = URL.prototype;\n  assert.isFunction(toJSON);\n  assert.arity(toJSON, 0);\n  assert.name(toJSON, 'toJSON');\n  assert.enumerable(URL.prototype, 'toJSON');\n  if (!NODE) assert.looksNative(toJSON);\n  const url = new URL('http://zloirock.ru/');\n  assert.same(url.toJSON(), 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.toJSON(), 'http://zloirock.ru/?foo=bar');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#toString","suites":[],"line":509,"code":"QUnit.test('URL#toString', assert => {\n  const {\n    toString\n  } = URL.prototype;\n  assert.isFunction(toString);\n  assert.arity(toString, 0);\n  assert.name(toString, 'toString');\n  assert.enumerable(URL.prototype, 'toString');\n  if (!NODE) assert.looksNative(toString);\n  const url = new URL('http://zloirock.ru/');\n  assert.same(url.toString(), 'http://zloirock.ru/');\n\n  if (DESCRIPTORS) {\n    url.searchParams.append('foo', 'bar');\n    assert.same(url.toString(), 'http://zloirock.ru/?foo=bar');\n  }\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL#@@toStringTag","suites":[],"line":526,"code":"QUnit.test('URL#@@toStringTag', assert => {\n  const url = new URL('http://zloirock.ru/');\n  assert.same({}.toString.call(url), '[object URL]');\n});","file":"tests/web.url.js","skipped":false,"dir":"tests"},{"name":"URL.sham","suites":[],"line":530,"code":"QUnit.test('URL.sham', assert => {\n  assert.same(URL.sham, DESCRIPTORS ? undefined : true);\n}); // `core-js` URL implementation pass all (exclude some encoding-related) tests","file":"tests/web.url.js","skipped":false,"dir":"tests"}]}