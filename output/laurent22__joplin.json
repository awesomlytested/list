{"repo":"laurent22/joplin","url":"https://github.com/laurent22/joplin","branch":"dev","configs":[{"package":"joplin","lang":"ts","dir":"packages/app-cli/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@joplin/fork-htmlparser2","lang":"ts","dir":"packages/fork-htmlparser2/src/__tests__","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@joplin/fork-sax","lang":"js","dir":"packages/fork-sax/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@joplin/fork-uslug","lang":"js","dir":"packages/fork-uslug/test","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@joplin/renderer","lang":"js","dir":"packages/renderer/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@joplin/turndown-plugin-gfm","lang":"js","dir":"packages/turndown-plugin-gfm/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@joplin/turndown","lang":"js","dir":"packages/turndown/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should save history when navigating through notes","suites":["feature_NoteHistory"],"updatePoint":{"line":38,"column":54},"line":38,"code":"\tit('should save history when navigating through notes', (async () => {\n\t\t// setup\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\t// let notes1 = await createNTestNotes(5, folders[1]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[3].id });\n\t\tawait testApp.wait();\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[2].id });\n\t\tawait testApp.wait();\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[1].id });\n\t\tawait testApp.wait();\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[0].id });\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[1].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[1].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[4].id });\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[4].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should save history when navigating through notebooks","suites":["feature_NoteHistory"],"updatePoint":{"line":90,"column":58},"line":90,"code":"\tit('should save history when navigating through notebooks', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tconst notes1 = await createNTestNotes(5, folders[1]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[1]) });\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes1[4].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[1].id);\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[4].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes1[4].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[1].id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[4].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should save history when searching for a note","suites":["feature_NoteHistory"],"updatePoint":{"line":130,"column":50},"line":130,"code":"\tit('should save history when searching for a note', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tconst notes1 = await createNTestNotes(5, folders[1]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[1]) });\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\n\t\texpect(state.selectedNoteIds).toEqual([notes1[4].id]); // notes1[4]\n\t\texpect(state.selectedFolderId).toEqual(folders[1].id);\n\n\t\tconst searchId = uuid.create();\n\t\ttestApp.dispatch({\n\t\t\ttype: 'SEARCH_UPDATE',\n\t\t\tsearch: {\n\t\t\t\tid: searchId,\n\t\t\t\ttitle: notes0[0].title,\n\t\t\t\tquery_pattern: notes0[0].title,\n\t\t\t\tquery_folder_id: null,\n\t\t\t\ttype: BaseModel.TYPE_SEARCH,\n\t\t\t},\n\t\t});\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({\n\t\t\ttype: 'SEARCH_SELECT',\n\t\t\tid: searchId,\n\t\t});\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(ids(state.backwardHistoryNotes)).toEqual(ids([notes0[4], notes1[4]]));\n\t\texpect(ids(state.forwardHistoryNotes)).toEqual([]);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should ensure no adjacent duplicates","suites":["feature_NoteHistory"],"updatePoint":{"line":172,"column":41},"line":172,"code":"\tit('should ensure no adjacent duplicates', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tconst notes0 = await createNTestNotes(3, folders[0]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[0].id });\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[1]);\n\t\tawait testApp.wait();\n\t\tgoToNote(testApp, notes0[2]);\n\t\tawait testApp.wait();\n\t\tgoToNote(testApp, notes0[1]);\n\t\tawait testApp.wait();\n\t\tgoToNote(testApp, notes0[2]);\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\ttestApp.dispatch({ type: 'NOTE_DELETE', id: notes0[1].id });\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[0].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should ensure history is not corrupted when notes get deleted.","suites":["feature_NoteHistory"],"updatePoint":{"line":210,"column":67},"line":210,"code":"\tit('should ensure history is not corrupted when notes get deleted.', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes0[0].id });\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[1]);\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[2]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_DELETE', id: notes0[1].id });\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[0].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should ensure history is not corrupted when notes get created.","suites":["feature_NoteHistory"],"updatePoint":{"line":240,"column":67},"line":240,"code":"\tit('should ensure history is not corrupted when notes get created.', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[0]);\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[1]);\n\t\tawait testApp.wait();\n\n\t\tconst newNote = await Note.save({\n\t\t\tparent_id: folders[0].id,\n\t\t\tis_todo: 0,\n\t\t\tbody: 'test',\n\t\t});\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, newNote);\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([newNote.id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoToNote(testApp, notes0[2]);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([newNote.id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[1].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([newNote.id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\t\texpect(state.selectedFolderId).toEqual(folders[0].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should ensure history works when traversing all notes","suites":["feature_NoteHistory"],"updatePoint":{"line":301,"column":58},"line":301,"code":"\tit('should ensure history works when traversing all notes', (async () => {\n\t\tconst folders = await createNTestFolders(2);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tconst notes1 = await createNTestNotes(5, folders[1]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[0]) });\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[0]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'SMART_FILTER_SELECT', id: ALL_NOTES_FILTER_ID });\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds(notes0.concat(notes1)));\n\t\texpect(state.selectedNoteIds).toEqual(ids([notes0[0]]));\n\n\t\tgoToNote(testApp, notes0[2]);\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes0[4]);\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, notes1[2]);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes1[2].id]);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[4].id]);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[0].id]);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[2].id]);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteIds).toEqual([notes0[4].id]);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should ensure history works when traversing through conflict notes","suites":["feature_NoteHistory"],"updatePoint":{"line":359,"column":71},"line":359,"code":"\tit('should ensure history works when traversing through conflict notes', (async () => {\n\t\tconst folders = await createNTestFolders(1);\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(5, folders[0]);\n\t\tawait testApp.wait();\n\n\t\t// create two conflict notes with parent_id folder 1\n\t\tconst note1 = await Note.save({ title: 'note 1', parent_id: folders[0].id, is_conflict: 1 });\n\t\tawait testApp.wait();\n\t\tconst note2 = await Note.save({ title: 'note 2', parent_id: folders[0].id, is_conflict: 1 });\n\t\tawait testApp.wait();\n\n\t\t// Testing history between conflict notes\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: Folder.conflictFolderId() });\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, note1);\n\t\tawait testApp.wait();\n\n\t\tgoToNote(testApp, note2);\n\t\tawait testApp.wait();\n\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note2.id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note1.id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note2.id);\n\n\t\t// Testing history between conflict and non conflict notes.\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: folders[0].id });\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(folders[0].id);\n\t\texpect(state.selectedNoteIds[0]).toBe(notes0[4].id);\n\n\t\tgoBackWard(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note2.id);\n\n\t\tgoForward(state);\n\t\tawait testApp.wait();\n\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(folders[0].id);\n\t\texpect(state.selectedNoteIds[0]).toBe(notes0[4].id);\n\t}));","file":"feature_NoteHistory.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should leave a conflict note in the conflict folder when it modified","suites":["integration_NoteList"],"updatePoint":{"line":26,"column":73},"line":26,"code":"\tit('should leave a conflict note in the conflict folder when it modified', (async () => {\n\t\tconst folder = await Folder.save({ title: 'test' });\n\t\tconst note = await Note.save({ title: 'note 1', parent_id: folder.id, is_conflict: 1 });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: Folder.conflictFolderId() });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT',\tid: note.id });\n\t\tawait testApp.wait();\n\n\t\t// Check that the conflict folder is selected and that the conflict note is inside\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note.id);\n\n\t\tawait Note.save({ id: note.id, title: 'note 1 mod', is_conflict: 1 });\n\t\tawait testApp.wait();\n\n\t\t// Check that the conflict folder is still selected with the note still inside\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedFolderId).toBe(Folder.conflictFolderId());\n\t\texpect(state.selectedNoteIds[0]).toBe(note.id);\n\t}));","file":"feature_NoteList.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should show all notes","suites":["integration_ShowAllNotes"],"updatePoint":{"line":39,"column":26},"line":39,"code":"\tit('should show all notes', (async () => {\n\t\t// setup\n\t\tconst folders = await createNTestFolders(3);\n\t\tFolder.moveToFolder(id(folders[2]), id(folders[1])); // subfolder\n\t\tawait testApp.wait();\n\t\tconst notes0 = await createNTestNotes(3, folders[0]);\n\t\tconst notes1 = await createNTestNotes(3, folders[1]);\n\t\tconst notes2 = await createNTestNotes(3, folders[2]);\n\t\tawait testApp.wait();\n\n\t\t// TEST ACTION: View all-notes\n\t\ttestApp.dispatch({ type: 'SMART_FILTER_SELECT', id: ALL_NOTES_FILTER_ID });\n\t\tawait testApp.wait();\n\n\t\t// check: all the notes are shown\n\t\tconst state = testApp.store().getState();\n\t\texpect(state.notesParentType).toEqual('SmartFilter');\n\t\texpect(state.selectedSmartFilterId).toEqual(ALL_NOTES_FILTER_ID);\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds(notes0.concat(notes1).concat(notes2)));\n\t}));","file":"feature_ShowAllNotes.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should show retain note selection when going from a folder to all-notes","suites":["integration_ShowAllNotes"],"updatePoint":{"line":60,"column":76},"line":60,"code":"\tit('should show retain note selection when going from a folder to all-notes', (async () => {\n\t\t// setup\n\t\tconst folders = await createNTestFolders(2);\n\t\tconst notes0 = await createNTestNotes(3, folders[0]);\n\t\tconst notes1 = await createNTestNotes(3, folders[1]);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: id(folders[1]) });\n\t\tawait testApp.wait();\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT',\tid: id(notes1[1]) });\n\t\tawait testApp.wait();\n\n\t\t// check the state is set up as expected\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.notesParentType).toEqual('Folder');\n\t\texpect(state.selectedFolderId).toEqual(id(folders[1]));\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds(notes1));\n\t\texpect(state.selectedNoteIds).toEqual(ids([notes1[1]]));\n\n\t\t// TEST ACTION: View all-notes\n\t\ttestApp.dispatch({ type: 'SMART_FILTER_SELECT', id: ALL_NOTES_FILTER_ID });\n\t\tawait testApp.wait();\n\n\t\t// check: all the notes are shown\n\t\tstate = testApp.store().getState();\n\t\texpect(state.notesParentType).toEqual('SmartFilter');\n\t\texpect(state.selectedSmartFilterId).toEqual(ALL_NOTES_FILTER_ID);\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds(notes0.concat(notes1)));\n\t\texpect(state.selectedNoteIds).toEqual(ids([notes1[1]]));\n\t}));","file":"feature_ShowAllNotes.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should support note duplication","suites":["integration_ShowAllNotes"],"updatePoint":{"line":91,"column":36},"line":91,"code":"\tit('should support note duplication', (async () => {\n\t\t// setup\n\t\tconst folder1 = await Folder.save({ title: 'folder1' });\n\t\tconst folder2 = await Folder.save({ title: 'folder2' });\n\t\tconst note1 = await Note.save({ title: 'note1', parent_id: folder1.id });\n\t\tconst note2 = await Note.save({ title: 'note2', parent_id: folder2.id });\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: folder1.id }); // active folder\n\t\tawait time.msleep(100);\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT',\tid: note1.id });\n\t\tawait time.msleep(100);\n\t\ttestApp.dispatch({ type: 'SMART_FILTER_SELECT', id: ALL_NOTES_FILTER_ID });\n\t\tawait time.msleep(100);\n\n\t\t// check the state is set up as expected\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.notesParentType).toEqual('SmartFilter');\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds([note1, note2]));\n\n\t\t// TEST ACTION: duplicate a note from the active folder\n\t\tconst newNote1 = await Note.duplicate(note1.id);\n\t\tawait time.msleep(100);\n\n\t\t// check the note is duplicated and the view updated\n\t\tstate = testApp.store().getState();\n\t\texpect(state.notes.length).toEqual(3);\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds([note1, note2, newNote1]));\n\n\t\t// TEST ACTION: duplicate a note from a non-active folder\n\t\tconst newNote2 = await Note.duplicate(note2.id);\n\t\tawait time.msleep(100);\n\n\t\t// check the note is duplicated and the view updated\n\t\tstate = testApp.store().getState();\n\t\texpect(state.notes.length).toEqual(4);\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds([note1, note2, newNote1, newNote2]));\n\t}));","file":"feature_ShowAllNotes.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should support changing the note parent","suites":["integration_ShowAllNotes"],"updatePoint":{"line":128,"column":44},"line":128,"code":"\tit('should support changing the note parent', (async () => {\n\t\t// setup\n\t\tconst folder1 = await Folder.save({ title: 'folder1' });\n\t\tconst folder2 = await Folder.save({ title: 'folder2' });\n\t\tconst note1 = await Note.save({ title: 'note1', parent_id: folder1.id });\n\t\tconst note2 = await Note.save({ title: 'note1', parent_id: folder2.id });\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: folder1.id }); // active folder\n\t\tawait time.msleep(100);\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT',\tid: note1.id });\n\t\tawait time.msleep(100);\n\t\ttestApp.dispatch({ type: 'SMART_FILTER_SELECT', id: ALL_NOTES_FILTER_ID });\n\t\tawait time.msleep(100);\n\n\t\t// check the state is set up as expected\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.notesParentType).toEqual('SmartFilter');\n\t\texpect(sortedIds(state.notes)).toEqual(sortedIds([note1, note2]));\n\t\texpect(note1.parent_id).toEqual(folder1.id);\n\n\t\t// TEST ACTION: change the notes parent\n\t\tawait Note.moveToFolder(note1.id, folder2.id);\n\t\tawait time.msleep(100);\n\n\t\t// check the note is duplicated and the view updated\n\t\tstate = testApp.store().getState();\n\t\texpect(state.notes.length).toEqual(2);\n\t\tlet n1 = await Note.load(note1.id);\n\t\texpect(n1.parent_id).toEqual(folder2.id);\n\n\t\t// TEST ACTION: change the notes parent\n\t\tawait Note.moveToFolder(note1.id, folder1.id);\n\t\tawait time.msleep(100);\n\n\t\t// check the note is duplicated and the view updated\n\t\tstate = testApp.store().getState();\n\t\texpect(state.notes.length).toEqual(2);\n\t\tn1 = await Note.load(note1.id);\n\t\texpect(n1.parent_id).toEqual(folder1.id);\n\t}));","file":"feature_ShowAllNotes.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should clear tag list when a note is deleted","suites":["integration_TagList"],"updatePoint":{"line":26,"column":49},"line":26,"code":"\tit('should clear tag list when a note is deleted', (async () => {\n\t\t// setup and select the note\n\t\tconst folders = await createNTestFolders(1);\n\t\tconst notes = await createNTestNotes(5, folders[0]);\n\t\tconst tags = await createNTestTags(3);\n\t\tawait testApp.wait();\n\n\t\tawait Tag.addNote(tags[2].id, notes[2].id);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: folders[0].id });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT',\tid: notes[2].id });\n\t\tawait testApp.wait();\n\n\t\t// check the tag list is correct\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedNoteTags.length).toEqual(1);\n\t\texpect(state.selectedNoteTags[0].id).toEqual(tags[2].id);\n\n\t\t// delete the note\n\t\ttestApp.dispatch({ type: 'NOTE_DELETE',\tid: notes[2].id });\n\t\tawait testApp.wait();\n\n\t\t// check the tag list is updated\n\t\tstate = testApp.store().getState();\n\t\texpect(state.selectedNoteTags.length).toEqual(0);\n\t}));","file":"feature_TagList.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should update tag list when a note is deleted","suites":["integration_TagList"],"updatePoint":{"line":57,"column":50},"line":57,"code":"\tit('should update tag list when a note is deleted', (async () => {\n\t\t// set up and select the note\n\t\tconst folders = await createNTestFolders(1);\n\t\tconst notes = await createNTestNotes(5, folders[0]);\n\t\tconst tags = await createNTestTags(3);\n\t\tawait testApp.wait();\n\n\t\tawait Tag.addNote(tags[1].id, notes[1].id);\n\t\tawait Tag.addNote(tags[0].id, notes[0].id);\n\t\tawait Tag.addNote(tags[2].id, notes[0].id);\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'FOLDER_SELECT', id: folders[0].id });\n\t\tawait testApp.wait();\n\n\t\ttestApp.dispatch({ type: 'NOTE_SELECT', id: notes[1].id\t});\n\t\tawait testApp.wait();\n\n\t\t// check the tag list is correct\n\t\tlet state = testApp.store().getState();\n\t\texpect(state.selectedNoteTags.length).toEqual(1);\n\t\texpect(state.selectedNoteTags[0].id).toEqual(tags[1].id);\n\n\t\t// delete the note\n\t\ttestApp.dispatch({ type: 'NOTE_DELETE',\tid: notes[1].id });\n\t\tawait testApp.wait();\n\n\t\t// check the tag list is updated\n\t\tstate = testApp.store().getState();\n\t\tconst tagIds = state.selectedNoteTags.map(n => n.id).sort();\n\t\tconst expectedTagIds = [tags[0].id, tags[2].id].sort();\n\t\texpect(state.selectedNoteTags.length).toEqual(2);\n\t\texpect(tagIds).toEqual(expectedTagIds);\n\t}));","file":"feature_TagList.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should convert from Html to Html","suites":["HtmlToHtml"],"updatePoint":{"line":23,"column":37},"line":23,"code":"\tit('should convert from Html to Html', (async () => {\n\t\tconst basePath = `${__dirname}/html_to_html`;\n\t\tconst files = await shim.fsDriver().readDirStats(basePath);\n\t\tconst htmlToHtml = new HtmlToHtml();\n\n\t\tfor (let i = 0; i < files.length; i++) {\n\t\t\tconst htmlSourceFilename = files[i].path;\n\t\t\tif (htmlSourceFilename.indexOf('.src.html') < 0) continue;\n\n\t\t\tconst htmlSourceFilePath = `${basePath}/${htmlSourceFilename}`;\n\t\t\tconst htmlDestPath = `${basePath}/${filename(filename(htmlSourceFilePath))}.dest.html`;\n\n\t\t\t// if (htmlSourceFilename !== 'table_with_header.html') continue;\n\n\t\t\tconst htmlToHtmlOptions = {\n\t\t\t\tbodyOnly: true,\n\t\t\t};\n\n\t\t\tconst sourceHtml = await shim.fsDriver().readFile(htmlSourceFilePath);\n\t\t\tlet expectedHtml = await shim.fsDriver().readFile(htmlDestPath);\n\n\t\t\tconst result = await htmlToHtml.render(sourceHtml, null, htmlToHtmlOptions);\n\t\t\tlet actualHtml = result.html;\n\n\t\t\tif (os.EOL === '\\r\\n') {\n\t\t\t\texpectedHtml = expectedHtml.replace(/\\r\\n/g, '\\n');\n\t\t\t\tactualHtml = actualHtml.replace(/\\r\\n/g, '\\n');\n\t\t\t}\n\n\t\t\tif (actualHtml !== expectedHtml) {\n\t\t\t\tconsole.info('');\n\t\t\t\tconsole.info(`Error converting file: ${htmlSourceFilename}`);\n\t\t\t\tconsole.info('--------------------------------- Got:');\n\t\t\t\tconsole.info(actualHtml);\n\t\t\t\tconsole.info('--------------------------------- Raw:');\n\t\t\t\tconsole.info(actualHtml.split('\\n'));\n\t\t\t\tconsole.info('--------------------------------- Expected:');\n\t\t\t\tconsole.info(expectedHtml.split('\\n'));\n\t\t\t\tconsole.info('--------------------------------------------');\n\t\t\t\tconsole.info('');\n\n\t\t\t\texpect(false).toBe(true);\n\t\t\t\t// return;\n\t\t\t} else {\n\t\t\t\texpect(true).toBe(true);\n\t\t\t}\n\t\t}\n\t}));","file":"HtmlToHtml.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should convert from Html to Markdown","suites":["HtmlToMd"],"updatePoint":{"line":14,"column":41},"line":14,"code":"\tit('should convert from Html to Markdown', (async () => {\n\t\tconst basePath = `${__dirname}/html_to_md`;\n\t\tconst files = await shim.fsDriver().readDirStats(basePath);\n\t\tconst htmlToMd = new HtmlToMd();\n\n\t\tfor (let i = 0; i < files.length; i++) {\n\t\t\tconst htmlFilename = files[i].path;\n\t\t\tif (htmlFilename.indexOf('.html') < 0) continue;\n\n\t\t\tconst htmlPath = `${basePath}/${htmlFilename}`;\n\t\t\tconst mdPath = `${basePath}/${filename(htmlFilename)}.md`;\n\n\t\t\t// if (htmlFilename !== 'anchor_same_title_and_url.html') continue;\n\n\t\t\t// if (htmlFilename.indexOf('image_preserve_size') !== 0) continue;\n\n\t\t\tconst htmlToMdOptions: any = {};\n\n\t\t\tif (htmlFilename === 'anchor_local.html') {\n\t\t\t\t// Normally the list of anchor names in the document are retrieved from the HTML code\n\t\t\t\t// This is straightforward when the document is still in DOM format, as with the clipper,\n\t\t\t\t// but otherwise it would need to be somehow parsed out from the HTML. Here we just\n\t\t\t\t// hard code the anchors that we know are in the file.\n\t\t\t\thtmlToMdOptions.anchorNames = ['first', 'second', 'fourth'];\n\t\t\t}\n\n\t\t\tif (htmlFilename.indexOf('image_preserve_size') === 0) {\n\t\t\t\thtmlToMdOptions.preserveImageTagsWithSize = true;\n\t\t\t}\n\n\t\t\tconst html = await shim.fsDriver().readFile(htmlPath);\n\t\t\tlet expectedMd = await shim.fsDriver().readFile(mdPath);\n\n\t\t\tlet actualMd = await htmlToMd.parse(`<div>${html}</div>`, htmlToMdOptions);\n\n\t\t\tif (os.EOL === '\\r\\n') {\n\t\t\t\texpectedMd = expectedMd.replace(/\\r\\n/g, '\\n');\n\t\t\t\tactualMd = actualMd.replace(/\\r\\n/g, '\\n');\n\t\t\t}\n\n\t\t\tif (actualMd !== expectedMd) {\n\t\t\t\tconst result = [];\n\n\t\t\t\tresult.push('');\n\t\t\t\tresult.push(`Error converting file: ${htmlFilename}`);\n\t\t\t\tresult.push('--------------------------------- Got:');\n\t\t\t\tresult.push(actualMd.split('\\n').map((l: string) => `\"${l}\"`).join('\\n'));\n\t\t\t\tresult.push('--------------------------------- Expected:');\n\t\t\t\tresult.push(expectedMd.split('\\n').map((l: string) => `\"${l}\"`).join('\\n'));\n\t\t\t\tresult.push('--------------------------------------------');\n\t\t\t\tresult.push('');\n\n\t\t\t\tconsole.info(result.join('\\n'));\n\n\t\t\t\t// console.info('');\n\t\t\t\t// console.info(`Error converting file: ${htmlFilename}`);\n\t\t\t\t// console.info('--------------------------------- Got:');\n\t\t\t\t// console.info(actualMd);\n\t\t\t\t// console.info('--------------------------------- Raw:');\n\t\t\t\t// console.info(actualMd.split('\\n'));\n\t\t\t\t// console.info('--------------------------------- Expected:');\n\t\t\t\t// console.info(expectedMd.split('\\n'));\n\t\t\t\t// console.info('--------------------------------------------');\n\t\t\t\t// console.info('');\n\n\t\t\t\texpect(false).toBe(true);\n\t\t\t\t// return;\n\t\t\t} else {\n\t\t\t\texpect(true).toBe(true);\n\t\t\t}\n\t\t}\n\t}));","file":"HtmlToMd.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should allow disabling escape","suites":["HtmlToMd"],"updatePoint":{"line":87,"column":34},"line":87,"code":"\tit('should allow disabling escape', async () => {\n\t\tconst htmlToMd = new HtmlToMd();\n\t\texpect(htmlToMd.parse('https://test.com/1_2_3.pdf', { disableEscapeContent: true })).toBe('https://test.com/1_2_3.pdf');\n\t\texpect(htmlToMd.parse('https://test.com/1_2_3.pdf', { disableEscapeContent: false })).toBe('https://test.com/1\\\\_2\\\\_3.pdf');\n\t});","file":"HtmlToMd.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should strip markup","suites":["MarkupToHtml"],"updatePoint":{"line":6,"column":24},"line":6,"code":"\tit('should strip markup', (async () => {\n\t\tconst service = new MarkupToHtml();\n\n\t\tconst testCases = {\n\t\t\t[MarkupToHtml.MARKUP_LANGUAGE_MARKDOWN]: [\n\t\t\t\t['', ''],\n\t\t\t\t['## hello', 'hello'],\n\t\t\t\t['## hello **hello!**', 'hello hello!'],\n\t\t\t\t['*hi!*', 'hi!'],\n\t\t\t\t['Some `code` here', 'Some code here'],\n\t\t\t\t['Some <s>html</s> here', 'Some html here'],\n\t\t\t\t['Some &amp; here', 'Some & here'],\n\t\t\t\t['Some & here', 'Some & here'],\n\t\t\t\t['[![image alt](:/fe9ea7fa727e4375b2e7d8a1b873314d)](https://example.com)', ''],\n\t\t\t],\n\t\t\t[MarkupToHtml.MARKUP_LANGUAGE_HTML]: [\n\t\t\t\t['<h1>hello</h1>', 'hello'],\n\t\t\t\t['Some <b>strong</b> text', 'Some strong text'],\n\t\t\t\t['<b>M&amp;Ms</b>', 'M&Ms'],\n\t\t\t\t['<style>BODY{margin:0;padding:0;background:#f0f0f0}</style>', ''],\n\t\t\t],\n\t\t};\n\n\t\tfor (const markup in testCases) {\n\t\t\tfor (const t of testCases[markup]) {\n\t\t\t\tconst input = t[0];\n\t\t\t\tconst expected = t[1];\n\t\t\t\tconst actual = service.stripMarkup(Number(markup), input);\n\t\t\t\texpect(actual).toBe(expected, `Markup: ${markup}`);\n\t\t\t}\n\t\t}\n\n\t\texpect(service.stripMarkup(1, 'one line\\n\\ntwo line', { collapseWhiteSpaces: true })).toBe('one line two line');\n\t\texpect(service.stripMarkup(1, 'one line    two line', { collapseWhiteSpaces: true })).toBe('one line two line');\n\t\texpect(service.stripMarkup(1, 'one line\\n    two line', { collapseWhiteSpaces: true })).toBe('one line two line');\n\t}));","file":"MarkupToHtml.js","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should convert from Markdown to Html","suites":["MdToHtml"],"updatePoint":{"line":27,"column":41},"line":27,"code":"\tit('should convert from Markdown to Html', (async () => {\n\t\tconst basePath = `${__dirname}/md_to_html`;\n\t\tconst files = await shim.fsDriver().readDirStats(basePath);\n\t\tconst mdToHtml = newTestMdToHtml();\n\n\t\tfor (let i = 0; i < files.length; i++) {\n\t\t\tconst mdFilename = files[i].path;\n\t\t\tif (mdFilename.indexOf('.md') < 0) continue;\n\n\t\t\tconst mdFilePath = `${basePath}/${mdFilename}`;\n\t\t\tconst htmlPath = `${basePath}/${filename(mdFilePath)}.html`;\n\n\t\t\t// if (mdFilename !== 'sanitize_9.md') continue;\n\n\t\t\tconst mdToHtmlOptions: any = {\n\t\t\t\tbodyOnly: true,\n\t\t\t};\n\n\t\t\tif (mdFilename === 'checkbox_alternative.md') {\n\t\t\t\tmdToHtmlOptions.plugins = {\n\t\t\t\t\tcheckbox: {\n\t\t\t\t\t\tcheckboxRenderingType: 2,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst markdown = await shim.fsDriver().readFile(mdFilePath);\n\t\t\tlet expectedHtml = await shim.fsDriver().readFile(htmlPath);\n\n\t\t\tconst result = await mdToHtml.render(markdown, null, mdToHtmlOptions);\n\t\t\tlet actualHtml = result.html;\n\n\t\t\texpectedHtml = expectedHtml.replace(/\\r?\\n/g, '\\n');\n\t\t\tactualHtml = actualHtml.replace(/\\r?\\n/g, '\\n');\n\n\t\t\tif (actualHtml !== expectedHtml) {\n\t\t\t\tconst msg: string[] = [\n\t\t\t\t\t'',\n\t\t\t\t\t`Error converting file: ${mdFilename}`,\n\t\t\t\t\t'--------------------------------- Got:',\n\t\t\t\t\tactualHtml,\n\t\t\t\t\t'--------------------------------- Raw:',\n\t\t\t\t\tactualHtml.split('\\n'),\n\t\t\t\t\t'--------------------------------- Expected:',\n\t\t\t\t\texpectedHtml.split('\\n'),\n\t\t\t\t\t'--------------------------------------------',\n\t\t\t\t\t'',\n\t\t\t\t];\n\n\t\t\t\tconsole.info(msg.join('\\n'));\n\n\t\t\t\texpect(false).toBe(true);\n\t\t\t\t// return;\n\t\t\t} else {\n\t\t\t\texpect(true).toBe(true);\n\t\t\t}\n\t\t}\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should return enabled plugin assets","suites":["MdToHtml"],"updatePoint":{"line":86,"column":40},"line":86,"code":"\tit('should return enabled plugin assets', (async () => {\n\t\tconst pluginOptions: any = {};\n\t\tconst pluginNames = MdToHtml.pluginNames();\n\n\t\tfor (const n of pluginNames) pluginOptions[n] = { enabled: false };\n\n\t\t{\n\t\t\tconst mdToHtml = newTestMdToHtml({ pluginOptions: pluginOptions });\n\t\t\tconst assets = await mdToHtml.allAssets(themeStyle(1));\n\t\t\texpect(assets.length).toBe(1); // Base note style should always be returned\n\t\t}\n\n\t\t{\n\t\t\tpluginOptions['checkbox'].enabled = true;\n\t\t\tconst mdToHtml = newTestMdToHtml({ pluginOptions: pluginOptions });\n\n\t\t\tconst assets = await mdToHtml.allAssets(themeStyle(1));\n\t\t\texpect(assets.length).toBe(2);\n\t\t\texpect(assets[1].mime).toBe('text/css');\n\n\t\t\tconst content = await shim.fsDriver().readFile(assets[1].path);\n\t\t\texpect(content.indexOf('joplin-checklist') >= 0).toBe(true);\n\t\t}\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should wrapped the rendered Markdown","suites":["MdToHtml"],"updatePoint":{"line":111,"column":41},"line":111,"code":"\tit('should wrapped the rendered Markdown', (async () => {\n\t\tconst mdToHtml = newTestMdToHtml();\n\n\t\t// In this case, the HTML contains both the style and\n\t\t// the rendered markdown wrapped in a DIV.\n\t\tconst result = await mdToHtml.render('just **testing**');\n\t\texpect(result.cssStrings.length).toBeGreaterThan(0);\n\t\texpect(result.html.indexOf('rendered-md') >= 0).toBe(true);\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should return the rendered body only","suites":["MdToHtml"],"updatePoint":{"line":121,"column":41},"line":121,"code":"\tit('should return the rendered body only', (async () => {\n\t\tconst mdToHtml = newTestMdToHtml();\n\n\t\t// In this case, the HTML contains only the rendered markdown, with\n\t\t// no wrapper and no style. The style is instead in the cssStrings\n\t\t// property.\n\t\t{\n\t\t\tconst result = await mdToHtml.render('just **testing**', null, { bodyOnly: true });\n\t\t\texpect(result.cssStrings.length).toBeGreaterThan(0);\n\t\t\texpect(result.html.trim()).toBe('just <strong>testing</strong>');\n\t\t}\n\n\t\t// But it should not remove the wrapping <p> tags if there's more\n\t\t// than one line\n\t\t{\n\t\t\tconst result = await mdToHtml.render('one\\n\\ntwo', null, { bodyOnly: true });\n\t\t\texpect(result.html.trim()).toBe('<p>one</p>\\n<p>two</p>');\n\t\t}\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should render an empty string","suites":["MdToHtml"],"updatePoint":{"line":141,"column":34},"line":141,"code":"\tit('should render an empty string', (async () => {\n\t\tconst mdToHtml = newTestMdToHtml();\n\t\tconst result = await mdToHtml.render('', null, { splitted: true });\n\t\t// The TinyMCE component checks for this exact string to apply a hack,\n\t\t// so make sure it doesn't change from version to version.\n\t\texpect(result.html).toBe('<div id=\"rendered-md\"></div>');\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should split HTML and CSS","suites":["MdToHtml"],"updatePoint":{"line":149,"column":30},"line":149,"code":"\tit('should split HTML and CSS', (async () => {\n\t\tconst mdToHtml = newTestMdToHtml();\n\n\t\t// It is similar to the bodyOnly option, excepts that the rendered\n\t\t// Markdown is wrapped in a DIV\n\t\tconst result = await mdToHtml.render('just **testing**', null, { splitted: true });\n\t\texpect(result.cssStrings.length).toBeGreaterThan(0);\n\t\texpect(result.html.trim()).toBe('<div id=\"rendered-md\"><p>just <strong>testing</strong></p>\\n</div>');\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should render links correctly","suites":["MdToHtml"],"updatePoint":{"line":159,"column":34},"line":159,"code":"\tit('should render links correctly', (async () => {\n\t\tconst testCases = [\n\t\t\t// 0: input\n\t\t\t// 1: output with linkify = off\n\t\t\t// 2: output with linkify = on\n\t\t\t[\n\t\t\t\t'https://example.com',\n\t\t\t\t'https://example.com',\n\t\t\t\t'<a data-from-md title=\\'https://example.com\\' href=\\'https://example.com\\'>https://example.com</a>',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'file://C:\\\\AUTOEXEC.BAT',\n\t\t\t\t'file://C:\\\\AUTOEXEC.BAT',\n\t\t\t\t'<a data-from-md title=\\'file://C:%5CAUTOEXEC.BAT\\' href=\\'file://C:%5CAUTOEXEC.BAT\\'>file://C:\\\\AUTOEXEC.BAT</a>',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'example.com',\n\t\t\t\t'example.com',\n\t\t\t\t'example.com',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'oo.ps',\n\t\t\t\t'oo.ps',\n\t\t\t\t'oo.ps',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'test@example.com',\n\t\t\t\t'test@example.com',\n\t\t\t\t'test@example.com',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'<https://example.com>',\n\t\t\t\t'<a data-from-md title=\\'https://example.com\\' href=\\'https://example.com\\'>https://example.com</a>',\n\t\t\t\t'<a data-from-md title=\\'https://example.com\\' href=\\'https://example.com\\'>https://example.com</a>',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'[ok](https://example.com)',\n\t\t\t\t'<a data-from-md title=\\'https://example.com\\' href=\\'https://example.com\\'>ok</a>',\n\t\t\t\t'<a data-from-md title=\\'https://example.com\\' href=\\'https://example.com\\'>ok</a>',\n\t\t\t],\n\t\t\t[\n\t\t\t\t'[bla.pdf](file:///Users/tessus/Downloads/bla.pdf)',\n\t\t\t\t'<a data-from-md title=\\'file:///Users/tessus/Downloads/bla.pdf\\' href=\\'file:///Users/tessus/Downloads/bla.pdf\\'>bla.pdf</a>',\n\t\t\t\t'<a data-from-md title=\\'file:///Users/tessus/Downloads/bla.pdf\\' href=\\'file:///Users/tessus/Downloads/bla.pdf\\'>bla.pdf</a>',\n\t\t\t],\n\t\t];\n\n\t\tconst mdToHtmlLinkifyOn = newTestMdToHtml({\n\t\t\tpluginOptions: {\n\t\t\t\tlinkify: { enabled: true },\n\t\t\t},\n\t\t});\n\n\t\tconst mdToHtmlLinkifyOff = newTestMdToHtml({\n\t\t\tpluginOptions: {\n\t\t\t\tlinkify: { enabled: false },\n\t\t\t},\n\t\t});\n\n\t\tfor (const testCase of testCases) {\n\t\t\tconst [input, expectedLinkifyOff, expectedLinkifyOn] = testCase;\n\n\t\t\t{\n\t\t\t\tconst actual = await mdToHtmlLinkifyOn.render(input, null, {\n\t\t\t\t\tbodyOnly: true,\n\t\t\t\t\tplainResourceRendering: true,\n\t\t\t\t});\n\n\t\t\t\texpect(actual.html).toBe(expectedLinkifyOn);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tconst actual = await mdToHtmlLinkifyOff.render(input, null, {\n\t\t\t\t\tbodyOnly: true,\n\t\t\t\t\tplainResourceRendering: true,\n\t\t\t\t});\n\n\t\t\t\texpect(actual.html).toBe(expectedLinkifyOff);\n\t\t\t}\n\t\t}\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should return attributes of line numbers","suites":["MdToHtml"],"updatePoint":{"line":241,"column":45},"line":241,"code":"\tit('should return attributes of line numbers', (async () => {\n\t\tconst mdToHtml = newTestMdToHtml();\n\n\t\t// Mapping information between source lines and html elements is\n\t\t// annotated.\n\t\t{\n\t\t\tconst input = '# Head\\nFruits\\n- Apple\\n';\n\t\t\tconst result = await mdToHtml.render(input, null, { bodyOnly: true, mapsToLine: true });\n\t\t\texpect(result.html.trim()).toBe('<h1 id=\"head\" class=\"maps-to-line\" source-line=\"0\" source-line-end=\"1\">Head</h1>\\n' +\n\t\t\t\t'<p class=\"maps-to-line\" source-line=\"1\" source-line-end=\"2\">Fruits</p>\\n' +\n\t\t\t\t'<ul>\\n<li class=\"maps-to-line\" source-line=\"2\" source-line-end=\"3\">Apple</li>\\n</ul>'\n\t\t\t);\n\t\t}\n\t}));","file":"MdToHtml.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should be enabled on macOS and Windows","suites":[],"updatePoint":{"line":28,"column":43},"line":28,"code":"\tit('should be enabled on macOS and Windows', (async () => {\n\t\texpect(Setting.value('keychain.supported')).toBe(1);\n\t}));","file":"services/keychain/KeychainService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should set, get and delete passwords","suites":[],"updatePoint":{"line":32,"column":41},"line":32,"code":"\tit('should set, get and delete passwords', (async () => {\n\t\tconst service = KeychainService.instance();\n\n\t\tconst isSet = await service.setPassword('zz_testunit', 'password');\n\t\texpect(isSet).toBe(true);\n\n\t\tconst password = await service.password('zz_testunit');\n\t\texpect(password).toBe('password');\n\n\t\tawait service.deletePassword('zz_testunit');\n\n\t\texpect(await service.password('zz_testunit')).toBe(null);\n\t}));","file":"services/keychain/KeychainService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should save and load secure settings","suites":[],"updatePoint":{"line":46,"column":41},"line":46,"code":"\tit('should save and load secure settings', (async () => {\n\t\tSetting.setObjectValue('encryption.passwordCache', 'testing', '123456');\n\t\tawait Setting.saveAll();\n\t\tawait Setting.load();\n\t\tconst passwords = Setting.value('encryption.passwordCache');\n\t\texpect(passwords.testing).toBe('123456');\n\t}));","file":"services/keychain/KeychainService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should delete db settings if they have been saved in keychain","suites":[],"updatePoint":{"line":54,"column":66},"line":54,"code":"\tit('should delete db settings if they have been saved in keychain', (async () => {\n\t\t// First save some secure settings and make sure it ends up in the databse\n\t\tKeychainService.instance().enabled = false;\n\n\t\tSetting.setValue('sync.5.password', 'password');\n\t\tawait Setting.saveAll();\n\n\t\t{\n\t\t\t// Check that it is in the database\n\t\t\tconst row = await db().selectOne('SELECT * FROM settings WHERE key = \"sync.5.password\"');\n\t\t\texpect(row.value).toBe('password');\n\t\t}\n\n\t\tKeychainService.instance().enabled = true;\n\n\t\t// Change any setting to make sure a save operation is triggered\n\t\tSetting.setValue('sync.5.path', '/tmp');\n\n\t\t// Save the settings - now db secure keys should have been cleared and moved to keychain\n\t\tawait Setting.saveAll();\n\n\t\t{\n\t\t\t// Check that it's been removed from the database\n\t\t\tconst row = await db().selectOne('SELECT * FROM settings WHERE key = \"sync.5.password\"');\n\t\t\texpect(row).toBe(undefined);\n\t\t}\n\n\t\t// However we should still get it via the Setting class, since it will use the keychain\n\t\texpect(Setting.value('sync.5.password')).toBe('password');\n\n\t\t// Now do it again - because there was a bug that would cause the second attempt to save to the db instead\n\t\tSetting.setValue('sync.5.username', 'john');\n\t\tawait Setting.saveAll();\n\n\t\t{\n\t\t\t// Check that it's been removed from the database\n\t\t\tconst row = await db().selectOne('SELECT * FROM settings WHERE key = \"sync.5.password\"');\n\t\t\texpect(row).toBe(undefined);\n\t\t}\n\t}));","file":"services/keychain/KeychainService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"will pass","suites":[],"updatePoint":{"line":97,"column":14},"line":97,"code":"\tit('will pass', () => {\n\t\texpect(true).toBe(true);\n\t});","file":"services/keychain/KeychainService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should listen to setting change event","suites":["JoplinSettings"],"updatePoint":{"line":18,"column":44},"line":18,"code":"\ttest('should listen to setting change event', async () => {\n\t\tconst service = newPluginService();\n\n\t\tconst pluginScript = newPluginScript(`\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.settings.registerSettings({\n\t\t\t\t\t\t'myCustomSetting1': {\n\t\t\t\t\t\t\tvalue: 1,\n\t\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t\t\tpublic: true,\n\t\t\t\t\t\t\tlabel: 'My Custom Setting 1',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'myCustomSetting2': {\n\t\t\t\t\t\t\tvalue: 2,\n\t\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t\t\tpublic: true,\n\t\t\t\t\t\t\tlabel: 'My Custom Setting 2',\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tjoplin.settings.onChange((event) => {\n\t\t\t\t\t\tjoplin.data.post(['folders'], null, { title: JSON.stringify(event.keys) });\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\tSetting.setValue('plugin-org.joplinapp.plugins.PluginTest.myCustomSetting1', 111);\n\t\tSetting.setValue('plugin-org.joplinapp.plugins.PluginTest.myCustomSetting2', 222);\n\n\t\t// Also change a global setting, to verify that the plugin doesn't get\n\t\t// notifications for non-plugin related events.\n\t\tSetting.setValue('locale', 'fr_FR');\n\n\t\tSetting.emitScheduledChangeEvent();\n\n\t\tawait waitForFolderCount(1);\n\n\t\tconst folder = (await Folder.all())[0];\n\n\t\tconst settingNames: string[] = JSON.parse(folder.title);\n\t\tsettingNames.sort();\n\n\t\texpect(settingNames.join(',')).toBe('myCustomSetting1,myCustomSetting2');\n\n\t\tawait service.destroy();\n\t});","file":"services/plugins/api/JoplinSettings.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should allow registering multiple settings","suites":["JoplinSettings"],"updatePoint":{"line":70,"column":49},"line":70,"code":"\ttest('should allow registering multiple settings', async () => {\n\t\tconst service = newPluginService();\n\n\t\tconst pluginScript = newPluginScript(`\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.settings.registerSettings({\n\t\t\t\t\t\t'myCustomSetting1': {\n\t\t\t\t\t\t\tvalue: 1,\n\t\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t\t\tpublic: true,\n\t\t\t\t\t\t\tlabel: 'My Custom Setting 1',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'myCustomSetting2': {\n\t\t\t\t\t\t\tvalue: 2,\n\t\t\t\t\t\t\ttype: 1,\n\t\t\t\t\t\t\tpublic: true,\n\t\t\t\t\t\t\tlabel: 'My Custom Setting 2',\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\texpect(Setting.value('plugin-org.joplinapp.plugins.PluginTest.myCustomSetting1')).toBe(1);\n\t\texpect(Setting.value('plugin-org.joplinapp.plugins.PluginTest.myCustomSetting2')).toBe(2);\n\n\t\tawait service.destroy();\n\t});","file":"services/plugins/api/JoplinSettings.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should register commands with the keymap service","suites":["JoplinViewMenuItem"],"updatePoint":{"line":17,"column":55},"line":17,"code":"\ttest('should register commands with the keymap service', async () => {\n\t\tconst service = newPluginService();\n\n\t\tKeymapService.instance().initialize();\n\n\t\tconst pluginScript = newPluginScript(`\t\t\t\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.commands.register({\n\t\t\t\t\t\tname: 'testCommand1',\n\t\t\t\t\t\tlabel: 'My Test Command 1',\n\t\t\t\t\t\ticonName: 'fas fa-music',\n\t\t\t\t\t\texecute: async () => {},\n\t\t\t\t\t});\n\n\t\t\t\t\tawait joplin.views.menuItems.create('myMenuItem1', 'testCommand1', 'tools', { accelerator: 'CmdOrCtrl+Alt+Shift+B' });\n\n\t\t\t\t\tawait joplin.commands.register({\n\t\t\t\t\t\tname: 'testCommand2',\n\t\t\t\t\t\tlabel: 'My Test Command 2',\n\t\t\t\t\t\ticonName: 'fas fa-music',\n\t\t\t\t\t\texecute: async () => {},\n\t\t\t\t\t});\n\n\t\t\t\t\tawait joplin.views.menuItems.create('myMenuItem2', 'testCommand2', 'tools');\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\tconst commandNames = KeymapService.instance().getCommandNames();\n\n\t\texpect(commandNames.includes('testCommand1')).toBe(true);\n\t\texpect(commandNames.includes('testCommand2')).toBe(true);\n\n\t\tawait service.destroy();\n\t});","file":"services/plugins/api/JoplinViewMenuItem.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should listen to noteChange events","suites":["JoplinWorkspace"],"updatePoint":{"line":20,"column":41},"line":20,"code":"\ttest('should listen to noteChange events', async () => {\n\t\tconst appState: Record<string, any> = {\n\t\t\tselectedNoteIds: [],\n\t\t};\n\n\t\tconst service = newPluginService('1.4', {\n\t\t\tgetState: () => {\n\t\t\t\treturn appState;\n\t\t\t},\n\t\t});\n\n\t\tconst pluginScript = newPluginScript(`\t\t\t\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.workspace.onNoteChange(async (event) => {\n\t\t\t\t\t\tawait joplin.data.post(['folders'], null, { title: JSON.stringify(event) });\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tconst note = await Note.save({});\n\t\tappState.selectedNoteIds.push(note.id);\n\t\tawait ItemChange.waitForAllSaved();\n\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\tawait Note.save({ id: note.id, body: 'testing' });\n\t\tawait ItemChange.waitForAllSaved();\n\n\t\tconst folder = (await Folder.all())[0];\n\n\t\tconst result: any = JSON.parse(folder.title);\n\n\t\texpect(result.id).toBe(note.id);\n\t\texpect(result.event).toBe(ItemChange.TYPE_UPDATE);\n\n\t\tawait service.destroy();\n\t});","file":"services/plugins/api/JoplinWorkspace.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should return the selected folder","suites":["JoplinWorkspace"],"updatePoint":{"line":61,"column":40},"line":61,"code":"\ttest('should return the selected folder', async () => {\n\t\tconst service = newPluginService();\n\n\t\tconst pluginScript = newPluginScript(`\t\t\t\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tconst folder = await joplin.workspace.selectedFolder();\n\t\t\t\t\tawait joplin.data.put(['folders', folder.id], null, { title: \"changedtitle\" });\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tconst folder = await Folder.save({ title: 'folder' });\n\t\tSetting.setValue('activeFolderId', folder.id);\n\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\tconst modFolder = await Folder.load(folder.id);\n\t\texpect(modFolder.title).toBe('changedtitle');\n\t});","file":"services/plugins/api/JoplinWorkspace.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load and run a simple plugin","suites":["services_PluginService"],"updatePoint":{"line":40,"column":40},"line":40,"code":"\tit('should load and run a simple plugin', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins([`${testPluginDir}/simple`], {});\n\n\t\texpect(() => service.pluginById('org.joplinapp.plugins.Simple')).not.toThrowError();\n\n\t\tconst allFolders = await Folder.all();\n\t\texpect(allFolders.length).toBe(1);\n\t\texpect(allFolders[0].title).toBe('my plugin folder');\n\n\t\tconst allNotes = await Note.all();\n\t\texpect(allNotes.length).toBe(1);\n\t\texpect(allNotes[0].title).toBe('testing plugin!');\n\t\texpect(allNotes[0].parent_id).toBe(allFolders[0].id);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load and run a simple plugin and handle trailing slash","suites":["services_PluginService"],"updatePoint":{"line":56,"column":66},"line":56,"code":"\tit('should load and run a simple plugin and handle trailing slash', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins([`${testPluginDir}/simple/`], {});\n\t\texpect(() => service.pluginById('org.joplinapp.plugins.Simple')).not.toThrowError();\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load and run a plugin that uses external packages","suites":["services_PluginService"],"updatePoint":{"line":62,"column":61},"line":62,"code":"\tit('should load and run a plugin that uses external packages', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins([`${testPluginDir}/withExternalModules`], {});\n\t\texpect(() => service.pluginById('org.joplinapp.plugins.ExternalModuleDemo')).not.toThrowError();\n\n\t\tconst allFolders = await Folder.all();\n\t\texpect(allFolders.length).toBe(1);\n\n\t\t// If you have an error here, it might mean you need to run `npm i` from\n\t\t// the \"withExternalModules\" folder. Not clear exactly why.\n\t\texpect(allFolders[0].title).toBe('  foo');\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load multiple plugins from a directory","suites":["services_PluginService"],"updatePoint":{"line":75,"column":50},"line":75,"code":"\tit('should load multiple plugins from a directory', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins(`${testPluginDir}/multi_plugins`, {});\n\n\t\tconst plugin1 = service.pluginById('org.joplinapp.plugins.MultiPluginDemo1');\n\t\tconst plugin2 = service.pluginById('org.joplinapp.plugins.MultiPluginDemo2');\n\t\texpect(!!plugin1).toBe(true);\n\t\texpect(!!plugin2).toBe(true);\n\n\t\tconst allFolders = await Folder.all();\n\t\texpect(allFolders.length).toBe(2);\n\t\texpect(allFolders.map((f: any) => f.title).sort().join(', ')).toBe('multi - simple1, multi - simple2');\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load plugins from JS bundles","suites":["services_PluginService"],"updatePoint":{"line":89,"column":40},"line":89,"code":"\tit('should load plugins from JS bundles', (async () => {\n\t\tconst service = newPluginService();\n\n\t\tconst plugin = await service.loadPluginFromJsBundle('/tmp', `\n\t\t\t/* joplin-manifest:\n\t\t\t{\n\t\t\t\t\"id\": \"org.joplinapp.plugins.JsBundleTest\",\n\t\t\t\t\"manifest_version\": 1,\n\t\t\t\t\"app_min_version\": \"1.4\",\n\t\t\t\t\"name\": \"JS Bundle test\",\n\t\t\t\t\"description\": \"JS Bundle Test plugin\",\n\t\t\t\t\"version\": \"1.0.0\",\n\t\t\t\t\"author\": \"Laurent Cozic\",\n\t\t\t\t\"homepage_url\": \"https://joplinapp.org\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.data.post(['folders'], null, { title: \"my plugin folder\" });\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tawait service.runPlugin(plugin);\n\n\t\texpect(plugin.manifest.manifest_version).toBe(1);\n\t\texpect(plugin.manifest.name).toBe('JS Bundle test');\n\n\t\tconst allFolders = await Folder.all();\n\t\texpect(allFolders.length).toBe(1);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load plugins from JS bundle files","suites":["services_PluginService"],"updatePoint":{"line":122,"column":45},"line":122,"code":"\tit('should load plugins from JS bundle files', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins(`${testPluginDir}/jsbundles`, {});\n\t\texpect(!!service.pluginById('org.joplinapp.plugins.JsBundleDemo')).toBe(true);\n\t\texpect((await Folder.all()).length).toBe(1);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should load plugins from JPL archive","suites":["services_PluginService"],"updatePoint":{"line":129,"column":41},"line":129,"code":"\tit('should load plugins from JPL archive', (async () => {\n\t\tconst service = newPluginService();\n\t\tawait service.loadAndRunPlugins([`${testPluginDir}/jpl_test/org.joplinapp.FirstJplPlugin.jpl`], {});\n\t\texpect(!!service.pluginById('org.joplinapp.FirstJplPlugin')).toBe(true);\n\t\texpect((await Folder.all()).length).toBe(1);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should validate JS bundles","suites":["services_PluginService"],"updatePoint":{"line":136,"column":31},"line":136,"code":"\tit('should validate JS bundles', (async () => {\n\t\tconst invalidJsBundles = [\n\t\t\t`\n\t\t\t\t/* joplin-manifest:\n\t\t\t\t{\n\t\t\t\t\t\"not_a_valid_manifest_at_all\": 1\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tjoplin.plugins.register({\n\t\t\t\t\tonStart: async function() {},\n\t\t\t\t});\n\t\t\t`, `\n\t\t\t\t/* joplin-manifest:\n\t\t\t\t*/\n\n\t\t\t\tjoplin.plugins.register({\n\t\t\t\t\tonStart: async function() {},\n\t\t\t\t});\n\t\t\t`, `\n\t\t\t\tjoplin.plugins.register({\n\t\t\t\t\tonStart: async function() {},\n\t\t\t\t});\n\t\t\t`, '',\n\t\t];\n\n\t\tconst service = newPluginService();\n\n\t\tfor (const jsBundle of invalidJsBundles) {\n\t\t\tawait expectThrow(async () => await service.loadPluginFromJsBundle('/tmp', jsBundle));\n\t\t}\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should register a Markdown-it plugin","suites":["services_PluginService"],"updatePoint":{"line":169,"column":41},"line":169,"code":"\tit('should register a Markdown-it plugin', (async () => {\n\t\tconst tempDir = await createTempDir();\n\n\t\tconst contentScriptPath = `${tempDir}/markdownItTestPlugin.js`;\n\t\tconst contentScriptCssPath = `${tempDir}/markdownItTestPlugin.css`;\n\t\tawait shim.fsDriver().copy(`${testPluginDir}/markdownItTestPlugin.js`, contentScriptPath);\n\t\tawait shim.fsDriver().copy(`${testPluginDir}/content_script/src/markdownItTestPlugin.css`, contentScriptCssPath);\n\n\t\tconst service = newPluginService();\n\n\t\tconst plugin = await service.loadPluginFromJsBundle(tempDir, `\n\t\t\t/* joplin-manifest:\n\t\t\t{\n\t\t\t\t\"id\": \"org.joplinapp.plugin.MarkdownItPluginTest\",\n\t\t\t\t\"manifest_version\": 1,\n\t\t\t\t\"app_min_version\": \"1.4\",\n\t\t\t\t\"name\": \"JS Bundle test\",\n\t\t\t\t\"description\": \"JS Bundle Test plugin\",\n\t\t\t\t\"version\": \"1.0.0\",\n\t\t\t\t\"author\": \"Laurent Cozic\",\n\t\t\t\t\"homepage_url\": \"https://joplinapp.org\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tawait joplin.contentScripts.register('markdownItPlugin', 'justtesting', './markdownItTestPlugin.js');\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tawait service.runPlugin(plugin);\n\n\t\tconst contentScripts = plugin.contentScriptsByType(ContentScriptType.MarkdownItPlugin);\n\t\texpect(contentScripts.length).toBe(1);\n\t\texpect(!!contentScripts[0].path).toBe(true);\n\n\t\tconst contentScript = contentScripts[0];\n\n\t\tconst mdToHtml = new MdToHtml();\n\t\tconst module = require(contentScript.path).default;\n\t\tmdToHtml.loadExtraRendererRule(contentScript.id, tempDir, module({}));\n\n\t\tconst result = await mdToHtml.render([\n\t\t\t'```justtesting',\n\t\t\t'something',\n\t\t\t'```',\n\t\t].join('\\n'));\n\n\t\tconst asset = result.pluginAssets.find(a => a.name === 'justtesting/markdownItTestPlugin.css');\n\t\tconst assetContent: string = await shim.fsDriver().readFile(asset.path, 'utf8');\n\n\t\texpect(assetContent.includes('.just-testing')).toBe(true);\n\t\texpect(assetContent.includes('background-color: rgb(202, 255, 255)')).toBe(true);\n\t\texpect(result.html.includes('JUST TESTING: something')).toBe(true);\n\n\t\tawait shim.fsDriver().remove(tempDir);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should enable and disable plugins depending on what app version they support","suites":["services_PluginService"],"updatePoint":{"line":228,"column":81},"line":228,"code":"\tit('should enable and disable plugins depending on what app version they support', (async () => {\n\t\tconst pluginScript = `\n\t\t\t/* joplin-manifest:\n\t\t\t{\n\t\t\t\t\"id\": \"org.joplinapp.plugins.PluginTest\",\n\t\t\t\t\"manifest_version\": 1,\n\t\t\t\t\"app_min_version\": \"1.4\",\n\t\t\t\t\"name\": \"JS Bundle test\",\n\t\t\t\t\"version\": \"1.0.0\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() { },\n\t\t\t});\n\t\t`;\n\n\t\tconst testCases = [\n\t\t\t['1.4', true],\n\t\t\t['1.5', true],\n\t\t\t['2.0', true],\n\t\t\t['1.3', false],\n\t\t\t['0.9', false],\n\t\t];\n\n\t\tfor (const testCase of testCases) {\n\t\t\tconst [appVersion, hasNoError] = testCase;\n\t\t\tconst service = newPluginService(appVersion as string);\n\t\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\n\t\t\tif (hasNoError) {\n\t\t\t\tawait expectNotThrow(() => service.runPlugin(plugin));\n\t\t\t} else {\n\t\t\t\tawait expectThrow(() => service.runPlugin(plugin));\n\t\t\t}\n\t\t}\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should install a plugin","suites":["services_PluginService"],"updatePoint":{"line":266,"column":28},"line":266,"code":"\tit('should install a plugin', (async () => {\n\t\tconst service = newPluginService();\n\t\tconst pluginPath = `${testPluginDir}/jpl_test/org.joplinapp.FirstJplPlugin.jpl`;\n\t\tawait service.installPlugin(pluginPath);\n\t\tconst installedPluginPath = `${Setting.value('pluginDir')}/org.joplinapp.FirstJplPlugin.jpl`;\n\t\texpect(await fs.pathExists(installedPluginPath)).toBe(true);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should rename the plugin archive to the right name","suites":["services_PluginService"],"updatePoint":{"line":274,"column":55},"line":274,"code":"\tit('should rename the plugin archive to the right name', (async () => {\n\t\tconst tempDir = await createTempDir();\n\t\tconst service = newPluginService();\n\t\tconst pluginPath = `${testPluginDir}/jpl_test/org.joplinapp.FirstJplPlugin.jpl`;\n\t\tconst tempPath = `${tempDir}/something.jpl`;\n\t\tawait shim.fsDriver().copy(pluginPath, tempPath);\n\t\tconst installedPluginPath = `${Setting.value('pluginDir')}/org.joplinapp.FirstJplPlugin.jpl`;\n\t\tawait service.installPlugin(tempPath);\n\t\texpect(await fs.pathExists(installedPluginPath)).toBe(true);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should create the data directory","suites":["services_PluginService"],"updatePoint":{"line":285,"column":37},"line":285,"code":"\tit('should create the data directory', (async () => {\n\t\tconst pluginScript = newPluginScript(`\n\t\t\tjoplin.plugins.register({\n\t\t\t\tonStart: async function() {\n\t\t\t\t\tconst dataDir = await joplin.plugins.dataDir();\n\t\t\t\t\tjoplin.data.post(['folders'], null, { title: JSON.stringify(dataDir) });\n\t\t\t\t},\n\t\t\t});\n\t\t`);\n\n\t\tconst expectedPath = `${Setting.value('pluginDataDir')}/org.joplinapp.plugins.PluginTest`;\n\t\texpect(await fs.pathExists(expectedPath)).toBe(false);\n\n\t\tconst service = newPluginService();\n\t\tconst plugin = await service.loadPluginFromJsBundle('', pluginScript);\n\t\tawait service.runPlugin(plugin);\n\n\t\texpect(await fs.pathExists(expectedPath)).toBe(true);\n\n\t\tconst folders = await Folder.all();\n\t\texpect(JSON.parse(folders[0].title)).toBe(expectedPath);\n\t}));","file":"services/plugins/PluginService.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should get the manifests","suites":["services_plugins_RepositoryApi"],"updatePoint":{"line":19,"column":29},"line":19,"code":"\tit('should get the manifests', (async () => {\n\t\tconst api = await newRepoApi();\n\t\tconst manifests = await api.manifests();\n\t\texpect(!!manifests.find(m => m.id === 'joplin.plugin.ambrt.backlinksToNote')).toBe(true);\n\t\texpect(!!manifests.find(m => m.id === 'org.joplinapp.plugins.ToggleSidebars')).toBe(true);\n\t}));","file":"services/plugins/RepositoryApi.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should search","suites":["services_plugins_RepositoryApi"],"updatePoint":{"line":26,"column":18},"line":26,"code":"\tit('should search', (async () => {\n\t\tconst api = await newRepoApi();\n\n\t\t{\n\t\t\tconst results = await api.search('to');\n\t\t\texpect(results.length).toBe(2);\n\t\t\texpect(!!results.find(m => m.id === 'joplin.plugin.ambrt.backlinksToNote')).toBe(true);\n\t\t\texpect(!!results.find(m => m.id === 'org.joplinapp.plugins.ToggleSidebars')).toBe(true);\n\t\t}\n\n\t\t{\n\t\t\tconst results = await api.search('backlink');\n\t\t\texpect(results.length).toBe(1);\n\t\t\texpect(!!results.find(m => m.id === 'joplin.plugin.ambrt.backlinksToNote')).toBe(true);\n\t\t}\n\t}));","file":"services/plugins/RepositoryApi.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should download a plugin","suites":["services_plugins_RepositoryApi"],"updatePoint":{"line":43,"column":29},"line":43,"code":"\tit('should download a plugin', (async () => {\n\t\tconst api = await newRepoApi();\n\t\tconst pluginPath = await api.downloadPlugin('org.joplinapp.plugins.ToggleSidebars');\n\t\texpect(await shim.fsDriver().exists(pluginPath)).toBe(true);\n\t}));","file":"services/plugins/RepositoryApi.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should tell if a plugin can be updated","suites":["services_plugins_RepositoryApi"],"updatePoint":{"line":49,"column":43},"line":49,"code":"\tit('should tell if a plugin can be updated', (async () => {\n\t\tconst api = await newRepoApi();\n\t\texpect(await api.pluginCanBeUpdated('org.joplinapp.plugins.ToggleSidebars', '1.0.0')).toBe(true);\n\t\texpect(await api.pluginCanBeUpdated('org.joplinapp.plugins.ToggleSidebars', '1.0.2')).toBe(false);\n\t\texpect(await api.pluginCanBeUpdated('does.not.exist', '1.0.0')).toBe(false);\n\t}));","file":"services/plugins/RepositoryApi.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should create a new sandbox proxy","suites":["services_plugins_sandboxProxy"],"updatePoint":{"line":12,"column":38},"line":12,"code":"\tit('should create a new sandbox proxy', (async () => {\n\t\tinterface Result {\n\t\t\tpath: string;\n\t\t\targs: any[];\n\t\t}\n\n\t\tconst results: Result[] = [];\n\n\t\tconst target: any = (path: string, args: any[]) => {\n\t\t\tresults.push({ path, args });\n\t\t};\n\n\t\tconst proxy = sandboxProxy(target);\n\n\t\tproxy.testing.bla.test('hello', '123');\n\t\tproxy.testing.test2();\n\n\t\texpect(results[0].path).toBe('testing.bla.test');\n\t\texpect(results[0].args.join('_')).toBe('hello_123');\n\t\texpect(results[1].path).toBe('testing.test2');\n\t\texpect(results[1].args.join('_')).toBe('');\n\t}));","file":"services/plugins/sandboxProxy.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"should allow importing a namespace","suites":["services_plugins_sandboxProxy"],"updatePoint":{"line":35,"column":39},"line":35,"code":"\tit('should allow importing a namespace', (async () => {\n\t\tinterface Result {\n\t\t\tpath: string;\n\t\t\targs: any[];\n\t\t}\n\n\t\tconst results: Result[] = [];\n\n\t\tconst target: any = (path: string, args: any[]) => {\n\t\t\tresults.push({ path, args });\n\t\t};\n\n\t\tconst proxy = sandboxProxy(target);\n\n\t\tconst ns = proxy.testing.blabla;\n\t\tns.test();\n\t\tns.test2();\n\n\t\texpect(results[0].path).toBe('testing.blabla.test');\n\t\texpect(results[1].path).toBe('testing.blabla.test2');\n\t}));","file":"services/plugins/sandboxProxy.ts","skipped":false,"dir":"packages/app-cli/tests"},{"name":"malformed documents","suites":[],"updatePoint":{"line":11,"column":25,"index":287},"line":11,"code":"test('malformed documents', function (t) {\n  t.plan(0);\n  const turndownService = new TurndownService();\n  turndownService.turndown('<HTML><head></head><BODY><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><body onload=alert(document.cookie);></body></html>');\n  t.end();\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"null input","suites":[],"updatePoint":{"line":17,"column":16,"index":627},"line":17,"code":"test('null input', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  t.throws(function () {\n    turndownService.turndown(null);\n  }, /null is not a string/);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"undefined input","suites":[],"updatePoint":{"line":24,"column":21,"index":823},"line":24,"code":"test('undefined input', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  t.throws(function () {\n    turndownService.turndown(void 0);\n  }, /undefined is not a string/);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#addRule returns the instance","suites":[],"updatePoint":{"line":31,"column":35,"index":1040},"line":31,"code":"test('#addRule returns the instance', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  const rule = {\n    filter: ['del', 's', 'strike'],\n    replacement: function (content) {\n      return `~~${content}~~`;\n    }\n  };\n  t.equal(turndownService.addRule('strikethrough', rule), turndownService);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#addRule adds the rule","suites":[],"updatePoint":{"line":42,"column":28,"index":1361},"line":42,"code":"test('#addRule adds the rule', function (t) {\n  t.plan(2);\n  const turndownService = new TurndownService();\n  const rule = {\n    filter: ['del', 's', 'strike'],\n    replacement: function (content) {\n      return `~~${content}~~`;\n    }\n  }; // Assert rules#add is called\n\n  turndownService.rules.add = function (key, r) {\n    t.equal(key, 'strikethrough');\n    t.equal(rule, r);\n  };\n\n  turndownService.addRule('strikethrough', rule);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#use returns the instance for chaining","suites":[],"updatePoint":{"line":59,"column":44,"index":1816},"line":59,"code":"test('#use returns the instance for chaining', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  t.equal(turndownService.use(function plugin() {}), turndownService);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#use with a single plugin calls the fn with instance","suites":[],"updatePoint":{"line":64,"column":58,"index":2029},"line":64,"code":"test('#use with a single plugin calls the fn with instance', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n\n  function plugin(service) {\n    t.equal(service, turndownService);\n  }\n\n  turndownService.use(plugin);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#use with multiple plugins calls each fn with instance","suites":[],"updatePoint":{"line":74,"column":60,"index":2278},"line":74,"code":"test('#use with multiple plugins calls each fn with instance', function (t) {\n  t.plan(2);\n  const turndownService = new TurndownService();\n\n  function plugin1(service) {\n    t.equal(service, turndownService);\n  }\n\n  function plugin2(service) {\n    t.equal(service, turndownService);\n  }\n\n  turndownService.use([plugin1, plugin2]);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#keep keeps elements as HTML","suites":[],"updatePoint":{"line":88,"column":34,"index":2588},"line":88,"code":"test('#keep keeps elements as HTML', function (t) {\n  t.plan(2);\n  const turndownService = new TurndownService();\n  const input = '<p>Hello <del>world</del><ins>World</ins></p>'; // Without `.keep(['del', 'ins'])`\n\n  t.equal(turndownService.turndown(input), 'Hello worldWorld'); // With `.keep(['del', 'ins'])`\n\n  turndownService.keep(['del', 'ins']);\n  t.equal(turndownService.turndown('<p>Hello <del>world</del><ins>World</ins></p>'), 'Hello <del>world</del><ins>World</ins>');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#keep returns the TurndownService instance for chaining","suites":[],"updatePoint":{"line":98,"column":61,"index":3099},"line":98,"code":"test('#keep returns the TurndownService instance for chaining', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  t.equal(turndownService.keep(['del', 'ins']), turndownService);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"keep rules are overridden by the standard rules","suites":[],"updatePoint":{"line":103,"column":53,"index":3302},"line":103,"code":"test('keep rules are overridden by the standard rules', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  turndownService.keep('p');\n  t.equal(turndownService.turndown('<p>Hello world</p>'), 'Hello world');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"keepReplacement can be customised","suites":[],"updatePoint":{"line":109,"column":39,"index":3528},"line":109,"code":"test('keepReplacement can be customised', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService({\n    keepReplacement: function (content, node) {\n      return `\\n\\n${node.outerHTML}\\n\\n`;\n    }\n  });\n  turndownService.keep(['del', 'ins']);\n  t.equal(turndownService.turndown('<p>Hello <del>world</del><ins>World</ins></p>'), 'Hello \\n\\n<del>world</del>\\n\\n<ins>World</ins>');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#remove removes elements","suites":[],"updatePoint":{"line":119,"column":30,"index":3919},"line":119,"code":"test('#remove removes elements', function (t) {\n  t.plan(2);\n  const turndownService = new TurndownService();\n  const input = '<del>Please redact me</del>'; // Without `.remove('del')`\n\n  t.equal(turndownService.turndown(input), 'Please redact me'); // With `.remove('del')`\n\n  turndownService.remove('del');\n  t.equal(turndownService.turndown(input), '');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"#remove returns the TurndownService instance for chaining","suites":[],"updatePoint":{"line":129,"column":63,"index":4313},"line":129,"code":"test('#remove returns the TurndownService instance for chaining', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  t.equal(turndownService.remove(['del', 'ins']), turndownService);\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"remove elements are overridden by rules","suites":[],"updatePoint":{"line":134,"column":45,"index":4510},"line":134,"code":"test('remove elements are overridden by rules', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  turndownService.remove('p');\n  t.equal(turndownService.turndown('<p>Hello world</p>'), 'Hello world');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"},{"name":"remove elements are overridden by keep","suites":[],"updatePoint":{"line":140,"column":44,"index":4743},"line":140,"code":"test('remove elements are overridden by keep', function (t) {\n  t.plan(1);\n  const turndownService = new TurndownService();\n  turndownService.keep(['del', 'ins']);\n  turndownService.remove(['del', 'ins']);\n  t.equal(turndownService.turndown('<p>Hello <del>world</del><ins>World</ins></p>'), 'Hello <del>world</del><ins>World</ins>');\n});","file":"turndown-test.js","skipped":false,"dir":"packages/turndown/test"}]}