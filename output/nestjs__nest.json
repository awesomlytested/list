{"repo":"nestjs/nest","url":"https://github.com/nestjs/nest","branch":"master","configs":[{"package":"@nestjs/common","lang":"js","dir":"packages/common/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nestjs/core","lang":"ts","dir":"packages/core/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nestjs/microservices","lang":"ts","dir":"packages/microservices/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nestjs/platform-express","lang":"js","dir":"packages/platform-express/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nestjs/websockets","lang":"ts","dir":"packages/websockets/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"nest-typescript-starter","lang":"ts","dir":"sample/30-event-emitter/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should return a response as a string when input is a string","suites":["HttpException","getResponse"],"updatePoint":{"line":6,"column":67,"index":772},"line":6,"code":"    it('should return a response as a string when input is a string', () => {\n      const message = 'My error message';\n      expect(new HttpException(message, 404).getResponse()).to.be.eql('My error message');\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a response as an object when input is an object","suites":["HttpException","getResponse"],"updatePoint":{"line":10,"column":69,"index":993},"line":10,"code":"    it('should return a response as an object when input is an object', () => {\n      const message = {\n        msg: 'My error message',\n        reason: 'this can be a human readable reason',\n        anything: 'else'\n      };\n      expect(new HttpException(message, 404).getResponse()).to.be.eql(message);\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a message from a built-in exception as an object","suites":["HttpException","getResponse"],"updatePoint":{"line":18,"column":70,"index":1308},"line":18,"code":"    it('should return a message from a built-in exception as an object', () => {\n      const message = 'My error message';\n      expect(new BadRequestException(message).getResponse()).to.be.eql({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'My error message'\n      });\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return an object even when the message is undefined","suites":["HttpException","getResponse"],"updatePoint":{"line":26,"column":66,"index":1609},"line":26,"code":"    it('should return an object even when the message is undefined', () => {\n      expect(new BadRequestException().getResponse()).to.be.eql({\n        statusCode: 400,\n        message: 'Bad Request'\n      });\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return given status code","suites":["HttpException","built-in exceptions","getStatus"],"updatePoint":{"line":35,"column":41,"index":1883},"line":35,"code":"      it('should return given status code', () => {\n        const testCases = [[BadRequestException, 400], [UnauthorizedException, 401], [ForbiddenException, 403], [NotFoundException, 404], [MethodNotAllowedException, 405], [NotAcceptableException, 406], [RequestTimeoutException, 408], [ConflictException, 409], [GoneException, 410], [PreconditionFailedException, 412], [PayloadTooLargeException, 413], [UnsupportedMediaTypeException, 415], [ImATeapotException, 418], [MisdirectedException, 421], [UnprocessableEntityException, 422], [InternalServerErrorException, 500], [NotImplementedException, 501], [BadGatewayException, 502], [ServiceUnavailableException, 503], [GatewayTimeoutException, 504], [HttpVersionNotSupportedException, 505]];\n        testCases.forEach(([ExceptionClass, expectedStatus]) => {\n          expect(new ExceptionClass().getStatus()).to.be.eql(expectedStatus);\n        });\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a response with default message and status code","suites":["HttpException","built-in exceptions","getResponse"],"updatePoint":{"line":43,"column":71,"index":2865},"line":43,"code":"      it('should return a response with default message and status code', () => {\n        const testCases = [[BadRequestException, 400, 'Bad Request'], [UnauthorizedException, 401, 'Unauthorized'], [ForbiddenException, 403, 'Forbidden'], [NotFoundException, 404, 'Not Found'], [MethodNotAllowedException, 405, 'Method Not Allowed'], [NotAcceptableException, 406, 'Not Acceptable'], [RequestTimeoutException, 408, 'Request Timeout'], [ConflictException, 409, 'Conflict'], [GoneException, 410, 'Gone'], [PreconditionFailedException, 412, 'Precondition Failed'], [PayloadTooLargeException, 413, 'Payload Too Large'], [UnsupportedMediaTypeException, 415, 'Unsupported Media Type'], [ImATeapotException, 418, \"I'm a teapot\"], [MisdirectedException, 421, 'Misdirected'], [UnprocessableEntityException, 422, 'Unprocessable Entity'], [InternalServerErrorException, 500, 'Internal Server Error'], [NotImplementedException, 501, 'Not Implemented'], [BadGatewayException, 502, 'Bad Gateway'], [ServiceUnavailableException, 503, 'Service Unavailable'], [GatewayTimeoutException, 504, 'Gateway Timeout'], [HttpVersionNotSupportedException, 505, 'HTTP Version Not Supported']];\n        testCases.forEach(([ExceptionClass, expectedStatus, expectedMessage]) => {\n          expect(new ExceptionClass().getResponse()).to.be.eql({\n            message: expectedMessage,\n            statusCode: expectedStatus\n          });\n        });\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a response with an \"error\" attribute when description was provided as the \"option\" object","suites":["HttpException","built-in exceptions","getResponse"],"updatePoint":{"line":52,"column":113,"index":4332},"line":52,"code":"      it('should return a response with an \"error\" attribute when description was provided as the \"option\" object', () => {\n        const badRequestError = new BadRequestException('ErrorMessage', {\n          description: 'Some error description'\n        });\n        expect(badRequestError.getResponse()).to.be.eql({\n          message: 'ErrorMessage',\n          error: 'Some error description',\n          statusCode: 400\n        });\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should inherit from error","suites":["HttpException","built-in exceptions","getResponse"],"updatePoint":{"line":64,"column":31,"index":4706},"line":64,"code":"  it('should inherit from error', () => {\n    const error = new HttpException('', 400);\n    expect(error instanceof Error).to.be.true;\n  });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should concatenate HttpException with the given message","suites":["HttpException","when serializing","and \"response\" parameter is a string"],"updatePoint":{"line":70,"column":65,"index":4981},"line":70,"code":"      it('should concatenate HttpException with the given message', () => {\n        const responseAsString = 'Some Error';\n        const error = new HttpException(responseAsString, 400);\n        expect(`${error}`).to.be.eql(`HttpException: ${responseAsString}`);\n        expect(`${error}`.includes('[object Object]')).to.not.be.true;\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should use default message","suites":["HttpException","when serializing","and \"response\" parameter is an object"],"updatePoint":{"line":78,"column":36,"index":5366},"line":78,"code":"      it('should use default message', () => {\n        const responseAsObject = {\n          foo: 'bar'\n        };\n        const error = new HttpException(responseAsObject, 400);\n        const badRequestError = new BadRequestException(responseAsObject);\n        expect(`${error}`).to.be.eql(`HttpException: Http Exception`);\n        expect(`${badRequestError}`).to.be.eql(`BadRequestException: Bad Request Exception`);\n        expect(`${error}`.includes('[object Object]')).to.not.be.true;\n        expect(`${badRequestError}`.includes('[object Object]')).to.not.be.true;\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return expected object","suites":["HttpException","createBody","when object has been passed"],"updatePoint":{"line":93,"column":39,"index":6048},"line":93,"code":"      it('should return expected object', () => {\n        const object = {\n          message: 'test'\n        };\n        expect(HttpException.createBody(object)).to.be.eql(object);\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return expected object","suites":["HttpException","createBody","when string has been passed"],"updatePoint":{"line":101,"column":39,"index":6298},"line":101,"code":"      it('should return expected object', () => {\n        const error = 'test';\n        const status = 500;\n        const message = 'error';\n        expect(HttpException.createBody(message, error, status)).to.be.eql({\n          error,\n          message,\n          statusCode: status\n        });\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return expected object","suites":["HttpException","createBody","when nil has been passed"],"updatePoint":{"line":113,"column":39,"index":6660},"line":113,"code":"      it('should return expected object', () => {\n        const status = 500;\n        const error = 'error';\n        expect(HttpException.createBody(null, error, status)).to.be.eql({\n          message: error,\n          statusCode: status\n        });\n      });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should not override pre-defined body if message is array","suites":["HttpException","createBody","when nil has been passed"],"updatePoint":{"line":122,"column":64,"index":6953},"line":122,"code":"    it('should not override pre-defined body if message is array', () => {\n      expect(HttpException.createBody(['a', 'random', 'array'], 'error', 200)).to.eql({\n        message: ['a', 'random', 'array'],\n        error: 'error',\n        statusCode: 200\n      });\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"configures a cause when message is a string and the options object is passed","suites":["HttpException","initCause"],"updatePoint":{"line":133,"column":84,"index":7396},"line":133,"code":"    it('configures a cause when message is a string and the options object is passed', () => {\n      const error = new HttpException(customDescription, 400, {\n        cause: errorCause\n      });\n      expect(`${error}`).to.be.eql(`HttpException: ${customDescription}`);\n      const {\n        cause\n      } = error;\n      expect(cause).to.be.eql(errorCause);\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"configures a cause when using a built-in exception with options","suites":["HttpException","initCause"],"updatePoint":{"line":143,"column":71,"index":7749},"line":143,"code":"    it('configures a cause when using a built-in exception with options', () => {\n      const builtInErrorClasses = [BadGatewayException, BadRequestException, ConflictException, ForbiddenException, GatewayTimeoutException, GoneException, HttpVersionNotSupportedException, ImATeapotException, InternalServerErrorException, MethodNotAllowedException, MisdirectedException, NotAcceptableException, NotFoundException, NotImplementedException, PayloadTooLargeException, PreconditionFailedException, RequestTimeoutException, ServiceUnavailableException, UnauthorizedException, UnprocessableEntityException, UnsupportedMediaTypeException];\n      builtInErrorClasses.forEach(ExceptionClass => {\n        const error = new ExceptionClass(customDescription, {\n          cause: errorCause\n        });\n        const {\n          cause\n        } = error;\n        expect(cause).to.be.eql(errorCause);\n      });\n    });","file":"exceptions/http.exception.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should take only required providers","suites":["getInjectionProviders"],"updatePoint":{"line":5,"column":41,"index":261},"line":5,"code":"  it('should take only required providers', () => {\n    class C {\n      static token = 'a';\n    }\n    const p = [{\n      provide: 'a',\n      useValue: 'a'\n    }, {\n      provide: 'b',\n      useValue: 'b'\n    }, C, {\n      provide: 'd',\n      useFactory: (c, b) => [c, b],\n      inject: [C, {\n        token: 'b',\n        optional: true\n      }, 'x']\n    }, {\n      provide: 'e',\n      useFactory: (d, b) => [d, b],\n      inject: ['d', 'b']\n    }, {\n      provide: 'f',\n      useValue: 'f'\n    }];\n    // should not include 'a' and 'f'\n    const expected = p.slice(1, -1);\n    const result = getInjectionProviders(p, ['e']);\n    expect(result).to.have.length(expected.length);\n    expect(result).to.have.members(expected);\n    expect(result).not.to.have.members([p[0], p[5]]);\n  });","file":"module-utils/utils/get-injection-providers.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return original value if one was provided","suites":["DefaultValuePipe","transform"],"updatePoint":{"line":7,"column":56,"index":311},"line":7,"code":"    it('should return original value if one was provided', () => {\n      const value = 'value';\n      const result = target.transform(value);\n      expect(result).to.equal(value);\n    });","file":"pipes/default-value.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return default value if no value was provided","suites":["DefaultValuePipe","transform"],"updatePoint":{"line":12,"column":60,"index":503},"line":12,"code":"    it('should return default value if no value was provided', () => {\n      const result = target.transform(undefined);\n      expect(result).to.equal(defaultValue);\n    });","file":"pipes/default-value.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a ParseFilePipe with no validators","suites":["ParseFilePipeBuilder","build","when no validator was passed"],"updatePoint":{"line":10,"column":58,"index":433},"line":10,"code":"      it('should return a ParseFilePipe with no validators', () => {\n        const parseFilePipe = parseFilePipeBuilder.build();\n        expect(parseFilePipe.getValidators()).to.be.empty;\n      });","file":"pipes/file/parse-file-pipe.builder.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a ParseFilePipe with MaxSizeValidator and given options","suites":["ParseFilePipeBuilder","build","when addMaxSizeValidator was chained"],"updatePoint":{"line":16,"column":79,"index":721},"line":16,"code":"      it('should return a ParseFilePipe with MaxSizeValidator and given options', () => {\n        const options = {\n          maxSize: 1000\n        };\n        const parseFilePipe = parseFilePipeBuilder.addMaxSizeValidator(options).build();\n        expect(parseFilePipe.getValidators()).to.deep.include(new MaxFileSizeValidator(options));\n      });","file":"pipes/file/parse-file-pipe.builder.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a ParseFilePipe with FileTypeValidator and given options","suites":["ParseFilePipeBuilder","build","when addFileTypeValidator was chained"],"updatePoint":{"line":25,"column":80,"index":1140},"line":25,"code":"      it('should return a ParseFilePipe with FileTypeValidator and given options', () => {\n        const options = {\n          fileType: 'image/jpeg'\n        };\n        const parseFilePipe = parseFilePipeBuilder.addFileTypeValidator(options).build();\n        expect(parseFilePipe.getValidators()).to.deep.include(new FileTypeValidator(options));\n      });","file":"pipes/file/parse-file-pipe.builder.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return a ParseFilePipe with TestFileValidator and given options","suites":["ParseFilePipeBuilder","build","when custom validator was chained"],"updatePoint":{"line":34,"column":80,"index":1562},"line":34,"code":"      it('should return a ParseFilePipe with TestFileValidator and given options', () => {\n        class TestFileValidator extends FileValidator {\n          buildErrorMessage(file) {\n            return 'TestFileValidator failed';\n          }\n          isValid(file) {\n            return true;\n          }\n        }\n        const options = {\n          name: 'test'\n        };\n        const parseFilePipe = parseFilePipeBuilder.addValidator(new TestFileValidator(options)).build();\n        expect(parseFilePipe.getValidators()).to.deep.include(new TestFileValidator(options));\n      });","file":"pipes/file/parse-file-pipe.builder.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should not reuse validators","suites":["ParseFilePipeBuilder","build","when it is called twice with different validators"],"updatePoint":{"line":51,"column":37,"index":2186},"line":51,"code":"      it('should not reuse validators', () => {\n        const maxSizeValidatorOptions = {\n          maxSize: 1000\n        };\n        const pipeWithMaxSizeValidator = parseFilePipeBuilder.addMaxSizeValidator(maxSizeValidatorOptions).build();\n        const fileTypeValidatorOptions = {\n          fileType: 'image/jpeg'\n        };\n        const pipeWithFileTypeValidator = parseFilePipeBuilder.addFileTypeValidator(fileTypeValidatorOptions).build();\n        expect(pipeWithFileTypeValidator.getValidators()).not.to.deep.equal(pipeWithMaxSizeValidator.getValidators());\n      });","file":"pipes/file/parse-file-pipe.builder.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return the file object","suites":["ParseFilePipe","transform","when there are no validators (explicit)"],"updatePoint":{"line":31,"column":39,"index":842},"line":31,"code":"      it('should return the file object', async () => {\n        const requestFile = {\n          path: 'some-path'\n        };\n        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(requestFile);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return the file object","suites":["ParseFilePipe","transform","when there are no validators (by default constructor)"],"updatePoint":{"line":42,"column":39,"index":1234},"line":42,"code":"      it('should return the file object', async () => {\n        const requestFile = {\n          path: 'some-path'\n        };\n        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(requestFile);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return the file object","suites":["ParseFilePipe","transform","when all the validators validate the file"],"updatePoint":{"line":55,"column":39,"index":1678},"line":55,"code":"      it('should return the file object', async () => {\n        const requestFile = {\n          path: 'some-path'\n        };\n        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(requestFile);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should throw a BadRequestException","suites":["ParseFilePipe","transform","when some validator invalidates the file","and the pipe has the default error"],"updatePoint":{"line":69,"column":46,"index":2201},"line":69,"code":"        it('should throw a BadRequestException', async () => {\n          const requestFile = {\n            path: 'some-path'\n          };\n          await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(BadRequestException);\n        });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should throw this custom Error","suites":["ParseFilePipe","transform","when some validator invalidates the file","and the pipe has a custom error code"],"updatePoint":{"line":83,"column":42,"index":2732},"line":83,"code":"        it('should throw this custom Error', async () => {\n          const requestFile = {\n            path: 'some-path'\n          };\n          await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(ConflictException);\n        });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should pass validation if no file is provided","suites":["ParseFilePipe","transform","when fileIsRequired is false"],"updatePoint":{"line":98,"column":55,"index":3211},"line":98,"code":"      it('should pass validation if no file is provided', async () => {\n        const requestFile = undefined;\n        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(requestFile);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should throw an error if no file is provided","suites":["ParseFilePipe","transform","when fileIsRequired is true"],"updatePoint":{"line":110,"column":54,"index":3630},"line":110,"code":"      it('should throw an error if no file is provided', async () => {\n        const requestFile = undefined;\n        await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(BadRequestException);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should pass validation if a file is provided","suites":["ParseFilePipe","transform","when fileIsRequired is true"],"updatePoint":{"line":114,"column":54,"index":3850},"line":114,"code":"      it('should pass validation if a file is provided', async () => {\n        const requestFile = {\n          path: 'some-path'\n        };\n        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(requestFile);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should throw an error if no file is provided","suites":["ParseFilePipe","transform","when fileIsRequired is not explicitly provided"],"updatePoint":{"line":127,"column":54,"index":4316},"line":127,"code":"      it('should throw an error if no file is provided', async () => {\n        const requestFile = undefined;\n        await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(BadRequestException);\n      });","file":"pipes/file/parse-file.pipe.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return object with forwardRef property","suites":["forwardRef"],"updatePoint":{"line":4,"column":51,"index":173},"line":4,"code":"  it('should return object with forwardRef property', () => {\n    const fn = () => ({});\n    const referenceFn = forwardRef(() => fn);\n    expect(referenceFn.forwardRef()).to.be.eql(fn);\n  });","file":"utils/forward-ref.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return package","suites":["loadPackage","when package is available"],"updatePoint":{"line":5,"column":29,"index":202},"line":5,"code":"    it('should return package', () => {\n      expect(loadPackage('reflect-metadata', 'ctx')).to.be.eql(\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require('reflect-metadata'));\n    });","file":"utils/load-package.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should enrich prototype with given values","suites":["MergeWithValues"],"updatePoint":{"line":12,"column":47,"index":322},"line":12,"code":"  it('should enrich prototype with given values', () => {\n    expect(type.prototype).to.contain(data);\n  });","file":"utils/merge-with-values.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should set name of metatype","suites":["MergeWithValues"],"updatePoint":{"line":15,"column":33,"index":417},"line":15,"code":"  it('should set name of metatype', () => {\n    expect(type.name).to.eq(Test.name + JSON.stringify(data));\n  });","file":"utils/merge-with-values.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should generate random string","suites":["randomStringGenerator"],"updatePoint":{"line":4,"column":35,"index":191},"line":4,"code":"  it('should generate random string', () => {\n    expect(randomStringGenerator()).to.be.a('string');\n  });","file":"utils/random-string-generator.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should pass error handling to first suitable error handler","suites":["selectExceptionFilterMetadata"],"updatePoint":{"line":8,"column":64,"index":327},"line":8,"code":"  it('should pass error handling to first suitable error handler', () => {\n    const metadataList = [{\n      exceptionMetatypes: [FirstError, SecondError],\n      func: () => {}\n    }, {\n      exceptionMetatypes: [ThirdError, FourthError],\n      func: () => {}\n    }];\n    expect(selectExceptionFilterMetadata(metadataList, new FourthError())).to.be.equal(metadataList[1]);\n  });","file":"utils/select-exception-filter-metadata.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should pass exception handling to the first one","suites":["selectExceptionFilterMetadata","when multiple exception handlers are accepting error handling"],"updatePoint":{"line":19,"column":55,"index":781},"line":19,"code":"    it('should pass exception handling to the first one', () => {\n      const metadataList = [{\n        exceptionMetatypes: [FirstError, SecondError],\n        func: () => {}\n      }, {\n        exceptionMetatypes: [FirstError, FourthError],\n        func: () => {}\n      }];\n      expect(selectExceptionFilterMetadata(metadataList, new FirstError())).to.be.equal(metadataList[0]);\n    });","file":"utils/select-exception-filter-metadata.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return undefined","suites":["selectExceptionFilterMetadata","when no exception handler is accepting error handling"],"updatePoint":{"line":31,"column":31,"index":1226},"line":31,"code":"    it('should return undefined', () => {\n      const metadataList = [{\n        exceptionMetatypes: [FirstError, SecondError],\n        func: () => {}\n      }, {\n        exceptionMetatypes: [FirstError, FourthError],\n        func: () => {}\n      }];\n      expect(selectExceptionFilterMetadata(metadataList, new ThirdError())).to.be.undefined;\n    });","file":"utils/select-exception-filter-metadata.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should pass any remaining error handling to it","suites":["selectExceptionFilterMetadata","when exception handler has empty list of meta types"],"updatePoint":{"line":43,"column":54,"index":1679},"line":43,"code":"    it('should pass any remaining error handling to it', () => {\n      const metadataList = [{\n        exceptionMetatypes: [FirstError, SecondError],\n        func: () => {}\n      }, {\n        exceptionMetatypes: [],\n        func: () => {}\n      }];\n      expect(selectExceptionFilterMetadata(metadataList, new ThirdError())).to.be.equal(metadataList[1]);\n    });","file":"utils/select-exception-filter-metadata.util.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when obj is undefined","suites":["Shared utils","isUndefined"],"updatePoint":{"line":8,"column":48,"index":382},"line":8,"code":"    it('should return true when obj is undefined', () => {\n      expect(isUndefined(undefined)).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when object is not undefined","suites":["Shared utils","isUndefined"],"updatePoint":{"line":11,"column":56,"index":506},"line":11,"code":"    it('should return false when object is not undefined', () => {\n      expect(isUndefined({})).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when obj is function","suites":["Shared utils","isFunction"],"updatePoint":{"line":16,"column":47,"index":654},"line":16,"code":"    it('should return true when obj is function', () => {\n      expect(isFunction(() => ({}))).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when object is not function","suites":["Shared utils","isFunction"],"updatePoint":{"line":19,"column":55,"index":777},"line":19,"code":"    it('should return false when object is not function', () => {\n      expect(isFunction(null)).to.be.false;\n      expect(isFunction(undefined)).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when obj is object","suites":["Shared utils","isObject"],"updatePoint":{"line":25,"column":45,"index":971},"line":25,"code":"    it('should return true when obj is object', () => {\n      expect(isObject({})).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when object is not object","suites":["Shared utils","isObject"],"updatePoint":{"line":28,"column":53,"index":1082},"line":28,"code":"    it('should return false when object is not object', () => {\n      expect(isObject(3)).to.be.false;\n      expect(isObject(null)).to.be.false;\n      expect(isObject(undefined)).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when obj is plain object","suites":["Shared utils","isPlainObject"],"updatePoint":{"line":35,"column":51,"index":1322},"line":35,"code":"    it('should return true when obj is plain object', () => {\n      expect(isPlainObject({})).to.be.true;\n      expect(isPlainObject({\n        prop: true\n      })).to.be.true;\n      expect(isPlainObject({\n        constructor: Foo\n      })).to.be.true;\n      expect(isPlainObject(Object.create(null))).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when object is not object","suites":["Shared utils","isPlainObject"],"updatePoint":{"line":45,"column":53,"index":1645},"line":45,"code":"    it('should return false when object is not object', () => {\n      expect(isPlainObject(3)).to.be.false;\n      expect(isPlainObject(null)).to.be.false;\n      expect(isPlainObject(undefined)).to.be.false;\n      expect(isPlainObject([1, 2, 3])).to.be.false;\n      expect(isPlainObject(new Date())).to.be.false;\n      expect(isPlainObject(new Foo(1))).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when val is a string","suites":["Shared utils","isString"],"updatePoint":{"line":55,"column":47,"index":2049},"line":55,"code":"    it('should return true when val is a string', () => {\n      expect(isString('true')).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when val is not a string","suites":["Shared utils","isString"],"updatePoint":{"line":58,"column":52,"index":2163},"line":58,"code":"    it('should return false when val is not a string', () => {\n      expect(isString(new String('fine'))).to.be.false;\n      expect(isString(false)).to.be.false;\n      expect(isString(null)).to.be.false;\n      expect(isString(undefined)).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when val is a Symbol","suites":["Shared utils","isSymbol"],"updatePoint":{"line":66,"column":47,"index":2454},"line":66,"code":"    it('should return true when val is a Symbol', () => {\n      expect(isSymbol(Symbol())).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when val is not a symbol","suites":["Shared utils","isSymbol"],"updatePoint":{"line":69,"column":52,"index":2570},"line":69,"code":"    it('should return false when val is not a symbol', () => {\n      expect(isSymbol('Symbol()')).to.be.false;\n      expect(isSymbol(false)).to.be.false;\n      expect(isSymbol(null)).to.be.false;\n      expect(isSymbol(undefined)).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when val is a number or NaN","suites":["Shared utils","isNumber"],"updatePoint":{"line":77,"column":54,"index":2860},"line":77,"code":"    it('should return true when val is a number or NaN', () => {\n      expect(isNumber(1)).to.be.true;\n      expect(isNumber(1.23)).to.be.true; // with decimals\n      expect(isNumber(123e-5)).to.be.true; // scientific (exponent) notation\n      expect(isNumber(0o1)).to.be.true; // octal notation\n      expect(isNumber(0b1)).to.be.true; // binary notation\n      expect(isNumber(0x1)).to.be.true; // hexadecimal notation\n      expect(isNumber(NaN)).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when val is not a number","suites":["Shared utils","isNumber"],"updatePoint":{"line":86,"column":52,"index":3325},"line":86,"code":"    it('should return false when val is not a number', () => {\n      // expect(isNumber(1n)).to.be.false; // big int (available on ES2020)\n      expect(isNumber('1')).to.be.false; // string\n      expect(isNumber(undefined)).to.be.false; // nullish\n      expect(isNumber(null)).to.be.false; // nullish\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when string is equal to constructor","suites":["Shared utils","isConstructor"],"updatePoint":{"line":95,"column":62,"index":3687},"line":95,"code":"    it('should return true when string is equal to constructor', () => {\n      expect(isConstructor('constructor')).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when string is not equal to constructor","suites":["Shared utils","isConstructor"],"updatePoint":{"line":98,"column":67,"index":3828},"line":98,"code":"    it('should return false when string is not equal to constructor', () => {\n      expect(isConstructor('nope')).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return the validated path (\"add / if not exists\")","suites":["Shared utils","addLeadingSlash"],"updatePoint":{"line":103,"column":64,"index":4004},"line":103,"code":"    it('should return the validated path (\"add / if not exists\")', () => {\n      expect(addLeadingSlash('nope')).to.be.eql('/nope');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return the same path","suites":["Shared utils","addLeadingSlash"],"updatePoint":{"line":106,"column":35,"index":4116},"line":106,"code":"    it('should return the same path', () => {\n      expect(addLeadingSlash('/nope')).to.be.eql('/nope');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return empty path","suites":["Shared utils","addLeadingSlash"],"updatePoint":{"line":109,"column":32,"index":4226},"line":109,"code":"    it('should return empty path', () => {\n      expect(addLeadingSlash('')).to.be.eql('');\n      expect(addLeadingSlash(null)).to.be.eql('');\n      expect(addLeadingSlash(undefined)).to.be.eql('');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should remove all trailing slashes at the end of the path","suites":["Shared utils","normalizePath"],"updatePoint":{"line":116,"column":65,"index":4508},"line":116,"code":"    it('should remove all trailing slashes at the end of the path', () => {\n      expect(normalizePath('path/')).to.be.eql('/path');\n      expect(normalizePath('path///')).to.be.eql('/path');\n      expect(normalizePath('/path/path///')).to.be.eql('/path/path');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should replace all slashes with only one slash","suites":["Shared utils","normalizePath"],"updatePoint":{"line":121,"column":54,"index":4767},"line":121,"code":"    it('should replace all slashes with only one slash', () => {\n      expect(normalizePath('////path/')).to.be.eql('/path');\n      expect(normalizePath('///')).to.be.eql('/');\n      expect(normalizePath('/path////path///')).to.be.eql('/path/path');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return / for empty path","suites":["Shared utils","normalizePath"],"updatePoint":{"line":126,"column":38,"index":5009},"line":126,"code":"    it('should return / for empty path', () => {\n      expect(normalizePath('')).to.be.eql('/');\n      expect(normalizePath(null)).to.be.eql('/');\n      expect(normalizePath(undefined)).to.be.eql('/');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when obj is undefined or null","suites":["Shared utils","isNil"],"updatePoint":{"line":133,"column":56,"index":5271},"line":133,"code":"    it('should return true when obj is undefined or null', () => {\n      expect(isNil(undefined)).to.be.true;\n      expect(isNil(null)).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when object is not undefined and null","suites":["Shared utils","isNil"],"updatePoint":{"line":137,"column":65,"index":5436},"line":137,"code":"    it('should return false when object is not undefined and null', () => {\n      expect(isNil('3')).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return true when array is empty or not exists","suites":["Shared utils","isEmpty"],"updatePoint":{"line":142,"column":60,"index":5589},"line":142,"code":"    it('should return true when array is empty or not exists', () => {\n      expect(isEmpty([])).to.be.true;\n      expect(isEmpty(null)).to.be.true;\n      expect(isEmpty(undefined)).to.be.true;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should return false when array is not empty","suites":["Shared utils","isEmpty"],"updatePoint":{"line":147,"column":51,"index":5782},"line":147,"code":"    it('should return false when array is not empty', () => {\n      expect(isEmpty([1, 2])).to.be.false;\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should strip end slash if present","suites":["Shared utils","stripEndSlash"],"updatePoint":{"line":152,"column":41,"index":5927},"line":152,"code":"    it('should strip end slash if present', () => {\n      expect(stripEndSlash('/cats/')).to.equal('/cats');\n      expect(stripEndSlash('/cats')).to.equal('/cats');\n    });","file":"utils/shared.utils.spec.ts","skipped":false,"dir":"packages/common/test"},{"name":"should set global path","suites":["ApplicationConfig","globalPath"],"updatePoint":{"line":17,"column":30},"line":17,"code":"    it('should set global path', () => {\n      const path = 'test';\n      appConfig.setGlobalPrefix(path);\n\n      expect(appConfig.getGlobalPrefix()).to.be.eql(path);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set global path options","suites":["ApplicationConfig","globalPath"],"updatePoint":{"line":23,"column":38},"line":23,"code":"    it('should set global path options', () => {\n      const options: GlobalPrefixOptions<ExcludeRouteMetadata> = {\n        exclude: [\n          {\n            path: '/health',\n            pathRegex: new RegExp(/health/),\n            requestMethod: RequestMethod.GET,\n          },\n        ],\n      };\n      appConfig.setGlobalPrefixOptions(options);\n\n      expect(appConfig.getGlobalPrefixOptions()).to.be.eql(options);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should has empty string as a global path by default","suites":["ApplicationConfig","globalPath"],"updatePoint":{"line":37,"column":59},"line":37,"code":"    it('should has empty string as a global path by default', () => {\n      expect(appConfig.getGlobalPrefix()).to.be.eql('');\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should has empty string as a global path option by default","suites":["ApplicationConfig","globalPath"],"updatePoint":{"line":40,"column":66},"line":40,"code":"    it('should has empty string as a global path option by default', () => {\n      expect(appConfig.getGlobalPrefixOptions()).to.be.eql({});\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set io adapter","suites":["ApplicationConfig","IOAdapter"],"updatePoint":{"line":45,"column":29},"line":45,"code":"    it('should set io adapter', () => {\n      const ioAdapter = { test: 0 };\n      appConfig.setIoAdapter(ioAdapter as any);\n\n      expect(appConfig.getIoAdapter()).to.be.eql(ioAdapter);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set global pipes","suites":["ApplicationConfig","Pipes"],"updatePoint":{"line":53,"column":31},"line":53,"code":"    it('should set global pipes', () => {\n      const pipes = ['test', 'test2'];\n      appConfig.useGlobalPipes(...(pipes as any));\n\n      expect(appConfig.getGlobalPipes()).to.be.eql(pipes);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add pipe","suites":["ApplicationConfig","Pipes"],"updatePoint":{"line":59,"column":23},"line":59,"code":"    it('should add pipe', () => {\n      const pipe = 'testOne';\n      appConfig.addGlobalPipe(pipe as any);\n\n      expect(appConfig.getGlobalPipes()).to.contain(pipe);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add global pipe","suites":["ApplicationConfig","Pipes"],"updatePoint":{"line":65,"column":30},"line":65,"code":"    it('should add global pipe', () => {\n      const pipe = 'testOne';\n      appConfig.addGlobalRequestPipe(pipe as any);\n\n      expect(appConfig.getGlobalRequestPipes()).to.contain(pipe);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set global filters","suites":["ApplicationConfig","Filters"],"updatePoint":{"line":73,"column":33},"line":73,"code":"    it('should set global filters', () => {\n      const filters = ['test', 'test2'];\n      appConfig.useGlobalFilters(...(filters as any));\n\n      expect(appConfig.getGlobalFilters()).to.be.eql(filters);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add filter","suites":["ApplicationConfig","Filters"],"updatePoint":{"line":79,"column":25},"line":79,"code":"    it('should add filter', () => {\n      const filter = 'testOne';\n      appConfig.addGlobalFilter(filter as any);\n\n      expect(appConfig.getGlobalFilters()).to.contain(filter);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add request filter","suites":["ApplicationConfig","Filters"],"updatePoint":{"line":85,"column":33},"line":85,"code":"    it('should add request filter', () => {\n      const filter = 'testOne';\n      appConfig.addGlobalRequestFilter(filter as any);\n\n      expect(appConfig.getGlobalRequestFilters()).to.contain(filter);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set global guards","suites":["ApplicationConfig","Guards"],"updatePoint":{"line":93,"column":32},"line":93,"code":"    it('should set global guards', () => {\n      const guards = ['test', 'test2'];\n      appConfig.useGlobalGuards(...(guards as any));\n\n      expect(appConfig.getGlobalGuards()).to.be.eql(guards);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add guard","suites":["ApplicationConfig","Guards"],"updatePoint":{"line":99,"column":24},"line":99,"code":"    it('should add guard', () => {\n      const guard = 'testOne';\n      appConfig.addGlobalGuard(guard as any);\n\n      expect(appConfig.getGlobalGuards()).to.contain(guard);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add request guard","suites":["ApplicationConfig","Guards"],"updatePoint":{"line":105,"column":32},"line":105,"code":"    it('should add request guard', () => {\n      const guard = 'testOne';\n      appConfig.addGlobalRequestGuard(guard as any);\n\n      expect(appConfig.getGlobalRequestGuards()).to.contain(guard);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set global interceptors","suites":["ApplicationConfig","Interceptors"],"updatePoint":{"line":113,"column":38},"line":113,"code":"    it('should set global interceptors', () => {\n      const interceptors = ['test', 'test2'];\n      appConfig.useGlobalInterceptors(...(interceptors as any));\n\n      expect(appConfig.getGlobalInterceptors()).to.be.eql(interceptors);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add interceptor","suites":["ApplicationConfig","Interceptors"],"updatePoint":{"line":119,"column":30},"line":119,"code":"    it('should add interceptor', () => {\n      const interceptor = 'testOne';\n      appConfig.addGlobalInterceptor(interceptor as any);\n\n      expect(appConfig.getGlobalInterceptors()).to.contain(interceptor);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add request interceptor","suites":["ApplicationConfig","Interceptors"],"updatePoint":{"line":125,"column":38},"line":125,"code":"    it('should add request interceptor', () => {\n      const interceptor = 'testOne';\n      appConfig.addGlobalRequestInterceptor(interceptor as any);\n\n      expect(appConfig.getGlobalRequestInterceptors()).to.contain(interceptor);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set versioning","suites":["ApplicationConfig","Versioning"],"updatePoint":{"line":133,"column":29},"line":133,"code":"    it('should set versioning', () => {\n      const options = { type: 'test' };\n      appConfig.enableVersioning(options as any);\n\n      expect(appConfig.getVersioning()).to.be.eql(options);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should ignore duplicated versions on defaultVersion array","suites":["ApplicationConfig","Versioning"],"updatePoint":{"line":140,"column":65},"line":140,"code":"    it('should ignore duplicated versions on defaultVersion array', () => {\n      const options = { type: 'test', defaultVersion: ['1', '2', '2', '1'] };\n      appConfig.enableVersioning(options as any);\n\n      expect(appConfig.getVersioning().defaultVersion).to.be.eql(['1', '2']);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should have undefined as the versioning by default","suites":["ApplicationConfig","Versioning"],"updatePoint":{"line":147,"column":58},"line":147,"code":"    it('should have undefined as the versioning by default', () => {\n      expect(appConfig.getVersioning()).to.be.eql(undefined);\n    });","file":"application-config.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"when exception is instanceof RuntimeException","suites":["ExceptionHandler","handle"],"updatePoint":{"line":22,"column":53},"line":22,"code":"    it('when exception is instanceof RuntimeException', () => {\n      const exception = new RuntimeException('msg');\n      instance.handle(exception);\n      expect(errorSpy.calledWith(exception.message, exception.stack)).to.be\n        .true;\n    });","file":"errors/test/exception-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"when exception is not instanceof RuntimeException","suites":["ExceptionHandler","handle"],"updatePoint":{"line":28,"column":57},"line":28,"code":"    it('when exception is not instanceof RuntimeException', () => {\n      const exception = new InvalidMiddlewareException('msg');\n      instance.handle(exception);\n      expect(errorSpy.calledWith(exception.what(), exception.stack)).to.be.true;\n    });","file":"errors/test/exception-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call callback","suites":["ExceptionsZone","run"],"updatePoint":{"line":15,"column":28},"line":15,"code":"    it('should call callback', () => {\n      ExceptionsZone.run(callback as any, rethrow);\n      expect(callback.called).to.be.true;\n    });","file":"errors/test/exceptions-zone.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"handle\" method of exceptionHandler and rethrows","suites":["ExceptionsZone","run","when callback throws exception"],"updatePoint":{"line":28,"column":70},"line":28,"code":"      it('should call \"handle\" method of exceptionHandler and rethrows', () => {\n        const throwsCallback = () => {\n          throw new Error('');\n        };\n        expect(() => ExceptionsZone.run(throwsCallback, rethrow)).to.throws();\n        expect(handleSpy.called).to.be.true;\n      });","file":"errors/test/exceptions-zone.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call callback","suites":["ExceptionsZone","asyncRun"],"updatePoint":{"line":42,"column":28},"line":42,"code":"    it('should call callback', async () => {\n      await ExceptionsZone.asyncRun(callback as any, rethrow);\n      expect(callback.called).to.be.true;\n    });","file":"errors/test/exceptions-zone.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"handle\" method of exceptionHandler and rethrows error","suites":["ExceptionsZone","asyncRun","when callback throws exception"],"updatePoint":{"line":55,"column":76},"line":55,"code":"      it('should call \"handle\" method of exceptionHandler and rethrows error', async () => {\n        const throwsCallback = () => {\n          throw new Error('');\n        };\n        expect(ExceptionsZone.asyncRun(throwsCallback, rethrow)).to.eventually\n          .be.rejected;\n      });","file":"errors/test/exceptions-zone.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display class","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":16,"column":28},"line":16,"code":"    it('should display class', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatService (?, CatService). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n      @Module({\n        imports: [ /* the Module containing dependency */ ]\n      })\n      `);\n\n      class CatService {}\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException('CatService', {\n          index,\n          dependencies: ['', CatService],\n        }).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the provide token","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":39,"column":40},"line":39,"code":"    it('should display the provide token', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatService (?, MY_TOKEN). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n      @Module({\n      imports: [ /* the Module containing dependency */ ]\n      })\n      `);\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException('CatService', {\n          index,\n          dependencies: ['', 'MY_TOKEN'],\n        }).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the function name","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":60,"column":40},"line":60,"code":"    it('should display the function name', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatService (?, CatFunction). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n      @Module({\n        imports: [ /* the Module containing dependency */ ]\n      })\n      `);\n\n      function CatFunction() {}\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException('CatService', {\n          index,\n          dependencies: ['', CatFunction],\n        }).message,\n      );\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should use \"+\" if unknown dependency name","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":81,"column":49},"line":81,"code":"    it('should use \"+\" if unknown dependency name', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatService (?, +). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n        @Module({\n          imports: [ /* the Module containing dependency */ ]\n        })\n      `);\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException('CatService', {\n          index,\n          dependencies: ['', undefined],\n        }).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the module name","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":102,"column":38},"line":102,"code":"    it('should display the module name', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatService (?, MY_TOKEN). Please make sure that the argument dependency at index [0] is available in the TestModule context.\n\n      Potential solutions:\n      - Is TestModule a valid NestJS module?\n      - If dependency is a provider, is it part of the current TestModule?\n      - If dependency is exported from a separate @Module, is that module imported within TestModule?\n        @Module({\n          imports: [ /* the Module containing dependency */ ]\n        })\n      `);\n\n      class MetaType {\n        name: string;\n      }\n      class TestModule {\n        metatype: MetaType;\n      }\n      const myModule = new TestModule();\n      const myMetaType = new MetaType();\n      myMetaType.name = 'TestModule';\n      myModule.metatype = myMetaType;\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException(\n          'CatService',\n          { index, dependencies: ['', 'MY_TOKEN'] },\n          myModule as Module,\n        ).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the symbol name of the provider","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":136,"column":54},"line":136,"code":"    it('should display the symbol name of the provider', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the Symbol(CatProvider) (?). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n        @Module({\n          imports: [ /* the Module containing dependency */ ]\n        })\n      `);\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException(Symbol('CatProvider'), {\n          index,\n          dependencies: [''],\n        }).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the symbol dependency of the provider","suites":["Error Messages","UNKNOWN_DEPENDENCIES_MESSAGE"],"updatePoint":{"line":157,"column":60},"line":157,"code":"    it('should display the symbol dependency of the provider', () => {\n      const expectedResult =\n        stringCleaner(`Nest can't resolve dependencies of the CatProvider (?, Symbol(DogProvider)). Please make sure that the argument dependency at index [0] is available in the current context.\n\n      Potential solutions:\n      - If dependency is a provider, is it part of the current Module?\n      - If dependency is exported from a separate @Module, is that module imported within Module?\n        @Module({\n          imports: [ /* the Module containing dependency */ ]\n        })\n      `);\n\n      const actualMessage = stringCleaner(\n        new UnknownDependenciesException('CatProvider', {\n          index,\n          dependencies: ['', Symbol('DogProvider')],\n        }).message,\n      );\n\n      expect(actualMessage).to.equal(expectedResult);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the module name with the undefined index and scope","suites":["Error Messages","UNDEFINED_MODULE_EXCEPTION"],"updatePoint":{"line":181,"column":73},"line":181,"code":"    it('should display the module name with the undefined index and scope', () => {\n      const expectedMessage =\n        stringCleaner(`Nest cannot create the CatsModule instance.\nThe module at index [0] of the CatsModule \"imports\" array is undefined.\n\nPotential causes:\n- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency\n- The module at index [0] is of type \"undefined\". Check your import statements and the type of the module.\n\nScope [AppModule -> CatsModule]`);\n\n      const actualMessage = stringCleaner(\n        UNDEFINED_MODULE_MESSAGE(CatsModule, 0, [AppModule, CatsModule]),\n      );\n\n      expect(actualMessage).to.be.eq(expectedMessage);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should display the module name with the invalid index and scope","suites":["Error Messages","INVALID_MODULE_MESSAGE"],"updatePoint":{"line":201,"column":71},"line":201,"code":"    it('should display the module name with the invalid index and scope', () => {\n      const expectedMessage =\n        stringCleaner(`Nest cannot create the CatsModule instance.\nReceived an unexpected value at index [0] of the CatsModule \"imports\" array.\n\nScope [AppModule -> CatsModule]`);\n\n      const actualMessage = stringCleaner(\n        INVALID_MODULE_MESSAGE(CatsModule, 0, [AppModule, CatsModule]),\n      );\n\n      expect(actualMessage).to.be.eq(expectedMessage);\n    });","file":"errors/test/messages.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["BaseExceptionFilterContext","getFilterInstance","when param is an object"],"updatePoint":{"line":19,"column":32},"line":19,"code":"      it('should return instance', () => {\n        const instance = { catch: () => null };\n        expect(filter.getFilterInstance(instance)).to.be.eql(instance);\n      });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pick instance from container","suites":["BaseExceptionFilterContext","getFilterInstance","when param is a constructor"],"updatePoint":{"line":25,"column":45},"line":25,"code":"      it('should pick instance from container', () => {\n        const wrapper = {\n          instance: 'test',\n          getInstanceByContextId: () => wrapper,\n        };\n        sinon\n          .stub(filter, 'getInstanceByMetatype')\n          .callsFake(() => wrapper as any);\n        expect(filter.getFilterInstance(Filter)).to.be.eql(wrapper.instance);\n      });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["BaseExceptionFilterContext","getFilterInstance","when param is a constructor"],"updatePoint":{"line":35,"column":28},"line":35,"code":"      it('should return null', () => {\n        sinon.stub(filter, 'getInstanceByMetatype').callsFake(() => null);\n        expect(filter.getFilterInstance(Filter)).to.be.eql(null);\n      });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["BaseExceptionFilterContext","getInstanceByMetatype","when \"moduleContext\" is nil"],"updatePoint":{"line":44,"column":33},"line":44,"code":"      it('should return undefined', () => {\n        (filter as any).moduleContext = undefined;\n        expect(filter.getInstanceByMetatype(null)).to.be.undefined;\n      });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["BaseExceptionFilterContext","getInstanceByMetatype","when \"moduleContext\" is not nil","and when module exists"],"updatePoint":{"line":55,"column":35},"line":55,"code":"        it('should return undefined', () => {\n          sinon.stub(container.getModules(), 'get').callsFake(() => undefined);\n          expect(filter.getInstanceByMetatype(null)).to.be.undefined;\n        });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["BaseExceptionFilterContext","getInstanceByMetatype","when \"moduleContext\" is not nil","and when module does not exist"],"updatePoint":{"line":62,"column":34},"line":62,"code":"        it('should return instance', () => {\n          const instance = { test: true };\n          const module = { injectables: { get: () => instance } };\n          sinon\n            .stub(container.getModules(), 'get')\n            .callsFake(() => module as any);\n          expect(filter.getInstanceByMetatype(class {})).to.be.eql(instance);\n        });","file":"exceptions/base-exception-filter.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should send expected response status code and message when exception is unknown","suites":["ExceptionsHandler","next"],"updatePoint":{"line":49,"column":87},"line":49,"code":"    it('should send expected response status code and message when exception is unknown', () => {\n      handler.next(new Error(), new ExecutionContextHost([0, response]));\n\n      expect(statusStub.calledWith(500)).to.be.true;\n      expect(\n        jsonStub.calledWith({\n          statusCode: 500,\n          message: 'Internal server error',\n        }),\n      ).to.be.true;\n    });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should send expected response status code and message","suites":["ExceptionsHandler","next","when exception is instantiated by \"http-errors\" library"],"updatePoint":{"line":61,"column":63},"line":61,"code":"      it('should send expected response status code and message', () => {\n        const error = new createHttpError.NotFound('User does not exist');\n        handler.next(error, new ExecutionContextHost([0, response]));\n\n        expect(statusStub.calledWith(404)).to.be.true;\n        expect(\n          jsonStub.calledWith({\n            statusCode: 404,\n            message: 'User does not exist',\n          }),\n        ).to.be.true;\n      });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should send expected response status code and json object","suites":["ExceptionsHandler","next","when exception is an instance of HttpException"],"updatePoint":{"line":75,"column":67},"line":75,"code":"      it('should send expected response status code and json object', () => {\n        const status = 401;\n        const message = {\n          custom: 'Unauthorized',\n        };\n        handler.next(\n          new HttpException(message, status),\n          new ExecutionContextHost([0, response]),\n        );\n\n        expect(statusStub.calledWith(status)).to.be.true;\n        expect(jsonStub.calledWith(message)).to.be.true;\n      });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should send expected response status code and transform message to json","suites":["ExceptionsHandler","next","when exception is an instance of HttpException"],"updatePoint":{"line":88,"column":81},"line":88,"code":"      it('should send expected response status code and transform message to json', () => {\n        const status = 401;\n        const message = 'Unauthorized';\n\n        handler.next(\n          new HttpException(message, status),\n          new ExecutionContextHost([0, response]),\n        );\n\n        expect(statusStub.calledWith(status)).to.be.true;\n        expect(jsonStub.calledWith({ message, statusCode: status })).to.be.true;\n      });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should do nothing","suites":["ExceptionsHandler","next","when \"invokeCustomFilters\" returns true"],"updatePoint":{"line":105,"column":27},"line":105,"code":"      it('should do nothing', () => {\n        handler.next(\n          new Error(),\n          sinon.createStubInstance(ExecutionContextHost),\n        );\n\n        expect(statusStub.notCalled).to.be.true;\n        expect(jsonStub.notCalled).to.be.true;\n      });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set custom filters","suites":["ExceptionsHandler","setCustomFilters"],"updatePoint":{"line":118,"column":33},"line":118,"code":"    it('should set custom filters', () => {\n      handler.setCustomFilters(filters as any);\n      expect((handler as any).filters).to.be.eql(filters);\n    });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception when passed argument is not an array","suites":["ExceptionsHandler","setCustomFilters"],"updatePoint":{"line":122,"column":67},"line":122,"code":"    it('should throw exception when passed argument is not an array', () => {\n      expect(() => handler.setCustomFilters(null)).to.throws(\n        InvalidExceptionFilterException,\n      );\n    });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is empty"],"updatePoint":{"line":130,"column":29},"line":130,"code":"      it('should return false', () => {\n        expect(handler.invokeCustomFilters(null, null)).to.be.false;\n      });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call funcSpy","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":146,"column":31},"line":146,"code":"        it('should call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.false;\n        });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call funcSpy with exception and response passed as an arguments","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":150,"column":82},"line":150,"code":"        it('should call funcSpy with exception and response passed as an arguments', () => {\n          const exception = new TestException();\n          const res = { foo: 'bar' };\n\n          handler.invokeCustomFilters(exception, res as any);\n          expect(funcSpy.calledWith(exception, res)).to.be.true;\n        });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":157,"column":30},"line":157,"code":"        it('should return true', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .true;\n        });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call funcSpy","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":163,"column":35},"line":163,"code":"        it('should not call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.true;\n        });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["ExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":167,"column":31},"line":167,"code":"        it('should return false', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .false;\n        });","file":"exceptions/exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return plain ExceptionHandler object","suites":["ExternalExceptionFilterContext","create","when filters metadata is empty"],"updatePoint":{"line":37,"column":53},"line":37,"code":"      it('should return plain ExceptionHandler object', () => {\n        const filter = exceptionFilter.create(\n          new EmptyMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.be.empty;\n      });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ExceptionHandler object with exception filters","suites":["ExternalExceptionFilterContext","create","when filters metadata is not empty"],"updatePoint":{"line":50,"column":70},"line":50,"code":"      it('should return ExceptionHandler object with exception filters', () => {\n        const filter = exceptionFilter.create(\n          new WithMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.not.be.empty;\n      });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return FILTER_CATCH_EXCEPTIONS metadata","suites":["ExternalExceptionFilterContext","reflectCatchExceptions"],"updatePoint":{"line":61,"column":54},"line":61,"code":"    it('should return FILTER_CATCH_EXCEPTIONS metadata', () => {\n      expect(\n        exceptionFilter.reflectCatchExceptions(new ExceptionFilter()),\n      ).to.be.eql([CustomException]);\n    });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an empty array when metadata was found","suites":["ExternalExceptionFilterContext","reflectCatchExceptions"],"updatePoint":{"line":66,"column":60},"line":66,"code":"    it('should return an empty array when metadata was found', () => {\n      expect(\n        exceptionFilter.reflectCatchExceptions(new ClassWithNoMetadata()),\n      ).to.be.eql([]);\n    });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected exception filters metadata","suites":["ExternalExceptionFilterContext","createConcreteContext"],"updatePoint":{"line":76,"column":57},"line":76,"code":"    it('should return expected exception filters metadata', () => {\n      const resolved = exceptionFilter.createConcreteContext(filters as any);\n      expect(resolved).to.have.length(1);\n      expect(resolved[0].exceptionMetatypes).to.be.deep.equal([\n        CustomException,\n      ]);\n      expect(resolved[0].func).to.be.a('function');\n    });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return global filters","suites":["ExternalExceptionFilterContext","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":88,"column":38},"line":88,"code":"      it('should return global filters', () => {\n        const expectedResult = applicationConfig.getGlobalFilters();\n        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);\n      });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should merge static global with request/transient scoped filters","suites":["ExternalExceptionFilterContext","getGlobalMetadata","otherwise"],"updatePoint":{"line":94,"column":74},"line":94,"code":"      it('should merge static global with request/transient scoped filters', () => {\n        const globalFilters: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedFilterWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalFilters')\n          .callsFake(() => globalFilters);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestFilters')\n          .callsFake(() => scopedFilterWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(\n          instance,\n          ...globalFilters,\n        );\n      });","file":"exceptions/external-exception-filter-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method returns expected stream with message when exception is unknown","suites":["ExternalExceptionsHandler","next"],"updatePoint":{"line":19,"column":84},"line":19,"code":"    it('should method returns expected stream with message when exception is unknown', () => {\n      const error = new Error();\n      expect(() => handler.next(error, null)).to.throw(error);\n    });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return observable","suites":["ExternalExceptionsHandler","next","when \"invokeCustomFilters\" returns value"],"updatePoint":{"line":28,"column":34},"line":28,"code":"      it('should return observable', () => {\n        const result = handler.next(new Error(), null);\n        expect(result).to.be.eql(observable$);\n      });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set custom filters","suites":["ExternalExceptionsHandler","setCustomFilters"],"updatePoint":{"line":36,"column":33},"line":36,"code":"    it('should set custom filters', () => {\n      handler.setCustomFilters(filters as any);\n      expect((handler as any).filters).to.be.eql(filters);\n    });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception when passed argument is not an array","suites":["ExternalExceptionsHandler","setCustomFilters"],"updatePoint":{"line":40,"column":67},"line":40,"code":"    it('should throw exception when passed argument is not an array', () => {\n      expect(() => handler.setCustomFilters(null)).to.throw();\n    });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return identity","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is empty"],"updatePoint":{"line":46,"column":32},"line":46,"code":"      it('should return identity', () => {\n        expect(handler.invokeCustomFilters(null, null)).to.be.null;\n      });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call funcSpy","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":63,"column":31},"line":63,"code":"        it('should call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.false;\n        });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call funcSpy with exception and response passed as an arguments","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":67,"column":82},"line":67,"code":"        it('should call funcSpy with exception and response passed as an arguments', () => {\n          const exception = new TestException();\n          handler.invokeCustomFilters(exception, null);\n          expect(funcSpy.calledWith(exception)).to.be.true;\n        });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return stream","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":72,"column":32},"line":72,"code":"        it('should return stream', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .not.null;\n        });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call funcSpy","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":84,"column":35},"line":84,"code":"        it('should not call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.true;\n        });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["ExternalExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":88,"column":30},"line":88,"code":"        it('should return null', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .null;\n        });","file":"exceptions/external-exceptions-handler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["GuardsConsumer","tryActivate","when guards array is empty"],"updatePoint":{"line":14,"column":28},"line":14,"code":"      it('should return true', async () => {\n        const canActivate = await consumer.tryActivate(\n          [],\n          [],\n          { constructor: null },\n          null,\n        );\n        expect(canActivate).to.be.true;\n      });","file":"guards/guards-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["GuardsConsumer","tryActivate","when guards array is not empty","when at least on guard returns false"],"updatePoint":{"line":26,"column":31},"line":26,"code":"        it('should return false', async () => {\n          const canActivate = await consumer.tryActivate(\n            [...guards, { canActivate: () => false }],\n            [],\n            { constructor: null },\n            null,\n          );\n          expect(canActivate).to.be.false;\n        });","file":"guards/guards-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["GuardsConsumer","tryActivate","when guards array is not empty","when each guard returns true"],"updatePoint":{"line":37,"column":30},"line":37,"code":"        it('should return true', async () => {\n          const canActivate = await consumer.tryActivate(\n            guards,\n            [],\n            { constructor: null },\n            null,\n          );\n          expect(canActivate).to.be.true;\n        });","file":"guards/guards-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return result","suites":["GuardsConsumer","pickResult","when result is Observable"],"updatePoint":{"line":51,"column":30},"line":51,"code":"      it('should return result', async () => {\n        expect(await consumer.pickResult(of(true))).to.be.true;\n      });","file":"guards/guards-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should await promise","suites":["GuardsConsumer","pickResult","when result is Promise"],"updatePoint":{"line":56,"column":30},"line":56,"code":"      it('should await promise', async () => {\n        expect(await consumer.pickResult(Promise.resolve(true))).to.be.true;\n      });","file":"guards/guards-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty array","suites":["GuardsContextCreator","createConcreteContext","when `moduleContext` is nil"],"updatePoint":{"line":61,"column":35},"line":61,"code":"      it('should return empty array', () => {\n        const result = guardsContextCreator.createConcreteContext(guards);\n        expect(result).to.be.empty;\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should filter metatypes","suites":["GuardsContextCreator","createConcreteContext","when `moduleContext` is defined"],"updatePoint":{"line":70,"column":33},"line":70,"code":"      it('should filter metatypes', () => {\n        const guardTypeRefs = [guards[0].metatype, guards[1].instance];\n        expect(\n          guardsContextCreator.createConcreteContext(guardTypeRefs),\n        ).to.have.length(2);\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["GuardsContextCreator","getGuardInstance","when param is an object"],"updatePoint":{"line":81,"column":32},"line":81,"code":"      it('should return instance', () => {\n        const instance = { canActivate: () => null };\n        expect(guardsContextCreator.getGuardInstance(instance)).to.be.eql(\n          instance,\n        );\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pick instance from container","suites":["GuardsContextCreator","getGuardInstance","when param is a constructor"],"updatePoint":{"line":89,"column":45},"line":89,"code":"      it('should pick instance from container', () => {\n        const wrapper = {\n          instance: 'test',\n          getInstanceByContextId: () => wrapper,\n        };\n        sinon\n          .stub(guardsContextCreator, 'getInstanceByMetatype')\n          .callsFake(() => wrapper as any);\n        expect(guardsContextCreator.getGuardInstance(Guard)).to.be.eql(\n          wrapper.instance,\n        );\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["GuardsContextCreator","getGuardInstance","when param is a constructor"],"updatePoint":{"line":101,"column":28},"line":101,"code":"      it('should return null', () => {\n        sinon\n          .stub(guardsContextCreator, 'getInstanceByMetatype')\n          .callsFake(() => null);\n        expect(guardsContextCreator.getGuardInstance(Guard)).to.be.eql(null);\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["GuardsContextCreator","getInstanceByMetatype","when \"moduleContext\" is nil"],"updatePoint":{"line":112,"column":33},"line":112,"code":"      it('should return undefined', () => {\n        (guardsContextCreator as any).moduleContext = undefined;\n        expect(guardsContextCreator.getInstanceByMetatype(null)).to.be\n          .undefined;\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["GuardsContextCreator","getInstanceByMetatype","when \"moduleContext\" is not nil","but module does not exist"],"updatePoint":{"line":124,"column":35},"line":124,"code":"        it('should return undefined', () => {\n          expect(\n            guardsContextCreator.getInstanceByMetatype(class RandomModule {}),\n          ).to.be.undefined;\n        });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return global guards","suites":["GuardsContextCreator","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":135,"column":37},"line":135,"code":"      it('should return global guards', () => {\n        const expectedResult = applicationConfig.getGlobalGuards();\n        expect(guardsContextCreator.getGlobalMetadata()).to.be.equal(\n          expectedResult,\n        );\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should merge static global with request/transient scoped guards","suites":["GuardsContextCreator","getGlobalMetadata","otherwise"],"updatePoint":{"line":143,"column":73},"line":143,"code":"      it('should merge static global with request/transient scoped guards', () => {\n        const globalGuards: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedGuardWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalGuards')\n          .callsFake(() => globalGuards);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestGuards')\n          .callsFake(() => scopedGuardWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(guardsContextCreator.getGlobalMetadata({ id: 3 })).to.contains(\n          instance,\n          ...globalGuards,\n        );\n      });","file":"guards/guards-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should wrap application reference","suites":["HttpAdapterHost"],"updatePoint":{"line":6,"column":39},"line":6,"code":"  it('should wrap application reference', () => {\n    const ref = {};\n    applicationRefHost.httpAdapter = ref as any;\n\n    expect(applicationRefHost.httpAdapter).to.be.eql(ref);\n  });","file":"helpers/application-ref-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an object with random \"id\" property","suites":["createContextId"],"updatePoint":{"line":5,"column":55},"line":5,"code":"  it('should return an object with random \"id\" property', () => {\n    expect(createContextId()).to.have.property('id');\n  });","file":"helpers/context-id-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ROUTE_ARGS_METADATA callback metadata","suites":["ContextUtils","reflectCallbackMetadata"],"updatePoint":{"line":24,"column":59},"line":24,"code":"    it('should return ROUTE_ARGS_METADATA callback metadata', () => {\n      const instance = new TestController();\n      const metadata = contextUtils.reflectCallbackMetadata(\n        instance,\n        'callback',\n        ROUTE_ARGS_METADATA,\n      );\n\n      const expectedMetadata = {\n        [`${RouteParamtypes.REQUEST}:0`]: {\n          index: 0,\n          data: undefined,\n          pipes: [],\n        },\n        [`${RouteParamtypes.BODY}:1`]: {\n          index: 1,\n          data: undefined,\n          pipes: [],\n        },\n        [`custom${CUSTOM_ROUTE_ARGS_METADATA}:2`]: {\n          index: 2,\n          factory: () => {},\n          data: undefined,\n        },\n      };\n      expect(metadata[`${RouteParamtypes.REQUEST}:0`]).to.deep.equal(\n        expectedMetadata[`${RouteParamtypes.REQUEST}:0`],\n      );\n      expect(metadata[`${RouteParamtypes.REQUEST}:1`]).to.deep.equal(\n        expectedMetadata[`${RouteParamtypes.REQUEST}:1`],\n      );\n\n      const keys = Object.keys(metadata);\n      const custom = keys.find(key => key.includes(CUSTOM_ROUTE_ARGS_METADATA));\n\n      expect(metadata[custom]).to.be.an('object');\n      expect(metadata[custom].index).to.be.eq(2);\n      expect(metadata[custom].data).to.be.eq(undefined);\n      expect(metadata[custom].factory).to.be.a('function');\n    });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return maximum index + 1 (length) placed in array","suites":["ContextUtils","getArgumentsLength"],"updatePoint":{"line":66,"column":64},"line":66,"code":"    it('should return maximum index + 1 (length) placed in array', () => {\n      const max = 4;\n      const metadata = {\n        [RouteParamtypes.REQUEST]: { index: 0 },\n        [RouteParamtypes.BODY]: {\n          index: max,\n        },\n      };\n      expect(\n        contextUtils.getArgumentsLength(Object.keys(metadata), metadata),\n      ).to.be.eq(max + 1);\n    });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create N size array filled with null","suites":["ContextUtils","createNullArray"],"updatePoint":{"line":80,"column":51},"line":80,"code":"    it('should create N size array filled with null', () => {\n      const size = 3;\n      expect(contextUtils.createNullArray(size)).to.be.deep.eq([\n        undefined,\n        undefined,\n        undefined,\n      ]);\n    });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return \"paramsProperties\" when paramtypes array doesn't exists","suites":["ContextUtils","mergeParamsMetatypes"],"updatePoint":{"line":90,"column":78},"line":90,"code":"    it('should return \"paramsProperties\" when paramtypes array doesn\\'t exists', () => {\n      const paramsProperties = ['1'];\n      expect(\n        contextUtils.mergeParamsMetatypes(paramsProperties as any, null),\n      ).to.be.eql(paramsProperties);\n    });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return curried factory","suites":["ContextUtils","getCustomFactory","when factory is function"],"updatePoint":{"line":101,"column":39},"line":101,"code":"      it('should return curried factory', () => {\n        const data = 3;\n        const result = 10;\n        const customFactory = (_, req) => result;\n\n        expect(\n          contextUtils.getCustomFactory(customFactory, data, contextFactory)(),\n        ).to.be.eql(result);\n      });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return curried null identity","suites":["ContextUtils","getCustomFactory","when factory is undefined / is not a function"],"updatePoint":{"line":112,"column":45},"line":112,"code":"      it('should return curried null identity', () => {\n        const customFactory = undefined;\n        expect(\n          contextUtils.getCustomFactory(\n            customFactory,\n            undefined,\n            contextFactory,\n          )(),\n        ).to.be.eql(null);\n      });","file":"helpers/context-utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return constructorRef","suites":["ExecutionContextHost","getClass"],"updatePoint":{"line":20,"column":36},"line":20,"code":"    it('should return constructorRef', () => {\n      expect(contextHost.getClass()).to.be.eql(constructorRef);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return handler","suites":["ExecutionContextHost","getHandler"],"updatePoint":{"line":26,"column":29},"line":26,"code":"    it('should return handler', () => {\n      expect(contextHost.getHandler()).to.be.eql(callback);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return args","suites":["ExecutionContextHost","getArgs"],"updatePoint":{"line":32,"column":26},"line":32,"code":"    it('should return args', () => {\n      expect(contextHost.getArgs()).to.be.eql(args);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return argument by index","suites":["ExecutionContextHost","getArgByIndex"],"updatePoint":{"line":38,"column":39},"line":38,"code":"    it('should return argument by index', () => {\n      expect(contextHost.getArgByIndex(0)).to.be.eql(args[0]);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return rpc proxy","suites":["ExecutionContextHost","switchToRpc"],"updatePoint":{"line":44,"column":31},"line":44,"code":"    it('should return rpc proxy', () => {\n      const proxy = contextHost.switchToRpc();\n      expect(proxy.getData).to.be.a('function');\n      expect(proxy.getContext).to.be.a('function');\n      expect(proxy.getData()).to.be.eq(args[0]);\n      expect(proxy.getContext()).to.be.eq(args[1]);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return http proxy","suites":["ExecutionContextHost","switchToHttp"],"updatePoint":{"line":54,"column":32},"line":54,"code":"    it('should return http proxy', () => {\n      const proxy = contextHost.switchToHttp();\n      expect(proxy.getRequest).to.be.a('function');\n      expect(proxy.getResponse).to.be.a('function');\n      expect(proxy.getNext).to.be.a('function');\n      expect(proxy.getRequest()).to.be.eq(args[0]);\n      expect(proxy.getResponse()).to.be.eq(args[1]);\n      expect(proxy.getNext()).to.be.eq(args[2]);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ws proxy","suites":["ExecutionContextHost","switchToWs"],"updatePoint":{"line":66,"column":30},"line":66,"code":"    it('should return ws proxy', () => {\n      const proxy = contextHost.switchToWs();\n      expect(proxy.getData).to.be.a('function');\n      expect(proxy.getClient).to.be.a('function');\n      expect(proxy.getClient()).to.be.eq(args[0]);\n      expect(proxy.getData()).to.be.eq(args[1]);\n    });","file":"helpers/execution-context-host.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"getContextModuleName\" with expected argument","suites":["ExternalContextCreator","create"],"updatePoint":{"line":53,"column":65},"line":53,"code":"    it('should call \"getContextModuleName\" with expected argument', done => {\n      const getContextModuleKeySpy = sinon.spy(\n        contextCreator,\n        'getContextModuleKey',\n      );\n      contextCreator.create({ foo: 'bar' }, callback as any, '', '', null);\n      expect(getContextModuleKeySpy.called).to.be.true;\n      done();\n    });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be a function","suites":["ExternalContextCreator","create","returns proxy function"],"updatePoint":{"line":76,"column":30},"line":76,"code":"      it('should be a function', () => {\n        expect(proxyContext).to.be.a('function');\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception when \"tryActivate\" returns false","suites":["ExternalContextCreator","create","returns proxy function","when proxy function called","when can not activate"],"updatePoint":{"line":81,"column":69},"line":81,"code":"          it('should throw exception when \"tryActivate\" returns false', async () => {\n            sinon\n              .stub(guardsConsumer, 'tryActivate')\n              .callsFake(async () => false);\n            let err: any;\n            try {\n              await proxyContext(1, 2, 3);\n            } catch (e) {\n              err = e;\n            }\n            expect(err).to.be.instanceOf(ForbiddenException);\n          });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply context and args","suites":["ExternalContextCreator","create","returns proxy function","when proxy function called","when can activate"],"updatePoint":{"line":95,"column":43},"line":95,"code":"          it('should apply context and args', async () => {\n            const args = [1, 2, 3];\n            sinon\n              .stub(guardsConsumer, 'tryActivate')\n              .callsFake(async () => true);\n\n            await proxyContext(...args);\n            expect(applySpy.called).to.be.true;\n          });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty string","suites":["ExternalContextCreator","getContextModuleKey","when constructor is undefined"],"updatePoint":{"line":110,"column":36},"line":110,"code":"      it('should return empty string', () => {\n        expect(contextCreator.getContextModuleKey(undefined)).to.be.eql('');\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return module key","suites":["ExternalContextCreator","getContextModuleKey","when module reference provider exists"],"updatePoint":{"line":115,"column":34},"line":115,"code":"      it('should return module key', () => {\n        const modules = new Map();\n        const moduleKey = 'key';\n\n        const moduleRef = new Module(class {}, modules as any);\n        modules.set(moduleKey, moduleRef);\n        (contextCreator as any).modulesContainer = modules;\n\n        sinon.stub(moduleRef, 'hasProvider').callsFake(() => true);\n\n        expect(\n          contextCreator.getContextModuleKey({ randomObject: true } as any),\n        ).to.be.eql(moduleKey);\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty string","suites":["ExternalContextCreator","getContextModuleKey","when provider does not exists"],"updatePoint":{"line":131,"column":36},"line":131,"code":"      it('should return empty string', () => {\n        expect(contextCreator.getContextModuleKey({} as any)).to.be.eql('');\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exchange arguments keys for appropriate values","suites":["ExternalContextCreator","exchangeKeysForValues"],"updatePoint":{"line":137,"column":61},"line":137,"code":"    it('should exchange arguments keys for appropriate values', () => {\n      const metadata = {\n        [RouteParamtypes.REQUEST]: { index: 0, data: 'test', pipes: [] },\n        [RouteParamtypes.BODY]: { index: 2, data: 'test', pipes: [] },\n        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {\n          index: 3,\n          data: 'custom',\n          pipes: [],\n        },\n      };\n      const keys = Object.keys(metadata);\n      const values = contextCreator.exchangeKeysForValues(\n        keys,\n        metadata,\n        '',\n        new RouteParamsFactory(),\n      );\n      const expectedValues = [\n        { index: 0, type: RouteParamtypes.REQUEST, data: 'test' },\n        { index: 2, type: RouteParamtypes.BODY, data: 'test' },\n        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },\n      ];\n      expect(values[0]).to.deep.include(expectedValues[0]);\n      expect(values[1]).to.deep.include(expectedValues[1]);\n    });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"consumer.apply\"","suites":["ExternalContextCreator","getParamValue"],"updatePoint":{"line":172,"column":36},"line":172,"code":"    it('should call \"consumer.apply\"', () => {\n      contextCreator.getParamValue(\n        value,\n        { metatype, type: RouteParamtypes.NEXT, data: null },\n        transforms,\n      );\n      expect(consumerApplySpy.called).to.be.true;\n    });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns null","suites":["ExternalContextCreator","createPipesFn","when \"paramsOptions\" is empty"],"updatePoint":{"line":183,"column":22},"line":183,"code":"      it('returns null', async () => {\n        const pipesFn = contextCreator.createPipesFn([], []);\n        expect(pipesFn).to.be.null;\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns function","suites":["ExternalContextCreator","createPipesFn","when \"paramsOptions\" is not empty"],"updatePoint":{"line":189,"column":26},"line":189,"code":"      it('returns function', async () => {\n        const pipesFn = contextCreator.createPipesFn(\n          [],\n          [\n            {\n              index: 1,\n              type: 'test',\n              data: null,\n              pipes: [],\n              extractValue: () => null,\n            },\n          ],\n        );\n        await pipesFn([]);\n        expect(pipesFn).to.be.a('function');\n      });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Promise","suites":["ExternalContextCreator","transformToResult","when resultOrDeferred","is Promise"],"updatePoint":{"line":211,"column":33},"line":211,"code":"        it('should return Promise', async () => {\n          const value = 100;\n          expect(\n            await contextCreator.transformToResult(Promise.resolve(value)),\n          ).to.be.eq(100);\n        });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Promise","suites":["ExternalContextCreator","transformToResult","when resultOrDeferred","is Observable"],"updatePoint":{"line":220,"column":33},"line":220,"code":"        it('should return Promise', async () => {\n          const value = 100;\n          expect(await contextCreator.transformToResult(of(value))).to.be.eq(\n            100,\n          );\n        });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Promise","suites":["ExternalContextCreator","transformToResult","when resultOrDeferred","is value"],"updatePoint":{"line":229,"column":33},"line":229,"code":"        it('should return Promise', async () => {\n          const value = 100;\n          expect(await contextCreator.transformToResult(value)).to.be.eq(100);\n        });","file":"helpers/external-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return thunk","suites":["ExternalErrorProxy","createProxy"],"updatePoint":{"line":19,"column":34},"line":19,"code":"    it('should method return thunk', () => {\n      const proxy = externalErrorProxy.createProxy(() => {}, handler);\n      expect(typeof proxy === 'function').to.be.true;\n    });","file":"helpers/external-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate callback passed as argument","suites":["ExternalErrorProxy","createProxy"],"updatePoint":{"line":24,"column":61},"line":24,"code":"    it('should method encapsulate callback passed as argument', () => {\n      const expectation = handlerMock.expects('next').once();\n      const proxy = externalErrorProxy.createProxy((req, res, next) => {\n        throw new HttpException('test', 500);\n      }, handler);\n      proxy(null, null, null);\n      expectation.verify();\n    });","file":"helpers/external-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate async callback passed as argument","suites":["ExternalErrorProxy","createProxy"],"updatePoint":{"line":33,"column":67},"line":33,"code":"    it('should method encapsulate async callback passed as argument', done => {\n      const expectation = handlerMock.expects('next').once();\n      const proxy = externalErrorProxy.createProxy(async (req, res, next) => {\n        throw new HttpException('test', 500);\n      }, handler);\n      proxy(null, null, null);\n\n      setTimeout(() => {\n        expectation.verify();\n        done();\n      }, 0);\n    });","file":"helpers/external-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return proper method","suites":["RouterMethodFactory"],"updatePoint":{"line":23,"column":33},"line":23,"code":"  it('should return proper method', () => {\n    expect(factory.get(target, RequestMethod.DELETE)).to.equal(target.delete);\n    expect(factory.get(target, RequestMethod.POST)).to.equal(target.post);\n    expect(factory.get(target, RequestMethod.ALL)).to.equal(target.all);\n    expect(factory.get(target, RequestMethod.PUT)).to.equal(target.put);\n    expect(factory.get(target, RequestMethod.GET)).to.equal(target.get);\n    expect(factory.get(target, RequestMethod.PATCH)).to.equal(target.patch);\n    expect(factory.get(target, RequestMethod.OPTIONS)).to.equal(target.options);\n    expect(factory.get(target, RequestMethod.HEAD)).to.equal(target.head);\n    expect(factory.get(target, -1 as any)).to.equal(target.use);\n  });","file":"helpers/router-method-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"beforeApplicationShutdown\" hook for the entire module","suites":["BeforeAppShutdown","callBeforeAppShutdownHook"],"updatePoint":{"line":40,"column":74},"line":40,"code":"    it('should call \"beforeApplicationShutdown\" hook for the entire module', async () => {\n      const signal = 'SIGTERM';\n\n      const hookSpy = sinon.spy(sampleProvider, 'beforeApplicationShutdown');\n      await callBeforeAppShutdownHook(moduleRef, signal);\n\n      expect(hookSpy.calledWith(signal)).to.be.true;\n    });","file":"hooks/before-app-shutdown.hook.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"onApplicationBootstrap\" hook for the entire module","suites":["OnApplicationBootstrap","callModuleBootstrapHook"],"updatePoint":{"line":40,"column":71},"line":40,"code":"    it('should call \"onApplicationBootstrap\" hook for the entire module', async () => {\n      const hookSpy = sinon.spy(sampleProvider, 'onApplicationBootstrap');\n      await callModuleBootstrapHook(moduleRef);\n\n      expect(hookSpy.called).to.be.true;\n    });","file":"hooks/on-app-bootstrap.hook.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"onApplicationShutdown\" hook for the entire module","suites":["OnApplicationShutdown","callAppShutdownHook"],"updatePoint":{"line":40,"column":70},"line":40,"code":"    it('should call \"onApplicationShutdown\" hook for the entire module', async () => {\n      const hookSpy = sinon.spy(sampleProvider, 'onApplicationShutdown');\n      await callAppShutdownHook(moduleRef);\n\n      expect(hookSpy.called).to.be.true;\n    });","file":"hooks/on-app-shutdown.hook.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"onModuleDestroy\" hook for the entire module","suites":["OnModuleDestroy","callModuleDestroyHook"],"updatePoint":{"line":40,"column":64},"line":40,"code":"    it('should call \"onModuleDestroy\" hook for the entire module', async () => {\n      const hookSpy = sinon.spy(sampleProvider, 'onModuleDestroy');\n      await callModuleDestroyHook(moduleRef);\n\n      expect(hookSpy.called).to.be.true;\n    });","file":"hooks/on-module-destroy.hook.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"onModuleInit\" hook for the entire module","suites":["OnModuleInit","callModuleInitHook"],"updatePoint":{"line":40,"column":61},"line":40,"code":"    it('should call \"onModuleInit\" hook for the entire module', async () => {\n      const hookSpy = sinon.spy(sampleProvider, 'onModuleInit');\n      await callModuleInitHook(moduleRef);\n\n      expect(hookSpy.called).to.be.true;\n    });","file":"hooks/on-module-init.hook.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return object with \"type\" and \"dynamicMetadata\" property","suites":["ModuleCompiler","extractMetadata","when module is a dynamic module"],"updatePoint":{"line":12,"column":73},"line":12,"code":"      it('should return object with \"type\" and \"dynamicMetadata\" property', async () => {\n        const obj = { module: 'test', providers: [] };\n        const { module, ...dynamicMetadata } = obj;\n        expect(await compiler.extractMetadata(obj as any)).to.be.deep.equal({\n          type: module,\n          dynamicMetadata,\n        });\n      });","file":"injector/compiler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return object with \"type\" property","suites":["ModuleCompiler","extractMetadata","when module is a not dynamic module"],"updatePoint":{"line":22,"column":51},"line":22,"code":"      it('should return object with \"type\" property', async () => {\n        const type = 'test';\n        expect(await compiler.extractMetadata(type as any)).to.be.deep.equal({\n          type,\n        });\n      });","file":"injector/compiler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["ModuleCompiler","isDynamicModule","when module is a dynamic module"],"updatePoint":{"line":33,"column":28},"line":33,"code":"      it('should return true', () => {\n        expect(compiler.isDynamicModule({ module: true } as any)).to.be.true;\n      });","file":"injector/compiler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["ModuleCompiler","isDynamicModule","when module is a dynamic module"],"updatePoint":{"line":38,"column":29},"line":38,"code":"      it('should return false', () => {\n        expect(compiler.isDynamicModule({ x: true } as any)).to.be.false;\n      });","file":"injector/compiler.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"addProvider\" throw \"UnknownModuleException\" when module is not stored in collection","suites":["NestContainer"],"updatePoint":{"line":24,"column":97},"line":24,"code":"  it('should \"addProvider\" throw \"UnknownModuleException\" when module is not stored in collection', () => {\n    expect(() => container.addProvider({} as any, 'TestModule')).throw(\n      UnknownModuleException,\n    );\n  });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"addProvider\" throw \"CircularDependencyException\" when provider is nil","suites":["NestContainer"],"updatePoint":{"line":30,"column":83},"line":30,"code":"  it('should \"addProvider\" throw \"CircularDependencyException\" when provider is nil', () => {\n    expect(() => container.addProvider(null, 'TestModule')).throw(\n      CircularDependencyException,\n    );\n  });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"addController\" throw \"UnknownModuleException\" when module is not stored in collection","suites":["NestContainer"],"updatePoint":{"line":36,"column":99},"line":36,"code":"  it('should \"addController\" throw \"UnknownModuleException\" when module is not stored in collection', () => {\n    expect(() => container.addController(null, 'TestModule')).throw(\n      UnknownModuleException,\n    );\n  });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"addExportedProvider\" throw \"UnknownModuleException\" when module is not stored in collection","suites":["NestContainer"],"updatePoint":{"line":42,"column":105},"line":42,"code":"  it('should \"addExportedProvider\" throw \"UnknownModuleException\" when module is not stored in collection', () => {\n    expect(() => container.addExportedProvider(null, 'TestModule')).throw(\n      UnknownModuleException,\n    );\n  });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"addInjectable\" throw \"UnknownModuleException\" when module is not stored in collection","suites":["NestContainer"],"updatePoint":{"line":48,"column":99},"line":48,"code":"  it('should \"addInjectable\" throw \"UnknownModuleException\" when module is not stored in collection', () => {\n    expect(() => container.addInjectable(null, 'TestModule', null)).throw(\n      UnknownModuleException,\n    );\n  });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `clear` on modules collection","suites":["NestContainer","clear"],"updatePoint":{"line":55,"column":49},"line":55,"code":"    it('should call `clear` on modules collection', () => {\n      const clearSpy = sinon.spy((container as any).modules, 'clear');\n      container.clear();\n      expect(clearSpy.called).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not add module if already exists in collection","suites":["NestContainer","addModule"],"updatePoint":{"line":63,"column":61},"line":63,"code":"    it('should not add module if already exists in collection', async () => {\n      const modules = new Map();\n      const setSpy = sinon.spy(modules, 'set');\n      (container as any).modules = modules;\n\n      await container.addModule(TestModule as any, []);\n      await container.addModule(TestModule as any, []);\n\n      expect(setSpy.calledOnce).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an exception when metatype is not defined","suites":["NestContainer","addModule"],"updatePoint":{"line":74,"column":62},"line":74,"code":"    it('should throw an exception when metatype is not defined', () => {\n      expect(container.addModule(undefined, [])).to.eventually.throws();\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add global module when module is global","suites":["NestContainer","addModule"],"updatePoint":{"line":78,"column":54},"line":78,"code":"    it('should add global module when module is global', async () => {\n      const addGlobalModuleSpy = sinon.spy(container, 'addGlobalModule');\n      await container.addModule(GlobalTestModule as any, []);\n      expect(addGlobalModuleSpy.calledOnce).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should replace module if already exists in collection","suites":["NestContainer","replaceModule"],"updatePoint":{"line":86,"column":61},"line":86,"code":"    it('should replace module if already exists in collection', async () => {\n      @Module({})\n      class ReplaceTestModule {}\n\n      const modules = new Map();\n      const setSpy = sinon.spy(modules, 'set');\n      (container as any).modules = modules;\n\n      await container.addModule(TestModule as any, []);\n      await container.replaceModule(\n        TestModule as any,\n        ReplaceTestModule as any,\n        [],\n      );\n\n      expect(setSpy.calledTwice).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an exception when metatype is not defined","suites":["NestContainer","replaceModule"],"updatePoint":{"line":104,"column":62},"line":104,"code":"    it('should throw an exception when metatype is not defined', () => {\n      expect(container.addModule(undefined, [])).to.eventually.throws();\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add global module when module is global","suites":["NestContainer","replaceModule"],"updatePoint":{"line":108,"column":54},"line":108,"code":"    it('should add global module when module is global', async () => {\n      const addGlobalModuleSpy = sinon.spy(container, 'addGlobalModule');\n      await container.addModule(GlobalTestModule as any, []);\n      expect(addGlobalModuleSpy.calledOnce).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["NestContainer","isGlobalModule","when module is not globally scoped"],"updatePoint":{"line":117,"column":29},"line":117,"code":"      it('should return false', () => {\n        expect(container.isGlobalModule(TestModule)).to.be.false;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["NestContainer","isGlobalModule","when module is globally scoped"],"updatePoint":{"line":122,"column":28},"line":122,"code":"      it('should return true', () => {\n        expect(container.isGlobalModule(GlobalTestModule)).to.be.true;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["NestContainer","isGlobalModule","when dynamic module is globally scoped"],"updatePoint":{"line":127,"column":28},"line":127,"code":"      it('should return true', () => {\n        expect(container.isGlobalModule(TestModule, { global: true })).to.be\n          .true;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"bindGlobalModuleToModule\" for every global module","suites":["NestContainer","bindGlobalsToImports"],"updatePoint":{"line":135,"column":70},"line":135,"code":"    it('should call \"bindGlobalModuleToModule\" for every global module', () => {\n      const global1 = { test: 1 };\n      const global2 = { test: 2 };\n\n      container.addGlobalModule(global1 as any);\n      container.addGlobalModule(global2 as any);\n\n      const bindGlobalModuleToModuleSpy = sinon.spy(\n        container,\n        'bindGlobalModuleToModule',\n      );\n      container.bindGlobalsToImports({\n        addRelatedModule: sinon.spy(),\n      } as any);\n      expect(bindGlobalModuleToModuleSpy.calledTwice).to.be.true;\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addRelatedModule\"","suites":["NestContainer","bindGlobalModuleToModule","when \"module\" is not \"globalModule\""],"updatePoint":{"line":155,"column":40},"line":155,"code":"      it('should call \"addRelatedModule\"', () => {\n        const module = { addRelatedModule: sinon.spy() };\n        container.bindGlobalModuleToModule(module as any, null);\n        expect(module.addRelatedModule.calledOnce).to.be.true;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"addRelatedModule\"","suites":["NestContainer","bindGlobalModuleToModule","when \"module\" is \"globalModule\""],"updatePoint":{"line":162,"column":44},"line":162,"code":"      it('should not call \"addRelatedModule\"', () => {\n        const module = { addRelatedModule: sinon.spy() };\n        container.bindGlobalModuleToModule(module as any, module as any);\n        expect(module.addRelatedModule.calledOnce).to.be.false;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add to the dynamic metadata collection","suites":["NestContainer","addDynamicMetadata","when dynamic metadata exists"],"updatePoint":{"line":180,"column":55},"line":180,"code":"      it('should add to the dynamic metadata collection', () => {\n        const addSpy = sinon.spy(collection, 'set');\n        const dynamicMetadata = { module: null };\n\n        container.addDynamicMetadata(token, dynamicMetadata, []);\n        expect(addSpy.calledWith(token, dynamicMetadata)).to.be.true;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not add to the dynamic metadata collection","suites":["NestContainer","addDynamicMetadata","when dynamic metadata does not exists"],"updatePoint":{"line":189,"column":59},"line":189,"code":"      it('should not add to the dynamic metadata collection', () => {\n        const addSpy = sinon.spy(collection, 'set');\n        container.addDynamicMetadata(token, null, []);\n        expect(addSpy.called).to.be.false;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"addModule\"","suites":["NestContainer","addDynamicModules","when array is empty/undefined"],"updatePoint":{"line":200,"column":37},"line":200,"code":"      it('should not call \"addModule\"', () => {\n        const addModuleSpy = sinon.spy(container, 'addModule');\n        container.addDynamicModules(undefined, []);\n        expect(addModuleSpy.called).to.be.false;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addModule\"","suites":["NestContainer","addDynamicModules","when array is not empty/undefined"],"updatePoint":{"line":207,"column":33},"line":207,"code":"      it('should call \"addModule\"', () => {\n        const addModuleSpy = sinon.spy(container, 'addModule');\n        container.addDynamicModules([Test] as any, []);\n        expect(addModuleSpy.called).to.be.true;\n      });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ApplicationConfig instance","suites":["NestContainer","get applicationConfig"],"updatePoint":{"line":216,"column":48},"line":216,"code":"    it('should return ApplicationConfig instance', () => {\n      expect(container.applicationConfig).to.be.eql(\n        (container as any)._applicationConfig,\n      );\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set http adapter","suites":["NestContainer","setHttpAdapter"],"updatePoint":{"line":224,"column":31},"line":224,"code":"    it('should set http adapter', () => {\n      const httpAdapter = new NoopHttpAdapter({});\n      container.setHttpAdapter(httpAdapter);\n\n      const internalStorage = (container as any).internalProvidersStorage;\n      expect(internalStorage.httpAdapter).to.be.eql(httpAdapter);\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return module by passed key","suites":["NestContainer","getModuleByKey"],"updatePoint":{"line":234,"column":42},"line":234,"code":"    it('should return module by passed key', () => {\n      const key = 'test';\n      const value = {};\n      container.getModules().set(key, value as any);\n\n      expect(container.getModuleByKey(key)).to.be.eql(value);\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register core module ref","suites":["NestContainer","registerCoreModuleRef"],"updatePoint":{"line":244,"column":39},"line":244,"code":"    it('should register core module ref', () => {\n      const ref = {} as any;\n      container.registerCoreModuleRef(ref);\n      expect((container as any).internalCoreModule).to.be.eql(ref);\n    });","file":"injector/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useClass is present","suites":["provider classifier","isClassProvider"],"updatePoint":{"line":11,"column":49},"line":11,"code":"    it('should return true if useClass is present', () => {\n      const classProvider: ClassProvider = {\n        useClass: class TestClass {},\n        provide: 'token',\n      };\n\n      expect(isClassProvider(classProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useClass is undefined","suites":["provider classifier","isClassProvider"],"updatePoint":{"line":20,"column":52},"line":20,"code":"    it('should return false if useClass is undefined', () => {\n      const classProvider: ClassProvider = {\n        useClass: undefined,\n        provide: 'token',\n      };\n\n      expect(isClassProvider(classProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useClass is not present","suites":["provider classifier","isClassProvider"],"updatePoint":{"line":29,"column":54},"line":29,"code":"    it('should return false if useClass is not present', () => {\n      const classProvider = {\n        provide: 'token',\n      };\n\n      expect(isClassProvider(classProvider as ClassProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if provider is undefined","suites":["provider classifier","isClassProvider"],"updatePoint":{"line":37,"column":52},"line":37,"code":"    it('should return false if provider is undefined', () => {\n      const classProvider = undefined;\n\n      expect(isClassProvider(classProvider as ClassProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useValue is not undefined","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":45,"column":55},"line":45,"code":"    it('should return true if useValue is not undefined', () => {\n      const valueProvider: ValueProvider = {\n        useValue: 'value',\n        provide: 'token',\n      };\n\n      expect(isValueProvider(valueProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useValue is \"false\"","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":54,"column":49},"line":54,"code":"    it('should return true if useValue is \"false\"', () => {\n      const valueProvider: ValueProvider = {\n        useValue: false,\n        provide: 'token',\n      };\n\n      expect(isValueProvider(valueProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useValue is \"null\"","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":63,"column":48},"line":63,"code":"    it('should return true if useValue is \"null\"', () => {\n      const valueProvider: ValueProvider = {\n        useValue: null,\n        provide: 'token',\n      };\n\n      expect(isValueProvider(valueProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useValue is an empty string","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":72,"column":57},"line":72,"code":"    it('should return true if useValue is an empty string', () => {\n      const valueProvider: ValueProvider = {\n        useValue: null,\n        provide: '',\n      };\n\n      expect(isValueProvider(valueProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useValue is undefined","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":81,"column":52},"line":81,"code":"    it('should return false if useValue is undefined', () => {\n      const valueProvider: ValueProvider = {\n        useValue: undefined,\n        provide: 'token',\n      };\n\n      expect(isValueProvider(valueProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useValue is not present","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":90,"column":54},"line":90,"code":"    it('should return false if useValue is not present', () => {\n      const valueProvider = {\n        provide: 'token',\n      };\n\n      expect(isValueProvider(valueProvider as ValueProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if provider is undefined","suites":["provider classifier","isValueProvider"],"updatePoint":{"line":98,"column":52},"line":98,"code":"    it('should return false if provider is undefined', () => {\n      const valueProvider = undefined;\n\n      expect(isValueProvider(valueProvider as ValueProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true if useFactory is present","suites":["provider classifier","isFactoryProvider"],"updatePoint":{"line":106,"column":51},"line":106,"code":"    it('should return true if useFactory is present', () => {\n      const factoryProvider: FactoryProvider = {\n        provide: 'token',\n        useFactory: () => {},\n      };\n\n      expect(isFactoryProvider(factoryProvider)).to.be.true;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useFactory is not present","suites":["provider classifier","isFactoryProvider"],"updatePoint":{"line":115,"column":56},"line":115,"code":"    it('should return false if useFactory is not present', () => {\n      const factoryProvider = {\n        provide: 'token',\n      };\n\n      expect(isFactoryProvider(factoryProvider as FactoryProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false if useFactory is undefined","suites":["provider classifier","isFactoryProvider"],"updatePoint":{"line":123,"column":54},"line":123,"code":"    it('should return false if useFactory is undefined', () => {\n      const factoryProvider: FactoryProvider = {\n        provide: 'token',\n        useFactory: undefined,\n      };\n\n      expect(isFactoryProvider(factoryProvider as FactoryProvider)).to.be.false;\n    });","file":"injector/helpers/provider-classifier.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create an instance of component with proper dependencies","suites":["Injector","loadInstance"],"updatePoint":{"line":73,"column":71},"line":73,"code":"    it('should create an instance of component with proper dependencies', async () => {\n      await injector.loadInstance(mainTest, moduleDeps.providers, moduleDeps);\n      const { instance } = moduleDeps.providers.get(\n        'MainTest',\n      ) as InstanceWrapper<MainTest>;\n\n      expect(instance.one).instanceof(DependencyOne);\n      expect(instance.two).instanceof(DependencyTwo);\n      expect(instance).instanceof(MainTest);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set \"isResolved\" property to true after instance initialization","suites":["Injector","loadInstance"],"updatePoint":{"line":84,"column":78},"line":84,"code":"    it('should set \"isResolved\" property to true after instance initialization', async () => {\n      await injector.loadInstance(mainTest, moduleDeps.providers, moduleDeps);\n      const { isResolved } = (\n        moduleDeps.providers.get('MainTest') as InstanceWrapper<MainTest>\n      ).getInstanceByContextId(STATIC_CONTEXT);\n      expect(isResolved).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw RuntimeException when type is not stored in collection","suites":["Injector","loadInstance"],"updatePoint":{"line":92,"column":75},"line":92,"code":"    it('should throw RuntimeException when type is not stored in collection', () => {\n      return expect(\n        injector.loadInstance({} as any, moduleDeps.providers, moduleDeps),\n      ).to.eventually.be.rejected;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should await done$ when \"isPending\"","suites":["Injector","loadInstance"],"updatePoint":{"line":98,"column":43},"line":98,"code":"    it('should await done$ when \"isPending\"', () => {\n      const wrapper = new InstanceWrapper({\n        name: 'MainTest',\n        metatype: MainTest,\n        instance: Object.create(MainTest.prototype),\n        isResolved: false,\n      });\n      const host = wrapper.getInstanceByContextId(STATIC_CONTEXT);\n      host.donePromise = Promise.resolve();\n      host.isPending = true;\n\n      expect(\n        injector.loadInstance(wrapper, moduleDeps.providers, moduleDeps),\n      ).to.eventually.not.throw();\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should await done$ when \"isPending\" and rethrow an exception (if thrown)","suites":["Injector","loadInstance"],"updatePoint":{"line":114,"column":80},"line":114,"code":"    it('should await done$ when \"isPending\" and rethrow an exception (if thrown)', () => {\n      const error = new Error('Test error');\n      const wrapper = new InstanceWrapper({\n        name: 'MainTest',\n        metatype: MainTest,\n        instance: Object.create(MainTest.prototype),\n        isResolved: false,\n      });\n      const host = wrapper.getInstanceByContextId(STATIC_CONTEXT);\n      host.donePromise = Promise.resolve(error);\n      host.isPending = true;\n\n      expect(\n        injector.loadInstance(wrapper, moduleDeps.providers, moduleDeps),\n      ).to.eventually.throw(error);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined when metatype is resolved","suites":["Injector","loadInstance"],"updatePoint":{"line":131,"column":57},"line":131,"code":"    it('should return undefined when metatype is resolved', async () => {\n      const result = await injector.loadInstance(\n        new InstanceWrapper({\n          name: 'MainTestResolved',\n          metatype: MainTest,\n          instance: Object.create(MainTest.prototype),\n          isResolved: true,\n        }),\n        moduleDeps.providers,\n        moduleDeps,\n      );\n      expect(result).to.be.undefined;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should create prototype of instance","suites":["Injector","loadPrototype"],"updatePoint":{"line":165,"column":43},"line":165,"code":"    it('should create prototype of instance', () => {\n      injector.loadPrototype(test, moduleDeps.providers);\n      expect(moduleDeps.providers.get('Test').instance).to.deep.equal(\n        Object.create(Test.prototype),\n      );\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined when collection is nil","suites":["Injector","loadPrototype"],"updatePoint":{"line":172,"column":54},"line":172,"code":"    it('should return undefined when collection is nil', () => {\n      const result = injector.loadPrototype(test, null);\n      expect(result).to.be.undefined;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined when target isResolved","suites":["Injector","loadPrototype"],"updatePoint":{"line":177,"column":54},"line":177,"code":"    it('should return undefined when target isResolved', () => {\n      const collection = {\n        get: () => ({\n          getInstanceByContextId: () => ({ isResolved: true }),\n          createPrototype: () => {},\n        }),\n      };\n      const result = injector.loadPrototype(test, collection as any);\n      expect(result).to.be.undefined;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined when \"inject\" is not nil","suites":["Injector","loadPrototype"],"updatePoint":{"line":188,"column":56},"line":188,"code":"    it('should return undefined when \"inject\" is not nil', () => {\n      const collection = {\n        get: () => new InstanceWrapper({ inject: [] }),\n      };\n      const result = injector.loadPrototype(test, collection as any);\n      expect(result).to.be.undefined;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"RuntimeException\" when param is undefined","suites":["Injector","resolveSingleParam"],"updatePoint":{"line":198,"column":63},"line":198,"code":"    it('should throw \"RuntimeException\" when param is undefined', async () => {\n      return expect(\n        injector.resolveSingleParam(\n          null,\n          undefined,\n          { index: 0, dependencies: [] },\n          null,\n        ),\n      ).to.eventually.be.rejected;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadInstance\" when instance is not resolved","suites":["Injector","loadMiddleware"],"updatePoint":{"line":218,"column":64},"line":218,"code":"    it('should call \"loadInstance\" when instance is not resolved', () => {\n      const collection = {\n        get: (...args) => ({}),\n        set: (...args) => {},\n      };\n\n      injector.loadMiddleware(\n        { metatype: { name: '', prototype: {} } } as any,\n        collection as any,\n        null,\n      );\n      expect(loadInstanceSpy.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"loadInstanceSpy\" when instance is not resolved","suites":["Injector","loadMiddleware"],"updatePoint":{"line":232,"column":71},"line":232,"code":"    it('should not call \"loadInstanceSpy\" when instance is not resolved', () => {\n      const collection = {\n        get: (...args) => ({\n          instance: {},\n        }),\n        set: (...args) => {},\n      };\n\n      injector.loadMiddleware(\n        { metatype: { name: '' } } as any,\n        collection as any,\n        null,\n      );\n      expect(loadInstanceSpy.called).to.be.false;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadInstance\" with expected arguments","suites":["Injector","loadController"],"updatePoint":{"line":257,"column":58},"line":257,"code":"    it('should call \"loadInstance\" with expected arguments', async () => {\n      const module = { controllers: [] };\n      const wrapper = { test: 'test', getEnhancersMetadata: () => [] };\n\n      await injector.loadController(wrapper as any, module as any);\n      expect(loadInstance.calledWith(wrapper, module.controllers, module)).to.be\n        .true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadInstance\" with expected arguments","suites":["Injector","loadInjectable"],"updatePoint":{"line":275,"column":58},"line":275,"code":"    it('should call \"loadInstance\" with expected arguments', async () => {\n      const module = { injectables: [] };\n      const wrapper = { test: 'test' };\n\n      await injector.loadInjectable(wrapper as any, module as any);\n      expect(loadInstance.calledWith(wrapper, module.injectables, module)).to.be\n        .true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return object from collection if exists","suites":["Injector","lookupComponent"],"updatePoint":{"line":299,"column":54},"line":299,"code":"    it('should return object from collection if exists', async () => {\n      const instance = { test: 3 };\n      const collection = {\n        has: () => true,\n        get: () => instance,\n      };\n      const result = await injector.lookupComponent(\n        collection as any,\n        null,\n        { name: metatype.name, index: 0, dependencies: [] },\n        wrapper,\n      );\n      expect(result).to.be.equal(instance);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an exception if recursion happens","suites":["Injector","lookupComponent"],"updatePoint":{"line":314,"column":54},"line":314,"code":"    it('should throw an exception if recursion happens', () => {\n      const name = 'RecursionService';\n      const instance = { test: 3 };\n      const collection = {\n        has: () => true,\n        get: () => instance,\n      };\n      const result = injector.lookupComponent(\n        collection as any,\n        null,\n        { name, index: 0, dependencies: [] },\n        Object.assign(wrapper, {\n          name,\n        }),\n      );\n      expect(result).to.eventually.be.rejected;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"lookupComponentInImports\" when object is not in collection","suites":["Injector","lookupComponent"],"updatePoint":{"line":332,"column":79},"line":332,"code":"    it('should call \"lookupComponentInImports\" when object is not in collection', async () => {\n      lookupComponentInImports.returns({});\n      const collection = {\n        has: () => false,\n      };\n      await injector.lookupComponent(\n        collection as any,\n        null,\n        { name: metatype.name, index: 0, dependencies: [] },\n        wrapper,\n      );\n      expect(lookupComponentInImports.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"UnknownDependenciesException\" when instanceWrapper is null and \"exports\" collection does not contain token","suites":["Injector","lookupComponent"],"updatePoint":{"line":346,"column":128},"line":346,"code":"    it('should throw \"UnknownDependenciesException\" when instanceWrapper is null and \"exports\" collection does not contain token', () => {\n      lookupComponentInImports.returns(null);\n      const collection = {\n        has: () => false,\n      };\n      const module = { exports: collection };\n      expect(\n        injector.lookupComponent(\n          collection as any,\n          module as any,\n          { name: metatype.name, index: 0, dependencies: [] },\n          wrapper,\n        ),\n      ).to.eventually.be.rejected;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not throw \"UnknownDependenciesException\" instanceWrapper is not null","suites":["Injector","lookupComponent"],"updatePoint":{"line":362,"column":83},"line":362,"code":"    it('should not throw \"UnknownDependenciesException\" instanceWrapper is not null', () => {\n      lookupComponentInImports.returns({});\n      const collection = {\n        has: () => false,\n      };\n      const module = { exports: collection };\n      expect(\n        injector.lookupComponent(\n          collection as any,\n          module as any,\n          { name: metatype.name, index: 0, dependencies: [] },\n          wrapper,\n        ),\n      ).to.eventually.be.not.rejected;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null when there is no related modules","suites":["Injector","lookupComponentInImports"],"updatePoint":{"line":391,"column":59},"line":391,"code":"    it('should return null when there is no related modules', async () => {\n      const result = await injector.lookupComponentInImports(\n        module as any,\n        'testToken',\n        new InstanceWrapper(),\n      );\n      expect(result).to.be.eq(null);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null when related modules do not have appropriate component","suites":["Injector","lookupComponentInImports"],"updatePoint":{"line":400,"column":81},"line":400,"code":"    it('should return null when related modules do not have appropriate component', () => {\n      let moduleFixture = {\n        relatedModules: new Map([\n          [\n            'key',\n            {\n              providers: {\n                has: () => false,\n              },\n              exports: {\n                has: () => true,\n              },\n            },\n          ],\n        ] as any),\n      };\n      expect(\n        injector.lookupComponentInImports(\n          moduleFixture as any,\n          metatype as any,\n          null,\n        ),\n      ).to.be.eventually.eq(null);\n\n      moduleFixture = {\n        relatedModules: new Map([\n          [\n            'key',\n            {\n              providers: {\n                has: () => true,\n              },\n              exports: {\n                has: () => false,\n              },\n            },\n          ],\n        ] as any),\n      };\n      expect(\n        injector.lookupComponentInImports(\n          moduleFixture as any,\n          metatype as any,\n          null,\n        ),\n      ).to.eventually.be.eq(null);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadProvider\" when component is not resolved","suites":["Injector","lookupComponentInImports"],"updatePoint":{"line":448,"column":65},"line":448,"code":"    it('should call \"loadProvider\" when component is not resolved', async () => {\n      const moduleFixture = {\n        imports: new Map([\n          [\n            'key',\n            {\n              providers: {\n                has: () => true,\n                get: () =>\n                  new InstanceWrapper({\n                    isResolved: false,\n                  }),\n              },\n              exports: {\n                has: () => true,\n              },\n              imports: new Map(),\n            },\n          ],\n        ] as any),\n      };\n      await injector.lookupComponentInImports(\n        moduleFixture as any,\n        metatype as any,\n        new InstanceWrapper(),\n      );\n      expect(loadProvider.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"loadProvider\" when component is resolved","suites":["Injector","lookupComponentInImports"],"updatePoint":{"line":477,"column":65},"line":477,"code":"    it('should not call \"loadProvider\" when component is resolved', async () => {\n      const moduleFixture = {\n        relatedModules: new Map([\n          [\n            'key',\n            {\n              providers: {\n                has: () => true,\n                get: () => ({\n                  isResolved: true,\n                }),\n              },\n              exports: {\n                has: () => true,\n              },\n              relatedModules: new Map(),\n            },\n          ],\n        ] as any),\n      };\n      await injector.lookupComponentInImports(\n        moduleFixture as any,\n        metatype as any,\n        null,\n      );\n      expect(loadProvider.called).to.be.false;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"return forwardRef() result","suites":["Injector","resolveParamToken","when \"forwardRef\" property is not nil"],"updatePoint":{"line":519,"column":36},"line":519,"code":"      it('return forwardRef() result', () => {\n        expect(injector.resolveParamToken(wrapper, param)).to.be.eql(\n          forwardRef,\n        );\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"set wrapper \"forwardRef\" property to true","suites":["Injector","resolveParamToken","when \"forwardRef\" property is not nil"],"updatePoint":{"line":524,"column":51},"line":524,"code":"      it('set wrapper \"forwardRef\" property to true', () => {\n        injector.resolveParamToken(wrapper, param);\n        expect(wrapper.forwardRef).to.be.true;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"set wrapper \"forwardRef\" property to false","suites":["Injector","resolveParamToken","when \"forwardRef\" property is nil"],"updatePoint":{"line":535,"column":52},"line":535,"code":"      it('set wrapper \"forwardRef\" property to false', () => {\n        injector.resolveParamToken(wrapper, param);\n        expect(wrapper.forwardRef).to.be.undefined;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"return param","suites":["Injector","resolveParamToken","when \"forwardRef\" property is nil"],"updatePoint":{"line":539,"column":22},"line":539,"code":"      it('return param', () => {\n        expect(injector.resolveParamToken(wrapper, param)).to.be.eql(param);\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call loadProvider","suites":["Injector","resolveComponentInstance","when instanceWrapper is not resolved and does not have forward ref"],"updatePoint":{"line":554,"column":34},"line":554,"code":"      it('should call loadProvider', async () => {\n        const wrapper = new InstanceWrapper({ isResolved: false });\n\n        const loadStub = sinon\n          .stub(injector, 'loadProvider')\n          .callsFake(() => null);\n        sinon\n          .stub(injector, 'lookupComponent')\n          .returns(Promise.resolve(wrapper));\n\n        await injector.resolveComponentInstance(\n          module,\n          '',\n          { index: 0, dependencies: [] },\n          wrapper,\n        );\n        expect(loadStub.called).to.be.true;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call loadProvider (isResolved)","suites":["Injector","resolveComponentInstance","when instanceWrapper is not resolved and does not have forward ref"],"updatePoint":{"line":572,"column":51},"line":572,"code":"      it('should not call loadProvider (isResolved)', async () => {\n        const wrapper = new InstanceWrapper({ isResolved: true });\n        const loadStub = sinon\n          .stub(injector, 'loadProvider')\n          .callsFake(() => null);\n\n        sinon\n          .stub(injector, 'lookupComponent')\n          .returns(Promise.resolve(wrapper));\n\n        await injector.resolveComponentInstance(\n          module,\n          '',\n          { index: 0, dependencies: [] },\n          wrapper,\n        );\n        expect(loadStub.called).to.be.false;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call loadProvider (forwardRef)","suites":["Injector","resolveComponentInstance","when instanceWrapper is not resolved and does not have forward ref"],"updatePoint":{"line":590,"column":51},"line":590,"code":"      it('should not call loadProvider (forwardRef)', async () => {\n        const wrapper = new InstanceWrapper({\n          isResolved: false,\n          forwardRef: true,\n        });\n        const loadStub = sinon\n          .stub(injector, 'loadProvider')\n          .callsFake(() => null);\n\n        sinon\n          .stub(injector, 'lookupComponent')\n          .returns(Promise.resolve(wrapper));\n\n        await injector.resolveComponentInstance(\n          module,\n          '',\n          { index: 0, dependencies: [] },\n          wrapper,\n        );\n        expect(loadStub.called).to.be.false;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should await instance","suites":["Injector","resolveComponentInstance","when instanceWrapper has async property"],"updatePoint":{"line":614,"column":31},"line":614,"code":"      it('should await instance', async () => {\n        sinon.stub(injector, 'loadProvider').callsFake(() => null);\n\n        const instance = Promise.resolve(true);\n        const wrapper = new InstanceWrapper({\n          isResolved: false,\n          forwardRef: true,\n          async: true,\n          instance,\n        });\n        sinon\n          .stub(injector, 'lookupComponent')\n          .returns(Promise.resolve(wrapper));\n\n        const result = await injector.resolveComponentInstance(\n          module,\n          '',\n          { index: 0, dependencies: [] },\n          wrapper,\n        );\n        expect(result.instance).to.be.true;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["Injector","applyProperties","when instance is not an object"],"updatePoint":{"line":641,"column":33},"line":641,"code":"      it('should return undefined', () => {\n        expect(injector.applyProperties('test', [])).to.be.undefined;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply each not nil property","suites":["Injector","applyProperties","when instance is an object"],"updatePoint":{"line":647,"column":44},"line":647,"code":"      it('should apply each not nil property', () => {\n        const properties = [\n          { key: 'one', instance: {} },\n          { key: 'two', instance: null },\n          { key: 'three', instance: true },\n        ];\n        const obj: Record<any, any> = {};\n        injector.applyProperties(obj, properties as PropertyDependency[]);\n\n        expect(obj.one).to.be.eql(properties[0].instance);\n        expect(obj.two).to.be.undefined;\n        expect(obj.three).to.be.eql(properties[2].instance);\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should instantiate class","suites":["Injector","instantiateClass","when context is static"],"updatePoint":{"line":667,"column":34},"line":667,"code":"      it('should instantiate class', async () => {\n        const wrapper = new InstanceWrapper({ metatype: TestClass });\n        await injector.instantiateClass([], wrapper, wrapper, STATIC_CONTEXT);\n\n        expect(wrapper.instance).to.not.be.undefined;\n        expect(wrapper.instance).to.be.instanceOf(TestClass);\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call factory","suites":["Injector","instantiateClass","when context is static"],"updatePoint":{"line":674,"column":29},"line":674,"code":"      it('should call factory', async () => {\n        const wrapper = new InstanceWrapper({\n          inject: [],\n          metatype: (() => ({})) as any,\n        });\n        await injector.instantiateClass([], wrapper, wrapper, STATIC_CONTEXT);\n\n        expect(wrapper.instance).to.not.be.undefined;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not instantiate class","suites":["Injector","instantiateClass","when context is not static"],"updatePoint":{"line":685,"column":38},"line":685,"code":"      it('should not instantiate class', async () => {\n        const ctx = { id: 3 };\n        const wrapper = new InstanceWrapper({ metatype: TestClass });\n        await injector.instantiateClass([], wrapper, wrapper, ctx);\n\n        expect(wrapper.instance).to.be.undefined;\n        expect(wrapper.getInstanceByContextId(ctx).isResolved).to.be.true;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call factory","suites":["Injector","instantiateClass","when context is not static"],"updatePoint":{"line":694,"column":33},"line":694,"code":"      it('should not call factory', async () => {\n        const wrapper = new InstanceWrapper({\n          inject: [],\n          metatype: sinon.spy() as any,\n        });\n        await injector.instantiateClass([], wrapper, wrapper, { id: 2 });\n        expect(wrapper.instance).to.be.undefined;\n        expect((wrapper.metatype as any).called).to.be.false;\n      });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should load instance per context id","suites":["Injector","loadPerContext"],"updatePoint":{"line":709,"column":43},"line":709,"code":"    it('should load instance per context id', async () => {\n      const container = new NestContainer();\n      const moduleCtor = class TestModule {};\n      const ctx = STATIC_CONTEXT;\n      const { moduleRef } = await container.addModule(moduleCtor, []);\n\n      moduleRef.addProvider({\n        provide: TestClass,\n        useClass: TestClass,\n      });\n\n      const instance = await injector.loadPerContext(\n        new TestClass(),\n        moduleRef,\n        moduleRef.providers,\n        ctx,\n      );\n      expect(instance).to.be.instanceOf(TestClass);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should load enhancers per context id","suites":["Injector","loadEnhancersPerContext"],"updatePoint":{"line":731,"column":44},"line":731,"code":"    it('should load enhancers per context id', async () => {\n      const wrapper = new InstanceWrapper();\n      wrapper.addEnhancerMetadata(\n        new InstanceWrapper({\n          host: new Module(class {}, new NestContainer()),\n        }),\n      );\n      wrapper.addEnhancerMetadata(\n        new InstanceWrapper({\n          host: new Module(class {}, new NestContainer()),\n        }),\n      );\n\n      const loadInstanceStub = sinon\n        .stub(injector, 'loadInstance')\n        .callsFake(async () => ({} as any));\n\n      await injector.loadEnhancersPerContext(wrapper, STATIC_CONTEXT);\n      expect(loadInstanceStub.calledTwice).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve ctor metadata","suites":["Injector","loadCtorMetadata"],"updatePoint":{"line":754,"column":36},"line":754,"code":"    it('should resolve ctor metadata', async () => {\n      const wrapper = new InstanceWrapper();\n      wrapper.addCtorMetadata(0, new InstanceWrapper());\n      wrapper.addCtorMetadata(1, new InstanceWrapper());\n\n      const resolveComponentHostStub = sinon\n        .stub(injector, 'resolveComponentHost')\n        .callsFake(async () => new InstanceWrapper());\n\n      await injector.loadCtorMetadata(\n        wrapper.getCtorMetadata(),\n        STATIC_CONTEXT,\n      );\n      expect(resolveComponentHostStub.calledTwice).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve properties metadata","suites":["Injector","loadPropertiesMetadata"],"updatePoint":{"line":772,"column":42},"line":772,"code":"    it('should resolve properties metadata', async () => {\n      const wrapper = new InstanceWrapper();\n      wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n      wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n\n      const resolveComponentHostStub = sinon\n        .stub(injector, 'resolveComponentHost')\n        .callsFake(async () => new InstanceWrapper());\n\n      await injector.loadPropertiesMetadata(\n        wrapper.getPropertiesMetadata(),\n        STATIC_CONTEXT,\n      );\n      expect(resolveComponentHostStub.calledTwice).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadCtorMetadata\" if metadata is not undefined","suites":["Injector","resolveConstructorParams"],"updatePoint":{"line":790,"column":67},"line":790,"code":"    it('should call \"loadCtorMetadata\" if metadata is not undefined', async () => {\n      const wrapper = new InstanceWrapper();\n      const metadata = [];\n      sinon.stub(wrapper, 'getCtorMetadata').callsFake(() => metadata);\n\n      const loadCtorMetadataSpy = sinon.spy(injector, 'loadCtorMetadata');\n      await injector.resolveConstructorParams(\n        wrapper,\n        null,\n        [],\n        () => {\n          expect(loadCtorMetadataSpy.called).to.be.true;\n        },\n        { id: 2 },\n      );\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadPropertiesMetadata\" if metadata is not undefined","suites":["Injector","resolveProperties"],"updatePoint":{"line":809,"column":73},"line":809,"code":"    it('should call \"loadPropertiesMetadata\" if metadata is not undefined', async () => {\n      const wrapper = new InstanceWrapper();\n      const metadata = [];\n      sinon.stub(wrapper, 'getPropertiesMetadata').callsFake(() => metadata);\n\n      const loadPropertiesMetadataSpy = sinon.spy(\n        injector,\n        'loadPropertiesMetadata',\n      );\n      await injector.resolveProperties(wrapper, null, null, { id: 2 });\n      expect(loadPropertiesMetadataSpy.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an array that consists of deps and optional dep ids","suites":["Injector","getClassDependencies"],"updatePoint":{"line":824,"column":73},"line":824,"code":"    it('should return an array that consists of deps and optional dep ids', async () => {\n      class FixtureDep1 {}\n      class FixtureDep2 {}\n\n      @Injectable()\n      class FixtureClass {\n        constructor(\n          private dep1: FixtureDep1,\n          @Optional() private dep2: FixtureDep2,\n        ) {}\n      }\n\n      const wrapper = new InstanceWrapper({ metatype: FixtureClass });\n      const [dependencies, optionalDependenciesIds] =\n        injector.getClassDependencies(wrapper);\n\n      expect(dependencies).to.deep.eq([FixtureDep1, FixtureDep2]);\n      expect(optionalDependenciesIds).to.deep.eq([1]);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not mutate the constructor metadata","suites":["Injector","getClassDependencies"],"updatePoint":{"line":844,"column":50},"line":844,"code":"    it('should not mutate the constructor metadata', async () => {\n      class FixtureDep1 {}\n      /** This needs to be something other than FixtureDep1 so the test can ensure that the metadata was not mutated */\n      const injectionToken = 'test_token';\n\n      @Injectable()\n      class FixtureClass {\n        constructor(@Inject(injectionToken) private dep1: FixtureDep1) {}\n      }\n\n      const wrapper = new InstanceWrapper({ metatype: FixtureClass });\n      const [dependencies] = injector.getClassDependencies(wrapper);\n      expect(dependencies).to.deep.eq([injectionToken]);\n\n      const paramtypes = Reflect.getMetadata(PARAMTYPES_METADATA, FixtureClass);\n      expect(paramtypes).to.deep.eq([FixtureDep1]);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an array that consists of deps and optional dep ids","suites":["Injector","getFactoryProviderDependencies"],"updatePoint":{"line":864,"column":73},"line":864,"code":"    it('should return an array that consists of deps and optional dep ids', async () => {\n      class FixtureDep1 {}\n      class FixtureDep2 {}\n\n      const wrapper = new InstanceWrapper({\n        inject: [\n          FixtureDep1,\n          { token: FixtureDep2, optional: true },\n          { token: FixtureDep2, optional: false },\n          {} as any,\n        ],\n      });\n      const [dependencies, optionalDependenciesIds] =\n        injector.getFactoryProviderDependencies(wrapper);\n\n      expect(dependencies).to.deep.eq([\n        FixtureDep1,\n        FixtureDep2,\n        FixtureDep2,\n        {},\n      ]);\n      expect(optionalDependenciesIds).to.deep.eq([1]);\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add dependency metadata to PropertiesMetadata when key is symbol","suites":["Injector","addDependencyMetadata"],"updatePoint":{"line":908,"column":79},"line":908,"code":"    it('should add dependency metadata to PropertiesMetadata when key is symbol', async () => {\n      const addPropertiesMetadataSpy = sinon.spy(\n        hostWrapper,\n        'addPropertiesMetadata',\n      );\n\n      const key = Symbol.for('symbol');\n      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);\n\n      expect(addPropertiesMetadataSpy.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add dependency metadata to PropertiesMetadata when key is string","suites":["Injector","addDependencyMetadata"],"updatePoint":{"line":920,"column":79},"line":920,"code":"    it('should add dependency metadata to PropertiesMetadata when key is string', async () => {\n      const addPropertiesMetadataSpy = sinon.spy(\n        hostWrapper,\n        'addPropertiesMetadata',\n      );\n\n      const key = 'string';\n      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);\n\n      expect(addPropertiesMetadataSpy.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add dependency metadata to CtorMetadata when key is number","suites":["Injector","addDependencyMetadata"],"updatePoint":{"line":932,"column":73},"line":932,"code":"    it('should add dependency metadata to CtorMetadata when key is number', async () => {\n      const addCtorMetadataSpy = sinon.spy(hostWrapper, 'addCtorMetadata');\n\n      const key = 0;\n      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);\n\n      expect(addCtorMetadataSpy.called).to.be.true;\n    });","file":"injector/injector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadPrototype\" for every provider and controller in every module","suites":["InstanceLoader"],"updatePoint":{"line":53,"column":83},"line":53,"code":"  it('should call \"loadPrototype\" for every provider and controller in every module', async () => {\n    const providerWrapper = new InstanceWrapper({\n      instance: null,\n      metatype: TestProvider,\n      token: 'TestProvider',\n    });\n    const ctrlWrapper = new InstanceWrapper({\n      instance: null,\n      metatype: TestCtrl,\n      token: 'TestRoute',\n    });\n\n    moduleMock.providers.set('TestProvider', providerWrapper);\n    moduleMock.controllers.set('TestRoute', ctrlWrapper);\n\n    const loadProviderPrototypeStub = sinon.stub(injector, 'loadPrototype');\n\n    sinon.stub(injector, 'loadController');\n    sinon.stub(injector, 'loadProvider');\n\n    await loader.createInstancesOfDependencies();\n\n    expect(\n      loadProviderPrototypeStub.calledWith(\n        providerWrapper,\n        moduleMock.providers,\n      ),\n    ).to.be.true;\n    expect(\n      loadProviderPrototypeStub.calledWith(ctrlWrapper, moduleMock.controllers),\n    ).to.be.true;\n  });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadProvider\"","suites":["InstanceLoader","for every provider in every module"],"updatePoint":{"line":106,"column":34},"line":106,"code":"    it('should call \"loadProvider\"', async () => {\n      expect(\n        loadProviderStub.calledWith(\n          moduleMock.providers.get(testProviderToken),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"inspectInstanceWrapper\"","suites":["InstanceLoader","for every provider in every module"],"updatePoint":{"line":115,"column":44},"line":115,"code":"    it('should call \"inspectInstanceWrapper\"', async () => {\n      expect(\n        inspectInstanceWrapperStub.calledWith(\n          moduleMock.providers.get(testProviderToken),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadController\"","suites":["InstanceLoader","for every controller in every module"],"updatePoint":{"line":142,"column":36},"line":142,"code":"    it('should call \"loadController\"', async () => {\n      expect(\n        loadControllerStub.calledWith(\n          moduleMock.controllers.get('TestRoute'),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"inspectInstanceWrapper\"","suites":["InstanceLoader","for every controller in every module"],"updatePoint":{"line":150,"column":44},"line":150,"code":"    it('should call \"inspectInstanceWrapper\"', async () => {\n      expect(\n        inspectInstanceWrapperStub.calledWith(\n          moduleMock.controllers.get('TestRoute'),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"loadInjectable\"","suites":["InstanceLoader","for every injectable in every module"],"updatePoint":{"line":178,"column":36},"line":178,"code":"    it('should call \"loadInjectable\"', async () => {\n      expect(\n        loadInjectableStub.calledWith(\n          moduleMock.injectables.get('TestProvider'),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"inspectInstanceWrapper\"","suites":["InstanceLoader","for every injectable in every module"],"updatePoint":{"line":186,"column":44},"line":186,"code":"    it('should call \"inspectInstanceWrapper\"', async () => {\n      expect(\n        inspectInstanceWrapperStub.calledWith(\n          moduleMock.injectables.get('TestProvider'),\n          moduleMock as any,\n        ),\n      ).to.be.true;\n    });","file":"injector/instance-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should assign partial","suites":["InstanceWrapper","initialize"],"updatePoint":{"line":17,"column":29},"line":17,"code":"    it('should assign partial', () => {\n      const instance = new InstanceWrapper(partial);\n\n      expect(instance.name).to.be.eql(partial.name);\n      expect(instance.scope).to.be.eql(partial.scope);\n      expect(instance.metatype).to.be.eql(partial.metatype);\n    });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set instance by context id","suites":["InstanceWrapper","initialize"],"updatePoint":{"line":24,"column":41},"line":24,"code":"    it('should set instance by context id', () => {\n      const instance = new InstanceWrapper(partial);\n\n      expect(\n        instance.getInstanceByContextId(STATIC_CONTEXT).instance,\n      ).to.be.eql(partial.instance);\n    });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeStatic","when circular reference"],"updatePoint":{"line":35,"column":28},"line":35,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper();\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeStatic()).to.be.true;\n        expect(otherWrapper.isDependencyTreeStatic()).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when circular reference and one non static"],"updatePoint":{"line":45,"column":29},"line":45,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper({ scope: Scope.REQUEST });\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeStatic()).to.be.false;\n        expect(otherWrapper.isDependencyTreeStatic()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when circular reference and one durable"],"updatePoint":{"line":55,"column":29},"line":55,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: true,\n        });\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeStatic()).to.be.false;\n        expect(otherWrapper.isDependencyTreeStatic()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when request scoped"],"updatePoint":{"line":68,"column":29},"line":68,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(wrapper.isDependencyTreeStatic()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when request scoped durable"],"updatePoint":{"line":76,"column":29},"line":76,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: true,\n        });\n        expect(wrapper.isDependencyTreeStatic()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when request scoped explicit non durable"],"updatePoint":{"line":85,"column":29},"line":85,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: false,\n        });\n        expect(wrapper.isDependencyTreeStatic()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeStatic","when default"],"updatePoint":{"line":94,"column":28},"line":94,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper({});\n        expect(wrapper.isDependencyTreeStatic()).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","dependencies, properties, enhancers","dependencies non static, properties static, enhancers static"],"updatePoint":{"line":102,"column":33},"line":102,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","dependencies, properties, enhancers","dependencies static, properties non static, enhancers static"],"updatePoint":{"line":114,"column":33},"line":114,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","dependencies, properties, enhancers","dependencies static, properties static, enhancers non static"],"updatePoint":{"line":126,"column":33},"line":126,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","dependencies","when each is static"],"updatePoint":{"line":139,"column":32},"line":139,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","dependencies","when one is not static"],"updatePoint":{"line":146,"column":33},"line":146,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addCtorMetadata(\n              1,\n              new InstanceWrapper({\n                scope: Scope.REQUEST,\n              }),\n            );\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","properties","when each is static"],"updatePoint":{"line":161,"column":32},"line":161,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","properties","when one is not static"],"updatePoint":{"line":169,"column":33},"line":169,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","enhancers","when each is static"],"updatePoint":{"line":182,"column":32},"line":182,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeStatic","when statically scoped","enhancers","when one is not static"],"updatePoint":{"line":190,"column":33},"line":190,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeStatic()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when circular reference and default scope"],"updatePoint":{"line":205,"column":29},"line":205,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper();\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeDurable()).to.be.false;\n        expect(otherWrapper.isDependencyTreeDurable()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when circular reference and one non durable"],"updatePoint":{"line":215,"column":29},"line":215,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper({ scope: Scope.REQUEST });\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeDurable()).to.be.false;\n        expect(otherWrapper.isDependencyTreeDurable()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when circular reference and one durable"],"updatePoint":{"line":225,"column":28},"line":225,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper();\n        const otherWrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: true,\n        });\n        wrapper.addCtorMetadata(0, otherWrapper);\n        otherWrapper.addCtorMetadata(0, wrapper);\n        expect(wrapper.isDependencyTreeDurable()).to.be.true;\n        expect(otherWrapper.isDependencyTreeDurable()).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when request scoped and durable"],"updatePoint":{"line":238,"column":28},"line":238,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: true,\n        });\n        expect(wrapper.isDependencyTreeDurable()).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when request scoped and non durable"],"updatePoint":{"line":247,"column":29},"line":247,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(wrapper.isDependencyTreeDurable()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when request scoped and explicit non durable"],"updatePoint":{"line":255,"column":29},"line":255,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n          durable: false,\n        });\n        expect(wrapper.isDependencyTreeDurable()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when default scope"],"updatePoint":{"line":264,"column":29},"line":264,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper();\n        expect(wrapper.isDependencyTreeDurable()).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies, properties, enhancers","dependencies non durable, properties non durable, enhancers durable"],"updatePoint":{"line":272,"column":33},"line":272,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addCtorMetadata(1, new InstanceWrapper());\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies, properties, enhancers","dependencies non durable, properties durable, enhancers durable"],"updatePoint":{"line":285,"column":33},"line":285,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addCtorMetadata(1, new InstanceWrapper());\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies, properties, enhancers","dependencies non durable, properties durable"],"updatePoint":{"line":301,"column":33},"line":301,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addCtorMetadata(1, new InstanceWrapper());\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addPropertiesMetadata(\n              'key2',\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies, properties, enhancers","properties durable, enhancers non durable"],"updatePoint":{"line":317,"column":33},"line":317,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addPropertiesMetadata(\n              'key2',\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies, properties, enhancers","dependencies durable, enhancers non durable"],"updatePoint":{"line":331,"column":33},"line":331,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when wrapper is non durable and dependency is static"],"updatePoint":{"line":346,"column":33},"line":346,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when wrapper is durable and dependency is static"],"updatePoint":{"line":353,"column":32},"line":353,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when wrapper is non durable and dependency is durable"],"updatePoint":{"line":363,"column":33},"line":363,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n            });\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when wrapper is durable and dependency is static"],"updatePoint":{"line":375,"column":32},"line":375,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when wrapper is durable and dependency is non durable"],"updatePoint":{"line":385,"column":32},"line":385,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addCtorMetadata(\n              0,\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when each is static"],"updatePoint":{"line":398,"column":33},"line":398,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when one is not static and non-durable"],"updatePoint":{"line":405,"column":33},"line":405,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addCtorMetadata(\n              1,\n              new InstanceWrapper({\n                scope: Scope.REQUEST,\n              }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when one is not static and durable"],"updatePoint":{"line":418,"column":32},"line":418,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addCtorMetadata(\n              1,\n              new InstanceWrapper({\n                scope: Scope.REQUEST,\n                durable: true,\n              }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","dependencies","when one is not static, durable and non durable"],"updatePoint":{"line":432,"column":33},"line":432,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addCtorMetadata(0, new InstanceWrapper());\n            wrapper.addCtorMetadata(\n              1,\n              new InstanceWrapper({\n                scope: Scope.REQUEST,\n                durable: true,\n              }),\n            );\n            wrapper.addCtorMetadata(\n              2,\n              new InstanceWrapper({\n                scope: Scope.REQUEST,\n              }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when wrapper is non durable and dependency is static"],"updatePoint":{"line":454,"column":33},"line":454,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when wrapper is durable and dependency is static"],"updatePoint":{"line":461,"column":32},"line":461,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when wrapper is non durable and dependency is durable"],"updatePoint":{"line":471,"column":33},"line":471,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n            });\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when wrapper is durable and dependency is static"],"updatePoint":{"line":483,"column":32},"line":483,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when wrapper is durable and dependency is non durable"],"updatePoint":{"line":493,"column":32},"line":493,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when each is static"],"updatePoint":{"line":506,"column":33},"line":506,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when one is not static and non-durable"],"updatePoint":{"line":514,"column":33},"line":514,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when one is not static and durable"],"updatePoint":{"line":525,"column":32},"line":525,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","properties","when one is not static, non durable and durable"],"updatePoint":{"line":536,"column":33},"line":536,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addPropertiesMetadata(\n              'key1',\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());\n            wrapper.addPropertiesMetadata(\n              'key3',\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when wrapper is non durable and dependency is static"],"updatePoint":{"line":553,"column":33},"line":553,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when wrapper is durable and dependency is static"],"updatePoint":{"line":560,"column":32},"line":560,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when wrapper is non durable and dependency is durable"],"updatePoint":{"line":570,"column":33},"line":570,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n            });\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when wrapper is durable and dependency is static"],"updatePoint":{"line":581,"column":32},"line":581,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when wrapper is durable and dependency is non durable"],"updatePoint":{"line":591,"column":32},"line":591,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper({\n              scope: Scope.REQUEST,\n              durable: true,\n            });\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when each is static"],"updatePoint":{"line":603,"column":33},"line":603,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when one is not static and non-durable"],"updatePoint":{"line":611,"column":33},"line":611,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when one is not static and durable"],"updatePoint":{"line":621,"column":32},"line":621,"code":"          it('should return true', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            expect(wrapper.isDependencyTreeDurable()).to.be.true;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isDependencyTreeDurable","when statically scoped","enhancers","when one is not static, non durable and durable"],"updatePoint":{"line":631,"column":33},"line":631,"code":"          it('should return false', () => {\n            const wrapper = new InstanceWrapper();\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),\n            );\n            wrapper.addEnhancerMetadata(new InstanceWrapper());\n            wrapper.addEnhancerMetadata(\n              new InstanceWrapper({ scope: Scope.REQUEST }),\n            );\n            expect(wrapper.isDependencyTreeDurable()).to.be.false;\n          });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isNotMetatype","when metatype is nil"],"updatePoint":{"line":649,"column":28},"line":649,"code":"      it('should return true', () => {\n        const instance = new InstanceWrapper({ metatype: null });\n        expect(instance.isNotMetatype).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isNotMetatype","when metatype is not nil"],"updatePoint":{"line":655,"column":29},"line":655,"code":"      it('should return false', () => {\n        const instance = new InstanceWrapper({ metatype: TestClass });\n        expect(instance.isNotMetatype).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add enhancers metadata","suites":["InstanceWrapper","addEnhancerMetadata"],"updatePoint":{"line":663,"column":37},"line":663,"code":"    it('should add enhancers metadata', () => {\n      const instance = new InstanceWrapper();\n      const enhancers = [new InstanceWrapper()];\n      instance.addEnhancerMetadata(enhancers[0]);\n      expect(instance.getEnhancersMetadata()).to.be.eql(enhancers);\n    });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set static context value","suites":["InstanceWrapper","when set instance has been called"],"updatePoint":{"line":672,"column":39},"line":672,"code":"    it('should set static context value', () => {\n      const instance = { test: true };\n      const wrapper = new InstanceWrapper();\n      wrapper.instance = instance;\n\n      expect(wrapper.getInstanceByContextId(STATIC_CONTEXT).instance).to.be.eql(\n        instance,\n      );\n    });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return static instance","suites":["InstanceWrapper","cloneStaticInstance","when wrapper is static"],"updatePoint":{"line":685,"column":39},"line":685,"code":"      it('should return static instance', () => {\n        const instance = { test: true };\n        const wrapper = new InstanceWrapper({ instance });\n\n        expect(wrapper.cloneStaticInstance({ id: 0 }).instance).to.be.eql(\n          instance,\n        );\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should clone instance by context id","suites":["InstanceWrapper","cloneStaticInstance","when wrapper is not static"],"updatePoint":{"line":695,"column":45},"line":695,"code":"      it('should clone instance by context id', () => {\n        const instance = { test: true };\n        const wrapper = new InstanceWrapper({ instance, scope: Scope.REQUEST });\n\n        expect(wrapper.cloneStaticInstance({ id: 0 }).instance).to.be.undefined;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"getInstanceByInquirerId\"","suites":["InstanceWrapper","getInstanceByContextId","when transient and inquirer has been passed"],"updatePoint":{"line":706,"column":47},"line":706,"code":"      it('should call \"getInstanceByInquirerId\"', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        const getInstanceByInquirerIdSpy = sinon.spy(\n          wrapper,\n          'getInstanceByInquirerId',\n        );\n        wrapper.getInstanceByContextId(STATIC_CONTEXT, 'inquirerId');\n        expect(getInstanceByInquirerIdSpy.called).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"setInstanceByInquirerId\"","suites":["InstanceWrapper","setInstanceByContextId","when transient and inquirer has been passed"],"updatePoint":{"line":722,"column":47},"line":722,"code":"      it('should call \"setInstanceByInquirerId\"', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        const setInstanceByInquirerIdSpy = sinon.spy(\n          wrapper,\n          'setInstanceByInquirerId',\n        );\n        wrapper.setInstanceByContextId(\n          STATIC_CONTEXT,\n          { instance: {} },\n          'inquirerId',\n        );\n        expect(setInstanceByInquirerIdSpy.called).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isInRequestScope","when tree and context are not static and is not transient"],"updatePoint":{"line":742,"column":28},"line":742,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(wrapper.isInRequestScope({ id: 3 })).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isInRequestScope","otherwise"],"updatePoint":{"line":750,"column":29},"line":750,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        expect(wrapper.isInRequestScope({ id: 3 })).to.be.false;\n\n        const wrapper2 = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(wrapper2.isInRequestScope(STATIC_CONTEXT)).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isLazyTransient","when inquirer is request scoped and context is not static and is transient"],"updatePoint":{"line":766,"column":28},"line":766,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        expect(\n          wrapper.isLazyTransient(\n            { id: 3 },\n            new InstanceWrapper({\n              scope: Scope.REQUEST,\n            }),\n          ),\n        ).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isLazyTransient","otherwise"],"updatePoint":{"line":781,"column":29},"line":781,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        expect(wrapper.isLazyTransient({ id: 3 }, new InstanceWrapper())).to.be\n          .false;\n\n        const wrapper2 = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(\n          wrapper2.isLazyTransient(\n            STATIC_CONTEXT,\n            new InstanceWrapper({\n              scope: Scope.TRANSIENT,\n            }),\n          ),\n        ).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["InstanceWrapper","isStatic","when inquirer is not request scoped and context and tree are static"],"updatePoint":{"line":805,"column":28},"line":805,"code":"      it('should return true', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.DEFAULT,\n        });\n        expect(\n          wrapper.isStatic(\n            STATIC_CONTEXT,\n            new InstanceWrapper({\n              scope: Scope.DEFAULT,\n            }),\n          ),\n        ).to.be.true;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["InstanceWrapper","isStatic","otherwise"],"updatePoint":{"line":820,"column":29},"line":820,"code":"      it('should return false', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.REQUEST,\n        });\n        expect(wrapper.isStatic({ id: 3 }, new InstanceWrapper())).to.be.false;\n\n        const wrapper2 = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        expect(\n          wrapper2.isStatic(\n            STATIC_CONTEXT,\n            new InstanceWrapper({\n              scope: Scope.REQUEST,\n            }),\n          ),\n        ).to.be.false;\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an empty array","suites":["InstanceWrapper","getStaticTransientInstances","when instance is not transient"],"updatePoint":{"line":843,"column":38},"line":843,"code":"      it('should return an empty array', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.DEFAULT,\n        });\n        expect(wrapper.getStaticTransientInstances()).to.be.eql([]);\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return all static instances","suites":["InstanceWrapper","getStaticTransientInstances","when instance is transient"],"updatePoint":{"line":851,"column":44},"line":851,"code":"      it('should return all static instances', () => {\n        const wrapper = new InstanceWrapper({\n          scope: Scope.TRANSIENT,\n        });\n        const instanceHost = {\n          instance: {},\n        };\n        wrapper.setInstanceByInquirerId(STATIC_CONTEXT, 'test', instanceHost);\n        expect(wrapper.getStaticTransientInstances()).to.be.eql([instanceHost]);\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should provide the given value in the STATIC_CONTEXT","suites":["InstanceWrapper","mergeWith","when provider is a ValueProvider"],"updatePoint":{"line":866,"column":62},"line":866,"code":"      it('should provide the given value in the STATIC_CONTEXT', () => {\n        const wrapper = new InstanceWrapper();\n        wrapper.mergeWith({\n          useValue: 'value',\n          provide: 'token',\n        });\n\n        expect(\n          wrapper.getInstanceByContextId(STATIC_CONTEXT).instance,\n        ).to.be.equal('value');\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should alter the instance wrapper metatype with the given class","suites":["InstanceWrapper","mergeWith","when provider is a ClassProvider"],"updatePoint":{"line":880,"column":73},"line":880,"code":"      it('should alter the instance wrapper metatype with the given class', () => {\n        const wrapper = new InstanceWrapper();\n\n        wrapper.mergeWith({\n          useClass: TestClass,\n          provide: 'token',\n        });\n\n        expect(wrapper.metatype).to.be.eql(TestClass);\n      });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should alter the instance wrapper metatype and inject attributes with the given values","suites":["InstanceWrapper","mergeWith","when provider is a FactoryProvider","and it has injected dependencies"],"updatePoint":{"line":894,"column":98},"line":894,"code":"        it('should alter the instance wrapper metatype and inject attributes with the given values', () => {\n          const wrapper = new InstanceWrapper();\n\n          const factory = (_dependency1: any, _dependency2: any) => {};\n          const injectedDependencies = ['dependency1', 'dependency2'];\n\n          wrapper.mergeWith({\n            provide: 'token',\n            useFactory: factory,\n            inject: injectedDependencies,\n          });\n\n          expect(wrapper.metatype).to.be.eql(factory);\n          expect(wrapper.inject).to.be.eq(injectedDependencies);\n        });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should alter the instance wrapper metatype with the given values","suites":["InstanceWrapper","mergeWith","when provider is a FactoryProvider","and it has no injected dependencies"],"updatePoint":{"line":912,"column":76},"line":912,"code":"        it('should alter the instance wrapper metatype with the given values', () => {\n          const wrapper = new InstanceWrapper();\n          const factory = (_dependency1: any, _dependency2: any) => {};\n\n          wrapper.mergeWith({\n            provide: 'token',\n            useFactory: factory,\n          });\n\n          expect(wrapper.metatype).to.be.eql(factory);\n          expect(wrapper.inject).to.be.eql([]);\n        });","file":"injector/instance-wrapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the internal core module definition","suites":["InternalCoreModuleFactory"],"updatePoint":{"line":12,"column":55},"line":12,"code":"  it('should return the internal core module definition', () => {\n    const moduleDefinition = InternalCoreModuleFactory.create(\n      new NestContainer(),\n      null,\n      null,\n      null,\n      null,\n    );\n\n    expect(moduleDefinition.module).to.equal(InternalCoreModule);\n\n    const providedInjectables = moduleDefinition.providers.map(\n      item => (item as ClassProvider | FactoryProvider).provide,\n    );\n    expect(providedInjectables).to.deep.equal([\n      ExternalContextCreator,\n      ModulesContainer,\n      HttpAdapterHost,\n      LazyModuleLoader,\n      SerializedGraph,\n    ]);\n\n    const lazyModuleLoaderProvider = moduleDefinition.providers.find(\n      item => (item as FactoryProvider)?.provide === LazyModuleLoader,\n    ) as FactoryProvider;\n    expect(lazyModuleLoaderProvider.useFactory()).to.be.instanceOf(\n      LazyModuleLoader,\n    );\n  });","file":"injector/internal-core-module/internal-core-module-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should load it and return a module reference","suites":["LazyModuleLoader","load","when module was not loaded yet"],"updatePoint":{"line":61,"column":54},"line":61,"code":"      it('should load it and return a module reference', async () => {\n        const moduleRef = await lazyModuleLoader.load(() => ModuleA);\n        expect(moduleRef).to.be.instanceOf(ModuleRef);\n        expect(moduleRef.get(bProvider.provide, { strict: false })).to.equal(\n          bProvider.useValue,\n        );\n      });","file":"injector/lazy-module-loader/lazy-module-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an existing module reference","suites":["LazyModuleLoader","load","when module was loaded already"],"updatePoint":{"line":73,"column":52},"line":73,"code":"      it('should return an existing module reference', async () => {\n        const moduleRef = await lazyModuleLoader.load(() => ModuleC);\n        const moduleRef2 = await lazyModuleLoader.load(() => ModuleC);\n        expect(moduleRef).to.equal(moduleRef2);\n      });","file":"injector/lazy-module-loader/lazy-module-loader.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected token","suites":["ModuleTokenFactory","create"],"updatePoint":{"line":15,"column":36},"line":15,"code":"    it('should return expected token', () => {\n      const type = Module;\n      const token1 = factory.create(type, undefined);\n      const token2 = factory.create(type, undefined);\n      expect(token1).to.be.deep.eq(token2);\n    });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should include dynamic metadata","suites":["ModuleTokenFactory","create"],"updatePoint":{"line":21,"column":39},"line":21,"code":"    it('should include dynamic metadata', () => {\n      const type = Module;\n      const token1 = factory.create(type, {\n        providers: [{}],\n      } as any);\n      const token2 = factory.create(type, {\n        providers: [{}],\n      } as any);\n\n      expect(token1).to.be.deep.eq(token2);\n    });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map module metatype to name","suites":["ModuleTokenFactory","getModuleName"],"updatePoint":{"line":34,"column":42},"line":34,"code":"    it('should map module metatype to name', () => {\n      const metatype = () => {};\n      expect(factory.getModuleName(metatype as any)).to.be.eql(metatype.name);\n    });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return hash","suites":["ModuleTokenFactory","getStringifiedOpaqueToken","when metadata exists"],"updatePoint":{"line":41,"column":28},"line":41,"code":"      it('should return hash', () => {\n        const metadata = { providers: ['', {}] };\n        expect(factory.getStringifiedOpaqueToken(metadata as any)).to.be.eql(\n          JSON.stringify(metadata),\n        );\n      });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return hash with class","suites":["ModuleTokenFactory","getStringifiedOpaqueToken","when metadata exists"],"updatePoint":{"line":47,"column":39},"line":47,"code":"      it('should return hash with class', () => {\n        class Provider {}\n        const metadata = { providers: [Provider], exports: [Provider] };\n        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(\n          '{\"providers\":[\"Provider\"],\"exports\":[\"Provider\"]}',\n        );\n      });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return hash with value provider with non-class function","suites":["ModuleTokenFactory","getStringifiedOpaqueToken","when metadata exists"],"updatePoint":{"line":54,"column":72},"line":54,"code":"      it('should return hash with value provider with non-class function', () => {\n        const provider = {\n          provide: 'ProvideValue',\n          useValue: function Provider() {},\n        };\n        const metadata = { providers: [provider] };\n        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(\n          `{\"providers\":[{\"provide\":\"ProvideValue\",\"useValue\":\"${provider.useValue.toString()}\"}]}`,\n        );\n      });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should serialize symbols in a dynamic metadata object","suites":["ModuleTokenFactory","getStringifiedOpaqueToken","when metadata exists"],"updatePoint":{"line":64,"column":63},"line":64,"code":"      it('should serialize symbols in a dynamic metadata object', () => {\n        const metadata = {\n          providers: [\n            {\n              provide: Symbol('a'),\n              useValue: 'a',\n            },\n            {\n              provide: Symbol('b'),\n              useValue: 'b',\n            },\n          ],\n        };\n\n        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(\n          '{\"providers\":[{\"provide\":\"Symbol(a)\",\"useValue\":\"a\"},{\"provide\":\"Symbol(b)\",\"useValue\":\"b\"}]}',\n        );\n      });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty string","suites":["ModuleTokenFactory","getStringifiedOpaqueToken","when metadata does not exist"],"updatePoint":{"line":84,"column":36},"line":84,"code":"      it('should return empty string', () => {\n        expect(factory.getStringifiedOpaqueToken(undefined)).to.be.eql('');\n      });","file":"injector/module-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add controller","suites":["Module"],"updatePoint":{"line":28,"column":27},"line":28,"code":"  it('should add controller', () => {\n    const collection = new Map();\n    const setSpy = sinon.spy(collection, 'set');\n    (module as any)._controllers = collection;\n\n    @Controller({ scope: Scope.REQUEST, durable: true })\n    class Test {}\n\n    module.addController(Test);\n    expect(\n      setSpy.calledWith(\n        Test,\n        new InstanceWrapper({\n          host: module,\n          token: Test,\n          name: 'Test',\n          scope: Scope.REQUEST,\n          metatype: Test,\n          durable: true,\n          instance: null,\n          isResolved: false,\n        }),\n      ),\n    ).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add injectable","suites":["Module"],"updatePoint":{"line":54,"column":27},"line":54,"code":"  it('should add injectable', () => {\n    const collection = new Map();\n    const setSpy = sinon.spy(collection, 'set');\n    (module as any)._injectables = collection;\n\n    module.addInjectable(TestProvider, 'interceptor', TestModule);\n    expect(\n      setSpy.calledWith(\n        TestProvider,\n        new InstanceWrapper({\n          host: module,\n          name: 'TestProvider',\n          token: TestProvider,\n          scope: undefined,\n          metatype: TestProvider,\n          instance: null,\n          durable: undefined,\n          isResolved: false,\n          subtype: 'interceptor',\n        }),\n      ),\n    ).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `addCustomProvider`","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":79,"column":39},"line":79,"code":"    it('should call `addCustomProvider`', () => {\n      const addCustomProviderSpy = sinon.spy(module, 'addCustomProvider');\n\n      module.addInjectable({ provide: 'test' } as any, 'guard');\n      expect(addCustomProviderSpy.called).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add provider","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":87,"column":25},"line":87,"code":"  it('should add provider', () => {\n    const collection = new Map();\n    const setSpy = sinon.spy(collection, 'set');\n    (module as any)._providers = collection;\n\n    module.addProvider(TestProvider);\n    expect(\n      setSpy.calledWith(\n        TestProvider,\n        new InstanceWrapper({\n          host: module,\n          name: 'TestProvider',\n          token: TestProvider,\n          scope: undefined,\n          metatype: TestProvider,\n          durable: undefined,\n          instance: null,\n          isResolved: false,\n        }),\n      ),\n    ).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomProvider\" when \"provide\" property exists","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":110,"column":68},"line":110,"code":"  it('should call \"addCustomProvider\" when \"provide\" property exists', () => {\n    const addCustomProvider = sinon.spy();\n    module.addCustomProvider = addCustomProvider;\n\n    const provider = { provide: 'test', useValue: 'test' };\n\n    module.addProvider(provider as any);\n    expect((addCustomProvider as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomClass\" when \"useClass\" property exists","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":120,"column":66},"line":120,"code":"  it('should call \"addCustomClass\" when \"useClass\" property exists', () => {\n    const addCustomClass = sinon.spy();\n    module.addCustomClass = addCustomClass;\n\n    const provider = { provide: 'test', useClass: () => null };\n\n    module.addCustomProvider(provider as any, new Map());\n    expect((addCustomClass as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomValue\" when \"useValue\" property exists","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":130,"column":66},"line":130,"code":"  it('should call \"addCustomValue\" when \"useValue\" property exists', () => {\n    const addCustomValue = sinon.spy();\n    module.addCustomValue = addCustomValue;\n\n    const provider = { provide: 'test', useValue: () => null };\n\n    module.addCustomProvider(provider as any, new Map());\n    expect((addCustomValue as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomValue\" when \"useValue\" property exists but its value is `undefined`","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":140,"column":95},"line":140,"code":"  it('should call \"addCustomValue\" when \"useValue\" property exists but its value is `undefined`', () => {\n    const addCustomValue = sinon.spy();\n    module.addCustomValue = addCustomValue;\n\n    const provider = { provide: 'test', useValue: undefined };\n\n    module.addCustomProvider(provider as any, new Map());\n    expect((addCustomValue as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomFactory\" when \"useFactory\" property exists","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":150,"column":70},"line":150,"code":"  it('should call \"addCustomFactory\" when \"useFactory\" property exists', () => {\n    const addCustomFactory = sinon.spy();\n    module.addCustomFactory = addCustomFactory;\n\n    const provider = { provide: 'test', useFactory: () => null };\n\n    module.addCustomProvider(provider as any, new Map());\n    expect((addCustomFactory as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addCustomUseExisting\" when \"useExisting\" property exists","suites":["Module","when injectable is custom provided"],"updatePoint":{"line":160,"column":75},"line":160,"code":"  it('should call \"addCustomUseExisting\" when \"useExisting\" property exists', () => {\n    const addCustomUseExisting = sinon.spy();\n    module.addCustomUseExisting = addCustomUseExisting;\n\n    const provider = { provide: 'test', useExisting: () => null };\n\n    module.addCustomUseExisting(provider as any, new Map());\n    expect((addCustomUseExisting as sinon.SinonSpy).called).to.be.true;\n  });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store provider","suites":["Module","addCustomClass"],"updatePoint":{"line":180,"column":29},"line":180,"code":"    it('should store provider', () => {\n      module.addCustomClass(provider as any, (module as any)._providers);\n      expect(\n        setSpy.calledWith(\n          provider.provide,\n          new InstanceWrapper({\n            host: module,\n            token: type as any,\n            name: provider.provide.name,\n            scope: undefined,\n            metatype: type as any,\n            durable: true,\n            instance: null,\n            isResolved: false,\n            subtype: undefined,\n          }),\n        ),\n      ).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store provider","suites":["Module","addCustomValue"],"updatePoint":{"line":212,"column":29},"line":212,"code":"    it('should store provider', () => {\n      module.addCustomValue(provider as any, (module as any)._providers);\n      expect(\n        setSpy.calledWith(\n          provider.provide,\n          new InstanceWrapper({\n            host: module,\n            token: provider.provide,\n            name: provider.provide.name,\n            scope: Scope.DEFAULT,\n            metatype: null,\n            instance: value,\n            isResolved: true,\n            async: false,\n            subtype: undefined,\n          }),\n        ),\n      ).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store provider","suites":["Module","addCustomFactory"],"updatePoint":{"line":244,"column":29},"line":244,"code":"    it('should store provider', () => {\n      module.addCustomFactory(provider as any, (module as any)._providers);\n\n      expect(\n        setSpy.calledWith(\n          provider.provide,\n          new InstanceWrapper({\n            host: module,\n            token: provider.provide as any,\n            name: provider.provide.name,\n            scope: undefined,\n            metatype: type as any,\n            durable: true,\n            instance: null,\n            isResolved: false,\n            inject: inject as any,\n            subtype: undefined,\n          }),\n        ),\n      ).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store provider","suites":["Module","addCustomUseExisting"],"updatePoint":{"line":277,"column":29},"line":277,"code":"    it('should store provider', () => {\n      module.addCustomUseExisting(provider as any, (module as any)._providers);\n      const factoryFn = (module as any)._providers.get(\n        provider.provide,\n      ).metatype;\n\n      const token = provider.provide as any;\n      expect(\n        setSpy.calledWith(\n          token,\n          new InstanceWrapper({\n            host: module,\n            token,\n            name: provider.provide.name,\n            metatype: factoryFn,\n            instance: null,\n            inject: [provider.useExisting as any],\n            isResolved: false,\n            isAlias: true,\n            subtype: undefined,\n          }),\n        ),\n      ).to.be.true;\n      expect(factoryFn(provider.useExisting)).to.be.eql(type);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw RuntimeException","suites":["Module","when get instance","when metatype does not exists in providers collection"],"updatePoint":{"line":309,"column":39},"line":309,"code":"      it('should throw RuntimeException', () => {\n        expect(() => module.instance).to.throws(RuntimeException);\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["Module","when get instance","when metatype exists in providers collection"],"updatePoint":{"line":314,"column":28},"line":314,"code":"      it('should return null', () => {\n        expect(module.instance).to.be.eql(null);\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `addCustomExportedProvider`","suites":["Module","when exported provider is custom provided"],"updatePoint":{"line":324,"column":47},"line":324,"code":"    it('should call `addCustomExportedProvider`', () => {\n      const addCustomExportedProviderSpy = sinon.spy(\n        module,\n        'addCustomExportedProvider',\n      );\n\n      module.addExportedProvider({ provide: 'test' } as any);\n      expect(addCustomExportedProviderSpy.called).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should support symbols","suites":["Module","when exported provider is custom provided"],"updatePoint":{"line":333,"column":30},"line":333,"code":"    it('should support symbols', () => {\n      const addCustomExportedProviderSpy = sinon.spy(\n        module,\n        'addCustomExportedProvider',\n      );\n      const symb = Symbol('test');\n      module.addExportedProvider({ provide: symb } as any);\n      expect(addCustomExportedProviderSpy.called).to.be.true;\n      expect((module as any)._exports.has(symb)).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `mergeWith`","suites":["Module","replace","when provider"],"updatePoint":{"line":347,"column":33},"line":347,"code":"      it('should call `mergeWith`', () => {\n        const wrapper = {\n          mergeWith: sinon.spy(),\n        };\n        sinon.stub(module, 'hasProvider').callsFake(() => true);\n        sinon.stub(module.providers, 'get').callsFake(() => wrapper as any);\n\n        module.replace(null, { isProvider: true });\n        expect(wrapper.mergeWith.called).to.be.true;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `mergeWith`","suites":["Module","replace","when guard"],"updatePoint":{"line":359,"column":33},"line":359,"code":"      it('should call `mergeWith`', () => {\n        const wrapper = {\n          mergeWith: sinon.spy(),\n          isProvider: true,\n        };\n        sinon.stub(module, 'hasInjectable').callsFake(() => true);\n        sinon.stub(module.injectables, 'get').callsFake(() => wrapper as any);\n\n        module.replace(null, {});\n        expect(wrapper.mergeWith.called).to.be.true;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return relatedModules","suites":["Module","imports"],"updatePoint":{"line":374,"column":36},"line":374,"code":"    it('should return relatedModules', () => {\n      const test = ['test'];\n      (module as any)._imports = test;\n\n      expect(module.imports).to.be.eql(test);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return injectables","suites":["Module","injectables"],"updatePoint":{"line":383,"column":33},"line":383,"code":"    it('should return injectables', () => {\n      const test = ['test'];\n      (module as any)._injectables = test;\n      expect(module.injectables).to.be.eql(test);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return controllers","suites":["Module","controllers"],"updatePoint":{"line":391,"column":33},"line":391,"code":"    it('should return controllers', () => {\n      const test = ['test'];\n      (module as any)._controllers = test;\n\n      expect(module.controllers).to.be.eql(test);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return exports","suites":["Module","exports"],"updatePoint":{"line":400,"column":29},"line":400,"code":"    it('should return exports', () => {\n      const test = ['test'];\n      (module as any)._exports = test;\n\n      expect(module.exports).to.be.eql(test);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return providers","suites":["Module","providers"],"updatePoint":{"line":409,"column":31},"line":409,"code":"    it('should return providers', () => {\n      const test = ['test'];\n      (module as any)._providers = test;\n\n      expect(module.providers).to.be.eql(test);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return metatype with \"get\" method","suites":["Module","createModuleReferenceType"],"updatePoint":{"line":425,"column":48},"line":425,"code":"    it('should return metatype with \"get\" method', () => {\n      expect(!!moduleRef.get).to.be.true;\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception if not exists","suites":["Module","createModuleReferenceType","get"],"updatePoint":{"line":429,"column":46},"line":429,"code":"      it('should throw exception if not exists', () => {\n        expect(() => moduleRef.get('fail')).to.throws(UnknownElementException);\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should behave as identity","suites":["Module","validateExportedProvider","when unit exists in provider collection"],"updatePoint":{"line":438,"column":35},"line":438,"code":"      it('should behave as identity', () => {\n        (module as any)._providers = new Map([[token, true]]);\n        expect(module.validateExportedProvider(token)).to.be.eql(token);\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should behave as identity","suites":["Module","validateExportedProvider","when unit exists in related modules collection"],"updatePoint":{"line":444,"column":35},"line":444,"code":"      it('should behave as identity', () => {\n        class Random {}\n        (module as any)._imports = new Set([\n          new Module(Random, new NestContainer()),\n        ]);\n        expect(module.validateExportedProvider(Random)).to.be.eql(Random);\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw UnknownExportException","suites":["Module","validateExportedProvider","when unit does not exist in both provider and related modules collections"],"updatePoint":{"line":453,"column":45},"line":453,"code":"      it('should throw UnknownExportException', () => {\n        expect(() => module.validateExportedProvider(token)).to.throws(\n          UnknownExportException,\n        );\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["Module","hasProvider","when module has provider"],"updatePoint":{"line":463,"column":28},"line":463,"code":"      it('should return true', () => {\n        const token = 'test';\n        module.providers.set(token, new InstanceWrapper());\n        expect(module.hasProvider(token)).to.be.true;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["Module","hasProvider","otherwise"],"updatePoint":{"line":470,"column":29},"line":470,"code":"      it('should return false', () => {\n        expect(module.hasProvider('_')).to.be.false;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["Module","hasInjectable","when module has injectable"],"updatePoint":{"line":478,"column":28},"line":478,"code":"      it('should return true', () => {\n        const token = 'test';\n        module.injectables.set(token, new InstanceWrapper());\n        expect(module.hasInjectable(token)).to.be.true;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["Module","hasInjectable","otherwise"],"updatePoint":{"line":485,"column":29},"line":485,"code":"      it('should return false', () => {\n        expect(module.hasInjectable('_')).to.be.false;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return module id","suites":["Module","getter \"id\""],"updatePoint":{"line":492,"column":31},"line":492,"code":"    it('should return module id', () => {\n      expect(module.id).to.be.equal(module['_id']);\n    });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["Module","getProviderByKey","when does not exist"],"updatePoint":{"line":499,"column":33},"line":499,"code":"      it('should return undefined', () => {\n        expect(module.getProviderByKey('test')).to.be.undefined;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance wrapper","suites":["Module","getProviderByKey","otherwise"],"updatePoint":{"line":504,"column":40},"line":504,"code":"      it('should return instance wrapper', () => {\n        module.addProvider(TestProvider);\n        expect(module.getProviderByKey(TestProvider)).to.not.be.undefined;\n      });","file":"injector/module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert an enhancer metadata cache entry","suites":["GraphInspector","insertEnhancerMetadataCache"],"updatePoint":{"line":26,"column":54},"line":26,"code":"    it('should insert an enhancer metadata cache entry', () => {\n      const entry = {\n        moduleToken: 'moduleToken',\n        classRef: class AppService {},\n        methodKey: undefined,\n        subtype: 'guard' as const,\n      };\n      graphInspector.insertEnhancerMetadataCache(entry);\n      expect(enhancersMetadataCache).includes(entry);\n    });","file":"inspector/graph-inspector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should inspect given instance wrapper and insert appropriate edges","suites":["GraphInspector","inspectInstanceWrapper"],"updatePoint":{"line":41,"column":74},"line":41,"code":"    it('should inspect given instance wrapper and insert appropriate edges', () => {\n      const moduleRef = new Module(class TestModule {}, container);\n      const instanceWrapper = new InstanceWrapper({\n        token: AppService,\n        name: AppService.name,\n        metatype: AppService,\n      });\n\n      const param1 = new InstanceWrapper({\n        token: 'PARAM_1',\n        metatype: class A {},\n        host: new Module(class AModule {}, container),\n      });\n      const param2 = new InstanceWrapper({\n        token: 'PARAM_2',\n        metatype: class B {},\n        host: new Module(class BModule {}, container),\n      });\n      const dependency = new InstanceWrapper({\n        name: 'PROPERTY',\n        token: 'PROPERTY',\n        metatype: class C {},\n        host: new Module(class CModule {}, container),\n      });\n\n      instanceWrapper.addCtorMetadata(0, param1);\n      instanceWrapper.addCtorMetadata(1, param2);\n      instanceWrapper.addCtorMetadata(2, dependency);\n\n      graphInspector.inspectInstanceWrapper(instanceWrapper, moduleRef);\n\n      const edgesArr = [...graph['edges'].values()];\n      expect(edgesArr).to.deep.equal([\n        {\n          id: edgesArr[0].id,\n          metadata: {\n            injectionType: 'constructor',\n            keyOrIndex: 0,\n            sourceClassName: instanceWrapper.metatype.name,\n            sourceClassToken: instanceWrapper.token,\n            sourceModuleName: 'TestModule',\n            targetClassName: param1.name,\n            targetClassToken: 'PARAM_1',\n            targetModuleName: 'AModule',\n            type: 'class-to-class',\n          },\n          source: instanceWrapper.id,\n          target: param1.id,\n        },\n        {\n          id: edgesArr[1].id,\n          metadata: {\n            injectionType: 'constructor',\n            keyOrIndex: 1,\n            sourceClassName: instanceWrapper.metatype.name,\n            sourceClassToken: instanceWrapper.token,\n            sourceModuleName: 'TestModule',\n            targetClassName: param2.name,\n            targetClassToken: 'PARAM_2',\n            targetModuleName: 'BModule',\n            type: 'class-to-class',\n          },\n          source: instanceWrapper.id,\n          target: param2.id,\n        },\n        {\n          id: edgesArr[2].id,\n          metadata: {\n            injectionType: 'constructor',\n            keyOrIndex: 2,\n            sourceClassName: 'AppService',\n            sourceClassToken: AppService,\n            sourceModuleName: 'TestModule',\n            targetClassName: dependency.name,\n            targetClassToken: 'PROPERTY',\n            targetModuleName: 'CModule',\n            type: 'class-to-class',\n          },\n          source: instanceWrapper.id,\n          target: dependency.id,\n        },\n      ]);\n    });","file":"inspector/graph-inspector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should inspect all modules","suites":["GraphInspector","inspectModules"],"updatePoint":{"line":131,"column":34},"line":131,"code":"    it('should inspect all modules', async () => {\n      const { moduleRef } = await container.addModule(TestModule, []);\n      moduleRef.addController(AController);\n\n      const subtype = 'interceptor';\n      const enhancerInstanceWrapper = moduleRef.addInjectable(\n        class Enhancer {},\n        subtype,\n      ) as InstanceWrapper;\n\n      const methodKey = 'findOne';\n      enhancersMetadataCache.push(\n        {\n          moduleToken: moduleRef.token,\n          classRef: AController,\n          enhancerRef: new RandomPipe(),\n          methodKey,\n          subtype,\n        },\n        {\n          moduleToken: moduleRef.token,\n          classRef: AController,\n          enhancerRef: function test() {},\n          methodKey,\n          subtype,\n        },\n        {\n          moduleToken: moduleRef.token,\n          classRef: AController,\n          enhancerInstanceWrapper,\n          methodKey: undefined,\n          subtype,\n        },\n      );\n\n      const serializedNode = { metadata: {} };\n      sinon.stub(graph, 'getNodeById').callsFake(() => serializedNode as any);\n\n      graphInspector.inspectModules();\n\n      expect(serializedNode).to.deep.equal({\n        metadata: {\n          enhancers: [\n            { methodKey, name: RandomPipe.name, subtype },\n            { methodKey, name: 'Function', subtype },\n            { methodKey: undefined, id: enhancerInstanceWrapper.id, subtype },\n          ],\n        },\n      });\n    });","file":"inspector/graph-inspector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should upsert existing node (update metadata) and add node to \"attachedEnhancers\" array","suites":["GraphInspector","insertAttachedEnhancer"],"updatePoint":{"line":184,"column":95},"line":184,"code":"    it('should upsert existing node (update metadata) and add node to \"attachedEnhancers\" array', () => {\n      const instanceWrapper = new InstanceWrapper({\n        metatype: class A {},\n        token: 'A',\n      });\n\n      const nodeDefinition = {\n        id: instanceWrapper.id,\n        label: 'A',\n        parent: '2c989d11-2731-4828-a2eb-c86d10c73621',\n        metadata: {\n          type: 'provider' as const,\n          sourceModuleName: 'AppModule',\n          durable: false,\n          static: true,\n          scope: Scope.DEFAULT,\n          transient: false,\n          token: class A {},\n          exported: false,\n          initTime: 100,\n        },\n      };\n      const insertedNode = graph.insertNode(nodeDefinition);\n\n      graphInspector.insertAttachedEnhancer(instanceWrapper);\n\n      expect(insertedNode.metadata).to.deep.equal({\n        ...nodeDefinition.metadata,\n        global: true,\n      });\n      expect(graph['extras'].attachedEnhancers).to.deep.contain({\n        nodeId: insertedNode.id,\n      });\n    });","file":"inspector/graph-inspector.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert a node with the expected schema (internal: true)","suites":["SerializedGraph","insertNode","when node definition represents an internal provider"],"updatePoint":{"line":21,"column":72},"line":21,"code":"      it('should insert a node with the expected schema (internal: true)', () => {\n        const nodeDefinition = {\n          id: '11430093-e992-4ae6-8ba4-c7db80419de8',\n          label: 'ApplicationConfig',\n          parent: '2c989d11-2731-4828-a2eb-c86d10c73621',\n          metadata: {\n            type: 'provider' as const,\n            sourceModuleName: 'AppModule',\n            durable: false,\n            static: true,\n            transient: false,\n            token: ApplicationConfig,\n            scope: Scope.DEFAULT,\n            exported: false,\n            initTime: 100,\n          },\n        };\n        serializedGraph.insertNode(nodeDefinition);\n\n        expect(nodesCollection.get(nodeDefinition.id)).to.deep.equal({\n          ...nodeDefinition,\n          metadata: {\n            ...nodeDefinition.metadata,\n            internal: true,\n          },\n        });\n      });","file":"inspector/serialized-graph.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert a node with the expected schema","suites":["SerializedGraph","insertNode","otherwise"],"updatePoint":{"line":50,"column":55},"line":50,"code":"      it('should insert a node with the expected schema', () => {\n        class AppService {}\n\n        const nodeDefinition = {\n          id: '11430093-e992-4ae6-8ba4-c7db80419de8',\n          label: 'AppService',\n          parent: '2c989d11-2731-4828-a2eb-c86d10c73621',\n          metadata: {\n            type: 'provider' as const,\n            sourceModuleName: 'AppModule',\n            durable: false,\n            static: true,\n            transient: false,\n            token: AppService,\n            scope: Scope.DEFAULT,\n            exported: false,\n            initTime: 100,\n          },\n        };\n        serializedGraph.insertNode(nodeDefinition);\n\n        expect(nodesCollection.get(nodeDefinition.id)).to.equal(nodeDefinition);\n      });","file":"inspector/serialized-graph.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert an edge with the expected schema (internal: true)","suites":["SerializedGraph","insertEdge","when edge definition represents internal providers connection"],"updatePoint":{"line":78,"column":73},"line":78,"code":"      it('should insert an edge with the expected schema (internal: true)', () => {\n        const edgeDefinition = {\n          source: '8920252f-4e7d-4f9e-9eeb-71da467a35cc',\n          target: 'c97bc04d-cfcf-41b1-96ec-db729f33676e',\n          metadata: {\n            type: 'class-to-class' as const,\n            sourceModuleName: 'UtilsExceptionsModule',\n            sourceClassName: 'AllExceptionsFilter',\n            targetClassName: 'HttpAdapterHost',\n            sourceClassToken:\n              'APP_FILTER (UUID: 4187828c-5c76-4aed-a29f-a6eb40054b9d)',\n            targetClassToken: 'HttpAdapterHost',\n            targetModuleName: 'InternalCoreModule',\n            keyOrIndex: 0,\n            injectionType: 'constructor' as const,\n          },\n        };\n        const edge = serializedGraph.insertEdge(edgeDefinition);\n\n        expect(edgesCollection.get(edge.id)).to.deep.equal({\n          ...edgeDefinition,\n          metadata: {\n            ...edgeDefinition.metadata,\n            internal: true,\n          },\n          id: edge.id,\n        });\n      });","file":"inspector/serialized-graph.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert an edge with the expected schema","suites":["SerializedGraph","insertEdge","otherwise"],"updatePoint":{"line":108,"column":56},"line":108,"code":"      it('should insert an edge with the expected schema', () => {\n        const edgeDefinition = {\n          source: '8920252f-4e7d-4f9e-9eeb-71da467a35cc',\n          target: 'c97bc04d-cfcf-41b1-96ec-db729f33676e',\n          metadata: {\n            type: 'class-to-class' as const,\n            sourceModuleName: 'UtilsExceptionsModule',\n            sourceClassName: 'AllExceptionsFilter',\n            targetClassName: 'AppService',\n            sourceClassToken:\n              'APP_FILTER (UUID: 4187828c-5c76-4aed-a29f-a6eb40054b9d)',\n            targetClassToken: 'AppService',\n            targetModuleName: 'InternalCoreModule',\n            keyOrIndex: 0,\n            injectionType: 'constructor' as const,\n          },\n        };\n        const edge = serializedGraph.insertEdge(edgeDefinition);\n\n        expect(edgesCollection.get(edge.id)).to.deep.equal({\n          ...edgeDefinition,\n          id: edge.id,\n        });\n      });","file":"inspector/serialized-graph.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a given node","suites":["SerializedGraph","getNodeById"],"updatePoint":{"line":136,"column":34},"line":136,"code":"    it('should return a given node', () => {\n      const nodeDefinition = {\n        id: '11430093-e992-4ae6-8ba4-c7db80419de8',\n        label: 'AppService',\n        parent: '2c989d11-2731-4828-a2eb-c86d10c73621',\n        metadata: {\n          type: 'provider' as const,\n          sourceModuleName: 'AppModule',\n          durable: false,\n          static: true,\n          transient: false,\n          scope: Scope.DEFAULT,\n          token: 'AppService',\n          exported: true,\n          initTime: 100,\n        },\n      };\n\n      nodesCollection.set(nodeDefinition.id, nodeDefinition);\n      expect(serializedGraph.getNodeById(nodeDefinition.id)).to.eq(\n        nodeDefinition,\n      );\n    });","file":"inspector/serialized-graph.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call next()","suites":["InterceptorsConsumer","intercept","when interceptors array is empty"],"updatePoint":{"line":30,"column":28},"line":30,"code":"      it('should call next()', async () => {\n        await consumer.intercept([], null, { constructor: null }, null, next);\n        expect(next.calledOnce).to.be.true;\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"does not call `intercept` (lazy evaluation)","suites":["InterceptorsConsumer","intercept","when interceptors array is not empty"],"updatePoint":{"line":40,"column":53},"line":40,"code":"      it('does not call `intercept` (lazy evaluation)', async () => {\n        await consumer.intercept(\n          interceptors,\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n\n        expect(interceptors[0].intercept.called).to.be.false;\n        expect(interceptors[1].intercept.called).to.be.false;\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call every `intercept` method when subscribe","suites":["InterceptorsConsumer","intercept","when interceptors array is not empty"],"updatePoint":{"line":52,"column":61},"line":52,"code":"      it('should call every `intercept` method when subscribe', async () => {\n        const intercepted = await consumer.intercept(\n          interceptors,\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n        await transformToResult(intercepted);\n\n        expect(interceptors[0].intercept.calledOnce).to.be.true;\n        expect(interceptors[1].intercept.calledOnce).to.be.true;\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call `next` (lazy evaluation)","suites":["InterceptorsConsumer","intercept","when interceptors array is not empty"],"updatePoint":{"line":65,"column":50},"line":65,"code":"      it('should not call `next` (lazy evaluation)', async () => {\n        await consumer.intercept(\n          interceptors,\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n        expect(next.called).to.be.false;\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call `next` when subscribe","suites":["InterceptorsConsumer","intercept","when interceptors array is not empty"],"updatePoint":{"line":75,"column":43},"line":75,"code":"      it('should call `next` when subscribe', async () => {\n        const intercepted = await consumer.intercept(\n          interceptors,\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n        await transformToResult(intercepted);\n        expect(next.called).to.be.true;\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow an interceptor to set values in AsyncLocalStorage that are accesible from the controller","suites":["InterceptorsConsumer","intercept","when AsyncLocalStorage is used"],"updatePoint":{"line":89,"column":111},"line":89,"code":"      it('should allow an interceptor to set values in AsyncLocalStorage that are accesible from the controller', async () => {\n        const storage = new AsyncLocalStorage<Record<string, any>>();\n        class StorageInterceptor implements NestInterceptor {\n          intercept(\n            _context: ExecutionContext,\n            next: CallHandler<any>,\n          ): Observable<any> | Promise<Observable<any>> {\n            return storage.run({ value: 'hello' }, () => next.handle());\n          }\n        }\n        const next = () => {\n          return Promise.resolve(storage.getStore().value);\n        };\n        const intercepted = await consumer.intercept(\n          [new StorageInterceptor()],\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n        const result = await transformToResult(intercepted);\n        expect(result).to.equal('hello');\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should retry a specified amount of times","suites":["InterceptorsConsumer","intercept","when retrying is enabled"],"updatePoint":{"line":115,"column":50},"line":115,"code":"      it('should retry a specified amount of times', async () => {\n        let count = 0;\n        const next = () => {\n          count++;\n          if (count < 3) {\n            return Promise.reject(new Error('count not reached'));\n          }\n          return Promise.resolve(count);\n        };\n        class RetryInterceptor implements NestInterceptor {\n          intercept(\n            _context: ExecutionContext,\n            next: CallHandler<any>,\n          ): Observable<any> | Promise<Observable<any>> {\n            return next.handle().pipe(retry(4));\n          }\n        }\n        const intercepted = await consumer.intercept(\n          [new RetryInterceptor()],\n          null,\n          { constructor: null },\n          null,\n          next,\n        );\n        expect(await transformToResult(intercepted)).to.equal(3);\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return execution context object","suites":["InterceptorsConsumer","createContext"],"updatePoint":{"line":144,"column":46},"line":144,"code":"    it('should return execution context object', () => {\n      const instance = { constructor: {} };\n      const callback = () => null;\n      const context = consumer.createContext([], instance, callback);\n\n      expect(context.getClass()).to.be.eql(instance.constructor);\n      expect(context.getHandler()).to.be.eql(callback);\n    });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Observable","suites":["InterceptorsConsumer","transformDeferred","when next() result is plain value"],"updatePoint":{"line":155,"column":34},"line":155,"code":"      it('should return Observable', async () => {\n        const val = 3;\n        const next = async () => val;\n        expect(await lastValueFrom(consumer.transformDeferred(next))).to.be.eql(\n          val,\n        );\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Observable","suites":["InterceptorsConsumer","transformDeferred","when next() result is Promise"],"updatePoint":{"line":164,"column":34},"line":164,"code":"      it('should return Observable', async () => {\n        const val = 3;\n        const next = async () => val;\n        expect(await lastValueFrom(consumer.transformDeferred(next))).to.be.eql(\n          val,\n        );\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Observable","suites":["InterceptorsConsumer","transformDeferred","when next() result is Observable"],"updatePoint":{"line":173,"column":34},"line":173,"code":"      it('should return Observable', async () => {\n        const val = 3;\n        const next = async () => of(val);\n        expect(\n          await await lastValueFrom(consumer.transformDeferred(next) as any),\n        ).to.be.eql(val);\n      });","file":"interceptors/interceptors-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty array","suites":["InterceptorsContextCreator","createConcreteContext","when `moduleContext` is nil"],"updatePoint":{"line":62,"column":35},"line":62,"code":"      it('should return empty array', () => {\n        const result =\n          interceptorsContextCreator.createConcreteContext(interceptors);\n        expect(result).to.be.empty;\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should filter metatypes","suites":["InterceptorsContextCreator","createConcreteContext","when `moduleContext` is defined"],"updatePoint":{"line":72,"column":33},"line":72,"code":"      it('should filter metatypes', () => {\n        const interceptorTypeRefs = [\n          interceptors[0].metatype,\n          interceptors[1].instance,\n        ];\n        expect(\n          interceptorsContextCreator.createConcreteContext(interceptorTypeRefs),\n        ).to.have.length(2);\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["InterceptorsContextCreator","getInterceptorInstance","when param is an object"],"updatePoint":{"line":86,"column":32},"line":86,"code":"      it('should return instance', () => {\n        const instance = { intercept: () => null };\n        expect(\n          interceptorsContextCreator.getInterceptorInstance(instance),\n        ).to.be.eql(instance);\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pick instance from container","suites":["InterceptorsContextCreator","getInterceptorInstance","when param is a constructor"],"updatePoint":{"line":94,"column":45},"line":94,"code":"      it('should pick instance from container', () => {\n        const wrapper: InstanceWrapper = {\n          instance: 'test',\n          getInstanceByContextId: () => wrapper,\n        } as any;\n        sinon\n          .stub(interceptorsContextCreator, 'getInstanceByMetatype')\n          .callsFake(() => wrapper);\n        expect(\n          interceptorsContextCreator.getInterceptorInstance(Interceptor),\n        ).to.be.eql(wrapper.instance);\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["InterceptorsContextCreator","getInterceptorInstance","when param is a constructor"],"updatePoint":{"line":106,"column":28},"line":106,"code":"      it('should return null', () => {\n        sinon\n          .stub(interceptorsContextCreator, 'getInstanceByMetatype')\n          .callsFake(() => null);\n        expect(\n          interceptorsContextCreator.getInterceptorInstance(Interceptor),\n        ).to.be.eql(null);\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["InterceptorsContextCreator","getInstanceByMetatype","when \"moduleContext\" is nil"],"updatePoint":{"line":119,"column":33},"line":119,"code":"      it('should return undefined', () => {\n        (interceptorsContextCreator as any).moduleContext = undefined;\n        expect(interceptorsContextCreator.getInstanceByMetatype(null)).to.be\n          .undefined;\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["InterceptorsContextCreator","getInstanceByMetatype","when \"moduleContext\" is not nil","and when module exists"],"updatePoint":{"line":131,"column":35},"line":131,"code":"        it('should return undefined', () => {\n          expect(interceptorsContextCreator.getInstanceByMetatype(class {})).to\n            .be.undefined;\n        });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return global interceptors","suites":["InterceptorsContextCreator","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":141,"column":43},"line":141,"code":"      it('should return global interceptors', () => {\n        const expectedResult = applicationConfig.getGlobalInterceptors();\n        expect(interceptorsContextCreator.getGlobalMetadata()).to.be.equal(\n          expectedResult,\n        );\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should merge static global with request/transient scoped interceptors","suites":["InterceptorsContextCreator","getGlobalMetadata","otherwise"],"updatePoint":{"line":149,"column":79},"line":149,"code":"      it('should merge static global with request/transient scoped interceptors', () => {\n        const globalInterceptors: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedInterceptorWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalInterceptors')\n          .callsFake(() => globalInterceptors);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestInterceptors')\n          .callsFake(() => scopedInterceptorWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(\n          interceptorsContextCreator.getGlobalMetadata({ id: 3 }),\n        ).to.contains(instance, ...globalInterceptors);\n      });","file":"interceptors/interceptors-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return only methods","suites":["MetadataScanner","scanFromPrototype"],"updatePoint":{"line":32,"column":34},"line":32,"code":"    it('should return only methods', () => {\n      const methods = scanner.getAllMethodNames(Test.prototype);\n      expect(methods).to.eql(['test', 'test2', 'testParent', 'testParent2']);\n    });","file":"metadata-scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the same instance for the same prototype","suites":["MetadataScanner","scanFromPrototype"],"updatePoint":{"line":37,"column":62},"line":37,"code":"    it('should return the same instance for the same prototype', () => {\n      const methods1 = scanner.getAllMethodNames(Test.prototype);\n      const methods2 = scanner.getAllMethodNames(Test.prototype);\n      expect(methods1 === methods2).to.eql(true);\n    });","file":"metadata-scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should keep compatibility with older methods","suites":["MetadataScanner","scanFromPrototype"],"updatePoint":{"line":43,"column":52},"line":43,"code":"    it('should keep compatibility with older methods', () => {\n      const methods1 = scanner.getAllMethodNames(Test.prototype).map(m => m[0]);\n      const methods2 = scanner.scanFromPrototype(\n        new Test(),\n        Test.prototype,\n        r => r[0],\n      );\n\n      expect(methods1).to.eql(methods2);\n\n      const methods3 = scanner.getAllMethodNames(Test.prototype);\n      const methods4 = [\n        ...new Set(scanner.getAllFilteredMethodNames(Test.prototype)),\n      ];\n\n      expect(methods3).to.eql(methods4);\n    });","file":"metadata-scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return configuration proxy","suites":["MiddlewareBuilder","apply"],"updatePoint":{"line":37,"column":41},"line":37,"code":"    it('should return configuration proxy', () => {\n      const configProxy = builder.apply([]);\n      const metatype = (MiddlewareBuilder as any).ConfigProxy;\n      expect(configProxy instanceof metatype).to.be.true;\n    });","file":"middleware/builder.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store configuration passed as argument","suites":["MiddlewareBuilder","apply","configuration proxy","when \"forRoutes()\" called"],"updatePoint":{"line":60,"column":57},"line":60,"code":"        it('should store configuration passed as argument', () => {\n          configProxy.forRoutes(route, Test);\n\n          expect(builder.build()).to.deep.equal([\n            {\n              middleware: [],\n              forRoutes: [\n                {\n                  method: RequestMethod.GET,\n                  path: route.path,\n                },\n                {\n                  method: RequestMethod.GET,\n                  path: '/path/route',\n                },\n                {\n                  method: RequestMethod.GET,\n                  path: '/path/versioned',\n                  version: '1',\n                },\n              ],\n            },\n          ]);\n        });","file":"middleware/builder.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should remove overlapping routes","suites":["MiddlewareBuilder","apply","configuration proxy","when \"forRoutes()\" called"],"updatePoint":{"line":124,"column":44},"line":124,"code":"        it('should remove overlapping routes', () => {\n          configProxy.forRoutes(UsersController);\n\n          expect(builder.build()).to.deep.equal([\n            {\n              middleware: [],\n              forRoutes: [\n                {\n                  method: RequestMethod.HEAD,\n                  path: '/users/rsvp',\n                },\n                {\n                  method: RequestMethod.OPTIONS,\n                  path: '/users/rsvp',\n                },\n                {\n                  method: RequestMethod.POST,\n                  path: '/users/rsvp',\n                },\n                {\n                  method: RequestMethod.PUT,\n                  path: '/users/rsvp',\n                },\n                {\n                  method: RequestMethod.POST,\n                  path: '/users/',\n                },\n                {\n                  method: RequestMethod.GET,\n                  path: '/users/',\n                },\n                {\n                  method: RequestMethod.GET,\n                  path: '/users/:id',\n                },\n                {\n                  method: RequestMethod.PATCH,\n                  path: '/users/:id',\n                },\n                {\n                  method: RequestMethod.DELETE,\n                  path: '/users/:id',\n                },\n                // Overlapping:\n                // {\n                //   method: RequestMethod.GET,\n                //   path: '/users/rsvp',\n                // },\n                // {\n                //   method: RequestMethod.PATCH,\n                //   path: '/users/rsvp',\n                // },\n                // {\n                //   method: RequestMethod.DELETE,\n                //   path: '/users/rsvp',\n                // },\n              ],\n            },\n          ]);\n        });","file":"middleware/builder.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map string to RouteInfo","suites":["MiddlewareBuilder","exclude"],"updatePoint":{"line":189,"column":38},"line":189,"code":"    it('should map string to RouteInfo', () => {\n      const path = '/test';\n      const proxy: any = builder.apply().exclude(path);\n\n      expect(proxy.getExcludedRoutes()).to.be.eql([\n        {\n          path,\n          method: -1 as any,\n        },\n      ]);\n    });","file":"middleware/builder.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store expected configurations for given module","suites":["MiddlewareContainer"],"updatePoint":{"line":42,"column":59},"line":42,"code":"  it('should store expected configurations for given module', () => {\n    const config: MiddlewareConfiguration[] = [\n      {\n        middleware: [TestMiddleware],\n        forRoutes: [TestRoute, 'test'],\n      },\n    ];\n    container.insertConfig(config, 'Module');\n    expect([...container.getConfigurations().get('Module')]).to.deep.equal(\n      config,\n    );\n  });","file":"middleware/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should store expected middleware for given module","suites":["MiddlewareContainer"],"updatePoint":{"line":55,"column":55},"line":55,"code":"  it('should store expected middleware for given module', () => {\n    const config: MiddlewareConfiguration[] = [\n      {\n        middleware: TestMiddleware,\n        forRoutes: [TestRoute],\n      },\n    ];\n\n    const key = 'Test';\n    container.insertConfig(config, key);\n\n    const collection = container.getMiddlewareCollection(key);\n    const insertedMiddleware = collection.get(TestMiddleware);\n\n    expect(collection.size).to.eql(config.length);\n    expect(insertedMiddleware).to.be.instanceOf(InstanceWrapper);\n    expect(insertedMiddleware.scope).to.be.undefined;\n    expect(insertedMiddleware.metatype).to.be.eql(TestMiddleware);\n  });","file":"middleware/container.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"configure\" method if method is implemented","suites":["MiddlewareModule","loadConfiguration"],"updatePoint":{"line":69,"column":63},"line":69,"code":"    it('should call \"configure\" method if method is implemented', async () => {\n      const stubContainer = new NestContainer();\n      stubContainer\n        .getModules()\n        .set('Test', new Module(class {}, stubContainer));\n\n      const configureSpy = sinon.spy();\n      const mockModule = {\n        instance: {\n          configure: configureSpy,\n        },\n      };\n\n      (middlewareModule as any).container = stubContainer;\n      await middlewareModule.loadConfiguration(\n        new MiddlewareContainer(stubContainer),\n        mockModule as any,\n        'Test',\n      );\n\n      expect(configureSpy.calledOnce).to.be.true;\n      expect(\n        configureSpy.calledWith(\n          new MiddlewareBuilder(\n            (middlewareModule as any).routesMapper,\n            undefined,\n            new RouteInfoPathExtractor(new ApplicationConfig()),\n          ),\n        ),\n      ).to.be.true;\n    });","file":"middleware/middleware-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"RuntimeException\" exception when middleware is not stored in container","suites":["MiddlewareModule","registerRouteMiddleware"],"updatePoint":{"line":113,"column":92},"line":113,"code":"    it('should throw \"RuntimeException\" exception when middleware is not stored in container', () => {\n      const route = { path: 'Test' };\n      const configuration = {\n        middleware: [TestMiddleware],\n        forRoutes: [BaseController],\n      };\n      const useSpy = sinon.spy();\n      const app = { use: useSpy };\n\n      middlewareModule['container'] = nestContainer;\n\n      expect(\n        middlewareModule.registerRouteMiddleware(\n          new MiddlewareContainer(nestContainer),\n          route as any,\n          configuration,\n          'Test',\n          app,\n        ),\n      ).to.eventually.be.rejectedWith(RuntimeException);\n    });","file":"middleware/middleware-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"InvalidMiddlewareException\" exception when middleware does not have \"use\" method","suites":["MiddlewareModule","registerRouteMiddleware"],"updatePoint":{"line":135,"column":102},"line":135,"code":"    it('should throw \"InvalidMiddlewareException\" exception when middleware does not have \"use\" method', () => {\n      @Injectable()\n      class InvalidMiddleware {}\n\n      const route = { path: 'Test' };\n      const configuration = {\n        middleware: [InvalidMiddleware],\n        forRoutes: [BaseController],\n      };\n\n      const useSpy = sinon.spy();\n      const app = { use: useSpy };\n\n      const container = new MiddlewareContainer(nestContainer);\n      const moduleKey = 'Test';\n      container.insertConfig([configuration], moduleKey);\n\n      const instance = new InvalidMiddleware();\n      container.getMiddlewareCollection(moduleKey).set('InvalidMiddleware', {\n        metatype: InvalidMiddleware,\n        instance,\n      } as any);\n\n      expect(\n        middlewareModule.registerRouteMiddleware(\n          container,\n          route as any,\n          configuration,\n          moduleKey,\n          app,\n        ),\n      ).to.be.rejectedWith(InvalidMiddlewareException);\n    });","file":"middleware/middleware-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should mount middleware when is stored in container","suites":["MiddlewareModule","registerRouteMiddleware"],"updatePoint":{"line":169,"column":59},"line":169,"code":"    it('should mount middleware when is stored in container', async () => {\n      const route = 'testPath';\n      const configuration = {\n        middleware: [TestMiddleware],\n        forRoutes: ['test', BasicController, BaseController],\n      };\n\n      const createMiddlewareFactoryStub = sinon\n        .stub()\n        .callsFake(() => () => null);\n      const app = {\n        createMiddlewareFactory: createMiddlewareFactoryStub,\n      };\n\n      const stubContainer = new NestContainer();\n      stubContainer\n        .getModules()\n        .set('Test', new Module(TestModule, stubContainer));\n\n      const container = new MiddlewareContainer(stubContainer);\n      const moduleKey = 'Test';\n      container.insertConfig([configuration], moduleKey);\n\n      const instance = new TestMiddleware();\n      container.getMiddlewareCollection(moduleKey).set(\n        TestMiddleware,\n        new InstanceWrapper({\n          metatype: TestMiddleware,\n          instance,\n        }),\n      );\n      sinon\n        .stub(stubContainer, 'getModuleByKey')\n        .callsFake(() => new Module(class {}, stubContainer));\n      middlewareModule['container'] = stubContainer;\n\n      await middlewareModule.registerRouteMiddleware(\n        container,\n        { path: route, method: RequestMethod.ALL },\n        configuration,\n        moduleKey,\n        app,\n      );\n      expect(createMiddlewareFactoryStub.calledOnce).to.be.true;\n    });","file":"middleware/middleware-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should insert the expected middleware definition","suites":["MiddlewareModule","registerRouteMiddleware"],"updatePoint":{"line":215,"column":56},"line":215,"code":"    it('should insert the expected middleware definition', async () => {\n      const route = 'testPath';\n      const configuration = {\n        middleware: [TestMiddleware],\n        forRoutes: ['test', BasicController, BaseController],\n      };\n      const instance = new TestMiddleware();\n      const instanceWrapper = new InstanceWrapper({\n        metatype: TestMiddleware,\n        instance,\n        name: TestMiddleware.name,\n      });\n      const createMiddlewareFactoryStub = sinon\n        .stub()\n        .callsFake(() => () => null);\n      const app = {\n        createMiddlewareFactory: createMiddlewareFactoryStub,\n      };\n\n      const stubContainer = new NestContainer();\n      stubContainer\n        .getModules()\n        .set('Test', new Module(TestModule, stubContainer));\n      const container = new MiddlewareContainer(stubContainer);\n      const moduleKey = 'Test';\n      container.insertConfig([configuration], moduleKey);\n      container\n        .getMiddlewareCollection(moduleKey)\n        .set(TestMiddleware, instanceWrapper);\n      sinon\n        .stub(stubContainer, 'getModuleByKey')\n        .callsFake(() => new Module(class {}, stubContainer));\n      middlewareModule['container'] = stubContainer;\n\n      const insertEntrypointDefinitionSpy = sinon.spy(\n        graphInspector,\n        'insertEntrypointDefinition',\n      );\n\n      await middlewareModule.registerRouteMiddleware(\n        container,\n        { path: route, method: RequestMethod.ALL },\n        configuration,\n        moduleKey,\n        app,\n      );\n\n      expect(createMiddlewareFactoryStub.calledOnce).to.be.true;\n      expect(\n        insertEntrypointDefinitionSpy.calledWith({\n          type: 'middleware',\n          methodName: 'use',\n          className: instanceWrapper.name,\n          classNodeId: instanceWrapper.id,\n          metadata: {\n            key: route,\n            path: route,\n            requestMethod: 'ALL',\n            version: undefined,\n          } as any,\n        }),\n      ).to.be.true;\n    });","file":"middleware/middleware-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve middleware instances from container","suites":["MiddlewareResolver"],"updatePoint":{"line":27,"column":56},"line":27,"code":"  it('should resolve middleware instances from container', () => {\n    const loadMiddleware = sinon.stub(resolver['injector'], 'loadMiddleware');\n    const middleware = new Map();\n    const wrapper = {\n      instance: { metatype: {} },\n      metatype: TestMiddleware,\n    };\n    middleware.set('TestMiddleware', wrapper);\n\n    const module = { metatype: { name: '' } } as any;\n    mockContainer.expects('getMiddlewareCollection').returns(middleware);\n    resolver.resolveInstances(module, null);\n\n    expect(loadMiddleware.callCount).to.be.equal(middleware.size);\n    expect(loadMiddleware.calledWith(wrapper as any, middleware, module)).to.be\n      .true;\n\n    loadMiddleware.restore();\n  });","file":"middleware/resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct paths","suites":["RouteInfoPathExtractor","extractPathsFrom"],"updatePoint":{"line":20,"column":35},"line":20,"code":"    it(`should return correct paths`, () => {\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql(['/*']);\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql(['/v1/*']);\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct paths when set global prefix","suites":["RouteInfoPathExtractor","extractPathsFrom"],"updatePoint":{"line":37,"column":58},"line":37,"code":"    it(`should return correct paths when set global prefix`, () => {\n      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql(['/api/*']);\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql(['/api/v1/*']);\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct paths when set global prefix and global prefix options","suites":["RouteInfoPathExtractor","extractPathsFrom"],"updatePoint":{"line":56,"column":84},"line":56,"code":"    it(`should return correct paths when set global prefix and global prefix options`, () => {\n      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');\n      Reflect.set(\n        routeInfoPathExtractor,\n        'excludedGlobalPrefixRoutes',\n        mapToExcludeRoute(['foo']),\n      );\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql(['/api/*', '/foo']);\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql(['/api/v1/*', '/v1/foo']);\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: 'foo',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql(['/v1/foo']);\n\n      expect(\n        routeInfoPathExtractor.extractPathsFrom({\n          path: 'bar',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql(['/api/v1/bar']);\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct path","suites":["RouteInfoPathExtractor","extractPathFrom"],"updatePoint":{"line":109,"column":34},"line":109,"code":"    it(`should return correct path`, () => {\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql('/*');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql('/v1/*');\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct path when set global prefix","suites":["RouteInfoPathExtractor","extractPathFrom"],"updatePoint":{"line":126,"column":57},"line":126,"code":"    it(`should return correct path when set global prefix`, () => {\n      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql('/*');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql('/api/v1/*');\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return correct path when set global prefix and global prefix options","suites":["RouteInfoPathExtractor","extractPathFrom"],"updatePoint":{"line":145,"column":83},"line":145,"code":"    it(`should return correct path when set global prefix and global prefix options`, () => {\n      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');\n      Reflect.set(\n        routeInfoPathExtractor,\n        'excludedGlobalPrefixRoutes',\n        mapToExcludeRoute(['foo']),\n      );\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n        }),\n      ).to.eql('/*');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: '*',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql('/api/v1/*');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: 'foo',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql('/v1/foo');\n\n      expect(\n        routeInfoPathExtractor.extractPathFrom({\n          path: 'bar',\n          method: RequestMethod.ALL,\n          version: '1',\n        }),\n      ).to.eql('/api/v1/bar');\n    });","file":"middleware/route-info-path-extractor.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map @Controller() to \"ControllerMetadata\" in forRoutes","suites":["RoutesMapper"],"updatePoint":{"line":35,"column":67},"line":35,"code":"  it('should map @Controller() to \"ControllerMetadata\" in forRoutes', () => {\n    const config: MiddlewareConfiguration = {\n      middleware: 'Test',\n      forRoutes: [\n        { path: 'test', method: RequestMethod.GET },\n        { path: 'versioned', version: '1', method: RequestMethod.GET },\n        TestRoute,\n      ],\n    };\n\n    expect(mapper.mapRouteToRouteInfo(config.forRoutes[0])).to.deep.equal([\n      { path: '/test', method: RequestMethod.GET },\n    ]);\n\n    expect(mapper.mapRouteToRouteInfo(config.forRoutes[1])).to.deep.equal([\n      { path: '/versioned', version: '1', method: RequestMethod.GET },\n    ]);\n\n    expect(mapper.mapRouteToRouteInfo(config.forRoutes[2])).to.deep.equal([\n      { path: '/test/test', method: RequestMethod.GET },\n      { path: '/test/another', method: RequestMethod.DELETE },\n      { path: '/test/versioned', method: RequestMethod.GET, version: '1' },\n    ]);\n  });","file":"middleware/routes-mapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map a controller with multiple paths to \"ControllerMetadata\" in forRoutes","suites":["RoutesMapper"],"updatePoint":{"line":68,"column":86},"line":68,"code":"  it('should map a controller with multiple paths to \"ControllerMetadata\" in forRoutes', () => {\n    const config = {\n      middleware: 'Test',\n      forRoutes: [\n        { path: 'test', method: RequestMethod.GET },\n        TestRouteWithMultiplePaths,\n      ],\n    };\n\n    expect(mapper.mapRouteToRouteInfo(config.forRoutes[0])).to.deep.equal([\n      { path: '/test', method: RequestMethod.GET },\n    ]);\n    expect(mapper.mapRouteToRouteInfo(config.forRoutes[1])).to.deep.equal([\n      { path: '/test/test', method: RequestMethod.GET },\n      { path: '/test/another', method: RequestMethod.DELETE },\n      { path: '/test2/test', method: RequestMethod.GET },\n      { path: '/test2/another', method: RequestMethod.DELETE },\n    ]);\n  });","file":"middleware/routes-mapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map a versioned controller to the corresponding route info objects (single version)","suites":["RoutesMapper"],"updatePoint":{"line":115,"column":96},"line":115,"code":"  it('should map a versioned controller to the corresponding route info objects (single version)', () => {\n    expect(mapper.mapRouteToRouteInfo(VersionedController)).to.deep.equal([\n      { path: '/versioned/', version: '1', method: RequestMethod.GET },\n      { path: '/versioned/override', version: '2', method: RequestMethod.GET },\n    ]);\n  });","file":"middleware/routes-mapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map a versioned controller to the corresponding route info objects (multiple versions)","suites":["RoutesMapper"],"updatePoint":{"line":122,"column":99},"line":122,"code":"  it('should map a versioned controller to the corresponding route info objects (multiple versions)', () => {\n    expect(mapper.mapRouteToRouteInfo(MultipleVersionController)).to.deep.equal(\n      [\n        { path: '/multiple', version: '1', method: RequestMethod.GET },\n        { path: '/multiple', version: '2', method: RequestMethod.GET },\n      ],\n    );\n  });","file":"middleware/routes-mapper.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return exclude route metadata","suites":["middleware utils","mapToExcludeRoute"],"updatePoint":{"line":23,"column":44},"line":23,"code":"    it('should return exclude route metadata', () => {\n      const stringRoute = 'foo';\n      const routeInfo = {\n        path: 'bar',\n        method: RequestMethod.GET,\n      };\n      expect(mapToExcludeRoute([stringRoute, routeInfo])).to.eql([\n        {\n          path: stringRoute,\n          requestMethod: RequestMethod.ALL,\n          pathRegex: pathToRegexp(addLeadingSlash(stringRoute)),\n        },\n        {\n          path: routeInfo.path,\n          requestMethod: routeInfo.method,\n          pathRegex: pathToRegexp(addLeadingSlash(routeInfo.path)),\n        },\n      ]);\n    });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return filtered middleware","suites":["middleware utils","filterMiddleware"],"updatePoint":{"line":48,"column":41},"line":48,"code":"    it('should return filtered middleware', () => {\n      expect(filterMiddleware(middleware, [], noopAdapter)).to.have.length(2);\n    });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an identity","suites":["middleware utils","mapToClass","when middleware is a class","when there is no excluded routes"],"updatePoint":{"line":55,"column":37},"line":55,"code":"        it('should return an identity', () => {\n          const type = mapToClass(Test, [], noopAdapter);\n          expect(type).to.eql(Test);\n        });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a host class","suites":["middleware utils","mapToClass","when middleware is a class","when there are excluded routes"],"updatePoint":{"line":61,"column":38},"line":61,"code":"        it('should return a host class', () => {\n          const type = mapToClass(\n            Test,\n            mapToExcludeRoute([{ path: '*', method: RequestMethod.ALL }]),\n            noopAdapter,\n          );\n          expect(type).to.not.eql(Test);\n          expect(type.name).to.eql(Test.name);\n        });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a metatype","suites":["middleware utils","mapToClass","when middleware is a function"],"updatePoint":{"line":73,"column":34},"line":73,"code":"      it('should return a metatype', () => {\n        const metatype = mapToClass(fnMiddleware, [], noopAdapter);\n        expect(metatype).to.not.eql(fnMiddleware);\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should define a `use` method","suites":["middleware utils","mapToClass","when middleware is a function"],"updatePoint":{"line":77,"column":38},"line":77,"code":"      it('should define a `use` method', () => {\n        const metatype = mapToClass(fnMiddleware, [], noopAdapter) as Type<any>;\n        expect(new metatype().use).to.exist;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should encapsulate a function","suites":["middleware utils","mapToClass","when middleware is a function"],"updatePoint":{"line":81,"column":39},"line":81,"code":"      it('should encapsulate a function', () => {\n        const spy = sinon.spy();\n        const metatype = mapToClass(spy, [], noopAdapter) as Type<any>;\n        new metatype().use();\n        expect(spy.called).to.be.true;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should returns true","suites":["middleware utils","isMiddlewareClass","when middleware is a class"],"updatePoint":{"line":91,"column":29},"line":91,"code":"      it('should returns true', () => {\n        expect(isMiddlewareClass(Test)).to.be.true;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should returns false","suites":["middleware utils","isMiddlewareClass","when middleware is a function"],"updatePoint":{"line":96,"column":30},"line":96,"code":"      it('should returns false', () => {\n        expect(isMiddlewareClass(fnMiddleware)).to.be.false;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["middleware utils","isRouteExcluded","when route is excluded"],"updatePoint":{"line":132,"column":28},"line":132,"code":"      it('should return true', () => {\n        expect(isMiddlewareRouteExcluded({}, excludedRoutes, adapter)).to.be\n          .true;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["middleware utils","isRouteExcluded","when route is not excluded"],"updatePoint":{"line":138,"column":29},"line":138,"code":"      it('should return false', () => {\n        expect(isMiddlewareRouteExcluded({}, [], adapter)).to.be.false;\n      });","file":"middleware/utils.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"shutdown process should not be interrupted by another handler","suites":["NestApplicationContext","listenToShutdownSignals"],"updatePoint":{"line":54,"column":69},"line":54,"code":"    it('shutdown process should not be interrupted by another handler', async () => {\n      const signal = 'SIGTERM';\n      let processUp = true;\n      let promisesResolved = false;\n      const applicationContext = await testHelper(A, Scope.DEFAULT);\n      applicationContext.enableShutdownHooks([signal]);\n\n      const waitProcessDown = new Promise(resolve => {\n        const shutdownCleanupRef = applicationContext['shutdownCleanupRef'];\n        const handler = () => {\n          if (\n            !process\n              .listeners(signal)\n              .find(handler => handler == shutdownCleanupRef)\n          ) {\n            processUp = false;\n            process.removeListener(signal, handler);\n            resolve(undefined);\n          }\n          return undefined;\n        };\n        process.on(signal, handler);\n      });\n\n      // add some third party handler\n      process.on(signal, signal => {\n        // do some work\n        process.kill(process.pid, signal);\n      });\n\n      const hookStub = sinon\n        .stub(applicationContext as any, 'callShutdownHook')\n        .callsFake(async () => {\n          // run some async code\n          await new Promise(resolve => setImmediate(() => resolve(undefined)));\n          if (processUp) {\n            promisesResolved = true;\n          }\n        });\n      process.kill(process.pid, signal);\n      await waitProcessDown;\n      hookStub.restore();\n      expect(processUp).to.be.false;\n      expect(promisesResolved).to.be.true;\n    });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should get value with function injection key","suites":["NestApplicationContext","get","when scope = DEFAULT"],"updatePoint":{"line":103,"column":54},"line":103,"code":"      it('should get value with function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.get(key);\n        const a2: A = await applicationContext.get(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should get value with string injection key","suites":["NestApplicationContext","get","when scope = DEFAULT"],"updatePoint":{"line":115,"column":52},"line":115,"code":"      it('should get value with string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.get(key);\n        const a2: A = await applicationContext.get(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should get value with symbol injection key","suites":["NestApplicationContext","get","when scope = DEFAULT"],"updatePoint":{"line":127,"column":52},"line":127,"code":"      it('should get value with symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.get(key);\n        const a2: A = await applicationContext.get(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use function injection key","suites":["NestApplicationContext","get","when scope = REQUEST"],"updatePoint":{"line":141,"column":60},"line":141,"code":"      it('should throw error when use function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use string injection key","suites":["NestApplicationContext","get","when scope = REQUEST"],"updatePoint":{"line":148,"column":58},"line":148,"code":"      it('should throw error when use string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use symbol injection key","suites":["NestApplicationContext","get","when scope = REQUEST"],"updatePoint":{"line":155,"column":58},"line":155,"code":"      it('should throw error when use symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use function injection key","suites":["NestApplicationContext","get","when scope = TRANSIENT"],"updatePoint":{"line":164,"column":60},"line":164,"code":"      it('should throw error when use function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use string injection key","suites":["NestApplicationContext","get","when scope = TRANSIENT"],"updatePoint":{"line":171,"column":58},"line":171,"code":"      it('should throw error when use string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw error when use symbol injection key","suites":["NestApplicationContext","get","when scope = TRANSIENT"],"updatePoint":{"line":178,"column":58},"line":178,"code":"      it('should throw error when use symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        expect(() => applicationContext.get(key)).to.be.throw;\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with function injection key","suites":["NestApplicationContext","resolve","when scope = DEFAULT"],"updatePoint":{"line":189,"column":58},"line":189,"code":"      it('should resolve value with function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with string injection key","suites":["NestApplicationContext","resolve","when scope = DEFAULT"],"updatePoint":{"line":201,"column":56},"line":201,"code":"      it('should resolve value with string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with symbol injection key","suites":["NestApplicationContext","resolve","when scope = DEFAULT"],"updatePoint":{"line":213,"column":56},"line":213,"code":"      it('should resolve value with symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.DEFAULT);\n\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).equal(a2);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with function injection key","suites":["NestApplicationContext","resolve","when scope = REQUEST"],"updatePoint":{"line":227,"column":58},"line":227,"code":"      it('should resolve value with function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with string injection key","suites":["NestApplicationContext","resolve","when scope = REQUEST"],"updatePoint":{"line":242,"column":56},"line":242,"code":"      it('should resolve value with string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with symbol injection key","suites":["NestApplicationContext","resolve","when scope = REQUEST"],"updatePoint":{"line":257,"column":56},"line":257,"code":"      it('should resolve value with symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.REQUEST);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with function injection key","suites":["NestApplicationContext","resolve","when scope = TRANSIENT"],"updatePoint":{"line":274,"column":58},"line":274,"code":"      it('should resolve value with function injection key', async () => {\n        const key = A;\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with string injection key","suites":["NestApplicationContext","resolve","when scope = TRANSIENT"],"updatePoint":{"line":289,"column":56},"line":289,"code":"      it('should resolve value with string injection key', async () => {\n        const key = 'KEY_A';\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should resolve value with symbol injection key","suites":["NestApplicationContext","resolve","when scope = TRANSIENT"],"updatePoint":{"line":304,"column":56},"line":304,"code":"      it('should resolve value with symbol injection key', async () => {\n        const key = Symbol('KEY_A');\n        const applicationContext = await testHelper(key, Scope.TRANSIENT);\n\n        const contextId = ContextIdFactory.create();\n        const a1: A = await applicationContext.resolve(key);\n        const a2: A = await applicationContext.resolve(key, contextId);\n        const a3: A = await applicationContext.resolve(key, contextId);\n\n        expect(a1).instanceOf(A);\n        expect(a2).instanceOf(A);\n        expect(a1).not.equal(a2);\n        expect(a2).equal(a3);\n      });","file":"nest-application-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"default should use new ApplicationConfig","suites":["NestApplication","Hybrid Application"],"updatePoint":{"line":19,"column":48},"line":19,"code":"    it('default should use new ApplicationConfig', () => {\n      const applicationConfig = new ApplicationConfig();\n      const container = new NestContainer(applicationConfig);\n      const instance = new NestApplication(\n        container,\n        new NoopHttpAdapter({}),\n        applicationConfig,\n        new GraphInspector(container),\n        {},\n      );\n      instance.useGlobalInterceptors(new Interceptor());\n      const microservice = instance.connectMicroservice<MicroserviceOptions>(\n        {},\n      );\n      expect((instance as any).config.getGlobalInterceptors().length).to.equal(\n        1,\n      );\n      expect(\n        (microservice as any).applicationConfig.getGlobalInterceptors().length,\n      ).to.equal(0);\n    });","file":"nest-application.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should inherit existing ApplicationConfig","suites":["NestApplication","Hybrid Application"],"updatePoint":{"line":40,"column":49},"line":40,"code":"    it('should inherit existing ApplicationConfig', () => {\n      const applicationConfig = new ApplicationConfig();\n      const container = new NestContainer(applicationConfig);\n      const instance = new NestApplication(\n        container,\n        new NoopHttpAdapter({}),\n        applicationConfig,\n        new GraphInspector(container),\n        {},\n      );\n      instance.useGlobalInterceptors(new Interceptor());\n      const microservice = instance.connectMicroservice<MicroserviceOptions>(\n        {},\n        { inheritAppConfig: true },\n      );\n      expect((instance as any).config.getGlobalInterceptors().length).to.equal(\n        1,\n      );\n      expect(\n        (microservice as any).applicationConfig.getGlobalInterceptors().length,\n      ).to.equal(1);\n    });","file":"nest-application.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should get correct global prefix options","suites":["NestApplication","Global Prefix"],"updatePoint":{"line":64,"column":48},"line":64,"code":"    it('should get correct global prefix options', () => {\n      const applicationConfig = new ApplicationConfig();\n      const container = new NestContainer(applicationConfig);\n      const instance = new NestApplication(\n        container,\n        new NoopHttpAdapter({}),\n        applicationConfig,\n        new GraphInspector(container),\n        {},\n      );\n      const excludeRoute = ['foo', { path: 'bar', method: RequestMethod.GET }];\n      instance.setGlobalPrefix('api', {\n        exclude: excludeRoute,\n      });\n      expect(applicationConfig.getGlobalPrefixOptions()).to.eql({\n        exclude: mapToExcludeRoute(excludeRoute),\n      });\n    });","file":"nest-application.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should initialize application only once","suites":["NestApplication","Double initialization"],"updatePoint":{"line":84,"column":47},"line":84,"code":"    it('should initialize application only once', async () => {\n      const noopHttpAdapter = new NoopHttpAdapter({});\n      const httpAdapterSpy = sinon.spy(noopHttpAdapter);\n\n      const applicationConfig = new ApplicationConfig();\n\n      const container = new NestContainer(applicationConfig);\n      container.setHttpAdapter(noopHttpAdapter);\n\n      const instance = new NestApplication(\n        container,\n        noopHttpAdapter,\n        applicationConfig,\n        new GraphInspector(container),\n        {},\n      );\n\n      await instance.init();\n      await instance.init();\n\n      expect(httpAdapterSpy.init.calledOnce).to.be.true;\n    });","file":"nest-application.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return body object","suites":["ParamsTokenFactory","exchangeEnumForString","when key is","RouteParamtypes.BODY"],"updatePoint":{"line":13,"column":37},"line":13,"code":"        it('should return body object', () => {\n          expect(factory.exchangeEnumForString(RouteParamtypes.BODY)).to.be.eql(\n            'body',\n          );\n        });","file":"pipes/params-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return query object","suites":["ParamsTokenFactory","exchangeEnumForString","when key is","RouteParamtypes.QUERY"],"updatePoint":{"line":20,"column":38},"line":20,"code":"        it('should return query object', () => {\n          expect(\n            factory.exchangeEnumForString(RouteParamtypes.QUERY),\n          ).to.be.eql('query');\n        });","file":"pipes/params-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return params object","suites":["ParamsTokenFactory","exchangeEnumForString","when key is","RouteParamtypes.PARAM"],"updatePoint":{"line":27,"column":39},"line":27,"code":"        it('should return params object', () => {\n          expect(\n            factory.exchangeEnumForString(RouteParamtypes.PARAM),\n          ).to.be.eql('param');\n        });","file":"pipes/params-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return \"custom\"","suites":["ParamsTokenFactory","exchangeEnumForString","when key is","not available"],"updatePoint":{"line":34,"column":34},"line":34,"code":"        it('should return \"custom\"', () => {\n          expect(factory.exchangeEnumForString(-1 as any)).to.be.eql('custom');\n        });","file":"pipes/params-token-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call all transform functions","suites":["PipesConsumer","apply"],"updatePoint":{"line":26,"column":43},"line":26,"code":"    it('should call all transform functions', done => {\n      consumer.apply(value, { metatype, type, data }, transforms).then(() => {\n        expect(\n          transforms.reduce(\n            (prev, next) => prev && next.transform.called,\n            true,\n          ),\n        ).to.be.true;\n        done();\n      });\n    });","file":"pipes/pipes-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected result","suites":["PipesConsumer","apply"],"updatePoint":{"line":37,"column":37},"line":37,"code":"    it('should return expected result', done => {\n      const expectedResult = 3;\n      consumer\n        .apply(value, { metatype, type, data }, transforms)\n        .then(result => {\n          expect(result).to.be.eql(expectedResult);\n          done();\n        });\n    });","file":"pipes/pipes-consumer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty array","suites":["PipesContextCreator","createConcreteContext","when metadata is empty or undefined"],"updatePoint":{"line":22,"column":35},"line":22,"code":"      it('should return empty array', () => {\n        expect(creator.createConcreteContext(undefined)).to.be.deep.equal([]);\n        expect(creator.createConcreteContext([])).to.be.deep.equal([]);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected array","suites":["PipesContextCreator","createConcreteContext","when metadata is not empty or undefined"],"updatePoint":{"line":29,"column":38},"line":29,"code":"      it('should return expected array', () => {\n        const transforms = creator.createConcreteContext(metadata as any);\n        expect(transforms).to.have.length(1);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["PipesContextCreator","getPipeInstance","when param is an object"],"updatePoint":{"line":37,"column":32},"line":37,"code":"      it('should return instance', () => {\n        const instance = { transform: () => null };\n        expect(creator.getPipeInstance(instance)).to.be.eql(instance);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pick instance from container","suites":["PipesContextCreator","getPipeInstance","when param is a constructor"],"updatePoint":{"line":43,"column":45},"line":43,"code":"      it('should pick instance from container', () => {\n        const wrapper: InstanceWrapper = {\n          instance: 'test',\n          getInstanceByContextId: () => wrapper,\n        } as any;\n        sinon.stub(creator, 'getInstanceByMetatype').callsFake(() => wrapper);\n        expect(creator.getPipeInstance(Pipe)).to.be.eql(wrapper.instance);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["PipesContextCreator","getPipeInstance","when param is a constructor"],"updatePoint":{"line":51,"column":28},"line":51,"code":"      it('should return null', () => {\n        sinon.stub(creator, 'getInstanceByMetatype').callsFake(() => null);\n        expect(creator.getPipeInstance(Pipe)).to.be.eql(null);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["PipesContextCreator","getInstanceByMetatype","when \"moduleContext\" is nil"],"updatePoint":{"line":60,"column":33},"line":60,"code":"      it('should return undefined', () => {\n        (creator as any).moduleContext = undefined;\n        expect(creator.getInstanceByMetatype(null)).to.be.undefined;\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["PipesContextCreator","getInstanceByMetatype","when \"moduleContext\" is not nil","and when module exists"],"updatePoint":{"line":71,"column":35},"line":71,"code":"        it('should return undefined', () => {\n          sinon.stub(container.getModules(), 'get').callsFake(() => undefined);\n          expect(creator.getInstanceByMetatype(null)).to.be.undefined;\n        });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return instance","suites":["PipesContextCreator","getInstanceByMetatype","when \"moduleContext\" is not nil","and when module does not exist"],"updatePoint":{"line":78,"column":34},"line":78,"code":"        it('should return instance', () => {\n          const instance = { test: true };\n          const module = { injectables: { get: () => instance } };\n          sinon\n            .stub(container.getModules(), 'get')\n            .callsFake(() => module as any);\n          expect(creator.getInstanceByMetatype(class Test {})).to.be.eql(\n            instance,\n          );\n        });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return global pipes","suites":["PipesContextCreator","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":94,"column":36},"line":94,"code":"      it('should return global pipes', () => {\n        const expectedResult = applicationConfig.getGlobalPipes();\n        expect(creator.getGlobalMetadata()).to.be.equal(expectedResult);\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should merge static global with request/transient scoped pipes","suites":["PipesContextCreator","getGlobalMetadata","otherwise"],"updatePoint":{"line":100,"column":72},"line":100,"code":"      it('should merge static global with request/transient scoped pipes', () => {\n        const globalPipes: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedPipeWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalPipes')\n          .callsFake(() => globalPipes);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestPipes')\n          .callsFake(() => scopedPipeWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(creator.getGlobalMetadata({ id: 3 })).to.contains(\n          instance,\n          ...globalPipes,\n        );\n      });","file":"pipes/pipes-context-creator.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should copy all enumerable properties and their descriptors","suites":["assignToObject"],"updatePoint":{"line":5,"column":65},"line":5,"code":"  it('should copy all enumerable properties and their descriptors', () => {\n    const sourceObj = {};\n    Object.defineProperty(sourceObj, 'foo', {\n      value: 123,\n      configurable: true,\n      enumerable: true,\n      writable: true,\n    });\n    Object.defineProperty(sourceObj, 'bar', {\n      value: 456,\n      configurable: true,\n      enumerable: true,\n      writable: false,\n    });\n    const targetObj = {};\n\n    assignToObject(targetObj, sourceObj);\n\n    expect(Object.getOwnPropertyDescriptor(targetObj, 'foo')).to.be.eql({\n      value: 123,\n      configurable: true,\n      enumerable: true,\n      writable: true,\n    });\n    expect(Object.getOwnPropertyDescriptor(targetObj, 'bar')).to.be.eql({\n      value: 456,\n      configurable: true,\n      enumerable: true,\n      writable: false,\n    });\n  });","file":"repl/assign-to-object.util.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"debug\"","suites":["DebugReplFn"],"updatePoint":{"line":61,"column":41},"line":61,"code":"  it('the function name should be \"debug\"', () => {\n    expect(debugReplFn).to.not.be.undefined;\n    expect(debugReplFn.fnDefinition.name).to.eql('debug');\n  });","file":"repl/native-functions/debug-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should print all modules along with their controllers and providers","suites":["DebugReplFn","action"],"updatePoint":{"line":67,"column":75},"line":67,"code":"    it('should print all modules along with their controllers and providers', () => {\n      let outputText = '';\n\n      sinon\n        .stub(replContext, 'writeToStdout')\n        .callsFake(text => (outputText += text));\n\n      debugReplFn.action();\n\n      expect(outputText).to.equal(`\nModuleA:\n - controllers:\n  ◻ ControllerA\n - providers:\n  ◻ ProviderA1\n  ◻ ProviderA2\n  ◻ SharedProvider\n  ◻ \"StringToken\"\nModuleB:\n - providers:\n  ◻ ProviderB1\n  ◻ ProviderB2\n  ◻ SharedProvider\n\n`);\n    });","file":"repl/native-functions/debug-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should print a specified module's controllers and providers","suites":["DebugReplFn","action","when module passed as a class reference"],"updatePoint":{"line":95,"column":69},"line":95,"code":"      it(\"should print a specified module's controllers and providers\", () => {\n        let outputText = '';\n\n        sinon\n          .stub(replContext, 'writeToStdout')\n          .callsFake(text => (outputText += text));\n\n        debugReplFn.action(class ModuleA {});\n\n        expect(outputText).to.equal(`\nModuleA:\n - controllers:\n  ◻ ControllerA\n - providers:\n  ◻ ProviderA1\n  ◻ ProviderA2\n  ◻ SharedProvider\n  ◻ \"StringToken\"\n\n`);\n      });","file":"repl/native-functions/debug-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should print a specified module's controllers and providers","suites":["DebugReplFn","action","when module passed as a string (module's key)"],"updatePoint":{"line":118,"column":69},"line":118,"code":"      it(\"should print a specified module's controllers and providers\", () => {\n        let outputText = '';\n\n        sinon\n          .stub(replContext, 'writeToStdout')\n          .callsFake(text => (outputText += text));\n\n        debugReplFn.action('ModuleA');\n\n        expect(outputText).to.equal(`\nModuleA:\n - controllers:\n  ◻ ControllerA\n - providers:\n  ◻ ProviderA1\n  ◻ ProviderA2\n  ◻ SharedProvider\n  ◻ \"StringToken\"\n\n`);\n      });","file":"repl/native-functions/debug-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"get\"","suites":["GetReplFn"],"updatePoint":{"line":35,"column":39},"line":35,"code":"  it('the function name should be \"get\"', () => {\n    expect(getReplFn).to.not.be.undefined;\n    expect(getReplFn.fnDefinition.name).to.eql('get');\n  });","file":"repl/native-functions/get-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pass arguments down to the application context","suites":["GetReplFn","action"],"updatePoint":{"line":41,"column":61},"line":41,"code":"    it('should pass arguments down to the application context', () => {\n      const token = 'test';\n      getReplFn.action(token);\n      expect(mockApp.get.calledWith(token)).to.be.true;\n    });","file":"repl/native-functions/get-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"help\"","suites":["HelpReplFn"],"updatePoint":{"line":40,"column":40},"line":40,"code":"  it('the function name should be \"help\"', () => {\n    expect(helpReplFn).to.not.be.undefined;\n    expect(helpReplFn.fnDefinition.name).to.eql('help');\n  });","file":"repl/native-functions/help-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should print all available native functions and their description","suites":["HelpReplFn","action"],"updatePoint":{"line":46,"column":73},"line":46,"code":"    it('should print all available native functions and their description', () => {\n      let outputText = '';\n      sinon\n        .stub(replContext, 'writeToStdout')\n        .callsFake(text => (outputText += text));\n\n      helpReplFn.action();\n\n      expect(outputText).to\n        .equal(`You can call .help on any function listed below (e.g.: help.help):\n\n$ - Retrieves an instance of either injectable or controller, otherwise, throws exception.\ndebug - Print all registered modules as a list together with their controllers and providers.\nIf the argument is passed in, for example, \"debug(MyModule)\" then it will only print components of this specific module.\nget - Retrieves an instance of either injectable or controller, otherwise, throws exception.\nhelp - Display all available REPL native functions.\nmethods - Display all public methods available on a given provider or controller.\nresolve - Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\nselect - Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.\n`);\n    });","file":"repl/native-functions/help-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"methods\"","suites":["MethodsReplFn"],"updatePoint":{"line":55,"column":43},"line":55,"code":"  it('the function name should be \"methods\"', () => {\n    expect(methodsReplFn).to.not.be.undefined;\n    expect(methodsReplFn.fnDefinition.name).to.eql('methods');\n  });","file":"repl/native-functions/methods-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should print all class methods","suites":["MethodsReplFn","action","when token is a class reference"],"updatePoint":{"line":62,"column":40},"line":62,"code":"      it('should print all class methods', () => {\n        class BaseService {\n          create() {}\n        }\n        class TestService extends BaseService {\n          findAll() {}\n          findOne() {}\n        }\n\n        let outputText = '';\n\n        sinon\n          .stub(replContext, 'writeToStdout')\n          .callsFake(text => (outputText += text));\n\n        methodsReplFn.action(TestService);\n\n        expect(outputText).to.equal(`\nMethods:\n ◻ findAll\n ◻ findOne\n ◻ create\n\n`);\n      });","file":"repl/native-functions/methods-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should grab provider from the container and print its all methods","suites":["MethodsReplFn","action","when token is a string"],"updatePoint":{"line":90,"column":75},"line":90,"code":"      it('should grab provider from the container and print its all methods', () => {\n        class ProviderA1 {\n          findAll() {}\n          findOne() {}\n        }\n        let outputText = '';\n\n        sinon\n          .stub(replContext, 'writeToStdout')\n          .callsFake(text => (outputText += text));\n\n        mockApp.get.callsFake(() => new ProviderA1());\n\n        methodsReplFn.action('ProviderA1');\n\n        expect(outputText).to.equal(`\nMethods:\n ◻ findAll\n ◻ findOne\n\n`);\n      });","file":"repl/native-functions/methods-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"resolve\"","suites":["ResolveReplFn"],"updatePoint":{"line":35,"column":43},"line":35,"code":"  it('the function name should be \"resolve\"', () => {\n    expect(resolveReplFn).to.not.be.undefined;\n    expect(resolveReplFn.fnDefinition.name).to.eql('resolve');\n  });","file":"repl/native-functions/resolve-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pass arguments down to the application context","suites":["ResolveReplFn","action"],"updatePoint":{"line":41,"column":61},"line":41,"code":"    it('should pass arguments down to the application context', async () => {\n      const token = 'test';\n      const contextId = {};\n\n      await resolveReplFn.action(token, contextId);\n      expect(mockApp.resolve.calledWith(token, contextId)).to.be.true;\n    });","file":"repl/native-functions/resolve-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"the function name should be \"select\"","suites":["SelectReplFn"],"updatePoint":{"line":35,"column":42},"line":35,"code":"  it('the function name should be \"select\"', () => {\n    expect(selectReplFn).to.not.be.undefined;\n    expect(selectReplFn.fnDefinition.name).to.eql('select');\n  });","file":"repl/native-functions/select-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pass arguments down to the application context","suites":["SelectReplFn","action"],"updatePoint":{"line":41,"column":61},"line":41,"code":"    it('should pass arguments down to the application context', () => {\n      const moduleCls = class TestModule {};\n      selectReplFn.action(moduleCls);\n      expect(mockApp.select.calledWith(moduleCls)).to.be.true;\n    });","file":"repl/native-functions/select-repl-fn.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"writeToStdout","suites":["ReplContext"],"updatePoint":{"line":29,"column":19},"line":29,"code":"  it('writeToStdout', () => {\n    const stdOutWrite = sinon.stub(process.stdout, 'write');\n    const text = sinon.stub() as unknown as string;\n\n    replContext.writeToStdout(text);\n\n    expect(stdOutWrite.calledOnce).to.be.true;\n    expect(stdOutWrite.calledWith(text)).to.be.true;\n  });","file":"repl/repl-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected list of route paths","suites":["PathsExplorer","scanForPaths"],"updatePoint":{"line":50,"column":57},"line":50,"code":"    it('should method return expected list of route paths', () => {\n      const paths = pathsExplorer.scanForPaths(new TestRoute());\n\n      expect(paths).to.have.length(4);\n\n      expect(paths[0].path).to.eql(['/test']);\n      expect(paths[1].path).to.eql(['/test']);\n      expect(paths[2].path).to.eql(['/another-test']);\n      expect(paths[3].path).to.eql(['/foo', '/bar']);\n\n      expect(paths[0].requestMethod).to.eql(RequestMethod.GET);\n      expect(paths[1].requestMethod).to.eql(RequestMethod.POST);\n      expect(paths[2].requestMethod).to.eql(RequestMethod.ALL);\n      expect(paths[3].requestMethod).to.eql(RequestMethod.GET);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected list of route paths alias","suites":["PathsExplorer","scanForPaths"],"updatePoint":{"line":66,"column":63},"line":66,"code":"    it('should method return expected list of route paths alias', () => {\n      const paths = pathsExplorer.scanForPaths(new TestRouteAlias());\n\n      expect(paths).to.have.length(4);\n\n      expect(paths[0].path).to.eql(['/test']);\n      expect(paths[1].path).to.eql(['/test']);\n      expect(paths[2].path).to.eql(['/another-test']);\n      expect(paths[3].path).to.eql(['/foo', '/bar']);\n\n      expect(paths[0].requestMethod).to.eql(RequestMethod.GET);\n      expect(paths[1].requestMethod).to.eql(RequestMethod.POST);\n      expect(paths[2].requestMethod).to.eql(RequestMethod.ALL);\n      expect(paths[3].requestMethod).to.eql(RequestMethod.GET);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represent single route","suites":["PathsExplorer","exploreMethodMetadata"],"updatePoint":{"line":84,"column":73},"line":84,"code":"    it('should method return expected object which represent single route', () => {\n      const instance = new TestRoute();\n      const instanceProto = Object.getPrototypeOf(instance);\n\n      const route = pathsExplorer.exploreMethodMetadata(\n        instance,\n        instanceProto,\n        'getTest',\n      );\n\n      expect(route.path).to.eql(['/test']);\n      expect(route.requestMethod).to.eql(RequestMethod.GET);\n      expect(route.targetCallback).to.eq(instance.getTest);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represent single route with alias","suites":["PathsExplorer","exploreMethodMetadata"],"updatePoint":{"line":99,"column":84},"line":99,"code":"    it('should method return expected object which represent single route with alias', () => {\n      const instance = new TestRouteAlias();\n      const instanceProto = Object.getPrototypeOf(instance);\n\n      const route = pathsExplorer.exploreMethodMetadata(\n        instance,\n        instanceProto,\n        'getTest',\n      );\n\n      expect(route.path).to.eql(['/test']);\n      expect(route.requestMethod).to.eql(RequestMethod.GET);\n      expect(route.targetCallback).to.eq(instance.getTest);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represent multiple routes","suites":["PathsExplorer","exploreMethodMetadata"],"updatePoint":{"line":114,"column":76},"line":114,"code":"    it('should method return expected object which represent multiple routes', () => {\n      const instance = new TestRoute();\n      const instanceProto = Object.getPrototypeOf(instance);\n\n      const route = pathsExplorer.exploreMethodMetadata(\n        instance,\n        instanceProto,\n        'getTestUsingArray',\n      );\n\n      expect(route.path).to.eql(['/foo', '/bar']);\n      expect(route.requestMethod).to.eql(RequestMethod.GET);\n      expect(route.targetCallback).to.eq(instance.getTestUsingArray);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represent multiple routes with alias","suites":["PathsExplorer","exploreMethodMetadata"],"updatePoint":{"line":129,"column":87},"line":129,"code":"    it('should method return expected object which represent multiple routes with alias', () => {\n      const instance = new TestRouteAlias();\n      const instanceProto = Object.getPrototypeOf(instance);\n\n      const route = pathsExplorer.exploreMethodMetadata(\n        instance,\n        instanceProto,\n        'getTestUsingArray',\n      );\n\n      expect(route.path).to.eql(['/foo', '/bar']);\n      expect(route.requestMethod).to.eql(RequestMethod.GET);\n      expect(route.targetCallback).to.eq(instance.getTestUsingArray);\n    });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return changed impl of single route","suites":["PathsExplorer","exploreMethodMetadata","when new implementation is injected into router"],"updatePoint":{"line":145,"column":59},"line":145,"code":"      it('should method return changed impl of single route', () => {\n        const instance = new TestRoute();\n        const instanceProto = Object.getPrototypeOf(instance);\n\n        const newImpl = function () {};\n        instance.getTest = newImpl;\n\n        const route = pathsExplorer.exploreMethodMetadata(\n          instance,\n          instanceProto,\n          'getTest',\n        );\n\n        expect(route.targetCallback).to.eq(newImpl);\n        expect(route.path).to.eql(['/test']);\n        expect(route.requestMethod).to.eql(RequestMethod.GET);\n      });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return changed impl of single route which alias applied","suites":["PathsExplorer","exploreMethodMetadata","when new implementation is injected into router"],"updatePoint":{"line":163,"column":79},"line":163,"code":"      it('should method return changed impl of single route which alias applied', () => {\n        const instance = new TestRouteAlias();\n        const instanceProto = Object.getPrototypeOf(instance);\n\n        const newImpl = function () {};\n        instance.getTest = newImpl;\n\n        const route = pathsExplorer.exploreMethodMetadata(\n          instance,\n          instanceProto,\n          'getTest',\n        );\n\n        expect(route.targetCallback).to.eq(newImpl);\n        expect(route.path).to.eql(['/test']);\n        expect(route.requestMethod).to.eql(RequestMethod.GET);\n      });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return changed impl of multiple routes","suites":["PathsExplorer","exploreMethodMetadata","when new implementation is injected into router"],"updatePoint":{"line":181,"column":62},"line":181,"code":"      it('should method return changed impl of multiple routes', () => {\n        const instance = new TestRoute();\n        const instanceProto = Object.getPrototypeOf(instance);\n\n        const newImpl = function () {};\n        instance.getTestUsingArray = newImpl;\n\n        const route = pathsExplorer.exploreMethodMetadata(\n          instance,\n          instanceProto,\n          'getTestUsingArray',\n        );\n\n        expect(route.targetCallback).to.eq(newImpl);\n        expect(route.path).to.eql(['/foo', '/bar']);\n        expect(route.requestMethod).to.eql(RequestMethod.GET);\n      });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return changed impl of multiple routes which alias applied","suites":["PathsExplorer","exploreMethodMetadata","when new implementation is injected into router"],"updatePoint":{"line":199,"column":82},"line":199,"code":"      it('should method return changed impl of multiple routes which alias applied', () => {\n        const instance = new TestRouteAlias();\n        const instanceProto = Object.getPrototypeOf(instance);\n\n        const newImpl = function () {};\n        instance.getTestUsingArray = newImpl;\n\n        const route = pathsExplorer.exploreMethodMetadata(\n          instance,\n          instanceProto,\n          'getTestUsingArray',\n        );\n\n        expect(route.targetCallback).to.eq(newImpl);\n        expect(route.path).to.eql(['/foo', '/bar']);\n        expect(route.requestMethod).to.eql(RequestMethod.GET);\n      });","file":"router/paths-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return next object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.NEXT"],"updatePoint":{"line":37,"column":37},"line":37,"code":"        it('should return next object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(RouteParamtypes.NEXT, ...args),\n          ).to.be.eql(next);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return response object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.RESPONSE"],"updatePoint":{"line":44,"column":41},"line":44,"code":"        it('should return response object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.RESPONSE,\n              ...args,\n            ),\n          ).to.be.eql(res);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return request object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.REQUEST"],"updatePoint":{"line":54,"column":40},"line":54,"code":"        it('should return request object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.REQUEST,\n              ...args,\n            ),\n          ).to.be.eql(req);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return body object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.BODY"],"updatePoint":{"line":64,"column":37},"line":64,"code":"        it('should return body object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(RouteParamtypes.BODY, ...args),\n          ).to.be.eql(req.body);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return headers object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.HEADERS"],"updatePoint":{"line":71,"column":40},"line":71,"code":"        it('should return headers object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.HEADERS,\n              ...args,\n            ),\n          ).to.be.eql(req.headers);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ip property","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.IP"],"updatePoint":{"line":81,"column":37},"line":81,"code":"        it('should return ip property', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(RouteParamtypes.IP, ...args),\n          ).to.be.equal(req.ip);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return session object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.SESSION"],"updatePoint":{"line":88,"column":40},"line":88,"code":"        it('should return session object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.SESSION,\n              ...args,\n            ),\n          ).to.be.eql(req.session);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return query object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.QUERY"],"updatePoint":{"line":98,"column":38},"line":98,"code":"        it('should return query object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.QUERY,\n              ...args,\n            ),\n          ).to.be.eql(req.query);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return params object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.PARAM"],"updatePoint":{"line":108,"column":39},"line":108,"code":"        it('should return params object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.PARAM,\n              ...args,\n            ),\n          ).to.be.eql(req.params);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return hosts object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.HOST"],"updatePoint":{"line":118,"column":38},"line":118,"code":"        it('should return hosts object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(RouteParamtypes.HOST, ...args),\n          ).to.be.eql(req.hosts);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return file object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.FILE"],"updatePoint":{"line":125,"column":37},"line":125,"code":"        it('should return file object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(RouteParamtypes.FILE, ...args),\n          ).to.be.eql(req.file);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return files object","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","RouteParamtypes.FILES"],"updatePoint":{"line":132,"column":38},"line":132,"code":"        it('should return files object', () => {\n          expect(\n            (factory as any).exchangeKeyForValue(\n              RouteParamtypes.FILES,\n              ...args,\n            ),\n          ).to.be.eql(req.files);\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return null","suites":["RouteParamsFactory","exchangeKeyForValue","when key is","not available"],"updatePoint":{"line":142,"column":30},"line":142,"code":"        it('should return null', () => {\n          expect((factory as any).exchangeKeyForValue(-1, ...args)).to.be.eql(\n            null,\n          );\n        });","file":"router/route-params-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return valid, concatenated paths (various combinations)","suites":["RoutePathFactory","create"],"updatePoint":{"line":18,"column":70},"line":18,"code":"    it('should return valid, concatenated paths (various combinations)', () => {\n      expect(\n        routePathFactory.create({\n          ctrlPath: 'ctrlPath/',\n          methodPath: '',\n        }),\n      ).to.deep.equal(['/ctrlPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath',\n          methodPath: '',\n        }),\n      ).to.deep.equal(['/ctrlPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath',\n        }),\n      ).to.deep.equal(['/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: 'ctrlPath/',\n          methodPath: 'methodPath/',\n        }),\n      ).to.deep.equal(['/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: 'ctrlPath/',\n          methodPath: 'methodPath',\n          modulePath: 'modulePath',\n        }),\n      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: 'ctrlPath/',\n          methodPath: 'methodPath',\n          modulePath: '/modulePath',\n        }),\n      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n        }),\n      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n          globalPrefix: 'api',\n        }),\n      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n          globalPrefix: '/api',\n        }),\n      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n          globalPrefix: '/api',\n          versioningOptions: {\n            type: VersioningType.HEADER,\n            header: 'x',\n          },\n          methodVersion: '1.0.0',\n          controllerVersion: '1.1.1',\n        }),\n      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n          globalPrefix: '/api/',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          methodVersion: '1.0.0',\n          controllerVersion: '1.1.1',\n        }),\n      ).to.deep.equal(['/api/v1.0.0/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          modulePath: '/modulePath/',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          methodVersion: '1.0.0',\n          controllerVersion: '1.1.1',\n        }),\n      ).to.deep.equal(['/v1.0.0/modulePath/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          globalPrefix: '/api',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          methodVersion: '1.0.0',\n          controllerVersion: '1.1.1',\n        }),\n      ).to.deep.equal(['/api/v1.0.0/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          globalPrefix: '/api',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          controllerVersion: '1.1.1',\n        }),\n      ).to.deep.equal(['/api/v1.1.1/ctrlPath/methodPath']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/methodPath/',\n          globalPrefix: '/api',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          controllerVersion: ['1.1.1', '1.2.3'],\n        }),\n      ).to.deep.equal([\n        '/api/v1.1.1/ctrlPath/methodPath',\n        '/api/v1.2.3/ctrlPath/methodPath',\n      ]);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '',\n          methodPath: '',\n          globalPrefix: '/api',\n          versioningOptions: {\n            type: VersioningType.URI,\n          },\n          controllerVersion: ['1.1.1', '1.2.3'],\n        }),\n      ).to.deep.equal(['/api/v1.1.1', '/api/v1.2.3']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '',\n          methodPath: '',\n          globalPrefix: '',\n          controllerVersion: VERSION_NEUTRAL,\n          versioningOptions: {\n            type: VersioningType.URI,\n            defaultVersion: VERSION_NEUTRAL,\n          },\n        }),\n      ).to.deep.equal(['/']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '',\n          methodPath: '',\n          globalPrefix: '',\n          controllerVersion: ['1', VERSION_NEUTRAL],\n          versioningOptions: {\n            type: VersioningType.URI,\n            defaultVersion: ['1', VERSION_NEUTRAL],\n          },\n        }),\n      ).to.deep.equal(['/v1', '/']);\n\n      expect(\n        routePathFactory.create({\n          ctrlPath: '',\n          methodPath: '',\n          globalPrefix: '',\n        }),\n      ).to.deep.equal(['/']);\n\n      sinon.stub(routePathFactory, 'isExcludedFromGlobalPrefix').returns(true);\n      expect(\n        routePathFactory.create({\n          ctrlPath: '/ctrlPath/',\n          methodPath: '/',\n          modulePath: '/',\n          globalPrefix: '/api',\n        }),\n      ).to.deep.equal(['/ctrlPath']);\n      sinon.restore();\n    });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["RoutePathFactory","isExcludedFromGlobalPrefix","when there is no exclude configuration"],"updatePoint":{"line":232,"column":29},"line":232,"code":"      it('should return false', () => {\n        sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({\n          exclude: undefined,\n        });\n        expect(\n          routePathFactory.isExcludedFromGlobalPrefix(\n            '/cats',\n            RequestMethod.GET,\n          ),\n        ).to.be.false;\n      });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["RoutePathFactory","isExcludedFromGlobalPrefix","otherwise","when route is not excluded"],"updatePoint":{"line":246,"column":31},"line":246,"code":"        it('should return false', () => {\n          sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({\n            exclude: [\n              {\n                path: '/random',\n                pathRegex: pathToRegexp('/random'),\n                requestMethod: RequestMethod.ALL,\n              },\n            ],\n          });\n          expect(\n            routePathFactory.isExcludedFromGlobalPrefix(\n              '/cats',\n              RequestMethod.GET,\n            ),\n          ).to.be.false;\n        });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["RoutePathFactory","isExcludedFromGlobalPrefix","otherwise","when route is excluded (by path)"],"updatePoint":{"line":265,"column":30},"line":265,"code":"        it('should return true', () => {\n          sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({\n            exclude: [\n              {\n                path: '/cats',\n                pathRegex: pathToRegexp('/cats'),\n                requestMethod: RequestMethod.ALL,\n              },\n            ],\n          });\n          expect(\n            routePathFactory.isExcludedFromGlobalPrefix(\n              '/cats',\n              RequestMethod.GET,\n            ),\n          ).to.be.true;\n        });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return true","suites":["RoutePathFactory","isExcludedFromGlobalPrefix","otherwise","when route is excluded (by path)","when route is excluded (by method and path)"],"updatePoint":{"line":284,"column":32},"line":284,"code":"          it('should return true', () => {\n            sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({\n              exclude: [\n                {\n                  path: '/cats',\n                  pathRegex: pathToRegexp('/cats'),\n                  requestMethod: RequestMethod.GET,\n                },\n              ],\n            });\n            expect(\n              routePathFactory.isExcludedFromGlobalPrefix(\n                '/cats',\n                RequestMethod.GET,\n              ),\n            ).to.be.true;\n            expect(\n              routePathFactory.isExcludedFromGlobalPrefix(\n                '/cats',\n                RequestMethod.POST,\n              ),\n            ).to.be.false;\n          });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return empty string","suites":["RoutePathFactory","getVersionPrefix","when URI versioning is enabled","and prefix is disabled"],"updatePoint":{"line":315,"column":38},"line":315,"code":"        it('should return empty string', () => {\n          expect(\n            routePathFactory.getVersionPrefix({\n              type: VersioningType.URI,\n              prefix: false,\n            }),\n          ).to.equal('');\n        });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return the default prefix","suites":["RoutePathFactory","getVersionPrefix","when URI versioning is enabled","and prefix is undefined"],"updatePoint":{"line":325,"column":44},"line":325,"code":"        it('should return the default prefix', () => {\n          expect(\n            routePathFactory.getVersionPrefix({\n              type: VersioningType.URI,\n            }),\n          ).to.equal('v');\n        });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return it","suites":["RoutePathFactory","getVersionPrefix","when URI versioning is enabled","and prefix is specified"],"updatePoint":{"line":334,"column":28},"line":334,"code":"        it('should return it', () => {\n          expect(\n            routePathFactory.getVersionPrefix({\n              type: VersioningType.URI,\n              prefix: 'test',\n            }),\n          ).to.equal('test');\n        });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return default prefix","suites":["RoutePathFactory","getVersionPrefix","when URI versioning is disabled"],"updatePoint":{"line":345,"column":38},"line":345,"code":"      it('should return default prefix', () => {\n        expect(\n          routePathFactory.getVersionPrefix({\n            type: VersioningType.HEADER,\n            header: 'X',\n          }),\n        ).to.equal('v');\n      });","file":"router/route-path-factory.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return plain ExceptionHandler object","suites":["RouterExceptionFilters","create","when filters metadata is empty"],"updatePoint":{"line":35,"column":53},"line":35,"code":"      it('should return plain ExceptionHandler object', () => {\n        const filter = exceptionFilter.create(\n          new EmptyMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.be.empty;\n      });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return ExceptionHandler object with exception filters","suites":["RouterExceptionFilters","create","when filters metadata is not empty"],"updatePoint":{"line":48,"column":70},"line":48,"code":"      it('should return ExceptionHandler object with exception filters', () => {\n        const filter = exceptionFilter.create(\n          new WithMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.not.be.empty;\n      });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return FILTER_CATCH_EXCEPTIONS metadata","suites":["RouterExceptionFilters","reflectCatchExceptions"],"updatePoint":{"line":59,"column":54},"line":59,"code":"    it('should return FILTER_CATCH_EXCEPTIONS metadata', () => {\n      expect(\n        exceptionFilter.reflectCatchExceptions(new ExceptionFilter()),\n      ).to.be.eql([CustomException]);\n    });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected exception filters metadata","suites":["RouterExceptionFilters","createConcreteContext"],"updatePoint":{"line":69,"column":57},"line":69,"code":"    it('should return expected exception filters metadata', () => {\n      const resolved = exceptionFilter.createConcreteContext(filters as any);\n      expect(resolved).to.have.length(1);\n      expect(resolved[0].exceptionMetatypes).to.be.deep.equal([\n        CustomException,\n      ]);\n      expect(resolved[0].func).to.be.a('function');\n    });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return global filters","suites":["RouterExceptionFilters","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":80,"column":38},"line":80,"code":"      it('should return global filters', () => {\n        const expectedResult = applicationConfig.getGlobalFilters();\n        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);\n      });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should merge static global with request/transient scoped filters","suites":["RouterExceptionFilters","getGlobalMetadata","otherwise"],"updatePoint":{"line":86,"column":74},"line":86,"code":"      it('should merge static global with request/transient scoped filters', () => {\n        const globalFilters: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedFilterWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalFilters')\n          .callsFake(() => globalFilters);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestFilters')\n          .callsFake(() => scopedFilterWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(\n          instance,\n          ...globalFilters,\n        );\n      });","file":"router/router-exception-filters.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"exchangeKeysForValues\" with expected arguments","suites":["RouterExecutionContext","create","when callback metadata is not undefined"],"updatePoint":{"line":84,"column":69},"line":84,"code":"      it('should call \"exchangeKeysForValues\" with expected arguments', done => {\n        const keys = Object.keys(metadata);\n\n        contextCreator.create({ foo: 'bar' }, callback as any, '', '', 0);\n        expect(exchangeKeysForValuesSpy.called).to.be.true;\n        expect(exchangeKeysForValuesSpy.calledWith(keys, metadata)).to.be.true;\n        done();\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be a function","suites":["RouterExecutionContext","create","when callback metadata is not undefined","returns proxy function"],"updatePoint":{"line":116,"column":32},"line":116,"code":"        it('should be a function', () => {\n          expect(proxyContext).to.be.a('function');\n        });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply expected context and arguments to callback","suites":["RouterExecutionContext","create","when callback metadata is not undefined","returns proxy function","when proxy function called"],"updatePoint":{"line":135,"column":69},"line":135,"code":"          it('should apply expected context and arguments to callback', done => {\n            tryActivateStub.callsFake(async () => true);\n            proxyContext(request, response, next).then(() => {\n              const args = [next, undefined, request.body.test];\n              expect(applySpy.called).to.be.true;\n              expect(applySpy.calledWith(instance, args)).to.be.true;\n              done();\n            });\n          });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception when \"tryActivate\" returns false","suites":["RouterExecutionContext","create","when callback metadata is not undefined","returns proxy function","when proxy function called"],"updatePoint":{"line":144,"column":69},"line":144,"code":"          it('should throw exception when \"tryActivate\" returns false', async () => {\n            tryActivateStub.callsFake(async () => false);\n\n            let error: HttpException;\n            try {\n              await proxyContext(request, response, next);\n            } catch (e) {\n              error = e;\n            }\n            expect(error).to.be.instanceOf(ForbiddenException);\n            expect(error.message).to.be.eql('Forbidden resource');\n            expect(error.getResponse()).to.be.eql({\n              statusCode: HttpStatus.FORBIDDEN,\n              error: 'Forbidden',\n              message: FORBIDDEN_MESSAGE,\n            });\n          });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply expected context when \"canActivateFn\" apply","suites":["RouterExecutionContext","create","when callback metadata is not undefined","returns proxy function","when proxy function called"],"updatePoint":{"line":161,"column":70},"line":161,"code":"          it('should apply expected context when \"canActivateFn\" apply', () => {\n            proxyContext(request, response, next).then(() => {\n              expect(tryActivateStub.args[0][1][0]).to.equals(request);\n              expect(tryActivateStub.args[0][1][1]).to.equals(response);\n              expect(tryActivateStub.args[0][1][2]).to.equals(next);\n            });\n          });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply expected context when \"intercept\" apply","suites":["RouterExecutionContext","create","when callback metadata is not undefined","returns proxy function","when proxy function called"],"updatePoint":{"line":168,"column":66},"line":168,"code":"          it('should apply expected context when \"intercept\" apply', () => {\n            const interceptStub = sinon.stub(interceptorsConsumer, 'intercept');\n            proxyContext(request, response, next).then(() => {\n              expect(interceptStub.args[0][1][0]).to.equals(request);\n              expect(interceptStub.args[0][1][1]).to.equals(response);\n              expect(interceptStub.args[0][1][2]).to.equals(next);\n            });\n          });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should exchange arguments keys for appropriate values","suites":["RouterExecutionContext","exchangeKeysForValues"],"updatePoint":{"line":182,"column":61},"line":182,"code":"    it('should exchange arguments keys for appropriate values', () => {\n      const metadata = {\n        [RouteParamtypes.REQUEST]: { index: 0, data: 'test', pipes: [] },\n        [RouteParamtypes.BODY]: { index: 2, data: 'test', pipes: [] },\n        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {\n          index: 3,\n          data: 'custom',\n          pipes: [],\n        },\n      };\n      const keys = Object.keys(metadata);\n      const values = contextCreator.exchangeKeysForValues(keys, metadata, '');\n      const expectedValues = [\n        { index: 0, type: RouteParamtypes.REQUEST, data: 'test' },\n        { index: 2, type: RouteParamtypes.BODY, data: 'test' },\n        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },\n      ];\n      expect(values[0]).to.deep.include(expectedValues[0]);\n      expect(values[1]).to.deep.include(expectedValues[1]);\n    });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"consumer.apply\" with expected arguments","suites":["RouterExecutionContext","getParamValue","when paramtype is query, body or param"],"updatePoint":{"line":214,"column":62},"line":214,"code":"      it('should call \"consumer.apply\" with expected arguments', () => {\n        contextCreator.getParamValue(\n          value,\n          { metatype, type: RouteParamtypes.QUERY, data: null },\n          transforms,\n        );\n        expect(\n          consumerApplySpy.calledWith(\n            value,\n            { metatype, type: RouteParamtypes.QUERY, data: null },\n            transforms,\n          ),\n        ).to.be.true;\n\n        contextCreator.getParamValue(\n          value,\n          { metatype, type: RouteParamtypes.BODY, data: null },\n          transforms,\n        );\n        expect(\n          consumerApplySpy.calledWith(\n            value,\n            { metatype, type: RouteParamtypes.BODY, data: null },\n            transforms,\n          ),\n        ).to.be.true;\n\n        contextCreator.getParamValue(\n          value,\n          { metatype, type: RouteParamtypes.PARAM, data: null },\n          transforms,\n        );\n        expect(\n          consumerApplySpy.calledWith(\n            value,\n            { metatype, type: RouteParamtypes.PARAM, data: null },\n            transforms,\n          ),\n        ).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return false","suites":["RouterExecutionContext","isPipeable","when paramtype is not query, body, param and custom"],"updatePoint":{"line":258,"column":29},"line":258,"code":"      it('should return false', () => {\n        const result = contextCreator.isPipeable(RouteParamtypes.NEXT);\n        expect(result).to.be.false;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"otherwise","suites":["RouterExecutionContext","isPipeable","when paramtype is not query, body, param and custom"],"updatePoint":{"line":262,"column":19},"line":262,"code":"      it('otherwise', () => {\n        expect(contextCreator.isPipeable(RouteParamtypes.BODY)).to.be.true;\n        expect(contextCreator.isPipeable(RouteParamtypes.QUERY)).to.be.true;\n        expect(contextCreator.isPipeable(RouteParamtypes.PARAM)).to.be.true;\n        expect(contextCreator.isPipeable(RouteParamtypes.FILE)).to.be.true;\n        expect(contextCreator.isPipeable(RouteParamtypes.FILES)).to.be.true;\n        expect(contextCreator.isPipeable('custom')).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"returns null","suites":["RouterExecutionContext","createPipesFn","when \"paramsOptions\" is empty"],"updatePoint":{"line":274,"column":22},"line":274,"code":"      it('returns null', async () => {\n        const pipesFn = contextCreator.createPipesFn([], []);\n        expect(pipesFn).to.be.null;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw ForbiddenException when \"tryActivate\" returns false","suites":["RouterExecutionContext","createGuardsFn"],"updatePoint":{"line":281,"column":72},"line":281,"code":"    it('should throw ForbiddenException when \"tryActivate\" returns false', async () => {\n      const guardsFn = contextCreator.createGuardsFn([null], null, null);\n      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);\n\n      let error: ForbiddenException;\n      try {\n        await guardsFn([]);\n      } catch (e) {\n        error = e;\n      }\n\n      expect(error).to.be.instanceOf(ForbiddenException);\n      expect(error.message).to.be.eql('Forbidden resource');\n      expect(error.getResponse()).to.be.eql({\n        statusCode: HttpStatus.FORBIDDEN,\n        message: FORBIDDEN_MESSAGE,\n        error: 'Forbidden',\n      });\n    });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"res.render()\" with expected args","suites":["RouterExecutionContext","createHandleResponseFn","when \"renderTemplate\" is defined"],"updatePoint":{"line":310,"column":55},"line":310,"code":"      it('should call \"res.render()\" with expected args', async () => {\n        const template = 'template';\n        const value = 'test';\n        const response = { render: sinon.spy() };\n\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(template);\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(value, response);\n\n        expect(response.render.calledWith(template, value)).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"res.render()\"","suites":["RouterExecutionContext","createHandleResponseFn","when \"renderTemplate\" is undefined"],"updatePoint":{"line":329,"column":40},"line":329,"code":"      it('should not call \"res.render()\"', async () => {\n        const result = Promise.resolve('test');\n        const response = { render: sinon.spy() };\n\n        sinon.stub(contextCreator, 'reflectResponseHeaders').returns([]);\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns(undefined);\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(result, response);\n\n        expect(response.render.called).to.be.false;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"res.redirect()\" with expected args","suites":["RouterExecutionContext","createHandleResponseFn","when \"redirectResponse\" is present"],"updatePoint":{"line":356,"column":57},"line":356,"code":"      it('should call \"res.redirect()\" with expected args', async () => {\n        const redirectResponse = {\n          url: 'http://test.com',\n          statusCode: 302,\n        };\n        const response = { redirect: sinon.spy() };\n\n        const handler = contextCreator.createHandleResponseFn(\n          () => {},\n          true,\n          redirectResponse,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(redirectResponse, response);\n\n        expect(\n          response.redirect.calledWith(\n            redirectResponse.statusCode,\n            redirectResponse.url,\n          ),\n        ).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"res.redirect()\"","suites":["RouterExecutionContext","createHandleResponseFn","when \"redirectResponse\" is undefined"],"updatePoint":{"line":381,"column":42},"line":381,"code":"      it('should not call \"res.redirect()\"', async () => {\n        const result = Promise.resolve('test');\n        const response = { redirect: sinon.spy() };\n\n        sinon.stub(contextCreator, 'reflectResponseHeaders').returns([]);\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns(undefined);\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(result, response);\n\n        expect(response.redirect.called).to.be.false;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"adapter.reply()\" with expected args","suites":["RouterExecutionContext","createHandleResponseFn","when replying with result"],"updatePoint":{"line":402,"column":58},"line":402,"code":"      it('should call \"adapter.reply()\" with expected args', async () => {\n        const result = Promise.resolve('test');\n        const response = {};\n\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns(undefined);\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          false,\n          undefined,\n          1234,\n        ) as HandlerResponseBasicFn;\n        const adapterReplySpy = sinon.spy(adapter, 'reply');\n        await handler(result, response);\n        expect(\n          adapterReplySpy.calledOnceWithExactly(\n            sinon.match.same(response),\n            'test',\n            1234,\n          ),\n        ).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should delegate result to SseStream","suites":["RouterExecutionContext","createHandleResponseFn","when \"isSse\" is enabled"],"updatePoint":{"line":428,"column":45},"line":428,"code":"      it('should delegate result to SseStream', async () => {\n        const result = of('test');\n        const response = new PassThrough();\n        response.write = sinon.spy();\n\n        const request = new PassThrough();\n        request.on = sinon.spy();\n\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns('/');\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(result, response, request);\n\n        expect((response.write as any).called).to.be.true;\n        expect((request.on as any).called).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not allow a non-observable result","suites":["RouterExecutionContext","createHandleResponseFn","when \"isSse\" is enabled"],"updatePoint":{"line":451,"column":50},"line":451,"code":"      it('should not allow a non-observable result', async () => {\n        const result = Promise.resolve('test');\n        const response = new PassThrough();\n        const request = new PassThrough();\n\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns('/');\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n\n        try {\n          await handler(result, response, request);\n        } catch (e) {\n          expect(e.message).to.equal(\n            'You must return an Observable stream to use Server-Sent Events (SSE).',\n          );\n        }\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply any headers that exists on the response","suites":["RouterExecutionContext","createHandleResponseFn","when \"isSse\" is enabled"],"updatePoint":{"line":475,"column":62},"line":475,"code":"      it('should apply any headers that exists on the response', async () => {\n        const result = of('test');\n        const response = new PassThrough() as HeaderStream;\n        response.write = sinon.spy();\n        response.writeHead = sinon.spy();\n        response.flushHeaders = sinon.spy();\n        response.getHeaders = sinon\n          .stub()\n          .returns({ 'access-control-headers': 'some-cors-value' });\n\n        const request = new PassThrough();\n        request.on = sinon.spy();\n\n        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined);\n        sinon.stub(contextCreator, 'reflectSse').returns('/');\n\n        const handler = contextCreator.createHandleResponseFn(\n          null,\n          true,\n          undefined,\n          200,\n        ) as HandlerResponseBasicFn;\n        await handler(result, response, request);\n\n        expect(\n          (response.writeHead as sinon.SinonSpy).calledWith(\n            200,\n            sinon.match.hasNested('access-control-headers', 'some-cors-value'),\n          ),\n        ).to.be.true;\n      });","file":"router/router-execution-context.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represent single route","suites":["RouterExplorer","applyPathsToRouterProxy"],"updatePoint":{"line":90,"column":73},"line":90,"code":"    it('should method return expected object which represent single route', () => {\n      const bindStub = sinon.stub(\n        routerBuilder,\n        'applyCallbackToRouter' as any,\n      );\n      const paths = [\n        { path: [''], requestMethod: RequestMethod.GET },\n        { path: ['test'], requestMethod: RequestMethod.GET },\n        { path: ['foo', 'bar'], requestMethod: RequestMethod.GET },\n      ];\n\n      routerBuilder.applyPathsToRouterProxy(\n        null,\n        paths as any,\n        null,\n        '',\n        {},\n        '',\n      );\n\n      expect(bindStub.calledWith(null, paths[0], null)).to.be.true;\n      expect(bindStub.callCount).to.be.eql(paths.length);\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return expected object which represents a single versioned route","suites":["RouterExplorer","applyPathsToRouterProxy"],"updatePoint":{"line":114,"column":86},"line":114,"code":"    it('should method return expected object which represents a single versioned route', () => {\n      const bindStub = sinon.stub(\n        routerBuilder,\n        'applyCallbackToRouter' as any,\n      );\n      const paths = [\n        { path: [''], requestMethod: RequestMethod.GET },\n        { path: ['test'], requestMethod: RequestMethod.GET },\n        { path: ['foo', 'bar'], requestMethod: RequestMethod.GET },\n      ];\n\n      const routePathMetadata: RoutePathMetadata = {\n        versioningOptions: { type: VersioningType.URI },\n      };\n      routerBuilder.applyPathsToRouterProxy(\n        null,\n        paths as any,\n        null,\n        '',\n        routePathMetadata,\n        '1',\n      );\n\n      expect(\n        bindStub.calledWith(null, paths[0], null, '', routePathMetadata, '1'),\n      ).to.be.true;\n      expect(bindStub.callCount).to.be.eql(paths.length);\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected path","suites":["RouterExplorer","extractRouterPath"],"updatePoint":{"line":145,"column":35},"line":145,"code":"    it('should return expected path', () => {\n      expect(routerBuilder.extractRouterPath(TestRoute)).to.be.eql(['/global']);\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return expected path with alias","suites":["RouterExplorer","extractRouterPath"],"updatePoint":{"line":149,"column":46},"line":149,"code":"    it('should return expected path with alias', () => {\n      expect(routerBuilder.extractRouterPath(TestRouteAlias)).to.be.eql([\n        '/global',\n        '/global-alias',\n      ]);\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw UnknownRequestMappingException when missing the `@Controller()` decorator in the class, displaying class's name","suites":["RouterExplorer","extractRouterPath"],"updatePoint":{"line":156,"column":132},"line":156,"code":"    it(\"should throw UnknownRequestMappingException when missing the `@Controller()` decorator in the class, displaying class's name\", () => {\n      expect(() =>\n        routerBuilder.extractRouterPath(ClassWithMissingControllerDecorator),\n      ).to.throw(\n        UnknownRequestMappingException,\n        /ClassWithMissingControllerDecorator/,\n      );\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should delegate error to exception filters","suites":["RouterExplorer","createRequestScopedHandler","when \"loadPerContext\" throws"],"updatePoint":{"line":192,"column":52},"line":192,"code":"      it('should delegate error to exception filters', async () => {\n        const handler = routerBuilder.createRequestScopedHandler(\n          wrapper,\n          RequestMethod.ALL,\n          module,\n          moduleKey,\n          methodKey,\n        );\n        await handler(null, null, null);\n\n        expect(nextSpy.called).to.be.true;\n        expect(nextSpy.getCall(0).args[0]).to.be.instanceOf(Error);\n        expect(nextSpy.getCall(0).args[1]).to.be.instanceOf(\n          ExecutionContextHost,\n        );\n      });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call and return the `applyVersionFilter` from the underlying http server","suites":["RouterExplorer","applyVersionFilter"],"updatePoint":{"line":212,"column":87},"line":212,"code":"    it('should call and return the `applyVersionFilter` from the underlying http server', () => {\n      const router = sinon.spy(new NoopHttpAdapter({}));\n      const routePathMetadata: RoutePathMetadata = {\n        methodVersion:\n          sinon.fake() as unknown as RoutePathMetadata['methodVersion'],\n        versioningOptions:\n          sinon.fake() as unknown as RoutePathMetadata['versioningOptions'],\n      };\n      const handler = sinon.stub();\n\n      // We're using type assertion here because `applyVersionFilter` is private\n      const versionFilter = (routerBuilder as any).applyVersionFilter(\n        router,\n        routePathMetadata,\n        handler,\n      );\n\n      expect(\n        router.applyVersionFilter.calledOnceWithExactly(\n          handler,\n          routePathMetadata.methodVersion,\n          routePathMetadata.versioningOptions,\n        ),\n      ).to.be.true;\n\n      expect(router.applyVersionFilter.returnValues[0]).to.be.equal(\n        versionFilter,\n      );\n    });","file":"router/router-explorer.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a dynamic module with routes registered as a provider","suites":["RouterModule","register"],"updatePoint":{"line":17,"column":75},"line":17,"code":"    it('should return a dynamic module with routes registered as a provider', () => {\n      expect(RouterModule.register(routes)).to.deep.equal({\n        module: RouterModule,\n        providers: [\n          {\n            provide: ROUTES,\n            useValue: routes,\n          },\n        ],\n      });\n    });","file":"router/router-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should update the \"targetModulesByContainer\" weak map","suites":["RouterModule","when instantiated"],"updatePoint":{"line":30,"column":61},"line":30,"code":"    it('should update the \"targetModulesByContainer\" weak map', () => {\n      const moduleRef = new Module(TestModuleClass, new NestContainer(null));\n      const container = new ModulesContainer([\n        [TestModuleClass.name, moduleRef],\n      ]);\n\n      new RouterModule(container, routes);\n\n      class NotRegisteredModuleClass {}\n\n      new RouterModule(container, [\n        {\n          path: 'random',\n          module: NotRegisteredModuleClass,\n        },\n      ]);\n\n      expect(targetModulesByContainer.get(container).has(moduleRef)).to.be.true;\n    });","file":"router/router-module.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return thunk","suites":["RouterProxy","createProxy"],"updatePoint":{"line":22,"column":34},"line":22,"code":"    it('should method return thunk', () => {\n      const proxy = routerProxy.createProxy(() => {}, handler);\n      expect(typeof proxy === 'function').to.be.true;\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate callback passed as argument","suites":["RouterProxy","createProxy"],"updatePoint":{"line":27,"column":61},"line":27,"code":"    it('should method encapsulate callback passed as argument', () => {\n      const proxy = routerProxy.createProxy((req, res, next) => {\n        throw httpException;\n      }, handler);\n      proxy(null, null, null);\n\n      expect(nextStub.calledOnce).to.be.true;\n      expect(\n        nextStub.calledWith(\n          httpException,\n          new ExecutionContextHost([null, null, null]),\n        ),\n      ).to.be.true;\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate async callback passed as argument","suites":["RouterProxy","createProxy"],"updatePoint":{"line":42,"column":67},"line":42,"code":"    it('should method encapsulate async callback passed as argument', done => {\n      const proxy = routerProxy.createProxy(async (req, res, next) => {\n        throw httpException;\n      }, handler);\n      proxy(null, null, null);\n\n      setTimeout(() => {\n        expect(nextStub.calledOnce).to.be.true;\n        expect(\n          nextStub.calledWith(\n            httpException,\n            new ExecutionContextHost([null, null, null]),\n          ),\n        ).to.be.true;\n        done();\n      }, 0);\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method return thunk","suites":["RouterProxy","createExceptionLayerProxy"],"updatePoint":{"line":62,"column":34},"line":62,"code":"    it('should method return thunk', () => {\n      const proxy = routerProxy.createExceptionLayerProxy(() => {}, handler);\n      expect(typeof proxy === 'function').to.be.true;\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate callback passed as argument","suites":["RouterProxy","createExceptionLayerProxy"],"updatePoint":{"line":67,"column":61},"line":67,"code":"    it('should method encapsulate callback passed as argument', () => {\n      const proxy = routerProxy.createExceptionLayerProxy(\n        (err, req, res, next) => {\n          throw httpException;\n        },\n        handler,\n      );\n      proxy(null, null, null, null);\n\n      expect(nextStub.calledOnce).to.be.true;\n      expect(\n        nextStub.calledWith(\n          httpException,\n          new ExecutionContextHost([null, null, null]),\n        ),\n      ).to.be.true;\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should method encapsulate async callback passed as argument","suites":["RouterProxy","createExceptionLayerProxy"],"updatePoint":{"line":85,"column":67},"line":85,"code":"    it('should method encapsulate async callback passed as argument', done => {\n      const proxy = routerProxy.createExceptionLayerProxy(\n        async (err, req, res, next) => {\n          throw httpException;\n        },\n        handler,\n      );\n      proxy(null, null, null, null);\n\n      setTimeout(() => {\n        expect(nextStub.calledOnce).to.be.true;\n        expect(\n          nextStub.calledWith(\n            httpException,\n            new ExecutionContextHost([null, null, null]),\n          ),\n        ).to.be.true;\n        done();\n      }, 0);\n    });","file":"router/router-proxy.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call send()","suites":["RouterResponseController","apply","when result is","nil"],"updatePoint":{"line":46,"column":30},"line":46,"code":"        it('should call send()', async () => {\n          const value = null;\n          await routerResponseController.apply(value, response, 200);\n          expect(response.send.called).to.be.true;\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call send(value)","suites":["RouterResponseController","apply","when result is","string"],"updatePoint":{"line":53,"column":35},"line":53,"code":"        it('should call send(value)', async () => {\n          const value = 'string';\n          await routerResponseController.apply(value, response, 200);\n          expect(response.send.called).to.be.true;\n          expect(response.send.calledWith(String(value))).to.be.true;\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call json(value)","suites":["RouterResponseController","apply","when result is","object"],"updatePoint":{"line":61,"column":35},"line":61,"code":"        it('should call json(value)', async () => {\n          const value = { test: 'test' };\n          await routerResponseController.apply(value, response, 200);\n          expect(response.json.called).to.be.true;\n          expect(response.json.calledWith(value)).to.be.true;\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return Promise that resolves to the value resolved by the input Promise","suites":["RouterResponseController","transformToResult","when resultOrDeferred","is Promise"],"updatePoint":{"line":74,"column":90},"line":74,"code":"        it('should return Promise that resolves to the value resolved by the input Promise', async () => {\n          const value = 100;\n          expect(\n            await routerResponseController.transformToResult(\n              Promise.resolve(value),\n            ),\n          ).to.be.eq(value);\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return toPromise","suites":["RouterResponseController","transformToResult","when resultOrDeferred","is Observable"],"updatePoint":{"line":85,"column":35},"line":85,"code":"        it('should return toPromise', async () => {\n          const lastValue = 100;\n          expect(\n            await routerResponseController.transformToResult(\n              of(1, 2, 3, lastValue),\n            ),\n          ).to.be.eq(lastValue);\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a Promise that resolves to the input value","suites":["RouterResponseController","transformToResult","when resultOrDeferred","is an object that has the method `subscribe`"],"updatePoint":{"line":96,"column":68},"line":96,"code":"        it('should return a Promise that resolves to the input value', async () => {\n          const value = { subscribe() {} };\n          expect(\n            await routerResponseController.transformToResult(value),\n          ).to.equal(value);\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return a Promise that resolves to the input value","suites":["RouterResponseController","transformToResult","when resultOrDeferred","is an ordinary value"],"updatePoint":{"line":105,"column":68},"line":105,"code":"        it('should return a Promise that resolves to the input value', async () => {\n          const value = 100;\n          expect(\n            await routerResponseController.transformToResult(value),\n          ).to.be.eq(value);\n        });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return 201","suites":["RouterResponseController","getStatusByMethod","when RequestMethod is POST"],"updatePoint":{"line":117,"column":27},"line":117,"code":"      it('should return 201', () => {\n        expect(\n          routerResponseController.getStatusByMethod(RequestMethod.POST),\n        ).to.be.eql(201);\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return 200","suites":["RouterResponseController","getStatusByMethod","when RequestMethod is not POST"],"updatePoint":{"line":124,"column":27},"line":124,"code":"      it('should return 200', () => {\n        expect(\n          routerResponseController.getStatusByMethod(RequestMethod.GET),\n        ).to.be.eql(200);\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"res.render()\" with expected args","suites":["RouterResponseController","render"],"updatePoint":{"line":140,"column":53},"line":140,"code":"    it('should call \"res.render()\" with expected args', async () => {\n      const template = 'template';\n      const value = 'test';\n      const result = Promise.resolve(value);\n      const response = { render: sinon.spy() };\n\n      await routerResponseController.render(result, response, template);\n      expect(response.render.calledWith(template, value)).to.be.true;\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set all custom headers","suites":["RouterResponseController","setHeaders"],"updatePoint":{"line":158,"column":37},"line":158,"code":"    it('should set all custom headers', () => {\n      const response = {};\n      const headers = [{ name: 'test', value: 'test_value' }];\n\n      routerResponseController.setHeaders(response, headers);\n      expect(\n        setHeaderStub.calledWith(response, headers[0].name, headers[0].value),\n      ).to.be.true;\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should set status","suites":["RouterResponseController","status"],"updatePoint":{"line":176,"column":25},"line":176,"code":"    it('should set status', () => {\n      const response = {};\n      const statusCode = 400;\n\n      routerResponseController.setStatus(response, statusCode);\n      expect(statusStub.calledWith(response, statusCode)).to.be.true;\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should transformToResult","suites":["RouterResponseController","redirect should HttpServer.redirect"],"updatePoint":{"line":186,"column":32},"line":186,"code":"    it('should transformToResult', async () => {\n      const transformToResultSpy = sinon\n        .stub(routerResponseController, 'transformToResult')\n        .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));\n      const result = {};\n      await routerResponseController.redirect(result, null, null);\n      expect(transformToResultSpy.firstCall.args[0]).to.be.equal(result);\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should pass the response to redirect","suites":["RouterResponseController","redirect should HttpServer.redirect"],"updatePoint":{"line":194,"column":44},"line":194,"code":"    it('should pass the response to redirect', async () => {\n      sinon\n        .stub(routerResponseController, 'transformToResult')\n        .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));\n      const redirectSpy = sinon.spy(adapter, 'redirect');\n      const response = {};\n      await routerResponseController.redirect(null, response, null);\n      expect(redirectSpy.firstCall.args[0]).to.be.equal(response);\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should come from the transformed result if present","suites":["RouterResponseController","redirect should HttpServer.redirect","status code"],"updatePoint":{"line":204,"column":60},"line":204,"code":"      it('should come from the transformed result if present', async () => {\n        sinon\n          .stub(routerResponseController, 'transformToResult')\n          .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));\n        const redirectSpy = sinon.spy(adapter, 'redirect');\n        await routerResponseController.redirect(null, null, {\n          statusCode: 999,\n          url: 'not form here',\n        });\n        expect(redirectSpy.firstCall.args[1]).to.be.eql(123);\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should come from the redirectResponse if not on the transformed result","suites":["RouterResponseController","redirect should HttpServer.redirect","status code"],"updatePoint":{"line":215,"column":80},"line":215,"code":"      it('should come from the redirectResponse if not on the transformed result', async () => {\n        sinon\n          .stub(routerResponseController, 'transformToResult')\n          .returns(Promise.resolve({}));\n        const redirectSpy = sinon.spy(adapter, 'redirect');\n        await routerResponseController.redirect(null, null, {\n          statusCode: 123,\n          url: 'redirect url',\n        });\n        expect(redirectSpy.firstCall.args[1]).to.be.eql(123);\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should default to HttpStatus.FOUND","suites":["RouterResponseController","redirect should HttpServer.redirect","status code"],"updatePoint":{"line":226,"column":44},"line":226,"code":"      it('should default to HttpStatus.FOUND', async () => {\n        sinon\n          .stub(routerResponseController, 'transformToResult')\n          .returns(Promise.resolve({}));\n        const redirectSpy = sinon.spy(adapter, 'redirect');\n        await routerResponseController.redirect(null, null, {\n          url: 'redirect url',\n        });\n        expect(redirectSpy.firstCall.args[1]).to.be.eql(HttpStatus.FOUND);\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should come from the transformed result if present","suites":["RouterResponseController","redirect should HttpServer.redirect","url"],"updatePoint":{"line":238,"column":60},"line":238,"code":"      it('should come from the transformed result if present', async () => {\n        sinon\n          .stub(routerResponseController, 'transformToResult')\n          .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));\n        const redirectSpy = sinon.spy(adapter, 'redirect');\n        await routerResponseController.redirect(null, null, {\n          url: 'not from here',\n        });\n        expect(redirectSpy.firstCall.args[2]).to.be.eql('redirect url');\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should come from the redirectResponse if not on the transformed result","suites":["RouterResponseController","redirect should HttpServer.redirect","url"],"updatePoint":{"line":248,"column":80},"line":248,"code":"      it('should come from the redirectResponse if not on the transformed result', async () => {\n        sinon\n          .stub(routerResponseController, 'transformToResult')\n          .returns(Promise.resolve({}));\n        const redirectSpy = sinon.spy(adapter, 'redirect');\n        await routerResponseController.redirect(null, null, {\n          statusCode: 123,\n          url: 'redirect url',\n        });\n        expect(redirectSpy.firstCall.args[2]).to.be.eql('redirect url');\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should accept only observables","suites":["RouterResponseController","Server-Sent-Events"],"updatePoint":{"line":262,"column":38},"line":262,"code":"    it('should accept only observables', async () => {\n      const result = Promise.resolve('test');\n      try {\n        await routerResponseController.sse(\n          result as unknown as any,\n          {} as unknown as ServerResponse,\n          {} as unknown as IncomingMessage,\n        );\n      } catch (e) {\n        expect(e.message).to.eql(\n          'You must return an Observable stream to use Server-Sent Events (SSE).',\n        );\n      }\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should write string","suites":["RouterResponseController","Server-Sent-Events"],"updatePoint":{"line":277,"column":27},"line":277,"code":"    it('should write string', async () => {\n      class Sink extends Writable {\n        private readonly chunks: string[] = [];\n\n        _write(\n          chunk: any,\n          encoding: string,\n          callback: (error?: Error | null) => void,\n        ): void {\n          this.chunks.push(chunk);\n          callback();\n        }\n\n        get content() {\n          return this.chunks.join('');\n        }\n      }\n\n      const written = (stream: Writable) =>\n        new Promise((resolve, reject) =>\n          stream.on('error', reject).on('finish', resolve),\n        );\n\n      const result = of('test');\n      const response = new Sink();\n      const request = new PassThrough();\n      routerResponseController.sse(\n        result,\n        response as unknown as ServerResponse,\n        request as unknown as IncomingMessage,\n      );\n      request.destroy();\n      await written(response);\n      expect(response.content).to.eql(\n        `\nid: 1\ndata: test\n\n`,\n      );\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should close on request close","suites":["RouterResponseController","Server-Sent-Events"],"updatePoint":{"line":319,"column":37},"line":319,"code":"    it('should close on request close', done => {\n      const result = of('test');\n      const response = new Writable();\n      response.end = () => done() as any;\n      response._write = () => {};\n\n      const request = new Writable();\n      request._write = () => {};\n\n      routerResponseController.sse(\n        result,\n        response as unknown as ServerResponse,\n        request as unknown as IncomingMessage,\n      );\n      request.emit('close');\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should close the request when observable completes","suites":["RouterResponseController","Server-Sent-Events"],"updatePoint":{"line":336,"column":58},"line":336,"code":"    it('should close the request when observable completes', done => {\n      const result = of('test');\n      const response = new Writable();\n      response.end = done as any;\n      response._write = () => {};\n\n      const request = new Writable();\n      request._write = () => {};\n\n      routerResponseController.sse(\n        result,\n        response as unknown as ServerResponse,\n        request as unknown as IncomingMessage,\n      );\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should allow to intercept the response","suites":["RouterResponseController","Server-Sent-Events"],"updatePoint":{"line":352,"column":46},"line":352,"code":"    it('should allow to intercept the response', done => {\n      const result = sinon.spy();\n      const response = new Writable();\n      response.end();\n      response._write = () => {};\n\n      const request = new Writable();\n      request._write = () => {};\n\n      try {\n        routerResponseController.sse(\n          result as unknown as Observable<string>,\n          response as unknown as ServerResponse,\n          request as unknown as IncomingMessage,\n        );\n      } catch {\n        // Whether an error is thrown or not\n        // is not relevant, so long as\n        // result is not called\n      }\n\n      sinon.assert.notCalled(result);\n      done();\n    });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should close the request","suites":["RouterResponseController","Server-Sent-Events","when there is an error"],"updatePoint":{"line":378,"column":34},"line":378,"code":"      it('should close the request', done => {\n        const result = new Subject();\n        const response = new Writable();\n        response.end = done as any;\n        response._write = () => {};\n\n        const request = new Writable();\n        request._write = () => {};\n\n        routerResponseController.sse(\n          result,\n          response as unknown as ServerResponse,\n          request as unknown as IncomingMessage,\n        );\n\n        result.error(new Error('Some error'));\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should write the error message to the stream","suites":["RouterResponseController","Server-Sent-Events","when there is an error"],"updatePoint":{"line":396,"column":54},"line":396,"code":"      it('should write the error message to the stream', async () => {\n        class Sink extends Writable {\n          private readonly chunks: string[] = [];\n\n          _write(\n            chunk: any,\n            encoding: string,\n            callback: (error?: Error | null) => void,\n          ): void {\n            this.chunks.push(chunk);\n            callback();\n          }\n\n          get content() {\n            return this.chunks.join('');\n          }\n        }\n\n        const written = (stream: Writable) =>\n          new Promise((resolve, reject) =>\n            stream.on('error', reject).on('finish', resolve),\n          );\n\n        const result = new Subject();\n        const response = new Sink();\n        const request = new PassThrough();\n        routerResponseController.sse(\n          result,\n          response as unknown as ServerResponse,\n          request as unknown as IncomingMessage,\n        );\n\n        result.error(new Error('Some error'));\n        request.destroy();\n\n        await written(response);\n        expect(response.content).to.eql(\n          `\nevent: error\nid: 1\ndata: Some error\n\n`,\n        );\n      });","file":"router/router-response-controller.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register controllers to router instance","suites":["RoutesResolver","registerRouters"],"updatePoint":{"line":88,"column":54},"line":88,"code":"    it('should register controllers to router instance', () => {\n      const routes = new Map();\n      const routeWrapper = new InstanceWrapper({\n        instance: new TestRoute(),\n        metatype: TestRoute,\n      });\n      routes.set('TestRoute', routeWrapper);\n\n      const appInstance = new NoopHttpAdapter(router);\n      const exploreSpy = sinon.spy(\n        (routesResolver as any).routerExplorer,\n        'explore',\n      );\n      const moduleName = '';\n      modules.set(moduleName, {});\n\n      sinon\n        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')\n        .callsFake(() => ['']);\n      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);\n\n      const routePathMetadata = {\n        ctrlPath: '',\n        modulePath: '',\n        globalPrefix: '',\n        controllerVersion: undefined,\n        versioningOptions: undefined,\n        methodVersion: undefined,\n        methodPath: '/another-test',\n      };\n      expect(exploreSpy.called).to.be.true;\n      expect(\n        exploreSpy.calledWith(\n          routeWrapper,\n          moduleName,\n          appInstance,\n          undefined,\n          routePathMetadata,\n        ),\n      ).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register with host when specified","suites":["RoutesResolver","registerRouters"],"updatePoint":{"line":130,"column":48},"line":130,"code":"    it('should register with host when specified', () => {\n      const routes = new Map();\n      const routeWrapper = new InstanceWrapper({\n        instance: new TestHostRoute(),\n        metatype: TestHostRoute,\n      });\n      routes.set('TestHostRoute', routeWrapper);\n\n      const appInstance = new NoopHttpAdapter(router);\n      const exploreSpy = sinon.spy(\n        (routesResolver as any).routerExplorer,\n        'explore',\n      );\n      const moduleName = '';\n      modules.set(moduleName, {});\n\n      sinon\n        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')\n        .callsFake(() => ['']);\n      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);\n\n      const routePathMetadata = {\n        ctrlPath: '',\n        modulePath: '',\n        globalPrefix: '',\n        controllerVersion: undefined,\n        versioningOptions: undefined,\n        methodVersion: undefined,\n        methodPath: '/',\n      };\n\n      expect(exploreSpy.called).to.be.true;\n      expect(\n        exploreSpy.calledWith(\n          routeWrapper,\n          moduleName,\n          appInstance,\n          'api.example.com',\n          routePathMetadata,\n        ),\n      ).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register with version when specified","suites":["RoutesResolver","registerRouters"],"updatePoint":{"line":173,"column":51},"line":173,"code":"    it('should register with version when specified', () => {\n      const applicationConfig = new ApplicationConfig();\n      applicationConfig.enableVersioning({\n        type: VersioningType.URI,\n      });\n      routesResolver = new RoutesResolver(\n        container,\n        applicationConfig,\n        new Injector(),\n        new GraphInspector(container),\n      );\n\n      const routes = new Map();\n      const routeWrapper = new InstanceWrapper({\n        instance: new TestVersionRoute(),\n        metatype: TestVersionRoute,\n      });\n      routes.set('TestVersionRoute', routeWrapper);\n\n      const appInstance = new NoopHttpAdapter(router);\n      const exploreSpy = sinon.spy(\n        (routesResolver as any).routerExplorer,\n        'explore',\n      );\n      const moduleName = '';\n      modules.set(moduleName, {});\n\n      sinon\n        .stub((routesResolver as any).routerExplorer, 'extractRouterPath')\n        .callsFake(() => ['']);\n      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);\n\n      const routePathMetadata = {\n        ctrlPath: '',\n        modulePath: '',\n        globalPrefix: '',\n        controllerVersion: '1',\n        versioningOptions: {\n          type: VersioningType.URI,\n        },\n        methodVersion: undefined,\n        methodPath: '/',\n      };\n\n      expect(exploreSpy.called).to.be.true;\n      expect(\n        exploreSpy.calledWith(\n          routeWrapper,\n          moduleName,\n          appInstance,\n          undefined,\n          routePathMetadata,\n        ),\n      ).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"registerRouters\" for each module","suites":["RoutesResolver","resolve"],"updatePoint":{"line":231,"column":53},"line":231,"code":"    it('should call \"registerRouters\" for each module', () => {\n      const routes = new Map();\n      routes.set(\n        'TestRoute',\n        new InstanceWrapper({\n          instance: new TestRoute(),\n          metatype: TestRoute,\n        }),\n      );\n      modules.set('TestModule', { routes, metatype: class {} });\n      modules.set('TestModule2', { routes, metatype: class {} });\n\n      const registerRoutersStub = sinon\n        .stub(routesResolver, 'registerRouters')\n        .callsFake(() => undefined);\n\n      routesResolver.resolve({ use: sinon.spy() } as any, 'basePath');\n      expect(registerRoutersStub.calledTwice).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register each module with the base path and append the module path if present ","suites":["RoutesResolver","resolve","registerRouters"],"updatePoint":{"line":252,"column":95},"line":252,"code":"      it('should register each module with the base path and append the module path if present ', () => {\n        const routes = new Map();\n        routes.set('TestRoute', {\n          instance: new TestRoute(),\n          metatype: TestRoute,\n        });\n\n        Reflect.defineMetadata(MODULE_PATH, '/test', TestModule);\n        modules.set('TestModule', { routes, metatype: TestModule });\n        modules.set('TestModule2', { routes, metatype: TestModule2 });\n\n        const spy = sinon\n          .stub(routesResolver, 'registerRouters')\n          .callsFake(() => undefined);\n\n        routesResolver.resolve(applicationRef, 'api/v1');\n\n        expect(\n          spy\n            .getCall(0)\n            .calledWith(sinon.match.any, sinon.match.any, 'api/v1', '/test'),\n        ).to.be.true;\n        expect(\n          spy\n            .getCall(1)\n            .calledWith(\n              sinon.match.any,\n              sinon.match.any,\n              'api/v1',\n              sinon.match.any,\n            ),\n        ).to.be.true;\n      });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register each module with the module path if present","suites":["RoutesResolver","resolve","registerRouters"],"updatePoint":{"line":286,"column":69},"line":286,"code":"      it('should register each module with the module path if present', () => {\n        const routes = new Map();\n        routes.set('TestRoute', {\n          instance: new TestRoute(),\n          metatype: TestRoute,\n        });\n\n        Reflect.defineMetadata(MODULE_PATH, '/test', TestModule);\n        modules.set('TestModule', { routes, metatype: TestModule });\n        modules.set('TestModule2', { routes, metatype: TestModule2 });\n\n        const spy = sinon\n          .stub(routesResolver, 'registerRouters')\n          .callsFake(() => undefined);\n\n        routesResolver.resolve(applicationRef, '');\n\n        expect(\n          spy\n            .getCall(0)\n            .calledWith(sinon.match.any, sinon.match.any, '', '/test'),\n        ).to.be.true;\n        // without module path\n        expect(\n          spy\n            .getCall(1)\n            .calledWith(sinon.match.any, sinon.match.any, '', undefined),\n        ).to.be.true;\n      });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map to BadRequestException","suites":["RoutesResolver","mapExternalExceptions","when exception prototype is","SyntaxError"],"updatePoint":{"line":321,"column":45},"line":321,"code":"        it('should map to BadRequestException', () => {\n          const err = new SyntaxError();\n          const outputErr = routesResolver.mapExternalException(err);\n          expect(outputErr).to.be.instanceof(BadRequestException);\n        });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should map to BadRequestException","suites":["RoutesResolver","mapExternalExceptions","when exception prototype is","URIError"],"updatePoint":{"line":328,"column":45},"line":328,"code":"        it('should map to BadRequestException', () => {\n          const err = new URIError();\n          const outputErr = routesResolver.mapExternalException(err);\n          expect(outputErr).to.be.instanceof(BadRequestException);\n        });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should behave as an identity","suites":["RoutesResolver","mapExternalExceptions","when exception prototype is","other"],"updatePoint":{"line":335,"column":40},"line":335,"code":"        it('should behave as an identity', () => {\n          const err = new Error();\n          const outputErr = routesResolver.mapExternalException(err);\n          expect(outputErr).to.be.eql(err);\n        });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register not found handler","suites":["RoutesResolver","registerNotFoundHandler"],"updatePoint":{"line":345,"column":41},"line":345,"code":"    it('should register not found handler', () => {\n      routesResolver.registerNotFoundHandler();\n\n      expect(applicationRef.setNotFoundHandler.called).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should register exception handler","suites":["RoutesResolver","registerExceptionHandler"],"updatePoint":{"line":353,"column":41},"line":353,"code":"    it('should register exception handler', () => {\n      routesResolver.registerExceptionHandler();\n\n      expect(applicationRef.setErrorHandler.called).to.be.true;\n    });","file":"router/routes-resolver.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"writes multiple multiline messages","suites":["SseStream"],"updatePoint":{"line":42,"column":40},"line":42,"code":"  it('writes multiple multiline messages', async () => {\n    const sse = new SseStream();\n    const sink = new Sink();\n    sse.pipe(sink);\n\n    sse.writeMessage(\n      {\n        data: 'hello\\nworld',\n      },\n      noop,\n    );\n    sse.writeMessage(\n      {\n        data: 'bonjour\\nmonde',\n      },\n      noop,\n    );\n    sse.end();\n    await written(sink);\n\n    expect(sink.content).to.equal(\n      `\nid: 1\ndata: hello\ndata: world\n\nid: 2\ndata: bonjour\ndata: monde\n\n`,\n    );\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"writes object messages as JSON","suites":["SseStream"],"updatePoint":{"line":76,"column":36},"line":76,"code":"  it('writes object messages as JSON', async () => {\n    const sse = new SseStream();\n    const sink = new Sink();\n    sse.pipe(sink);\n\n    sse.writeMessage(\n      {\n        data: { hello: 'world' },\n      },\n      noop,\n    );\n    sse.end();\n    await written(sink);\n\n    expect(sink.content).to.equal(\n      `\nid: 1\ndata: {\"hello\":\"world\"}\n\n`,\n    );\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"writes all message attributes","suites":["SseStream"],"updatePoint":{"line":99,"column":35},"line":99,"code":"  it('writes all message attributes', async () => {\n    const sse = new SseStream();\n    const sink = new Sink();\n    sse.pipe(sink);\n\n    sse.writeMessage(\n      {\n        type: 'tea-time',\n        id: 'the-id',\n        retry: 222,\n        data: 'hello',\n      },\n      noop,\n    );\n    sse.end();\n    await written(sink);\n\n    expect(sink.content).to.equal(\n      `\nevent: tea-time\nid: the-id\nretry: 222\ndata: hello\n\n`,\n    );\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"sets headers on destination when it looks like a HTTP Response","suites":["SseStream"],"updatePoint":{"line":127,"column":68},"line":127,"code":"  it('sets headers on destination when it looks like a HTTP Response', callback => {\n    const sse = new SseStream();\n    const sink = new Sink(\n      (status: number, headers: string | OutgoingHttpHeaders) => {\n        expect(headers).to.deep.equal({\n          'Content-Type': 'text/event-stream',\n          Connection: 'keep-alive',\n          'Cache-Control':\n            'private, no-cache, no-store, must-revalidate, max-age=0, no-transform',\n          Pragma: 'no-cache',\n          Expire: '0',\n          'X-Accel-Buffering': 'no',\n        });\n        callback();\n        return sink;\n      },\n    );\n    sse.pipe(sink);\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"sets additional headers when provided","suites":["SseStream"],"updatePoint":{"line":147,"column":43},"line":147,"code":"  it('sets additional headers when provided', callback => {\n    const sse = new SseStream();\n    const sink = new Sink(\n      (status: number, headers: string | OutgoingHttpHeaders) => {\n        expect(headers).to.contain.keys('access-control-headers');\n        expect(headers['access-control-headers']).to.equal('some-cors-value');\n        callback();\n        return sink;\n      },\n    );\n\n    sse.pipe(sink, {\n      additionalHeaders: { 'access-control-headers': 'some-cors-value' },\n    });\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"allows an eventsource to connect","suites":["SseStream"],"updatePoint":{"line":163,"column":38},"line":163,"code":"  it('allows an eventsource to connect', callback => {\n    let sse: SseStream;\n    const server = createServer((req, res) => {\n      sse = new SseStream(req);\n      sse.pipe(res);\n    });\n\n    server.listen(() => {\n      const es = new EventSource(\n        `http://localhost:${(server.address() as AddressInfo).port}`,\n      );\n      es.onmessage = e => {\n        expect(e.data).to.equal('hello');\n        es.close();\n        server.close(callback);\n      };\n      es.onopen = () => sse.writeMessage({ data: 'hello' }, noop);\n      es.onerror = e =>\n        callback(new Error(`Error from EventSource: ${JSON.stringify(e)}`));\n    });\n  });","file":"router/sse-stream.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should flatten all route paths","suites":["flattenRoutePaths"],"updatePoint":{"line":6,"column":36},"line":6,"code":"  it('should flatten all route paths', () => {\n    @Module({})\n    class ParentModule {}\n    @Module({})\n    class ChildModule {}\n    @Module({})\n    class ChildChildModule {}\n    @Module({})\n    class ChildModule2 {}\n    @Module({})\n    class ParentChildModule {}\n    @Module({})\n    class ChildChildModule2 {}\n    @Module({})\n    class AuthModule {}\n    @Module({})\n    class CatsModule {}\n    @Module({})\n    class DogsModule {}\n\n    @Module({})\n    class AuthModule2 {}\n    @Module({})\n    class CatsModule2 {}\n    @Module({})\n    class CatsModule3 {}\n    @Module({})\n    class AuthModule3 {}\n    const routes = [\n      {\n        path: '/parent',\n        module: ParentModule,\n        children: [\n          {\n            path: '/child',\n            module: ChildModule,\n            children: [\n              { path: '/child2', module: ChildModule2 },\n              {\n                path: '/parentchild',\n                module: ParentChildModule,\n                children: [\n                  {\n                    path: '/childchild',\n                    module: ChildChildModule,\n                    children: [\n                      { path: '/child2child', module: ChildChildModule2 },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n      { path: '/v1', children: [AuthModule, CatsModule, DogsModule] },\n      { path: '/v2', children: [AuthModule2, CatsModule2] },\n      { path: '/v3', children: [AuthModule3, CatsModule3] },\n    ];\n    const expectedRoutes = [\n      { path: '/parent', module: ParentModule },\n      { path: '/parent/child', module: ChildModule },\n      { path: '/parent/child/child2', module: ChildModule2 },\n      { path: '/parent/child/parentchild', module: ParentChildModule },\n      {\n        path: '/parent/child/parentchild/childchild',\n        module: ChildChildModule,\n      },\n      {\n        path: '/parent/child/parentchild/childchild/child2child',\n        module: ChildChildModule2,\n      },\n      { path: '/v1', module: AuthModule },\n      { path: '/v1', module: CatsModule },\n      { path: '/v1', module: DogsModule },\n      { path: '/v2', module: AuthModule2 },\n      { path: '/v2', module: CatsModule2 },\n      { path: '/v3', module: AuthModule3 },\n      { path: '/v3', module: CatsModule3 },\n    ];\n    expect(flattenRoutePaths(routes)).to.be.eql(expectedRoutes);\n  });","file":"router/utils/flat-routes.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertOrOverrideModule\" call twice (2 modules) container method \"addModule\"","suites":["DependenciesScanner"],"updatePoint":{"line":81,"column":89},"line":81,"code":"  it('should \"insertOrOverrideModule\" call twice (2 modules) container method \"addModule\"', async () => {\n    const expectationCountAddModule = mockContainer\n      .expects('addModule')\n      .twice();\n    const expectationCountReplaceModule = mockContainer\n      .expects('replaceModule')\n      .never();\n\n    await scanner.scan(TestModule as any);\n    expectationCountAddModule.verify();\n    expectationCountReplaceModule.verify();\n  });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertProvider\" call twice (2 components) container method \"addProvider\"","suites":["DependenciesScanner"],"updatePoint":{"line":94,"column":86},"line":94,"code":"  it('should \"insertProvider\" call twice (2 components) container method \"addProvider\"', async () => {\n    const expectation = mockContainer.expects('addProvider').twice();\n    const stub = sinon.stub(scanner, 'insertExportedProvider');\n\n    await scanner.scan(TestModule as any);\n    expectation.verify();\n    stub.restore();\n  });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertController\" call twice (2 components) container method \"addController\"","suites":["DependenciesScanner"],"updatePoint":{"line":103,"column":90},"line":103,"code":"  it('should \"insertController\" call twice (2 components) container method \"addController\"', async () => {\n    const expectation = mockContainer.expects('addController').twice();\n    await scanner.scan(TestModule as any);\n    expectation.verify();\n  });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertExportedProvider\" call once (1 component) container method \"addExportedProvider\"","suites":["DependenciesScanner"],"updatePoint":{"line":109,"column":100},"line":109,"code":"  it('should \"insertExportedProvider\" call once (1 component) container method \"addExportedProvider\"', async () => {\n    const expectation = mockContainer.expects('addExportedProvider').once();\n    await scanner.scan(TestModule as any);\n    expectation.verify();\n  });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"putModule\" call twice (2 modules) container method \"replaceModule\"","suites":["DependenciesScanner","when there is modules overrides"],"updatePoint":{"line":166,"column":82},"line":166,"code":"    it('should \"putModule\" call twice (2 modules) container method \"replaceModule\"', async () => {\n      const expectationReplaceModuleFirst = mockContainer\n        .expects('replaceModule')\n        .once()\n        .withArgs(OverwrittenModuleOne, OverrideModuleOne, sinon.match.array);\n      const expectationReplaceModuleSecond = mockContainer\n        .expects('replaceModule')\n        .once()\n        .withArgs(OverwrittenModuleTwo, OverrideModuleTwo, sinon.match.array);\n      const expectationCountAddModule = mockContainer\n        .expects('addModule')\n        .once();\n\n      await scanner.scan(OverrideTestModule as any, {\n        overrides: modulesToOverride,\n      });\n\n      expectationReplaceModuleFirst.verify();\n      expectationReplaceModuleSecond.verify();\n      expectationCountAddModule.verify();\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertProvider\" call once container method \"addProvider\"","suites":["DependenciesScanner","when there is modules overrides"],"updatePoint":{"line":188,"column":72},"line":188,"code":"    it('should \"insertProvider\" call once container method \"addProvider\"', async () => {\n      const expectation = mockContainer.expects('addProvider').once();\n\n      await scanner.scan(OverrideTestModule as any);\n      expectation.verify();\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"insertController\" call twice (2 components) container method \"addController\"","suites":["DependenciesScanner","when there is modules overrides"],"updatePoint":{"line":195,"column":92},"line":195,"code":"    it('should \"insertController\" call twice (2 components) container method \"addController\"', async () => {\n      const expectation = mockContainer.expects('addController').twice();\n      await scanner.scan(OverrideTestModule as any);\n      expectation.verify();\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should \"putModule\" call container method \"replaceModule\" with forwardRef() when forwardRef property exists","suites":["DependenciesScanner","when there is modules overrides"],"updatePoint":{"line":201,"column":114},"line":201,"code":"    it('should \"putModule\" call container method \"replaceModule\" with forwardRef() when forwardRef property exists', async () => {\n      const overwrittenForwardRefSpy = sinon.spy();\n\n      @Module({})\n      class OverwrittenForwardRef {}\n\n      @Module({})\n      class Overwritten {\n        public static forwardRef() {\n          overwrittenForwardRefSpy();\n          return OverwrittenForwardRef;\n        }\n      }\n\n      const overrideForwardRefSpy = sinon.spy();\n\n      @Module({})\n      class OverrideForwardRef {}\n\n      @Module({})\n      class Override {\n        public static forwardRef() {\n          overrideForwardRefSpy();\n          return OverrideForwardRef;\n        }\n      }\n\n      @Module({\n        imports: [Overwritten],\n      })\n      class OverrideForwardRefTestModule {}\n\n      await scanner.scan(OverrideForwardRefTestModule as any, {\n        overrides: [\n          {\n            moduleToReplace: Overwritten,\n            newModule: Override,\n          },\n        ],\n      });\n\n      expect(overwrittenForwardRefSpy.called).to.be.true;\n      expect(overrideForwardRefSpy.called).to.be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"reflectParamInjectables\" and \"reflectInjectables\"","suites":["DependenciesScanner","reflectDynamicMetadata","when param has prototype"],"updatePoint":{"line":249,"column":72},"line":249,"code":"      it('should call \"reflectParamInjectables\" and \"reflectInjectables\"', () => {\n        const reflectInjectables = sinon\n          .stub(scanner, 'reflectInjectables')\n          .callsFake(() => undefined);\n\n        const reflectParamInjectables = sinon\n          .stub(scanner, 'reflectParamInjectables')\n          .callsFake(() => undefined);\n\n        scanner.reflectDynamicMetadata({ prototype: true } as any, '');\n        expect(reflectInjectables.called).to.be.true;\n        expect(reflectParamInjectables.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"\"reflectParamInjectables\" and \"reflectInjectables\"","suites":["DependenciesScanner","reflectDynamicMetadata","when param has not prototype"],"updatePoint":{"line":264,"column":77},"line":264,"code":"      it('should not call \"\"reflectParamInjectables\" and \"reflectInjectables\"', () => {\n        const reflectInjectables = sinon\n          .stub(scanner, 'reflectInjectables')\n          .callsFake(() => undefined);\n        const reflectParamInjectables = sinon\n          .stub(scanner, 'reflectParamInjectables')\n\n          .callsFake(() => undefined);\n        scanner.reflectDynamicMetadata({} as any, '');\n\n        expect(reflectInjectables.called).to.be.false;\n        expect(reflectParamInjectables.called).to.be.false;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"addInjectable\"","suites":["DependenciesScanner","insertInjectable","when injectable is of type function"],"updatePoint":{"line":312,"column":37},"line":312,"code":"      it('should call \"addInjectable\"', () => {\n        expect(addInjectableStub.calledWith(InjectableCls, token)).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"insertEnhancerMetadataCache\"","suites":["DependenciesScanner","insertInjectable","when injectable is of type function"],"updatePoint":{"line":316,"column":51},"line":316,"code":"      it('should call \"insertEnhancerMetadataCache\"', () => {\n        expect(\n          insertEnhancerMetadataCacheStub.calledWith({\n            moduleToken: token,\n            classRef: HostCls,\n            enhancerInstanceWrapper: instanceWrapper,\n            targetNodeId: instanceWrapper.id,\n            methodKey,\n            subtype,\n          }),\n        ).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not call \"addInjectable\"","suites":["DependenciesScanner","insertInjectable","when injectable is not of type function"],"updatePoint":{"line":343,"column":41},"line":343,"code":"      it('should not call \"addInjectable\"', () => {\n        expect(addInjectableStub.notCalled).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call \"insertEnhancerMetadataCache\"","suites":["DependenciesScanner","insertInjectable","when injectable is not of type function"],"updatePoint":{"line":347,"column":51},"line":347,"code":"      it('should call \"insertEnhancerMetadataCache\"', () => {\n        expect(\n          insertEnhancerMetadataCacheStub.calledWith({\n            moduleToken: token,\n            classRef: HostCls,\n            enhancerRef: injectableRef,\n            methodKey,\n            subtype,\n          }),\n        ).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return undefined","suites":["DependenciesScanner","reflectKeyMetadata"],"updatePoint":{"line":369,"column":31},"line":369,"code":"    it('should return undefined', () => {\n      const result = scanner.reflectKeyMetadata(TestComponent, 'key', 'method');\n      expect(result).to.be.undefined;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an array that consists of 1 element","suites":["DependenciesScanner","reflectKeyMetadata"],"updatePoint":{"line":373,"column":57},"line":373,"code":"    it('should return an array that consists of 1 element', () => {\n      const methodKey = 'method';\n      const result = scanner.reflectKeyMetadata(\n        CompMethod,\n        GUARDS_METADATA,\n        methodKey,\n      );\n      expect(result).to.be.deep.equal({ methodKey, metadata: [Guard] });\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an array that consists of 2 elements","suites":["DependenciesScanner","reflectKeyMetadata"],"updatePoint":{"line":382,"column":58},"line":382,"code":"    it('should return an array that consists of 2 elements', () => {\n      const methodKey = 'method2';\n      const result = scanner.reflectKeyMetadata(\n        CompMethod,\n        GUARDS_METADATA,\n        methodKey,\n      );\n      expect(result).to.be.deep.equal({ methodKey, metadata: [Guard, Guard] });\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call forwardRef() when forwardRef property exists","suites":["DependenciesScanner","insertModule"],"updatePoint":{"line":394,"column":64},"line":394,"code":"    it('should call forwardRef() when forwardRef property exists', () => {\n      sinon.stub(container, 'addModule').returns({} as any);\n\n      const module = { forwardRef: sinon.spy() };\n      scanner.insertModule(module, []);\n\n      expect(module.forwardRef.called).to.be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"InvalidClassModuleException\" exception when supplying a class annotated with `@Injectable()` decorator","suites":["DependenciesScanner","insertModule"],"updatePoint":{"line":402,"column":124},"line":402,"code":"    it('should throw \"InvalidClassModuleException\" exception when supplying a class annotated with `@Injectable()` decorator', () => {\n      sinon.stub(container, 'addModule').returns({} as any);\n\n      expect(scanner.insertModule(TestComponent, [])).to.be.rejectedWith(\n        InvalidClassModuleException,\n      );\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"InvalidClassModuleException\" exception when supplying a class annotated with `@Controller()` decorator","suites":["DependenciesScanner","insertModule"],"updatePoint":{"line":409,"column":124},"line":409,"code":"    it('should throw \"InvalidClassModuleException\" exception when supplying a class annotated with `@Controller()` decorator', () => {\n      sinon.stub(container, 'addModule').returns({} as any);\n\n      expect(scanner.insertModule(TestController, [])).to.be.rejectedWith(\n        InvalidClassModuleException,\n      );\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"InvalidClassModuleException\" exception when supplying a class annotated with (only) `@Catch()` decorator","suites":["DependenciesScanner","insertModule"],"updatePoint":{"line":416,"column":126},"line":416,"code":"    it('should throw \"InvalidClassModuleException\" exception when supplying a class annotated with (only) `@Catch()` decorator', () => {\n      sinon.stub(container, 'addModule').returns({} as any);\n\n      expect(\n        scanner.insertModule(TestExceptionFilterWithoutInjectable, []),\n      ).to.be.rejectedWith(InvalidClassModuleException);\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call forwardRef() when forwardRef property exists","suites":["DependenciesScanner","insertImport"],"updatePoint":{"line":426,"column":64},"line":426,"code":"    it('should call forwardRef() when forwardRef property exists', async () => {\n      const module = { forwardRef: sinon.stub().returns({}) };\n\n      sinon.stub(container, 'addImport').returns({} as any);\n      await scanner.insertImport(module as any, [] as any, 'test');\n      expect(module.forwardRef.called).to.be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw exception","suites":["DependenciesScanner","insertImport","when \"related\" is nil"],"updatePoint":{"line":434,"column":32},"line":434,"code":"      it('should throw exception', async () => {\n        let error;\n        try {\n          await scanner.insertImport(undefined, [] as any, 'test');\n        } catch (e) {\n          error = e;\n        }\n        expect(error).to.not.be.undefined;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call container \"addProvider\" with expected args","suites":["DependenciesScanner","insertProvider","when provider is not custom"],"updatePoint":{"line":450,"column":64},"line":450,"code":"      it('should call container \"addProvider\" with expected args', () => {\n        const provider = {};\n        const expectation = mockContainer\n          .expects('addProvider')\n          .withArgs(provider, token);\n\n        mockContainer.expects('addProvider').callsFake(() => false);\n        scanner.insertProvider(provider as any, token);\n\n        expectation.verify();\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call container \"addProvider\" with expected args","suites":["DependenciesScanner","insertProvider","when provider is custom","and is global"],"updatePoint":{"line":469,"column":66},"line":469,"code":"        it('should call container \"addProvider\" with expected args', () => {\n          const expectation = mockContainer.expects('addProvider').atLeast(1);\n\n          mockContainer.expects('addProvider').callsFake(() => false);\n          scanner.insertProvider(provider, token);\n\n          expectation.verify();\n        });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should push new object to \"applicationProvidersApplyMap\" array","suites":["DependenciesScanner","insertProvider","when provider is custom","and is global"],"updatePoint":{"line":477,"column":74},"line":477,"code":"        it('should push new object to \"applicationProvidersApplyMap\" array', () => {\n          mockContainer.expects('addProvider').callsFake(() => false);\n          scanner.insertProvider(provider, token);\n          const applyMap = (scanner as any).applicationProvidersApplyMap;\n\n          expect(applyMap).to.have.length(1);\n          expect(applyMap[0].moduleKey).to.be.eql(token);\n        });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call container \"addInjectable\" with expected args","suites":["DependenciesScanner","insertProvider","when provider is custom","and is global and request/transient scoped"],"updatePoint":{"line":492,"column":68},"line":492,"code":"        it('should call container \"addInjectable\" with expected args', () => {\n          const expectation = mockContainer.expects('addInjectable').atLeast(1);\n\n          mockContainer.expects('addInjectable').callsFake(() => false);\n          scanner.insertProvider(provider, token);\n\n          expectation.verify();\n        });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should call container \"addProvider\" with expected args","suites":["DependenciesScanner","insertProvider","when provider is custom","and is not global"],"updatePoint":{"line":506,"column":66},"line":506,"code":"        it('should call container \"addProvider\" with expected args', () => {\n          const expectation = mockContainer\n            .expects('addProvider')\n            .withArgs(component, token);\n\n          mockContainer.expects('addProvider').callsFake(() => false);\n          scanner.insertProvider(component, token);\n\n          expectation.verify();\n        });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should not push new object to \"applicationProvidersApplyMap\" array","suites":["DependenciesScanner","insertProvider","when provider is custom","and is not global"],"updatePoint":{"line":516,"column":78},"line":516,"code":"        it('should not push new object to \"applicationProvidersApplyMap\" array', () => {\n          expect((scanner as any).applicationProvidersApplyMap).to.have.length(\n            0,\n          );\n\n          mockContainer.expects('addProvider').callsFake(() => false);\n          scanner.insertProvider(component, token);\n          expect((scanner as any).applicationProvidersApplyMap).to.have.length(\n            0,\n          );\n        });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply each provider","suites":["DependenciesScanner","applyApplicationProviders"],"updatePoint":{"line":531,"column":34},"line":531,"code":"    it('should apply each provider', () => {\n      const provider = {\n        moduleKey: 'moduleToken',\n        providerKey: 'providerToken',\n        type: APP_GUARD,\n      };\n      (scanner as any).applicationProvidersApplyMap = [provider];\n\n      const expectedInstance = {};\n      const instanceWrapper = {\n        instance: expectedInstance,\n      } as unknown as InstanceWrapper;\n      mockContainer.expects('getModules').callsFake(() => ({\n        get: () => ({\n          providers: { get: () => instanceWrapper },\n        }),\n      }));\n\n      const applySpy = sinon.spy();\n      sinon.stub(scanner, 'getApplyProvidersMap').callsFake(() => ({\n        [provider.type]: applySpy,\n      }));\n\n      const insertAttachedEnhancerStub = sinon.stub(\n        graphInspector,\n        'insertAttachedEnhancer',\n      );\n\n      scanner.applyApplicationProviders();\n\n      expect(applySpy.called).to.be.true;\n      expect(applySpy.calledWith(expectedInstance)).to.be.true;\n      expect(insertAttachedEnhancerStub.calledWith(instanceWrapper)).to.be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should apply each globally scoped provider","suites":["DependenciesScanner","applyApplicationProviders"],"updatePoint":{"line":565,"column":50},"line":565,"code":"    it('should apply each globally scoped provider', () => {\n      const provider = {\n        moduleKey: 'moduleToken',\n        providerKey: 'providerToken',\n        type: APP_GUARD,\n        scope: Scope.REQUEST,\n      };\n      (scanner as any).applicationProvidersApplyMap = [provider];\n\n      const expectedInstanceWrapper = new InstanceWrapper();\n      mockContainer.expects('getModules').callsFake(() => ({\n        get: () => ({\n          injectables: { get: () => expectedInstanceWrapper },\n        }),\n      }));\n\n      const applySpy = sinon.spy();\n      sinon.stub(scanner, 'getApplyRequestProvidersMap').callsFake(() => ({\n        [provider.type]: applySpy,\n      }));\n\n      const insertAttachedEnhancerStub = sinon.stub(\n        graphInspector,\n        'insertAttachedEnhancer',\n      );\n\n      scanner.applyApplicationProviders();\n\n      expect(applySpy.called).to.be.true;\n      expect(applySpy.calledWith(expectedInstanceWrapper)).to.be.true;\n      expect(insertAttachedEnhancerStub.calledWith(expectedInstanceWrapper)).to\n        .be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should add enhancers metadata to every controller and every entry provider","suites":["DependenciesScanner","addScopedEnhancersMetadata"],"updatePoint":{"line":608,"column":82},"line":608,"code":"    it('should add enhancers metadata to every controller and every entry provider', () => {\n      (scanner as any).applicationProvidersApplyMap = [provider];\n\n      const instance = new InstanceWrapper({ name: 'test' });\n      const controllers = new Map();\n      const providers = new Map();\n\n      const fakeController = new InstanceWrapper();\n      const fakeProvider = new InstanceWrapper();\n\n      const providerToken = 'entryProvider';\n      controllers.set('test', fakeController);\n      providers.set(providerToken, fakeProvider);\n\n      mockContainer.expects('getModules').callsFake(() => ({\n        get: () => ({\n          injectables: { get: () => instance },\n          controllers,\n          entryProviders: Array.from(providers.values()),\n        }),\n        values() {\n          return [this.get()];\n        },\n      }));\n\n      const addEnhancerMetadataControllerSpy = sinon.spy(\n        fakeController,\n        'addEnhancerMetadata',\n      );\n      const addEnhancerMetadataProviderSpy = sinon.spy(\n        fakeProvider,\n        'addEnhancerMetadata',\n      );\n      scanner.addScopedEnhancersMetadata();\n\n      expect(addEnhancerMetadataControllerSpy.called).to.be.true;\n      expect(addEnhancerMetadataControllerSpy.calledWith(instance)).to.be.true;\n      expect(addEnhancerMetadataProviderSpy.called).to.be.true;\n      expect(addEnhancerMetadataProviderSpy.calledWith(instance)).to.be.true;\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalInterceptor\"","suites":["DependenciesScanner","getApplyProvidersMap","when token is "],"updatePoint":{"line":652,"column":37},"line":652,"code":"      it('call \"addGlobalInterceptor\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalInterceptor',\n        );\n        scanner.getApplyProvidersMap()[APP_INTERCEPTOR](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalGuard\"","suites":["DependenciesScanner","getApplyProvidersMap","when token is "],"updatePoint":{"line":662,"column":31},"line":662,"code":"      it('call \"addGlobalGuard\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalGuard',\n        );\n        scanner.getApplyProvidersMap()[APP_GUARD](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalPipe\"","suites":["DependenciesScanner","getApplyProvidersMap","when token is "],"updatePoint":{"line":672,"column":30},"line":672,"code":"      it('call \"addGlobalPipe\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalPipe',\n        );\n        scanner.getApplyProvidersMap()[APP_PIPE](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalFilter\"","suites":["DependenciesScanner","getApplyProvidersMap","when token is "],"updatePoint":{"line":682,"column":32},"line":682,"code":"      it('call \"addGlobalFilter\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalFilter',\n        );\n        scanner.getApplyProvidersMap()[APP_FILTER](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalRequestInterceptor\"","suites":["DependenciesScanner","getApplyRequestProvidersMap","when token is "],"updatePoint":{"line":694,"column":44},"line":694,"code":"      it('call \"addGlobalRequestInterceptor\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalRequestInterceptor',\n        );\n        scanner.getApplyRequestProvidersMap()[APP_INTERCEPTOR](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalRequestGuard\"","suites":["DependenciesScanner","getApplyRequestProvidersMap","when token is "],"updatePoint":{"line":704,"column":38},"line":704,"code":"      it('call \"addGlobalRequestGuard\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalRequestGuard',\n        );\n        scanner.getApplyRequestProvidersMap()[APP_GUARD](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalRequestPipe\"","suites":["DependenciesScanner","getApplyRequestProvidersMap","when token is "],"updatePoint":{"line":714,"column":37},"line":714,"code":"      it('call \"addGlobalRequestPipe\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalRequestPipe',\n        );\n        scanner.getApplyRequestProvidersMap()[APP_PIPE](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"call \"addGlobalRequestFilter\"","suites":["DependenciesScanner","getApplyRequestProvidersMap","when token is "],"updatePoint":{"line":724,"column":39},"line":724,"code":"      it('call \"addGlobalRequestFilter\"', () => {\n        const addSpy = sinon.spy(\n          (scanner as any).applicationConfig,\n          'addGlobalRequestFilter',\n        );\n        scanner.getApplyRequestProvidersMap()[APP_FILTER](null);\n        expect(addSpy.called).to.be.true;\n      });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an exception when the imports array includes undefined","suites":["DependenciesScanner","scanForModules"],"updatePoint":{"line":735,"column":75},"line":735,"code":"    it('should throw an exception when the imports array includes undefined', () => {\n      try {\n        scanner.scanForModules({\n          moduleDefinition: UndefinedModule,\n          scope: [UndefinedModule],\n        });\n      } catch (exception) {\n        expect(exception instanceof UndefinedModuleException).to.be.true;\n      }\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw an exception when the imports array includes an invalid value","suites":["DependenciesScanner","scanForModules"],"updatePoint":{"line":745,"column":82},"line":745,"code":"    it('should throw an exception when the imports array includes an invalid value', () => {\n      try {\n        scanner.scanForModules({\n          moduleDefinition: InvalidModule,\n          scope: [InvalidModule],\n        });\n      } catch (exception) {\n        expect(exception instanceof InvalidModuleException).to.be.true;\n      }\n    });","file":"scanner.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata","suites":["Reflector","get"],"updatePoint":{"line":11,"column":31},"line":11,"code":"    it('should reflect metadata', () => {\n      const key = 'key';\n      const value = 'value';\n      Reflect.defineMetadata(key, value, Test);\n      expect(reflector.get(key, Test)).to.eql(value);\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata of all targets","suites":["Reflector","getAll"],"updatePoint":{"line":20,"column":46},"line":20,"code":"    it('should reflect metadata of all targets', () => {\n      const key = 'key';\n      const value = 'value';\n      Reflect.defineMetadata(key, value, Test);\n      expect(reflector.getAll(key, [Test])).to.eql([value]);\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should return an empty array when there are no targets","suites":["Reflector","getAllAndMerge"],"updatePoint":{"line":29,"column":62},"line":29,"code":"    it('should return an empty array when there are no targets', () => {\n      const key = 'key';\n      expect(reflector.getAllAndMerge(key, [])).to.be.empty;\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata of all targets and concat arrays","suites":["Reflector","getAllAndMerge"],"updatePoint":{"line":33,"column":64},"line":33,"code":"    it('should reflect metadata of all targets and concat arrays', () => {\n      const key = 'key';\n      const value = 'value';\n      Reflect.defineMetadata(key, [value], Test);\n      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql([\n        value,\n        value,\n      ]);\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata of all targets and create an array","suites":["Reflector","getAllAndMerge"],"updatePoint":{"line":42,"column":66},"line":42,"code":"    it('should reflect metadata of all targets and create an array', () => {\n      const key = 'key';\n      const value = 'value';\n      Reflect.defineMetadata(key, value, Test);\n      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql([\n        value,\n        value,\n      ]);\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata of all targets and merge an object","suites":["Reflector","getAllAndMerge"],"updatePoint":{"line":51,"column":66},"line":51,"code":"    it('should reflect metadata of all targets and merge an object', () => {\n      const key = 'key';\n      const value = { test: 'test' };\n      Reflect.defineMetadata(key, value, Test);\n      expect(reflector.getAllAndMerge(key, [Test, Test])).to.eql({\n        ...value,\n      });\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should reflect metadata of all targets and return a first not undefined value","suites":["Reflector","getAllAndOverride"],"updatePoint":{"line":62,"column":85},"line":62,"code":"    it('should reflect metadata of all targets and return a first not undefined value', () => {\n      const key = 'key';\n      const value = 'value';\n      Reflect.defineMetadata(key, value, Test);\n      expect(reflector.getAllAndOverride(key, [Test, Test])).to.eql(value);\n    });","file":"services/reflector.service.spec.ts","skipped":false,"dir":"packages/core/test"},{"name":"should throw \"InvalidGrpcServiceException\"","suites":["ClientGrpcProxy","getService","when \"grpcClient[name]\" is nil"],"updatePoint":{"line":43,"column":52},"line":43,"code":"      it('should throw \"InvalidGrpcServiceException\"', () => {\n        (client as any).grpcClient = {};\n        expect(() => client.getService('test')).to.throw(\n          InvalidGrpcServiceException,\n        );\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw \"InvalidGrpcServiceException\" (multiple proto)","suites":["ClientGrpcProxy","getService","when \"grpcClient[name]\" is nil"],"updatePoint":{"line":50,"column":69},"line":50,"code":"      it('should throw \"InvalidGrpcServiceException\" (multiple proto)', () => {\n        (clientMulti as any).grpcClient = {};\n\n        expect(() => clientMulti.getService('test')).to.throw(\n          InvalidGrpcServiceException,\n        );\n\n        expect(() => clientMulti.getService('test2')).to.throw(\n          InvalidGrpcServiceException,\n        );\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create grpcService","suites":["ClientGrpcProxy","getService","when \"grpcClient[name]\" is not nil"],"updatePoint":{"line":63,"column":35},"line":63,"code":"      it('should create grpcService', () => {\n        (client as any).grpcClients[0] = {\n          test: GrpcService,\n        };\n        expect(() => client.getService('test')).to.not.throw(\n          InvalidGrpcServiceException,\n        );\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create grpcService","suites":["ClientGrpcProxy","getService","when \"grpcClient[name]\" is not nil","when \"grpcClient[name]\" is not nil (multiple proto)"],"updatePoint":{"line":73,"column":37},"line":73,"code":"        it('should create grpcService', () => {\n          (clientMulti as any).grpcClients[0] = {\n            test: GrpcService,\n            test2: GrpcService,\n          };\n          expect(() => clientMulti.getService('test')).to.not.throw(\n            InvalidGrpcServiceException,\n          );\n          expect(() => clientMulti.getService('test2')).to.not.throw(\n            InvalidGrpcServiceException,\n          );\n        });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createStreamServiceMethod\"","suites":["ClientGrpcProxy","createServiceMethod","when method is a response stream"],"updatePoint":{"line":92,"column":49},"line":92,"code":"      it('should call \"createStreamServiceMethod\"', () => {\n        const cln = { [methodName]: { responseStream: true } };\n        const spy = sinon.spy(client, 'createStreamServiceMethod');\n        client.createServiceMethod(cln, methodName);\n\n        expect(spy.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createUnaryServiceMethod\"","suites":["ClientGrpcProxy","createServiceMethod","when method is not a response stream"],"updatePoint":{"line":101,"column":48},"line":101,"code":"      it('should call \"createUnaryServiceMethod\"', () => {\n        const cln = { [methodName]: { responseStream: false } };\n        const spy = sinon.spy(client, 'createUnaryServiceMethod');\n        client.createServiceMethod(cln, methodName);\n\n        expect(spy.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return observable","suites":["ClientGrpcProxy","createStreamServiceMethod"],"updatePoint":{"line":112,"column":32},"line":112,"code":"    it('should return observable', () => {\n      const methodKey = 'method';\n      const fn = client.createStreamServiceMethod(\n        { [methodKey]: {} },\n        methodKey,\n      );\n      expect(fn()).to.be.instanceof(Observable);\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call native method","suites":["ClientGrpcProxy","createStreamServiceMethod","on subscribe"],"updatePoint":{"line":130,"column":35},"line":130,"code":"      it('should call native method', () => {\n        const spy = sinon.spy(obj, methodName);\n        stream$.subscribe({\n          next: () => ({}),\n          error: () => ({}),\n        });\n\n        expect(spy.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to request upstream","suites":["ClientGrpcProxy","createStreamServiceMethod","when stream request"],"updatePoint":{"line":157,"column":46},"line":157,"code":"      it('should subscribe to request upstream', () => {\n        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');\n        stream$.subscribe({\n          next: () => ({}),\n          error: () => ({}),\n        });\n        upstream.next({ test: true });\n\n        expect(writeSpy.called).to.be.true;\n        expect(upstreamSubscribe.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"propagates server errors","suites":["ClientGrpcProxy","createStreamServiceMethod","flow-control"],"updatePoint":{"line":202,"column":34},"line":202,"code":"      it('propagates server errors', () => {\n        const err = new Error('something happened');\n        stream$.subscribe({\n          next: dataSpy,\n          error: errorSpy,\n          complete: completeSpy,\n        });\n\n        eventCallbacks.data('a');\n        eventCallbacks.data('b');\n        callMock.finished = true;\n        eventCallbacks.error(err);\n        eventCallbacks.data('c');\n\n        expect(Object.keys(eventCallbacks).length).to.eq(3);\n        expect(dataSpy.args).to.eql([['a'], ['b']]);\n        expect(errorSpy.args[0][0]).to.eql(err);\n        expect(completeSpy.called).to.be.false;\n        expect(callMock.cancel.called).to.be.false;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"handles client side cancel","suites":["ClientGrpcProxy","createStreamServiceMethod","flow-control"],"updatePoint":{"line":223,"column":36},"line":223,"code":"      it('handles client side cancel', () => {\n        const grpcServerCancelErrMock = {\n          details: 'Cancelled',\n        };\n        const subscription = stream$.subscribe({\n          next: dataSpy,\n          error: errorSpy,\n        });\n\n        eventCallbacks.data('a');\n        eventCallbacks.data('b');\n        subscription.unsubscribe();\n        eventCallbacks.error(grpcServerCancelErrMock);\n        eventCallbacks.end();\n        eventCallbacks.data('c');\n\n        expect(callMock.cancel.called, 'should call call.cancel()').to.be.true;\n        expect(callMock.destroy.called, 'should call call.destroy()').to.be\n          .true;\n        expect(dataSpy.args).to.eql([['a'], ['b']]);\n        expect(errorSpy.called, 'should not error if client canceled').to.be\n          .false;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return observable","suites":["ClientGrpcProxy","createUnaryServiceMethod"],"updatePoint":{"line":250,"column":32},"line":250,"code":"    it('should return observable', () => {\n      const methodKey = 'method';\n      const fn = client.createUnaryServiceMethod(\n        { [methodKey]: {} },\n        methodKey,\n      );\n      expect(fn()).to.be.instanceof(Observable);\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call native method","suites":["ClientGrpcProxy","createUnaryServiceMethod","on subscribe"],"updatePoint":{"line":276,"column":35},"line":276,"code":"      it('should call native method', () => {\n        const spy = sinon.spy(obj, methodName);\n        stream$.subscribe({\n          next: () => ({}),\n          error: () => ({}),\n        });\n\n        expect(spy.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to request upstream","suites":["ClientGrpcProxy","createUnaryServiceMethod","when stream request"],"updatePoint":{"line":320,"column":46},"line":320,"code":"      it('should subscribe to request upstream', () => {\n        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');\n        stream$.subscribe({\n          next: () => ({}),\n          error: () => ({}),\n        });\n        upstream.next({ test: true });\n\n        expect(writeSpy.called).to.be.true;\n        expect(upstreamSubscribe.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should cancel call on client unsubscribe","suites":["ClientGrpcProxy","createUnaryServiceMethod","flow-control"],"updatePoint":{"line":334,"column":50},"line":334,"code":"      it('should cancel call on client unsubscribe', () => {\n        const methodName = 'm';\n\n        const dataSpy = sinon.spy();\n        const errorSpy = sinon.spy();\n        const completeSpy = sinon.spy();\n\n        const callMock = {\n          cancel: sinon.spy(),\n          finished: false,\n        };\n\n        let handler: (error: any, data: any) => void;\n\n        const obj = {\n          [methodName]: (callback, ...args) => {\n            handler = callback;\n\n            return callMock;\n          },\n        };\n\n        const stream$ = client.createUnaryServiceMethod(obj, methodName)();\n\n        const subscription = stream$.subscribe({\n          next: dataSpy,\n          error: errorSpy,\n          complete: completeSpy,\n        });\n\n        subscription.unsubscribe();\n        handler(null, 'a');\n\n        expect(dataSpy.called).to.be.false;\n        expect(errorSpy.called).to.be.false;\n        expect(completeSpy.called).to.be.false;\n        expect(callMock.cancel.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should cancel call on client unsubscribe case client streaming","suites":["ClientGrpcProxy","createUnaryServiceMethod","flow-control"],"updatePoint":{"line":373,"column":72},"line":373,"code":"      it('should cancel call on client unsubscribe case client streaming', () => {\n        const methodName = 'm';\n\n        const dataSpy = sinon.spy();\n        const errorSpy = sinon.spy();\n        const completeSpy = sinon.spy();\n        const writeSpy = sinon.spy();\n\n        const callMock = {\n          cancel: sinon.spy(),\n          finished: false,\n          write: writeSpy,\n        };\n\n        let handler: (error: any, data: any) => void;\n        const obj = {\n          [methodName]: callback => {\n            handler = callback;\n            return callMock;\n          },\n        };\n\n        (obj[methodName] as any).requestStream = true;\n        const upstream: Subject<unknown> = new Subject();\n        const stream$: Observable<any> = client.createUnaryServiceMethod(\n          obj,\n          methodName,\n        )(upstream);\n\n        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');\n        stream$.subscribe({\n          next: () => ({}),\n          error: () => ({}),\n        });\n        upstream.next({ test: true });\n\n        const subscription = stream$.subscribe({\n          next: dataSpy,\n          error: errorSpy,\n          complete: completeSpy,\n        });\n\n        subscription.unsubscribe();\n        handler(null, 'a');\n\n        expect(dataSpy.called).to.be.false;\n        expect(writeSpy.called).to.be.true;\n        expect(errorSpy.called).to.be.false;\n        expect(completeSpy.called).to.be.false;\n        expect(callMock.cancel.called).to.be.true;\n        expect(upstreamSubscribe.called).to.be.true;\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw \"InvalidGrpcPackageException\"","suites":["ClientGrpcProxy","createClients","when package does not exist"],"updatePoint":{"line":430,"column":52},"line":430,"code":"      it('should throw \"InvalidGrpcPackageException\"', () => {\n        sinon.stub(client, 'lookupPackage').callsFake(() => null);\n        (client as any).logger = new NoopLogger();\n\n        try {\n          client.createClients();\n        } catch (err) {\n          expect(err).to.be.instanceof(InvalidGrpcPackageException);\n        }\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw InvalidProtoDefinitionException","suites":["ClientGrpcProxy","loadProto","when proto is invalid"],"updatePoint":{"line":445,"column":54},"line":445,"code":"      it('should throw InvalidProtoDefinitionException', () => {\n        sinon.stub(client, 'getOptionsProp' as any).callsFake(() => {\n          throw new Error();\n        });\n        (client as any).logger = new NoopLogger();\n        expect(() => client.loadProto()).to.throws(\n          InvalidProtoDefinitionException,\n        );\n      });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"close\" method","suites":["ClientGrpcProxy","close"],"updatePoint":{"line":457,"column":34},"line":457,"code":"    it('should call \"close\" method', () => {\n      const grpcClient = { close: sinon.spy() };\n      (client as any).grpcClients[0] = grpcClient;\n\n      client.close();\n      expect(grpcClient.close.called).to.be.true;\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception","suites":["ClientGrpcProxy","publish"],"updatePoint":{"line":467,"column":30},"line":467,"code":"    it('should throw exception', () => {\n      expect(() => client['publish'](null, null)).to.throws(Error);\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception","suites":["ClientGrpcProxy","send"],"updatePoint":{"line":473,"column":30},"line":473,"code":"    it('should throw exception', () => {\n      expect(() => client.send(null, null)).to.throws(Error);\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception","suites":["ClientGrpcProxy","connect"],"updatePoint":{"line":479,"column":30},"line":479,"code":"    it('should throw exception', () => {\n      client.connect().catch(error => expect(error).to.be.instanceof(Error));\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception","suites":["ClientGrpcProxy","dispatchEvent"],"updatePoint":{"line":485,"column":30},"line":485,"code":"    it('should throw exception', () => {\n      client['dispatchEvent'](null).catch(error =>\n        expect(error).to.be.instanceof(Error),\n      );\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return root package in case package name is not defined","suites":["ClientGrpcProxy","lookupPackage"],"updatePoint":{"line":493,"column":70},"line":493,"code":"    it('should return root package in case package name is not defined', () => {\n      const root = {};\n\n      expect(client.lookupPackage(root, undefined)).to.be.equal(root);\n      expect(client.lookupPackage(root, '')).to.be.equal(root);\n    });","file":"client/client-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should accept a custom logCreator in client options","suites":["ClientKafka","createClient"],"updatePoint":{"line":204,"column":59},"line":204,"code":"    it(`should accept a custom logCreator in client options`, () => {\n      const logCreatorSpy = sinon.spy(() => 'test');\n      const logCreator = () => logCreatorSpy;\n\n      client = new ClientKafka({\n        client: {\n          brokers: [],\n          logCreator,\n        },\n      });\n\n      const logger = client.createClient().logger();\n\n      logger.info({ namespace: '', level: 1, log: 'test' });\n\n      expect(logCreatorSpy.called).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create an array of response patterns","suites":["ClientKafka","subscribeToResponseOf"],"updatePoint":{"line":235,"column":51},"line":235,"code":"    it(`should create an array of response patterns`, () => {\n      client.subscribeToResponseOf(topic);\n\n      expect(normalizePatternSpy.calledWith(topic)).to.be.true;\n      expect(getResponsePatternNameSpy.calledWith(topic)).to.be.true;\n      expect(client['responsePatterns']).to.not.be.empty;\n      expect(client['responsePatterns'][0]).to.eq(replyTopic);\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close server","suites":["ClientKafka","close"],"updatePoint":{"line":256,"column":27},"line":256,"code":"    it('should close server', async () => {\n      await client.close();\n\n      expect(consumer.disconnect.calledOnce).to.be.true;\n      expect(producer.disconnect.calledOnce).to.be.true;\n      expect((client as any).consumer).to.be.null;\n      expect((client as any).producer).to.be.null;\n      expect((client as any).client).to.be.null;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should expect the connection to be created","suites":["ClientKafka","connect","consumer and producer"],"updatePoint":{"line":283,"column":52},"line":283,"code":"      it('should expect the connection to be created', async () => {\n        const connection = await client.connect();\n\n        expect(createClientStub.calledOnce).to.be.true;\n        expect(producerStub.calledOnce).to.be.true;\n\n        expect(consumerStub.calledOnce).to.be.true;\n\n        expect(on.calledOnce).to.be.true;\n        expect(client['consumerAssignments']).to.be.empty;\n\n        expect(connect.calledTwice).to.be.true;\n\n        expect(bindTopicsStub.calledOnce).to.be.true;\n        expect(connection).to.deep.equal(producerStub());\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should expect the connection to be reused","suites":["ClientKafka","connect","consumer and producer"],"updatePoint":{"line":300,"column":51},"line":300,"code":"      it('should expect the connection to be reused', async () => {\n        (client as any).initialized = Promise.resolve({});\n\n        await client.connect();\n\n        expect(createClientStub.calledOnce).to.be.false;\n        expect(producerStub.calledOnce).to.be.false;\n        expect(consumerStub.calledOnce).to.be.false;\n\n        expect(on.calledOnce).to.be.false;\n        expect(client['consumerAssignments']).to.be.empty;\n\n        expect(connect.calledTwice).to.be.false;\n\n        expect(bindTopicsStub.calledOnce).to.be.false;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should expect the connection to be created","suites":["ClientKafka","connect","producer only mode"],"updatePoint":{"line":330,"column":52},"line":330,"code":"      it('should expect the connection to be created', async () => {\n        const connection = await client.connect();\n\n        expect(createClientStub.calledOnce).to.be.true;\n        expect(producerStub.calledOnce).to.be.true;\n\n        expect(consumerStub.calledOnce).to.be.false;\n\n        expect(on.calledOnce).to.be.false;\n        expect(client['consumerAssignments']).to.be.empty;\n\n        expect(connect.calledOnce).to.be.true;\n\n        expect(bindTopicsStub.calledOnce).to.be.false;\n        expect(connection).to.deep.equal(producerStub());\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should expect the connection to be reused","suites":["ClientKafka","connect","producer only mode"],"updatePoint":{"line":347,"column":51},"line":347,"code":"      it('should expect the connection to be reused', async () => {\n        (client as any).initialized = Promise.resolve({});\n\n        await client.connect();\n\n        expect(createClientStub.calledOnce).to.be.false;\n        expect(producerStub.calledOnce).to.be.false;\n        expect(consumerStub.calledOnce).to.be.false;\n\n        expect(on.calledOnce).to.be.false;\n        expect(client['consumerAssignments']).to.be.empty;\n\n        expect(connect.calledTwice).to.be.false;\n\n        expect(bindTopicsStub.calledOnce).to.be.false;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should update consumer assignments","suites":["ClientKafka","setConsumerAssignments"],"updatePoint":{"line":367,"column":42},"line":367,"code":"    it('should update consumer assignments', async () => {\n      await client.connect();\n\n      const consumerAssignments: ConsumerGroupJoinEvent = {\n        id: 'id',\n        type: 'type',\n        timestamp: 1234567890,\n        payload: {\n          duration: 20,\n          groupId: 'group-id',\n          isLeader: true,\n          leaderId: 'member-1',\n          groupProtocol: 'RoundRobin',\n          memberId: 'member-1',\n          memberAssignment: {\n            'topic-a': [0, 1, 2],\n            'topic-b': [3, 4, 5],\n          },\n        },\n      };\n\n      client['setConsumerAssignments'](consumerAssignments);\n\n      expect(client['consumerAssignments']).to.deep.eq(\n        // consumerAssignments.payload.memberAssignment,\n        {\n          'topic-a': 0,\n          'topic-b': 3,\n        },\n      );\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not update consumer assignments if there are no partitions assigned to consumer","suites":["ClientKafka","setConsumerAssignments"],"updatePoint":{"line":399,"column":94},"line":399,"code":"    it('should not update consumer assignments if there are no partitions assigned to consumer', async () => {\n      await client.connect();\n\n      const consumerAssignments: ConsumerGroupJoinEvent = {\n        id: 'id',\n        type: 'type',\n        timestamp: 1234567890,\n        payload: {\n          duration: 20,\n          groupId: 'group-id',\n          isLeader: true,\n          leaderId: 'member-1',\n          groupProtocol: 'RoundRobin',\n          memberId: 'member-1',\n          memberAssignment: {\n            'topic-a': [],\n            'topic-b': [3, 4, 5],\n          },\n        },\n      };\n\n      client['setConsumerAssignments'](consumerAssignments);\n\n      expect(client['consumerAssignments']).to.deep.eq({\n        'topic-b': 3,\n      });\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind topics from response patterns","suites":["ClientKafka","bindTopics"],"updatePoint":{"line":429,"column":49},"line":429,"code":"    it('should bind topics from response patterns', async () => {\n      (client as any).responsePatterns = [replyTopic];\n      (client as any).consumer = kafkaClient.consumer();\n\n      await client.bindTopics();\n\n      expect(subscribe.calledOnce).to.be.true;\n      expect(\n        subscribe.calledWith({\n          topics: [replyTopic],\n        }),\n      ).to.be.true;\n      expect(run.calledOnce).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind topics from response patterns with options","suites":["ClientKafka","bindTopics"],"updatePoint":{"line":444,"column":62},"line":444,"code":"    it('should bind topics from response patterns with options', async () => {\n      (client as any).responsePatterns = [replyTopic];\n      (client as any).consumer = kafkaClient.consumer();\n      (client as any).options.subscribe = {};\n      (client as any).options.subscribe.fromBeginning = true;\n\n      await client.bindTopics();\n\n      expect(subscribe.calledOnce).to.be.true;\n      expect(\n        subscribe.calledWith({\n          topics: [replyTopic],\n          fromBeginning: true,\n        }),\n      ).to.be.true;\n      expect(run.calledOnce).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with expected arguments","suites":["ClientKafka","createResponseCallback","not completed"],"updatePoint":{"line":473,"column":54},"line":473,"code":"      it('should call callback with expected arguments', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: messageValue,\n          }),\n        ).to.be.true;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with dispose param","suites":["ClientKafka","createResponseCallback","disposed and \"id\" is correct"],"updatePoint":{"line":492,"column":49},"line":492,"code":"      it('should call callback with dispose param', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            isDisposed: true,\n            response: deserializedPayloadDisposed.message.value,\n            err: undefined,\n          }),\n        ).to.be.true;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with error param","suites":["ClientKafka","createResponseCallback","error and \"id\" is correct"],"updatePoint":{"line":512,"column":47},"line":512,"code":"      it('should call callback with error param', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            isDisposed: true,\n            response: undefined,\n            err: NO_MESSAGE_HANDLER,\n          }),\n        ).to.be.true;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call callback","suites":["ClientKafka","createResponseCallback","without \"id\""],"updatePoint":{"line":532,"column":34},"line":532,"code":"      it('should not call callback', () => {\n        expect(callback.called).to.be.false;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call callback","suites":["ClientKafka","createResponseCallback","disposed and \"id\" is incorrect"],"updatePoint":{"line":546,"column":34},"line":546,"code":"      it('should not call callback', () => {\n        expect(callback.called).to.be.false;\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientKafka","dispatchEvent"],"updatePoint":{"line":569,"column":29},"line":569,"code":"    it('should publish packet', async () => {\n      sinon.stub(client as any, 'producer').value({\n        send: sendSpy,\n      });\n\n      await client['dispatchEvent'](eventMessage);\n\n      expect(sendSpy.calledOnce).to.be.true;\n      expect(sendSpy.args[0][0].topic).to.eq(topic);\n      expect(sendSpy.args[0][0].messages).to.not.be.empty;\n\n      const sentMessage = sendSpy.args[0][0].messages[0];\n\n      expect(sentMessage.value).to.eq(messageValue);\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error","suites":["ClientKafka","dispatchEvent"],"updatePoint":{"line":585,"column":26},"line":585,"code":"    it('should throw error', async () => {\n      sinon.stub(client as any, 'producer').value({\n        send: sendStub,\n      });\n\n      client['dispatchEvent'](eventMessage).catch(err =>\n        expect(err).to.be.instanceOf(Error),\n      );\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should get consumer assignments","suites":["ClientKafka","getConsumerAssignments"],"updatePoint":{"line":597,"column":39},"line":597,"code":"    it('should get consumer assignments', () => {\n      client['consumerAssignments'] = {\n        [replyTopic]: 0,\n      };\n\n      const result = client.getConsumerAssignments();\n\n      expect(result).to.deep.eq(client['consumerAssignments']);\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should get reply partition","suites":["ClientKafka","getReplyTopicPartition"],"updatePoint":{"line":609,"column":34},"line":609,"code":"    it('should get reply partition', () => {\n      client['consumerAssignments'] = {\n        [replyTopic]: 0,\n      };\n\n      const result = client['getReplyTopicPartition'](replyTopic);\n\n      expect(result).to.eq('0');\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error when the topic is not being consumed","suites":["ClientKafka","getReplyTopicPartition"],"updatePoint":{"line":619,"column":63},"line":619,"code":"    it('should throw error when the topic is not being consumed', () => {\n      client['consumerAssignments'] = {};\n\n      expect(() => client['getReplyTopicPartition'](replyTopic)).to.throw(\n        InvalidKafkaClientTopicException,\n      );\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error when the topic is not being consumed","suites":["ClientKafka","getReplyTopicPartition"],"updatePoint":{"line":627,"column":63},"line":627,"code":"    it('should throw error when the topic is not being consumed', () => {\n      client['consumerAssignments'] = {\n        [topic]: undefined,\n      };\n\n      expect(() => client['getReplyTopicPartition'](replyTopic)).to.throw(\n        InvalidKafkaClientTopicException,\n      );\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should assign a packet id","suites":["ClientKafka","publish"],"updatePoint":{"line":685,"column":33},"line":685,"code":"    it('should assign a packet id', async () => {\n      await client['publish'](readPacket, callback);\n      expect(assignPacketIdStub.calledWith(readPacket)).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should normalize the pattern","suites":["ClientKafka","publish"],"updatePoint":{"line":690,"column":36},"line":690,"code":"    it('should normalize the pattern', async () => {\n      await client['publish'](readPacket, callback);\n      expect(normalizePatternSpy.calledWith(topic)).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should get the reply pattern","suites":["ClientKafka","publish"],"updatePoint":{"line":695,"column":36},"line":695,"code":"    it('should get the reply pattern', async () => {\n      await client['publish'](readPacket, callback);\n      expect(getResponsePatternNameSpy.calledWith(topic)).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should get the reply partition","suites":["ClientKafka","publish"],"updatePoint":{"line":700,"column":38},"line":700,"code":"    it('should get the reply partition', async () => {\n      await client['publish'](readPacket, callback);\n      expect(getReplyTopicPartitionSpy.calledWith(replyTopic)).to.be.true;\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should add the callback to the routing map","suites":["ClientKafka","publish"],"updatePoint":{"line":705,"column":50},"line":705,"code":"    it('should add the callback to the routing map', async () => {\n      await client['publish'](readPacket, callback);\n      expect(routingMapSetSpy.calledOnce).to.be.true;\n      expect(routingMapSetSpy.args[0][0]).to.eq(correlationId);\n      expect(routingMapSetSpy.args[0][1]).to.eq(callback);\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send the message with headers","suites":["ClientKafka","publish"],"updatePoint":{"line":712,"column":44},"line":712,"code":"    it('should send the message with headers', async () => {\n      await client['publish'](readPacket, callback);\n\n      expect(sendSpy.calledOnce).to.be.true;\n      expect(sendSpy.args[0][0].topic).to.eq(topic);\n      expect(sendSpy.args[0][0].messages).to.not.be.empty;\n\n      const sentMessage = sendSpy.args[0][0].messages[0];\n\n      expect(sentMessage.value).to.eq(messageValue);\n      expect(sentMessage.headers).to.not.be.empty;\n      expect(sentMessage.headers[KafkaHeaders.CORRELATION_ID]).to.eq(\n        correlationId,\n      );\n      expect(sentMessage.headers[KafkaHeaders.REPLY_TOPIC]).to.eq(replyTopic);\n      expect(sentMessage.headers[KafkaHeaders.REPLY_PARTITION]).to.eq(\n        replyPartition,\n      );\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should remove callback from routing map when unsubscribe","suites":["ClientKafka","publish"],"updatePoint":{"line":732,"column":64},"line":732,"code":"    it('should remove callback from routing map when unsubscribe', async () => {\n      client['publish'](readPacket, callback)();\n      expect(client['routingMap'].has(correlationId)).to.be.false;\n      expect(client['routingMap'].size).to.eq(0);\n    });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ClientKafka","publish","on error"],"updatePoint":{"line":756,"column":30},"line":756,"code":"      it('should call callback', async () => {\n        return new Promise(async resolve => {\n          return client['publish'](readPacket, ({ err }) => resolve(err));\n        }).then(err => {\n          expect(err).to.be.instanceof(Error);\n        });\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should remove callback from routing map","suites":["ClientKafka","publish","dispose callback"],"updatePoint":{"line":792,"column":49},"line":792,"code":"      it('should remove callback from routing map', async () => {\n        expect(client['routingMap'].has(correlationId)).to.be.false;\n        expect(client['routingMap'].size).to.eq(0);\n      });","file":"client/client-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should leave pattern as it is","suites":["ClientMqtt","getRequestPattern"],"updatePoint":{"line":14,"column":37},"line":14,"code":"    it(`should leave pattern as it is`, () => {\n      expect(client.getRequestPattern(test)).to.equal(test);\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should append \"/reply\" to string","suites":["ClientMqtt","getResponsePattern"],"updatePoint":{"line":19,"column":40},"line":19,"code":"    it(`should append \"/reply\" to string`, () => {\n      const expectedResult = test + '/reply';\n      expect(client.getResponsePattern(test)).to.equal(expectedResult);\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to response pattern name","suites":["ClientMqtt","publish"],"updatePoint":{"line":64,"column":49},"line":64,"code":"    it('should subscribe to response pattern name', async () => {\n      await client['publish'](msg, () => {});\n      expect(subscribeSpy.calledWith(`${pattern}/reply`)).to.be.true;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish stringified message to request pattern name","suites":["ClientMqtt","publish"],"updatePoint":{"line":68,"column":66},"line":68,"code":"    it('should publish stringified message to request pattern name', async () => {\n      await client['publish'](msg, () => {});\n      expect(publishSpy.calledWith(pattern, JSON.stringify(msg))).to.be.true;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should add callback to routing map","suites":["ClientMqtt","publish"],"updatePoint":{"line":72,"column":42},"line":72,"code":"    it('should add callback to routing map', async () => {\n      await client['publish'](msg, () => {});\n      expect(client['routingMap'].has(id)).to.be.true;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ClientMqtt","publish","on error"],"updatePoint":{"line":83,"column":30},"line":83,"code":"      it('should call callback', () => {\n        const callback = sinon.spy();\n        client['publish'](msg, callback);\n\n        expect(callback.called).to.be.true;\n        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should unsubscribe to response pattern name","suites":["ClientMqtt","publish","dispose callback"],"updatePoint":{"line":110,"column":53},"line":110,"code":"      it('should unsubscribe to response pattern name', () => {\n        expect(unsubscribeSpy.calledWith(channel)).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should remove callback from routing map","suites":["ClientMqtt","publish","dispose callback"],"updatePoint":{"line":113,"column":49},"line":113,"code":"      it('should remove callback from routing map', () => {\n        expect(client['routingMap'].has(id)).to.be.false;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientMqtt","publish","headers"],"updatePoint":{"line":118,"column":60},"line":118,"code":"      it('should not generate headers if none are configured', async () => {\n        await client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2]).to.be.undefined;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientMqtt","publish","headers"],"updatePoint":{"line":122,"column":36},"line":122,"code":"      it('should send packet headers', async () => {\n        const requestHeaders = { '1': '123' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientMqtt","publish","headers"],"updatePoint":{"line":133,"column":50},"line":133,"code":"      it('should combine packet and static headers', async () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.userProperties = staticHeaders;\n\n        const requestHeaders = { '1': '123' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql({\n          ...staticHeaders,\n          ...requestHeaders,\n        });\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientMqtt","publish","headers"],"updatePoint":{"line":148,"column":58},"line":148,"code":"      it('should prefer packet headers over static headers', async () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { 'client-id': 'override-client-id' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with expected arguments","suites":["ClientMqtt","createResponseCallback","not completed"],"updatePoint":{"line":179,"column":54},"line":179,"code":"      it('should call callback with expected arguments', () => {\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: responseMessage.response,\n          }),\n        ).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with dispose param","suites":["ClientMqtt","createResponseCallback","disposed and \"id\" is correct"],"updatePoint":{"line":205,"column":49},"line":205,"code":"      it('should call callback with dispose param', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            isDisposed: true,\n            response: responseMessage.response,\n            err: undefined,\n          }),\n        ).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call callback","suites":["ClientMqtt","createResponseCallback","disposed and \"id\" is incorrect"],"updatePoint":{"line":225,"column":34},"line":225,"code":"      it('should not call callback', () => {\n        expect(callback.called).to.be.false;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close \"pub\" when it is not null","suites":["ClientMqtt","close"],"updatePoint":{"line":236,"column":46},"line":236,"code":"    it('should close \"pub\" when it is not null', () => {\n      client.close();\n      expect(endSpy.called).to.be.true;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not close \"pub\" when it is null","suites":["ClientMqtt","close"],"updatePoint":{"line":240,"column":46},"line":240,"code":"    it('should not close \"pub\" when it is null', () => {\n      (client as any).mqttClient = null;\n      client.close();\n      expect(endSpy.called).to.be.false;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleError\" once","suites":["ClientMqtt","connect","when is not connected"],"updatePoint":{"line":282,"column":40},"line":282,"code":"      it('should call \"handleError\" once', async () => {\n        expect(handleErrorsSpy.called).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createClient\" once","suites":["ClientMqtt","connect","when is not connected"],"updatePoint":{"line":285,"column":41},"line":285,"code":"      it('should call \"createClient\" once', async () => {\n        expect(createClientStub.called).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"connect$\" once","suites":["ClientMqtt","connect","when is not connected"],"updatePoint":{"line":288,"column":37},"line":288,"code":"      it('should call \"connect$\" once', async () => {\n        expect(connect$Stub.called).to.be.true;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"createClient\"","suites":["ClientMqtt","connect","when is connected"],"updatePoint":{"line":296,"column":40},"line":296,"code":"      it('should not call \"createClient\"', () => {\n        expect(createClientStub.called).to.be.false;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"handleError\"","suites":["ClientMqtt","connect","when is connected"],"updatePoint":{"line":299,"column":39},"line":299,"code":"      it('should not call \"handleError\"', () => {\n        expect(handleErrorsSpy.called).to.be.false;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"connect$\"","suites":["ClientMqtt","connect","when is connected"],"updatePoint":{"line":302,"column":36},"line":302,"code":"      it('should not call \"connect$\"', () => {\n        expect(connect$Stub.called).to.be.false;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should merge close event","suites":["ClientMqtt","mergeCloseEvent"],"updatePoint":{"line":308,"column":32},"line":308,"code":"    it('should merge close event', () => {\n      const error = new Error();\n      const instance: any = {\n        on: (ev, callback) => callback(error),\n        off: () => ({}),\n      };\n      client.mergeCloseEvent(instance as any, EMPTY).subscribe({\n        error: (err: any) => expect(err).to.be.eql(error),\n      });\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind error event handler","suites":["ClientMqtt","handleError"],"updatePoint":{"line":320,"column":39},"line":320,"code":"    it('should bind error event handler', () => {\n      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));\n      const emitter = {\n        addListener: callback,\n      };\n      client.handleError(emitter as any);\n      expect(callback.getCall(0).args[0]).to.be.eql(ERROR_EVENT);\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientMqtt","dispatchEvent"],"updatePoint":{"line":343,"column":29},"line":343,"code":"    it('should publish packet', async () => {\n      publishStub.callsFake((a, b, c, d) => d());\n      await client['dispatchEvent'](msg);\n\n      expect(publishStub.called).to.be.true;\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error","suites":["ClientMqtt","dispatchEvent"],"updatePoint":{"line":349,"column":26},"line":349,"code":"    it('should throw error', async () => {\n      publishStub.callsFake((a, b, c, d) => d(new Error()));\n      client['dispatchEvent'](msg).catch(err =>\n        expect(err).to.be.instanceOf(Error),\n      );\n    });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientMqtt","dispatchEvent","headers"],"updatePoint":{"line":356,"column":60},"line":356,"code":"      it('should not generate headers if none are configured', async () => {\n        publishStub.callsFake((a, b, c, d) => d());\n        await client['dispatchEvent'](msg);\n        expect(publishStub.getCall(0).args[2]).to.be.undefined;\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientMqtt","dispatchEvent","headers"],"updatePoint":{"line":361,"column":36},"line":361,"code":"      it('should send packet headers', async () => {\n        publishStub.callsFake((a, b, c, d) => d());\n        const requestHeaders = { '1': '123' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['dispatchEvent'](msg);\n        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientMqtt","dispatchEvent","headers"],"updatePoint":{"line":373,"column":50},"line":373,"code":"      it('should combine packet and static headers', async () => {\n        publishStub.callsFake((a, b, c, d) => d());\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.userProperties = staticHeaders;\n\n        const requestHeaders = { '1': '123' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['dispatchEvent'](msg);\n        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(\n          {\n            ...staticHeaders,\n            ...requestHeaders,\n          },\n        );\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientMqtt","dispatchEvent","headers"],"updatePoint":{"line":391,"column":58},"line":391,"code":"      it('should prefer packet headers over static headers', async () => {\n        publishStub.callsFake((a, b, c, d) => d());\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { 'client-id': 'override-client-id' };\n        msg.data = new MqttRecord('data', {\n          properties: { userProperties: requestHeaders },\n        });\n\n        await client['dispatchEvent'](msg);\n        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish stringified message to pattern name","suites":["ClientNats","publish"],"updatePoint":{"line":55,"column":58},"line":55,"code":"    it('should publish stringified message to pattern name', () => {\n      client['publish'](msg, () => {});\n      expect(publishSpy.getCall(0).args[0]).to.be.eql(pattern);\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ClientNats","publish","on error"],"updatePoint":{"line":72,"column":30},"line":72,"code":"      it('should call callback', () => {\n        const callback = sinon.spy();\n        client['publish'](msg, callback);\n\n        expect(callback.called).to.be.true;\n        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should unsubscribe","suites":["ClientNats","publish","dispose callback"],"updatePoint":{"line":97,"column":28},"line":97,"code":"      it('should unsubscribe', () => {\n        expect(unsubscribeSpy.called).to.be.true;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientNats","publish","headers"],"updatePoint":{"line":103,"column":60},"line":103,"code":"      it('should not generate headers if none are configured', () => {\n        client['publish'](msg, () => {});\n        expect(natsClient.publish.getCall(0).args[2].headers).to.be.undefined;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientNats","publish","headers"],"updatePoint":{"line":108,"column":36},"line":108,"code":"      it('should send packet headers', () => {\n        const requestHeaders = createHeaders();\n        requestHeaders.set('1', '123');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['publish'](msg, () => {});\n        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(\n          '123',\n        );\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientNats","publish","headers"],"updatePoint":{"line":118,"column":50},"line":118,"code":"      it('should combine packet and static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = createHeaders();\n        requestHeaders.set('1', '123');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2].headers.get('client-id')).to.eql(\n          'some-client-id',\n        );\n        expect(publishSpy.getCall(0).args[2].headers.get('1')).to.eql('123');\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientNats","publish","headers"],"updatePoint":{"line":133,"column":58},"line":133,"code":"      it('should prefer packet headers over static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = createHeaders();\n        requestHeaders.set('client-id', 'override-client-id');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['publish'](msg, () => {});\n        expect(publishSpy.getCall(0).args[2].headers.get('client-id')).to.eql(\n          'override-client-id',\n        );\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with expected arguments","suites":["ClientNats","createSubscriptionHandler","not completed"],"updatePoint":{"line":169,"column":54},"line":169,"code":"      it('should call callback with expected arguments', () => {\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: responseMessage.response,\n          }),\n        ).to.be.true;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with dispose param","suites":["ClientNats","createSubscriptionHandler","disposed and \"id\" is correct"],"updatePoint":{"line":190,"column":49},"line":190,"code":"      it('should call callback with dispose param', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            isDisposed: true,\n            response: responseMessage.response,\n            err: undefined,\n          }),\n        ).to.be.true;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call callback","suites":["ClientNats","createSubscriptionHandler","disposed and \"id\" is incorrect"],"updatePoint":{"line":219,"column":34},"line":219,"code":"      it('should not call callback', () => {\n        expect(callback.called).to.be.false;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close \"natsClient\" when it is not null","suites":["ClientNats","close"],"updatePoint":{"line":232,"column":53},"line":232,"code":"    it('should close \"natsClient\" when it is not null', () => {\n      client.close();\n      expect(natsClose.called).to.be.true;\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleStatusUpdatesSpy\" once","suites":["ClientNats","connect","when is not connected"],"updatePoint":{"line":258,"column":51},"line":258,"code":"      it('should call \"handleStatusUpdatesSpy\" once', async () => {\n        expect(handleStatusUpdatesSpy.called).to.be.true;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createClient\" once","suites":["ClientNats","connect","when is not connected"],"updatePoint":{"line":261,"column":41},"line":261,"code":"      it('should call \"createClient\" once', async () => {\n        expect(createClientSpy.called).to.be.true;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"createClient\"","suites":["ClientNats","connect","when is connected"],"updatePoint":{"line":270,"column":40},"line":270,"code":"      it('should not call \"createClient\"', () => {\n        expect(createClientSpy.called).to.be.false;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"handleStatusUpdatesSpy\"","suites":["ClientNats","connect","when is connected"],"updatePoint":{"line":273,"column":50},"line":273,"code":"      it('should not call \"handleStatusUpdatesSpy\"', () => {\n        expect(handleStatusUpdatesSpy.called).to.be.false;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should retrieve \"status()\" async iterator","suites":["ClientNats","handleStatusUpdates"],"updatePoint":{"line":279,"column":49},"line":279,"code":"    it('should retrieve \"status()\" async iterator', () => {\n      const clientMock = {\n        status: sinon.stub().returns({\n          [Symbol.asyncIterator]: [],\n        }),\n      };\n      client.handleStatusUpdates(clientMock as any);\n      expect(clientMock.status.called).to.be.true;\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should log \"disconnect\" and \"error\" statuses as \"errors\"","suites":["ClientNats","handleStatusUpdates"],"updatePoint":{"line":289,"column":64},"line":289,"code":"    it('should log \"disconnect\" and \"error\" statuses as \"errors\"', async () => {\n      const logErrorSpy = sinon.spy((client as any).logger, 'error');\n      const clientMock = {\n        status: sinon.stub().returns({\n          async *[Symbol.asyncIterator]() {\n            yield { type: 'disconnect', data: 'localhost' };\n            yield { type: 'error', data: {} };\n          },\n        }),\n      };\n      await client.handleStatusUpdates(clientMock as any);\n      expect(logErrorSpy.calledTwice).to.be.true;\n      expect(\n        logErrorSpy.calledWith(\n          `NatsError: type: \"disconnect\", data: \"localhost\".`,\n        ),\n      );\n      expect(\n        logErrorSpy.calledWith(`NatsError: type: \"disconnect\", data: \"{}\".`),\n      );\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should log other statuses as \"logs\"","suites":["ClientNats","handleStatusUpdates"],"updatePoint":{"line":310,"column":43},"line":310,"code":"    it('should log other statuses as \"logs\"', async () => {\n      const logSpy = sinon.spy((client as any).logger, 'log');\n      const clientMock = {\n        status: sinon.stub().returns({\n          async *[Symbol.asyncIterator]() {\n            yield { type: 'non-disconnect', data: 'localhost' };\n            yield { type: 'warn', data: {} };\n          },\n        }),\n      };\n      await client.handleStatusUpdates(clientMock as any);\n      expect(logSpy.calledTwice).to.be.true;\n      expect(\n        logSpy.calledWith(\n          `NatsStatus: type: \"non-disconnect\", data: \"localhost\".`,\n        ),\n      );\n      expect(logSpy.calledWith(`NatsStatus: type: \"warn\", data: \"{}\".`));\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientNats","dispatchEvent"],"updatePoint":{"line":347,"column":29},"line":347,"code":"    it('should publish packet', async () => {\n      await client['dispatchEvent'](msg);\n\n      expect(natsClient.publish.called).to.be.true;\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error","suites":["ClientNats","dispatchEvent"],"updatePoint":{"line":353,"column":26},"line":353,"code":"    it('should throw error', async () => {\n      subscribeStub.callsFake((channel, options) =>\n        options.callback(new Error()),\n      );\n      client['dispatchEvent'](msg).catch(err =>\n        expect(err).to.be.instanceOf(Error),\n      );\n    });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientNats","dispatchEvent","headers"],"updatePoint":{"line":363,"column":60},"line":363,"code":"      it('should not generate headers if none are configured', () => {\n        client['dispatchEvent'](msg);\n        expect(natsClient.publish.getCall(0).args[2].headers).to.be.undefined;\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientNats","dispatchEvent","headers"],"updatePoint":{"line":368,"column":36},"line":368,"code":"      it('should send packet headers', () => {\n        const requestHeaders = createHeaders();\n        requestHeaders.set('1', '123');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['dispatchEvent'](msg);\n        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(\n          '123',\n        );\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientNats","dispatchEvent","headers"],"updatePoint":{"line":379,"column":50},"line":379,"code":"      it('should combine packet and static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = createHeaders();\n        requestHeaders.set('1', '123');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['dispatchEvent'](msg);\n        expect(\n          natsClient.publish.getCall(0).args[2].headers.get('client-id'),\n        ).to.eql('some-client-id');\n        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(\n          '123',\n        );\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientNats","dispatchEvent","headers"],"updatePoint":{"line":396,"column":58},"line":396,"code":"      it('should prefer packet headers over static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = createHeaders();\n        requestHeaders.set('client-id', 'override-client-id');\n        msg.data = new NatsRecord('data', requestHeaders);\n\n        client['dispatchEvent'](msg);\n        expect(\n          natsClient.publish.getCall(0).args[2].headers.get('client-id'),\n        ).to.eql('override-client-id');\n      });","file":"client/client-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create tcp client by default","suites":["ClientProxyFactory","create"],"updatePoint":{"line":15,"column":43},"line":15,"code":"    it(`should create tcp client by default`, () => {\n      const proxy = ClientProxyFactory.create({});\n      expect(proxy instanceof ClientTCP).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create redis client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":20,"column":34},"line":20,"code":"    it(`should create redis client`, () => {\n      const proxy = ClientProxyFactory.create({ transport: Transport.REDIS });\n      expect(proxy instanceof ClientRedis).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create nats client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":25,"column":33},"line":25,"code":"    it(`should create nats client`, () => {\n      const proxy = ClientProxyFactory.create({ transport: Transport.NATS });\n      expect(proxy instanceof ClientNats).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create mqtt client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":30,"column":33},"line":30,"code":"    it(`should create mqtt client`, () => {\n      const proxy = ClientProxyFactory.create({ transport: Transport.MQTT });\n      expect(proxy instanceof ClientMqtt).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create grpc client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":35,"column":33},"line":35,"code":"    it(`should create grpc client`, () => {\n      const proxy = ClientProxyFactory.create({\n        transport: Transport.GRPC,\n        options: {\n          protoPath: join(__dirname, './test.proto'),\n          package: 'test',\n        },\n      });\n      expect(proxy instanceof ClientGrpcProxy).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create rmq client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":46,"column":32},"line":46,"code":"    it(`should create rmq client`, () => {\n      const proxy = ClientProxyFactory.create({ transport: Transport.RMQ });\n      expect(proxy instanceof ClientRMQ).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create kafka client","suites":["ClientProxyFactory","create"],"updatePoint":{"line":51,"column":34},"line":51,"code":"    it(`should create kafka client`, () => {\n      const proxy = ClientProxyFactory.create({ transport: Transport.KAFKA });\n      expect(proxy instanceof ClientKafka).to.be.true;\n    });","file":"client/client-proxy-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"\"error\" when first parameter is not null or undefined","suites":["ClientProxy","createObserver","returned function calls"],"updatePoint":{"line":28,"column":63},"line":28,"code":"      it(`\"error\" when first parameter is not null or undefined`, () => {\n        const testClient = new TestClientProxy();\n        const err = 'test';\n        const error = sinon.spy();\n        const next = sinon.spy();\n        const complete = sinon.spy();\n        const observer = {\n          error,\n          next,\n          complete,\n        };\n        const fn = testClient['createObserver'](observer);\n\n        fn({ err });\n        expect(error.calledWith(err)).to.be.true;\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"\"next\" when first parameter is null or undefined","suites":["ClientProxy","createObserver","returned function calls"],"updatePoint":{"line":45,"column":58},"line":45,"code":"      it(`\"next\" when first parameter is null or undefined`, () => {\n        const testClient = new TestClientProxy();\n        const data = 'test';\n        const error = sinon.spy();\n        const next = sinon.spy();\n        const complete = sinon.spy();\n        const observer = {\n          error,\n          next,\n          complete,\n        };\n        const fn = testClient['createObserver'](observer);\n\n        fn({ response: data });\n        expect(next.calledWith(data)).to.be.true;\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"\"complete\" when third parameter is true","suites":["ClientProxy","createObserver","returned function calls"],"updatePoint":{"line":62,"column":49},"line":62,"code":"      it(`\"complete\" when third parameter is true`, () => {\n        const testClient = new TestClientProxy();\n        const data = 'test';\n        const error = sinon.spy();\n        const next = sinon.spy();\n        const complete = sinon.spy();\n        const observer = {\n          error,\n          next,\n          complete,\n        };\n        const fn = testClient['createObserver'](observer);\n\n        fn({ data, isDisposed: true } as any);\n        expect(complete.called).to.be.true;\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an observable stream","suites":["ClientProxy","send"],"updatePoint":{"line":82,"column":42},"line":82,"code":"    it(`should return an observable stream`, () => {\n      const stream$ = client.send({}, '');\n      expect(stream$ instanceof Observable).to.be.true;\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"connect\" on subscribe","suites":["ClientProxy","send"],"updatePoint":{"line":86,"column":42},"line":86,"code":"    it('should call \"connect\" on subscribe', () => {\n      const connectSpy = sinon.spy(client, 'connect');\n      const stream$ = client.send({ test: 3 }, 'test');\n\n      stream$.subscribe();\n      expect(connectSpy.calledOnce).to.be.true;\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable with error","suites":["ClientProxy","send","when \"connect\" throws"],"updatePoint":{"line":94,"column":45},"line":94,"code":"      it('should return Observable with error', () => {\n        sinon.stub(client, 'connect').callsFake(() => {\n          throw new Error();\n        });\n        const stream$ = client.send({ test: 3 }, 'test');\n        stream$.subscribe({\n          next: () => {},\n          error: err => {\n            expect(err).to.be.instanceof(Error);\n          },\n        });\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"publish\"","suites":["ClientProxy","send","when is connected"],"updatePoint":{"line":111,"column":31},"line":111,"code":"      it(`should call \"publish\"`, () => {\n        const pattern = { test: 3 };\n        const data = 'test';\n        const publishSpy = sinon.spy();\n        const stream$ = client.send(pattern, data);\n        client.publish = publishSpy;\n\n        stream$.subscribe(() => {\n          expect(publishSpy.calledOnce).to.be.true;\n        });\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable with error","suites":["ClientProxy","send","when is connected"],"updatePoint":{"line":123,"column":43},"line":123,"code":"    it('should return Observable with error', () => {\n      const err$ = client.send(null, null);\n      expect(err$).to.be.instanceOf(Observable);\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an observable stream","suites":["ClientProxy","emit"],"updatePoint":{"line":130,"column":42},"line":130,"code":"    it(`should return an observable stream`, () => {\n      const stream$ = client.emit({}, '');\n      expect(stream$ instanceof Observable).to.be.true;\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"connect\" immediately","suites":["ClientProxy","emit"],"updatePoint":{"line":134,"column":41},"line":134,"code":"    it('should call \"connect\" immediately', () => {\n      const connectSpy = sinon.spy(client, 'connect');\n      client.emit({ test: 3 }, 'test');\n      expect(connectSpy.calledOnce).to.be.true;\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable with error","suites":["ClientProxy","emit","when \"connect\" throws"],"updatePoint":{"line":140,"column":45},"line":140,"code":"      it('should return Observable with error', () => {\n        sinon.stub(client, 'connect').callsFake(() => {\n          throw new Error();\n        });\n        const stream$ = client.emit({ test: 3 }, 'test');\n        stream$.subscribe({\n          next: () => {},\n          error: err => {\n            expect(err).to.be.instanceof(Error);\n          },\n        });\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"dispatchEvent\"","suites":["ClientProxy","emit","when is connected"],"updatePoint":{"line":157,"column":37},"line":157,"code":"      it(`should call \"dispatchEvent\"`, () => {\n        const pattern = { test: 3 };\n        const data = 'test';\n        const dispatchEventSpy = sinon\n          .stub()\n          .callsFake(() => Promise.resolve(true));\n        const stream$ = client.emit(pattern, data);\n        client['dispatchEvent'] = dispatchEventSpy;\n\n        stream$.subscribe(() => {\n          expect(dispatchEventSpy.calledOnce).to.be.true;\n        });\n      });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable with error","suites":["ClientProxy","emit","when is connected"],"updatePoint":{"line":171,"column":43},"line":171,"code":"    it('should return Observable with error', () => {\n      const err$ = client.emit(null, null);\n      expect(err$).to.be.instanceOf(Observable);\n    });","file":"client/client-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should leave pattern as it is","suites":["ClientRedis","getRequestPattern"],"updatePoint":{"line":11,"column":37},"line":11,"code":"    it(`should leave pattern as it is`, () => {\n      const expectedResult = test;\n      expect(client.getRequestPattern(test)).to.equal(expectedResult);\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should append \".reply\" to string","suites":["ClientRedis","getReplyPattern"],"updatePoint":{"line":17,"column":40},"line":17,"code":"    it(`should append \".reply\" to string`, () => {\n      const expectedResult = test + '.reply';\n      expect(client.getReplyPattern(test)).to.equal(expectedResult);\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to response pattern name","suites":["ClientRedis","publish"],"updatePoint":{"line":56,"column":49},"line":56,"code":"    it('should subscribe to response pattern name', () => {\n      client['publish'](msg, () => {});\n      expect(subscribeSpy.calledWith(`${pattern}.reply`)).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish stringified message to request pattern name","suites":["ClientRedis","publish"],"updatePoint":{"line":60,"column":66},"line":60,"code":"    it('should publish stringified message to request pattern name', async () => {\n      await client['publish'](msg, () => {});\n      expect(publishSpy.calledWith(pattern, JSON.stringify(msg))).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ClientRedis","publish","on error"],"updatePoint":{"line":77,"column":30},"line":77,"code":"      it('should call callback', () => {\n        const callback = sinon.spy();\n        client['publish'](msg, callback);\n\n        expect(callback.called).to.be.true;\n        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should unsubscribe to response pattern name","suites":["ClientRedis","publish","dispose callback"],"updatePoint":{"line":109,"column":53},"line":109,"code":"      it('should unsubscribe to response pattern name', () => {\n        expect(unsubscribeSpy.calledWith(channel)).to.be.true;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should clean routingMap","suites":["ClientRedis","publish","dispose callback"],"updatePoint":{"line":112,"column":33},"line":112,"code":"      it('should clean routingMap', () => {\n        expect(client['routingMap'].has(id)).to.be.false;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with expected arguments","suites":["ClientRedis","createResponseCallback","not completed"],"updatePoint":{"line":135,"column":54},"line":135,"code":"      it('should call callback with expected arguments', () => {\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: responseMessage.response,\n          }),\n        ).to.be.true;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with dispose param","suites":["ClientRedis","createResponseCallback","disposed and \"id\" is correct"],"updatePoint":{"line":160,"column":49},"line":160,"code":"      it('should call callback with dispose param', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            isDisposed: true,\n            response: responseMessage.response,\n            err: undefined,\n          }),\n        ).to.be.true;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call callback","suites":["ClientRedis","createResponseCallback","disposed and \"id\" is incorrect"],"updatePoint":{"line":178,"column":34},"line":178,"code":"      it('should not call callback', () => {\n        expect(callback.called).to.be.false;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close \"pub\" when it is not null","suites":["ClientRedis","close"],"updatePoint":{"line":195,"column":46},"line":195,"code":"    it('should close \"pub\" when it is not null', () => {\n      client.close();\n      expect(pubClose.called).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not close \"pub\" when it is null","suites":["ClientRedis","close"],"updatePoint":{"line":199,"column":46},"line":199,"code":"    it('should not close \"pub\" when it is null', () => {\n      (client as any).pubClient = null;\n      client.close();\n      expect(pubClose.called).to.be.false;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close \"sub\" when it is not null","suites":["ClientRedis","close"],"updatePoint":{"line":204,"column":46},"line":204,"code":"    it('should close \"sub\" when it is not null', () => {\n      client.close();\n      expect(subClose.called).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not close \"sub\" when it is null","suites":["ClientRedis","close"],"updatePoint":{"line":208,"column":46},"line":208,"code":"    it('should not close \"sub\" when it is null', () => {\n      (client as any).subClient = null;\n      client.close();\n      expect(subClose.called).to.be.false;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createClient\" twice","suites":["ClientRedis","connect"],"updatePoint":{"line":235,"column":40},"line":235,"code":"    it('should call \"createClient\" twice', () => {\n      expect(createClientSpy.calledTwice).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleError\" twice","suites":["ClientRedis","connect"],"updatePoint":{"line":238,"column":39},"line":238,"code":"    it('should call \"handleError\" twice', () => {\n      expect(handleErrorsSpy.calledTwice).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind error event handler","suites":["ClientRedis","handleError"],"updatePoint":{"line":243,"column":39},"line":243,"code":"    it('should bind error event handler', () => {\n      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));\n      const emitter = {\n        addListener: callback,\n      };\n      client.handleError(emitter as any);\n      expect(callback.getCall(0).args[0]).to.be.eql(ERROR_EVENT);\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return options object with \"retryStrategy\" and call \"createRetryStrategy\"","suites":["ClientRedis","getClientOptions"],"updatePoint":{"line":253,"column":88},"line":253,"code":"    it('should return options object with \"retryStrategy\" and call \"createRetryStrategy\"', () => {\n      const createSpy = sinon.spy(client, 'createRetryStrategy');\n      const { retryStrategy } = client.getClientOptions();\n      try {\n        retryStrategy({} as any);\n      } catch {}\n      expect(createSpy.called).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ClientRedis","createRetryStrategy","when is terminated"],"updatePoint":{"line":264,"column":33},"line":264,"code":"      it('should return undefined', () => {\n        (client as any).isExplicitlyTerminated = true;\n        const result = client.createRetryStrategy(0);\n        expect(result).to.be.undefined;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ClientRedis","createRetryStrategy","when \"retryAttempts\" does not exist"],"updatePoint":{"line":271,"column":33},"line":271,"code":"      it('should return undefined', () => {\n        (client as any).isExplicitlyTerminated = false;\n        (client as any).options.options = {};\n        (client as any).options.options.retryAttempts = undefined;\n        const result = client.createRetryStrategy(1);\n        expect(result).to.be.undefined;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ClientRedis","createRetryStrategy","when \"attempts\" count is max"],"updatePoint":{"line":280,"column":33},"line":280,"code":"      it('should return undefined', () => {\n        (client as any).isExplicitlyTerminated = false;\n        (client as any).options.options = {};\n        (client as any).options.options.retryAttempts = 3;\n        const result = client.createRetryStrategy(4);\n        expect(result).to.be.undefined;\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return delay (ms)","suites":["ClientRedis","createRetryStrategy","otherwise"],"updatePoint":{"line":289,"column":34},"line":289,"code":"      it('should return delay (ms)', () => {\n        (client as any).options = {};\n        (client as any).isExplicitlyTerminated = false;\n        (client as any).options.retryAttempts = 3;\n        (client as any).options.retryDelay = 3;\n        const result = client.createRetryStrategy(2);\n        expect(result).to.be.eql((client as any).options.retryDelay);\n      });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientRedis","dispatchEvent"],"updatePoint":{"line":311,"column":29},"line":311,"code":"    it('should publish packet', async () => {\n      publishStub.callsFake((a, b, c) => c());\n      await client['dispatchEvent'](msg);\n\n      expect(publishStub.called).to.be.true;\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error","suites":["ClientRedis","dispatchEvent"],"updatePoint":{"line":317,"column":26},"line":317,"code":"    it('should throw error', async () => {\n      publishStub.callsFake((a, b, c) => c(new Error()));\n      client['dispatchEvent'](msg).catch(err =>\n        expect(err).to.be.instanceOf(Error),\n      );\n    });","file":"client/client-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleError\" once","suites":["ClientRMQ","connect","when is not connected"],"updatePoint":{"line":46,"column":40},"line":46,"code":"      it('should call \"handleError\" once', async () => {\n        expect(handleErrorsSpy.called).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createClient\" once","suites":["ClientRMQ","connect","when is not connected"],"updatePoint":{"line":49,"column":41},"line":49,"code":"      it('should call \"createClient\" once', async () => {\n        expect(createClientStub.called).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"connect$\" once","suites":["ClientRMQ","connect","when is not connected"],"updatePoint":{"line":52,"column":37},"line":52,"code":"      it('should call \"connect$\" once', async () => {\n        expect(connect$Stub.called).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"createClient\"","suites":["ClientRMQ","connect","when is connected"],"updatePoint":{"line":61,"column":40},"line":61,"code":"      it('should not call \"createClient\"', () => {\n        expect(createClientStub.called).to.be.false;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"handleError\"","suites":["ClientRMQ","connect","when is connected"],"updatePoint":{"line":64,"column":39},"line":64,"code":"      it('should not call \"handleError\"', () => {\n        expect(handleErrorsSpy.called).to.be.false;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"connect$\"","suites":["ClientRMQ","connect","when is connected"],"updatePoint":{"line":67,"column":36},"line":67,"code":"      it('should not call \"connect$\"', () => {\n        expect(connect$Stub.called).to.be.false;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createChannel\" method of the client instance","suites":["ClientRMQ","createChannel"],"updatePoint":{"line":87,"column":65},"line":87,"code":"    it('should call \"createChannel\" method of the client instance', async () => {\n      await client.createChannel();\n      expect(createChannelStub.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"setupChannel\" method of the client instance","suites":["ClientRMQ","createChannel"],"updatePoint":{"line":91,"column":64},"line":91,"code":"    it('should call \"setupChannel\" method of the client instance', async () => {\n      await client.createChannel();\n      expect(setupChannelStub.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"consume\" method of the channel instance","suites":["ClientRMQ","consumeChannel"],"updatePoint":{"line":109,"column":60},"line":109,"code":"    it('should call \"consume\" method of the channel instance', async () => {\n      await client.consumeChannel(channel);\n      expect(consumeStub.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"assertQueue\" with queue and queue options","suites":["ClientRMQ","setupChannel"],"updatePoint":{"line":138,"column":62},"line":138,"code":"    it('should call \"assertQueue\" with queue and queue options', async () => {\n      await client.setupChannel(channel, () => null);\n      expect(channel.assertQueue.calledWith(queue, queueOptions)).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"prefetch\" with prefetchCount and \"isGlobalPrefetchCount\"","suites":["ClientRMQ","setupChannel"],"updatePoint":{"line":142,"column":77},"line":142,"code":"    it('should call \"prefetch\" with prefetchCount and \"isGlobalPrefetchCount\"', async () => {\n      await client.setupChannel(channel, () => null);\n      expect(channel.prefetch.calledWith(prefetchCount, isGlobalPrefetchCount))\n        .to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"consumeChannel\" method","suites":["ClientRMQ","setupChannel"],"updatePoint":{"line":147,"column":43},"line":147,"code":"    it('should call \"consumeChannel\" method', async () => {\n      await client.setupChannel(channel, () => null);\n      expect(consumeStub.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"resolve\" function","suites":["ClientRMQ","setupChannel"],"updatePoint":{"line":151,"column":38},"line":151,"code":"    it('should call \"resolve\" function', async () => {\n      const resolve = sinon.spy();\n      await client.setupChannel(channel, resolve);\n      expect(resolve.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should merge disconnect event","suites":["ClientRMQ","mergeDisconnectEvent"],"updatePoint":{"line":159,"column":37},"line":159,"code":"    it('should merge disconnect event', () => {\n      const error = new Error();\n      const instance: any = {\n        on: (ev, callback) => callback(error),\n        off: () => ({}),\n      };\n      client\n        .mergeDisconnectEvent(instance as any, EMPTY)\n        .subscribe({ error: (err: any) => expect(err).to.be.eql(error) });\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send message to a proper queue","suites":["ClientRMQ","publish"],"updatePoint":{"line":196,"column":45},"line":196,"code":"    it('should send message to a proper queue', () => {\n      client['publish'](msg, () => {\n        expect(sendToQueueStub.called).to.be.true;\n        expect(sendToQueueStub.getCall(0).args[0]).to.be.eql(client['queue']);\n      });\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send buffer from stringified message","suites":["ClientRMQ","publish"],"updatePoint":{"line":203,"column":51},"line":203,"code":"    it('should send buffer from stringified message', () => {\n      client['publish'](msg, () => {\n        expect(sendToQueueStub.called).to.be.true;\n        expect(sendToQueueStub.getCall(1).args[1]).to.be.eql(\n          Buffer.from(JSON.stringify(msg)),\n        );\n      });\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should unsubscribe","suites":["ClientRMQ","publish","dispose callback"],"updatePoint":{"line":225,"column":28},"line":225,"code":"      it('should unsubscribe', () => {\n        expect(unsubscribeSpy.called).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientRMQ","publish","headers"],"updatePoint":{"line":231,"column":60},"line":231,"code":"      it('should not generate headers if none are configured', () => {\n        client['publish'](msg, () => {\n          expect(sendToQueueStub.getCall(0).args[2].headers).to.be.undefined;\n        });\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientRMQ","publish","headers"],"updatePoint":{"line":237,"column":36},"line":237,"code":"      it('should send packet headers', () => {\n        const requestHeaders = { '1': '123' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        client['publish'](msg, () => {\n          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(\n            requestHeaders,\n          );\n        });\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientRMQ","publish","headers"],"updatePoint":{"line":248,"column":50},"line":248,"code":"      it('should combine packet and static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { '1': '123' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        client['publish'](msg, () => {\n          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql({\n            ...staticHeaders,\n            ...requestHeaders,\n          });\n        });\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientRMQ","publish","headers"],"updatePoint":{"line":263,"column":58},"line":263,"code":"      it('should prefer packet headers over static headers', () => {\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { 'client-id': 'override-client-id' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        client['publish'](msg, () => {\n          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(\n            requestHeaders,\n          );\n        });\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with correct object","suites":["ClientRMQ","handleMessage","when error"],"updatePoint":{"line":286,"column":50},"line":286,"code":"      it('should call callback with correct object', async () => {\n        const packet = {\n          err: true,\n          response: 'test',\n          isDisposed: false,\n        };\n        await client.handleMessage(packet, callback);\n        expect(\n          callback.calledWith({\n            err: packet.err,\n            response: 'test',\n            isDisposed: true,\n          }),\n        ).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with correct object","suites":["ClientRMQ","handleMessage","when disposed"],"updatePoint":{"line":308,"column":50},"line":308,"code":"      it('should call callback with correct object', async () => {\n        const packet = {\n          response: 'test',\n          isDisposed: true,\n        };\n        await client.handleMessage(packet, callback);\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: 'test',\n            isDisposed: true,\n          }),\n        ).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with correct object","suites":["ClientRMQ","handleMessage","when response"],"updatePoint":{"line":330,"column":50},"line":330,"code":"      it('should call callback with correct object', async () => {\n        const packet = {\n          response: 'test',\n          isDisposed: false,\n        };\n        await client.handleMessage(packet, callback);\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: packet.response,\n          }),\n        ).to.be.true;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close channel when it is not null","suites":["ClientRMQ","close"],"updatePoint":{"line":356,"column":48},"line":356,"code":"    it('should close channel when it is not null', () => {\n      client.close();\n      expect(channelCloseSpy.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close client when it is not null","suites":["ClientRMQ","close"],"updatePoint":{"line":361,"column":47},"line":361,"code":"    it('should close client when it is not null', () => {\n      client.close();\n      expect(clientCloseSpy.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientRMQ","dispatchEvent"],"updatePoint":{"line":380,"column":29},"line":380,"code":"    it('should publish packet', async () => {\n      sendToQueueStub.callsFake((a, b, c, d) => d());\n      await client['dispatchEvent'](msg);\n\n      expect(sendToQueueStub.called).to.be.true;\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw error","suites":["ClientRMQ","dispatchEvent"],"updatePoint":{"line":386,"column":26},"line":386,"code":"    it('should throw error', async () => {\n      sendToQueueStub.callsFake((a, b, c, d) => d(new Error()));\n      client['dispatchEvent'](msg).catch(err =>\n        expect(err).to.be.instanceOf(Error),\n      );\n    });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not generate headers if none are configured","suites":["ClientRMQ","dispatchEvent","headers"],"updatePoint":{"line":394,"column":60},"line":394,"code":"      it('should not generate headers if none are configured', async () => {\n        sendToQueueStub.callsFake((a, b, c, d) => d());\n        await client['dispatchEvent'](msg);\n        expect(sendToQueueStub.getCall(0).args[2].headers).to.be.undefined;\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send packet headers","suites":["ClientRMQ","dispatchEvent","headers"],"updatePoint":{"line":400,"column":36},"line":400,"code":"      it('should send packet headers', async () => {\n        sendToQueueStub.callsFake((a, b, c, d) => d());\n        const requestHeaders = { '1': '123' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        await client['dispatchEvent'](msg);\n        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should combine packet and static headers","suites":["ClientRMQ","dispatchEvent","headers"],"updatePoint":{"line":411,"column":50},"line":411,"code":"      it('should combine packet and static headers', async () => {\n        sendToQueueStub.callsFake((a, b, c, d) => d());\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { '1': '123' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        await client['dispatchEvent'](msg);\n        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql({\n          ...staticHeaders,\n          ...requestHeaders,\n        });\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should prefer packet headers over static headers","suites":["ClientRMQ","dispatchEvent","headers"],"updatePoint":{"line":426,"column":58},"line":426,"code":"      it('should prefer packet headers over static headers', async () => {\n        sendToQueueStub.callsFake((a, b, c, d) => d());\n        const staticHeaders = { 'client-id': 'some-client-id' };\n        (client as any).options.headers = staticHeaders;\n\n        const requestHeaders = { 'client-id': 'override-client-id' };\n        msg.data = new RmqRecord('data', { headers: requestHeaders });\n\n        await client['dispatchEvent'](msg);\n        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(\n          requestHeaders,\n        );\n      });","file":"client/client-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send message","suites":["ClientTCP","publish"],"updatePoint":{"line":43,"column":27},"line":43,"code":"    it('should send message', () => {\n      client['publish'](msg, () => ({}));\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should remove listener from routing map","suites":["ClientTCP","publish","on dispose"],"updatePoint":{"line":47,"column":49},"line":47,"code":"      it('should remove listener from routing map', () => {\n        client['publish'](msg, () => ({}))();\n\n        expect(client['routingMap'].size).to.be.eq(0);\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ClientTCP","publish","on error"],"updatePoint":{"line":54,"column":30},"line":54,"code":"      it('should call callback', () => {\n        const callback = sinon.spy();\n        sinon.stub(client, 'assignPacketId' as any).callsFake(() => {\n          throw new Error();\n        });\n        client['publish'](msg, callback);\n        expect(callback.called).to.be.true;\n        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should emit disposed callback","suites":["ClientTCP","handleResponse","when disposed"],"updatePoint":{"line":75,"column":39},"line":75,"code":"      it('should emit disposed callback', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            err: undefined,\n            response: undefined,\n            isDisposed: true,\n          }),\n        ).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not end server","suites":["ClientTCP","handleResponse","when not disposed"],"updatePoint":{"line":94,"column":31},"line":94,"code":"      it('should not end server', () => {\n        expect(socket.end.called).to.be.false;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with error and response data","suites":["ClientTCP","handleResponse","when not disposed"],"updatePoint":{"line":97,"column":59},"line":97,"code":"      it('should call callback with error and response data', () => {\n        expect(callback.called).to.be.true;\n        expect(\n          callback.calledWith({\n            err: buffer.err,\n            response: buffer.response,\n          }),\n        ).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"bindEvents\" once","suites":["ClientTCP","connect","when is not connected"],"updatePoint":{"line":133,"column":39},"line":133,"code":"      it('should call \"bindEvents\" once', async () => {\n        expect(bindEventsSpy.called).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createSocket\" once","suites":["ClientTCP","connect","when is not connected"],"updatePoint":{"line":136,"column":41},"line":136,"code":"      it('should call \"createSocket\" once', async () => {\n        expect(createSocketStub.called).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"connect$\" once","suites":["ClientTCP","connect","when is not connected"],"updatePoint":{"line":139,"column":37},"line":139,"code":"      it('should call \"connect$\" once', async () => {\n        expect(connect$Stub.called).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should listen on messages","suites":["ClientTCP","connect","when is not connected"],"updatePoint":{"line":142,"column":35},"line":142,"code":"      it('should listen on messages', () => {\n        expect(socket.on.called).to.be.true;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"createSocket\"","suites":["ClientTCP","connect","when is connected"],"updatePoint":{"line":150,"column":40},"line":150,"code":"      it('should not call \"createSocket\"', () => {\n        expect(createSocketStub.called).to.be.false;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"bindEvents\"","suites":["ClientTCP","connect","when is connected"],"updatePoint":{"line":153,"column":38},"line":153,"code":"      it('should not call \"bindEvents\"', () => {\n        expect(bindEventsSpy.called).to.be.false;\n      });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should end() socket","suites":["ClientTCP","close"],"updatePoint":{"line":171,"column":27},"line":171,"code":"    it('should end() socket', () => {\n      expect(socket.end.called).to.be.true;\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should set \"isConnected\" to false","suites":["ClientTCP","close"],"updatePoint":{"line":174,"column":41},"line":174,"code":"    it('should set \"isConnected\" to false', () => {\n      expect((client as any).isConnected).to.be.false;\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should set \"socket\" to null","suites":["ClientTCP","close"],"updatePoint":{"line":177,"column":35},"line":177,"code":"    it('should set \"socket\" to null', () => {\n      expect((client as any).socket).to.be.null;\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should clear out the routing map","suites":["ClientTCP","close"],"updatePoint":{"line":180,"column":40},"line":180,"code":"    it('should clear out the routing map', () => {\n      expect((client as any).routingMap.size).to.be.eq(0);\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callbacks","suites":["ClientTCP","close"],"updatePoint":{"line":183,"column":29},"line":183,"code":"    it('should call callbacks', () => {\n      expect(\n        callback.calledWith({\n          err: sinon.match({ message: 'Connection closed' }),\n        }),\n      ).to.be.true;\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind error event handler","suites":["ClientTCP","bindEvents"],"updatePoint":{"line":192,"column":39},"line":192,"code":"    it('should bind error event handler', () => {\n      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));\n      const emitter = {\n        on: callback,\n      };\n      client.bindEvents(emitter as any);\n      expect(callback.getCall(0).args[0]).to.be.eql(ERROR_EVENT);\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish packet","suites":["ClientTCP","dispatchEvent"],"updatePoint":{"line":213,"column":29},"line":213,"code":"    it('should publish packet', async () => {\n      await client['dispatchEvent'](msg);\n\n      expect(sendMessageStub.called).to.be.true;\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should upgrade to TLS","suites":["ClientTCP","tls"],"updatePoint":{"line":221,"column":29},"line":221,"code":"    it('should upgrade to TLS', () => {\n      const client = new ClientTCP({ tlsOptions: {} });\n      const jsonSocket = client.createSocket();\n      expect(jsonSocket.socket).instanceOf(TLSSocket);\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not upgrade to TLS, if not requested","suites":["ClientTCP","tls"],"updatePoint":{"line":226,"column":51},"line":226,"code":"    it('should not upgrade to TLS, if not requested', () => {\n      const jsonSocket = new ClientTCP({}).createSocket();\n      expect(jsonSocket.socket).instanceOf(NetSocket);\n    });","file":"client/client-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return array of clients","suites":["ClientsContainer","getAllClients"],"updatePoint":{"line":10,"column":38},"line":10,"code":"    it('should return array of clients', () => {\n      const clients = [1, 2, 3];\n      (instance as any).clients = clients;\n      expect(instance.getAllClients()).to.be.eql(clients);\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should push client into clients array","suites":["ClientsContainer","addClient"],"updatePoint":{"line":17,"column":45},"line":17,"code":"    it('should push client into clients array', () => {\n      const client = 'test';\n      instance.addClient(client as any);\n      expect(instance.getAllClients()).to.be.deep.equal([client]);\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should remove all clients","suites":["ClientsContainer","clear"],"updatePoint":{"line":24,"column":33},"line":24,"code":"    it('should remove all clients', () => {\n      const clients = [1, 2, 3];\n      (instance as any).clients = clients;\n      instance.clear();\n      expect(instance.getAllClients()).to.be.deep.equal([]);\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return plain ExceptionHandler object","suites":["ExceptionFiltersContext","create","when filters metadata is empty"],"updatePoint":{"line":33,"column":53},"line":33,"code":"      it('should return plain ExceptionHandler object', () => {\n        const filter = exceptionFilter.create(\n          new EmptyMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.be.empty;\n      });","file":"context/exception-filters-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return ExceptionHandler object with exception filters","suites":["ExceptionFiltersContext","create","when filters metadata is not empty"],"updatePoint":{"line":46,"column":70},"line":46,"code":"      it('should return ExceptionHandler object with exception filters', () => {\n        const filter = exceptionFilter.create(\n          new WithMetadata(),\n          () => ({} as any),\n          undefined,\n        );\n        expect((filter as any).filters).to.not.be.empty;\n      });","file":"context/exception-filters-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return global filters","suites":["ExceptionFiltersContext","getGlobalMetadata","when contextId is static and inquirerId is nil"],"updatePoint":{"line":59,"column":38},"line":59,"code":"      it('should return global filters', () => {\n        const expectedResult = applicationConfig.getGlobalFilters();\n        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);\n      });","file":"context/exception-filters-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should merge static global with request/transient scoped filters","suites":["ExceptionFiltersContext","getGlobalMetadata","otherwise"],"updatePoint":{"line":65,"column":74},"line":65,"code":"      it('should merge static global with request/transient scoped filters', () => {\n        const globalFilters: any = ['test'];\n        const instanceWrapper = new InstanceWrapper();\n        const instance = 'request-scoped';\n        const scopedFilterWrappers = [instanceWrapper];\n\n        sinon\n          .stub(applicationConfig, 'getGlobalFilters')\n          .callsFake(() => globalFilters);\n        sinon\n          .stub(applicationConfig, 'getGlobalRequestFilters')\n          .callsFake(() => scopedFilterWrappers);\n        sinon\n          .stub(instanceWrapper, 'getInstanceByContextId')\n          .callsFake(() => ({ instance } as any));\n\n        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(\n          instance,\n          ...globalFilters,\n        );\n      });","file":"context/exception-filters-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return \"data\" property","suites":["RequestContextHost","getData"],"updatePoint":{"line":15,"column":37},"line":15,"code":"    it('should return \"data\" property', () => {\n      expect(ctxHost.getData()).to.be.eql(data);\n    });","file":"context/request-context-host.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return \"context\" property","suites":["RequestContextHost","getContext"],"updatePoint":{"line":20,"column":40},"line":20,"code":"    it('should return \"context\" property', () => {\n      expect(ctxHost.getContext()).to.be.eql(ctx);\n    });","file":"context/request-context-host.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return \"pattern\" property","suites":["RequestContextHost","getPattern"],"updatePoint":{"line":25,"column":40},"line":25,"code":"    it('should return \"pattern\" property', () => {\n      expect(ctxHost.getPattern()).to.be.eql(pattern);\n    });","file":"context/request-context-host.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create exception handler","suites":["RpcContextCreator","create"],"updatePoint":{"line":82,"column":39},"line":82,"code":"    it('should create exception handler', () => {\n      const handlerCreateSpy = sinon.spy(exceptionFiltersContext, 'create');\n      contextCreator.create(instance, instance.test, module, 'test');\n      expect(\n        handlerCreateSpy.calledWith(instance, instance.test as any, module),\n      ).to.be.true;\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create pipes context","suites":["RpcContextCreator","create"],"updatePoint":{"line":89,"column":35},"line":89,"code":"    it('should create pipes context', () => {\n      const pipesCreateSpy = sinon.spy(pipesCreator, 'create');\n      contextCreator.create(instance, instance.test, module, 'test');\n      expect(pipesCreateSpy.calledWith(instance, instance.test as any, module))\n        .to.be.true;\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should create guards context","suites":["RpcContextCreator","create"],"updatePoint":{"line":95,"column":36},"line":95,"code":"    it('should create guards context', () => {\n      const guardsCreateSpy = sinon.spy(guardsContextCreator, 'create');\n      contextCreator.create(instance, instance.test, module, 'test');\n      expect(guardsCreateSpy.calledWith(instance, instance.test, module)).to.be\n        .true;\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call guards consumer `tryActivate`","suites":["RpcContextCreator","create","when proxy called"],"updatePoint":{"line":102,"column":51},"line":102,"code":"      it('should call guards consumer `tryActivate`', async () => {\n        const tryActivateSpy = sinon.spy(guardsConsumer, 'tryActivate');\n        sinon\n          .stub(guardsContextCreator, 'create')\n          .callsFake(() => [{ canActivate: () => true }]);\n        const proxy = await contextCreator.create(\n          instance,\n          instance.test,\n          module,\n          'test',\n        );\n        const data = 'test';\n        await proxy(data);\n\n        expect(tryActivateSpy.called).to.be.true;\n      });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw forbidden exception","suites":["RpcContextCreator","create","when proxy called","when can not activate"],"updatePoint":{"line":119,"column":44},"line":119,"code":"        it('should throw forbidden exception', async () => {\n          sinon\n            .stub(guardsConsumer, 'tryActivate')\n            .callsFake(async () => false);\n\n          const proxy = await contextCreator.create(\n            instance,\n            instance.test,\n            module,\n            'test',\n          );\n          const data = 'test';\n\n          proxy(null, data).catch(err =>\n            expect(err).to.be.instanceOf(RpcException),\n          );\n        });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return paramtypes array","suites":["RpcContextCreator","reflectCallbackParamtypes"],"updatePoint":{"line":141,"column":38},"line":141,"code":"    it('should return paramtypes array', () => {\n      const paramtypes = contextCreator.reflectCallbackParamtypes(\n        instance,\n        instance.test,\n      );\n      expect(paramtypes).to.be.eql([String]);\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception when \"tryActivate\" returns false","suites":["RpcContextCreator","createGuardsFn"],"updatePoint":{"line":151,"column":63},"line":151,"code":"    it('should throw exception when \"tryActivate\" returns false', () => {\n      const guardsFn = contextCreator.createGuardsFn([null], null, null);\n      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);\n      guardsFn([]).catch(err => expect(err).to.not.be.undefined);\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should exchange arguments keys for appropriate values","suites":["RpcContextCreator","exchangeKeysForValues"],"updatePoint":{"line":159,"column":61},"line":159,"code":"    it('should exchange arguments keys for appropriate values', () => {\n      const metadata = {\n        [RpcParamtype.PAYLOAD]: { index: 0, data: 'test', pipes: [] },\n        [RpcParamtype.CONTEXT]: { index: 2, data: 'test', pipes: [] },\n        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {\n          index: 3,\n          data: 'custom',\n          pipes: [],\n        },\n      };\n      const keys = Object.keys(metadata);\n      const values = contextCreator.exchangeKeysForValues(\n        keys,\n        metadata,\n        '',\n        new RpcParamsFactory(),\n        (args: unknown[]) => new ExecutionContextHost(args),\n      );\n      const expectedValues = [\n        { index: 0, type: RpcParamtype.PAYLOAD, data: 'test' },\n        { index: 2, type: RpcParamtype.CONTEXT, data: 'test' },\n        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },\n      ];\n      expect(values[0]).to.deep.include(expectedValues[0]);\n      expect(values[1]).to.deep.include(expectedValues[1]);\n      expect(values[2]).to.deep.include(expectedValues[2]);\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"consumer.apply\"","suites":["RpcContextCreator","getParamValue"],"updatePoint":{"line":196,"column":36},"line":196,"code":"    it('should call \"consumer.apply\"', () => {\n      contextCreator.getParamValue(\n        value,\n        { metatype, type: RpcParamtype.PAYLOAD, data: null },\n        transforms,\n      );\n      expect(consumerApplySpy.called).to.be.true;\n    });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"returns null","suites":["RpcContextCreator","createPipesFn","when \"paramsOptions\" is empty"],"updatePoint":{"line":207,"column":22},"line":207,"code":"      it('returns null', async () => {\n        const pipesFn = contextCreator.createPipesFn([], []);\n        expect(pipesFn).to.be.null;\n      });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"returns function","suites":["RpcContextCreator","createPipesFn","when \"paramsOptions\" is not empty"],"updatePoint":{"line":213,"column":26},"line":213,"code":"      it('returns function', async () => {\n        const pipesFn = contextCreator.createPipesFn(\n          [],\n          [\n            {\n              index: 1,\n              type: 'test',\n              data: null,\n              pipes: [],\n              extractValue: () => null,\n            },\n          ],\n        );\n        await pipesFn([]);\n        expect(pipesFn).to.be.a('function');\n      });","file":"context/rpc-context-creator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should method return thunk","suites":["RpcProxy","create"],"updatePoint":{"line":20,"column":34},"line":20,"code":"    it('should method return thunk', async () => {\n      const proxy = await routerProxy.create(async data => of(true), handler);\n      expect(typeof proxy === 'function').to.be.true;\n    });","file":"context/rpc-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should method encapsulate callback passed as argument","suites":["RpcProxy","create"],"updatePoint":{"line":25,"column":61},"line":25,"code":"    it('should method encapsulate callback passed as argument', async () => {\n      const expectation = handlerMock.expects('handle').once();\n      const proxy = routerProxy.create(async data => {\n        throw new RpcException('test');\n      }, handler);\n      await proxy(null);\n      expectation.verify();\n    });","file":"context/rpc-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should attach \"catchError\" operator when observable was returned","suites":["RpcProxy","create"],"updatePoint":{"line":34,"column":72},"line":34,"code":"    it('should attach \"catchError\" operator when observable was returned', async () => {\n      const expectation = handlerMock.expects('handle').once();\n      const proxy = routerProxy.create(async (client, data) => {\n        return throwError(() => new RpcException('test'));\n      }, handler);\n      (await proxy(null, null)).subscribe({\n        error: () => expectation.verify(),\n      });\n    });","file":"context/rpc-proxy.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return \"args\" array","suites":["BaseRpcContext","getArgs"],"updatePoint":{"line":12,"column":34},"line":12,"code":"    it('should return \"args\" array', () => {\n      expect(rpcContext.getArgs()).to.be.eql(args);\n    });","file":"ctx-host/base-rpc-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return argument by index","suites":["BaseRpcContext","getArgByIndex"],"updatePoint":{"line":17,"column":39},"line":17,"code":"    it('should return argument by index', () => {\n      expect(rpcContext.getArgByIndex(0)).to.be.eql(args[0]);\n      expect(rpcContext.getArgByIndex(1)).to.be.eql(args[1]);\n      expect(rpcContext.getArgByIndex(2)).to.be.eql(args[2]);\n    });","file":"ctx-host/base-rpc-context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return topic","suites":["KafkaContext","getTopic"],"updatePoint":{"line":33,"column":27},"line":33,"code":"    it('should return topic', () => {\n      expect(context.getTopic()).to.be.eql(args[2]);\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return partition","suites":["KafkaContext","getPartition"],"updatePoint":{"line":38,"column":31},"line":38,"code":"    it('should return partition', () => {\n      expect(context.getPartition()).to.be.eql(args[1]);\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return original message","suites":["KafkaContext","getMessage"],"updatePoint":{"line":43,"column":38},"line":43,"code":"    it('should return original message', () => {\n      expect(context.getMessage()).to.be.eql(args[0]);\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return consumer instance","suites":["KafkaContext","getConsumer"],"updatePoint":{"line":48,"column":39},"line":48,"code":"    it('should return consumer instance', () => {\n      expect(context.getConsumer()).to.deep.eq({ test: 'consumer' });\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return heartbeat callback","suites":["KafkaContext","getHeartbeat"],"updatePoint":{"line":53,"column":40},"line":53,"code":"    it('should return heartbeat callback', () => {\n      expect(context.getHeartbeat()).to.be.eql(args[4]);\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return producer instance","suites":["KafkaContext","getProducer"],"updatePoint":{"line":58,"column":39},"line":58,"code":"    it('should return producer instance', () => {\n      expect(context.getProducer()).to.deep.eq({ test: 'producer' });\n    });","file":"ctx-host/kafka.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return topic","suites":["MqttContext","getTopic"],"updatePoint":{"line":12,"column":27},"line":12,"code":"    it('should return topic', () => {\n      expect(context.getTopic()).to.be.eql(args[0]);\n    });","file":"ctx-host/mqtt.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return packet","suites":["MqttContext","getPacket"],"updatePoint":{"line":17,"column":28},"line":17,"code":"    it('should return packet', () => {\n      expect(context.getPacket()).to.be.eql(args[1]);\n    });","file":"ctx-host/mqtt.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return subject","suites":["NatsContext","getSubject"],"updatePoint":{"line":12,"column":29},"line":12,"code":"    it('should return subject', () => {\n      expect(context.getSubject()).to.be.eql(args[0]);\n    });","file":"ctx-host/nats.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return headers","suites":["NatsContext","getHeaders"],"updatePoint":{"line":17,"column":29},"line":17,"code":"    it('should return headers', () => {\n      expect(context.getHeaders()).to.be.eql(args[1]);\n    });","file":"ctx-host/nats.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return original channel","suites":["RedisContext","getChannel"],"updatePoint":{"line":12,"column":38},"line":12,"code":"    it('should return original channel', () => {\n      expect(context.getChannel()).to.be.eql(args[0]);\n    });","file":"ctx-host/redis.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return original message","suites":["RmqContext","getMessage"],"updatePoint":{"line":12,"column":38},"line":12,"code":"    it('should return original message', () => {\n      expect(context.getMessage()).to.be.eql(args[0]);\n    });","file":"ctx-host/rmq.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return channel reference","suites":["RmqContext","getChannelRef"],"updatePoint":{"line":17,"column":39},"line":17,"code":"    it('should return channel reference', () => {\n      expect(context.getChannelRef()).to.be.eql(args[1]);\n    });","file":"ctx-host/rmq.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return pattern","suites":["RmqContext","getPattern"],"updatePoint":{"line":22,"column":29},"line":22,"code":"    it('should return pattern', () => {\n      expect(context.getPattern()).to.be.eql(args[2]);\n    });","file":"ctx-host/rmq.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return subject","suites":["TcpContext","getSubject"],"updatePoint":{"line":12,"column":29},"line":12,"code":"    it('should return subject', () => {\n      expect(context.getSocketRef()).to.be.eql(args[0]);\n    });","file":"ctx-host/tcp.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return pattern","suites":["TcpContext","getPattern"],"updatePoint":{"line":17,"column":29},"line":17,"code":"    it('should return pattern', () => {\n      expect(context.getPattern()).to.be.eql(args[1]);\n    });","file":"ctx-host/tcp.context.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance property with metadata","suites":["@Client"],"updatePoint":{"line":15,"column":43},"line":15,"code":"  it(`should enhance property with metadata`, () => {\n    const isClient = Reflect.getOwnMetadata(\n      CLIENT_METADATA,\n      TestComponent,\n      'instance',\n    );\n    const config = Reflect.getOwnMetadata(\n      CLIENT_CONFIGURATION_METADATA,\n      TestComponent,\n      'instance',\n    );\n\n    expect(isClient).to.be.true;\n    expect(config).to.be.eql(pattern);\n  });","file":"decorators/client.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance class with expected request metadata","suites":["@Ctx"],"updatePoint":{"line":11,"column":57},"line":11,"code":"  it('should enhance class with expected request metadata', () => {\n    const argsMetadata = Reflect.getMetadata(\n      PARAM_ARGS_METADATA,\n      CtxTest,\n      'test',\n    );\n    const expectedMetadata = {\n      [`${RpcParamtype.CONTEXT}:0`]: {\n        data: undefined,\n        index: 0,\n        pipes: [],\n      },\n    };\n    expect(argsMetadata).to.be.eql(expectedMetadata);\n  });","file":"decorators/ctx.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@EventPattern"],"updatePoint":{"line":26,"column":61},"line":26,"code":"  it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {\n    const metadata = Reflect.getMetadata(PATTERN_METADATA, TestComponent.test);\n    expect(metadata.length).to.equal(1);\n    expect(metadata[0]).to.be.eql(pattern);\n  });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@EventPattern"],"updatePoint":{"line":31,"column":68},"line":31,"code":"  it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n    const metadata = Reflect.getMetadata(\n      PATTERN_EXTRAS_METADATA,\n      TestComponent.test,\n    );\n    expect(metadata).to.be.deep.equal(extras);\n  });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with last  metadata","suites":["@EventPattern"],"updatePoint":{"line":38,"column":66},"line":38,"code":"  it(`should enhance method with last ${PATTERN_METADATA} metadata`, () => {\n    const metadata = Reflect.getMetadata(\n      PATTERN_METADATA,\n      TestComponent.testOnlyThird,\n    );\n    expect(metadata.length).to.equal(1);\n    expect(metadata[0]).to.be.eql(patternSecond);\n  });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with both  metadata","suites":["@EventPattern"],"updatePoint":{"line":46,"column":66},"line":46,"code":"  it(`should enhance method with both ${PATTERN_METADATA} metadata`, () => {\n    const metadata = Reflect.getMetadata(\n      PATTERN_METADATA,\n      TestComponent.testBoth,\n    );\n    expect(metadata.length).to.equal(2);\n    expect(metadata[0]).to.be.eql(patternSecond);\n    expect(metadata[1]).to.be.eql(patternThird);\n  });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@EventPattern","decorator overloads"],"updatePoint":{"line":88,"column":63},"line":88,"code":"    it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent1.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent1.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent1.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.undefined;\n      expect(extrasArg).to.be.eql({});\n    });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  metadata","suites":["@EventPattern","decorator overloads"],"updatePoint":{"line":106,"column":86},"line":106,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent2.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent2.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent2.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql({});\n    });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  metadata","suites":["@EventPattern","decorator overloads"],"updatePoint":{"line":124,"column":91},"line":124,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent3.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent3.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent3.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.undefined;\n      expect(extrasArg).to.be.eql(extras);\n    });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  and \\\n metadata","suites":["@EventPattern","decorator overloads"],"updatePoint":{"line":143,"column":35},"line":142,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \\\n${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent4.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent4.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent4.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql(extras);\n    });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should merge with existing  metadata","suites":["@EventPattern","decorator overloads"],"updatePoint":{"line":161,"column":70},"line":161,"code":"    it(`should merge with existing ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent5.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent5.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent5.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql({\n        ...additionalExtras,\n        ...extras,\n      });\n    });","file":"decorators/event-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@MessagePattern"],"updatePoint":{"line":23,"column":61},"line":23,"code":"  it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {\n    const [metadata] = Reflect.getMetadata(\n      PATTERN_METADATA,\n      TestComponent.test,\n    );\n    expect(metadata).to.be.eql(pattern);\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@MessagePattern"],"updatePoint":{"line":30,"column":68},"line":30,"code":"  it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n    const metadata = Reflect.getMetadata(\n      PATTERN_EXTRAS_METADATA,\n      TestComponent.test,\n    );\n    expect(metadata).to.be.deep.equal(extras);\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with  metadata","suites":["@MessagePattern","decorator overloads"],"updatePoint":{"line":70,"column":63},"line":70,"code":"    it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent1.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent1.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent1.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.undefined;\n      expect(extrasArg).to.be.eql({});\n    });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  metadata","suites":["@MessagePattern","decorator overloads"],"updatePoint":{"line":88,"column":86},"line":88,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent2.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent2.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent2.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql({});\n    });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  metadata","suites":["@MessagePattern","decorator overloads"],"updatePoint":{"line":106,"column":91},"line":106,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent3.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent3.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent3.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.undefined;\n      expect(extrasArg).to.be.eql(extras);\n    });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance method with ,  and \\\n metadata","suites":["@MessagePattern","decorator overloads"],"updatePoint":{"line":125,"column":35},"line":124,"code":"    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \\\n${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent4.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent4.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent4.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql(extras);\n    });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should merge with existing  metadata","suites":["@MessagePattern","decorator overloads"],"updatePoint":{"line":143,"column":70},"line":143,"code":"    it(`should merge with existing ${PATTERN_EXTRAS_METADATA} metadata`, () => {\n      const [metadataArg] = Reflect.getMetadata(\n        PATTERN_METADATA,\n        TestComponent5.test,\n      );\n      const transportArg = Reflect.getMetadata(\n        TRANSPORT_METADATA,\n        TestComponent5.test,\n      );\n      const extrasArg = Reflect.getMetadata(\n        PATTERN_EXTRAS_METADATA,\n        TestComponent5.test,\n      );\n      expect(metadataArg).to.be.eql(pattern);\n      expect(transportArg).to.be.eql(Transport.TCP);\n      expect(extrasArg).to.be.eql({\n        ...additionalExtras,\n        ...extras,\n      });\n    });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method and service name","suites":["@GrpcMethod"],"updatePoint":{"line":178,"column":43},"line":178,"code":"  it('should derive method and service name', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);\n    expect(metadata).to.be.eql({\n      service: TestService.name,\n      rpc: 'Test',\n      streaming: GrpcMethodStreamingType.NO_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method","suites":["@GrpcMethod"],"updatePoint":{"line":188,"column":26},"line":188,"code":"  it('should derive method', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.NO_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should override both method and service","suites":["@GrpcMethod"],"updatePoint":{"line":198,"column":45},"line":198,"code":"  it('should override both method and service', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.NO_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method and service name","suites":["@GrpcStreamMethod"],"updatePoint":{"line":221,"column":43},"line":221,"code":"  it('should derive method and service name', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);\n    expect(metadata).to.be.eql({\n      service: TestService.name,\n      rpc: 'Test',\n      streaming: GrpcMethodStreamingType.RX_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method","suites":["@GrpcStreamMethod"],"updatePoint":{"line":231,"column":26},"line":231,"code":"  it('should derive method', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.RX_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should override both method and service","suites":["@GrpcStreamMethod"],"updatePoint":{"line":241,"column":45},"line":241,"code":"  it('should override both method and service', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.RX_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method and service name","suites":["@GrpcStreamCall"],"updatePoint":{"line":264,"column":43},"line":264,"code":"  it('should derive method and service name', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);\n    expect(metadata).to.be.eql({\n      service: TestService.name,\n      rpc: 'Test',\n      streaming: GrpcMethodStreamingType.PT_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should derive method","suites":["@GrpcStreamCall"],"updatePoint":{"line":274,"column":26},"line":274,"code":"  it('should derive method', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.PT_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should override both method and service","suites":["@GrpcStreamCall"],"updatePoint":{"line":284,"column":45},"line":284,"code":"  it('should override both method and service', () => {\n    const svc = new TestService();\n    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);\n    expect(metadata).to.be.eql({\n      service: 'TestService2',\n      rpc: 'Test2',\n      streaming: GrpcMethodStreamingType.PT_STREAMING,\n    });\n  });","file":"decorators/message-pattern.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should enhance class with expected request metadata","suites":["@Payload"],"updatePoint":{"line":12,"column":57},"line":12,"code":"  it('should enhance class with expected request metadata', () => {\n    const argsMetadata = Reflect.getMetadata(\n      PARAM_ARGS_METADATA,\n      MessagePayloadTest,\n      'test',\n    );\n    const expectedMetadata = {\n      [`${RpcParamtype.PAYLOAD}:0`]: {\n        data: undefined,\n        index: 0,\n        pipes: [ValidationPipe],\n      },\n    };\n    expect(argsMetadata).to.be.eql(expectedMetadata);\n  });","file":"decorators/payload.decorator.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the value unchanged","suites":["IdentityDeserializer","deserialize"],"updatePoint":{"line":10,"column":41},"line":10,"code":"    it('should return the value unchanged', () => {\n      const value = {};\n      expect(instance.deserialize(value)).to.be.eql(value);\n    });","file":"deserializers/identity.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the same value unchanged","suites":["IncomingRequestDeserializer","deserialize","when response is not external"],"updatePoint":{"line":12,"column":48},"line":12,"code":"      it('should return the same value unchanged', () => {\n        const incomingRequest: IncomingRequest = {\n          id: '1',\n          pattern: 'pattern',\n          data: [],\n        };\n        expect(instance.deserialize(incomingRequest)).to.be.equal(\n          incomingRequest,\n        );\n      });","file":"deserializers/incoming-request.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should map to the internal schema","suites":["IncomingRequestDeserializer","deserialize","otherwise","when options are passed in"],"updatePoint":{"line":25,"column":45},"line":25,"code":"        it('should map to the internal schema', () => {\n          const externalRequest = {\n            array: [1, 2, 3],\n          };\n          const options = {\n            channel: 'test',\n          };\n          expect(\n            instance.deserialize(externalRequest, options),\n          ).to.be.deep.equal({\n            pattern: options.channel,\n            data: externalRequest,\n          });\n        });","file":"deserializers/incoming-request.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should map to proper schema with undefined values","suites":["IncomingRequestDeserializer","deserialize","otherwise","when options are undefined"],"updatePoint":{"line":41,"column":61},"line":41,"code":"        it('should map to proper schema with undefined values', () => {\n          expect(instance.deserialize({})).to.be.deep.equal({\n            pattern: undefined,\n            data: undefined,\n          });\n        });","file":"deserializers/incoming-request.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the same value unchanged","suites":["IncomingResponseDeserializer","deserialize","when response is not external"],"updatePoint":{"line":12,"column":48},"line":12,"code":"      it('should return the same value unchanged', () => {\n        const incomingResponse: IncomingResponse = {\n          id: '1',\n          response: {},\n        };\n        const errResponse: IncomingResponse = {\n          id: '1',\n          err: {},\n        };\n        expect(instance.deserialize(incomingResponse)).to.be.equal(\n          incomingResponse,\n        );\n        expect(instance.deserialize(errResponse)).to.be.equal(errResponse);\n      });","file":"deserializers/incoming-response.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should map to the internal schema","suites":["IncomingResponseDeserializer","deserialize","otherwise"],"updatePoint":{"line":28,"column":43},"line":28,"code":"      it('should map to the internal schema', () => {\n        const externalResponse = {\n          id: '1',\n          array: [1, 2, 3],\n        };\n        expect(instance.deserialize(externalResponse)).to.be.deep.equal({\n          id: externalResponse.id,\n          isDisposed: true,\n          response: externalResponse,\n        });\n      });","file":"deserializers/incoming-response.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an object with \"err\"","suites":["KafkaResponseDeserializer","serialize","when error header is present"],"updatePoint":{"line":14,"column":44},"line":14,"code":"      it('should return an object with \"err\"', () => {\n        const err = new Error();\n        const packet = instance.deserialize({\n          headers: {\n            [KafkaHeaders.CORRELATION_ID]: id,\n            [KafkaHeaders.NEST_ERR]: err,\n          },\n        });\n        expect(packet.id).to.be.equal(id);\n        expect(packet.err).to.be.equal(err);\n        expect(packet.isDisposed).to.be.true;\n        expect(packet.response).to.be.undefined;\n      });","file":"deserializers/kafka-response.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an object with \"isDisposed\"","suites":["KafkaResponseDeserializer","serialize","when is disposed header is present"],"updatePoint":{"line":29,"column":51},"line":29,"code":"      it('should return an object with \"isDisposed\"', () => {\n        const value = 'test';\n        const packet = instance.deserialize({\n          headers: {\n            [KafkaHeaders.CORRELATION_ID]: id,\n            [KafkaHeaders.NEST_IS_DISPOSED]: true,\n          },\n          value,\n        });\n        expect(packet.id).to.be.equal(id);\n        expect(packet.err).to.be.undefined;\n        expect(packet.isDisposed).to.be.true;\n        expect(packet.response).to.be.eql(value);\n      });","file":"deserializers/kafka-response.deserializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return error message as string","suites":["RpcException","when string passed"],"updatePoint":{"line":9,"column":45},"line":9,"code":"    it('should return error message as string', () => {\n      expect(instance.getError()).to.be.eql(error);\n    });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should set the message property","suites":["RpcException","when string passed"],"updatePoint":{"line":12,"column":39},"line":12,"code":"    it('should set the message property', () => {\n      expect(instance.message).to.be.eql(error);\n    });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return error as object","suites":["RpcException","when object passed","and message property is undefined"],"updatePoint":{"line":22,"column":39},"line":22,"code":"      it('should return error as object', () => {\n        expect(instance.getError()).to.be.eql(error);\n      });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should fallback error message to class name","suites":["RpcException","when object passed","and message property is undefined"],"updatePoint":{"line":25,"column":53},"line":25,"code":"      it('should fallback error message to class name', () => {\n        expect(instance.message).to.be.eql('Rpc Exception');\n      });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return error as object","suites":["RpcException","when object passed","and message property is not undefined"],"updatePoint":{"line":33,"column":39},"line":33,"code":"      it('should return error as object', () => {\n        expect(instance.getError()).to.be.eql(error);\n      });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return error message as the extracted \"message\" string","suites":["RpcException","when object passed","and message property is not undefined"],"updatePoint":{"line":36,"column":71},"line":36,"code":"      it('should return error message as the extracted \"message\" string', () => {\n        expect(instance.message).to.be.eql(error.message);\n      });","file":"exceptions/rpc-exception.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should method returns expected stream with message when exception is unknown","suites":["RpcExceptionsHandler","handle"],"updatePoint":{"line":16,"column":84},"line":16,"code":"    it('should method returns expected stream with message when exception is unknown', done => {\n      const stream$ = handler.handle(new Error(), null);\n      stream$\n        .pipe(\n          catchError((err: any) => {\n            expect(err).to.be.eql({\n              status: 'error',\n              message: 'Internal server error',\n            });\n            done();\n            return EMPTY;\n          }),\n        )\n        .subscribe(() => ({}));\n    });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should method emit expected status and json object","suites":["RpcExceptionsHandler","handle","when exception is instance of WsException"],"updatePoint":{"line":32,"column":60},"line":32,"code":"      it('should method emit expected status and json object', done => {\n        const message = {\n          custom: 'Unauthorized',\n        };\n        const stream$ = handler.handle(new RpcException(message), null);\n        stream$\n          .pipe(\n            catchError((err: any) => {\n              expect(err).to.be.eql(message);\n              done();\n              return EMPTY;\n            }),\n          )\n          .subscribe(() => ({}));\n      });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should method emit expected status and transform message to json","suites":["RpcExceptionsHandler","handle","when exception is instance of WsException"],"updatePoint":{"line":47,"column":74},"line":47,"code":"      it('should method emit expected status and transform message to json', done => {\n        const message = 'Unauthorized';\n\n        const stream$ = handler.handle(new RpcException(message), null);\n        stream$\n          .pipe(\n            catchError((err: any) => {\n              expect(err).to.be.eql({ message, status: 'error' });\n              done();\n              return EMPTY;\n            }),\n          )\n          .subscribe(() => ({}));\n      });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return observable","suites":["RpcExceptionsHandler","handle","when \"invokeCustomFilters\" returns observable"],"updatePoint":{"line":67,"column":34},"line":67,"code":"      it('should return observable', () => {\n        const result = handler.handle(new RpcException(''), null);\n        expect(result).to.be.eql(observable$);\n      });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should set custom filters","suites":["RpcExceptionsHandler","setCustomFilters"],"updatePoint":{"line":75,"column":33},"line":75,"code":"    it('should set custom filters', () => {\n      handler.setCustomFilters(filters as any);\n      expect((handler as any).filters).to.be.eql(filters);\n    });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw exception when passed argument is not an array","suites":["RpcExceptionsHandler","setCustomFilters"],"updatePoint":{"line":79,"column":67},"line":79,"code":"    it('should throw exception when passed argument is not an array', () => {\n      expect(() => handler.setCustomFilters(null)).to.throw();\n    });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return identity","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is empty"],"updatePoint":{"line":85,"column":32},"line":85,"code":"      it('should return identity', () => {\n        expect(handler.invokeCustomFilters(null, null)).to.be.null;\n      });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call funcSpy","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":101,"column":31},"line":101,"code":"        it('should call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.false;\n        });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call funcSpy with exception and response passed as an arguments","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":105,"column":82},"line":105,"code":"        it('should call funcSpy with exception and response passed as an arguments', () => {\n          const exception = new TestException();\n          handler.invokeCustomFilters(exception, null);\n          expect(funcSpy.calledWith(exception)).to.be.true;\n        });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return stream","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":110,"column":32},"line":110,"code":"        it('should return stream', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .not.null;\n        });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call funcSpy","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":116,"column":35},"line":116,"code":"        it('should not call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.true;\n        });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return null","suites":["RpcExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":120,"column":30},"line":120,"code":"        it('should return null', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .null;\n        });","file":"exceptions/rpc-exceptions-handler.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return a message payload object","suites":["RpcParamsFactory","exchangeKeyForValue","when key is","RpcParamtype.PAYLOAD"],"updatePoint":{"line":17,"column":50},"line":17,"code":"        it('should return a message payload object', () => {\n          expect(\n            factory.exchangeKeyForValue(RpcParamtype.PAYLOAD, null, args),\n          ).to.be.eql(payload);\n        });","file":"factories/rpc-params-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return a message payload object with parameter extraction","suites":["RpcParamsFactory","exchangeKeyForValue","when key is","RpcParamtype.PAYLOAD"],"updatePoint":{"line":22,"column":76},"line":22,"code":"        it('should return a message payload object with parameter extraction', () => {\n          expect(\n            factory.exchangeKeyForValue(RpcParamtype.PAYLOAD, 'data', args),\n          ).to.be.eql(payload.data);\n        });","file":"factories/rpc-params-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return a ctx object","suites":["RpcParamsFactory","exchangeKeyForValue","when key is","RpcParamtype.CONTEXT"],"updatePoint":{"line":29,"column":38},"line":29,"code":"        it('should return a ctx object', () => {\n          expect(\n            factory.exchangeKeyForValue(RpcParamtype.CONTEXT, null, args),\n          ).to.be.eql(ctx);\n        });","file":"factories/rpc-params-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return null","suites":["RpcParamsFactory","exchangeKeyForValue","when key is not available"],"updatePoint":{"line":37,"column":28},"line":37,"code":"      it('should return null', () => {\n        expect(factory.exchangeKeyForValue(-1, null, [])).to.be.eql(null);\n      });","file":"factories/rpc-params-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return null","suites":["RpcParamsFactory","exchangeKeyForValue","when args are not available"],"updatePoint":{"line":42,"column":28},"line":42,"code":"      it('should return null', () => {\n        expect(factory.exchangeKeyForValue(null, null, null)).to.be.eql(null);\n      });","file":"factories/rpc-params-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"error","suites":["KafkaLogger"],"updatePoint":{"line":38,"column":11},"line":38,"code":"  it('error', () => {\n    kafkaLogger({\n      namespace,\n      level: logLevel.ERROR,\n      label,\n      log: entry,\n    });\n\n    expect(error.calledOnce).to.be.true;\n    expect(error.args[0][0]).to.eq(\n      'label [namespace] message {\"other\":{\"stuff\":\"here\"}}',\n    );\n  });","file":"helpers/kafka-logger.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"nothing","suites":["KafkaLogger"],"updatePoint":{"line":52,"column":13},"line":52,"code":"  it('nothing', () => {\n    kafkaLogger({\n      namespace,\n      level: logLevel.NOTHING,\n      label,\n      log: entry,\n    });\n\n    expect(error.calledOnce).to.be.true;\n  });","file":"helpers/kafka-logger.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"warn","suites":["KafkaLogger"],"updatePoint":{"line":63,"column":10},"line":63,"code":"  it('warn', () => {\n    kafkaLogger({\n      namespace,\n      level: logLevel.WARN,\n      label,\n      log: entry,\n    });\n\n    expect(warn.calledOnce).to.be.true;\n  });","file":"helpers/kafka-logger.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"info","suites":["KafkaLogger"],"updatePoint":{"line":74,"column":10},"line":74,"code":"  it('info', () => {\n    kafkaLogger({\n      namespace,\n      level: logLevel.INFO,\n      label,\n      log: entry,\n    });\n\n    expect(log.calledOnce).to.be.true;\n  });","file":"helpers/kafka-logger.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"debug","suites":["KafkaLogger"],"updatePoint":{"line":85,"column":11},"line":85,"code":"  it('debug', () => {\n    kafkaLogger({\n      namespace,\n      level: logLevel.DEBUG,\n      label,\n      log: entry,\n    });\n\n    expect(debug.calledOnce).to.be.true;\n  });","file":"helpers/kafka-logger.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"undefined","suites":["KafkaParser","parse"],"updatePoint":{"line":13,"column":17},"line":13,"code":"    it('undefined', () => {\n      expect(\n        kafkaParser.parse({\n          value: undefined,\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: null,\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"null","suites":["KafkaParser","parse"],"updatePoint":{"line":24,"column":12},"line":24,"code":"    it('null', () => {\n      expect(\n        kafkaParser.parse({\n          value: null,\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: null,\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer string","suites":["KafkaParser","parse"],"updatePoint":{"line":35,"column":21},"line":35,"code":"    it('buffer string', () => {\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from('string'),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: 'string',\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"binary buffer using kafka schema registry preamble","suites":["KafkaParser","parse"],"updatePoint":{"line":46,"column":58},"line":46,"code":"    it('binary buffer using kafka schema registry preamble', () => {\n      const kafkaSchemaPreambleWithSchemaId = [0x00, 0x00, 0x00, 0x00, 0x01];\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from(kafkaSchemaPreambleWithSchemaId),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: Buffer.from(kafkaSchemaPreambleWithSchemaId),\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer number","suites":["KafkaParser","parse"],"updatePoint":{"line":58,"column":21},"line":58,"code":"    it('buffer number', () => {\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from('12345'),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: '12345',\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer bigint","suites":["KafkaParser","parse"],"updatePoint":{"line":69,"column":21},"line":69,"code":"    it('buffer bigint', () => {\n      const long = '9007199254740992';\n\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from(long),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: long,\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer json","suites":["KafkaParser","parse"],"updatePoint":{"line":82,"column":19},"line":82,"code":"    it('buffer json', () => {\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from(JSON.stringify({ prop: 'value' })),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: {\n          prop: 'value',\n        },\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer json with key","suites":["KafkaParser","parse"],"updatePoint":{"line":95,"column":28},"line":95,"code":"    it('buffer json with key', () => {\n      expect(\n        kafkaParser.parse({\n          value: Buffer.from(JSON.stringify({ prop: 'value' })),\n          key: Buffer.from('1'),\n        }),\n      ).to.deep.eq({\n        headers: {},\n        key: '1',\n        value: {\n          prop: 'value',\n        },\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer json with key and headers","suites":["KafkaParser","parse"],"updatePoint":{"line":110,"column":40},"line":110,"code":"    it('buffer json with key and headers', () => {\n      expect(\n        kafkaParser.parse({\n          headers: {\n            [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),\n          },\n          value: Buffer.from(JSON.stringify({ prop: 'value' })),\n          key: Buffer.from('1'),\n        }),\n      ).to.deep.eq({\n        key: '1',\n        value: {\n          prop: 'value',\n        },\n        headers: {\n          [KafkaHeaders.CORRELATION_ID]: 'correlation-id',\n        },\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"parse message multiple times (simulate retry)","suites":["KafkaParser","parse"],"updatePoint":{"line":130,"column":53},"line":130,"code":"    it('parse message multiple times (simulate retry)', () => {\n      const message = {\n        headers: {\n          [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),\n        },\n        value: Buffer.from(JSON.stringify({ prop: 'value' })),\n        key: Buffer.from('1'),\n      };\n      const expectedParsedMessage = {\n        key: '1',\n        value: {\n          prop: 'value',\n        },\n        headers: {\n          [KafkaHeaders.CORRELATION_ID]: 'correlation-id',\n        },\n      };\n      expect(kafkaParser.parse(message)).to.deep.eq(expectedParsedMessage);\n      // Parse message again and verify it still works correctly\n      expect(kafkaParser.parse(message)).to.deep.eq(expectedParsedMessage);\n      // Verify message was not modified\n      expect(message).to.deep.eq({\n        headers: {\n          [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),\n        },\n        value: Buffer.from(JSON.stringify({ prop: 'value' })),\n        key: Buffer.from('1'),\n      });\n    });","file":"helpers/kafka-parser.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"assign all partitions evenly","suites":["kafka reply partition assigner","assign"],"updatePoint":{"line":28,"column":36},"line":28,"code":"    it('assign all partitions evenly', async () => {\n      metadata['topic-A'] = Array(14)\n        .fill(1)\n        .map((_, i) => ({ partitionId: i }));\n\n      metadata['topic-B'] = Array(5)\n        .fill(1)\n        .map((_, i) => ({ partitionId: i }));\n\n      const members = [\n        {\n          memberId: 'member-3',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {},\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-1',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {},\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-4',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {},\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-2',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {},\n              }),\n            ),\n          }),\n        },\n      ];\n\n      const assignment = await assigner.assign({ members, topics });\n\n      expect(assignment).to.deep.equal([\n        {\n          memberId: 'member-1',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [0, 4, 8, 12],\n              'topic-B': [0],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-2',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [1, 5, 9, 13],\n              'topic-B': [1],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-3',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [2, 6, 10],\n              'topic-B': [2, 4],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-4',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [3, 7, 11],\n              'topic-B': [3],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n      ]);\n    });","file":"helpers/kafka-reply-partition-assigner.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"assign all partitions evenly","suites":["kafka reply partition assigner","re-assign"],"updatePoint":{"line":140,"column":36},"line":140,"code":"    it('assign all partitions evenly', async () => {\n      metadata['topic-A'] = Array(11)\n        .fill(1)\n        .map((_, i) => ({ partitionId: i }));\n\n      metadata['topic-B'] = Array(7)\n        .fill(1)\n        .map((_, i) => ({ partitionId: i }));\n\n      const members = [\n        {\n          memberId: 'member-3',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {\n                  'topic-A': 0,\n                  'topic-B': 0,\n                },\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-1',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {\n                  'topic-A': 1,\n                  'topic-B': 1,\n                },\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-4',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {\n                  'topic-A': 2,\n                },\n              }),\n            ),\n          }),\n        },\n        {\n          memberId: 'member-2',\n          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n            version: assigner.version,\n            topics: ['topic-A', 'topic-B'],\n            userData: Buffer.from(\n              JSON.stringify({\n                previousAssignment: {},\n              }),\n            ),\n          }),\n        },\n      ];\n\n      const assignment = await assigner.assign({ members, topics });\n\n      expect(assignment).to.deep.equal([\n        {\n          memberId: 'member-1',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [1, 4, 8],\n              'topic-B': [1, 5],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-2',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [3, 5, 9],\n              'topic-B': [2, 6],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-3',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [0, 6, 10],\n              'topic-B': [0],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n        {\n          memberId: 'member-4',\n          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({\n            version: assigner.version,\n            assignment: {\n              'topic-A': [2, 7],\n              'topic-B': [3, 4],\n            },\n            userData: Buffer.alloc(0),\n          }),\n        },\n      ]);\n    });","file":"helpers/kafka-reply-partition-assigner.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"returns the assigner name and metadata","suites":["kafka reply partition assigner","protocol"],"updatePoint":{"line":260,"column":46},"line":260,"code":"    it('returns the assigner name and metadata', () => {\n      // set previous assignments\n      (client as any).consumerAssignments = {\n        'topic-A': 0,\n        'topic-B': 1,\n      };\n\n      const protocol = assigner.protocol({ topics });\n\n      expect(getPreviousAssignment.calledOnce).to.be.true;\n      expect(getConsumerAssignments.calledOnce).to.be.true;\n\n      expect(protocol).to.deep.equal({\n        name: assigner.name,\n        metadata: Kafka.AssignerProtocol.MemberMetadata.encode({\n          version: assigner.version,\n          topics,\n          userData: Buffer.from(\n            JSON.stringify({\n              previousAssignment: (client as any).consumerAssignments,\n            }),\n          ),\n        }),\n      });\n    });","file":"helpers/kafka-reply-partition-assigner.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should connect, send and receive message","suites":["JsonSocket connection"],"updatePoint":{"line":10,"column":46},"line":10,"code":"  it('should connect, send and receive message', done => {\n    helpers.createServerAndClient(\n      (error, server, clientSocket, serverSocket) => {\n        if (error) {\n          return done(error);\n        }\n\n        expect(clientSocket['isClosed']).to.be.false;\n        expect(serverSocket['isClosed']).to.be.false;\n\n        Promise.all([\n          new Promise(callback => {\n            clientSocket.sendMessage({ type: 'ping' }, callback);\n          }),\n          new Promise<void>(callback => {\n            clientSocket.on(MESSAGE_EVENT, (message: string) => {\n              expect(message).to.deep.equal({ type: 'pong' });\n              callback();\n            });\n          }),\n          new Promise(callback => {\n            serverSocket.on(MESSAGE_EVENT, (message: string) => {\n              expect(message).to.deep.equal({ type: 'ping' });\n              serverSocket.sendMessage({ type: 'pong' }, callback);\n            });\n          }),\n        ])\n          .then(() => {\n            expect(clientSocket['isClosed']).to.equal(false);\n            expect(serverSocket['isClosed']).to.equal(false);\n            clientSocket.end();\n            server.close(done);\n          })\n          .catch(e => done(e));\n      },\n    );\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send long messages with special characters without issues","suites":["JsonSocket connection"],"updatePoint":{"line":48,"column":70},"line":48,"code":"  it('should send long messages with special characters without issues', done => {\n    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {\n      if (err) {\n        return done(err);\n      }\n      expect(clientSocket['isClosed']).to.equal(false);\n      expect(serverSocket['isClosed']).to.equal(false);\n      Promise.all([\n        new Promise<void>(callback => {\n          clientSocket.sendMessage(longPayload, callback);\n        }),\n        new Promise<void>(callback => {\n          clientSocket.on(MESSAGE_EVENT, (message: { type: 'pong' }) => {\n            expect(message).to.deep.equal({ type: 'pong' });\n            callback();\n          });\n        }),\n        new Promise<void>(callback => {\n          serverSocket.on(MESSAGE_EVENT, (message: { type: 'pong' }) => {\n            expect(message).to.deep.equal(longPayload);\n            serverSocket.sendMessage({ type: 'pong' }, callback);\n          });\n        }),\n      ])\n        .then(() => {\n          expect(clientSocket['isClosed']).to.equal(false);\n          expect(serverSocket['isClosed']).to.equal(false);\n          clientSocket.end();\n          server.close(done);\n        })\n        .catch(e => done(e));\n    });\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send multiple messages","suites":["JsonSocket connection"],"updatePoint":{"line":82,"column":35},"line":82,"code":"  it('should send multiple messages', done => {\n    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {\n      if (err) {\n        return done(err);\n      }\n      Promise.all([\n        new Promise<void>(callback =>\n          Promise.all(\n            helpers\n              .range(1, 100)\n              .map(\n                i =>\n                  new Promise(resolve =>\n                    clientSocket.sendMessage({ number: i }, resolve),\n                  ),\n              ),\n          ).then(_ => callback()),\n        ),\n        new Promise<void>(callback => {\n          let lastNumber = 0;\n          serverSocket.on(MESSAGE_EVENT, (message: { number: number }) => {\n            expect(message.number).to.deep.equal(lastNumber + 1);\n            lastNumber = message.number;\n            if (lastNumber === 100) {\n              callback();\n            }\n          });\n        }),\n      ])\n        .then(() => {\n          clientSocket.end();\n          server.close(done);\n        })\n        .catch(e => done(e));\n    });\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return true for \"closed\" when server disconnects","suites":["JsonSocket connection"],"updatePoint":{"line":119,"column":61},"line":119,"code":"  it('should return true for \"closed\" when server disconnects', done => {\n    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {\n      if (err) {\n        return done(err);\n      }\n\n      new Promise(callback => {\n        serverSocket.end();\n        setTimeout(callback, 10);\n      })\n        .then(\n          () =>\n            new Promise<void>(callback => {\n              expect(clientSocket['isClosed']).to.equal(true);\n              expect(serverSocket['isClosed']).to.equal(true);\n              callback();\n            }),\n        )\n        .then(() => {\n          clientSocket.end();\n          server.close(done);\n        })\n        .catch(e => done(e));\n    });\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return true for \"closed\" when client disconnects","suites":["JsonSocket connection"],"updatePoint":{"line":145,"column":61},"line":145,"code":"  it('should return true for \"closed\" when client disconnects', done => {\n    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {\n      if (err) {\n        return done(err);\n      }\n\n      new Promise(callback => {\n        clientSocket.end();\n        setTimeout(callback, 10);\n      })\n        .then(\n          () =>\n            new Promise<void>(callback => {\n              expect(clientSocket['isClosed']).to.equal(true);\n              expect(serverSocket['isClosed']).to.equal(true);\n              callback();\n            }),\n        )\n        .then(() => server.close(done))\n        .catch(e => done(e));\n    });\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return true for \"closed\" when client (re)connects","suites":["JsonSocket connection"],"updatePoint":{"line":168,"column":62},"line":168,"code":"  it('should return true for \"closed\" when client (re)connects', done => {\n    const server = createServer();\n\n    server.on('listening', () => {\n      const clientSocket = new JsonSocket(new Socket());\n\n      server.once('connection', socket => {\n        const serverSocket = new JsonSocket(socket);\n\n        serverSocket.once('end', () => {\n          setTimeout(() => {\n            expect(serverSocket['isClosed']).to.equal(true);\n            expect(clientSocket['isClosed']).to.equal(true);\n\n            clientSocket.on(CONNECT_EVENT, () => {\n              setTimeout(() => {\n                expect(clientSocket['isClosed']).to.equal(false);\n\n                clientSocket.end();\n                server.close(done);\n              }, 10);\n            });\n\n            const address2 = server.address();\n            if (!address2) {\n              throw new Error('server.address() returned null');\n            }\n            const port2 = (address2 as AddressInfo).port;\n\n            clientSocket.connect(port2, ip);\n          }, 10);\n        });\n\n        clientSocket.end();\n      });\n\n      const address1 = server.address();\n      if (!address1) {\n        throw new Error('server.address() returned null');\n      }\n      const port1 = (address1 as AddressInfo).port;\n\n      clientSocket.connect(port1, ip);\n    });\n    server.listen();\n  });","file":"json-socket/connection.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the instance when subscribing to event","suites":["JsonSocket chaining"],"updatePoint":{"line":7,"column":58},"line":7,"code":"  it('should return the instance when subscribing to event', done => {\n    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {\n      if (err) {\n        return done(err);\n      }\n\n      expect(clientSocket.on(MESSAGE_EVENT, () => {})).to.be.instanceof(\n        JsonSocket,\n      );\n      expect(clientSocket.on(CONNECT_EVENT, () => {})).to.deep.equal(\n        clientSocket,\n      );\n      expect(\n        clientSocket.on(MESSAGE_EVENT, () => {}).on('end', () => {}),\n      ).to.deep.equal(clientSocket);\n\n      clientSocket.end();\n      server.close(done);\n    });\n  });","file":"json-socket/listener-chaining.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse JSON strings","suites":["JsonSocket message parsing"],"updatePoint":{"line":21,"column":31},"line":21,"code":"  it('should parse JSON strings', () => {\n    socket['handleData']('13#\"Hello there\"');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal('Hello there');\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse JSON numbers","suites":["JsonSocket message parsing"],"updatePoint":{"line":28,"column":31},"line":28,"code":"  it('should parse JSON numbers', () => {\n    socket['handleData']('5#12.34');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal(12.34);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse JSON bools","suites":["JsonSocket message parsing"],"updatePoint":{"line":35,"column":29},"line":35,"code":"  it('should parse JSON bools', () => {\n    socket['handleData']('4#true');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal(true);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse JSON objects","suites":["JsonSocket message parsing"],"updatePoint":{"line":42,"column":31},"line":42,"code":"  it('should parse JSON objects', () => {\n    socket['handleData']('17#{\"a\":\"yes\",\"b\":9}');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal({ a: 'yes', b: 9 });\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse JSON arrays","suites":["JsonSocket message parsing"],"updatePoint":{"line":49,"column":30},"line":49,"code":"  it('should parse JSON arrays', () => {\n    socket['handleData']('9#[\"yes\",9]');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal(['yes', 9]);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse multiple messages in one packet","suites":["JsonSocket message parsing"],"updatePoint":{"line":56,"column":50},"line":56,"code":"  it('should parse multiple messages in one packet', () => {\n    socket['handleData']('5#\"hey\"4#true');\n    expect(messages.length).to.deep.equal(2);\n    expect(messages[0]).to.deep.equal('hey');\n    expect(messages[1]).to.deep.equal(true);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse chunked messages","suites":["JsonSocket message parsing"],"updatePoint":{"line":64,"column":35},"line":64,"code":"  it('should parse chunked messages', () => {\n    socket['handleData']('13#\"Hel');\n    socket['handleData']('lo there\"');\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal('Hello there');\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse chunked and multiple messages","suites":["JsonSocket message parsing"],"updatePoint":{"line":72,"column":48},"line":72,"code":"  it('should parse chunked and multiple messages', () => {\n    socket['handleData']('13#\"Hel');\n    socket['handleData']('lo there\"4#true');\n    expect(messages.length).to.deep.equal(2);\n    expect(messages[0]).to.deep.equal('Hello there');\n    expect(messages[1]).to.deep.equal(true);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse chunked messages with multi-byte characters","suites":["JsonSocket message parsing"],"updatePoint":{"line":81,"column":62},"line":81,"code":"  it('should parse chunked messages with multi-byte characters', () => {\n    // 0x33 0x23 0xd8 0x22 0xa9 0x22 = 3#\"ة\" (U+00629)\n    socket['onData'](Buffer.from([0x33, 0x23, 0x22, 0xd8]));\n    socket['onData'](Buffer.from([0xa9, 0x22]));\n    expect(messages.length).to.deep.equal(1);\n    expect(messages[0]).to.deep.equal('ة');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse multiple messages with unicode correctly","suites":["JsonSocket message parsing"],"updatePoint":{"line":89,"column":59},"line":89,"code":"  it('should parse multiple messages with unicode correctly', () => {\n    socket['handleData']('41#\"Diese Zeile enthält das Unicode-Zeichen\"4#true');\n    expect(messages[0]).to.deep.equal(\n      'Diese Zeile enthält das Unicode-Zeichen',\n    );\n    expect(messages[1]).to.deep.equal(true);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse multiple and chunked messages with unicode correctly","suites":["JsonSocket message parsing"],"updatePoint":{"line":98,"column":71},"line":98,"code":"  it('should parse multiple and chunked messages with unicode correctly', () => {\n    socket['handleData']('41#\"Diese Zeile enthält ');\n    socket['handleData']('das Unicode-Zeichen\"4#true');\n    expect(messages[0]).to.deep.equal(\n      'Diese Zeile enthält das Unicode-Zeichen',\n    );\n    expect(messages[1]).to.deep.equal(true);\n    expect(socket['buffer']).to.deep.equal('');\n  });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should fail to parse invalid JSON","suites":["JsonSocket message parsing","Error handling","JSON Error"],"updatePoint":{"line":114,"column":43},"line":114,"code":"      it('should fail to parse invalid JSON', () => {\n        try {\n          socket['handleData']('4#\"Hel');\n        } catch (err) {\n          expect(err.message).to.deep.equal(errorMsg);\n        }\n        expect(messages.length).to.deep.equal(0);\n        expect(socket['buffer']).to.deep.equal('');\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should emit  event on socket","suites":["JsonSocket message parsing","Error handling","JSON Error"],"updatePoint":{"line":124,"column":52},"line":124,"code":"      it(`should emit ${ERROR_EVENT} event on socket`, () => {\n        const socketEmitSpy: sinon.SinonSpy<any, any> = sinon.spy(\n          socket['socket'],\n          'emit',\n        );\n\n        socket['onData'](packet);\n\n        expect(socketEmitSpy.calledOnceWithExactly(ERROR_EVENT, errorMsg)).to.be\n          .true;\n        socketEmitSpy.restore();\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send a FIN packet","suites":["JsonSocket message parsing","Error handling","JSON Error"],"updatePoint":{"line":137,"column":34},"line":137,"code":"      it(`should send a FIN packet`, () => {\n        const socketEndSpy = sinon.spy(socket['socket'], 'end');\n\n        socket['onData'](packet);\n\n        expect(socketEndSpy.calledOnce).to.be.true;\n        socketEndSpy.restore();\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not accept invalid content length","suites":["JsonSocket message parsing","Error handling","Corrupted length value"],"updatePoint":{"line":152,"column":50},"line":152,"code":"      it('should not accept invalid content length', () => {\n        try {\n          socket['handleData'](packetString);\n        } catch (err) {\n          expect(err.message).to.deep.equal(errorMsg);\n        }\n        expect(messages.length).to.deep.equal(0);\n        expect(socket['buffer']).to.deep.equal('');\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should emit  event on socket","suites":["JsonSocket message parsing","Error handling","Corrupted length value"],"updatePoint":{"line":162,"column":52},"line":162,"code":"      it(`should emit ${ERROR_EVENT} event on socket`, () => {\n        const socketEmitSpy: sinon.SinonSpy<any, any> = sinon.spy(\n          socket['socket'],\n          'emit',\n        );\n\n        socket['onData'](packet);\n\n        expect(socketEmitSpy.calledOnceWithExactly(ERROR_EVENT, errorMsg)).to.be\n          .true;\n        socketEmitSpy.restore();\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send a FIN packet","suites":["JsonSocket message parsing","Error handling","Corrupted length value"],"updatePoint":{"line":175,"column":34},"line":175,"code":"      it(`should send a FIN packet`, () => {\n        const socketEndSpy = sinon.spy(socket['socket'], 'end');\n\n        socket['onData'](packet);\n\n        expect(socketEndSpy.calledOnce).to.be.true;\n        socketEndSpy.restore();\n      });","file":"json-socket/message-parsing.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server for each pattern handler","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":92,"column":74},"line":92,"code":"    it(`should call \"addHandler\" method of server for each pattern handler`, () => {\n      explorer.expects('explore').returns(handlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), server, '');\n      expect(addSpy.calledTwice).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server for each pattern handler with same transport","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":97,"column":94},"line":97,"code":"    it(`should call \"addHandler\" method of server for each pattern handler with same transport`, () => {\n      const serverHandlers = [\n        {\n          patterns: [{ cmd: 'test' }],\n          targetCallback: 'tt',\n          transport: Transport.TCP,\n        },\n        { pattern: 'test2', targetCallback: '2', transport: Transport.KAFKA },\n      ];\n      explorer.expects('explore').returns(serverHandlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');\n      expect(addSpyTCP.calledOnce).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server without transportID for each pattern handler with any transport value","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":110,"column":119},"line":110,"code":"    it(`should call \"addHandler\" method of server without transportID for each pattern handler with any transport value`, () => {\n      const serverHandlers = [\n        { patterns: [{ cmd: 'test' }], targetCallback: 'tt' },\n        {\n          patterns: ['test2'],\n          targetCallback: '2',\n          transport: Transport.KAFKA,\n        },\n      ];\n      explorer.expects('explore').returns(serverHandlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), server, '');\n      expect(addSpy.calledTwice).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server with transportID for each pattern handler with self transport and without transport","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":123,"column":133},"line":123,"code":"    it(`should call \"addHandler\" method of server with transportID for each pattern handler with self transport and without transport`, () => {\n      const serverHandlers = [\n        { patterns: ['test'], targetCallback: 'tt' },\n        {\n          patterns: ['test2'],\n          targetCallback: '2',\n          transport: Transport.KAFKA,\n        },\n        {\n          patterns: [{ cmd: 'test3' }],\n          targetCallback: '3',\n          transport: Transport.TCP,\n        },\n      ];\n      explorer.expects('explore').returns(serverHandlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');\n      expect(addSpyTCP.calledTwice).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server with transportID for each pattern handler without transport","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":141,"column":109},"line":141,"code":"    it(`should call \"addHandler\" method of server with transportID for each pattern handler without transport`, () => {\n      explorer.expects('explore').returns(handlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');\n      expect(addSpyTCP.calledTwice).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server with custom transportID for pattern handler with the same custom token","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":146,"column":120},"line":146,"code":"    it(`should call \"addHandler\" method of server with custom transportID for pattern handler with the same custom token`, () => {\n      const serverHandlers = [\n        {\n          patterns: [{ cmd: 'test' }],\n          targetCallback: 'tt',\n          transport: customTransport,\n        },\n        {\n          patterns: ['test2'],\n          targetCallback: '2',\n          transport: Transport.KAFKA,\n        },\n      ];\n\n      explorer.expects('explore').returns(serverHandlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), serverCustom, '');\n      expect(addSpyCustom.calledOnce).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" method of server with extras data","suites":["ListenersController","registerPatternHandlers"],"updatePoint":{"line":164,"column":66},"line":164,"code":"    it(`should call \"addHandler\" method of server with extras data`, () => {\n      const serverHandlers = [\n        {\n          patterns: ['test'],\n          targetCallback: 'tt',\n          extras: { param: 'value' },\n        },\n      ];\n      explorer.expects('explore').returns(serverHandlers);\n      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');\n      expect(addSpyTCP.calledOnce).to.be.true;\n      expect(\n        addSpyTCP.calledWith(\n          sinon.match.any,\n          sinon.match.any,\n          sinon.match.any,\n          sinon.match({ param: 'value' }),\n        ),\n      ).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addHandler\" with deferred proxy","suites":["ListenersController","registerPatternHandlers","when request scoped"],"updatePoint":{"line":185,"column":54},"line":185,"code":"      it(`should call \"addHandler\" with deferred proxy`, () => {\n        explorer.expects('explore').returns(handlers);\n        instance.registerPatternHandlers(\n          new InstanceWrapper({ scope: Scope.REQUEST }),\n          server,\n          '',\n        );\n        expect(addSpy.calledTwice).to.be.true;\n      });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should pass all arguments to the proxy chain","suites":["ListenersController","createRequestScopedHandler","when \"loadPerContext\" resolves"],"updatePoint":{"line":223,"column":54},"line":223,"code":"      it('should pass all arguments to the proxy chain', async () => {\n        sinon\n          .stub(injector, 'loadPerContext')\n          .callsFake(() => Promise.resolve({}));\n        const handler = instance.createRequestScopedHandler(\n          wrapper,\n          patterns,\n          module,\n          moduleKey,\n          methodKey,\n        );\n        await handler('data', 'metadata');\n\n        expect(proxySpy.called).to.be.true;\n        expect(proxySpy.getCall(0).args[0]).to.be.eql('data');\n        expect(proxySpy.getCall(0).args[1]).to.be.eql('metadata');\n      });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should delegate error to exception filters","suites":["ListenersController","createRequestScopedHandler","when \"loadPerContext\" throws"],"updatePoint":{"line":251,"column":52},"line":251,"code":"      it('should delegate error to exception filters', async () => {\n        sinon.stub(injector, 'loadPerContext').callsFake(() => {\n          throw new Error();\n        });\n        const handler = instance.createRequestScopedHandler(\n          wrapper,\n          patterns,\n          module,\n          moduleKey,\n          methodKey,\n        );\n        await handler([]);\n\n        expect(handleSpy.called).to.be.true;\n        expect(handleSpy.getCall(0).args[0]).to.be.instanceOf(Error);\n        expect(handleSpy.getCall(0).args[1]).to.be.instanceOf(\n          ExecutionContextHost,\n        );\n      });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should inspect & insert corresponding entrypoint definitions","suites":["ListenersController","insertEntrypointDefinition"],"updatePoint":{"line":274,"column":68},"line":274,"code":"    it('should inspect & insert corresponding entrypoint definitions', () => {\n      class TestCtrl {}\n      const instanceWrapper = new InstanceWrapper({\n        metatype: TestCtrl,\n        name: TestCtrl.name,\n      });\n      const definition: EventOrMessageListenerDefinition = {\n        patterns: ['findOne'],\n        methodKey: 'find',\n        isEventHandler: false,\n        targetCallback: null,\n        extras: { qos: 2 },\n      };\n      const transportId = Transport.MQTT;\n\n      const insertEntrypointDefinitionSpy = sinon.spy(\n        graphInspector,\n        'insertEntrypointDefinition',\n      );\n      instance.insertEntrypointDefinition(\n        instanceWrapper,\n        definition,\n        transportId,\n      );\n      expect(\n        insertEntrypointDefinitionSpy.calledWith({\n          type: 'microservice',\n          methodName: definition.methodKey,\n          className: 'TestCtrl',\n          classNodeId: instanceWrapper.id,\n          metadata: {\n            key: definition.patterns.toString(),\n            transportId: 'MQTT',\n            patterns: definition.patterns,\n            isEventHandler: definition.isEventHandler,\n            extras: definition.extras,\n          } as any,\n        }),\n      ).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should assign client to instance","suites":["ListenersController","assignClientToInstance"],"updatePoint":{"line":317,"column":40},"line":317,"code":"    it('should assign client to instance', () => {\n      const propertyKey = 'key';\n      const object = {};\n      const client = { test: true };\n      instance.assignClientToInstance(object, propertyKey, client);\n\n      expect(object[propertyKey]).to.be.eql(client);\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind all clients to properties","suites":["ListenersController","assignClientsToProperties"],"updatePoint":{"line":330,"column":45},"line":330,"code":"    it('should bind all clients to properties', () => {\n      const controller = new TestClass();\n      const metadata = [\n        {\n          property: 'key',\n          metadata: {},\n        },\n      ];\n      sinon\n        .stub((instance as any).metadataExplorer, 'scanForClientHooks')\n        .callsFake(() => metadata);\n\n      const assignClientToInstanceSpy = sinon.spy(\n        instance,\n        'assignClientToInstance',\n      );\n      instance.assignClientsToProperties(controller);\n\n      expect(assignClientToInstanceSpy.calledOnce).to.be.true;\n    });","file":"listeners-controller.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"scanFromPrototype\" with expected arguments","suites":["ListenerMetadataExplorer","explore"],"updatePoint":{"line":59,"column":63},"line":59,"code":"    it(`should call \"scanFromPrototype\" with expected arguments`, () => {\n      const obj = new Test();\n      instance.explore(obj);\n\n      const { args } = getAllMethodNames.getCall(0);\n      expect(args[0]).to.be.eql(Object.getPrototypeOf(obj));\n    });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined when \"handlerType\" metadata is undefined","suites":["ListenerMetadataExplorer","exploreMethodMetadata"],"updatePoint":{"line":72,"column":72},"line":72,"code":"    it(`should return undefined when \"handlerType\" metadata is undefined`, () => {\n      const metadata = instance.exploreMethodMetadata(\n        Object.getPrototypeOf(test),\n        'noPattern',\n      );\n      expect(metadata).to.eq(undefined);\n    });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return pattern properties when \"handlerType\" metadata is not undefined","suites":["ListenerMetadataExplorer","exploreMethodMetadata","@MessagePattern"],"updatePoint":{"line":81,"column":87},"line":81,"code":"      it(`should return pattern properties when \"handlerType\" metadata is not undefined`, () => {\n        const metadata = instance.exploreMethodMetadata(\n          Object.getPrototypeOf(test),\n          'testMessage',\n        );\n        expect(metadata).to.have.keys([\n          'isEventHandler',\n          'methodKey',\n          'targetCallback',\n          'patterns',\n          'transport',\n          'extras',\n        ]);\n        expect(metadata.patterns.length).to.eql(1);\n        expect(metadata.patterns[0]).to.eql(msgPattern);\n      });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return multiple patterns when more than one is declared","suites":["ListenerMetadataExplorer","exploreMethodMetadata","@MessagePattern"],"updatePoint":{"line":97,"column":72},"line":97,"code":"      it(`should return multiple patterns when more than one is declared`, () => {\n        const metadata = instance.exploreMethodMetadata(\n          Object.getPrototypeOf(test),\n          'testMultipleMessage',\n        );\n        expect(metadata).to.have.keys([\n          'isEventHandler',\n          'methodKey',\n          'targetCallback',\n          'patterns',\n          'transport',\n          'extras',\n        ]);\n        expect(metadata.patterns.length).to.eql(2);\n        expect(metadata.patterns[0]).to.eql(firstMultipleMsgPattern);\n        expect(metadata.patterns[1]).to.eql(secondMultipleMsgPattern);\n      });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return pattern properties when \"handlerType\" metadata is not undefined","suites":["ListenerMetadataExplorer","exploreMethodMetadata","@EventPattern"],"updatePoint":{"line":117,"column":87},"line":117,"code":"      it(`should return pattern properties when \"handlerType\" metadata is not undefined`, () => {\n        const metadata = instance.exploreMethodMetadata(\n          Object.getPrototypeOf(test),\n          'testEvent',\n        );\n        expect(metadata).to.have.keys([\n          'isEventHandler',\n          'methodKey',\n          'targetCallback',\n          'patterns',\n          'transport',\n          'extras',\n        ]);\n        expect(metadata.patterns.length).to.eql(1);\n        expect(metadata.patterns[0]).to.eql(evtPattern);\n      });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return multiple patterns when more than one is declared","suites":["ListenerMetadataExplorer","exploreMethodMetadata","@EventPattern"],"updatePoint":{"line":133,"column":72},"line":133,"code":"      it(`should return multiple patterns when more than one is declared`, () => {\n        const metadata = instance.exploreMethodMetadata(\n          Object.getPrototypeOf(test),\n          'testMultipleEvent',\n        );\n        expect(metadata).to.have.keys([\n          'isEventHandler',\n          'methodKey',\n          'targetCallback',\n          'patterns',\n          'transport',\n          'extras',\n        ]);\n        expect(metadata.patterns.length).to.eql(2);\n        expect(metadata.patterns[0]).to.eql(firstMultipleEvtPattern);\n        expect(metadata.patterns[1]).to.eql(secondMultipleEvtPattern);\n      });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return properties with @Client decorator","suites":["ListenerMetadataExplorer","scanForClientHooks"],"updatePoint":{"line":153,"column":55},"line":153,"code":"    it(`should return properties with @Client decorator`, () => {\n      const obj = new Test();\n      const hooks = [...instance.scanForClientHooks(obj)];\n\n      expect(hooks).to.have.length(2);\n      expect(hooks[0]).to.deep.eq({\n        property: 'client',\n        metadata: clientMetadata,\n      });\n      expect(hooks[1]).to.deep.eq({\n        property: 'redisClient',\n        metadata: clientSecMetadata,\n      });\n    });","file":"listeners-metadata-explorer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an expected module ref","suites":["ClientsModule","register"],"updatePoint":{"line":20,"column":44},"line":20,"code":"    it('should return an expected module ref', () => {\n      expect(dynamicModule.module).to.be.eql(ClientsModule);\n    });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an expected providers array","suites":["ClientsModule","register"],"updatePoint":{"line":23,"column":49},"line":23,"code":"    it('should return an expected providers array', () => {\n      expect(dynamicModule.providers).to.be.deep.eq([\n        {\n          provide: 'test',\n          useValue: ClientsModule['assignOnAppShutdownHook'](\n            ClientProxyFactory.create({}),\n          ),\n        },\n      ]);\n    });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an expected module ref","suites":["ClientsModule","registerAsync"],"updatePoint":{"line":43,"column":44},"line":43,"code":"    it('should return an expected module ref', () => {\n      dynamicModule = ClientsModule.registerAsync([registerOption]);\n      expect(dynamicModule.module).to.be.eql(ClientsModule);\n    });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an expected providers array with useFactory","suites":["ClientsModule","registerAsync","when useFactory"],"updatePoint":{"line":49,"column":67},"line":49,"code":"      it('should return an expected providers array with useFactory', () => {\n        dynamicModule = ClientsModule.registerAsync([registerOption]);\n        expect(dynamicModule.imports).to.be.deep.eq([]);\n        expect(dynamicModule.exports).to.be.eq(dynamicModule.providers);\n        expect(dynamicModule.providers).to.be.have.length(1);\n\n        const provider = dynamicModule.providers[0] as FactoryProvider;\n        expect(provider.provide).to.be.eql('test');\n        expect(provider.inject).to.be.deep.eq([]);\n        expect(provider.useFactory).to.be.an.instanceOf(Function);\n      });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return an expected providers array with useClass","suites":["ClientsModule","registerAsync","when useClass"],"updatePoint":{"line":63,"column":65},"line":63,"code":"      it('should return an expected providers array with useClass', () => {\n        @Injectable()\n        class ClientOptionService implements ClientsModuleOptionsFactory {\n          createClientOptions(): Promise<ClientOptions> | ClientOptions {\n            return {\n              transport: Transport.TCP,\n              options: {},\n            };\n          }\n        }\n        const useClassOption = {\n          name: 'classTest',\n          useClass: ClientOptionService,\n        };\n        dynamicModule = ClientsModule.registerAsync([useClassOption]);\n        expect(dynamicModule.imports).to.be.deep.eq([]);\n        expect(dynamicModule.providers).to.be.have.length(2);\n\n        const classTestProvider = dynamicModule.providers[0] as FactoryProvider;\n        expect(classTestProvider.provide).to.be.eql('classTest');\n        expect(classTestProvider.inject).to.be.deep.eq([ClientOptionService]);\n        expect(classTestProvider.useFactory).to.be.an.instanceOf(Function);\n      });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"provider should call \"createClientOptions\"","suites":["ClientsModule","registerAsync","when useClass"],"updatePoint":{"line":86,"column":52},"line":86,"code":"      it('provider should call \"createClientOptions\"', async () => {\n        const asyncOptions = {\n          useClass: Object,\n        };\n        const dynamicModule = ClientsModule.registerAsync([\n          asyncOptions as any,\n        ]);\n        const optionsFactory = {\n          createClientOptions: sinon.spy(),\n        };\n        try {\n          await ((dynamicModule.providers[0] as any).useFactory as any)(\n            optionsFactory,\n          );\n        } catch (e) {\n          console.log(e);\n        }\n        expect(optionsFactory.createClientOptions.called).to.be.true;\n      });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should provide an options","suites":["ClientsModule","registerAsync","when useExisting"],"updatePoint":{"line":108,"column":35},"line":108,"code":"      it('should provide an options', () => {\n        const asyncOptions = {\n          useExisting: Object,\n        };\n        dynamicModule = ClientsModule.registerAsync([asyncOptions as any]);\n        expect(dynamicModule.providers).to.have.length(1);\n        expect(dynamicModule.imports).to.be.deep.eq([]);\n        const classTestProvider = dynamicModule.providers[0] as FactoryProvider;\n        expect(classTestProvider.useFactory).to.be.an.instanceOf(Function);\n      });","file":"module/clients.module.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the value unchanged","suites":["IdentitySerializer","serialize"],"updatePoint":{"line":10,"column":41},"line":10,"code":"    it('should return the value unchanged', () => {\n      const value = {};\n      expect(instance.serialize(value)).to.be.eql(value);\n    });","file":"serializers/identity.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"undefined","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":11,"column":17},"line":11,"code":"    it('undefined', async () => {\n      expect(await instance.serialize(undefined)).to.deep.eq({\n        headers: {},\n        value: null,\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"null","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":18,"column":12},"line":18,"code":"    it('null', async () => {\n      expect(await instance.serialize(null)).to.deep.eq({\n        headers: {},\n        value: null,\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"string","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":25,"column":14},"line":25,"code":"    it('string', async () => {\n      expect(await instance.serialize('string')).to.deep.eq({\n        headers: {},\n        value: 'string',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"number","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":32,"column":14},"line":32,"code":"    it('number', async () => {\n      expect(await instance.serialize(12345)).to.deep.eq({\n        headers: {},\n        value: '12345',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":39,"column":14},"line":39,"code":"    it('buffer', async () => {\n      expect(await instance.serialize(Buffer.from('buffer'))).to.deep.eq({\n        headers: {},\n        value: Buffer.from('buffer'),\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"array","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":46,"column":13},"line":46,"code":"    it('array', async () => {\n      expect(await instance.serialize([1, 2, 3, 4, 5])).to.deep.eq({\n        headers: {},\n        value: '[1,2,3,4,5]',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"object","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":53,"column":14},"line":53,"code":"    it('object', async () => {\n      expect(\n        await instance.serialize({\n          prop: 'value',\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: '{\"prop\":\"value\"}',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"complex object with .toString()","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":64,"column":39},"line":64,"code":"    it('complex object with .toString()', async () => {\n      class Complex {\n        private readonly name = 'complex';\n        public toString(): string {\n          return this.name;\n        }\n      }\n\n      expect(await instance.serialize(new Complex())).to.deep.eq({\n        headers: {},\n        value: 'complex',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"complex object without .toString()","suites":["KafkaRequestSerializer","serialize"],"updatePoint":{"line":78,"column":42},"line":78,"code":"    it('complex object without .toString()', async () => {\n      class ComplexWithOutToString {\n        private readonly name = 'complex';\n      }\n\n      expect(await instance.serialize(new ComplexWithOutToString())).to.deep.eq(\n        {\n          headers: {},\n          value: '[object Object]',\n        },\n      );\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"kafka message without key","suites":["KafkaRequestSerializer","serialize kafka message"],"updatePoint":{"line":93,"column":33},"line":93,"code":"    it('kafka message without key', async () => {\n      expect(\n        await instance.serialize({\n          value: 'string',\n        }),\n      ).to.deep.eq({\n        headers: {},\n        value: 'string',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"kafka message with key","suites":["KafkaRequestSerializer","serialize kafka message"],"updatePoint":{"line":104,"column":30},"line":104,"code":"    it('kafka message with key', async () => {\n      expect(\n        await instance.serialize({\n          key: '1',\n          value: 'string',\n        }),\n      ).to.deep.eq({\n        headers: {},\n        key: '1',\n        value: 'string',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"kafka message with headers","suites":["KafkaRequestSerializer","serialize kafka message"],"updatePoint":{"line":117,"column":34},"line":117,"code":"    it('kafka message with headers', async () => {\n      expect(\n        await instance.serialize({\n          key: '1',\n          value: 'string',\n          headers: {\n            [KafkaHeaders.CORRELATION_ID]: '1234',\n          },\n        }),\n      ).to.deep.eq({\n        headers: {\n          [KafkaHeaders.CORRELATION_ID]: '1234',\n        },\n        key: '1',\n        value: 'string',\n      });\n    });","file":"serializers/kafka-request.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse mqtt record instance","suites":["MqttRecordSerializer","serialize"],"updatePoint":{"line":11,"column":41},"line":11,"code":"    it('should parse mqtt record instance', () => {\n      const mqttMessage = new MqttRecordBuilder()\n        .setData({ value: 'string' })\n        .setQoS(1)\n        .setDup(true)\n        .setRetain(true)\n        .setProperties({})\n        .build();\n\n      expect(\n        instance.serialize({\n          data: mqttMessage,\n        }),\n      ).to.deep.eq({\n        options: { qos: 1, retain: true, dup: true, properties: {} },\n        data: { value: 'string' },\n      });\n    });","file":"serializers/mqtt-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should act as an identity function if msg is not an instance of MqttRecord class","suites":["MqttRecordSerializer","serialize"],"updatePoint":{"line":29,"column":88},"line":29,"code":"    it('should act as an identity function if msg is not an instance of MqttRecord class', () => {\n      const packet = {\n        data: { random: true },\n      };\n      expect(instance.serialize(packet)).to.eq(packet);\n    });","file":"serializers/mqtt-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"undefined","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":14,"column":17},"line":14,"code":"    it('undefined', () => {\n      expect(instance.serialize({ data: undefined })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: undefined }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"null","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":21,"column":12},"line":21,"code":"    it('null', () => {\n      expect(instance.serialize({ data: null })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: null }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"string","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":28,"column":14},"line":28,"code":"    it('string', () => {\n      expect(instance.serialize({ data: 'string' })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: 'string' }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"number","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":35,"column":14},"line":35,"code":"    it('number', () => {\n      expect(instance.serialize({ data: 12345 })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: 12345 }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"buffer","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":42,"column":14},"line":42,"code":"    it('buffer', () => {\n      expect(instance.serialize({ data: Buffer.from('buffer') })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: Buffer.from('buffer') }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"array","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":49,"column":13},"line":49,"code":"    it('array', () => {\n      expect(instance.serialize({ data: [1, 2, 3, 4, 5] })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: [1, 2, 3, 4, 5] }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"object","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":56,"column":14},"line":56,"code":"    it('object', () => {\n      const serObject = { prop: 'value' };\n      expect(instance.serialize({ data: serObject })).to.deep.eq({\n        headers: undefined,\n        data: jsonCodec.encode({ data: serObject }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"nats message with data and nats headers","suites":["NatsRecordSerializer","serialize"],"updatePoint":{"line":64,"column":47},"line":64,"code":"    it('nats message with data and nats headers', () => {\n      const natsHeaders = nats.headers();\n      natsHeaders.set('1', 'header_1');\n      const natsMessage = new NatsRecordBuilder()\n        .setHeaders(natsHeaders)\n        .setData({ value: 'string' })\n        .build();\n      expect(\n        instance.serialize({\n          data: natsMessage,\n        }),\n      ).to.deep.eq({\n        headers: natsHeaders,\n        data: jsonCodec.encode({\n          data: {\n            value: 'string',\n          },\n        }),\n      });\n    });","file":"serializers/nats-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse rmq record instance","suites":["RmqRecordSerializer","serialize"],"updatePoint":{"line":11,"column":40},"line":11,"code":"    it('should parse rmq record instance', () => {\n      const rmqMessage = new RmqRecordBuilder()\n        .setData({ value: 'string' })\n        .setOptions({ appId: 'app', persistent: true })\n        .build();\n\n      expect(\n        instance.serialize({\n          data: rmqMessage,\n        }),\n      ).to.deep.eq({\n        options: { appId: 'app', persistent: true },\n        data: { value: 'string' },\n      });\n    });","file":"serializers/rmq-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should act as an identity function if msg is not an instance of RmqRecord class","suites":["RmqRecordSerializer","serialize"],"updatePoint":{"line":27,"column":87},"line":27,"code":"    it('should act as an identity function if msg is not an instance of RmqRecord class', () => {\n      const packet = {\n        data: { random: true },\n      };\n      expect(instance.serialize(packet)).to.eq(packet);\n    });","file":"serializers/rmq-record.serializer.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return tcp server by default","suites":["ServerFactory","create"],"updatePoint":{"line":14,"column":43},"line":14,"code":"    it(`should return tcp server by default`, () => {\n      expect(ServerFactory.create({}) instanceof ServerTCP).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return redis server","suites":["ServerFactory","create"],"updatePoint":{"line":18,"column":34},"line":18,"code":"    it(`should return redis server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.REDIS }) instanceof\n          ServerRedis,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return redis server","suites":["ServerFactory","create"],"updatePoint":{"line":25,"column":34},"line":25,"code":"    it(`should return redis server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.REDIS }) instanceof\n          ServerRedis,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return mqtt server","suites":["ServerFactory","create"],"updatePoint":{"line":32,"column":33},"line":32,"code":"    it(`should return mqtt server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.MQTT }) instanceof\n          ServerMqtt,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return nats server","suites":["ServerFactory","create"],"updatePoint":{"line":39,"column":33},"line":39,"code":"    it(`should return nats server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.NATS }) instanceof\n          ServerNats,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return rmq server","suites":["ServerFactory","create"],"updatePoint":{"line":46,"column":32},"line":46,"code":"    it(`should return rmq server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.RMQ }) instanceof ServerRMQ,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return kafka server","suites":["ServerFactory","create"],"updatePoint":{"line":52,"column":34},"line":52,"code":"    it(`should return kafka server`, () => {\n      expect(\n        ServerFactory.create({ transport: Transport.KAFKA }) instanceof\n          ServerKafka,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return grpc server","suites":["ServerFactory","create"],"updatePoint":{"line":59,"column":33},"line":59,"code":"    it(`should return grpc server`, () => {\n      expect(\n        ServerFactory.create({\n          transport: Transport.GRPC,\n          options: { protoPath: '', package: '' },\n        }) instanceof ServerGrpc,\n      ).to.be.true;\n    });","file":"server/server-factory.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"bindEvents\"","suites":["ServerGrpc","listen"],"updatePoint":{"line":47,"column":32},"line":47,"code":"    it('should call \"bindEvents\"', async () => {\n      await server.listen(callback);\n      await server.close();\n      expect(bindEventsStub.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"client.start\"","suites":["ServerGrpc","listen"],"updatePoint":{"line":52,"column":34},"line":52,"code":"    it('should call \"client.start\"', async () => {\n      const client = { start: sinon.spy() };\n      sinon.stub(server, 'createClient').callsFake(async () => client);\n\n      await server.listen(callback);\n      expect(client.start.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ServerGrpc","listen"],"updatePoint":{"line":59,"column":28},"line":59,"code":"    it('should call callback', async () => {\n      await server.listen(callback);\n      await server.close();\n      expect(callback.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerGrpc","listen","when \"start\" throws an exception"],"updatePoint":{"line":65,"column":65},"line":65,"code":"      it('should call callback with a thrown error as an argument', async () => {\n        const error = new Error('random error');\n\n        const callbackSpy = sinon.spy();\n        sinon.stub(server, 'createClient').callsFake(async () => null);\n\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        await server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"bindEvents\"","suites":["ServerGrpc","listen (multiple proto)"],"updatePoint":{"line":91,"column":32},"line":91,"code":"    it('should call \"bindEvents\"', async () => {\n      await serverMulti.listen(callback);\n      await serverMulti.close();\n      expect(bindEventsStub.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"client.start\"","suites":["ServerGrpc","listen (multiple proto)"],"updatePoint":{"line":96,"column":34},"line":96,"code":"    it('should call \"client.start\"', async () => {\n      const client = { start: sinon.spy() };\n      sinon.stub(serverMulti, 'createClient').callsFake(async () => client);\n      await serverMulti.listen(callback);\n      expect(client.start.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ServerGrpc","listen (multiple proto)"],"updatePoint":{"line":102,"column":28},"line":102,"code":"    it('should call callback', async () => {\n      await serverMulti.listen(callback);\n      await serverMulti.close();\n      expect(callback.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw \"InvalidGrpcPackageException\"","suites":["ServerGrpc","bindEvents","when package does not exist"],"updatePoint":{"line":114,"column":52},"line":114,"code":"      it('should throw \"InvalidGrpcPackageException\"', async () => {\n        sinon.stub(server, 'lookupPackage').callsFake(() => null);\n        (server as any).logger = new NoopLogger();\n        try {\n          await server.bindEvents();\n        } catch (err) {\n          expect(err).to.be.instanceOf(InvalidGrpcPackageException);\n        }\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addService\"","suites":["ServerGrpc","bindEvents","when package exist"],"updatePoint":{"line":125,"column":34},"line":125,"code":"      it('should call \"addService\"', async () => {\n        const serviceNames = [\n          {\n            name: 'test',\n            service: true,\n          },\n          {\n            name: 'test2',\n            service: true,\n          },\n        ];\n        sinon.stub(server, 'lookupPackage').callsFake(() => ({\n          test: { service: true },\n          test2: { service: true },\n        }));\n        sinon.stub(server, 'getServiceNames').callsFake(() => serviceNames);\n        (server as any).grpcClient = { addService: sinon.spy() };\n\n        await server.bindEvents();\n        expect((server as any).grpcClient.addService.calledTwice).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should throw \"InvalidGrpcPackageException\"","suites":["ServerGrpc","bindEvents (multiple proto)","when package does not exist"],"updatePoint":{"line":154,"column":52},"line":154,"code":"      it('should throw \"InvalidGrpcPackageException\"', async () => {\n        sinon.stub(serverMulti, 'lookupPackage').callsFake(() => null);\n        (serverMulti as any).logger = new NoopLogger();\n        try {\n          await serverMulti.bindEvents();\n        } catch (err) {\n          expect(err).to.be.instanceOf(InvalidGrpcPackageException);\n        }\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"addService\"","suites":["ServerGrpc","bindEvents (multiple proto)","when package exist"],"updatePoint":{"line":165,"column":34},"line":165,"code":"      it('should call \"addService\"', async () => {\n        const serviceNames = [\n          {\n            name: 'test',\n            service: true,\n          },\n        ];\n        sinon.stub(serverMulti, 'lookupPackage').callsFake(() => ({\n          test: { service: true },\n        }));\n        sinon\n          .stub(serverMulti, 'getServiceNames')\n          .callsFake(() => serviceNames);\n\n        (serverMulti as any).grpcClient = { addService: sinon.spy() };\n\n        await serverMulti.bindEvents();\n        expect((serverMulti as any).grpcClient.addService.calledTwice).to.be\n          .true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return filtered object keys","suites":["ServerGrpc","getServiceNames"],"updatePoint":{"line":189,"column":42},"line":189,"code":"    it('should return filtered object keys', () => {\n      const obj = {\n        key: { service: true },\n        key2: { service: true },\n        key3: { service: false },\n      };\n      const expected = [\n        {\n          name: 'key',\n          service: { service: true },\n        },\n        {\n          name: 'key2',\n          service: { service: true },\n        },\n      ];\n      expect(server.getServiceNames(obj)).to.be.eql(expected);\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createServiceMethod\"","suites":["ServerGrpc","createService"],"updatePoint":{"line":213,"column":41},"line":213,"code":"    it('should call \"createServiceMethod\"', async () => {\n      const handlers = objectToMap({\n        test: null,\n        test2: () => ({}),\n      });\n      sinon\n        .stub(server, 'createPattern')\n        .onFirstCall()\n        .returns('test')\n        .onSecondCall()\n        .returns('test2');\n\n      const spy = sinon\n        .stub(server, 'createServiceMethod')\n        .callsFake(() => ({} as any));\n      (server as any).messageHandlers = handlers;\n      await server.createService(\n        {\n          prototype: { test: true, test2: true },\n        },\n        'name',\n      );\n      expect(spy.calledOnce).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createPattern\" with proper arguments","suites":["ServerGrpc","createService","when RX streaming"],"updatePoint":{"line":238,"column":59},"line":238,"code":"      it('should call \"createPattern\" with proper arguments', async () => {\n        const handlers = objectToMap({\n          test2: {\n            requestStream: true,\n          },\n        });\n        const createPatternStub = sinon\n          .stub(server, 'createPattern')\n          .onFirstCall()\n          .returns('test2');\n\n        sinon.stub(server, 'createServiceMethod').callsFake(() => ({} as any));\n        (server as any).messageHandlers = handlers;\n        await server.createService(\n          {\n            prototype: {\n              test2: {\n                requestStream: true,\n              },\n            },\n          },\n          'name',\n        );\n        expect(\n          createPatternStub.calledWith(\n            'name',\n            'test2',\n            GrpcMethodStreamingType.RX_STREAMING,\n          ),\n        ).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createPattern\" with proper arguments","suites":["ServerGrpc","createService","when pass through streaming"],"updatePoint":{"line":271,"column":59},"line":271,"code":"      it('should call \"createPattern\" with proper arguments', async () => {\n        const handlers = objectToMap({\n          test2: {\n            requestStream: true,\n          },\n        });\n        const createPatternStub = sinon\n          .stub(server, 'createPattern')\n          .onFirstCall()\n          .returns('_invalid')\n          .onSecondCall()\n          .returns('test2');\n\n        sinon.stub(server, 'createServiceMethod').callsFake(() => ({} as any));\n        (server as any).messageHandlers = handlers;\n        await server.createService(\n          {\n            prototype: {\n              test2: {\n                requestStream: true,\n              },\n            },\n          },\n          'name',\n        );\n        expect(\n          createPatternStub.calledWith(\n            'name',\n            'test2',\n            GrpcMethodStreamingType.PT_STREAMING,\n          ),\n        ).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return pattern","suites":["ServerGrpc","createPattern"],"updatePoint":{"line":308,"column":29},"line":308,"code":"    it('should return pattern', () => {\n      const service = 'test';\n      const method = 'method';\n      expect(\n        server.createPattern(\n          service,\n          method,\n          GrpcMethodStreamingType.NO_STREAMING,\n        ),\n      ).to.be.eql(\n        JSON.stringify({\n          service,\n          rpc: method,\n          streaming: GrpcMethodStreamingType.NO_STREAMING,\n        }),\n      );\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createStreamServiceMethod\"","suites":["ServerGrpc","createServiceMethod","when method is a response stream"],"updatePoint":{"line":329,"column":49},"line":329,"code":"      it('should call \"createStreamServiceMethod\"', () => {\n        const cln = sinon.spy();\n        const spy = sinon.spy(server, 'createStreamServiceMethod');\n        server.createServiceMethod(\n          cln,\n          { responseStream: true } as any,\n          GrpcMethodStreamingType.NO_STREAMING,\n        );\n\n        expect(spy.called).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createUnaryServiceMethod\"","suites":["ServerGrpc","createServiceMethod","when method is not a response stream"],"updatePoint":{"line":342,"column":48},"line":342,"code":"      it('should call \"createUnaryServiceMethod\"', () => {\n        const cln = sinon.spy();\n        const spy = sinon.spy(server, 'createUnaryServiceMethod');\n        server.createServiceMethod(\n          cln,\n          { responseStream: false } as any,\n          GrpcMethodStreamingType.NO_STREAMING,\n        );\n\n        expect(spy.called).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createRequestStreamMethod\"","suites":["ServerGrpc","createServiceMethod","when request is a stream","when stream type is RX_STREAMING"],"updatePoint":{"line":356,"column":51},"line":356,"code":"        it('should call \"createRequestStreamMethod\"', () => {\n          const cln = sinon.spy();\n          const spy = sinon.spy(server, 'createRequestStreamMethod');\n          server.createServiceMethod(\n            cln,\n            { requestStream: true } as any,\n            GrpcMethodStreamingType.RX_STREAMING,\n          );\n\n          expect(spy.called).to.be.true;\n        });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createStreamCallMethod\"","suites":["ServerGrpc","createServiceMethod","when request is a stream","when stream type is PT_STREAMING"],"updatePoint":{"line":369,"column":48},"line":369,"code":"        it('should call \"createStreamCallMethod\"', () => {\n          const cln = sinon.spy();\n          const spy = sinon.spy(server, 'createStreamCallMethod');\n          server.createServiceMethod(\n            cln,\n            { requestStream: true } as any,\n            GrpcMethodStreamingType.PT_STREAMING,\n          );\n\n          expect(spy.called).to.be.true;\n        });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerGrpc","createStreamServiceMethod"],"updatePoint":{"line":385,"column":30},"line":385,"code":"    it('should return function', () => {\n      const fn = server.createStreamServiceMethod(sinon.spy());\n      expect(fn).to.be.a('function');\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call native method","suites":["ServerGrpc","createStreamServiceMethod","on call"],"updatePoint":{"line":390,"column":35},"line":390,"code":"      it('should call native method', async () => {\n        const call = {\n          write: sinon.spy(),\n          end: sinon.spy(),\n          addListener: sinon.spy(),\n          removeListener: sinon.spy(),\n        };\n        const callback = sinon.spy();\n        const native = sinon.spy();\n\n        await server.createStreamServiceMethod(native)(call, callback);\n        expect(native.called).to.be.true;\n        expect(call.addListener.calledWith('cancelled')).to.be.true;\n        expect(call.removeListener.calledWith('cancelled')).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close the result observable when receiving an 'cancelled' event from the client","suites":["ServerGrpc","createStreamServiceMethod","on call"],"updatePoint":{"line":406,"column":96},"line":406,"code":"      it(`should close the result observable when receiving an 'cancelled' event from the client`, async () => {\n        let cancelCb: () => void;\n        const call = {\n          write: sinon\n            .stub()\n            .onSecondCall()\n            .callsFake(() => cancelCb()),\n          end: sinon.spy(),\n          addListener: (name, cb) => (cancelCb = cb),\n          removeListener: sinon.spy(),\n        };\n        const result$ = of(1, 2, 3);\n        const callback = sinon.spy();\n        const native = sinon\n          .stub()\n          .returns(new Promise((resolve, reject) => resolve(result$)));\n\n        await server.createStreamServiceMethod(native)(call, callback);\n        expect(call.write.calledTwice).to.be.true;\n        expect(call.end.called).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return observable","suites":["ServerGrpc","createUnaryServiceMethod"],"updatePoint":{"line":431,"column":32},"line":431,"code":"    it('should return observable', () => {\n      const fn = server.createUnaryServiceMethod(sinon.spy());\n      expect(fn).to.be.a('function');\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call native & callback methods","suites":["ServerGrpc","createUnaryServiceMethod","on call"],"updatePoint":{"line":436,"column":47},"line":436,"code":"      it('should call native & callback methods', async () => {\n        const call = { write: sinon.spy(), end: sinon.spy() };\n        const callback = sinon.spy();\n        const native = sinon.spy();\n\n        await server.createUnaryServiceMethod(native)(call, callback);\n        expect(native.called).to.be.true;\n        expect(callback.called).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should await when a promise is return by the native","suites":["ServerGrpc","createUnaryServiceMethod","on call"],"updatePoint":{"line":446,"column":61},"line":446,"code":"      it('should await when a promise is return by the native', async () => {\n        const call = { write: sinon.spy(), end: sinon.spy() };\n        const callback = sinon.spy();\n\n        const original = { native: Function };\n        const mock = sinon.mock(original);\n\n        mock\n          .expects('native')\n          .once()\n          .returns(\n            (() => {\n              const sub = new ReplaySubject<any>(1);\n              sub.next(new Promise(resolve => resolve({ foo: 'bar' })));\n              return sub.asObservable();\n            })(),\n          );\n\n        await server.createUnaryServiceMethod(original.native)(call, callback);\n        mock.verify();\n        expect(callback.calledWith(null, { foo: 'bar' })).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should wrap call into Subject","suites":["ServerGrpc","createRequestStreamMethod"],"updatePoint":{"line":472,"column":37},"line":472,"code":"    it('should wrap call into Subject', () => {\n      const handler = sinon.spy();\n      const fn = server.createRequestStreamMethod(handler, false);\n      const call = {\n        on: (event, callback) => callback(),\n        off: sinon.spy(),\n        end: sinon.spy(),\n        write: sinon.spy(),\n      };\n      fn(call as any, sinon.spy());\n\n      expect(handler.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should wrap call into Subject with metadata","suites":["ServerGrpc","createRequestStreamMethod"],"updatePoint":{"line":486,"column":51},"line":486,"code":"    it('should wrap call into Subject with metadata', () => {\n      const handler = sinon.spy();\n      const fn = server.createRequestStreamMethod(handler, false);\n      const call = {\n        on: (event, callback) => callback(),\n        off: sinon.spy(),\n        end: sinon.spy(),\n        write: sinon.spy(),\n        metadata: {\n          test: '123',\n        },\n      };\n      fn(call as any, sinon.spy());\n\n      expect(handler.called).to.be.true;\n      expect(handler.args[0][1]).to.eq(call.metadata);\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ServerGrpc","createRequestStreamMethod","when response is not a stream"],"updatePoint":{"line":504,"column":30},"line":504,"code":"      it('should call callback', async () => {\n        const handler = async () => ({ test: true });\n        const fn = server.createRequestStreamMethod(handler, false);\n        const call = {\n          on: (event, callback) => {\n            if (event !== CANCEL_EVENT) {\n              callback();\n            }\n          },\n          off: sinon.spy(),\n          end: sinon.spy(),\n          write: sinon.spy(),\n        };\n\n        const responseCallback = sinon.spy();\n        await fn(call as any, responseCallback);\n\n        expect(responseCallback.called).to.be.true;\n      });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call write() and end()","suites":["ServerGrpc","createRequestStreamMethod","when response is not a stream","when response is a stream"],"updatePoint":{"line":524,"column":41},"line":524,"code":"        it('should call write() and end()', async () => {\n          const handler = async () => ({ test: true });\n          const fn = server.createRequestStreamMethod(handler, true);\n          const call = {\n            on: (event, callback) => {\n              if (event !== CANCEL_EVENT) {\n                callback();\n              }\n            },\n            off: sinon.spy(),\n            end: sinon.spy(),\n            write: sinon.spy(),\n          };\n\n          await fn(call as any, null);\n\n          expect(call.write.called).to.be.true;\n          expect(call.end.called).to.be.true;\n        });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should pass through to \"methodHandler\"","suites":["ServerGrpc","createStreamCallMethod"],"updatePoint":{"line":548,"column":46},"line":548,"code":"    it('should pass through to \"methodHandler\"', () => {\n      const handler = sinon.spy();\n      const fn = server.createStreamCallMethod(handler, false);\n      const args = [1, 2, 3];\n      fn(args as any, sinon.spy());\n\n      expect(handler.calledWith(args)).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"forceShutdown\" by default","suites":["ServerGrpc","close"],"updatePoint":{"line":559,"column":46},"line":559,"code":"    it('should call \"forceShutdown\" by default', async () => {\n      const grpcClient = {\n        forceShutdown: sinon.spy(),\n        tryShutdown: sinon.stub().yields(),\n      };\n      (server as any).grpcClient = grpcClient;\n      await server.close();\n      expect(grpcClient.forceShutdown.called).to.be.true;\n      expect(grpcClient.tryShutdown.called).to.be.false;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"forceShutdown\" when \"gracefulShutdown\" is false","suites":["ServerGrpc","close"],"updatePoint":{"line":570,"column":68},"line":570,"code":"    it('should call \"forceShutdown\" when \"gracefulShutdown\" is false', async () => {\n      const grpcClient = {\n        forceShutdown: sinon.spy(),\n        tryShutdown: sinon.stub().yields(),\n      };\n      (server as any).grpcClient = grpcClient;\n      (server as any).options.gracefulShutdown = false;\n      await server.close();\n      expect(grpcClient.forceShutdown.called).to.be.true;\n      expect(grpcClient.tryShutdown.called).to.be.false;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"tryShutdown\" when \"gracefulShutdown\" is true","suites":["ServerGrpc","close"],"updatePoint":{"line":582,"column":65},"line":582,"code":"    it('should call \"tryShutdown\" when \"gracefulShutdown\" is true', async () => {\n      const grpcClient = {\n        forceShutdown: sinon.spy(),\n        tryShutdown: sinon.stub().yields(),\n      };\n      (server as any).grpcClient = grpcClient;\n      (server as any).options.gracefulShutdown = true;\n      await server.close();\n      expect(grpcClient.forceShutdown.called).to.be.false;\n      expect(grpcClient.tryShutdown.called).to.be.true;\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return parsed json","suites":["ServerGrpc","deserialize"],"updatePoint":{"line":596,"column":33},"line":596,"code":"    it(`should return parsed json`, () => {\n      const obj = { test: 'test' };\n      expect(server.deserialize(obj)).to.deep.equal(\n        JSON.parse(JSON.stringify(obj)),\n      );\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not parse argument if it is not an object","suites":["ServerGrpc","deserialize"],"updatePoint":{"line":602,"column":56},"line":602,"code":"    it(`should not parse argument if it is not an object`, () => {\n      const content = 'test';\n      expect(server.deserialize(content)).to.equal(content);\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse multi-level proto package tree\"","suites":["ServerGrpc","proto interfaces parser should account for package namespaces"],"updatePoint":{"line":609,"column":52},"line":609,"code":"    it('should parse multi-level proto package tree\"', () => {\n      const grpcPkg = {\n        A: {\n          C: {\n            E: {\n              service: {\n                serviceName: {},\n              },\n            },\n          },\n        },\n        B: {\n          D: {\n            service: {\n              serviceName: {},\n            },\n          },\n        },\n      };\n      const svcs = server.getServiceNames(grpcPkg);\n      expect(svcs.length).to.be.equal(\n        2,\n        'Amount of services collected from namespace should be equal 2',\n      );\n      expect(svcs[0].name).to.be.equal('A.C.E');\n      expect(svcs[1].name).to.be.equal('B.D');\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should parse single level proto package tree\"","suites":["ServerGrpc","proto interfaces parser should account for package namespaces"],"updatePoint":{"line":636,"column":53},"line":636,"code":"    it('should parse single level proto package tree\"', () => {\n      const grpcPkg = {\n        A: {\n          service: {\n            serviceName: {},\n          },\n        },\n        B: {\n          service: {\n            serviceName: {},\n          },\n        },\n      };\n      const services = server.getServiceNames(grpcPkg);\n      expect(services.length).to.be.equal(\n        2,\n        'Amount of services collected from namespace should be equal 2',\n      );\n      expect(services[0].name).to.be.equal('A');\n      expect(services[1].name).to.be.equal('B');\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should add handler","suites":["ServerGrpc","addHandler"],"updatePoint":{"line":663,"column":26},"line":663,"code":"    it(`should add handler`, () => {\n      sinon.stub(server as any, 'messageHandlers').value({ set() {} });\n\n      const messageHandlersSetSpy = sinon.spy(\n        (server as any).messageHandlers,\n        'set',\n      );\n      server.addHandler(pattern, callback as any);\n\n      expect(messageHandlersSetSpy.called).to.be.true;\n      expect(messageHandlersSetSpy.getCall(0).args[0]).to.be.equal(\n        JSON.stringify(pattern),\n      );\n    });","file":"server/server-grpc.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"bindEvents\"","suites":["ServerKafka","listen"],"updatePoint":{"line":126,"column":32},"line":126,"code":"    it('should call \"bindEvents\"', async () => {\n      bindEventsStub = sinon\n        .stub(server, 'bindEvents')\n        .callsFake(() => ({} as any));\n      await server.listen(callback);\n      expect(bindEventsStub.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback","suites":["ServerKafka","listen"],"updatePoint":{"line":133,"column":28},"line":133,"code":"    it('should call callback', async () => {\n      await server.listen(callback);\n      expect(callback.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerKafka","listen","when \"start\" throws an exception"],"updatePoint":{"line":138,"column":65},"line":138,"code":"      it('should call callback with a thrown error as an argument', () => {\n        const error = new Error('random error');\n\n        const callbackSpy = sinon.spy();\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close server","suites":["ServerKafka","close"],"updatePoint":{"line":158,"column":27},"line":158,"code":"    it('should close server', async () => {\n      await server.close();\n\n      expect(consumer.disconnect.calledOnce).to.be.true;\n      expect(producer.disconnect.calledOnce).to.be.true;\n      expect((server as any).consumer).to.be.null;\n      expect((server as any).producer).to.be.null;\n      expect((server as any).client).to.be.null;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call subscribe nor run on consumer when there are no messageHandlers","suites":["ServerKafka","bindEvents"],"updatePoint":{"line":170,"column":87},"line":170,"code":"    it('should not call subscribe nor run on consumer when there are no messageHandlers', async () => {\n      (server as any).logger = new NoopLogger();\n      await server.listen(callback);\n      await server.bindEvents((server as any).consumer);\n      expect(subscribe.called).to.be.false;\n      expect(run.called).to.be.true;\n      expect(connect.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call subscribe and run on consumer when there are messageHandlers","suites":["ServerKafka","bindEvents"],"updatePoint":{"line":178,"column":80},"line":178,"code":"    it('should call subscribe and run on consumer when there are messageHandlers', async () => {\n      (server as any).logger = new NoopLogger();\n      await server.listen(callback);\n\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n\n      await server.bindEvents((server as any).consumer);\n\n      expect(subscribe.called).to.be.true;\n      expect(\n        subscribe.calledWith({\n          topics: [pattern],\n        }),\n      ).to.be.true;\n\n      expect(run.called).to.be.true;\n      expect(connect.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call subscribe with options and run on consumer when there are messageHandlers","suites":["ServerKafka","bindEvents"],"updatePoint":{"line":200,"column":93},"line":200,"code":"    it('should call subscribe with options and run on consumer when there are messageHandlers', async () => {\n      (server as any).logger = new NoopLogger();\n      (server as any).options.subscribe = {};\n      (server as any).options.subscribe.fromBeginning = true;\n      await server.listen(callback);\n\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n\n      await server.bindEvents((server as any).consumer);\n\n      expect(subscribe.called).to.be.true;\n      expect(\n        subscribe.calledWith({\n          topics: [pattern],\n          fromBeginning: true,\n        }),\n      ).to.be.true;\n\n      expect(run.called).to.be.true;\n      expect(connect.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerKafka","getMessageHandler"],"updatePoint":{"line":228,"column":30},"line":228,"code":"    it(`should return function`, () => {\n      expect(typeof server.getMessageHandler()).to.be.eql('function');\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleMessage\"","suites":["ServerKafka","getMessageHandler","handler"],"updatePoint":{"line":232,"column":37},"line":232,"code":"      it('should call \"handleMessage\"', async () => {\n        const handleMessageStub = sinon\n          .stub(server, 'handleMessage')\n          .callsFake(() => null);\n        (await server.getMessageHandler())(null);\n        expect(handleMessageStub.called).to.be.true;\n      });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerKafka","getPublisher"],"updatePoint":{"line":256,"column":30},"line":256,"code":"    it(`should return function`, () => {\n      expect(typeof server.getPublisher(null, null, correlationId)).to.be.eql(\n        'function',\n      );\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"publish\" with expected arguments","suites":["ServerKafka","getPublisher"],"updatePoint":{"line":261,"column":53},"line":261,"code":"    it(`should call \"publish\" with expected arguments`, () => {\n      const data = {\n        id: 'uuid',\n        value: 'string',\n      };\n      publisher(data);\n\n      expect(\n        sendMessageStub.calledWith(\n          data,\n          replyTopic,\n          replyPartition,\n          correlationId,\n        ),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if correlation identifier is not present","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":289,"column":74},"line":289,"code":"    it('should call \"handleEvent\" if correlation identifier is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(eventPayload);\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if correlation identifier is present but the reply topic is not present","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":295,"column":105},"line":295,"code":"    it('should call \"handleEvent\" if correlation identifier is present but the reply topic is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(eventWithCorrelationIdPayload);\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call event handler when \"handleEvent\" is called","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":301,"column":62},"line":301,"code":"    it('should call event handler when \"handleEvent\" is called', async () => {\n      const messageHandler = sinon.mock();\n      const context = { test: true } as any;\n      const messageData = 'some data';\n      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);\n\n      await server.handleEvent(\n        topic,\n        { data: messageData, pattern: topic },\n        context,\n      );\n      expect(messageHandler.calledWith(messageData, context)).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not catch error thrown by event handler as part of \"handleEvent\"","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":315,"column":79},"line":315,"code":"    it('should not catch error thrown by event handler as part of \"handleEvent\"', async () => {\n      const error = new Error('handler error');\n      const messageHandler = sinon.mock().throwsException(error);\n      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);\n\n      try {\n        await server.handleEvent(\n          topic,\n          { data: 'some data', pattern: topic },\n          {} as any,\n        );\n\n        // code should not be executed\n        expect(true).to.be.false;\n      } catch (e) {\n        if (e instanceof AssertionError) {\n          throw e;\n        }\n        expect(e).to.be.eq(error);\n      }\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if correlation identifier and reply topic are present but the handler is of type eventHandler","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":337,"column":127},"line":337,"code":"    it('should call \"handleEvent\" if correlation identifier and reply topic are present but the handler is of type eventHandler', async () => {\n      const handler = sinon.spy();\n      (handler as any).isEventHandler = true;\n      (server as any).messageHandlers = objectToMap({\n        [topic]: handler,\n      });\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(payload);\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should NOT call \"handleEvent\" if correlation identifier and reply topic are present but the handler is not of type eventHandler","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":348,"column":135},"line":348,"code":"    it('should NOT call \"handleEvent\" if correlation identifier and reply topic are present but the handler is not of type eventHandler', async () => {\n      const handler = sinon.spy();\n      (handler as any).isEventHandler = false;\n      (server as any).messageHandlers = objectToMap({\n        [topic]: handler,\n      });\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(payload);\n      expect(handleEventSpy.called).to.be.false;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":359,"column":89},"line":359,"code":"    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {\n      await server.handleMessage(payload);\n      expect(\n        getPublisherSpy.calledWith({\n          id: payload.message.headers[KafkaHeaders.CORRELATION_ID].toString(),\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerKafka","handleMessage"],"updatePoint":{"line":369,"column":51},"line":369,"code":"    it(`should call handler with expected arguments`, async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [topic]: handler,\n      });\n\n      await server.handleMessage(payload);\n      expect(handler.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send message","suites":["ServerKafka","sendMessage"],"updatePoint":{"line":390,"column":27},"line":390,"code":"    it('should send message', async () => {\n      await server.sendMessage(\n        {\n          id: correlationId,\n          response: messageValue,\n        },\n        replyTopic,\n        replyPartition,\n        correlationId,\n      );\n\n      expect(\n        sendSpy.calledWith({\n          topic: replyTopic,\n          messages: [\n            {\n              partition: parseFloat(replyPartition),\n              value: messageValue,\n              headers: {\n                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),\n              },\n            },\n          ],\n        }),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send message without reply partition","suites":["ServerKafka","sendMessage"],"updatePoint":{"line":416,"column":51},"line":416,"code":"    it('should send message without reply partition', async () => {\n      await server.sendMessage(\n        {\n          id: correlationId,\n          response: messageValue,\n        },\n        replyTopic,\n        undefined,\n        correlationId,\n      );\n\n      expect(\n        sendSpy.calledWith({\n          topic: replyTopic,\n          messages: [\n            {\n              value: messageValue,\n              headers: {\n                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),\n              },\n            },\n          ],\n        }),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send error message","suites":["ServerKafka","sendMessage"],"updatePoint":{"line":441,"column":33},"line":441,"code":"    it('should send error message', async () => {\n      await server.sendMessage(\n        {\n          id: correlationId,\n          err: NO_MESSAGE_HANDLER,\n        },\n        replyTopic,\n        replyPartition,\n        correlationId,\n      );\n\n      expect(\n        sendSpy.calledWith({\n          topic: replyTopic,\n          messages: [\n            {\n              value: null,\n              partition: parseFloat(replyPartition),\n              headers: {\n                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),\n                [KafkaHeaders.NEST_ERR]: Buffer.from(NO_MESSAGE_HANDLER),\n              },\n            },\n          ],\n        }),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send `isDisposed` message","suites":["ServerKafka","sendMessage"],"updatePoint":{"line":468,"column":40},"line":468,"code":"    it('should send `isDisposed` message', async () => {\n      await server.sendMessage(\n        {\n          id: correlationId,\n          isDisposed: true,\n        },\n        replyTopic,\n        replyPartition,\n        correlationId,\n      );\n\n      expect(\n        sendSpy.calledWith({\n          topic: replyTopic,\n          messages: [\n            {\n              value: null,\n              partition: parseFloat(replyPartition),\n              headers: {\n                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),\n                [KafkaHeaders.NEST_IS_DISPOSED]: Buffer.alloc(1),\n              },\n            },\n          ],\n        }),\n      ).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should accept a custom logCreator in client options","suites":["ServerKafka","createClient"],"updatePoint":{"line":498,"column":59},"line":498,"code":"    it('should accept a custom logCreator in client options', () => {\n      const logCreatorSpy = sinon.spy(() => 'test');\n      const logCreator = () => logCreatorSpy;\n\n      server = new ServerKafka({\n        client: {\n          brokers: [],\n          logCreator,\n        },\n      });\n\n      const logger = server.createClient().logger();\n\n      logger.info({ namespace: '', level: 1, log: 'test' });\n\n      expect(logCreatorSpy.called).to.be.true;\n    });","file":"server/server-kafka.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"error\" event to handler","suites":["ServerMqtt","listen"],"updatePoint":{"line":29,"column":44},"line":29,"code":"    it('should bind \"error\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onSpy.getCall(0).args[0]).to.be.equal('error');\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"message\" event to handler","suites":["ServerMqtt","listen"],"updatePoint":{"line":33,"column":46},"line":33,"code":"    it('should bind \"message\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onSpy.getCall(1).args[0]).to.be.equal('message');\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"connect\" event to handler","suites":["ServerMqtt","listen"],"updatePoint":{"line":37,"column":46},"line":37,"code":"    it('should bind \"connect\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onSpy.getCall(2).args[0]).to.be.equal('connect');\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerMqtt","listen","when \"start\" throws an exception"],"updatePoint":{"line":42,"column":65},"line":42,"code":"      it('should call callback with a thrown error as an argument', () => {\n        const error = new Error('random error');\n\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should end mqttClient","suites":["ServerMqtt","close"],"updatePoint":{"line":58,"column":29},"line":58,"code":"    it('should end mqttClient', () => {\n      server.close();\n      expect(mqttClient.end.called).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to each pattern","suites":["ServerMqtt","bindEvents"],"updatePoint":{"line":74,"column":40},"line":74,"code":"    it('should subscribe to each pattern', () => {\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n      server.bindEvents(mqttClient);\n      expect(subscribeSpy.calledWith(pattern)).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerMqtt","getMessageHandler"],"updatePoint":{"line":85,"column":30},"line":85,"code":"    it(`should return function`, () => {\n      expect(\n        typeof server.getMessageHandler((server as any).mqttClient),\n      ).to.be.eql('function');\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleMessage\"","suites":["ServerMqtt","getMessageHandler","handler"],"updatePoint":{"line":91,"column":37},"line":91,"code":"      it('should call \"handleMessage\"', async () => {\n        const handleMessageStub = sinon\n          .stub(server, 'handleMessage')\n          .callsFake(() => null);\n        (await server.getMessageHandler((server as any).mqttClient))(null);\n        expect(handleMessageStub.called).to.be.true;\n      });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if identifier is not present","suites":["ServerMqtt","handleMessage"],"updatePoint":{"line":111,"column":62},"line":111,"code":"    it('should call \"handleEvent\" if identifier is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(\n        channel,\n        Buffer.from(JSON.stringify({ pattern: '', data })),\n        null,\n      );\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object","suites":["ServerMqtt","handleMessage"],"updatePoint":{"line":120,"column":89},"line":120,"code":"    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {\n      await server.handleMessage(\n        channel,\n        Buffer.from(JSON.stringify({ id, pattern: '', data })),\n        null,\n      );\n      expect(\n        getPublisherSpy.calledWith({\n          id,\n          status: 'error',\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerMqtt","handleMessage"],"updatePoint":{"line":134,"column":51},"line":134,"code":"    it(`should call handler with expected arguments`, async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      await server.handleMessage(\n        channel,\n        Buffer.from(JSON.stringify({ pattern: '', data, id: '2' })),\n        null,\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerMqtt","getPublisher"],"updatePoint":{"line":162,"column":30},"line":162,"code":"    it(`should return function`, () => {\n      expect(typeof server.getPublisher(null, null, id)).to.be.eql('function');\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"publish\" with expected arguments","suites":["ServerMqtt","getPublisher"],"updatePoint":{"line":165,"column":53},"line":165,"code":"    it(`should call \"publish\" with expected arguments`, () => {\n      const respond = 'test';\n      publisher({ respond, id });\n      expect(\n        publisherSpy.calledWith(\n          `${pattern}/reply`,\n          JSON.stringify({ respond, id }),\n        ),\n      ).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should leave pattern as it is","suites":["ServerMqtt","getRequestPattern"],"updatePoint":{"line":178,"column":37},"line":178,"code":"    it(`should leave pattern as it is`, () => {\n      expect(server.getRequestPattern(test)).to.equal(test);\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should append \"/reply\" to string","suites":["ServerMqtt","getReplyPattern"],"updatePoint":{"line":184,"column":40},"line":184,"code":"    it(`should append \"/reply\" to string`, () => {\n      const expectedResult = test + '/reply';\n      expect(server.getReplyPattern(test)).to.equal(expectedResult);\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return parsed json","suites":["ServerMqtt","parseMessage"],"updatePoint":{"line":190,"column":33},"line":190,"code":"    it(`should return parsed json`, () => {\n      const obj = { test: 'test' };\n      expect(server.parseMessage(obj)).to.deep.equal(\n        JSON.parse(JSON.stringify(obj)),\n      );\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not parse argument if it is not an object","suites":["ServerMqtt","parseMessage"],"updatePoint":{"line":196,"column":56},"line":196,"code":"    it(`should not parse argument if it is not an object`, () => {\n      const content = 'test';\n      expect(server.parseMessage(content)).to.equal(content);\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerMqtt","handleEvent"],"updatePoint":{"line":205,"column":51},"line":205,"code":"    it('should call handler with expected arguments', () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      server.handleEvent(\n        channel,\n        { pattern: '', data },\n        new BaseRpcContext([]),\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return true when topic matches with provided pattern","suites":["ServerMqtt","matchMqttPattern"],"updatePoint":{"line":220,"column":67},"line":220,"code":"    it('should return true when topic matches with provided pattern', () => {\n      expect(server.matchMqttPattern('root/valid/+', 'root/valid/child')).to.be\n        .true;\n      expect(server.matchMqttPattern('root/valid/#', 'root/valid/child')).to.be\n        .true;\n      expect(\n        server.matchMqttPattern('root/valid/#', 'root/valid/child/grandchild'),\n      ).to.be.true;\n      expect(server.matchMqttPattern('root/+/child', 'root/valid/child')).to.be\n        .true;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return false when topic does not matches with provided pattern","suites":["ServerMqtt","matchMqttPattern"],"updatePoint":{"line":232,"column":77},"line":232,"code":"    it('should return false when topic does not matches with provided pattern', () => {\n      expect(server.matchMqttPattern('root/test/+', 'root/invalid/child')).to.be\n        .false;\n      expect(server.matchMqttPattern('root/test/#', 'root/invalid/child')).to.be\n        .false;\n      expect(\n        server.matchMqttPattern(\n          'root/#/grandchild',\n          'root/invalid/child/grandchild',\n        ),\n      ).to.be.false;\n      expect(\n        server.matchMqttPattern(\n          'root/+/grandchild',\n          'root/invalid/child/grandchild',\n        ),\n      ).to.be.false;\n    });","file":"server/server-mqtt.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerNats","listen","when \"start\" throws an exception"],"updatePoint":{"line":28,"column":65},"line":28,"code":"      it('should call callback with a thrown error as an argument', async () => {\n        const error = new Error('random error');\n\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        await server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close natsClient","suites":["ServerNats","close"],"updatePoint":{"line":44,"column":31},"line":44,"code":"    it('should close natsClient', () => {\n      server.close();\n      expect(natsClient.close.called).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should subscribe to each acknowledge patterns","suites":["ServerNats","bindEvents"],"updatePoint":{"line":60,"column":53},"line":60,"code":"    it('should subscribe to each acknowledge patterns', () => {\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n      server.bindEvents(natsClient);\n      expect(subscribeSpy.calledWith(pattern)).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerNats","getMessageHandler"],"updatePoint":{"line":71,"column":30},"line":71,"code":"    it(`should return function`, () => {\n      expect(typeof server.getMessageHandler(null)).to.be.eql('function');\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleMessage\"","suites":["ServerNats","getMessageHandler","handler"],"updatePoint":{"line":75,"column":37},"line":75,"code":"      it('should call \"handleMessage\"', async () => {\n        const handleMessageStub = sinon\n          .stub(server, 'handleMessage')\n          .callsFake(() => null);\n        await server.getMessageHandler('')('' as any, '');\n        expect(handleMessageStub.called).to.be.true;\n      });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if identifier is not present","suites":["ServerNats","handleMessage"],"updatePoint":{"line":94,"column":62},"line":94,"code":"    it('should call \"handleEvent\" if identifier is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      const data = JSONCodec().encode({ id: 10 });\n      const natsMsg: NatsMsg = {\n        data,\n        subject: channel,\n        sid: +id,\n        respond: sinon.spy(),\n      };\n      await server.handleMessage(channel, natsMsg);\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish NO_MESSAGE_HANDLER if pattern does not exist in messageHandlers object","suites":["ServerNats","handleMessage"],"updatePoint":{"line":106,"column":93},"line":106,"code":"    it(`should publish NO_MESSAGE_HANDLER if pattern does not exist in messageHandlers object`, async () => {\n      const data = JSONCodec().encode({\n        id,\n        pattern: 'test',\n        data: 'test',\n      });\n      const natsMsg: NatsMsg = {\n        data,\n        subject: channel,\n        sid: +id,\n        respond: sinon.spy(),\n      };\n\n      await server.handleMessage(channel, natsMsg);\n      expect(\n        getPublisherSpy.calledWith({\n          id,\n          status: 'error',\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerNats","handleMessage"],"updatePoint":{"line":128,"column":51},"line":128,"code":"    it(`should call handler with expected arguments`, async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      const headers = {};\n      const natsContext = new NatsContext([channel, headers]);\n\n      const data = JSONCodec().encode({\n        pattern: channel,\n        data: 'test',\n        id,\n      });\n      const natsMsg: NatsMsg = {\n        data,\n        subject: channel,\n        sid: +id,\n        respond: sinon.spy(),\n        headers,\n      };\n      await server.handleMessage(channel, natsMsg);\n      expect(handler.calledWith('test', natsContext)).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerNats","getPublisher"],"updatePoint":{"line":156,"column":30},"line":156,"code":"    it(`should return function`, () => {\n      const natsMsg: NatsMsg = {\n        data: new Uint8Array(),\n        subject: '',\n        sid: +id,\n        respond: sinon.spy(),\n      };\n      expect(typeof server.getPublisher(natsMsg, id)).to.be.eql('function');\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"respond\" when reply topic provided","suites":["ServerNats","getPublisher"],"updatePoint":{"line":165,"column":55},"line":165,"code":"    it(`should call \"respond\" when reply topic provided`, () => {\n      const replyTo = 'test';\n      const natsMsg = {\n        data: new Uint8Array(),\n        subject: '',\n        sid: +id,\n        respond: sinon.spy(),\n        reply: replyTo,\n      };\n      const publisher = server.getPublisher(natsMsg, id);\n\n      const respond = 'test';\n      publisher({ respond, id });\n      expect(natsMsg.respond.calledWith(JSONCodec().encode({ respond, id }))).to\n        .be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not call \"publish\" when replyTo NOT provided","suites":["ServerNats","getPublisher"],"updatePoint":{"line":181,"column":59},"line":181,"code":"    it(`should not call \"publish\" when replyTo NOT provided`, () => {\n      const replyTo = undefined;\n      const natsMsg = {\n        data: new Uint8Array(),\n        subject: '',\n        reply: replyTo,\n        sid: +id,\n        respond: sinon.spy(),\n      };\n      const publisher = server.getPublisher(natsMsg, id);\n\n      const respond = 'test';\n      publisher({ respond, id });\n      expect(natsMsg.respond.notCalled);\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerNats","handleEvent"],"updatePoint":{"line":201,"column":51},"line":201,"code":"    it('should call handler with expected arguments', () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      server.handleEvent(\n        channel,\n        { pattern: '', data },\n        new BaseRpcContext([]),\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should retrieve \"status()\" async iterator","suites":["ServerNats","handleStatusUpdates"],"updatePoint":{"line":216,"column":49},"line":216,"code":"    it('should retrieve \"status()\" async iterator', () => {\n      const serverMock = {\n        status: sinon.stub().returns({\n          [Symbol.asyncIterator]: [],\n        }),\n      };\n      server.handleStatusUpdates(serverMock as any);\n      expect(serverMock.status.called).to.be.true;\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should log \"disconnect\" and \"error\" statuses as \"errors\"","suites":["ServerNats","handleStatusUpdates"],"updatePoint":{"line":226,"column":64},"line":226,"code":"    it('should log \"disconnect\" and \"error\" statuses as \"errors\"', async () => {\n      const logErrorSpy = sinon.spy((server as any).logger, 'error');\n      const serverMock = {\n        status: sinon.stub().returns({\n          async *[Symbol.asyncIterator]() {\n            yield { type: 'disconnect', data: 'localhost' };\n            yield { type: 'error', data: {} };\n          },\n        }),\n      };\n      await server.handleStatusUpdates(serverMock as any);\n      expect(logErrorSpy.calledTwice).to.be.true;\n      expect(\n        logErrorSpy.calledWith(\n          `NatsError: type: \"disconnect\", data: \"localhost\".`,\n        ),\n      );\n      expect(\n        logErrorSpy.calledWith(`NatsError: type: \"disconnect\", data: \"{}\".`),\n      );\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should log other statuses as \"logs\"","suites":["ServerNats","handleStatusUpdates"],"updatePoint":{"line":247,"column":43},"line":247,"code":"    it('should log other statuses as \"logs\"', async () => {\n      const logSpy = sinon.spy((server as any).logger, 'log');\n      const serverMock = {\n        status: sinon.stub().returns({\n          async *[Symbol.asyncIterator]() {\n            yield { type: 'non-disconnect', data: 'localhost' };\n            yield { type: 'warn', data: {} };\n          },\n        }),\n      };\n      await server.handleStatusUpdates(serverMock as any);\n      expect(logSpy.calledTwice).to.be.true;\n      expect(\n        logSpy.calledWith(\n          `NatsStatus: type: \"non-disconnect\", data: \"localhost\".`,\n        ),\n      );\n      expect(logSpy.calledWith(`NatsStatus: type: \"warn\", data: \"{}\".`));\n    });","file":"server/server-nats.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"error\" event to handler","suites":["ServerRedis","listen"],"updatePoint":{"line":34,"column":44},"line":34,"code":"    it('should bind \"error\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onSpy.getCall(0).args[0]).to.be.equal('error');\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"RedisClient#connect()\"","suites":["ServerRedis","listen"],"updatePoint":{"line":38,"column":43},"line":38,"code":"    it('should call \"RedisClient#connect()\"', () => {\n      server.listen(callbackSpy);\n      expect(connectSpy.called).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerRedis","listen","when \"start\" throws an exception"],"updatePoint":{"line":43,"column":65},"line":43,"code":"      it('should call callback with a thrown error as an argument', () => {\n        const error = new Error('random error');\n\n        const callbackSpy = sinon.spy();\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close pub & sub server","suites":["ServerRedis","close"],"updatePoint":{"line":62,"column":37},"line":62,"code":"    it('should close pub & sub server', () => {\n      server.close();\n\n      expect(pub.quit.called).to.be.true;\n      expect(sub.quit.called).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"message\" event to handler if wildcards are disabled","suites":["ServerRedis","handleConnection"],"updatePoint":{"line":84,"column":72},"line":84,"code":"    it('should bind \"message\" event to handler if wildcards are disabled', () => {\n      server.bindEvents(sub, null);\n      expect(onSpy.getCall(0).args[0]).to.be.equal('message');\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"pmessage\" event to handler if wildcards are enabled","suites":["ServerRedis","handleConnection"],"updatePoint":{"line":88,"column":72},"line":88,"code":"    it('should bind \"pmessage\" event to handler if wildcards are enabled', () => {\n      (server as any).options = {};\n      (server as any).options.wildcards = true;\n\n      server.bindEvents(psub, null);\n      expect(onSpy.getCall(0).args[0]).to.be.equal('pmessage');\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should \"subscribe\" to each pattern if wildcards are disabled","suites":["ServerRedis","handleConnection"],"updatePoint":{"line":96,"column":68},"line":96,"code":"    it('should \"subscribe\" to each pattern if wildcards are disabled', () => {\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n      server.bindEvents(sub, null);\n      expect(subscribeSpy.calledWith(pattern)).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should \"psubscribe\" to each pattern if wildcards are enabled","suites":["ServerRedis","handleConnection"],"updatePoint":{"line":106,"column":68},"line":106,"code":"    it('should \"psubscribe\" to each pattern if wildcards are enabled', () => {\n      (server as any).options = {};\n      (server as any).options.wildcards = true;\n\n      const pattern = 'test';\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler,\n      });\n      server.bindEvents(psub, null);\n      expect(subscribeSpy.calledWith(pattern)).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerRedis","getMessageHandler"],"updatePoint":{"line":120,"column":30},"line":120,"code":"    it(`should return function`, () => {\n      expect(typeof server.getMessageHandler(null)).to.be.eql('function');\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if identifier is not present","suites":["ServerRedis","handleMessage"],"updatePoint":{"line":135,"column":62},"line":135,"code":"    it('should call \"handleEvent\" if identifier is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      sinon.stub(server, 'parseMessage').callsFake(() => ({ data } as any));\n\n      await server.handleMessage(channel, JSON.stringify({}), null, channel);\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object","suites":["ServerRedis","handleMessage"],"updatePoint":{"line":142,"column":89},"line":142,"code":"    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {\n      sinon.stub(server, 'parseMessage').callsFake(() => ({ id, data } as any));\n      await server.handleMessage(\n        channel,\n        JSON.stringify({ id }),\n        null,\n        channel,\n      );\n      expect(\n        getPublisherSpy.calledWith({\n          id,\n          status: 'error',\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerRedis","handleMessage"],"updatePoint":{"line":158,"column":51},"line":158,"code":"    it(`should call handler with expected arguments`, async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n      sinon.stub(server, 'parseMessage').callsFake(() => ({ id, data } as any));\n\n      await server.handleMessage(channel, {}, null, channel);\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return function","suites":["ServerRedis","getPublisher"],"updatePoint":{"line":183,"column":30},"line":183,"code":"    it(`should return function`, () => {\n      expect(typeof server.getPublisher(null, null, id)).to.be.eql('function');\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"publish\" with expected arguments","suites":["ServerRedis","getPublisher"],"updatePoint":{"line":186,"column":53},"line":186,"code":"    it(`should call \"publish\" with expected arguments`, () => {\n      const respond = 'test';\n      publisher({ respond, id });\n      expect(\n        publisherSpy.calledWith(\n          `${pattern}.reply`,\n          JSON.stringify({ respond, id }),\n        ),\n      ).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return parsed json","suites":["ServerRedis","parseMessage"],"updatePoint":{"line":198,"column":33},"line":198,"code":"    it(`should return parsed json`, () => {\n      const obj = { test: 'test' };\n      expect(server.parseMessage(obj)).to.deep.equal(\n        JSON.parse(JSON.stringify(obj)),\n      );\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not parse argument if it is not an object","suites":["ServerRedis","parseMessage"],"updatePoint":{"line":204,"column":56},"line":204,"code":"    it(`should not parse argument if it is not an object`, () => {\n      const content = 'test';\n      expect(server.parseMessage(content)).to.equal(content);\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should leave pattern as it is","suites":["ServerRedis","getRequestPattern"],"updatePoint":{"line":211,"column":37},"line":211,"code":"    it(`should leave pattern as it is`, () => {\n      const expectedResult = test;\n      expect(server.getRequestPattern(test)).to.equal(expectedResult);\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should append \".reply\" to string","suites":["ServerRedis","getReplyPattern"],"updatePoint":{"line":218,"column":40},"line":218,"code":"    it(`should append \".reply\" to string`, () => {\n      const expectedResult = test + '.reply';\n      expect(server.getReplyPattern(test)).to.equal(expectedResult);\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return options object with \"retryStrategy\" and call \"createRetryStrategy\"","suites":["ServerRedis","getClientOptions"],"updatePoint":{"line":224,"column":88},"line":224,"code":"    it('should return options object with \"retryStrategy\" and call \"createRetryStrategy\"', () => {\n      const createSpy = sinon.spy(server, 'createRetryStrategy');\n      const { retryStrategy } = server.getClientOptions();\n      try {\n        retryStrategy(0);\n      } catch {}\n      expect(createSpy.called).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerRedis","createRetryStrategy","when is terminated"],"updatePoint":{"line":235,"column":33},"line":235,"code":"      it('should return undefined', () => {\n        (server as any).isExplicitlyTerminated = true;\n        const result = server.createRetryStrategy(0);\n        expect(result).to.be.undefined;\n      });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerRedis","createRetryStrategy","when \"retryAttempts\" does not exist"],"updatePoint":{"line":242,"column":33},"line":242,"code":"      it('should return undefined', () => {\n        (server as any).options.options = {};\n        (server as any).options.options.retryAttempts = undefined;\n\n        expect(server.createRetryStrategy(4)).to.be.undefined;\n      });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerRedis","createRetryStrategy","when \"attempts\" count is max"],"updatePoint":{"line":250,"column":33},"line":250,"code":"      it('should return undefined', () => {\n        (server as any).options.options = {};\n        (server as any).options.options.retryAttempts = 3;\n\n        expect(server.createRetryStrategy(4)).to.be.undefined;\n      });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return delay (ms)","suites":["ServerRedis","createRetryStrategy","otherwise"],"updatePoint":{"line":258,"column":34},"line":258,"code":"      it('should return delay (ms)', () => {\n        (server as any).options = {};\n        (server as any).isExplicitlyTerminated = false;\n        (server as any).options.retryAttempts = 3;\n        (server as any).options.retryDelay = 3;\n        const result = server.createRetryStrategy(2);\n        expect(result).to.be.eql((server as any).options.retryDelay);\n      });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerRedis","handleEvent"],"updatePoint":{"line":272,"column":51},"line":272,"code":"    it('should call handler with expected arguments', () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      server.handleEvent(\n        channel,\n        { pattern: '', data },\n        new BaseRpcContext([]),\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-redis.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"createClient\"","suites":["ServerRMQ","listen"],"updatePoint":{"line":44,"column":34},"line":44,"code":"    it('should call \"createClient\"', () => {\n      server.listen(callbackSpy);\n      expect(createClient.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"connect\" event to handler","suites":["ServerRMQ","listen"],"updatePoint":{"line":48,"column":46},"line":48,"code":"    it('should bind \"connect\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onStub.getCall(0).args[0]).to.be.equal('connect');\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"disconnect\" event to handler","suites":["ServerRMQ","listen"],"updatePoint":{"line":52,"column":49},"line":52,"code":"    it('should bind \"disconnect\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onStub.getCall(1).args[0]).to.be.equal('disconnect');\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind \"connectFailed\" event to handler","suites":["ServerRMQ","listen"],"updatePoint":{"line":56,"column":52},"line":56,"code":"    it('should bind \"connectFailed\" event to handler', () => {\n      server.listen(callbackSpy);\n      expect(onStub.getCall(2).args[0]).to.be.equal('connectFailed');\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call callback with a thrown error as an argument","suites":["ServerRMQ","listen","when \"start\" throws an exception"],"updatePoint":{"line":61,"column":65},"line":61,"code":"      it('should call callback with a thrown error as an argument', () => {\n        const error = new Error('random error');\n\n        sinon.stub(server, 'start').callsFake(() => {\n          throw error;\n        });\n        server.listen(callbackSpy);\n        expect(callbackSpy.calledWith(error)).to.be.true;\n      });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close server","suites":["ServerRMQ","close"],"updatePoint":{"line":80,"column":27},"line":80,"code":"    it('should close server', () => {\n      server.close();\n      expect(rmqServer.close.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close channel","suites":["ServerRMQ","close"],"updatePoint":{"line":84,"column":28},"line":84,"code":"    it('should close channel', () => {\n      server.close();\n      expect(rmqChannel.close.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"handleEvent\" if identifier is not present","suites":["ServerRMQ","handleMessage"],"updatePoint":{"line":113,"column":62},"line":113,"code":"    it('should call \"handleEvent\" if identifier is not present', async () => {\n      const handleEventSpy = sinon.spy(server, 'handleEvent');\n      await server.handleMessage(createMessage({ pattern: '', data: '' }), '');\n      expect(handleEventSpy.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send NO_MESSAGE_HANDLER error if key does not exists in handlers object","suites":["ServerRMQ","handleMessage"],"updatePoint":{"line":118,"column":86},"line":118,"code":"    it('should send NO_MESSAGE_HANDLER error if key does not exists in handlers object', async () => {\n      await server.handleMessage(msg, '');\n      expect(\n        sendMessageStub.calledWith({\n          id: '3',\n          status: 'error',\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler if exists in handlers object","suites":["ServerRMQ","handleMessage"],"updatePoint":{"line":128,"column":56},"line":128,"code":"    it('should call handler if exists in handlers object', async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler as any,\n      });\n      await server.handleMessage(msg, '');\n      expect(handler.calledOnce).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not throw if the message is an invalid json","suites":["ServerRMQ","handleMessage"],"updatePoint":{"line":136,"column":58},"line":136,"code":"    it('should not throw if the message is an invalid json', async () => {\n      const invalidMsg = {\n        content: {\n          toString: () => 'd',\n        },\n        properties: { correlationId: 1 },\n      };\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [pattern]: handler as any,\n      });\n\n      return server.handleMessage(invalidMsg, '').catch(() => {\n        assert.fail('Was not supposed to throw an error');\n      });\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"assertQueue\" with queue and queue options","suites":["ServerRMQ","setupChannel"],"updatePoint":{"line":173,"column":62},"line":173,"code":"    it('should call \"assertQueue\" with queue and queue options', async () => {\n      await server.setupChannel(channel, () => null);\n      expect(channel.assertQueue.calledWith(queue, queueOptions)).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"prefetch\" with prefetchCount and \"isGlobalPrefetchCount\"","suites":["ServerRMQ","setupChannel"],"updatePoint":{"line":177,"column":77},"line":177,"code":"    it('should call \"prefetch\" with prefetchCount and \"isGlobalPrefetchCount\"', async () => {\n      await server.setupChannel(channel, () => null);\n      expect(channel.prefetch.calledWith(prefetchCount, isGlobalPrefetchCount))\n        .to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"consumeChannel\" method","suites":["ServerRMQ","setupChannel"],"updatePoint":{"line":182,"column":43},"line":182,"code":"    it('should call \"consumeChannel\" method', async () => {\n      await server.setupChannel(channel, () => null);\n      expect(channel.consume.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"resolve\" function","suites":["ServerRMQ","setupChannel"],"updatePoint":{"line":186,"column":38},"line":186,"code":"    it('should call \"resolve\" function', async () => {\n      const resolve = sinon.spy();\n      await server.setupChannel(channel, resolve);\n      expect(resolve.called).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should publish message to indicated queue","suites":["ServerRMQ","sendMessage"],"updatePoint":{"line":203,"column":49},"line":203,"code":"    it('should publish message to indicated queue', () => {\n      const message = { test: true };\n      const replyTo = 'test';\n      const correlationId = '0';\n\n      server.sendMessage(message, replyTo, correlationId);\n      expect(\n        channel.sendToQueue.calledWith(\n          replyTo,\n          Buffer.from(JSON.stringify(message)),\n          { correlationId },\n        ),\n      ).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerRMQ","handleEvent"],"updatePoint":{"line":223,"column":51},"line":223,"code":"    it('should call handler with expected arguments', () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      server.handleEvent(\n        channel,\n        { pattern: '', data },\n        new RmqContext([{}, {}, '']),\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should negative acknowledge without retrying if key does not exists in handlers object and noAck option is false","suites":["ServerRMQ","handleEvent"],"updatePoint":{"line":237,"column":120},"line":237,"code":"    it('should negative acknowledge without retrying if key does not exists in handlers object and noAck option is false', () => {\n      const nack = sinon.spy();\n      const message = { pattern: 'no-exists', data };\n      (server as any).channel = {\n        nack,\n      };\n      (server as any).noAck = false;\n      server.handleEvent(channel, message, new RmqContext([message, '', '']));\n\n      expect(nack.calledWith(message, false, false)).to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should not negative acknowledge if key does not exists in handlers object but noAck option is true","suites":["ServerRMQ","handleEvent"],"updatePoint":{"line":249,"column":106},"line":249,"code":"    it('should not negative acknowledge if key does not exists in handlers object but noAck option is true', () => {\n      const nack = sinon.spy();\n      const message = { pattern: 'no-exists', data };\n      (server as any).channel = {\n        nack,\n      };\n      (server as any).noAck = true;\n      server.handleEvent(channel, message, new RmqContext([message, '', '']));\n\n      expect(nack.calledWith(message, false, false)).not.to.be.true;\n    });","file":"server/server-rmq.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should bind message and error events to handler","suites":["ServerTCP","bindHandler"],"updatePoint":{"line":22,"column":55},"line":22,"code":"    it('should bind message and error events to handler', () => {\n      server.bindHandler(null);\n      expect(socket.on.calledTwice).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should close server","suites":["ServerTCP","close"],"updatePoint":{"line":32,"column":27},"line":32,"code":"    it('should close server', () => {\n      server.close();\n      expect(tcpServer.close.called).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call native listen method with expected arguments","suites":["ServerTCP","listen"],"updatePoint":{"line":42,"column":64},"line":42,"code":"    it('should call native listen method with expected arguments', () => {\n      const callback = () => {};\n      server.listen(callback);\n      expect(\n        serverMock.listen.calledWith(\n          (server as any).port,\n          (server as any).host,\n          callback,\n        ),\n      ).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send NO_MESSAGE_HANDLER error if key does not exists in handlers object","suites":["ServerTCP","handleMessage"],"updatePoint":{"line":66,"column":86},"line":66,"code":"    it('should send NO_MESSAGE_HANDLER error if key does not exists in handlers object', async () => {\n      await server.handleMessage(socket, msg);\n      expect(\n        socket.sendMessage.calledWith({\n          id: msg.id,\n          status: 'error',\n          err: NO_MESSAGE_HANDLER,\n        }),\n      ).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler if exists in handlers object","suites":["ServerTCP","handleMessage"],"updatePoint":{"line":76,"column":56},"line":76,"code":"    it('should call handler if exists in handlers object', async () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [msg.pattern]: handler as any,\n      });\n      await server.handleMessage(socket, msg);\n      expect(handler.calledOnce).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerTCP","handleClose","when is terminated"],"updatePoint":{"line":87,"column":33},"line":87,"code":"      it('should return undefined', () => {\n        (server as any).isExplicitlyTerminated = true;\n        const result = server.handleClose();\n        expect(result).to.be.undefined;\n      });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerTCP","handleClose","when \"retryAttempts\" does not exist"],"updatePoint":{"line":94,"column":33},"line":94,"code":"      it('should return undefined', () => {\n        (server as any).options.retryAttempts = undefined;\n        const result = server.handleClose();\n        expect(result).to.be.undefined;\n      });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return undefined","suites":["ServerTCP","handleClose","when \"retryAttemptsCount\" count is max"],"updatePoint":{"line":101,"column":33},"line":101,"code":"      it('should return undefined', () => {\n        (server as any).options.retryAttempts = 3;\n        (server as any).retryAttemptsCount = 3;\n        const result = server.handleClose();\n        expect(result).to.be.undefined;\n      });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return delay (ms)","suites":["ServerTCP","handleClose","otherwise"],"updatePoint":{"line":109,"column":34},"line":109,"code":"      it('should return delay (ms)', () => {\n        (server as any).options = {};\n        (server as any).isExplicitlyTerminated = false;\n        (server as any).options.retryAttempts = 3;\n        (server as any).retryAttemptsCount = 2;\n        (server as any).options.retryDelay = 3;\n        const result = server.handleClose();\n        expect(result).to.be.not.undefined;\n      });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call handler with expected arguments","suites":["ServerTCP","handleEvent"],"updatePoint":{"line":125,"column":51},"line":125,"code":"    it('should call handler with expected arguments', () => {\n      const handler = sinon.spy();\n      (server as any).messageHandlers = objectToMap({\n        [channel]: handler,\n      });\n\n      server.handleEvent(\n        channel,\n        { pattern: '', data },\n        new BaseRpcContext([]),\n      );\n      expect(handler.calledWith(data)).to.be.true;\n    });","file":"server/server-tcp.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should add handler","suites":["Server","addHandler"],"updatePoint":{"line":22,"column":26},"line":22,"code":"    it(`should add handler`, () => {\n      const handlerRoute = 'hello';\n      sandbox\n        .stub(server as any, 'messageHandlers')\n        .value({ set() {}, has() {} });\n\n      const messageHandlersSetSpy = sinon.spy(\n        (server as any).messageHandlers,\n        'set',\n      );\n      const normalizePatternStub = sinon\n        .stub(server as any, 'normalizePattern')\n        .returns(handlerRoute);\n\n      server.addHandler(pattern, callback as any);\n\n      expect(messageHandlersSetSpy.called).to.be.true;\n      expect(messageHandlersSetSpy.args[0][0]).to.be.equal(handlerRoute);\n      expect(messageHandlersSetSpy.args[0][1]).to.be.equal(callback);\n\n      normalizePatternStub.restore();\n    });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should find tail and assign a handler ref to it","suites":["Server","addHandler","when handler is an event handler","and there are other handlers registered for the pattern already"],"updatePoint":{"line":46,"column":59},"line":46,"code":"        it('should find tail and assign a handler ref to it', () => {\n          const handlerRoute = 'hello';\n          const headHandler: any = () => null;\n          const nextHandler: any = () => null;\n\n          headHandler.next = nextHandler;\n          (server as any)['messageHandlers'] = new Map([\n            [handlerRoute, headHandler],\n          ]);\n          const normalizePatternStub = sinon\n            .stub(server as any, 'normalizePattern')\n            .returns(handlerRoute);\n\n          server.addHandler(pattern, callback as any, true);\n\n          expect(nextHandler.next).to.equal(callback);\n          normalizePatternStub.restore();\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call 'transformPatternToRoute' with 'string' argument","suites":["Server","getRouteFromPattern","when gets 'string' pattern"],"updatePoint":{"line":80,"column":70},"line":80,"code":"      it(`should call 'transformPatternToRoute' with 'string' argument`, () => {\n        const inputServerPattern = 'hello';\n        const transformedServerPattern = inputServerPattern;\n        (server as any).getRouteFromPattern(inputServerPattern);\n\n        expect(normalizePatternStub.args[0][0]).to.be.equal(\n          transformedServerPattern,\n        );\n      });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call 'transformPatternToRoute' with 'json' argument","suites":["Server","getRouteFromPattern","when gets 'json' pattern as 'string'"],"updatePoint":{"line":92,"column":68},"line":92,"code":"      it(`should call 'transformPatternToRoute' with 'json' argument`, () => {\n        const inputServerPattern = '{\"controller\":\"app\",\"use\":\"getHello\"}';\n        const transformedServerPattern = {\n          controller: 'app',\n          use: 'getHello',\n        };\n        (server as any).getRouteFromPattern(inputServerPattern);\n\n        expect(normalizePatternStub.args[0][0]).to.be.deep.equal(\n          transformedServerPattern,\n        );\n      });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send error and complete","suites":["Server","send","when stream","throws exception"],"updatePoint":{"line":121,"column":42},"line":121,"code":"        it('should send error and complete', () => {\n          process.nextTick(() => {\n            expect(\n              sendSpy.calledWith({\n                err: 'test',\n                isDisposed: true,\n              }),\n            ).to.be.true;\n          });\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should send response and \"complete\" event","suites":["Server","send","when stream","emits response"],"updatePoint":{"line":136,"column":53},"line":136,"code":"        it('should send response and \"complete\" event', () => {\n          process.nextTick(() => {\n            expect(\n              sendSpy.calledWith({\n                response: 'test',\n                isDisposed: true,\n              }),\n            ).to.be.true;\n          });\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable that emits the resolved value of the supplied promise","suites":["Server","transformToObservable","when resultOrDeferred","is Promise"],"updatePoint":{"line":152,"column":90},"line":152,"code":"        it('should return Observable that emits the resolved value of the supplied promise', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(\n              server.transformToObservable(Promise.resolve(value)),\n            ),\n          ).to.be.eq(100);\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the observable itself","suites":["Server","transformToObservable","when resultOrDeferred","is Observable"],"updatePoint":{"line":162,"column":47},"line":162,"code":"        it('should return the observable itself', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(server.transformToObservable(of(value))),\n          ).to.be.eq(100);\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable that emits the supplied number","suites":["Server","transformToObservable","when resultOrDeferred","is any number"],"updatePoint":{"line":170,"column":67},"line":170,"code":"        it('should return Observable that emits the supplied number', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(server.transformToObservable(value)),\n          ).to.be.eq(100);\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return Observable that emits the supplied array","suites":["Server","transformToObservable","when resultOrDeferred","is an array"],"updatePoint":{"line":178,"column":66},"line":178,"code":"        it('should return Observable that emits the supplied array', async () => {\n          const value = [1, 2, 3];\n          expect(\n            await lastValueFrom(server.transformToObservable(value)),\n          ).to.be.eq(value);\n        });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return registered handlers","suites":["Server","getHandlers"],"updatePoint":{"line":189,"column":41},"line":189,"code":"    it('should return registered handlers', () => {\n      const messageHandlers = [() => null, () => true];\n      sandbox.stub(server as any, 'messageHandlers').value(messageHandlers);\n      expect(server.getHandlers()).to.equal(messageHandlers);\n    });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return expected handler","suites":["Server","getHandlerByPattern","when handler exists"],"updatePoint":{"line":222,"column":40},"line":222,"code":"      it('should return expected handler', () => {\n        messageHandlersHasSpy.returns(true);\n\n        const value = server.getHandlerByPattern(handlerRoute);\n\n        expect(messageHandlersHasSpy.args[0][0]).to.be.equal(handlerRoute);\n        expect(messageHandlersGetSpy.called).to.be.true;\n        expect(messageHandlersGetSpy.args[0][0]).to.be.equal(handlerRoute);\n        expect(value).to.be.equal(callback);\n      });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return null","suites":["Server","getHandlerByPattern","when handler does not exists"],"updatePoint":{"line":235,"column":28},"line":235,"code":"      it('should return null', () => {\n        messageHandlersHasSpy.returns(false);\n\n        const value = server.getHandlerByPattern(handlerRoute);\n\n        expect(messageHandlersHasSpy.args[0][0]).to.be.equal(handlerRoute);\n        expect(messageHandlersGetSpy.called).to.be.false;\n        expect(value).to.be.null;\n      });","file":"server/server.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the 'number' what is wrapped in a string","suites":["transformPatternToRoute","when gets 'number' value"],"updatePoint":{"line":13,"column":62},"line":13,"code":"    it(`should return the 'number' what is wrapped in a string`, () => {\n      const testPatterns = [1, 150, 12345];\n      const expectedResults = [`1`, `150`, `12345`];\n\n      equalTest(testPatterns, expectedResults);\n    });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the same string","suites":["transformPatternToRoute","when gets 'string' value"],"updatePoint":{"line":22,"column":37},"line":22,"code":"    it(`should return the same string`, () => {\n      const testPatterns = [`pattern1`, 'PaTteRn2', '3PaTteRn'];\n\n      equalTest(testPatterns, testPatterns);\n    });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return correct route","suites":["transformPatternToRoute","when gets 'JSON' value","without nested JSON (1 level)"],"updatePoint":{"line":31,"column":37},"line":31,"code":"      it(`should return correct route`, () => {\n        const testPatterns = [\n          {\n            controller: 'app',\n            use: 'getHello',\n          },\n          {\n            use: 'getHello',\n            controller: 'app',\n          },\n          {\n            service: 'one',\n            use: 'getHello',\n            controller: 'app',\n            id: 150,\n          },\n        ];\n\n        const expectedResults = [\n          JSON.stringify(testPatterns[0]),\n          `{\"controller\":\"app\",\"use\":\"getHello\"}`,\n          `{\"controller\":\"app\",\"id\":150,\"service\":\"one\",\"use\":\"getHello\"}`,\n        ];\n\n        equalTest(testPatterns, expectedResults);\n      });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return correct route","suites":["transformPatternToRoute","when gets 'JSON' value","with nested JSON (2 levels)"],"updatePoint":{"line":59,"column":37},"line":59,"code":"      it(`should return correct route`, () => {\n        const testPatterns = [\n          {\n            controller: 'app',\n            use: { p1: 'path1', p2: 'path2', p3: 10 },\n          },\n          {\n            use: { p1: 'path1', p2: 'path2' },\n            controller: 'app',\n          },\n          {\n            service: 'one',\n            use: { p1: 'path1', p2: 'path2', id: 160 },\n            controller: 'app',\n          },\n        ];\n\n        const expectedResults = [\n          JSON.stringify(testPatterns[0]),\n          `{\"controller\":\"app\",\"use\":{\"p1\":\"path1\",\"p2\":\"path2\"}}`,\n          `{\"controller\":\"app\",\"service\":\"one\",\"use\":{\"id\":160,\"p1\":\"path1\",\"p2\":\"path2\"}}`,\n        ];\n\n        equalTest(testPatterns, expectedResults);\n      });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return correct route","suites":["transformPatternToRoute","when gets 'JSON' value","with nested JSON (3 levels)"],"updatePoint":{"line":86,"column":37},"line":86,"code":"      it(`should return correct route`, () => {\n        const testPatterns = [\n          {\n            controller: 'app',\n            use: { p1: 'path1', p2: { pp1: 'ppath1' } },\n          },\n          {\n            use: { p1: 'path1' },\n            controller: { p2: 'path2' },\n          },\n          {\n            service: 'one',\n            use: { p1: 'path1', p2: { pp1: 'ppath1' } },\n            controller: { p1: { pp1: 'ppath1', id: 180 } },\n          },\n        ];\n\n        const expectedResults = [\n          JSON.stringify(testPatterns[0]),\n          `{\"controller\":{\"p2\":\"path2\"},\"use\":{\"p1\":\"path1\"}}`,\n          `{\"controller\":{\"p1\":{\"id\":180,\"pp1\":\"ppath1\"}},\"service\":\"one\",\"use\":{\"p1\":\"path1\",\"p2\":{\"pp1\":\"ppath1\"}}}`,\n        ];\n\n        equalTest(testPatterns, expectedResults);\n      });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should return the value unchanged","suites":["transformPatternToRoute","when gets value with incorrect type (no string/number/JSON)"],"updatePoint":{"line":115,"column":41},"line":115,"code":"    it(`should return the value unchanged`, () => {\n      const testPatterns = [null, undefined, Symbol(213)];\n\n      testPatterns.forEach((testPattern: any) => {\n        expect(transformPatternToRoute(testPattern)).to.be.eq(testPattern);\n      });\n    });","file":"utils/transform-pattern.utils.spec.ts","skipped":false,"dir":"packages/microservices/test"},{"name":"should call \"serverAndEventStreamsHosts\" get method with expected arguments","suites":["SocketsContainer","getSocketEventsHostByPort"],"updatePoint":{"line":22,"column":83},"line":22,"code":"    it(`should call \"serverAndEventStreamsHosts\" get method with expected arguments`, () => {\n      const config = { port, path: 'random' };\n      instance.getOneByConfig(config);\n\n      const token = hash(config);\n      expect(getSpy.calledWith(token)).to.be.true;\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"serverAndEventStreamsHosts\" set method with expected arguments","suites":["SocketsContainer","addOne"],"updatePoint":{"line":31,"column":83},"line":31,"code":"    it(`should call \"serverAndEventStreamsHosts\" set method with expected arguments`, () => {\n      const server = {};\n      const config = { port, path: 'random' };\n\n      instance.addOne(config, server as any);\n\n      const token = hash(config);\n      expect(setSpy.calledWith(token, server)).to.be.true;\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return \"serverAndEventStreamsHosts\"","suites":["SocketsContainer","getAll"],"updatePoint":{"line":42,"column":50},"line":42,"code":"    it('should return \"serverAndEventStreamsHosts\"', () => {\n      const collection = ['test'];\n      (instance as any).serverAndEventStreamsHosts = collection;\n      expect(instance.getAll()).to.be.eq(collection);\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should clear hosts collection","suites":["SocketsContainer","clear"],"updatePoint":{"line":49,"column":37},"line":49,"code":"    it('should clear hosts collection', () => {\n      const collection = { clear: sinon.spy() };\n      (instance as any).serverAndEventStreamsHosts = collection;\n      instance.clear();\n      expect(collection.clear.called).to.be.true;\n    });","file":"container.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return plain ExceptionHandler object","suites":["ExceptionFiltersContext","create","when filters metadata is empty"],"updatePoint":{"line":28,"column":53},"line":28,"code":"      it('should return plain ExceptionHandler object', () => {\n        const filter = exceptionFilter.create(\n          new EmptyMetadata(),\n          () => ({} as any),\n          '',\n        );\n        expect((filter as any).filters).to.be.empty;\n      });","file":"context/exception-filters.context.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return ExceptionHandler object with exception filters","suites":["ExceptionFiltersContext","create","when filters metadata is not empty"],"updatePoint":{"line":41,"column":70},"line":41,"code":"      it('should return ExceptionHandler object with exception filters', () => {\n        const filter = exceptionFilter.create(\n          new WithMetadata(),\n          () => ({} as any),\n          '',\n        );\n        expect((filter as any).filters).to.not.be.empty;\n      });","file":"context/exception-filters.context.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should create exception handler","suites":["WsContextCreator","create"],"updatePoint":{"line":79,"column":39},"line":79,"code":"    it('should create exception handler', () => {\n      const handlerCreateSpy = sinon.spy(exceptionFiltersContext, 'create');\n      contextCreator.create(instance, instance.test, module, 'create');\n      expect(\n        handlerCreateSpy.calledWith(instance, instance.test as any, module),\n      ).to.be.true;\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should create pipes context","suites":["WsContextCreator","create"],"updatePoint":{"line":86,"column":35},"line":86,"code":"    it('should create pipes context', () => {\n      const pipesCreateSpy = sinon.spy(pipesCreator, 'create');\n      contextCreator.create(instance, instance.test, module, 'create');\n      expect(pipesCreateSpy.calledWith(instance, instance.test, module)).to.be\n        .true;\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should create guards context","suites":["WsContextCreator","create"],"updatePoint":{"line":92,"column":36},"line":92,"code":"    it('should create guards context', () => {\n      const guardsCreateSpy = sinon.spy(guardsContextCreator, 'create');\n      contextCreator.create(instance, instance.test, module, 'create');\n      expect(guardsCreateSpy.calledWith(instance, instance.test, module)).to.be\n        .true;\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call guards consumer `tryActivate`","suites":["WsContextCreator","create","when proxy called"],"updatePoint":{"line":99,"column":51},"line":99,"code":"      it('should call guards consumer `tryActivate`', async () => {\n        const tryActivateSpy = sinon.spy(guardsConsumer, 'tryActivate');\n        sinon\n          .stub(guardsContextCreator, 'create')\n          .callsFake(() => [{ canActivate: () => true }]);\n        const proxy = await contextCreator.create(\n          instance,\n          instance.test,\n          module,\n          'test',\n        );\n        const data = 'test';\n        await proxy(null, data);\n\n        expect(tryActivateSpy.called).to.be.true;\n      });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should throw forbidden exception","suites":["WsContextCreator","create","when proxy called","when can not activate"],"updatePoint":{"line":116,"column":44},"line":116,"code":"        it('should throw forbidden exception', async () => {\n          sinon\n            .stub(guardsConsumer, 'tryActivate')\n            .callsFake(async () => false);\n          const proxy = await contextCreator.create(\n            instance,\n            instance.test,\n            module,\n            'test',\n          );\n          const data = 'test';\n          proxy(null, data).catch(err =>\n            expect(err).to.be.instanceOf(WsException),\n          );\n        });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return paramtypes array","suites":["WsContextCreator","reflectCallbackParamtypes"],"updatePoint":{"line":136,"column":38},"line":136,"code":"    it('should return paramtypes array', () => {\n      const paramtypes = contextCreator.reflectCallbackParamtypes(\n        instance,\n        instance.test,\n      );\n      expect(paramtypes).to.be.eql([String, Number]);\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should throw exception when \"tryActivate\" returns false","suites":["WsContextCreator","createGuardsFn"],"updatePoint":{"line":146,"column":63},"line":146,"code":"    it('should throw exception when \"tryActivate\" returns false', () => {\n      const guardsFn = contextCreator.createGuardsFn([null], null, null);\n      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);\n      guardsFn([]).catch(err => expect(err).to.not.be.undefined);\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should exchange arguments keys for appropriate values","suites":["WsContextCreator","exchangeKeysForValues"],"updatePoint":{"line":154,"column":61},"line":154,"code":"    it('should exchange arguments keys for appropriate values', () => {\n      const metadata = {\n        [WsParamtype.SOCKET]: { index: 0, data: 'test', pipes: [] },\n        [WsParamtype.PAYLOAD]: { index: 2, data: 'test', pipes: [] },\n        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {\n          index: 3,\n          data: 'custom',\n          pipes: [],\n        },\n      };\n      const keys = Object.keys(metadata);\n      const values = contextCreator.exchangeKeysForValues(\n        keys,\n        metadata,\n        '',\n        new WsParamsFactory(),\n        (args: unknown[]) => new ExecutionContextHost(args),\n      );\n      const expectedValues = [\n        { index: 0, type: WsParamtype.SOCKET, data: 'test' },\n        { index: 2, type: WsParamtype.PAYLOAD, data: 'test' },\n        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },\n      ];\n      expect(values[0]).to.deep.include(expectedValues[0]);\n      expect(values[1]).to.deep.include(expectedValues[1]);\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"consumer.apply\"","suites":["WsContextCreator","getParamValue"],"updatePoint":{"line":190,"column":36},"line":190,"code":"    it('should call \"consumer.apply\"', () => {\n      contextCreator.getParamValue(\n        value,\n        { metatype, type: WsParamtype.PAYLOAD, data: null },\n        transforms,\n      );\n      expect(consumerApplySpy.called).to.be.true;\n    });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"returns null","suites":["WsContextCreator","createPipesFn","when \"paramsOptions\" is empty"],"updatePoint":{"line":201,"column":22},"line":201,"code":"      it('returns null', async () => {\n        const pipesFn = contextCreator.createPipesFn([], []);\n        expect(pipesFn).to.be.null;\n      });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"returns function","suites":["WsContextCreator","createPipesFn","when \"paramsOptions\" is not empty"],"updatePoint":{"line":207,"column":26},"line":207,"code":"      it('returns function', async () => {\n        const pipesFn = contextCreator.createPipesFn(\n          [],\n          [\n            {\n              index: 1,\n              type: 'test',\n              data: null,\n              pipes: [],\n              extractValue: () => null,\n            },\n          ],\n        );\n        await pipesFn([]);\n        expect(pipesFn).to.be.a('function');\n      });","file":"context/ws-context-creator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should method return thunk","suites":["WsProxy","create"],"updatePoint":{"line":20,"column":34},"line":20,"code":"    it('should method return thunk', async () => {\n      const proxy = await routerProxy.create(async (client, data) => {},\n      handler);\n      expect(typeof proxy === 'function').to.be.true;\n    });","file":"context/ws-proxy.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should method encapsulate callback passed as argument","suites":["WsProxy","create"],"updatePoint":{"line":26,"column":61},"line":26,"code":"    it('should method encapsulate callback passed as argument', async () => {\n      const expectation = handlerMock.expects('handle').once();\n      const proxy = routerProxy.create(async (client, data) => {\n        throw new WsException('test');\n      }, handler);\n      await proxy(null, null);\n      expectation.verify();\n    });","file":"context/ws-proxy.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should attach \"catchError\" operator when observable was returned","suites":["WsProxy","create"],"updatePoint":{"line":35,"column":72},"line":35,"code":"    it('should attach \"catchError\" operator when observable was returned', async () => {\n      const expectation = handlerMock.expects('handle').once();\n      const proxy = routerProxy.create(async (client, data) => {\n        return throwError(() => new WsException('test'));\n      }, handler);\n      (await proxy(null, null)).subscribe(null, () => expectation.verify());\n    });","file":"context/ws-proxy.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should enhance class with expected request metadata","suites":["@ConnectedSocket"],"updatePoint":{"line":11,"column":57},"line":11,"code":"  it('should enhance class with expected request metadata', () => {\n    const argsMetadata = Reflect.getMetadata(\n      PARAM_ARGS_METADATA,\n      ConnectedSocketTest,\n      'test',\n    );\n    const expectedMetadata = {\n      [`${WsParamtype.SOCKET}:0`]: {\n        data: undefined,\n        index: 0,\n        pipes: [],\n      },\n    };\n    expect(argsMetadata).to.be.eql(expectedMetadata);\n  });","file":"decorators/connected-socket.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should enhance class with expected request metadata","suites":["@MessagePayload"],"updatePoint":{"line":12,"column":57},"line":12,"code":"  it('should enhance class with expected request metadata', () => {\n    const argsMetadata = Reflect.getMetadata(\n      PARAM_ARGS_METADATA,\n      MessagePayloadTest,\n      'test',\n    );\n    const expectedMetadata = {\n      [`${WsParamtype.PAYLOAD}:0`]: {\n        data: undefined,\n        index: 0,\n        pipes: [ValidationPipe],\n      },\n    };\n    expect(argsMetadata).to.be.eql(expectedMetadata);\n  });","file":"decorators/message-body.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return error message as string","suites":["WsException","when string passed"],"updatePoint":{"line":9,"column":45},"line":9,"code":"    it('should return error message as string', () => {\n      expect(instance.getError()).to.be.eql(error);\n    });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should set the message property","suites":["WsException","when string passed"],"updatePoint":{"line":12,"column":39},"line":12,"code":"    it('should set the message property', () => {\n      expect(instance.message).to.be.eql(error);\n    });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return error as object","suites":["WsException","when object passed","and message property is undefined"],"updatePoint":{"line":22,"column":39},"line":22,"code":"      it('should return error as object', () => {\n        expect(instance.getError()).to.be.eql(error);\n      });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should fallback error message to class name","suites":["WsException","when object passed","and message property is undefined"],"updatePoint":{"line":25,"column":53},"line":25,"code":"      it('should fallback error message to class name', () => {\n        expect(instance.message).to.be.eql('Ws Exception');\n      });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return error as object","suites":["WsException","when object passed","and message property is not undefined"],"updatePoint":{"line":33,"column":39},"line":33,"code":"      it('should return error as object', () => {\n        expect(instance.getError()).to.be.eql(error);\n      });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return error message as the extracted \"message\" string","suites":["WsException","when object passed","and message property is not undefined"],"updatePoint":{"line":36,"column":71},"line":36,"code":"      it('should return error message as the extracted \"message\" string', () => {\n        expect(instance.message).to.be.eql(error.message);\n      });","file":"exceptions/ws-exception.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should method emit expected status code message when exception is unknown","suites":["WsExceptionsHandler","handle"],"updatePoint":{"line":22,"column":81},"line":22,"code":"    it('should method emit expected status code message when exception is unknown', () => {\n      handler.handle(new Error(), new ExecutionContextHost([client]));\n      expect(\n        emitStub.calledWith('exception', {\n          status: 'error',\n          message: 'Internal server error',\n        }),\n      ).to.be.true;\n    });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should method emit expected status and json object","suites":["WsExceptionsHandler","handle","when exception is instance of WsException"],"updatePoint":{"line":32,"column":60},"line":32,"code":"      it('should method emit expected status and json object', () => {\n        const message = {\n          custom: 'Unauthorized',\n        };\n        handler.handle(\n          new WsException(message),\n          new ExecutionContextHost([client]),\n        );\n        expect(emitStub.calledWith('exception', message)).to.be.true;\n      });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should method emit expected status and transform message to json","suites":["WsExceptionsHandler","handle","when exception is instance of WsException"],"updatePoint":{"line":42,"column":74},"line":42,"code":"      it('should method emit expected status and transform message to json', () => {\n        const message = 'Unauthorized';\n\n        handler.handle(\n          new WsException(message),\n          new ExecutionContextHost([client]),\n        );\n        expect(emitStub.calledWith('exception', { message, status: 'error' }))\n          .to.be.true;\n      });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should not call `emit`","suites":["WsExceptionsHandler","handle","when \"invokeCustomFilters\" returns true"],"updatePoint":{"line":57,"column":32},"line":57,"code":"      it('should not call `emit`', () => {\n        handler.handle(new WsException(''), new ExecutionContextHost([client]));\n        expect(emitStub.notCalled).to.be.true;\n      });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should set custom filters","suites":["WsExceptionsHandler","setCustomFilters"],"updatePoint":{"line":65,"column":33},"line":65,"code":"    it('should set custom filters', () => {\n      handler.setCustomFilters(filters as any);\n      expect((handler as any).filters).to.be.eql(filters);\n    });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should throw exception when passed argument is not an array","suites":["WsExceptionsHandler","setCustomFilters"],"updatePoint":{"line":69,"column":67},"line":69,"code":"    it('should throw exception when passed argument is not an array', () => {\n      expect(() => handler.setCustomFilters(null)).to.throw();\n    });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return false","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is empty"],"updatePoint":{"line":75,"column":29},"line":75,"code":"      it('should return false', () => {\n        expect(handler.invokeCustomFilters(null, null)).to.be.false;\n      });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call funcSpy","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":91,"column":31},"line":91,"code":"        it('should call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.false;\n        });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call funcSpy with exception and response passed as an arguments","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":95,"column":82},"line":95,"code":"        it('should call funcSpy with exception and response passed as an arguments', () => {\n          const exception = new TestException();\n          const res = { foo: 'bar' };\n\n          handler.invokeCustomFilters(exception, res as any);\n          expect(funcSpy.calledWith(exception, res)).to.be.true;\n        });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return true","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter exists in filters array"],"updatePoint":{"line":102,"column":30},"line":102,"code":"        it('should return true', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .true;\n        });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should not call funcSpy","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":108,"column":35},"line":108,"code":"        it('should not call funcSpy', () => {\n          handler.invokeCustomFilters(new TestException(), null);\n          expect(funcSpy.notCalled).to.be.true;\n        });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return false","suites":["WsExceptionsHandler","invokeCustomFilters","when filters array is not empty","when filter does not exists in filters array"],"updatePoint":{"line":112,"column":31},"line":112,"code":"        it('should return false', () => {\n          expect(handler.invokeCustomFilters(new TestException(), null)).to.be\n            .false;\n        });","file":"exceptions/ws-exceptions-handler.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return expected observable socket object","suites":["ServerAndEventStreamsFactory","create"],"updatePoint":{"line":7,"column":55},"line":7,"code":"    it(`should return expected observable socket object`, () => {\n      const server = { test: 'test' };\n      const result = ServerAndEventStreamsFactory.create(server);\n\n      expect(result).to.have.keys('init', 'connection', 'disconnect', 'server');\n      expect(result.init instanceof ReplaySubject).to.be.true;\n      expect(result.connection instanceof Subject).to.be.true;\n      expect(result.disconnect instanceof Subject).to.be.true;\n      expect(result.server).to.be.eql(server);\n    });","file":"factories/server-and-event-streams-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return a message payload object","suites":["WsParamsFactory","exchangeKeyForValue","when key is","WsParamtype.PAYLOAD"],"updatePoint":{"line":17,"column":50},"line":17,"code":"        it('should return a message payload object', () => {\n          expect(\n            factory.exchangeKeyForValue(WsParamtype.PAYLOAD, null, args),\n          ).to.be.eql(data);\n        });","file":"factories/ws-params-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return a message payload object with parameter extraction","suites":["WsParamsFactory","exchangeKeyForValue","when key is","WsParamtype.PAYLOAD"],"updatePoint":{"line":22,"column":76},"line":22,"code":"        it('should return a message payload object with parameter extraction', () => {\n          expect(\n            factory.exchangeKeyForValue(WsParamtype.PAYLOAD, 'data', args),\n          ).to.be.eql(data.data);\n        });","file":"factories/ws-params-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return a connected socket object","suites":["WsParamsFactory","exchangeKeyForValue","when key is","WsParamtype.SOCKET"],"updatePoint":{"line":29,"column":51},"line":29,"code":"        it('should return a connected socket object', () => {\n          expect(\n            factory.exchangeKeyForValue(WsParamtype.SOCKET, null, args),\n          ).to.be.eql(client);\n        });","file":"factories/ws-params-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return null","suites":["WsParamsFactory","exchangeKeyForValue","when key is not available"],"updatePoint":{"line":37,"column":28},"line":37,"code":"      it('should return null', () => {\n        expect(factory.exchangeKeyForValue(-1, null, [])).to.be.eql(null);\n      });","file":"factories/ws-params-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return null","suites":["WsParamsFactory","exchangeKeyForValue","when args are not available"],"updatePoint":{"line":42,"column":28},"line":42,"code":"      it('should return null', () => {\n        expect(factory.exchangeKeyForValue(null, null, null)).to.be.eql(null);\n      });","file":"factories/ws-params-factory.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"scanFromPrototype\" with expected arguments","suites":["GatewayMetadataExplorer","explore"],"updatePoint":{"line":45,"column":63},"line":45,"code":"    it(`should call \"scanFromPrototype\" with expected arguments`, () => {\n      const obj = new Test();\n      instance.explore(obj as any);\n\n      const [argProto] = getAllMethodNames.getCall(0).args;\n      expect(argProto).to.be.eql(Object.getPrototypeOf(obj));\n    });","file":"gateway-metadata-explorer.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return null when \"isMessageMapping\" metadata is undefined","suites":["GatewayMetadataExplorer","exploreMethodMetadata"],"updatePoint":{"line":58,"column":72},"line":58,"code":"    it(`should return null when \"isMessageMapping\" metadata is undefined`, () => {\n      const metadata = instance.exploreMethodMetadata(test, 'noMessage');\n      expect(metadata).to.eq(null);\n    });","file":"gateway-metadata-explorer.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return message mapping properties when \"isMessageMapping\" metadata is not undefined","suites":["GatewayMetadataExplorer","exploreMethodMetadata"],"updatePoint":{"line":62,"column":98},"line":62,"code":"    it(`should return message mapping properties when \"isMessageMapping\" metadata is not undefined`, () => {\n      const metadata = instance.exploreMethodMetadata(test, 'test');\n      expect(metadata).to.have.keys(['callback', 'message', 'methodName']);\n      expect(metadata.message).to.eql(message);\n    });","file":"gateway-metadata-explorer.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return properties with @Client decorator","suites":["GatewayMetadataExplorer","scanForServerHooks"],"updatePoint":{"line":69,"column":55},"line":69,"code":"    it(`should return properties with @Client decorator`, () => {\n      const obj = new Test();\n      const servers = [...instance.scanForServerHooks(obj as any)];\n\n      expect(servers).to.have.length(2);\n      expect(servers).to.deep.eq(['server', 'anotherServer']);\n    });","file":"gateway-metadata-explorer.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return stored server","suites":["SocketServerProvider","scanForSocketServer"],"updatePoint":{"line":37,"column":35},"line":37,"code":"    it(`should return stored server`, () => {\n      const server = { test: 'test' };\n      mockContainer.expects('getOneByConfig').returns(server);\n\n      const result = instance.scanForSocketServer({ namespace: null }, port);\n\n      expect(createSocketServerSpy.called).to.be.false;\n      expect(result).to.eq(server);\n    });","file":"socket-server-provider.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"createSocketServer\" when server is not stored already","suites":["SocketServerProvider","scanForSocketServer"],"updatePoint":{"line":47,"column":74},"line":47,"code":"    it(`should call \"createSocketServer\" when server is not stored already`, () => {\n      mockContainer.expects('getOneByConfig').returns(null);\n\n      instance.scanForSocketServer({ path }, port);\n      expect(createSocketServerSpy.called).to.be.true;\n    });","file":"socket-server-provider.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"decorateWithNamespace\" when namespace is specified","suites":["SocketServerProvider","scanForSocketServer"],"updatePoint":{"line":54,"column":71},"line":54,"code":"    it(`should call \"decorateWithNamespace\" when namespace is specified`, () => {\n      const decorateWithNamespaceSpy = sinon.spy(\n        instance,\n        'decorateWithNamespace' as any,\n      );\n\n      instance.scanForSocketServer({ path, namespace: 'random' }, port);\n      expect(decorateWithNamespaceSpy.called).to.be.true;\n    });","file":"socket-server-provider.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"decorateWithNamespace\" and not call \"createSocketServer\"","suites":["SocketServerProvider","scanForSocketServer","when namespace is specified and server does exist already"],"updatePoint":{"line":65,"column":79},"line":65,"code":"      it(`should call \"decorateWithNamespace\" and not call \"createSocketServer\"`, () => {\n        const server = { test: 'test' };\n        mockContainer.expects('getOneByConfig').returns(server);\n\n        const decorateWithNamespaceSpy = sinon.spy(\n          instance,\n          'decorateWithNamespace' as any,\n        );\n\n        instance.scanForSocketServer({ path, namespace: 'random' }, port);\n        expect(decorateWithNamespaceSpy.called).to.be.true;\n        expect(createSocketServerSpy.called).to.be.false;\n      });","file":"socket-server-provider.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should compare elements at the specific position in arrays","suites":["compareElementAt"],"updatePoint":{"line":5,"column":64},"line":5,"code":"  it('should compare elements at the specific position in arrays', () => {\n    expect(compareElementAt([0, 1, 0], [2, 1, 7], 1)).to.be.true;\n    expect(compareElementAt([0, 1, 0], [2, 0, 7], 1)).to.be.false;\n  });","file":"utils/compare-element.util.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should decorate server property with expected metadata","suites":["@WebSocketServer"],"updatePoint":{"line":10,"column":60},"line":10,"code":"  it('should decorate server property with expected metadata', () => {\n    const isServer = Reflect.getOwnMetadata(\n      GATEWAY_SERVER_METADATA,\n      TestGateway,\n      'server',\n    );\n    expect(isServer).to.be.eql(true);\n  });","file":"utils/gateway-server.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should set property value to null by default","suites":["@WebSocketServer"],"updatePoint":{"line":18,"column":50},"line":18,"code":"  it('should set property value to null by default', () => {\n    expect(TestGateway.server).to.be.eql(null);\n  });","file":"utils/gateway-server.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should decorate transport with expected metadata","suites":["@WebSocketGateway"],"updatePoint":{"line":9,"column":54},"line":9,"code":"  it('should decorate transport with expected metadata', () => {\n    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway);\n    const port = Reflect.getMetadata('port', TestGateway);\n    const { namespace } = Reflect.getMetadata(GATEWAY_OPTIONS, TestGateway);\n\n    expect(isGateway).to.be.eql(true);\n    expect(port).to.be.eql(80);\n    expect(namespace).to.be.eql('/');\n  });","file":"utils/socket-gateway.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should decorate transport with port: 0","suites":["@WebSocketGateway"],"updatePoint":{"line":22,"column":44},"line":22,"code":"  it('should decorate transport with port: 0', () => {\n    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway2);\n    const port = Reflect.getMetadata('port', TestGateway2);\n\n    expect(isGateway).to.be.eql(true);\n    expect(port).to.be.eql(0);\n  });","file":"utils/socket-gateway.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should decorate transport with expected options","suites":["@WebSocketGateway"],"updatePoint":{"line":33,"column":53},"line":33,"code":"  it('should decorate transport with expected options', () => {\n    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway3);\n    const port = Reflect.getMetadata('port', TestGateway3);\n    const { namespace } = Reflect.getMetadata(GATEWAY_OPTIONS, TestGateway3);\n\n    expect(isGateway).to.be.eql(true);\n    expect(port).to.be.eql(0);\n    expect(namespace).to.be.eql('/');\n  });","file":"utils/socket-gateway.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should decorate transport with expected metadata","suites":["@SubscribeMessage"],"updatePoint":{"line":11,"column":54},"line":11,"code":"  it('should decorate transport with expected metadata', () => {\n    const isMessageMapping = Reflect.getMetadata(\n      MESSAGE_MAPPING_METADATA,\n      TestGateway.fn,\n    );\n    const message = Reflect.getMetadata('message', TestGateway.fn);\n\n    expect(isMessageMapping).to.be.true;\n    expect(message).to.be.eql('filter');\n  });","file":"utils/subscribe-message.decorator.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should throw \"InvalidSocketPortException\" when port is not a number","suites":["WebSocketsController","connectGatewayToServer"],"updatePoint":{"line":75,"column":75},"line":75,"code":"    it('should throw \"InvalidSocketPortException\" when port is not a number', () => {\n      Reflect.defineMetadata(PORT_METADATA, 'test', InvalidGateway);\n      expect(() =>\n        instance.connectGatewayToServer(\n          new InvalidGateway(),\n          InvalidGateway,\n          'moduleKey',\n          'instanceWrapperId',\n        ),\n      ).throws(InvalidSocketPortException);\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeToServerEvents\" with default values when metadata is empty","suites":["WebSocketsController","connectGatewayToServer"],"updatePoint":{"line":86,"column":88},"line":86,"code":"    it('should call \"subscribeToServerEvents\" with default values when metadata is empty', () => {\n      const gateway = new DefaultGateway();\n      instance.connectGatewayToServer(\n        gateway,\n        DefaultGateway,\n        'moduleKey',\n        'instanceWrapperId',\n      );\n      expect(subscribeToServerEvents.calledWith(gateway, {}, 0, 'moduleKey')).to\n        .be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeToServerEvents\" when metadata is valid","suites":["WebSocketsController","connectGatewayToServer"],"updatePoint":{"line":97,"column":68},"line":97,"code":"    it('should call \"subscribeToServerEvents\" when metadata is valid', () => {\n      const gateway = new Test();\n      instance.connectGatewayToServer(\n        gateway,\n        Test,\n        'moduleKey',\n        'instanceWrapperId',\n      );\n      expect(\n        subscribeToServerEvents.calledWith(\n          gateway,\n          { namespace },\n          port,\n          'moduleKey',\n        ),\n      ).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"assignServerToProperties\" with expected arguments","suites":["WebSocketsController","subscribeToServerEvents"],"updatePoint":{"line":148,"column":70},"line":148,"code":"    it('should call \"assignServerToProperties\" with expected arguments', () => {\n      instance.subscribeToServerEvents(\n        gateway,\n        { namespace },\n        port,\n        'moduleKey',\n        'instanceWrapperId',\n      );\n      expect(assignServerToProperties.calledWith(gateway, server.server)).to.be\n        .true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeEvents\" with expected arguments","suites":["WebSocketsController","subscribeToServerEvents"],"updatePoint":{"line":159,"column":61},"line":159,"code":"    it('should call \"subscribeEvents\" with expected arguments', () => {\n      instance.subscribeToServerEvents(\n        gateway,\n        { namespace },\n        port,\n        'moduleKey',\n        'instanceWrapperId',\n      );\n      expect(subscribeEvents.firstCall.args[0]).to.be.equal(gateway);\n      expect(subscribeEvents.firstCall.args[2]).to.be.equal(server);\n      expect(subscribeEvents.firstCall.args[1]).to.be.eql([\n        {\n          message: 'message',\n          methodName: 'methodName',\n          callback: messageHandlerCallback,\n        },\n      ]);\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should inspect & insert corresponding entrypoint definitions","suites":["WebSocketsController","inspectEntrypointDefinitions"],"updatePoint":{"line":179,"column":68},"line":179,"code":"    it('should inspect & insert corresponding entrypoint definitions', () => {\n      class GatewayHostCls {}\n\n      const port = 80;\n      const instanceWrapperId = '1234';\n      const messageHandlers: MessageMappingProperties[] = [\n        {\n          methodName: 'findOne',\n          message: 'find',\n          callback: null,\n        },\n        {\n          methodName: 'create',\n          message: 'insert',\n          callback: null,\n        },\n      ];\n      const insertEntrypointDefinitionSpy = sinon.spy(\n        graphInspector,\n        'insertEntrypointDefinition',\n      );\n      instance.inspectEntrypointDefinitions(\n        new GatewayHostCls(),\n        port,\n        messageHandlers,\n        instanceWrapperId,\n      );\n\n      expect(insertEntrypointDefinitionSpy.calledTwice).to.be.true;\n      expect(\n        insertEntrypointDefinitionSpy.calledWith({\n          type: 'websocket',\n          methodName: messageHandlers[0].methodName,\n          className: GatewayHostCls.name,\n          classNodeId: instanceWrapperId,\n          metadata: {\n            port,\n            key: messageHandlers[0].message,\n            message: messageHandlers[0].message,\n          } as any,\n        }),\n      ).to.be.true;\n      expect(\n        insertEntrypointDefinitionSpy.calledWith({\n          type: 'websocket',\n          methodName: messageHandlers[1].methodName,\n          className: GatewayHostCls.name,\n          classNodeId: instanceWrapperId,\n          metadata: {\n            port,\n            key: messageHandlers[1].message,\n            message: messageHandlers[1].message,\n          } as any,\n        }),\n      ).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeConnectionEvent\" with expected arguments","suites":["WebSocketsController","subscribeEvents"],"updatePoint":{"line":273,"column":70},"line":273,"code":"    it('should call \"subscribeConnectionEvent\" with expected arguments', () => {\n      instance.subscribeEvents(gateway, handlers, server as any);\n      expect(subscribeConnectionEvent.calledWith(gateway, server.connection)).to\n        .be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeDisconnectEvent\" with expected arguments","suites":["WebSocketsController","subscribeEvents"],"updatePoint":{"line":278,"column":70},"line":278,"code":"    it('should call \"subscribeDisconnectEvent\" with expected arguments', () => {\n      instance.subscribeEvents(gateway, handlers, server as any);\n      expect(subscribeDisconnectEvent.calledWith(gateway, server.disconnect)).to\n        .be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeInitEvent\" with expected arguments","suites":["WebSocketsController","subscribeEvents"],"updatePoint":{"line":283,"column":64},"line":283,"code":"    it('should call \"subscribeInitEvent\" with expected arguments', () => {\n      instance.subscribeEvents(gateway, handlers, server as any);\n      expect(subscribeInitEvent.calledWith(gateway, server.init)).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should bind connection handler to server","suites":["WebSocketsController","subscribeEvents"],"updatePoint":{"line":287,"column":48},"line":287,"code":"    it('should bind connection handler to server', () => {\n      instance.subscribeEvents(gateway, handlers, server as any);\n      expect(onSpy.calledWith('connection', getConnectionHandler())).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"getConnectionHandler\" with expected arguments","suites":["WebSocketsController","subscribeEvents"],"updatePoint":{"line":291,"column":66},"line":291,"code":"    it('should call \"getConnectionHandler\" with expected arguments', () => {\n      instance.subscribeEvents(gateway, handlers, server as any);\n      expect(\n        getConnectionHandler.calledWith(\n          instance,\n          gateway,\n          handlers,\n          server.disconnect,\n          server.connection,\n        ),\n      ).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return function","suites":["WebSocketsController","getConnectionHandler"],"updatePoint":{"line":344,"column":30},"line":344,"code":"    it('should return function', () => {\n      expect(\n        instance.getConnectionHandler(null, null, null, null, null),\n      ).to.be.a('function');\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"next\" method of connection object with expected argument","suites":["WebSocketsController","getConnectionHandler"],"updatePoint":{"line":349,"column":77},"line":349,"code":"    it('should call \"next\" method of connection object with expected argument', () => {\n      expect(nextSpy.calledWith([client])).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"subscribeMessages\" with expected arguments","suites":["WebSocketsController","getConnectionHandler"],"updatePoint":{"line":352,"column":63},"line":352,"code":"    it('should call \"subscribeMessages\" with expected arguments', () => {\n      expect(subscribeMessages.calledWith(handlers, client, gateway)).to.be\n        .true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call \"on\" method of client object with expected arguments","suites":["WebSocketsController","getConnectionHandler"],"updatePoint":{"line":356,"column":72},"line":356,"code":"    it('should call \"on\" method of client object with expected arguments', () => {\n      expect(onSpy.called).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should not call subscribe method when \"afterInit\" method not exists","suites":["WebSocketsController","subscribeInitEvent"],"updatePoint":{"line":368,"column":75},"line":368,"code":"    it('should not call subscribe method when \"afterInit\" method not exists', () => {\n      instance.subscribeInitEvent(gateway, event);\n      expect(subscribe.called).to.be.false;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call subscribe method of event object with expected arguments when \"afterInit\" exists","suites":["WebSocketsController","subscribeInitEvent"],"updatePoint":{"line":372,"column":100},"line":372,"code":"    it('should call subscribe method of event object with expected arguments when \"afterInit\" exists', () => {\n      (gateway as any).afterInit = () => {};\n      instance.subscribeInitEvent(gateway, event);\n      expect(subscribe.called).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should not call subscribe method when \"handleConnection\" method not exists","suites":["WebSocketsController","subscribeConnectionEvent"],"updatePoint":{"line":386,"column":82},"line":386,"code":"    it('should not call subscribe method when \"handleConnection\" method not exists', () => {\n      instance.subscribeConnectionEvent(gateway, event);\n      expect(subscribe.called).to.be.false;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call subscribe method of event object with expected arguments when \"handleConnection\" exists","suites":["WebSocketsController","subscribeConnectionEvent"],"updatePoint":{"line":390,"column":107},"line":390,"code":"    it('should call subscribe method of event object with expected arguments when \"handleConnection\" exists', () => {\n      (gateway as any).handleConnection = () => {};\n      instance.subscribeConnectionEvent(gateway, event);\n      expect(subscribe.called).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should not call subscribe method when \"handleDisconnect\" method not exists","suites":["WebSocketsController","subscribeDisconnectEvent"],"updatePoint":{"line":404,"column":82},"line":404,"code":"    it('should not call subscribe method when \"handleDisconnect\" method not exists', () => {\n      instance.subscribeDisconnectEvent(gateway, event);\n      expect(subscribe.called).to.be.false;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should call subscribe method of event object with expected arguments when \"handleDisconnect\" exists","suites":["WebSocketsController","subscribeDisconnectEvent"],"updatePoint":{"line":408,"column":107},"line":408,"code":"    it('should call subscribe method of event object with expected arguments when \"handleDisconnect\" exists', () => {\n      (gateway as any).handleDisconnect = () => {};\n      instance.subscribeDisconnectEvent(gateway, event);\n      expect(subscribe.called).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should bind each handler to client","suites":["WebSocketsController","subscribeMessages"],"updatePoint":{"line":428,"column":42},"line":428,"code":"    it('should bind each handler to client', () => {\n      instance.subscribeMessages(handlers, client, gateway);\n      expect(onSpy.calledTwice).to.be.true;\n    });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return Promise<Observable>","suites":["WebSocketsController","pickResult","when deferredResult contains value which","is a Promise"],"updatePoint":{"line":436,"column":45},"line":436,"code":"        it('should return Promise<Observable>', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(\n              await instance.pickResult(\n                Promise.resolve(Promise.resolve(value)),\n              ),\n            ),\n          ).to.be.eq(value);\n        });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return Promise<Observable>","suites":["WebSocketsController","pickResult","when deferredResult contains value which","is an Observable"],"updatePoint":{"line":449,"column":45},"line":449,"code":"        it('should return Promise<Observable>', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(\n              await instance.pickResult(Promise.resolve(of(value))),\n            ),\n          ).to.be.eq(value);\n        });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return Promise<Observable>","suites":["WebSocketsController","pickResult","when deferredResult contains value which","is an object that has the method `subscribe`"],"updatePoint":{"line":460,"column":45},"line":460,"code":"        it('should return Promise<Observable>', async () => {\n          const value = { subscribe() {} };\n          expect(\n            await lastValueFrom(\n              await instance.pickResult(Promise.resolve(value)),\n            ),\n          ).to.equal(value);\n        });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"should return Promise<Observable>","suites":["WebSocketsController","pickResult","when deferredResult contains value which","is an ordinary value"],"updatePoint":{"line":471,"column":45},"line":471,"code":"        it('should return Promise<Observable>', async () => {\n          const value = 100;\n          expect(\n            await lastValueFrom(\n              await instance.pickResult(Promise.resolve(value)),\n            ),\n          ).to.be.eq(value);\n        });","file":"web-sockets-controller.spec.ts","skipped":false,"dir":"packages/websockets/test"},{"name":"/ (GET)","suites":["AppController (e2e)"],"updatePoint":{"line":18,"column":13},"line":18,"code":"  it('/ (GET)', () => {\n    return request(app.getHttpServer())\n      .get('/')\n      .expect(200)\n      .expect('Hello World!');\n  });","file":"app.e2e-spec.ts","skipped":false,"dir":"sample/30-event-emitter/test"}]}