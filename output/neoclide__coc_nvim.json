{"repo":"neoclide/coc.nvim","url":"https://github.com/neoclide/coc.nvim","branch":"master","configs":[{"package":"coc.nvim-master","lang":"ts","dir":"src/__tests__","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"lang":"js","dir":"src/__tests__/extensions/test","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should send file change notification","suites":["Client integration"],"updatePoint":{"line":28,"column":42},"line":28,"code":"  it('should send file change notification', async () => {\n    if (global.__TEST__) return\n    let uri = URI.file(__filename)\n    await workspace.openResource(uri.toString())\n    let serverModule = path.join(__dirname, './server/testFileWatcher.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.ipc\n    }\n    let clientOptions: lsclient.LanguageClientOptions = {\n      documentSelector: ['css'],\n      synchronize: {}, initializationOptions: {},\n      middleware: {\n      }\n    }\n    let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    await helper.wait(100)\n    let file = path.join(__dirname, 'test.js')\n    fs.writeFileSync(file, '', 'utf8')\n    toDispose = Disposable.create(() => {\n      fs.unlinkSync(file)\n    })\n    await helper.wait(300)\n    let res = await client.sendRequest('custom/received')\n    expect(res).toEqual({\n      changes: [{\n        uri: URI.file(file).toString(),\n        type: 1\n      }]\n    })\n  })","file":"client/changedFiles.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should request all configuration","suites":["pull configuration feature"],"updatePoint":{"line":47,"column":38},"line":47,"code":"  it('should request all configuration', async () => {\n    let config: any\n    client.middleware.workspace = client.middleware.workspace ?? {}\n    client.middleware.workspace.configuration = (params, token, next) => {\n      config = next(params, token)\n      return config\n    }\n    await client.sendNotification('pull0')\n    await helper.wait(50)\n    expect(config).toBeDefined()\n    expect(config[0].http).toBeDefined()\n  })","file":"client/configuretion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should request configurations with sections","suites":["pull configuration feature"],"updatePoint":{"line":60,"column":49},"line":60,"code":"  it('should request configurations with sections', async () => {\n    let config: any\n    client.middleware.workspace = client.middleware.workspace ?? {}\n    client.middleware.workspace.configuration = (params, token, next) => {\n      config = next(params, token)\n      return config\n    }\n    await client.sendNotification('pull1')\n    await helper.wait(50)\n    expect(config).toBeDefined()\n    expect(config.length).toBe(3)\n    expect(config[1]).toBeNull()\n    expect(config[0].proxy).toBeDefined()\n    expect(config[2]).toBeNull()\n  })","file":"client/configuretion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send configuration for languageserver","suites":["publish configuration feature"],"updatePoint":{"line":78,"column":50},"line":78,"code":"  it('should send configuration for languageserver', async () => {\n    let client: LanguageClient\n    client = createClient('languageserver.cpp.settings')\n    let changed\n    client.onNotification('configurationChange', params => {\n      changed = params\n    })\n    await client.start()\n    await helper.wait(50)\n    expect(changed).toBeDefined()\n    expect(changed).toEqual({ settings: {} })\n    await client.stop()\n  })","file":"client/configuretion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send configuration for specific sections","suites":["publish configuration feature"],"updatePoint":{"line":92,"column":53},"line":92,"code":"  it('should send configuration for specific sections', async () => {\n    let client: LanguageClient\n    let called = false\n    client = createClient(['coc.preferences', 'npm', 'unknown'], {\n      workspace: {\n        didChangeConfiguration: (sections, next) => {\n          called = true\n          return next(sections)\n        }\n      }\n    })\n    let changed\n    client.onNotification('configurationChange', params => {\n      changed = params\n    })\n    await client.start()\n    await helper.wait(50)\n    expect(called).toBe(true)\n    expect(changed).toBeDefined()\n    expect(changed.settings.coc).toBeDefined()\n    expect(changed.settings.npm).toBeDefined()\n    let { configurations } = workspace\n    configurations.updateUserConfig({ 'npm.binPath': 'cnpm' })\n    await helper.wait(500)\n    expect(changed.settings.npm).toBeDefined()\n    expect(changed.settings.npm.binPath).toBe('cnpm')\n    await client.stop()\n  })","file":"client/configuretion.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ensure proper param passing","suites":["Connection Tests"],"updatePoint":{"line":36,"column":40},"line":36,"code":"  it('should ensure proper param passing', async () => {\n    let paramsCorrect = false\n    serverConnection.onRequest(InitializeRequest.type, params => {\n      paramsCorrect = !Array.isArray(params)\n      let result: InitializeResult = {\n        capabilities: {\n        }\n      }\n      return result\n    })\n\n    const init: InitializeParams = {\n      rootUri: 'file:///home/dirkb',\n      processId: 1,\n      capabilities: {},\n      workspaceFolders: null,\n    }\n    await clientConnection.sendRequest(InitializeRequest.type, init)\n    expect(paramsCorrect).toBe(true)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide token","suites":["Connection Tests"],"updatePoint":{"line":57,"column":26},"line":57,"code":"  it('should provide token', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.partialResultToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      partialResultToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report result","suites":["Connection Tests"],"updatePoint":{"line":70,"column":26},"line":70,"code":"  it('should report result', async () => {\n    let result: SymbolInformation = {\n      name: 'abc',\n      kind: SymbolKind.Class,\n      location: {\n        uri: 'file:///abc.txt',\n        range: { start: { line: 0, character: 1 }, end: { line: 2, character: 3 } }\n      }\n    }\n    serverConnection.onRequest(DocumentSymbolRequest.type, async params => {\n      expect(params.partialResultToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      await serverConnection.sendProgress(progressType, params.partialResultToken, [result])\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      partialResultToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    let progressOK = false\n    clientConnection.onProgress(progressType, '3b1db4c9-e011-489e-a9d1-0653e64707c2', values => {\n      progressOK = (values !== undefined && values.length === 1)\n    })\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n    expect(progressOK).toBeTruthy()\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide workDoneToken","suites":["Connection Tests"],"updatePoint":{"line":97,"column":34},"line":97,"code":"  it('should provide workDoneToken', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, params => {\n      expect(params.workDoneToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      workDoneToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report work done progress","suites":["Connection Tests"],"updatePoint":{"line":110,"column":38},"line":110,"code":"  it('should report work done progress', async () => {\n    serverConnection.onRequest(DocumentSymbolRequest.type, async params => {\n      expect(params.workDoneToken).toBe('3b1db4c9-e011-489e-a9d1-0653e64707c2')\n      await serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'begin',\n        title: 'progress'\n      })\n      await serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'report',\n        message: 'message'\n      })\n      await serverConnection.sendProgress(progressType, params.workDoneToken, {\n        kind: 'end',\n        message: 'message'\n      })\n      return []\n    })\n\n    const params: DocumentSymbolParams = {\n      textDocument: { uri: 'file:///abc.txt' },\n      workDoneToken: '3b1db4c9-e011-489e-a9d1-0653e64707c2'\n    }\n    let result = ''\n    clientConnection.onProgress(progressType, '3b1db4c9-e011-489e-a9d1-0653e64707c2', value => {\n      result += value.kind\n    })\n    await clientConnection.sendRequest(DocumentSymbolRequest.type, params)\n    expect(result).toBe('beginreportend')\n  })","file":"client/connection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convertToTextDocumentItem","suites":["converter"],"updatePoint":{"line":13,"column":38},"line":13,"code":"  it('should convertToTextDocumentItem', () => {\n    let doc = createDocument()\n    expect(cv.convertToTextDocumentItem(doc).uri).toBe(doc.uri)\n    expect(TextDocumentItem.is(cv.convertToTextDocumentItem(doc))).toBe(true)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCloseTextDocumentParams","suites":["converter"],"updatePoint":{"line":19,"column":38},"line":19,"code":"  it('should asCloseTextDocumentParams', () => {\n    let doc = createDocument()\n    expect(cv.asCloseTextDocumentParams(doc).textDocument.uri).toBe(doc.uri)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asRelativePattern","suites":["converter"],"updatePoint":{"line":24,"column":30},"line":24,"code":"  it('should asRelativePattern', async () => {\n    let rp = cv.asRelativePattern({\n      baseUri: 'file:///a',\n      pattern: '**/*'\n    })\n    expect(rp.baseUri.fsPath).toBe('/a')\n    rp = cv.asRelativePattern({\n      baseUri: { uri: 'file:///a', name: 'name' },\n      pattern: '**/*'\n    })\n    expect(rp.baseUri.fsPath).toBe('/a')\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asChangeTextDocumentParams","suites":["converter"],"updatePoint":{"line":37,"column":39},"line":37,"code":"  it('should asChangeTextDocumentParams', () => {\n    let doc = createDocument()\n    expect(cv.asFullChangeTextDocumentParams(doc).textDocument.uri).toBe(doc.uri)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asWillSaveTextDocumentParams","suites":["converter"],"updatePoint":{"line":42,"column":41},"line":42,"code":"  it('should asWillSaveTextDocumentParams', () => {\n    let res = cv.asWillSaveTextDocumentParams({ document: createDocument(), reason: TextDocumentSaveReason.Manual, waitUntil: () => {} })\n    expect(res.textDocument).toBeDefined()\n    expect(res.reason).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asVersionedTextDocumentIdentifier","suites":["converter"],"updatePoint":{"line":48,"column":46},"line":48,"code":"  it('should asVersionedTextDocumentIdentifier', () => {\n    let res = cv.asVersionedTextDocumentIdentifier(createDocument())\n    expect(res.uri).toBeDefined()\n    expect(res.version).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asSaveTextDocumentParams","suites":["converter"],"updatePoint":{"line":54,"column":37},"line":54,"code":"  it('should asSaveTextDocumentParams', () => {\n    let res = cv.asSaveTextDocumentParams(createDocument(), true)\n    expect(res.textDocument.uri).toBeDefined()\n    expect(res.text).toBeDefined()\n    res = cv.asSaveTextDocumentParams(createDocument(), false)\n    expect(res.text).toBeUndefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asUri","suites":["converter"],"updatePoint":{"line":62,"column":18},"line":62,"code":"  it('should asUri', () => {\n    let uri = URI.file('/tmp/a')\n    expect(cv.asUri(uri)).toBe(uri.toString())\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCompletionParams","suites":["converter"],"updatePoint":{"line":67,"column":31},"line":67,"code":"  it('should asCompletionParams', () => {\n    let params = cv.asCompletionParams(createDocument(), Position.create(0, 0), { triggerKind: CompletionTriggerKind.Invoked })\n    expect(params.textDocument).toBeDefined()\n    expect(params.position).toBeDefined()\n    expect(params.context).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asTextDocumentPositionParams","suites":["converter"],"updatePoint":{"line":74,"column":41},"line":74,"code":"  it('should asTextDocumentPositionParams', () => {\n    let params = cv.asTextDocumentPositionParams(createDocument(), Position.create(0, 0))\n    expect(params.textDocument).toBeDefined()\n    expect(params.position).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asTextDocumentIdentifier","suites":["converter"],"updatePoint":{"line":80,"column":37},"line":80,"code":"  it('should asTextDocumentIdentifier', () => {\n    let doc = cv.asTextDocumentIdentifier(createDocument())\n    expect(doc.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asReferenceParams","suites":["converter"],"updatePoint":{"line":85,"column":30},"line":85,"code":"  it('should asReferenceParams', () => {\n    let params = cv.asReferenceParams(createDocument(), Position.create(0, 0), { includeDeclaration: false })\n    expect(params.textDocument.uri).toBeDefined()\n    expect(params.position).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asDocumentSymbolParams","suites":["converter"],"updatePoint":{"line":91,"column":35},"line":91,"code":"  it('should asDocumentSymbolParams', () => {\n    let doc = cv.asDocumentSymbolParams(createDocument())\n    expect(doc.textDocument.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asCodeLensParams","suites":["converter"],"updatePoint":{"line":96,"column":29},"line":96,"code":"  it('should asCodeLensParams', () => {\n    let doc = cv.asCodeLensParams(createDocument())\n    expect(doc.textDocument.uri).toBeDefined()\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - edit range","suites":["converter"],"updatePoint":{"line":101,"column":36},"line":101,"code":"  it('Completion Result - edit range', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { editRange: Range.create(1, 2, 3, 4) },\n      items: [{ label: 'item', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - edit range with textEditText","suites":["converter"],"updatePoint":{"line":113,"column":54},"line":113,"code":"  it('Completion Result - edit range with textEditText', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { editRange: Range.create(1, 2, 3, 4) },\n      items: [{ label: 'item', textEditText: 'text', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    assert.strictEqual(result.items[0].insertText, 'text')\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - insert / replace range","suites":["converter"],"updatePoint":{"line":126,"column":48},"line":126,"code":"  it('Completion Result - insert / replace range', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { editRange: { insert: Range.create(1, 1, 1, 1), replace: Range.create(1, 2, 3, 4) } },\n      items: [{ label: 'item', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    assert.strictEqual(InsertReplaceEdit.is(result.items[0].textEdit), true)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - insert / replace range with textEditText","suites":["converter"],"updatePoint":{"line":139,"column":66},"line":139,"code":"  it('Completion Result - insert / replace range with textEditText', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { editRange: { insert: Range.create(1, 1, 1, 1), replace: Range.create(1, 2, 3, 4) } },\n      items: [{ label: 'item', textEditText: 'text', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    assert.strictEqual(result.items[0].insertText, 'text')\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - commit characters","suites":["converter"],"updatePoint":{"line":152,"column":43},"line":152,"code":"  it('Completion Result - commit characters', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { commitCharacters: ['.', ','] },\n      items: [{ label: 'item', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    const commitCharacters = result.items[0].commitCharacters!\n    assert.strictEqual(commitCharacters?.length, 2)\n    assert.strictEqual(commitCharacters[0], '.')\n    assert.strictEqual(commitCharacters[1], ',')\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - insert text mode","suites":["converter"],"updatePoint":{"line":168,"column":42},"line":168,"code":"  it('Completion Result - insert text mode', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { insertTextMode: InsertTextMode.asIs },\n      items: [{ label: 'item', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    assert.strictEqual(result.items[0].insertTextMode, InsertTextMode.asIs)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion Result - insert text format","suites":["converter"],"updatePoint":{"line":181,"column":44},"line":181,"code":"  it('Completion Result - insert text format', async () => {\n    const completionResult: CompletionList = {\n      isIncomplete: true,\n      itemDefaults: { insertTextFormat: InsertTextFormat.Snippet },\n      items: [{ label: 'item', insertText: '${value}', data: 'data' }]\n    }\n    const result = await cv.asCompletionList(completionResult)\n    assert.strictEqual(result.isIncomplete, completionResult.isIncomplete)\n    assert.strictEqual(result.items.length, 1)\n    assert.strictEqual(result.items[0].label, 'item')\n    assert.strictEqual(result.items[0].insertTextFormat, InsertTextFormat.Snippet)\n  })","file":"client/converter.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Delayer","suites":[],"updatePoint":{"line":6,"column":13},"line":6,"code":"test('Delayer', () => {\n  let count = 0\n  let factory = () => {\n    return Promise.resolve(++count)\n  }\n\n  let delayer = new Delayer(0)\n  let promises: Thenable<any>[] = []\n\n  assert(!delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  promises.push(delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) }))\n  assert(delayer.isTriggered())\n\n  return Promise.all(promises).then(() => {\n    assert(!delayer.isTriggered())\n  }).finally(() => {\n    delayer.dispose()\n  })\n})","file":"client/delayer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Delayer - forceDelivery","suites":[],"updatePoint":{"line":33,"column":29},"line":33,"code":"test('Delayer - forceDelivery', async () => {\n  let count = 0\n  let factory = () => {\n    return Promise.resolve(++count)\n  }\n\n  let delayer = new Delayer(150)\n  delayer.forceDelivery()\n  delayer.trigger(factory).then((result) => { assert.equal(result, 1); assert(!delayer.isTriggered()) })\n  await wait(10)\n  delayer.forceDelivery()\n  expect(count).toBe(1)\n  void delayer.trigger(factory)\n  await wait(10)\n  delayer.cancel()\n  expect(count).toBe(1)\n})","file":"client/delayer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Delayer - last task should be the one getting called","suites":[],"updatePoint":{"line":51,"column":58},"line":51,"code":"test('Delayer - last task should be the one getting called', function() {\n  let factoryFactory = (n: number) => () => {\n    return Promise.resolve(n)\n  }\n\n  let delayer = new Delayer(0)\n  let promises: Thenable<any>[] = []\n\n  assert(!delayer.isTriggered())\n\n  promises.push(delayer.trigger(factoryFactory(1)).then((n) => { assert.equal(n, 3) }))\n  promises.push(delayer.trigger(factoryFactory(2)).then((n) => { assert.equal(n, 3) }))\n  promises.push(delayer.trigger(factoryFactory(3)).then((n) => { assert.equal(n, 3) }))\n\n  const p = Promise.all(promises).then(() => {\n    assert(!delayer.isTriggered())\n  })\n\n  assert(delayer.isTriggered())\n\n  return p\n})","file":"client/delayer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should schedule documents by add","suites":["BackgroundScheduler"],"updatePoint":{"line":28,"column":38},"line":28,"code":"  it('should schedule documents by add', async () => {\n    let uris: string[] = []\n    let s = new BackgroundScheduler({\n      pull(document) {\n        uris.push(document.uri)\n      }\n    })\n    s.add(createDocument(1))\n    s.add(createDocument(1))\n    s.add(createDocument(2))\n    s.add(createDocument(3))\n    await helper.waitValue(() => {\n      return uris.length\n    }, 3)\n    let ids = uris.map(u => getId(u))\n    expect(ids).toEqual([1, 2, 3])\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should schedule documents by remove","suites":["BackgroundScheduler"],"updatePoint":{"line":46,"column":41},"line":46,"code":"  it('should schedule documents by remove', async () => {\n    let uris: string[] = []\n    let s = new BackgroundScheduler({\n      pull(document) {\n        uris.push(document.uri)\n      }\n    })\n    s.add(createDocument(1))\n    s.add(createDocument(2))\n    s.remove(createDocument(2))\n    s.add(createDocument(3))\n    s.remove(createDocument(3))\n    s.remove(createDocument(1))\n    await helper.waitValue(() => {\n      return uris.length\n    }, 3)\n    let ids = uris.map(u => getId(u))\n    expect(ids).toEqual([2, 3, 1])\n    s.dispose()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should track document","suites":["DocumentPullStateTracker"],"updatePoint":{"line":69,"column":27},"line":69,"code":"  it('should track document', async () => {\n    let tracker = new DocumentPullStateTracker()\n    let state = tracker.track(PullState.document, createDocument(1))\n    let other = tracker.track(PullState.document, createDocument(1))\n    expect(state).toBe(other)\n    tracker.track(PullState.workspace, createDocument(3))\n    let id = 'dcf06d3b-79f6-4a5e-bc8d-d3334f7b4cad'\n    tracker.update(PullState.document, createDocument(1, 2), id)\n    tracker.update(PullState.document, createDocument(2, 2), 'f758ae47-c94e-406e-ba41-0f3bb2fe4fc7')\n    let curr = tracker.getResultId(PullState.document, createDocument(1, 2))\n    expect(curr).toBe(id)\n    expect(tracker.getResultId(PullState.workspace, createDocument(1, 2))).toBeUndefined()\n    tracker.unTrack(PullState.document, createDocument(2, 2))\n    expect(tracker.trackingDocuments()).toEqual(['file:///1'])\n    tracker.update(PullState.workspace, createDocument(3, 2), 'fcb905e2-8edb-4239-9150-198c8175ed4a')\n    tracker.update(PullState.workspace, createDocument(1, 2), 'fe96d175-c19f-4705-bff1-101bf83b2953')\n    expect(tracker.tracks(PullState.workspace, createDocument(3, 1))).toBe(true)\n    expect(tracker.tracks(PullState.document, createDocument(4, 1))).toBe(false)\n    let res = tracker.getAllResultIds()\n    expect(res.length).toBe(2)\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should track URI","suites":["DocumentPullStateTracker"],"updatePoint":{"line":91,"column":22},"line":91,"code":"  it('should track URI', async () => {\n    let tracker = new DocumentPullStateTracker()\n    let state = tracker.track(PullState.document, createUri(1), undefined)\n    let other = tracker.track(PullState.document, createUri(1), undefined)\n    expect(state).toBe(other)\n    tracker.track(PullState.workspace, createUri(3), undefined)\n    let id = 'dcf06d3b-79f6-4a5e-bc8d-d3334f7b4cad'\n    tracker.update(PullState.document, createUri(1), undefined, id)\n    tracker.update(PullState.document, createUri(2), undefined, 'f758ae47-c94e-406e-ba41-0f3bb2fe4fc7')\n    let curr = tracker.getResultId(PullState.document, createUri(1))\n    expect(curr).toBe(id)\n    tracker.unTrack(PullState.document, createUri(2))\n    expect(tracker.trackingDocuments()).toEqual(['file:///1'])\n    tracker.update(PullState.workspace, createUri(3), undefined, undefined)\n    tracker.update(PullState.workspace, createUri(1), undefined, 'fe96d175-c19f-4705-bff1-101bf83b2953')\n    expect(tracker.tracks(PullState.workspace, createUri(3))).toBe(true)\n    expect(tracker.tracks(PullState.document, createUri(4))).toBe(false)\n    let res = tracker.getAllResultIds()\n    expect(res.length).toBe(1)\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work when change visible editor","suites":["DiagnosticFeature"],"updatePoint":{"line":153,"column":44},"line":153,"code":"  it('should work when change visible editor', async () => {\n    let doc = await workspace.loadFile(getUri(1), 'edit')\n    await workspace.loadFile(getUri(3), 'tabe')\n    let client = await createServer(true)\n    await helper.wait(30)\n    await workspace.loadFile(getUri(2), 'edit')\n    await helper.wait(30)\n    await workspace.loadFile(getUri(3), 'tabe')\n    await helper.wait(30)\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    expect(feature).toBeDefined()\n    let provider = feature.getProvider(doc.textDocument)\n    let res = provider.knows(PullState.document, doc.textDocument)\n    expect(res).toBe(false)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by document selector","suites":["DiagnosticFeature"],"updatePoint":{"line":170,"column":40},"line":170,"code":"  it('should filter by document selector', async () => {\n    let client = await createServer(true, false, {}, opt => {\n      opt.documentSelector = [{ language: 'vim' }]\n    })\n    let doc = await workspace.loadFile(getUri(1), 'edit')\n    await helper.wait(10)\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let provider = feature.getProvider(TextDocument.create('file:///1', 'vim', 1, ''))\n    let res = provider.knows(PullState.document, doc.textDocument)\n    expect(res).toBe(false)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by ignore","suites":["DiagnosticFeature"],"updatePoint":{"line":183,"column":29},"line":183,"code":"  it('should filter by ignore', async () => {\n    let client = await createServer(true, false, {}, opt => {\n      opt.diagnosticPullOptions = {\n        ignored: ['**/*.ts']\n      }\n    })\n    let doc = await workspace.loadFile(getUri('a.ts'), 'edit')\n    await helper.wait(10)\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let provider = feature.getProvider(doc.textDocument)\n    let res = provider.knows(PullState.document, doc.textDocument)\n    expect(res).toBe(false)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on request error","suites":["DiagnosticFeature"],"updatePoint":{"line":198,"column":39},"line":198,"code":"  it('should not throw on request error', async () => {\n    let client = await createServer(true)\n    await workspace.loadFile(getUri('error'), 'edit')\n    await workspace.loadFile(getUri('cancel'), 'tabe')\n    await workspace.loadFile(getUri('retrigger'), 'tabe')\n    await helper.wait(10)\n    await nvim.command('normal! 2gt')\n    await workspace.loadFile(getUri('unchanged'), 'edit')\n    await helper.wait(20)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pull diagnostic on change","suites":["DiagnosticFeature"],"updatePoint":{"line":210,"column":38},"line":210,"code":"  it('should pull diagnostic on change', async () => {\n    let doc = await workspace.loadFile(getUri('change'), 'edit')\n    let client = await createServer(true, false, {}, opt => {\n      opt.diagnosticPullOptions = {\n        onChange: true,\n        filter: doc => {\n          return doc.uri.endsWith('filtered')\n        }\n      }\n    })\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let provider = feature.getProvider(doc.textDocument)\n    await helper.waitValue(() => {\n      return provider.knows(PullState.document, doc.textDocument)\n    }, true)\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    await helper.wait(30)\n    let changeCount = await client.sendRequest('getChangeCount')\n    expect(changeCount).toBe(2)\n    await nvim.call('setline', [1, 'foo'])\n    let d = await workspace.loadFile(getUri('filtered'), 'tabe')\n    await d.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    await helper.wait(30)\n    await nvim.command(`bd! ${doc.bufnr}`)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pull diagnostic on save","suites":["DiagnosticFeature"],"updatePoint":{"line":237,"column":36},"line":237,"code":"  it('should pull diagnostic on save', async () => {\n    let doc = await workspace.loadFile(getUri(uuid() + 'filtered'), 'edit')\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    doc = await workspace.loadFile(getUri(uuid() + 'save'), 'tabe')\n    let client = await createServer(true, false, {}, opt => {\n      opt.diagnosticPullOptions = {\n        onSave: true,\n        filter: doc => {\n          return doc.uri.endsWith('filtered')\n        }\n      }\n    })\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let provider = feature.getProvider(doc.textDocument)\n    await helper.waitValue(() => {\n      return provider.knows(PullState.document, doc.textDocument)\n    }, true)\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    await nvim.command('wa')\n    await helper.wait(10)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use provideDiagnostics middleware","suites":["DiagnosticFeature"],"updatePoint":{"line":260,"column":46},"line":260,"code":"  it('should use provideDiagnostics middleware', async () => {\n    let called = false\n    let callHandle = false\n    let client = await createServer(true, false, {\n      provideDiagnostics: (doc, id, token, next) => {\n        called = true\n        return next(doc, id, token)\n      },\n      handleDiagnostics: (uri, diagnostics, next) => {\n        callHandle = true\n        return next(uri, diagnostics)\n      }\n    })\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    expect(feature).toBeDefined()\n    let textDocument = TextDocument.create(getUri('empty'), 'e', 1, '')\n    let provider = feature.getProvider(textDocument)\n    let res = await provider.diagnostics.provideDiagnostics(textDocument, '', CancellationToken.None)\n    expect(called).toBe(true)\n    expect(res).toEqual({ kind: 'full', items: [] })\n    await helper.waitValue(() => {\n      return callHandle\n    }, true)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use provideWorkspaceDiagnostics middleware","suites":["DiagnosticFeature"],"updatePoint":{"line":286,"column":55},"line":286,"code":"  it('should use provideWorkspaceDiagnostics middleware', async () => {\n    let called = false\n    let client = await createServer(false, true, {\n      provideWorkspaceDiagnostics: (resultIds, token, resultReporter, next) => {\n        called = true\n        return next(resultIds, token, resultReporter)\n      }\n    })\n    expect(called).toBe(true)\n    await helper.wait(60)\n    let count = await client.sendRequest('getWorkspceCount')\n    expect(count).toBeGreaterThan(1)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should receive partial result","suites":["DiagnosticFeature"],"updatePoint":{"line":301,"column":35},"line":301,"code":"  it('should receive partial result', async () => {\n    let client = await createServer(false, true, {}, opt => {\n      opt.diagnosticPullOptions = {\n        workspace: false\n      }\n    })\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let textDocument = TextDocument.create(getUri('empty'), 'e', 1, '')\n    let provider = feature.getProvider(textDocument)\n    let n = 0\n    await provider.diagnostics.provideWorkspaceDiagnostics([{ uri: 'uri', value: '1' }], CancellationToken.None, chunk => {\n      n++\n    })\n    expect(n).toBe(4)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire refresh event","suites":["DiagnosticFeature"],"updatePoint":{"line":318,"column":31},"line":318,"code":"  it('should fire refresh event', async () => {\n    let client = await createServer(true, false, {})\n    let feature = client.getFeature(DocumentDiagnosticRequest.method)\n    let textDocument = TextDocument.create(getUri('1'), 'e', 1, '')\n    let provider = feature.getProvider(textDocument)\n    let called = false\n    provider.onDidChangeDiagnosticsEmitter.event(() => {\n      called = true\n    })\n    await client.sendNotification('fireRefresh')\n    await helper.waitValue(() => {\n      return called\n    }, true)\n    await client.stop()\n  })","file":"client/diagnostics.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start server","suites":["DynamicFeature","RenameFeature"],"updatePoint":{"line":47,"column":27},"line":47,"code":"    it('should start server', async () => {\n      let client = await startServer({ prepareRename: false })\n      let feature = client.getFeature(RenameRequest.method)\n      let provider = feature.getProvider(textDocument)\n      expect(provider.prepareRename).toBeUndefined()\n      feature.unregister('')\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle different result","suites":["DynamicFeature","RenameFeature"],"updatePoint":{"line":56,"column":38},"line":56,"code":"    it('should handle different result', async () => {\n      let client = await startServer({ prepareRename: true }, {\n        provideRenameEdits: (doc, pos, newName, token, next) => {\n          return next(doc, pos, newName, token)\n        },\n        prepareRename: (doc, pos, token, next) => {\n          return next(doc, pos, token)\n        }\n      })\n      let feature = client.getFeature(RenameRequest.method)\n      let provider = feature.getProvider(textDocument)\n      expect(provider.prepareRename).toBeDefined()\n      let res = await provider.prepareRename(textDocument, position, token)\n      expect(res).toBeNull()\n\n      await client.sendRequest('setPrepareResponse', { defaultBehavior: true })\n      res = await provider.prepareRename(textDocument, position, token)\n      expect(res).toBeNull()\n      await client.sendRequest('setPrepareResponse', { range: Range.create(0, 0, 0, 3), placeholder: 'placeholder' })\n      res = await provider.prepareRename(textDocument, position, token)\n      expect((res as any).placeholder).toBe('placeholder')\n      await expect(async () => {\n        await client.sendRequest('setPrepareResponse', { defaultBehavior: false })\n        res = await provider.prepareRename(textDocument, position, token)\n      }).rejects.toThrow(Error)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use middleware","suites":["DynamicFeature","WorkspaceSymbolFeature"],"updatePoint":{"line":86,"column":29},"line":86,"code":"    it('should use middleware', async () => {\n      let client = await startServer({}, {\n        provideWorkspaceSymbols: (query, token, next) => {\n          return next(query, token)\n        },\n        resolveWorkspaceSymbol: (item, token, next) => {\n          return next(item, token)\n        }\n      })\n      await helper.wait(50)\n      let feature = client.getFeature(WorkspaceSymbolRequest.method)\n      let provider = feature.getProviders().find(o => typeof o.resolveWorkspaceSymbol === 'function')\n      expect(provider).toBeDefined()\n      let token = CancellationToken.None\n      let res = await provider.provideWorkspaceSymbols('', token)\n      expect(res.length).toBe(0)\n      let sym = SymbolInformation.create('name', SymbolKind.Array, Range.create(0, 1, 0, 1), 'file:///1')\n      let resolved = await provider.resolveWorkspaceSymbol(sym, token)\n      expect(resolved.name).toBe(sym.name)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register semanticTokens","suites":["DynamicFeature","SemanticTokensFeature"],"updatePoint":{"line":110,"column":38},"line":110,"code":"    it('should register semanticTokens', async () => {\n      let client = await startServer({})\n      await helper.wait(50)\n      let feature = client.getFeature(SemanticTokensRegistrationType.method)\n      let provider = feature.getProvider(textDocument)\n      expect(provider).toBeDefined()\n      expect(provider.range).toBeUndefined()\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use middleware","suites":["DynamicFeature","SemanticTokensFeature"],"updatePoint":{"line":120,"column":29},"line":120,"code":"    it('should use middleware', async () => {\n      let client = await startServer({ rangeTokens: true, delta: true }, {})\n      await helper.wait(50)\n      let feature = client.getFeature(SemanticTokensRegistrationType.method)\n      let provider = feature.getProvider(textDocument)\n      expect(provider).toBeDefined()\n      expect(provider.range).toBeDefined()\n      let res = await provider.full.provideDocumentSemanticTokensEdits(textDocument, '2', CancellationToken.None)\n      expect(res.resultId).toBe('3')\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use registered command","suites":["DynamicFeature","CodeActionFeature"],"updatePoint":{"line":134,"column":37},"line":134,"code":"    it('should use registered command', async () => {\n      let client = await startServer({})\n      await helper.wait(50)\n      let feature = client.getFeature(CodeActionRequest.method)\n      let provider = feature.getProvider(textDocument)\n      let actions = await provider.provideCodeActions(textDocument, Range.create(0, 1, 0, 1), { diagnostics: [] }, token)\n      expect(actions.length).toBe(1)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pull configuration for configured languageserver","suites":["DynamicFeature","PullConfigurationFeature"],"updatePoint":{"line":146,"column":63},"line":146,"code":"    it('should pull configuration for configured languageserver', async () => {\n      helper.updateConfiguration('languageserver.vim.settings.foo', 'bar')\n      let client = await startServer({})\n      await helper.wait(50)\n      await client.sendNotification('pullConfiguration')\n      await helper.wait(50)\n      let res = await client.sendRequest('getConfiguration')\n      expect(res).toEqual(['bar'])\n      helper.updateConfiguration('suggest.noselect', true)\n      await helper.wait(50)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use codeLens middleware","suites":["DynamicFeature","CodeLensFeature"],"updatePoint":{"line":161,"column":38},"line":161,"code":"    it('should use codeLens middleware', async () => {\n      let fn = jest.fn()\n      let client = await startServer({}, {\n        provideCodeLenses: (doc, token, next) => {\n          fn()\n          return next(doc, token)\n        },\n        resolveCodeLens: (codelens, token, next) => {\n          fn()\n          return next(codelens, token)\n        }\n      })\n      let feature = client.getFeature(CodeLensRequest.method)\n      let provider = feature.getProvider(textDocument).provider\n      expect(provider).toBeDefined()\n      let res = await provider.provideCodeLenses(textDocument, token)\n      expect(res.length).toBe(2)\n      let resolved = await provider.resolveCodeLens(res[0], token)\n      expect(resolved.command).toBeDefined()\n      expect(fn).toBeCalledTimes(2)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire refresh","suites":["DynamicFeature","InlineValueFeature"],"updatePoint":{"line":186,"column":27},"line":186,"code":"    it('should fire refresh', async () => {\n      let client = await startServer({})\n      await helper.wait(50)\n      let feature = client.getFeature(InlineValueRequest.method)\n      expect(feature).toBeDefined()\n      let provider = feature.getProvider(textDocument)\n      let called = false\n      provider.onDidChangeInlineValues.event(() => {\n        called = true\n      })\n      await client.sendNotification('fireInlineValueRefresh')\n      await helper.wait(50)\n      await helper.waitValue(() => {\n        return called\n      }, true)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register command with middleware","suites":["DynamicFeature","ExecuteCommandFeature"],"updatePoint":{"line":206,"column":47},"line":206,"code":"    it('should register command with middleware', async () => {\n      let called = false\n      let client = await startServer({}, {\n        executeCommand: (cmd, args, next) => {\n          called = true\n          return next(cmd, args)\n        }\n      })\n      await helper.wait(50)\n      let feature = client.getFeature(ExecuteCommandRequest.method)\n      expect(feature).toBeDefined()\n      expect(feature.getState().kind).toBe('workspace')\n      let res = await commands.executeCommand('test_command')\n      expect(res).toEqual({ success: true })\n      expect(called).toBe(true)\n      await client.sendNotification('unregister')\n      await helper.wait(30)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register command without middleware","suites":["DynamicFeature","ExecuteCommandFeature"],"updatePoint":{"line":226,"column":50},"line":226,"code":"    it('should register command without middleware', async () => {\n      let client = await startServer({}, {})\n      await helper.wait(50)\n      let res = await commands.executeCommand('test_command')\n      expect(res).toEqual({ success: true })\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide documentSymbols without middleware","suites":["DynamicFeature","DocumentSymbolFeature"],"updatePoint":{"line":236,"column":57},"line":236,"code":"    it('should provide documentSymbols without middleware', async () => {\n      let client = await startServer({}, {})\n      let feature = client.getFeature(DocumentSymbolRequest.method)\n      expect(feature).toBeDefined()\n      expect(feature.getState()).toBeDefined()\n      let provider = feature.getProvider(textDocument)\n      let res = await provider.provideDocumentSymbols(textDocument, token)\n      expect(res).toEqual([])\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide documentSymbols with middleware","suites":["DynamicFeature","DocumentSymbolFeature"],"updatePoint":{"line":247,"column":54},"line":247,"code":"    it('should provide documentSymbols with middleware', async () => {\n      let called = false\n      let client = await startServer({ label: true }, {\n        provideDocumentSymbols: (doc, token, next) => {\n          called = true\n          return next(doc, token)\n        }\n      })\n      let feature = client.getFeature(DocumentSymbolRequest.method)\n      let provider = feature.getProvider(textDocument)\n      expect(provider.meta).toEqual({ label: 'test' })\n      let res = await provider.provideDocumentSymbols(textDocument, token)\n      expect(res).toEqual([])\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use middleware for FileOperationFeature","suites":["DynamicFeature","FileOperationFeature"],"updatePoint":{"line":266,"column":54},"line":266,"code":"    it('should use middleware for FileOperationFeature', async () => {\n      let n = 0\n      let client = await startServer({}, {\n        workspace: {\n          didCreateFiles: (ev, next) => {\n            n++\n            return next(ev)\n          },\n          didRenameFiles: (ev, next) => {\n            n++\n            return next(ev)\n          },\n          didDeleteFiles: (ev, next) => {\n            n++\n            return next(ev)\n          },\n          willRenameFiles: (ev, next) => {\n            n++\n            return next(ev)\n          },\n          willDeleteFiles: (ev, next) => {\n            n++\n            return next(ev)\n          }\n        }\n      })\n      let createFeature = client.getFeature(DidCreateFilesNotification.method)\n      await createFeature.send({ files: [URI.file('/a/b')] })\n      let renameFeature = client.getFeature(DidRenameFilesNotification.method)\n      await renameFeature.send({ files: [{ oldUri: URI.file('/a/b'), newUri: URI.file('/c/d') }] })\n      let deleteFeature = client.getFeature(DidDeleteFilesNotification.method)\n      await deleteFeature.send({ files: [URI.file('/x/y')] })\n      let willRename = client.getFeature(WillRenameFilesRequest.method)\n      await willRename.send({ files: [{ oldUri: URI.file(__dirname), newUri: URI.file(path.join(__dirname, 'x')) }], waitUntil: () => {} })\n      let willDelete = client.getFeature(WillDeleteFilesRequest.method)\n      await willDelete.send({ files: [URI.file('/x/y')], waitUntil: () => {} })\n      await helper.waitValue(() => {\n        return n\n      }, 5)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register multiple completion sources","suites":["DynamicFeature","CompletionItemFeature"],"updatePoint":{"line":310,"column":51},"line":310,"code":"    it('should register multiple completion sources', async () => {\n      let client = await startServer({}, {})\n      let feature = client.getFeature(CompletionRequest.method)\n      await helper.waitValue(() => {\n        return feature.registrationLength\n      }, 2)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register listeners","suites":["DynamicFeature","WorkspaceFoldersFeature"],"updatePoint":{"line":321,"column":33},"line":321,"code":"    it('should register listeners', async () => {\n      let client = await startServer({}, {})\n      let feature = client.getFeature(DidChangeWorkspaceFoldersNotification.method)\n      expect(feature).toBeDefined()\n      let state = feature.getState() as any\n      expect(state.registrations).toBe(true)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle WorkspaceFoldersRequest","suites":["DynamicFeature","WorkspaceFoldersFeature"],"updatePoint":{"line":330,"column":45},"line":330,"code":"    it('should handle WorkspaceFoldersRequest', async () => {\n      let client = await startServer({ changeNotifications: true }, {})\n      let folders = workspace.workspaceFolders\n      expect(folders.length).toBe(0)\n      await client.sendNotification('requestFolders')\n      await helper.wait(30)\n      let res = await client.sendRequest('getFolders')\n      expect(res).toBeNull()\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use workspaceFolders middleware","suites":["DynamicFeature","WorkspaceFoldersFeature"],"updatePoint":{"line":341,"column":46},"line":341,"code":"    it('should use workspaceFolders middleware', async () => {\n      await workspace.loadFile(__filename)\n      let folders = workspace.workspaceFolders\n      expect(folders.length).toBe(1)\n      let called = false\n      let client = await startServer({ changeNotifications: true }, {\n        workspace: {\n          workspaceFolders: (token, next) => {\n            called = true\n            return next(token)\n          }\n        }\n      })\n      await client.sendNotification('requestFolders')\n      await helper.wait(30)\n      let res = await client.sendRequest('getFolders') as WorkspaceFolder[]\n      expect(called).toBe(true)\n      expect(Array.isArray(res)).toBe(true)\n      expect(res.length).toBe(1)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send folders event with middleware","suites":["DynamicFeature","WorkspaceFoldersFeature"],"updatePoint":{"line":363,"column":49},"line":363,"code":"    it('should send folders event with middleware', async () => {\n      let called = false\n      let client = await startServer({ changeNotifications: true }, {\n        workspace: {\n          didChangeWorkspaceFolders: (ev, next) => {\n            called = true\n            return next(ev)\n          }\n        }\n      })\n      let folders = workspace.workspaceFolders\n      expect(folders.length).toBe(0)\n      await workspace.loadFile(__filename)\n      await helper.wait(300)\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/dynamic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"InitializeResult","suites":["Client integration"],"updatePoint":{"line":119,"column":24},"line":119,"code":"  test('InitializeResult', () => {\n    let expected = {\n      capabilities: {\n        textDocumentSync: TextDocumentSyncKind.Full,\n        definitionProvider: true,\n        hoverProvider: true,\n        signatureHelpProvider: {\n          triggerCharacters: [','],\n          retriggerCharacters: [';']\n        },\n        completionProvider: { resolveProvider: true, triggerCharacters: ['\"', ':'] },\n        referencesProvider: true,\n        documentHighlightProvider: true,\n        codeActionProvider: {\n          resolveProvider: true\n        },\n        codeLensProvider: {\n          resolveProvider: true\n        },\n        documentFormattingProvider: true,\n        documentRangeFormattingProvider: true,\n        documentOnTypeFormattingProvider: {\n          firstTriggerCharacter: ':'\n        },\n        renameProvider: {\n          prepareProvider: true\n        },\n        documentLinkProvider: {\n          resolveProvider: true\n        },\n        colorProvider: true,\n        declarationProvider: true,\n        foldingRangeProvider: true,\n        implementationProvider: {\n          documentSelector: [{ language: '*' }]\n        },\n        selectionRangeProvider: true,\n        inlineValueProvider: {},\n        inlayHintProvider: {\n          resolveProvider: true\n        },\n        typeDefinitionProvider: {\n          id: '82671a9a-2a69-4e9f-a8d7-e1034eaa0d2e',\n          documentSelector: [{ language: '*' }]\n        },\n        callHierarchyProvider: true,\n        semanticTokensProvider: {\n          legend: {\n            tokenTypes: [],\n            tokenModifiers: []\n          },\n          range: true,\n          full: {\n            delta: true\n          }\n        },\n        workspace: {\n          fileOperations: {\n            didCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },\n            didRename: {\n              filters: [\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }\n              ]\n            },\n            didDelete: { filters: [{ scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },\n            willCreate: { filters: [{ scheme: 'file', pattern: { glob: '**/created-static/**{/,/*.txt}' } }] },\n            willRename: {\n              filters: [\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/', matches: 'folder' } },\n                { scheme: 'file', pattern: { glob: '**/renamed-static/**/*.txt', matches: 'file' } }\n              ]\n            },\n            willDelete: { filters: [{ scheme: 'file', pattern: { glob: '**/deleted-static/**{/,/*.txt}' } }] },\n          },\n        },\n        linkedEditingRangeProvider: true,\n        diagnosticProvider: {\n          identifier: 'da348dc5-c30a-4515-9d98-31ff3be38d14',\n          interFileDependencies: true,\n          workspaceDiagnostics: true\n        },\n        typeHierarchyProvider: true,\n        workspaceSymbolProvider: {\n          resolveProvider: true\n        },\n        notebookDocumentSync: {\n          notebookSelector: [{\n            notebook: { notebookType: 'jupyter-notebook' },\n            cells: [{ language: 'python' }]\n          }]\n        }\n      },\n      customResults: {\n        hello: 'world'\n      }\n    }\n    assert.deepEqual(client.initializeResult, expected)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"feature.getState()","suites":["Client integration"],"updatePoint":{"line":219,"column":26},"line":219,"code":"  test('feature.getState()', async () => {\n    const testFeature = (method: string, kind: string): void => {\n      let feature = client.getFeature(method as any)\n      assert.notStrictEqual(feature, undefined)\n      let res = feature.getState()\n      assert.strictEqual(res.kind, kind)\n    }\n    const testStaticFeature = (method: string, kind: string): void => {\n      let feature = client.getStaticFeature(method as any)\n      assert.notStrictEqual(feature, undefined)\n      let res = feature.getState()\n      assert.strictEqual(res.kind, kind)\n    }\n    testStaticFeature(ConfigurationRequest.method, 'static')\n    testStaticFeature(WorkDoneProgressCreateRequest.method, 'window')\n    testFeature(DidChangeWatchedFilesNotification.method, 'workspace')\n    testFeature(DidChangeConfigurationNotification.method, 'workspace')\n    testFeature(DidOpenTextDocumentNotification.method, 'document')\n    testFeature(DidChangeTextDocumentNotification.method, 'document')\n    testFeature(WillSaveTextDocumentNotification.method, 'document')\n    testFeature(WillSaveTextDocumentWaitUntilRequest.method, 'document')\n    testFeature(DidSaveTextDocumentNotification.method, 'document')\n    testFeature(DidCloseTextDocumentNotification.method, 'document')\n    testFeature(DidCreateFilesNotification.method, 'workspace')\n    testFeature(DidRenameFilesNotification.method, 'workspace')\n    testFeature(DidDeleteFilesNotification.method, 'workspace')\n    testFeature(WillCreateFilesRequest.method, 'workspace')\n    testFeature(WillRenameFilesRequest.method, 'workspace')\n    testFeature(WillDeleteFilesRequest.method, 'workspace')\n    testFeature(CompletionRequest.method, 'document')\n    testFeature(HoverRequest.method, 'document')\n    testFeature(SignatureHelpRequest.method, 'document')\n    testFeature(DefinitionRequest.method, 'document')\n    testFeature(ReferencesRequest.method, 'document')\n    testFeature(DocumentHighlightRequest.method, 'document')\n    testFeature(CodeActionRequest.method, 'document')\n    testFeature(CodeLensRequest.method, 'document')\n    testFeature(DocumentFormattingRequest.method, 'document')\n    testFeature(DocumentRangeFormattingRequest.method, 'document')\n    testFeature(DocumentOnTypeFormattingRequest.method, 'document')\n    testFeature(RenameRequest.method, 'document')\n    testFeature(DocumentSymbolRequest.method, 'document')\n    testFeature(DocumentLinkRequest.method, 'document')\n    testFeature(DocumentColorRequest.method, 'document')\n    testFeature(DeclarationRequest.method, 'document')\n    testFeature(FoldingRangeRequest.method, 'document')\n    testFeature(ImplementationRequest.method, 'document')\n    testFeature(SelectionRangeRequest.method, 'document')\n    testFeature(TypeDefinitionRequest.method, 'document')\n    testFeature(CallHierarchyPrepareRequest.method, 'document')\n    testFeature(SemanticTokensRegistrationType.method, 'document')\n    testFeature(LinkedEditingRangeRequest.method, 'document')\n    testFeature(TypeHierarchyPrepareRequest.method, 'document')\n    testFeature(InlineValueRequest.method, 'document')\n    testFeature(InlayHintRequest.method, 'document')\n    testFeature(WorkspaceSymbolRequest.method, 'workspace')\n    testFeature(DocumentDiagnosticRequest.method, 'document')\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Definition","suites":["Client integration"],"updatePoint":{"line":278,"column":23},"line":278,"code":"  test('Goto Definition', async () => {\n    const provider = client.getFeature(DefinitionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideDefinition(document, position, tokenSource.token)) as Location\n    assert.strictEqual(Location.is(result), true)\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 0, 0, 0, 1)\n    let middlewareCalled = false\n    middleware.provideDefinition = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideDefinition(document, position, tokenSource.token)\n    middleware.provideDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Hover","suites":["Client integration"],"updatePoint":{"line":295,"column":13},"line":295,"code":"  test('Hover', async () => {\n    const provider = client.getFeature(HoverRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideHover(document, position, tokenSource.token)\n    assert.ok(Hover.is(result))\n    assert.strictEqual((result.contents as any).kind, 'plaintext')\n    assert.strictEqual((result.contents as any).value, 'foo')\n    let middlewareCalled = false\n    middleware.provideHover = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideHover(document, position, tokenSource.token)\n    middleware.provideHover = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Completion","suites":["Client integration"],"updatePoint":{"line":312,"column":18},"line":312,"code":"  test('Completion', async () => {\n    const provider = client.getFeature(CompletionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: CompletionTriggerKind.Invoked, triggerCharacter: ':' })) as CompletionItem[]\n\n    isArray(result, CompletionItem)\n    const item = result[0]\n    assert.strictEqual(item.label, 'item')\n    assert.strictEqual(item.insertText, 'text')\n    assert.strictEqual(item.detail, undefined)\n    isDefined(provider.resolveCompletionItem)\n\n    const resolved = await provider.resolveCompletionItem(item, tokenSource.token)\n    isDefined(resolved)\n    assert.strictEqual(resolved.detail, 'detail')\n\n    let middlewareCalled = 0\n    middleware.provideCompletionItem = (document, position, context, token, next) => {\n      middlewareCalled++\n      return next(document, position, context, token)\n    }\n    middleware.resolveCompletionItem = (item, token, next) => {\n      middlewareCalled++\n      return next(item, token)\n    }\n    await provider.provideCompletionItems(document, position, tokenSource.token, { triggerKind: CompletionTriggerKind.Invoked, triggerCharacter: ':' })\n    await provider.resolveCompletionItem(item, tokenSource.token)\n    middleware.provideCompletionItem = undefined\n    middleware.resolveCompletionItem = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"SignatureHelpRequest","suites":["Client integration"],"updatePoint":{"line":344,"column":28},"line":344,"code":"  test('SignatureHelpRequest', async () => {\n    await helper.wait(50)\n    let provider = client.getFeature(SignatureHelpRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideSignatureHelp(document, position, tokenSource.token,\n      {\n        isRetrigger: false,\n        triggerKind: SignatureHelpTriggerKind.Invoked,\n        triggerCharacter: ':'\n      }\n    )\n\n    assert.strictEqual(result.activeSignature, 1)\n    assert.strictEqual(result.activeParameter, 1)\n    isArray(result.signatures, SignatureInformation)\n\n    const signature = result.signatures[0]\n    assert.strictEqual(signature.label, 'label')\n    assert.strictEqual(signature.documentation, 'doc')\n    isArray(signature.parameters, ParameterInformation)\n\n    const parameter = signature.parameters[0]\n    assert.strictEqual(parameter.label, 'label')\n    assert.strictEqual(parameter.documentation, 'doc')\n\n    let middlewareCalled = false\n    middleware.provideSignatureHelp = (d, p, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, c, t)\n    }\n    await provider.provideSignatureHelp(document, position, tokenSource.token,\n      {\n        isRetrigger: false,\n        triggerKind: SignatureHelpTriggerKind.Invoked,\n        triggerCharacter: ':'\n      }\n    )\n    middleware.provideSignatureHelp = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"References","suites":["Client integration"],"updatePoint":{"line":385,"column":18},"line":385,"code":"  test('References', async () => {\n    const provider = client.getFeature(ReferencesRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideReferences(document, position, {\n      includeDeclaration: true\n    }, tokenSource.token)\n\n    isArray(result, Location, 2)\n    for (let i = 0; i < result.length; i++) {\n      const location = result[i]\n      rangeEqual(location.range, i, i, i, i)\n      assert.strictEqual(location.uri.toString(), document.uri.toString())\n    }\n\n    let middlewareCalled = false\n    middleware.provideReferences = (d, p, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, c, t)\n    }\n    await provider.provideReferences(document, position, {\n      includeDeclaration: true\n    }, tokenSource.token)\n    middleware.provideReferences = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Highlight","suites":["Client integration"],"updatePoint":{"line":411,"column":26},"line":411,"code":"  test('Document Highlight', async () => {\n    const provider = client.getFeature(DocumentHighlightRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentHighlights(document, position, tokenSource.token)\n\n    isArray(result, DocumentHighlight, 1)\n\n    const highlight = result[0]\n    assert.strictEqual(highlight.kind, DocumentHighlightKind.Read)\n    rangeEqual(highlight.range, 2, 2, 2, 2)\n\n    let middlewareCalled = false\n    middleware.provideDocumentHighlights = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.provideDocumentHighlights(document, position, tokenSource.token)\n    middleware.provideDocumentHighlights = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Code Actions","suites":["Client integration"],"updatePoint":{"line":432,"column":20},"line":432,"code":"  test('Code Actions', async () => {\n    const provider = client.getFeature(CodeActionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideCodeActions(document, range, {\n      diagnostics: []\n    }, tokenSource.token)) as CodeAction[]\n\n    isArray(result, CodeAction)\n    const action = result[0]\n    assert.strictEqual(action.title, 'title')\n    assert.strictEqual(action.command?.title, 'title')\n    assert.strictEqual(action.command?.command, 'test_command')\n    let response = await commands.execute(action.command)\n    expect(response).toEqual({ success: true })\n\n    const resolved = (await provider.resolveCodeAction(result[0], tokenSource.token))\n    assert.strictEqual(resolved?.title, 'resolved')\n\n    let middlewareCalled = false\n    middleware.provideCodeActions = (d, r, c, t, n) => {\n      middlewareCalled = true\n      return n(d, r, c, t)\n    }\n\n    await provider.provideCodeActions(document, range, { diagnostics: [] }, tokenSource.token)\n    middleware.provideCodeActions = undefined\n    assert.ok(middlewareCalled)\n\n    middlewareCalled = false\n    middleware.resolveCodeAction = (c, t, n) => {\n      middlewareCalled = true\n      return n(c, t)\n    }\n\n    await provider.resolveCodeAction!(result[0], tokenSource.token)\n    middleware.resolveCodeAction = undefined\n    assert.ok(middlewareCalled)\n\n    let uri = URI.parse('lsptests://localhost/empty.bat').toString()\n    let textDocument = TextDocument.create(uri, 'bat', 1, '\\n')\n    let res = (await provider.provideCodeActions(textDocument, range, {\n      diagnostics: []\n    }, tokenSource.token)) as CodeAction[]\n    expect(res).toBeUndefined()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"CodeLens","suites":["Client integration"],"updatePoint":{"line":478,"column":16},"line":478,"code":"  test('CodeLens', async () => {\n    let feature = client.getFeature(CodeLensRequest.method)\n    let state = feature.getState()\n    expect((state as any).registrations).toBe(true)\n    expect((state as any).matches).toBe(true)\n    let tokenSource = new CancellationTokenSource()\n    let codeLens = await languages.getCodeLens(document, tokenSource.token)\n    expect(codeLens.length).toBe(2)\n    let resolved = await languages.resolveCodeLens(codeLens[0], tokenSource.token)\n    expect(resolved.command).toBeDefined()\n    let fireRefresh = false\n    let provider = feature.getProvider(document)\n    provider.onDidChangeCodeLensEmitter.event(() => {\n      fireRefresh = true\n    })\n    await client.sendNotification('fireCodeLensRefresh')\n    await helper.wait(50)\n    expect(fireRefresh).toBe(true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Progress","suites":["Client integration"],"updatePoint":{"line":498,"column":16},"line":498,"code":"  test('Progress', async () => {\n    const progressToken = 'TEST-PROGRESS-TOKEN'\n    const middlewareEvents: Array<WorkDoneProgressBegin | WorkDoneProgressReport | WorkDoneProgressEnd> = []\n    let currentProgressResolver: (value: unknown) => void | undefined\n\n    // Set up middleware that calls the current resolve function when it gets its 'end' progress event.\n    middleware.handleWorkDoneProgress = (token: ProgressToken, params, next) => {\n      if (token === progressToken) {\n        middlewareEvents.push(params)\n        if (params.kind === 'end') {\n          setImmediate(currentProgressResolver)\n        }\n      }\n      return next(token, params)\n    }\n\n    // Trigger multiple sample progress events.\n    for (let i = 0; i < 2; i++) {\n      await new Promise<unknown>((resolve, reject) => {\n        currentProgressResolver = resolve\n        void client.sendRequest(\n          new ProtocolRequestType<any, null, never, any, any>('testing/sendSampleProgress'),\n          {},\n          tokenSource.token,\n        ).catch(reject)\n      })\n    }\n\n    middleware.handleWorkDoneProgress = undefined\n\n    // Ensure all events were handled.\n    assert.deepStrictEqual(\n      middlewareEvents.map(p => p.kind),\n      ['begin', 'report', 'end', 'begin', 'report', 'end'],\n    )\n    await client.sendRequest(\n      new ProtocolRequestType<any, null, never, any, any>('testing/beginOnlyProgress'),\n      {},\n      tokenSource.token,\n    )\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Formatting","suites":["Client integration"],"updatePoint":{"line":540,"column":27},"line":540,"code":"  test('Document Formatting', async () => {\n    const provider = client.getFeature(DocumentFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, 'insert')\n    rangeEqual(edit.range, 0, 0, 0, 0)\n\n    let middlewareCalled = true\n    middleware.provideDocumentFormattingEdits = (d, c, t, n) => {\n      middlewareCalled = true\n      return n(d, c, t)\n    }\n    await provider.provideDocumentFormattingEdits(document, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Range Formatting","suites":["Client integration"],"updatePoint":{"line":560,"column":33},"line":560,"code":"  test('Document Range Formatting', async () => {\n    const provider = client.getFeature(DocumentRangeFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, '')\n    rangeEqual(edit.range, 1, 1, 1, 2)\n\n    let middlewareCalled = true\n    middleware.provideDocumentRangeFormattingEdits = (d, r, c, t, n) => {\n      middlewareCalled = true\n      return n(d, r, c, t)\n    }\n    await provider.provideDocumentRangeFormattingEdits(document, range, { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document on Type Formatting","suites":["Client integration"],"updatePoint":{"line":580,"column":35},"line":580,"code":"  test('Document on Type Formatting', async () => {\n    const provider = client.getFeature(DocumentOnTypeFormattingRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token)\n\n    isArray(result, TextEdit)\n    const edit = result[0]\n    assert.strictEqual(edit.newText, 'replace')\n    rangeEqual(edit.range, 2, 2, 2, 3)\n\n    let middlewareCalled = true\n    middleware.provideOnTypeFormattingEdits = (d, p, s, c, t, n) => {\n      middlewareCalled = true\n      return n(d, p, s, c, t)\n    }\n    await provider.provideOnTypeFormattingEdits(document, position, 'a', { tabSize: 4, insertSpaces: false }, tokenSource.token)\n    middleware.provideDocumentFormattingEdits = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Rename","suites":["Client integration"],"updatePoint":{"line":600,"column":14},"line":600,"code":"  test('Rename', async () => {\n    const provider = client.getFeature(RenameRequest.method).getProvider(document)\n    isDefined(provider)\n    isDefined(provider.prepareRename)\n    const prepareResult = await provider.prepareRename(document, position, tokenSource.token) as Range\n\n    rangeEqual(prepareResult, 1, 1, 1, 2)\n    const renameResult = await provider.provideRenameEdits(document, position, 'newName', tokenSource.token)\n    assert.ok(WorkspaceEdit.is(renameResult))\n    let middlewareCalled = 0\n    middleware.prepareRename = (d, p, t, n) => {\n      middlewareCalled++\n      return n(d, p, t)\n    }\n    await provider.prepareRename(document, position, tokenSource.token)\n    middleware.prepareRename = undefined\n    middleware.provideRenameEdits = (d, p, w, t, n) => {\n      middlewareCalled++\n      return n(d, p, w, t)\n    }\n    await provider.provideRenameEdits(document, position, 'newName', tokenSource.token)\n    middleware.provideRenameEdits = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Link","suites":["Client integration"],"updatePoint":{"line":625,"column":21},"line":625,"code":"  test('Document Link', async () => {\n    const provider = client.getFeature(DocumentLinkRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideDocumentLinks(document, tokenSource.token)\n\n    isArray(result, DocumentLink)\n    const documentLink = result[0]\n    rangeEqual(documentLink.range, 1, 1, 1, 2)\n\n    let middlewareCalled = 0\n    middleware.provideDocumentLinks = (d, t, n) => {\n      middlewareCalled++\n      return n(d, t)\n    }\n    await provider.provideDocumentLinks(document, tokenSource.token)\n    middleware.provideDocumentLinks = undefined\n\n    isDefined(provider.resolveDocumentLink)\n    const resolved = await provider.resolveDocumentLink(documentLink, tokenSource.token)\n    isDefined(resolved.target)\n    assert.strictEqual(resolved.target.toString(), URI.file('/target.txt').toString())\n\n    middleware.resolveDocumentLink = (i, t, n) => {\n      middlewareCalled++\n      return n(i, t)\n    }\n    await provider.resolveDocumentLink(documentLink, tokenSource.token)\n    middleware.resolveDocumentLink = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document Color","suites":["Client integration"],"updatePoint":{"line":656,"column":22},"line":656,"code":"  test('Document Color', async () => {\n    const provider = client.getFeature(DocumentColorRequest.method).getProvider(document)\n    isDefined(provider)\n    const colors = await provider.provideDocumentColors(document, tokenSource.token)\n\n    isArray(colors, ColorInformation)\n    const color = colors[0]\n\n    rangeEqual(color.range, 1, 1, 1, 2)\n    colorEqual(color.color, 1, 1, 1, 1)\n\n    let middlewareCalled = 0\n    middleware.provideDocumentColors = (d, t, n) => {\n      middlewareCalled++\n      return n(d, t)\n    }\n    await provider.provideDocumentColors(document, tokenSource.token)\n    middleware.provideDocumentColors = undefined\n\n    const presentations = await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token)\n\n    isArray(presentations, ColorPresentation)\n    const presentation = presentations[0]\n    assert.strictEqual(presentation.label, 'label')\n\n    middleware.provideColorPresentations = (c, x, t, n) => {\n      middlewareCalled++\n      return n(c, x, t)\n    }\n    await provider.provideColorPresentations(color.color, { document, range }, tokenSource.token)\n    middleware.provideColorPresentations = undefined\n    assert.strictEqual(middlewareCalled, 2)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Declaration","suites":["Client integration"],"updatePoint":{"line":690,"column":24},"line":690,"code":"  test('Goto Declaration', async () => {\n    const provider = client.getFeature(DeclarationRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideDeclaration(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 1, 1, 1, 2)\n\n    let middlewareCalled = false\n    middleware.provideDeclaration = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideDeclaration(document, position, tokenSource.token)\n    middleware.provideDeclaration = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Folding Ranges","suites":["Client integration"],"updatePoint":{"line":708,"column":22},"line":708,"code":"  test('Folding Ranges', async () => {\n    const provider = client.getFeature(FoldingRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideFoldingRanges(document, {}, tokenSource.token))\n\n    isArray(result, FoldingRange, 1)\n    const range = result[0]\n    assert.strictEqual(range.startLine, 1)\n    assert.strictEqual(range.endLine, 2)\n    let middlewareCalled = true\n    middleware.provideFoldingRanges = (d, c, t, n) => {\n      middlewareCalled = true\n      return n(d, c, t)\n    }\n    await provider.provideFoldingRanges(document, {}, tokenSource.token)\n    middleware.provideFoldingRanges = undefined\n    assert.ok(middlewareCalled)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Goto Implementation","suites":["Client integration"],"updatePoint":{"line":727,"column":27},"line":727,"code":"  test('Goto Implementation', async () => {\n    const provider = client.getFeature(ImplementationRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideImplementation(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 2, 2, 3, 3)\n\n    let middlewareCalled = false\n    middleware.provideImplementation = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideImplementation(document, position, tokenSource.token)\n    middleware.provideImplementation = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Selection Range","suites":["Client integration"],"updatePoint":{"line":745,"column":23},"line":745,"code":"  test('Selection Range', async () => {\n    const provider = client.getFeature(SelectionRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideSelectionRanges(document, [position], tokenSource.token))\n\n    isArray(result, SelectionRange, 1)\n    const range = result[0]\n    rangeEqual(range.range, 1, 2, 3, 4)\n    let middlewareCalled = false\n    middleware.provideSelectionRanges = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.provideSelectionRanges(document, [position], tokenSource.token)\n    middleware.provideSelectionRanges = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Type Definition","suites":["Client integration"],"updatePoint":{"line":763,"column":23},"line":763,"code":"  test('Type Definition', async () => {\n    const provider = client.getFeature(TypeDefinitionRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.provideTypeDefinition(document, position, tokenSource.token)) as Location\n\n    uriEqual(result.uri, uri)\n    rangeEqual(result.range, 2, 2, 3, 3)\n\n    let middlewareCalled = false\n    middleware.provideTypeDefinition = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideTypeDefinition(document, position, tokenSource.token)\n    middleware.provideTypeDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Call Hierarchy","suites":["Client integration"],"updatePoint":{"line":781,"column":22},"line":781,"code":"  test('Call Hierarchy', async () => {\n    const provider = client.getFeature(CallHierarchyPrepareRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = (await provider.prepareCallHierarchy(document, position, tokenSource.token)) as CallHierarchyItem[]\n    expect(result.length).toBe(1)\n\n    let middlewareCalled = false\n    middleware.prepareCallHierarchy = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.prepareCallHierarchy(document, position, tokenSource.token)\n    middleware.prepareCallHierarchy = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const item = result[0]\n    const incoming = (await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token)) as CallHierarchyIncomingCall[]\n    expect(incoming.length).toBe(1)\n    assert.deepEqual(incoming[0].from, item)\n    middlewareCalled = false\n    middleware.provideCallHierarchyIncomingCalls = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideCallHierarchyIncomingCalls(item, tokenSource.token)\n    middleware.provideCallHierarchyIncomingCalls = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const outgoing = (await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token)) as CallHierarchyOutgoingCall[]\n    expect(outgoing.length).toBe(1)\n    assert.deepEqual(outgoing[0].to, item)\n    middlewareCalled = false\n    middleware.provideCallHierarchyOutgoingCalls = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideCallHierarchyOutgoingCalls(item, tokenSource.token)\n    middleware.provideCallHierarchyOutgoingCalls = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Create Files","suites":["Client integration"],"updatePoint":{"line":887,"column":43},"line":887,"code":"  test('File Operations - Will Create Files', async () => {\n    const feature = client.getFeature(WillCreateFilesRequest.method)\n    isDefined(feature)\n\n    const sendCreateRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ token: CancellationToken.None, files: createFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendCreateRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL CREATE',\n      [\n        'file:///my/created-static/file.txt',\n        'file:///my/created-static/folder/',\n        'file:///my/created-dynamic/file.js',\n        'file:///my/created-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willCreateFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendCreateRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL CREATE',\n      [\n        'file:///my/created-static/file.txt',\n        'file:///my/created-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willCreateFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Create Files","suites":["Client integration"],"updatePoint":{"line":932,"column":42},"line":932,"code":"  test('File Operations - Did Create Files', async () => {\n    const feature = client.getFeature(DidCreateFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: createFiles })\n    await ensureNotificationReceived(\n      'create',\n      {\n        files: [\n          { uri: 'file:///my/created-static/file.txt' },\n          { uri: 'file:///my/created-static/folder/' },\n          { uri: 'file:///my/created-dynamic/file.js' },\n          { uri: 'file:///my/created-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didCreateFiles = (event, next) => next({\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: createFiles })\n    await ensureNotificationReceived(\n      'create',\n      {\n        files: [\n          { uri: 'file:///my/created-static/file.txt' },\n          { uri: 'file:///my/created-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didCreateFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Rename Files","suites":["Client integration"],"updatePoint":{"line":971,"column":43},"line":971,"code":"  test('File Operations - Will Rename Files', async () => {\n    const feature = client.getFeature(WillRenameFilesRequest.method)\n    isDefined(feature)\n\n    const sendRenameRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ files: renameFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendRenameRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL RENAME',\n      [\n        'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',\n        'file:///my/renamed-static/folder/ -> file:///my-new/renamed-static/folder/',\n        'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',\n        'file:///my/renamed-dynamic/folder/ -> file:///my-new/renamed-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willRenameFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.oldUri.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendRenameRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL RENAME',\n      [\n        'file:///my/renamed-static/file.txt -> file:///my-new/renamed-static/file.txt',\n        'file:///my/renamed-dynamic/file.js -> file:///my-new/renamed-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willRenameFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Rename Files","suites":["Client integration"],"updatePoint":{"line":1016,"column":42},"line":1016,"code":"  test('File Operations - Did Rename Files', async () => {\n    const feature = client.getFeature(DidRenameFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: renameFiles })\n    await ensureNotificationReceived(\n      'rename',\n      {\n        files: [\n          { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },\n          { oldUri: 'file:///my/renamed-static/folder/', newUri: 'file:///my-new/renamed-static/folder/' },\n          { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },\n          { oldUri: 'file:///my/renamed-dynamic/folder/', newUri: 'file:///my-new/renamed-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didRenameFiles = (event, next) => next({\n      files: event.files.filter(f => !f.oldUri.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: renameFiles })\n    await ensureNotificationReceived(\n      'rename',\n      {\n        files: [\n          { oldUri: 'file:///my/renamed-static/file.txt', newUri: 'file:///my-new/renamed-static/file.txt' },\n          { oldUri: 'file:///my/renamed-dynamic/file.js', newUri: 'file:///my-new/renamed-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didRenameFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Will Delete Files","suites":["Client integration"],"updatePoint":{"line":1055,"column":43},"line":1055,"code":"  test('File Operations - Will Delete Files', async () => {\n    const feature = client.getFeature(WillDeleteFilesRequest.method)\n    isDefined(feature)\n\n    const sendDeleteRequest = () => new Promise<WorkspaceEdit>(async (resolve, reject) => {\n      void feature.send({ files: deleteFiles, waitUntil: resolve })\n      // If feature.send didn't call waitUntil synchronously then something went wrong.\n      reject(new Error('Feature unexpectedly did not call waitUntil synchronously'))\n    })\n\n    // Send the event and ensure the server responds with an edit referencing the\n    // correct files.\n    let edits = await sendDeleteRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL DELETE',\n      [\n        'file:///my/deleted-static/file.txt',\n        'file:///my/deleted-static/folder/',\n        'file:///my/deleted-dynamic/file.js',\n        'file:///my/deleted-dynamic/folder/',\n      ],\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.willDeleteFiles = (event, next) => next({\n      ...event,\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    edits = await sendDeleteRequest()\n    ensureReferenceEdit(\n      edits,\n      'WILL DELETE',\n      [\n        'file:///my/deleted-static/file.txt',\n        'file:///my/deleted-dynamic/file.js',\n      ],\n    )\n\n    middleware.workspace.willDeleteFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"File Operations - Did Delete Files","suites":["Client integration"],"updatePoint":{"line":1100,"column":42},"line":1100,"code":"  test('File Operations - Did Delete Files', async () => {\n    const feature = client.getFeature(DidDeleteFilesNotification.method)\n    isDefined(feature)\n\n    // Send the event and ensure the server reports the notification was sent.\n    await feature.send({ files: deleteFiles })\n    await ensureNotificationReceived(\n      'delete',\n      {\n        files: [\n          { uri: 'file:///my/deleted-static/file.txt' },\n          { uri: 'file:///my/deleted-static/folder/' },\n          { uri: 'file:///my/deleted-dynamic/file.js' },\n          { uri: 'file:///my/deleted-dynamic/folder/' },\n        ],\n      },\n    )\n\n    // Add middleware that strips out any folders.\n    middleware.workspace = middleware.workspace || {}\n    middleware.workspace.didDeleteFiles = (event, next) => next({\n      files: event.files.filter(f => !f.path.endsWith('/')),\n    })\n\n    // Ensure we get the same results minus the folders that the middleware removed.\n    await feature.send({ files: deleteFiles })\n    await ensureNotificationReceived(\n      'delete',\n      {\n        files: [\n          { uri: 'file:///my/deleted-static/file.txt' },\n          { uri: 'file:///my/deleted-dynamic/file.js' },\n        ],\n      },\n    )\n\n    middleware.workspace.didDeleteFiles = undefined\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Semantic Tokens","suites":["Client integration"],"updatePoint":{"line":1139,"column":23},"line":1139,"code":"  test('Semantic Tokens', async () => {\n    const provider = client.getFeature(SemanticTokensRegistrationType.method).getProvider(document)\n    const rangeProvider = provider?.range\n    isDefined(rangeProvider)\n    const rangeResult = await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token)\n    assert.ok(rangeResult !== undefined)\n\n    let middlewareCalled = false\n    middleware.provideDocumentRangeSemanticTokens = (d, r, t, n) => {\n      middlewareCalled = true\n      return n(d, r, t)\n    }\n    await rangeProvider.provideDocumentRangeSemanticTokens(document, range, tokenSource.token)\n    middleware.provideDocumentRangeSemanticTokens = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const fullProvider = provider?.full\n    isDefined(fullProvider)\n    const fullResult = await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token)\n    assert.ok(fullResult !== undefined)\n\n    middlewareCalled = false\n    middleware.provideDocumentSemanticTokens = (d, t, n) => {\n      middlewareCalled = true\n      return n(d, t)\n    }\n    await fullProvider.provideDocumentSemanticTokens(document, tokenSource.token)\n    middleware.provideDocumentSemanticTokens = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    middlewareCalled = false\n    middleware.provideDocumentSemanticTokensEdits = (d, i, t, n) => {\n      middlewareCalled = true\n      return n(d, i, t)\n    }\n    await fullProvider.provideDocumentSemanticTokensEdits!(document, '2', tokenSource.token)\n    middleware.provideDocumentSemanticTokensEdits = undefined\n    assert.strictEqual(middlewareCalled, true)\n    let called = false\n    provider.onDidChangeSemanticTokensEmitter.event(() => {\n      called = true\n    })\n    await client.sendNotification('fireSemanticTokensRefresh')\n    await helper.waitValue(() => {\n      return called\n    }, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Linked Editing Ranges","suites":["Client integration"],"updatePoint":{"line":1187,"column":29},"line":1187,"code":"  test('Linked Editing Ranges', async () => {\n    const provider = client.getFeature(LinkedEditingRangeRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.provideLinkedEditingRanges(document, position, tokenSource.token)\n\n    isArray(result.ranges, Range, 1)\n    rangeEqual(result.ranges[0], 1, 1, 1, 1)\n\n    let middlewareCalled = false\n    middleware.provideLinkedEditingRange = (document, position, token, next) => {\n      middlewareCalled = true\n      return next(document, position, token)\n    }\n    await provider.provideLinkedEditingRanges(document, position, tokenSource.token)\n    middleware.provideTypeDefinition = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Document diagnostic pull","suites":["Client integration"],"updatePoint":{"line":1205,"column":32},"line":1205,"code":"  test('Document diagnostic pull', async () => {\n    const provider = client.getFeature(DocumentDiagnosticRequest.method)?.getProvider(document)\n    isDefined(provider)\n    const result = await provider.diagnostics.provideDiagnostics(document, undefined, tokenSource.token)\n    isDefined(result)\n    isFullDocumentDiagnosticReport(result)\n\n    const diag = result.items[0]\n    rangeEqual(diag.range, 1, 1, 1, 1)\n    assert.strictEqual(diag.message, 'diagnostic')\n\n    let middlewareCalled = false\n    middleware.provideDiagnostics = (document, previousResultId, token, next) => {\n      middlewareCalled = true\n      return next(document, previousResultId, token)\n    }\n    await provider.diagnostics.provideDiagnostics(document, undefined, tokenSource.token)\n    middleware.provideDiagnostics = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Workspace diagnostic pull","suites":["Client integration"],"updatePoint":{"line":1226,"column":33},"line":1226,"code":"  test('Workspace diagnostic pull', async () => {\n    const provider = client.getFeature(DocumentDiagnosticRequest.method)?.getProvider(document)\n    isDefined(provider)\n    isDefined(provider.diagnostics.provideWorkspaceDiagnostics)\n    await provider.diagnostics.provideWorkspaceDiagnostics([], tokenSource.token, result => {\n      isDefined(result)\n      isArray(result.items, undefined, 1)\n    })\n\n    let middlewareCalled = false\n    middleware.provideWorkspaceDiagnostics = (resultIds, token, reporter, next) => {\n      middlewareCalled = true\n      return next(resultIds, token, reporter)\n    }\n    await provider.diagnostics.provideWorkspaceDiagnostics([], tokenSource.token, () => {})\n    middleware.provideWorkspaceDiagnostics = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Type Hierarchy","suites":["Client integration"],"updatePoint":{"line":1245,"column":22},"line":1245,"code":"  test('Type Hierarchy', async () => {\n    const provider = client.getFeature(TypeHierarchyPrepareRequest.method).getProvider(document)\n    isDefined(provider)\n    const result = await provider.prepareTypeHierarchy(document, position, tokenSource.token)\n\n    isArray(result, undefined, 1)\n    const item = result[0]\n\n    let middlewareCalled = false\n    middleware.prepareTypeHierarchy = (d, p, t, n) => {\n      middlewareCalled = true\n      return n(d, p, t)\n    }\n    await provider.prepareTypeHierarchy(document, position, tokenSource.token)\n    middleware.prepareTypeHierarchy = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const incoming = await provider.provideTypeHierarchySupertypes(item, tokenSource.token)\n    isArray(incoming, undefined, 1)\n    middlewareCalled = false\n    middleware.provideTypeHierarchySupertypes = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideTypeHierarchySupertypes(item, tokenSource.token)\n    middleware.provideTypeHierarchySupertypes = undefined\n    assert.strictEqual(middlewareCalled, true)\n\n    const outgoing = await provider.provideTypeHierarchySubtypes(item, tokenSource.token)\n    isArray(outgoing, undefined, 1)\n    middlewareCalled = false\n    middleware.provideTypeHierarchySubtypes = (i, t, n) => {\n      middlewareCalled = true\n      return n(i, t)\n    }\n    await provider.provideTypeHierarchySubtypes(item, tokenSource.token)\n    middleware.provideTypeHierarchySubtypes = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Inline Values","suites":["Client integration"],"updatePoint":{"line":1285,"column":21},"line":1285,"code":"  test('Inline Values', async () => {\n    const providerData = client.getFeature(InlineValueRequest.method).getProvider(document)\n    isDefined(providerData)\n    const provider = providerData.provider\n    const results = (await provider.provideInlineValues(document, range, { frameId: 1, stoppedLocation: range }, tokenSource.token))\n\n    isArray(results, undefined, 3)\n\n    for (const r of results) {\n      rangeEqual(r.range, 1, 2, 3, 4)\n    }\n\n    // assert.ok(results[0] instanceof InlineValueText)\n    assert.strictEqual((results[0] as InlineValueText).text, 'text')\n\n    // assert.ok(results[1] instanceof InlineValueVariableLookup)\n    assert.strictEqual((results[1] as InlineValueVariableLookup).variableName, 'variableName')\n\n    // assert.ok(results[2] instanceof InlineValueEvaluatableExpression)\n    assert.strictEqual((results[2] as InlineValueEvaluatableExpression).expression, 'expression')\n\n    let middlewareCalled = false\n    middleware.provideInlineValues = (d, r, c, t, n) => {\n      middlewareCalled = true\n      return n(d, r, c, t)\n    }\n    await provider.provideInlineValues(document, range, { frameId: 1, stoppedLocation: range }, tokenSource.token)\n    middleware.provideInlineValues = undefined\n    assert.strictEqual(middlewareCalled, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Inlay Hints","suites":["Client integration"],"updatePoint":{"line":1316,"column":19},"line":1316,"code":"  test('Inlay Hints', async () => {\n    const providerData = client.getFeature(InlayHintRequest.method).getProvider(document)\n    isDefined(providerData)\n    const provider = providerData.provider\n    const results = (await provider.provideInlayHints(document, range, tokenSource.token))\n\n    isArray(results, undefined, 2)\n\n    const hint = results[0]\n    positionEqual(hint.position, 1, 1)\n    assert.strictEqual(hint.kind, InlayHintKind.Type)\n    const label = hint.label\n    isArray(label as [], InlayHintLabelPart, 1)\n    assert.strictEqual((label as InlayHintLabelPart[])[0].value, 'type')\n\n    let middlewareCalled = false\n    middleware.provideInlayHints = (d, r, t, n) => {\n      middlewareCalled = true\n      return n(d, r, t)\n    }\n    await provider.provideInlayHints(document, range, tokenSource.token)\n    middleware.provideInlayHints = undefined\n    assert.strictEqual(middlewareCalled, true)\n    assert.ok(typeof provider.resolveInlayHint === 'function')\n\n    const resolvedHint = await provider.resolveInlayHint!(hint, tokenSource.token)\n    assert.strictEqual((resolvedHint?.label as InlayHintLabelPart[])[0].tooltip, 'tooltip')\n    let called = false\n    await client.sendNotification('fireInlayHintsRefresh')\n    provider.onDidChangeInlayHints(() => {\n      called = true\n    })\n    await helper.waitValue(() => {\n      return called\n    }, true)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Workspace symbols","suites":["Client integration"],"updatePoint":{"line":1353,"column":25},"line":1353,"code":"  test('Workspace symbols', async () => {\n    const providers = client.getFeature(WorkspaceSymbolRequest.method).getProviders()\n    isDefined(providers)\n    assert.strictEqual(providers.length, 2)\n    const provider = providers[0]\n    const results = await provider.provideWorkspaceSymbols('', tokenSource.token)\n    isArray(results, undefined, 1)\n\n    assert.strictEqual(results.length, 1)\n\n    const symbol = await provider.resolveWorkspaceSymbol!(results[0], tokenSource.token)\n    isDefined(symbol)\n    rangeEqual(symbol.location.range, 1, 2, 3, 4)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Stop fails if server crashes after shutdown request","suites":["sever tests"],"updatePoint":{"line":1392,"column":59},"line":1392,"code":"  test('Stop fails if server crashes after shutdown request', async () => {\n    let file = path.join(__dirname, './server/crashOnShutdownServer.js')\n    const serverOptions: ServerOptions = {\n      module: file,\n      transport: TransportKind.ipc,\n    }\n    const clientOptions: LanguageClientOptions = {}\n    const client = new LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions)\n    await client._start()\n\n    await assert.rejects(async () => {\n      await client.stop()\n    }, /Pending response rejected since connection got disposed/)\n    assert.strictEqual(client.needsStart(), true)\n    assert.strictEqual(client.needsStop(), false)\n\n    // Stopping again should be a no-op.\n    await client.stop()\n    assert.strictEqual(client.needsStart(), true)\n    assert.strictEqual(client.needsStop(), false)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Stop fails if server shutdown request times out","suites":["sever tests"],"updatePoint":{"line":1414,"column":55},"line":1414,"code":"  test('Stop fails if server shutdown request times out', async () => {\n    const serverOptions: ServerOptions = {\n      module: path.join(__dirname, './server/timeoutOnShutdownServer.js'),\n      transport: TransportKind.ipc,\n    }\n    const clientOptions: LanguageClientOptions = {}\n    const client = new LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions)\n    await client._start()\n\n    await assert.rejects(async () => {\n      await client.stop(100)\n    }, /Stopping the server timed out/)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Server can not be stopped right after start","suites":["sever tests"],"updatePoint":{"line":1428,"column":51},"line":1428,"code":"  test('Server can not be stopped right after start', async () => {\n    const serverOptions: ServerOptions = {\n      module: path.join(__dirname, './server/startStopServer.js'),\n      transport: TransportKind.ipc,\n    }\n    const clientOptions: LanguageClientOptions = {}\n    const client = new LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions)\n    void client.start()\n    await assert.rejects(async () => {\n      await client.stop()\n    }, /Client is not running and can't be stopped/)\n\n    await client._start()\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Test state change events","suites":["sever tests"],"updatePoint":{"line":1444,"column":32},"line":1444,"code":"  test('Test state change events', async () => {\n    const serverOptions: ServerOptions = {\n      module: path.join(__dirname, './server/nullServer.js'),\n      transport: TransportKind.ipc,\n    }\n    const clientOptions: LanguageClientOptions = {}\n    const client = new LanguageClient('test svr', 'Test Language Server', serverOptions, clientOptions)\n    let state: State | undefined\n    client.onDidChangeState(event => {\n      state = event.newState\n    })\n    await client._start()\n    assert.strictEqual(state, State.Running, 'First start')\n\n    await client.stop()\n    assert.strictEqual(state, State.Stopped, 'First stop')\n\n    await client._start()\n    assert.strictEqual(state, State.Running, 'Second start')\n\n    await client.stop()\n    assert.strictEqual(state, State.Stopped, 'Second stop')\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Test state change events on crash","suites":["sever tests"],"updatePoint":{"line":1468,"column":41},"line":1468,"code":"  test('Test state change events on crash', async () => {\n    const serverOptions: ServerOptions = {\n      module: path.join(__dirname, './server/crashServer.js'),\n      transport: TransportKind.ipc,\n    }\n    const clientOptions: LanguageClientOptions = {}\n    const client = new CrashClient('test svr', 'Test Language Server', serverOptions, clientOptions)\n    let states: State[] = []\n    client.onDidChangeState(event => {\n      states.push(event.newState)\n    })\n    await client._start()\n    assert.strictEqual(states.length, 2, 'First start')\n    assert.strictEqual(states[0], State.Starting)\n    assert.strictEqual(states[1], State.Running)\n\n    states = []\n    await client.sendNotification(CrashNotification.type)\n    await client.onCrash\n\n    await client._start()\n    assert.strictEqual(states.length, 3, 'Restart after crash')\n    assert.strictEqual(states[0], State.Stopped)\n    assert.strictEqual(states[1], State.Starting)\n    assert.strictEqual(states[2], State.Running)\n\n    states = []\n    await client.stop()\n    assert.strictEqual(states.length, 1, 'After stop')\n    assert.strictEqual(states[0], State.Stopped)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server on request","suites":["Server activation"],"updatePoint":{"line":1543,"column":31},"line":1543,"code":"  test('Start server on request', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    const result: number = await client.sendRequest('request', { value: 10 })\n    assert.strictEqual(client.state, State.Running)\n    assert.strictEqual(result, 11)\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server fails on request when stopped once","suites":["Server activation"],"updatePoint":{"line":1552,"column":55},"line":1552,"code":"  test('Start server fails on request when stopped once', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    const result: number = await client.sendRequest('request', { value: 10 })\n    assert.strictEqual(client.state, State.Running)\n    assert.strictEqual(result, 11)\n    await client.stop()\n    await assert.rejects(async () => {\n      await client.sendRequest('request', { value: 10 })\n    }, /Client is not running/)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server on notification","suites":["Server activation"],"updatePoint":{"line":1564,"column":36},"line":1564,"code":"  test('Start server on notification', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    await client.sendNotification('notification')\n    assert.strictEqual(client.state, State.Running)\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server fails on notification when stopped once","suites":["Server activation"],"updatePoint":{"line":1572,"column":60},"line":1572,"code":"  test('Start server fails on notification when stopped once', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    await client.sendNotification('notification')\n    assert.strictEqual(client.state, State.Running)\n    await client.stop()\n    await assert.rejects(async () => {\n      await client.sendNotification('notification')\n    }, /Client is not running/)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Add pending request handler","suites":["Server activation"],"updatePoint":{"line":1583,"column":35},"line":1583,"code":"  test('Add pending request handler', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    let requestReceived = false\n    client.onRequest('request', () => {\n      requestReceived = true\n    })\n    await client.sendRequest('triggerRequest')\n    assert.strictEqual(requestReceived, true)\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Add pending notification handler","suites":["Server activation"],"updatePoint":{"line":1595,"column":40},"line":1595,"code":"  test('Add pending notification handler', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    let notificationReceived = false\n    client.onNotification('notification', () => {\n      notificationReceived = true\n    })\n    await client.sendRequest('triggerNotification')\n    assert.strictEqual(notificationReceived, true)\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Starting disposed server fails","suites":["Server activation"],"updatePoint":{"line":1607,"column":38},"line":1607,"code":"  test('Starting disposed server fails', async () => {\n    const client = createClient()\n    await client._start()\n    await client.dispose()\n    await assert.rejects(async () => {\n      await client._start()\n    }, /Client got disposed and can't be restarted./)\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server on document open","suites":["Server activation"],"updatePoint":{"line":1631,"column":37},"line":1631,"code":"  test('Start server on document open', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    const started = checkServerStart(client, workspace.onDidOpenTextDocument(document => {\n      if (workspace.match([{ scheme: 'lsptests', pattern: uri.fsPath }], document) > 0) {\n        void client.start()\n      }\n    }))\n    await workspace.openTextDocument(uri)\n    await started\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Start server on language feature","suites":["Server activation"],"updatePoint":{"line":1644,"column":40},"line":1644,"code":"  test('Start server on language feature', async () => {\n    const client = createClient()\n    assert.strictEqual(client.state, State.Stopped)\n    const started = checkServerStart(client, languages.registerDeclarationProvider(documentSelector, {\n      provideDeclaration: async () => {\n        await client._start()\n        return undefined\n      }\n    }))\n    await workspace.openTextDocument(uri)\n    await helper.doAction('declarations')\n    await started\n    await client.stop()\n  })","file":"client/features.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hook file events from client configuration","suites":["FileSystemWatcherFeature"],"updatePoint":{"line":66,"column":55},"line":66,"code":"  it('should hook file events from client configuration', async () => {\n    let client: LanguageClient\n    let watcher = new CustomWatcher()\n    let called = false\n    let changes: FileChangeType[] = []\n    client = createClient([watcher], {\n      workspace: {\n        didChangeWatchedFile: async (event, next): Promise<void> => {\n          called = true\n          changes.push(event.type)\n          return next(event)\n        }\n      }\n    })\n    let received: any[]\n    client.onNotification('filesChange', params => {\n      received = params.changes\n    })\n    await client.start()\n    expect(called).toBe(false)\n    let uri = URI.file(__filename)\n    watcher.fireCreate(uri)\n    expect(called).toBe(true)\n    watcher.fireChange(uri)\n    watcher.fireDelete(uri)\n    expect(changes).toEqual([1, 2, 3])\n    await helper.wait(100)\n    await client.stop()\n    expect(received.length).toBe(1)\n    expect(received[0]).toEqual({\n      uri: uri.toString(),\n      type: 3\n    })\n  })","file":"client/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with single watcher","suites":["FileSystemWatcherFeature"],"updatePoint":{"line":101,"column":37},"line":101,"code":"  it('should work with single watcher', async () => {\n    let client: LanguageClient\n    let watcher = new CustomWatcher()\n    client = createClient(watcher, {})\n    let received: any[]\n    client.onNotification('filesChange', params => {\n      received = params.changes\n    })\n    await client.start()\n    let uri = URI.file(__filename)\n    watcher.fireCreate(uri)\n    await helper.wait(100)\n    expect(received.length).toBe(1)\n    await client.stop()\n  })","file":"client/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support dynamic registration","suites":["FileSystemWatcherFeature"],"updatePoint":{"line":117,"column":41},"line":117,"code":"  it('should support dynamic registration', async () => {\n    let client: LanguageClient\n    client = createClient(undefined)\n    await client.start()\n    await helper.wait(50)\n    let feature = client.getFeature(DidChangeWatchedFilesNotification.method)\n    await (feature as any)._notifyFileEvent()\n    let state = feature.getState()\n    expect((state as any).registrations).toBe(true)\n    await client.sendNotification('unwatch')\n    await helper.wait(50)\n    state = feature.getState()\n    expect((state as any).registrations).toBe(false)\n    await client.stop()\n  })","file":"client/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get working directory","suites":["global functions"],"updatePoint":{"line":25,"column":34},"line":25,"code":"  it('should get working directory', async () => {\n    let cwd = await lsclient.getServerWorkingDir()\n    expect(cwd).toBeDefined()\n    cwd = await lsclient.getServerWorkingDir({ cwd: 'not_exists' })\n    expect(cwd).toBeUndefined()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get main root","suites":["global functions"],"updatePoint":{"line":32,"column":26},"line":32,"code":"  it('should get main root', async () => {\n    expect(lsclient.mainGetRootPath()).toBeUndefined()\n    let uri = URI.file(__filename)\n    await workspace.openResource(uri.toString())\n    expect(lsclient.mainGetRootPath()).toBeDefined()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get runtime path","suites":["global functions"],"updatePoint":{"line":39,"column":29},"line":39,"code":"  it('should get runtime path', async () => {\n    expect(lsclient.getRuntimePath(__filename, undefined)).toBeDefined()\n    let uri = URI.file(__filename)\n    await workspace.openResource(uri.toString())\n    expect(lsclient.getRuntimePath('package.json', undefined)).toBeDefined()\n    let name = path.basename(__filename)\n    expect(lsclient.getRuntimePath(name, __dirname)).toBeDefined()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check debug mode","suites":["global functions"],"updatePoint":{"line":48,"column":29},"line":48,"code":"  it('should check debug mode', async () => {\n    expect(lsclient.startedInDebugMode(['--debug'])).toBe(true)\n    expect(lsclient.startedInDebugMode(undefined)).toBe(false)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start server","suites":["Client events"],"updatePoint":{"line":55,"column":25},"line":55,"code":"  it('should start server', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {}\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.ipc\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register events before server start","suites":["Client events"],"updatePoint":{"line":67,"column":48},"line":67,"code":"  it('should register events before server start', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {}\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.ipc\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    let fn = jest.fn()\n    let disposable = client.onRequest('customRequest', () => {\n      fn()\n      disposable.dispose()\n      return {}\n    })\n    let dispose = client.onNotification('customNotification', () => {\n      fn()\n      dispose.dispose()\n    })\n    let dis = client.onProgress(WorkDoneProgress.type, '4fb247f8-0ede-415d-a80a-6629b6a9eaf8', p => {\n      expect(p).toEqual({ kind: 'end', message: 'end message' })\n      fn()\n      dis.dispose()\n    })\n    await client.start()\n    await client.sendNotification('send')\n    await helper.wait(60)\n    expect(fn).toBeCalledTimes(3)\n    //   let client = await testEventServer({ initEvent: true })\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register events after server start","suites":["Client events"],"updatePoint":{"line":98,"column":47},"line":98,"code":"  it('should register events after server start', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {\n      synchronize: {},\n      initializationOptions: { initEvent: true }\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    let fn = jest.fn()\n    let disposable = client.onRequest('customRequest', () => {\n      fn()\n      disposable.dispose()\n      return {}\n    })\n    let dispose = client.onNotification('customNotification', () => {\n      fn()\n      dispose.dispose()\n    })\n    let dis = client.onProgress(WorkDoneProgress.type, '4fb247f8-0ede-415d-a80a-6629b6a9eaf8', p => {\n      expect(p).toEqual({ kind: 'end', message: 'end message' })\n      fn()\n      dis.dispose()\n    })\n    await client.sendNotification('send')\n    await helper.wait(50)\n    expect(fn).toBeCalledTimes(3)\n    //   let client = await testEventServer({ initEvent: true })\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send progress","suites":["Client events"],"updatePoint":{"line":132,"column":26},"line":132,"code":"  it('should send progress', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {\n      synchronize: {},\n      initializationOptions: { initEvent: true }\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    let fn = jest.fn()\n    client.onNotification('progressResult', res => {\n      fn()\n      expect(res).toEqual({ kind: 'begin', title: 'begin progress' })\n    })\n    await client.sendProgress(WorkDoneProgress.type, '4b3a71d0-2b3f-46af-be2c-2827f548579f', { kind: 'begin', title: 'begin progress' })\n    await client.start()\n    await helper.wait(50)\n    let p = client.stop()\n    await expect(async () => {\n      await client._start()\n    }).rejects.toThrow(Error)\n    await p\n    expect(fn).toBeCalled()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle error","suites":["Client events"],"updatePoint":{"line":159,"column":25},"line":159,"code":"  it('should handle error', async () => {\n    let fn = jest.fn()\n    let clientOptions: lsclient.LanguageClientOptions = {\n      synchronize: {},\n      errorHandler: {\n        error: () => {\n          return ErrorAction.Shutdown\n        },\n        closed: () => {\n          fn()\n          return CloseAction.DoNotRestart\n        }\n      },\n      initializationOptions: { initEvent: true }\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    await client.sendRequest('doExit')\n    await client.start()\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle message events","suites":["Client events"],"updatePoint":{"line":187,"column":34},"line":187,"code":"  it('should handle message events', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {\n      synchronize: {},\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    await client.sendNotification('logMessage')\n    await client.sendNotification('showMessage')\n    let types = [MessageType.Error, MessageType.Warning, MessageType.Info, MessageType.Log]\n    for (const t of types) {\n      await client.sendNotification('requestMessage', { type: t })\n      await helper.wait(30)\n      if (t == MessageType.Error) {\n        await workspace.nvim.input('1')\n      } else {\n        await workspace.nvim.input('<cr>')\n      }\n    }\n    let uri = URI.file(__filename)\n    await client.sendNotification('showDocument', { external: true, uri: 'lsptest:///1' })\n    await client.sendNotification('showDocument', { uri: 'lsptest:///1', takeFocus: false })\n    await client.sendNotification('showDocument', { uri: uri.toString() })\n    await client.sendNotification('showDocument', { uri: uri.toString(), selection: Range.create(0, 0, 1, 0) })\n    await helper.wait(300)\n    expect(client.hasPendingResponse).toBe(false)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke showDocument middleware","suites":["Client events"],"updatePoint":{"line":220,"column":43},"line":220,"code":"  it('should invoke showDocument middleware', async () => {\n    let fn = jest.fn()\n    let clientOptions: lsclient.LanguageClientOptions = {\n      synchronize: {},\n      middleware: {\n        window: {\n          showDocument: async (params, next) => {\n            fn()\n            let res = await next(params, CancellationToken.None)\n            return res as any\n          }\n        }\n      }\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    let uri = URI.file(__filename)\n    await client.start()\n    await client.sendNotification('showDocument', { uri: uri.toString() })\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n    await client.restart()\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize from function","suites":["Client integration"],"updatePoint":{"line":264,"column":37},"line":264,"code":"  it('should initialize from function', async () => {\n    async function testServer(serverOptions: lsclient.ServerOptions) {\n      let clientOptions: lsclient.LanguageClientOptions = {}\n      let client = new lsclient.LanguageClient('HTML', serverOptions, clientOptions)\n      await client.start()\n      await client.dispose()\n    }\n    await testServer(() => {\n      let module = path.join(__dirname, './server/eventServer.js')\n      let sp = cp.fork(module, ['--node-ipc'], { cwd: process.cwd() })\n      return Promise.resolve({ reader: new IPCMessageReader(sp), writer: new IPCMessageWriter(sp) })\n    })\n    await testServer(() => {\n      let module = path.join(__dirname, './server/eventServer.js')\n      let sp = cp.fork(module, ['--stdio'], {\n        cwd: process.cwd(),\n        execArgv: [],\n        silent: true,\n      })\n      return Promise.resolve({ reader: sp.stdout, writer: sp.stdin })\n    })\n    await testServer(() => {\n      let module = path.join(__dirname, './server/eventServer.js')\n      let sp = cp.fork(module, ['--stdio'], {\n        cwd: process.cwd(),\n        execArgv: [],\n        silent: true,\n      })\n      return Promise.resolve({ process: sp, detached: false })\n    })\n    await testServer(() => {\n      let module = path.join(__dirname, './server/eventServer.js')\n      let sp = cp.fork(module, ['--stdio'], {\n        cwd: process.cwd(),\n        execArgv: [],\n        silent: true,\n      })\n      return Promise.resolve(sp)\n    })\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use IPC channel","suites":["Client integration"],"updatePoint":{"line":305,"column":39},"line":305,"code":"  it('should initialize use IPC channel', async () => {\n    helper.updateConfiguration('css.trace.server.verbosity', 'verbose')\n    helper.updateConfiguration('css.trace.server.format', 'json')\n    let uri = URI.file(__filename)\n    await workspace.loadFile(uri.toString())\n    let serverModule = path.join(__dirname, './server/testInitializeResult.js')\n    let serverOptions: lsclient.ServerOptions = {\n      run: { module: serverModule, transport: lsclient.TransportKind.ipc },\n      debug: { module: serverModule, transport: lsclient.TransportKind.ipc, options: { execArgv: ['--nolazy', '--inspect=6014'] } }\n    }\n    let clientOptions: lsclient.LanguageClientOptions = {\n      rootPatterns: ['.vim'],\n      requireRootPattern: true,\n      documentSelector: ['css'],\n      synchronize: {}, initializationOptions: {},\n      middleware: {\n        handleDiagnostics: (uri, diagnostics, next) => {\n          assert.equal(uri, \"uri:/test.ts\")\n          assert.ok(Array.isArray(diagnostics))\n          assert.equal(diagnostics.length, 0)\n          next(uri, diagnostics)\n        }\n      }\n    }\n    let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    let expected = {\n      capabilities: {\n        textDocumentSync: 1,\n        completionProvider: { resolveProvider: true, triggerCharacters: ['\"', ':'] },\n        hoverProvider: true,\n        renameProvider: {\n          prepareProvider: true\n        }\n      },\n      customResults: {\n        hello: \"world\"\n      }\n    }\n    assert.deepEqual(client.initializeResult, expected)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use stdio","suites":["Client integration"],"updatePoint":{"line":348,"column":33},"line":348,"code":"  it('should initialize use stdio', async () => {\n    helper.updateConfiguration('css.trace.server.verbosity', 'verbose')\n    helper.updateConfiguration('css.trace.server.format', 'text')\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio\n    }\n    let client = await testLanguageServer(serverOptions, {\n      workspaceFolder: { name: 'test', uri: URI.file(__dirname).toString() },\n      outputChannel: window.createOutputChannel('test'),\n      markdown: {},\n      disabledFeatures: ['pullDiagnostic'],\n      revealOutputChannelOn: lsclient.RevealOutputChannelOn.Info,\n      outputChannelName: 'custom',\n      connectionOptions: {\n        cancellationStrategy: {} as any,\n        maxRestartCount: 10,\n      },\n      stdioEncoding: 'utf8',\n      errorHandler: {\n        error: (): lsclient.ErrorAction => {\n          return lsclient.ErrorAction.Continue\n        },\n        closed: () => {\n          return lsclient.CloseAction.DoNotRestart\n        }\n      },\n      progressOnInitialization: true,\n      disableMarkdown: true,\n      disableDiagnostics: true\n    })\n    assert.deepStrictEqual(client.supportedMarkupKind, [MarkupKind.PlainText])\n    assert.strictEqual(client.name, 'Test Language Server')\n    assert.strictEqual(client.diagnostics, undefined)\n    client.trace = Trace.Verbose\n    let d = client.start()\n    let s = new CancellationTokenSource()\n    s.cancel()\n    client.handleFailedRequest(DidCreateFilesNotification.type, s.token, undefined, '')\n    await expect(async () => {\n      let error = new ResponseError(LSPErrorCodes.RequestCancelled, 'request cancelled')\n      client.handleFailedRequest(DidCreateFilesNotification.type, undefined, error, '')\n    }).rejects.toThrow(CancellationError)\n    let error = new ResponseError(LSPErrorCodes.ContentModified, 'content changed')\n    client.handleFailedRequest(DidCreateFilesNotification.type, undefined, error, '')\n    await client.stop()\n    client.info('message', new Error('my error'), true)\n    client.warn('message', 'error', true)\n    client.warn('message', 0, true)\n    client.logFailedRequest()\n    assert.strictEqual(client.diagnostics, undefined)\n    d.dispose()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use pipe","suites":["Client integration"],"updatePoint":{"line":403,"column":32},"line":403,"code":"  it('should initialize use pipe', async () => {\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.pipe\n    }\n    let client = await testLanguageServer(serverOptions, {\n      ignoredRootPaths: [workspace.root]\n    })\n    expect(client.serviceState).toBeDefined()\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize use socket","suites":["Client integration"],"updatePoint":{"line":416,"column":34},"line":416,"code":"  it('should initialize use socket', async () => {\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      options: {\n        env: {\n          NODE_SOCKET_TEST: 1\n        }\n      },\n      transport: {\n        kind: lsclient.TransportKind.socket,\n        port: 8088\n      }\n    }\n    let client = await testLanguageServer(serverOptions)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should initialize as command","suites":["Client integration"],"updatePoint":{"line":434,"column":34},"line":434,"code":"  it('should initialize as command', async () => {\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      command: 'node',\n      args: [serverModule, '--stdio']\n    }\n    let client = await testLanguageServer(serverOptions)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw as command","suites":["Client integration"],"updatePoint":{"line":444,"column":33},"line":444,"code":"  it('should not throw as command', async () => {\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      command: 'not_exists',\n      args: [serverModule, '--stdio']\n    }\n    let clientOptions: lsclient.LanguageClientOptions = {\n      documentSelector: ['css'],\n      initializationOptions: {}\n    }\n    await expect(async () => {\n      let client = new lsclient.LanguageClient('css', 'Test Language Server', serverOptions, clientOptions)\n      await client.start()\n      await client.stop()\n    }).rejects.toThrow(Error)\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should logMessage","suites":["Client integration"],"updatePoint":{"line":461,"column":23},"line":461,"code":"  it('should logMessage', async () => {\n    let called = false\n    let outputChannel = {\n      name: 'empty',\n      content: '',\n      append: () => {\n        called = true\n      },\n      appendLine: () => {},\n      clear: () => {},\n      show: () => {},\n      hide: () => {},\n      dispose: () => {}\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      command: 'node',\n      args: [serverModule, '--stdio']\n    }\n    let client = await testLanguageServer(serverOptions, { outputChannel })\n    client.logMessage('message')\n    client.logMessage(Buffer.from('message', 'utf8'))\n    expect(called).toBe(true)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle error on initialize","suites":["Client integration"],"updatePoint":{"line":487,"column":39},"line":487,"code":"  it('should handle error on initialize', async () => {\n    async function startServer(handler: InitializationFailedHandler | undefined, key = 'throwError'): Promise<lsclient.LanguageClient> {\n      let clientOptions: lsclient.LanguageClientOptions = {\n        initializationFailedHandler: handler,\n        initializationOptions: {\n          [key]: true\n        }\n      }\n      let serverModule = path.join(__dirname, './server/eventServer.js')\n      let serverOptions: lsclient.ServerOptions = {\n        module: serverModule,\n        transport: lsclient.TransportKind.ipc,\n      }\n      let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n      await client.start()\n      return client\n    }\n    let n = 0\n    try {\n      let client = await startServer(() => {\n        n++\n        return n == 1\n      })\n      await client.stop()\n    } catch (e) {\n      // ignore\n    }\n    try {\n      let client = await startServer(undefined)\n      await client.stop()\n    } catch (e) {\n      // ignore\n    }\n    try {\n      let client = await startServer(undefined, 'normalThrow')\n      await client.stop()\n    } catch (e) {\n      // ignore\n    }\n    try {\n      let client = await startServer(undefined, 'utf8')\n      void client.stop()\n      await client.stop()\n    } catch (e) {\n      // ignore\n    }\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should separate diagnostics","suites":["Client integration"],"updatePoint":{"line":535,"column":33},"line":535,"code":"  it('should separate diagnostics', async () => {\n    async function startServer(disable?: boolean, handleDiagnostics?: (uri: string, diagnostics: Diagnostic[], next: HandleDiagnosticsSignature) => void): Promise<lsclient.LanguageClient> {\n      let clientOptions: lsclient.LanguageClientOptions = {\n        disableDiagnostics: disable,\n        separateDiagnostics: true,\n        initializationOptions: {},\n        middleware: {\n          handleDiagnostics\n        }\n      }\n      let serverModule = path.join(__dirname, './server/eventServer.js')\n      let serverOptions: lsclient.ServerOptions = {\n        module: serverModule,\n        transport: lsclient.TransportKind.stdio,\n      }\n      let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n      await client.start()\n      return client\n    }\n    let client = await startServer()\n    await client.sendNotification('diagnostics')\n    await helper.wait(30)\n    let collection = client.diagnostics\n    let res = collection.get('lsptest:/2')\n    expect(res.length).toBe(2)\n    await client.stop()\n    client = await startServer(true)\n    await client.sendNotification('diagnostics')\n    await helper.wait(30)\n    collection = client.diagnostics\n    expect(collection).toBeUndefined()\n    await client.stop()\n    let called = false\n    client = await startServer(false, (uri, diagnostics, next) => {\n      called = true\n      next(uri, diagnostics)\n    })\n    await client.sendNotification('diagnostics')\n    await helper.wait(30)\n    expect(called).toBe(true)\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check version on apply workspaceEdit","suites":["Client integration"],"updatePoint":{"line":578,"column":49},"line":578,"code":"  it('should check version on apply workspaceEdit', async () => {\n    let uri = URI.file(__filename)\n    await workspace.loadFile(uri.toString())\n    let clientOptions: lsclient.LanguageClientOptions = {\n      documentSelector: [{ scheme: 'file' }],\n      initializationOptions: {},\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio,\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    let res\n    client.onNotification('result', p => {\n      res = p\n    })\n    await client.start()\n    await helper.wait(10)\n    await client.sendNotification('edits')\n    await helper.wait(50)\n    expect(res).toBeDefined()\n    expect(res).toEqual({ applied: false })\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply simple workspaceEdit","suites":["Client integration"],"updatePoint":{"line":604,"column":39},"line":604,"code":"  it('should apply simple workspaceEdit', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {\n      initializationOptions: {},\n    }\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.stdio,\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    let res\n    client.onNotification('result', p => {\n      res = p\n    })\n    await client.start()\n    await client.sendNotification('simpleEdit')\n    await helper.wait(30)\n    expect(res).toBeDefined()\n    expect(res).toEqual({ applied: true })\n    await client.stop()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup SettingMonitor","suites":["SettingMonitor"],"updatePoint":{"line":628,"column":33},"line":628,"code":"  it('should setup SettingMonitor', async () => {\n    let clientOptions: lsclient.LanguageClientOptions = {}\n    let serverModule = path.join(__dirname, './server/eventServer.js')\n    let serverOptions: lsclient.ServerOptions = {\n      module: serverModule,\n      transport: lsclient.TransportKind.ipc\n    }\n    let client = new lsclient.LanguageClient('html', 'Test Language Server', serverOptions, clientOptions)\n    await client.start()\n    let monitor = new lsclient.SettingMonitor(client, 'html.enabled')\n    let disposable = monitor.start()\n    helper.updateConfiguration('html.enabled', false)\n    await helper.wait(30)\n    expect(client.state).toBe(lsclient.State.Stopped)\n    helper.updateConfiguration('html.enabled', true)\n    await helper.wait(30)\n    expect(client.state).toBe(lsclient.State.Starting)\n    await client.onReady()\n    disposable.dispose()\n  })","file":"client/integration.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not start if cancelled","suites":["ProgressPart"],"updatePoint":{"line":46,"column":35},"line":46,"code":"  it('should not start if cancelled', async () => {\n    let client = createClient()\n    let p = new ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696')\n    p.cancel()\n    expect(p.begin({ kind: 'begin', title: 'canceleld' })).toBe(false)\n  })","file":"client/progressPart.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report progress","suites":["ProgressPart"],"updatePoint":{"line":53,"column":28},"line":53,"code":"  it('should report progress', async () => {\n    let client = createClient()\n    let p = new ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696')\n    p.begin({ kind: 'begin', title: 'p', percentage: 1, cancellable: true })\n    await helper.wait(30)\n    p.report({ kind: 'report', message: 'msg', percentage: 10 })\n    await helper.wait(10)\n    p.report({ kind: 'report', message: 'msg', percentage: 50 })\n    await helper.wait(10)\n    p.done('finised')\n  })","file":"client/progressPart.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close notification on cancel","suites":["ProgressPart"],"updatePoint":{"line":65,"column":41},"line":65,"code":"  it('should close notification on cancel', async () => {\n    let client = createClient()\n    let p = new ProgressPart(client, '0c7faec8-e36c-4cde-9815-95635c37d696')\n    let started = p.begin({ kind: 'begin', title: 'canceleld' })\n    expect(started).toBe(true)\n    p.cancel()\n    p.cancel()\n    let winids = await nvim.call('coc#notify#win_list') as number[]\n    await helper.wait(30)\n    expect(winids.length).toBe(1)\n    let win = nvim.createWindow(winids[0])\n    let closing = await win.getVar('closing')\n    expect(closing).toBe(1)\n  })","file":"client/progressPart.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send notification on cancel","suites":["ProgressPart"],"updatePoint":{"line":80,"column":40},"line":80,"code":"  it('should send notification on cancel', async () => {\n    let client = createClient()\n    let token = '0c7faec8-e36c-4cde-9815-95635c37d696'\n    let p = new ProgressPart(client, token)\n    let started = p.begin({ kind: 'begin', title: 'canceleld', cancellable: true })\n    expect(started).toBe(true)\n    for (let i = 0; i < 10; i++) {\n      await helper.wait(30)\n      let winids = await nvim.call('coc#notify#win_list') as number[]\n      if (winids.length == 1) break\n    }\n    await helper.wait(30)\n    nvim.call('coc#float#close_all', [], true)\n    await helper.waitValue(() => {\n      return client.token\n    }, token)\n  })","file":"client/progressPart.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register with empty documentSelector","suites":["TextDocumentSynchronization","DidOpenTextDocumentFeature"],"updatePoint":{"line":44,"column":51},"line":44,"code":"    it('should register with empty documentSelector', async () => {\n      let client = createClient(undefined)\n      await client.start()\n      let feature = client.getFeature(DidOpenTextDocumentNotification.method)\n      feature.register({ id: uuidv4(), registerOptions: { documentSelector: null } })\n      let res = await client.sendRequest('getLastOpen')\n      expect(res).toBe(null)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send event on document create","suites":["TextDocumentSynchronization","DidOpenTextDocumentFeature"],"updatePoint":{"line":54,"column":44},"line":54,"code":"    it('should send event on document create', async () => {\n      let client = createClient([{ language: 'vim' }])\n      await client.start()\n      let uri = URI.file(path.join(os.tmpdir(), 't.vim'))\n      let doc = await workspace.loadFile(uri.toString())\n      expect(doc.languageId).toBe('vim')\n      let res = await client.sendRequest('getLastOpen') as any\n      expect(res.uri).toBe(doc.uri)\n      expect(res.version).toBe(doc.version)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with middleware","suites":["TextDocumentSynchronization","DidOpenTextDocumentFeature"],"updatePoint":{"line":66,"column":35},"line":66,"code":"    it('should work with middleware', async () => {\n      let called = false\n      let client = createClient([{ language: 'vim' }], {\n        didOpen: (doc, next) => {\n          called = true\n          return next(doc)\n        }\n      })\n      await client.start()\n      let uri = URI.file(path.join(os.tmpdir(), 't.js'))\n      let doc = await workspace.loadFile(uri.toString())\n      expect(doc.languageId).toBe('javascript')\n      let feature = client.getFeature(DidOpenTextDocumentNotification.method)\n      feature.register({ id: uuidv4(), registerOptions: { documentSelector: [{ language: 'javascript' }] } })\n      let res = await client.sendRequest('getLastOpen') as any\n      expect(res.uri).toBe(doc.uri)\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send close event","suites":["TextDocumentSynchronization","DidCloseTextDocumentFeature"],"updatePoint":{"line":88,"column":31},"line":88,"code":"    it('should send close event', async () => {\n      let uri = URI.file(path.join(os.tmpdir(), 't.vim'))\n      let doc = await workspace.loadFile(uri.toString())\n      let client = createClient([{ language: 'vim' }])\n      await client.start()\n      await workspace.nvim.command(`bd! ${doc.bufnr}`)\n      await helper.wait(30)\n      let res = await client.sendRequest('getLastClose') as any\n      expect(res.uri).toBe(doc.uri)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should unregister document selector","suites":["TextDocumentSynchronization","DidCloseTextDocumentFeature"],"updatePoint":{"line":100,"column":43},"line":100,"code":"    it('should unregister document selector', async () => {\n      let called = false\n      let client = createClient([{ language: 'javascript' }], {\n        didClose: (e, next) => {\n          called = true\n          return next(e)\n        }\n      })\n      await client.start()\n      let openFeature = client.getFeature(DidOpenTextDocumentNotification.method)\n      let id = uuidv4()\n      let options = { id, registerOptions: { documentSelector: [{ language: 'vim' }] } }\n      openFeature.register(options)\n      let feature = client.getFeature(DidCloseTextDocumentNotification.method)\n      feature.register(options)\n      let uri = URI.file(path.join(os.tmpdir(), 't.vim'))\n      let doc = await workspace.loadFile(uri.toString())\n      await helper.wait(30)\n      feature.unregister(id)\n      feature.unregister('unknown')\n      await helper.wait(30)\n      let res = await client.sendRequest('getLastClose') as any\n      expect(res.uri).toBe(doc.uri)\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send full change event ","suites":["TextDocumentSynchronization","DidChangeTextDocumentFeature"],"updatePoint":{"line":129,"column":38},"line":129,"code":"    it('should send full change event ', async () => {\n      let called = false\n      let client = createClient([{ language: 'vim' }], {\n        didChange: (e, next) => {\n          called = true\n          return next(e)\n        }\n      })\n      await client.start()\n      let uri = URI.file(path.join(os.tmpdir(), 'x.vim'))\n      let doc = await workspace.loadFile(uri.toString())\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'bar')])\n      await client.forceDocumentSync()\n      let res = await client.sendRequest('getLastChange') as any\n      expect(res.text).toBe('bar\\n')\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send incremental change event","suites":["TextDocumentSynchronization","DidChangeTextDocumentFeature"],"updatePoint":{"line":148,"column":44},"line":148,"code":"    it('should send incremental change event', async () => {\n      let client = createClient([{ scheme: 'lsptest' }])\n      await client.start()\n      await client.sendNotification('registerDocumentSync')\n      await helper.wait(30)\n      let feature = client.getFeature(DidChangeTextDocumentNotification.method)\n      let fn = jest.fn()\n      feature.onNotificationSent(() => {\n        fn()\n      })\n      await nvim.command('edit t.vim')\n      let doc = await workspace.document\n      await nvim.call('setline', [1, 'foo'])\n      await doc.synchronize()\n      await client.forceDocumentSync()\n      await helper.wait(50)\n      await nvim.call('setline', [1, 'foo'])\n      await doc.synchronize()\n      expect(fn).toBeCalled()\n      let res = await client.sendRequest('getLastChange') as any\n      expect(res.uri).toBe(doc.uri)\n      expect(res.text).toBe('foo\\n')\n      let provider = feature.getProvider(doc.textDocument)\n      expect(provider).toBeDefined()\n      await provider.send({ contentChanges: [], textDocument: { uri: doc.uri, version: doc.version }, bufnr: doc.bufnr, original: '', originalLines: [] })\n      await client.sendNotification('unregisterDocumentSync')\n      await helper.wait(30)\n      provider = feature.getProvider(doc.textDocument)\n      expect(provider).toBeUndefined()\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not send change event when syncKind is none","suites":["TextDocumentSynchronization","DidChangeTextDocumentFeature"],"updatePoint":{"line":180,"column":58},"line":180,"code":"    it('should not send change event when syncKind is none', async () => {\n      let client = createClient([{ scheme: 'lsptest' }], {}, { none: true })\n      await client.start()\n      await client.sendNotification('registerDocumentSync')\n      await nvim.command('edit x.vim')\n      let doc = await workspace.document\n      await helper.wait(30)\n      let feature = client.getFeature(DidChangeTextDocumentNotification.method)\n      let provider = feature.getProvider(doc.textDocument)\n      let changes: TextDocumentContentChange[] = [{\n        range: Range.create(0, 0, 0, 0),\n        text: 'foo'\n      }]\n      await provider.send({ contentChanges: changes, textDocument: { uri: doc.uri, version: doc.version }, bufnr: doc.bufnr } as any)\n      let res = await client.sendRequest('getLastChange') as any\n      expect(res.text).toBe('\\n')\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should will save event","suites":["TextDocumentSynchronization","WillSaveFeature"],"updatePoint":{"line":200,"column":30},"line":200,"code":"    it('should will save event', async () => {\n      let called = false\n      let client = createClient([{ language: 'vim' }], {\n        willSave: (e, next) => {\n          called = true\n          return next(e)\n        }\n      })\n      await client.start()\n      let fsPath = path.join(os.tmpdir(), `${uuidv4()}.vim`)\n      let uri = URI.file(fsPath)\n      await workspace.openResource(uri.toString())\n      let doc = await workspace.document\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'bar')])\n      let feature = client.getFeature(WillSaveTextDocumentNotification.method)\n      let provider = feature.getProvider(doc.textDocument)\n      expect(provider).toBeDefined()\n      await provider.send({ document: doc.textDocument, reason: TextDocumentSaveReason.Manual, waitUntil: () => {} })\n      let res = await client.sendRequest('getLastWillSave') as any\n      expect(res.uri).toBe(doc.uri)\n      await client.stop()\n      expect(called).toBe(true)\n      if (fs.existsSync(fsPath)) {\n        fs.unlinkSync(fsPath)\n      }\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send will save until request","suites":["TextDocumentSynchronization","WillSaveWaitUntilFeature"],"updatePoint":{"line":229,"column":43},"line":229,"code":"    it('should send will save until request', async () => {\n      let client = createClient([{ scheme: 'lsptest' }])\n      await client.start()\n      await client.sendNotification('registerDocumentSync')\n      await helper.wait(30)\n      let fsPath = path.join(os.tmpdir(), `${uuidv4()}-foo.vim`)\n      let uri = URI.file(fsPath)\n      await workspace.openResource(uri.toString())\n      let doc = await workspace.document\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'x')])\n      nvim.command('w', true)\n      await helper.waitValue(() => {\n        return doc.getDocumentContent()\n      }, 'abcx\\n')\n      await client.sendNotification('unregisterDocumentSync')\n      await client.stop()\n      if (fs.existsSync(fsPath)) {\n        fs.unlinkSync(fsPath)\n      }\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on response error","suites":["TextDocumentSynchronization","WillSaveWaitUntilFeature"],"updatePoint":{"line":250,"column":42},"line":250,"code":"    it('should not throw on response error', async () => {\n      let called = false\n      let client = createClient([], {\n        willSaveWaitUntil: (event, next) => {\n          called = true\n          return next(event)\n        }\n      })\n      await client.start()\n      await client.sendNotification('registerDocumentSync')\n      await helper.wait(30)\n      let fsPath = path.join(os.tmpdir(), `${uuidv4()}-error.vim`)\n      let uri = URI.file(fsPath)\n      await workspace.openResource(uri.toString())\n      let doc = await workspace.document\n      await doc.synchronize()\n      nvim.command('w', true)\n      await helper.wait(50)\n      expect(called).toBe(true)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should unregister event handler","suites":["TextDocumentSynchronization","WillSaveWaitUntilFeature"],"updatePoint":{"line":272,"column":39},"line":272,"code":"    it('should unregister event handler', async () => {\n      let client = createClient(null)\n      await client.start()\n      await client.sendNotification('registerDocumentSync')\n      await helper.wait(30)\n      await client.sendNotification('unregisterDocumentSync')\n      await helper.wait(30)\n      await client.stop()\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send did save notification","suites":["TextDocumentSynchronization","DidSaveTextDocumentFeature"],"updatePoint":{"line":284,"column":41},"line":284,"code":"    it('should send did save notification', async () => {\n      let called = false\n      let client = createClient([{ language: 'vim' }], {\n        didSave: (e, next) => {\n          called = true\n          return next(e)\n        }\n      })\n      await client.start()\n      let fsPath = path.join(os.tmpdir(), `${uuidv4()}.vim`)\n      let uri = URI.file(fsPath)\n      await workspace.openResource(uri.toString())\n      let doc = await workspace.document\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'bar')])\n      nvim.command('w', true)\n      await helper.waitValue(() => {\n        return called\n      }, true)\n      let res = await client.sendRequest('getLastWillSave') as any\n      expect(res.uri).toBe(doc.uri)\n      await client.stop()\n      fs.unlinkSync(fsPath)\n    })","file":"client/textSynchronization.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"remove/add","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":74,"column":18},"line":74,"code":"  test('remove/add', async () => {\n    assert.ok(!MessageTransports.is({}))\n    testEvent([removedFolder], [addedFolder], [addedProto], [removedProto])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"remove","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":79,"column":14},"line":79,"code":"  test('remove', async () => {\n    testEvent([removedFolder], [], [], [removedProto])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"remove2","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":83,"column":15},"line":83,"code":"  test('remove2', async () => {\n    testEvent([removedFolder], undefined, [], [removedProto])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"add","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":87,"column":11},"line":87,"code":"  test('add', async () => {\n    testEvent([], [addedFolder], [addedProto], [])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"add2","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":91,"column":12},"line":91,"code":"  test('add2', async () => {\n    testEvent(undefined, [addedFolder], [addedProto], [])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"noChange1","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":95,"column":17},"line":95,"code":"  test('noChange1', async () => {\n    testNoEvent([addedFolder, removedFolder], [addedFolder, removedFolder])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"noChange2","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":99,"column":17},"line":99,"code":"  test('noChange2', async () => {\n    testNoEvent([], [])\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"noChange3","suites":["Workspace Folder Feature Tests"],"updatePoint":{"line":103,"column":17},"line":103,"code":"  test('noChange3', async () => {\n    testNoEvent(undefined, undefined)\n  })","file":"client/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not select complete item","suites":["completion","suggest configurations"],"updatePoint":{"line":54,"column":39},"line":54,"code":"    it('should not select complete item', async () => {\n      helper.updateConfiguration('suggest.noselect', true)\n      await create(['foobar'])\n      let info = await nvim.call('coc#pum#info')\n      expect(info.index).toBe(-1)\n      await nvim.call('coc#pum#select_confirm', [])\n      let line = await nvim.line\n      expect(line).toBe('foobar')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort items by preselect","suites":["completion","suggest configurations"],"updatePoint":{"line":64,"column":38},"line":64,"code":"    it('should sort items by preselect', async () => {\n      helper.updateConfiguration('suggest.noselect', true)\n      disposables.push(sources.createSource({\n        name: 'p',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({\n            items: [{ word: 'foo' }, { word: 'bar', preselect: true }]\n          })\n        })\n      }))\n      await nvim.input('i')\n      await triggerCompletion('p')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'bar')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable preselect feature","suites":["completion","suggest configurations"],"updatePoint":{"line":81,"column":40},"line":81,"code":"    it('should disable preselect feature', async () => {\n      helper.updateConfiguration('suggest.enablePreselect', false)\n      let source: ISource = {\n        enable: true,\n        name: 'preselect',\n        sourceType: SourceType.Service,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }, { word: 'foot', preselect: true }] })\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await triggerCompletion('preselect')\n      await helper.waitPopup()\n      let info = await nvim.call('coc#pum#info')\n      expect(info.index).toBe(0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger with none ascii characters","suites":["completion","suggest configurations"],"updatePoint":{"line":99,"column":49},"line":99,"code":"    it('should trigger with none ascii characters', async () => {\n      helper.updateConfiguration('suggest.asciiCharactersOnly', false)\n      await create([''], false)\n      await nvim.input('')\n      await helper.waitPopup()\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger with none ascii characters","suites":["completion","suggest configurations"],"updatePoint":{"line":106,"column":53},"line":106,"code":"    it('should not trigger with none ascii characters', async () => {\n      helper.updateConfiguration('suggest.asciiCharactersOnly', true)\n      await create([''], false)\n      await nvim.input('')\n      await helper.wait(50)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger with number input","suites":["completion","suggest configurations"],"updatePoint":{"line":115,"column":44},"line":115,"code":"    it('should not trigger with number input', async () => {\n      helper.updateConfiguration('suggest.ignoreRegexps', ['[0-9]+'])\n      await create(['1234', '1984'], false)\n      await nvim.input('1')\n      await helper.wait(50)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select recent used item","suites":["completion","suggest configurations"],"updatePoint":{"line":124,"column":38},"line":124,"code":"    it('should select recent used item', async () => {\n      helper.updateConfiguration('suggest.selection', 'recentlyUsed')\n      let name = await create(['foo', 'bar', 'foobar'])\n      await helper.confirmCompletion(1)\n      await nvim.input('<CR>')\n      await triggerCompletion(name)\n      let info = await nvim.call('coc#pum#info')\n      expect(info.index).toBe(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select recent item by prefix","suites":["completion","suggest configurations"],"updatePoint":{"line":134,"column":43},"line":134,"code":"    it('should select recent item by prefix', async () => {\n      helper.updateConfiguration('suggest.selection', 'recentlyUsedByPrefix')\n      let doc = await workspace.document\n      await nvim.setLine('world')\n      await doc.synchronize()\n      await nvim.input('owo')\n      await helper.visible('world')\n      await nvim.input('<C-y>')\n      await nvim.input('<esc>')\n      await helper.wait(30)\n      await nvim.input('ow')\n      await helper.visible('world')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve timeout sources","suites":["completion","suggest configurations"],"updatePoint":{"line":148,"column":42},"line":148,"code":"    it('should not resolve timeout sources', async () => {\n      helper.updateConfiguration('suggest.timeout', 30)\n      disposables.push(sources.createSource({\n        name: 'timeout',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          setTimeout(() => {\n            resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n          }, 100)\n        })\n      }))\n      await nvim.input('if')\n      await helper.wait(50)\n      let names = await nvim.getVar('coc_timeout_sources')\n      expect(names).toEqual(['timeout'])\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change default sort method","suites":["completion","suggest configurations"],"updatePoint":{"line":164,"column":41},"line":164,"code":"    it('should change default sort method', async () => {\n      const assertWords = async (arr: string[]) => {\n        await helper.waitPopup()\n        let win = await helper.getFloat('pum')\n        let words = await win.getVar('words')\n        expect(words).toEqual(arr)\n      }\n      helper.updateConfiguration('suggest.defaultSortMethod', 'none')\n      disposables.push(sources.createSource({\n        name: 'timeout',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'far' }, { word: 'foobar' }, { word: 'foo' }] })\n        })\n      }))\n      await nvim.input('if')\n      await assertWords(['far', 'foobar', 'foo'])\n      await nvim.input('<esc>')\n      helper.updateConfiguration('suggest.defaultSortMethod', 'alphabetical')\n      await helper.wait(10)\n      await nvim.input('of')\n      await assertWords(['far', 'foo', 'foobar'])\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove duplicated words","suites":["completion","suggest configurations"],"updatePoint":{"line":187,"column":38},"line":187,"code":"    it('should remove duplicated words', async () => {\n      helper.updateConfiguration('suggest.removeDuplicateItems', true)\n      disposables.push(sources.createSource({\n        name: 'dup',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo', dup: 1 }, { word: 'foo', dup: 1 }] })\n        })\n      }))\n      await nvim.input('if')\n      await helper.waitPopup()\n      let win = await helper.getFloat('pum')\n      let words = await win.getVar('words')\n      expect(words).toEqual(['foo'])\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use border with floatConfig","suites":["completion","suggest configurations"],"updatePoint":{"line":202,"column":42},"line":202,"code":"    it('should use border with floatConfig', async () => {\n      helper.updateConfiguration('suggest.floatConfig', {\n        border: true\n      })\n      disposables.push(sources.createSource({\n        name: 'words',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo', kind: 'w', menu: 'x' }, { word: 'foobar', kind: 'w', menu: 'y' }] })\n        })\n      }))\n      await nvim.input('if')\n      await helper.waitPopup()\n      let win = await helper.getFloat('pum')\n      let id = await nvim.call('coc#float#get_related', [win.id, 'border'])\n      expect(id).toBeGreaterThan(1000)\n      helper.updateConfiguration('suggest.floatConfig', {\n        border: true,\n        rounded: true,\n        borderhighlight: 'Normal'\n      })\n      await nvim.input('<esc>')\n      await nvim.input('of')\n      await helper.waitPopup()\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use pumFloatConfig","suites":["completion","suggest configurations"],"updatePoint":{"line":227,"column":33},"line":227,"code":"    it('should use pumFloatConfig', async () => {\n      helper.updateConfiguration('suggest.floatConfig', {})\n      helper.updateConfiguration('suggest.pumFloatConfig', {\n        border: true,\n        highlight: 'Normal',\n        winblend: 15,\n        shadow: true,\n        rounded: true\n      })\n      disposables.push(sources.createSource({\n        name: 'words',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo', kind: 'w', menu: 'x' }, { word: 'foobar', kind: 'w', menu: 'y' }] })\n        })\n      }))\n      await nvim.input('if')\n      await helper.waitPopup()\n      let win = await helper.getFloat('pum')\n      let id = await nvim.call('coc#float#get_related', [win.id, 'border'])\n      expect(id).toBeGreaterThan(1000)\n      let hl = await win.getOption('winhl')\n      expect(hl).toMatch('Normal')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do filter when autoTrigger is none","suites":["completion","suggest configurations"],"updatePoint":{"line":251,"column":49},"line":251,"code":"    it('should do filter when autoTrigger is none', async () => {\n      helper.updateConfiguration('suggest.autoTrigger', 'none')\n      disposables.push(sources.createSource({\n        name: 'words',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n        })\n      }))\n      await nvim.input('i')\n      nvim.call('coc#start', [], true)\n      await helper.waitPopup()\n      expect(completion.activeItems.length).toBe(2)\n      await nvim.input('f')\n      await helper.wait(50)\n      expect(completion.activeItems.length).toBe(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled by b:coc_suggest_disable","suites":["completion","suggest variables"],"updatePoint":{"line":277,"column":51},"line":277,"code":"    it('should be disabled by b:coc_suggest_disable', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setVar('coc_suggest_disable', 1)\n      await nvim.input('if')\n      await helper.wait(30)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled by b:coc_disabled_sources","suites":["completion","suggest variables"],"updatePoint":{"line":286,"column":52},"line":286,"code":"    it('should be disabled by b:coc_disabled_sources', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setVar('coc_disabled_sources', ['foo'])\n      await nvim.input('if')\n      await helper.wait(30)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled by b:coc_suggest_blacklist","suites":["completion","suggest variables"],"updatePoint":{"line":295,"column":53},"line":295,"code":"    it('should be disabled by b:coc_suggest_blacklist', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setVar('coc_suggest_blacklist', ['end'])\n      await nvim.setLine('en')\n      await nvim.input('Ad')\n      await helper.wait(30)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show slow source","suites":["completion","doComplete()"],"updatePoint":{"line":307,"column":31},"line":307,"code":"    it('should show slow source', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'slow',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          setTimeout(() => {\n            resolve({ items: [{ word: 'foo', kind: 'w' }, { word: 'bar' }] })\n          }, 50)\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      let items = await helper.items()\n      expect(items.length).toBe(2)\n      await nvim.input('foo')\n      await helper.wait(50)\n      items = await helper.items()\n      expect(items.length).toBe(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should catch error","suites":["completion","doComplete()"],"updatePoint":{"line":332,"column":26},"line":332,"code":"    it('should catch error', async () => {\n      disposables.push(sources.createSource({\n        name: 'error',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise((resolve, reject) => {\n          reject(new Error('custom error'))\n        })\n      }))\n      await nvim.input('if')\n      await helper.wait(50)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch('')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show items before slow source finished","suites":["completion","doComplete()"],"updatePoint":{"line":345,"column":53},"line":345,"code":"    it('should show items before slow source finished', async () => {\n      let source: ISource = {\n        name: 'fast',\n        enable: true,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n        })\n      }\n      disposables.push(sources.addSource(source))\n      let finished = false\n      let slowSource: ISource = {\n        name: 'slow',\n        enable: true,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          setTimeout(() => {\n            finished = true\n            resolve({ items: [{ word: 'world' }] })\n          }, 100)\n        })\n      }\n      disposables.push(sources.addSource(slowSource))\n      await nvim.input('if')\n      await helper.waitPopup()\n      expect(finished).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on backspace","suites":["completion","doComplete()"],"updatePoint":{"line":371,"column":35},"line":371,"code":"    it('should refresh on backspace', async () => {\n      await nvim.command('inoremap <silent><expr> <backspace> coc#pum#visible() ? \"\\\\<bs>\\\\<c-r>=coc#start()\\\\<CR>\" : \"\\\\<bs>\"')\n      disposables.push(Disposable.create(() => {\n        nvim.command(`iunmap <backspace>`, true)\n      }))\n      let source: ISource = {\n        name: 'fast',\n        enable: true,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo' }, { word: 'foot' }] })\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('ifo')\n      await helper.waitPopup()\n      await nvim.input('<backspace>')\n      await helper.wait(50)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop if no filtered items","suites":["completion","resumeCompletion()"],"updatePoint":{"line":394,"column":40},"line":394,"code":"    it('should stop if no filtered items', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo ')\n      await doc.synchronize()\n      await nvim.input('Af')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      await nvim.input('p')\n      await helper.waitValue(() => {\n        return completion.isActivated\n      }, false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resume after text change","suites":["completion","resumeCompletion()"],"updatePoint":{"line":407,"column":43},"line":407,"code":"    it('should not resume after text change', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo fat')\n      await doc.synchronize()\n      await nvim.input('of')\n      await nvim.setLine('fo')\n      await nvim.call('cursor', [2, 3])\n      await helper.wait(50)\n      expect(completion.isActivated).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop with bad insert on CursorMovedI","suites":["completion","resumeCompletion()"],"updatePoint":{"line":418,"column":51},"line":418,"code":"    it('should stop with bad insert on CursorMovedI', async () => {\n      await nvim.setLine('foo fat')\n      await nvim.input('of')\n      await nvim.setLine('f a')\n      await nvim.call('cursor', [2, 4])\n      await helper.wait(30)\n      let visible = await helper.pumvisible()\n      expect(visible).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate without filtered items","suites":["completion","resumeCompletion()"],"updatePoint":{"line":428,"column":48},"line":428,"code":"    it('should deactivate without filtered items', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo fbi ')\n      await doc.synchronize()\n      await nvim.input('Af')\n      await helper.waitPopup()\n      await nvim.input('c')\n      await helper.waitFor('coc#pum#visible', [], 0)\n      expect(completion.activeItems).toBeUndefined()\n      expect(completion.isActivated).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate when insert space","suites":["completion","resumeCompletion()"],"updatePoint":{"line":440,"column":43},"line":440,"code":"    it('should deactivate when insert space', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'empty',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({ items: [{ word: 'foo bar' }] })\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      let items = await helper.items()\n      expect(items[0].word).toBe('foo bar')\n      await nvim.input(' ')\n      await helper.waitFor('pumvisible', [], 0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use resume input to filter","suites":["completion","resumeCompletion()"],"updatePoint":{"line":461,"column":41},"line":461,"code":"    it('should use resume input to filter', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'source',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: (): Promise<CompleteResult> => new Promise(resolve => {\n          setTimeout(() => {\n            resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n          }, 60)\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.wait(20)\n      await nvim.input('f')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      let items = await helper.items()\n      expect(items.length).toBe(1)\n      expect(items[0].word).toBe('foo')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter slow source","suites":["completion","resumeCompletion()"],"updatePoint":{"line":485,"column":33},"line":485,"code":"    it('should filter slow source', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'slow',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: (): Promise<CompleteResult> => new Promise(resolve => {\n          setTimeout(() => {\n            resolve({ items: [{ word: 'foo' }, { word: 'bar' }] })\n          }, 100)\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.f')\n      await helper.waitPopup()\n      await nvim.input('o')\n      await helper.waitValue((() => {\n        return completion.activeItems?.length\n      }), 1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should complete inComplete source","suites":["completion","resumeCompletion()"],"updatePoint":{"line":507,"column":41},"line":507,"code":"    it('should complete inComplete source', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'inComplete',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n          if (opt.input.length <= 1) {\n            return { isIncomplete: true, items: [{ word: 'foo' }, { word: opt.input }] }\n          }\n          await helper.wait(10)\n          return { isIncomplete: false, items: [{ word: 'foo' }, { word: opt.input }] }\n        }\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      await nvim.input('a')\n      await helper.wait(20)\n      await nvim.input('b')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not complete inComplete source when isIncomplete is false","suites":["completion","resumeCompletion()"],"updatePoint":{"line":531,"column":72},"line":531,"code":"    it('should not complete inComplete source when isIncomplete is false', async () => {\n      let lastOption: CompleteOption\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'inComplete',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n          lastOption = opt\n          await helper.wait(30)\n          if (opt.input.length <= 1) {\n            return { isIncomplete: true, items: [{ word: 'foobar' }] }\n          }\n          return { isIncomplete: false, items: [{ word: 'foobar' }] }\n        }\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n      await nvim.input('fo')\n      await helper.wait(50)\n      await nvim.input('b')\n      await helper.wait(50)\n      expect(completion.isActivated).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter when type character after item selected without handle complete done","suites":["completion","resumeCompletion()"],"updatePoint":{"line":559,"column":90},"line":559,"code":"    it('should filter when type character after item selected without handle complete done', async () => {\n      let input: string\n      let fn = jest.fn()\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'filter',\n        sourceType: SourceType.Service,\n        doComplete: (opt): Promise<CompleteResult> => {\n          input = opt.input\n          if (input == 'f') return Promise.resolve({ items: [{ word: 'fo' }] })\n          if (input == 'foo') return Promise.resolve({ items: [{ word: 'foobar' }, { word: 'foot' }] })\n          return Promise.resolve({ items: [] })\n        },\n        onCompleteDone: () => {\n          fn()\n        }\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await nvim.input('<C-n>')\n      await helper.wait(20)\n      await nvim.input('o')\n      await helper.waitPopup()\n      expect(fn).toBeCalledTimes(0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect commitCharacter on TextChangedI","suites":["completion","TextChangedI"],"updatePoint":{"line":589,"column":54},"line":589,"code":"    it('should respect commitCharacter on TextChangedI', async () => {\n      helper.updateConfiguration('suggest.acceptSuggestionOnCommitCharacter', true)\n      let source: ISource = {\n        enable: true,\n        name: 'commit',\n        sourceType: SourceType.Service,\n        triggerCharacters: ['.'],\n        doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n          if (opt.triggerCharacter == '.') {\n            return Promise.resolve({ items: [{ word: 'bar' }] })\n          }\n          return Promise.resolve({ items: [{ word: 'foo' }] })\n        },\n        shouldCommit: (_item, character) => character == '.'\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await nvim.input('.')\n      await helper.waitFor('getline', ['.'], 'foo.')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop when input length below option input length","suites":["completion","TextChangedP"],"updatePoint":{"line":613,"column":63},"line":613,"code":"    it('should stop when input length below option input length', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo fbi ')\n      await doc.synchronize()\n      await nvim.input('Af')\n      await helper.waitPopup()\n      await nvim.input('<backspace>')\n      await helper.waitFor('getline', ['.'], 'foo fbi ')\n      expect(completion.isActivated).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter on none keyword input","suites":["completion","TextChangedP"],"updatePoint":{"line":624,"column":43},"line":624,"code":"    it('should filter on none keyword input', async () => {\n      let source: ISource = {\n        priority: 99,\n        enable: true,\n        name: 'temp',\n        sourceType: SourceType.Service,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo#abc' }] }),\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await nvim.input('#')\n      await helper.wait(50)\n      let items = await helper.getItems()\n      expect(items[0].word).toBe('foo#abc')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel on InsertLeave","suites":["completion","TextChangedP"],"updatePoint":{"line":641,"column":36},"line":641,"code":"    it('should cancel on InsertLeave', async () => {\n      let source: ISource = {\n        priority: 99,\n        enable: true,\n        name: 'temp',\n        sourceType: SourceType.Service,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo#abc' }] }),\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      expect(completion.isActivated).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel on CursorMoved","suites":["completion","TextChangedP"],"updatePoint":{"line":657,"column":36},"line":657,"code":"    it('should cancel on CursorMoved', async () => {\n      let buf = await nvim.buffer\n      await buf.setLines(['', 'bar'], { start: 0, end: -1, strictIndexing: false })\n      let source: ISource = {\n        priority: 99,\n        enable: true,\n        name: 'temp',\n        sourceType: SourceType.Service,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo#abc' }] }),\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('if')\n      await helper.waitPopup()\n      void events.fire('CompleteDone', [{}])\n      await helper.wait(10)\n      await events.fire('CursorMovedI', [buf.id, [2, 1]])\n      expect(completion.isActivated).toBe(false)\n      await nvim.input('<esc>')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use source-provided score","suites":["completion","TextChangedP"],"updatePoint":{"line":677,"column":40},"line":677,"code":"    it('should use source-provided score', async () => {\n      let source: ISource = {\n        priority: 0,\n        enable: true,\n        name: 'source',\n        sourceType: SourceType.Service,\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({\n          items: [\n            { word: 'candidate_a', sourceScore: 0.1 },\n            { word: 'candidate_b', sourceScore: 10 },\n            { word: 'candidate_c' },\n          ]\n        }),\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('ocand')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items[0].word).toBe('candidate_b')\n      expect(items[1].word).toBe('candidate_c')\n      expect(items[2].word).toBe('candidate_a')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do resolve for complete item","suites":["completion","onCompleteResolve"],"updatePoint":{"line":706,"column":43},"line":706,"code":"    it('should do resolve for complete item', async () => {\n      let resolved = false\n      disposables.push(sources.createSource({\n        name: 'resolve',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo' }] }),\n        onCompleteResolve: item => {\n          resolved = true\n          item.info = 'detail'\n        }\n      }))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], '.foo')\n      expect(resolved).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel resolve request","suites":["completion","onCompleteResolve"],"updatePoint":{"line":723,"column":37},"line":723,"code":"    it('should cancel resolve request', async () => {\n      let called = false\n      disposables.push(sources.createSource({\n        name: 'resolve',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo' }] }),\n        onCompleteResolve: async item => {\n          called = true\n          await helper.wait(100)\n          item.info = 'info'\n        }\n      }))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      nvim.call('coc#pum#cancel', [], true)\n      await helper.wait(30)\n      expect(called).toBe(true)\n      let floatWin = await helper.getFloat('pumdetail')\n      expect(floatWin).toBeUndefined()\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw error","suites":["completion","onCompleteResolve"],"updatePoint":{"line":743,"column":30},"line":743,"code":"    it('should not throw error', async () => {\n      let called = false\n      disposables.push(sources.createSource({\n        name: 'resolve',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo' }] }),\n        onCompleteResolve: async item => {\n          called = true\n          throw new Error('custom error')\n        }\n      }))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      expect(called).toBe(true)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline.includes('error')).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should timeout on resolve","suites":["completion","onCompleteResolve"],"updatePoint":{"line":760,"column":33},"line":760,"code":"    it('should timeout on resolve', async () => {\n      let called = false\n      disposables.push(sources.createSource({\n        name: 'resolve',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => Promise.resolve({ items: [{ word: 'foo' }] }),\n        onCompleteResolve: async item => {\n          called = true\n          await helper.wait(200)\n          item.info = 'info'\n        }\n      }))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      await helper.wait(200)\n      expect(called).toBe(true)\n      let floatWin = await helper.getFloat('pumdetail')\n      expect(floatWin).toBeUndefined()\n\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix word on CompleteDone","suites":["completion","CompleteDone"],"updatePoint":{"line":782,"column":39},"line":782,"code":"    it('should fix word on CompleteDone', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('fball football')\n      await doc.synchronize()\n      await nvim.input('i')\n      await nvim.call('cursor', [1, 2])\n      let option: CompleteOption = await nvim.call('coc#util#get_complete_option')\n      await completion.startCompletion(option)\n      await helper.waitPopup()\n      let items = await helper.items()\n      expect(items.length).toBe(1)\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'football football')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger completion if triggerAfterInsertEnter is true","suites":["completion","InsertEnter"],"updatePoint":{"line":803,"column":68},"line":803,"code":"    it('should trigger completion if triggerAfterInsertEnter is true', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo fo')\n      await doc.synchronize()\n      await nvim.input('A')\n      await doc.synchronize()\n      await helper.waitPopup()\n      expect(completion.isActivated).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger when input length too small","suites":["completion","InsertEnter"],"updatePoint":{"line":813,"column":54},"line":813,"code":"    it('should not trigger when input length too small', async () => {\n      await nvim.setLine('foo ')\n      await nvim.input('A')\n      await helper.wait(30)\n      expect(completion.isActivated).toBe(false)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger complete on trigger patterns match","suites":["completion","trigger completion"],"updatePoint":{"line":822,"column":57},"line":822,"code":"    it('should trigger complete on trigger patterns match', async () => {\n      let source: ISource = {\n        priority: 99,\n        enable: true,\n        name: 'temp',\n        triggerPatterns: [/EM/],\n        sourceType: SourceType.Service,\n        doComplete: (opt: CompleteOption): Promise<CompleteResult> => {\n          if (!opt.input.startsWith('EM')) return null\n          return Promise.resolve({\n            items: [\n              { word: 'foo', filterText: 'EMfoo' },\n              { word: 'bar', filterText: 'EMbar' }\n            ]\n          })\n        },\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await nvim.input('EM')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items.length).toBe(2)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel on backspace","suites":["completion","trigger completion"],"updatePoint":{"line":847,"column":34},"line":847,"code":"    it('should cancel on backspace', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      await doc.synchronize()\n      await nvim.input('of')\n      let res = await helper.visible('foo', 'around')\n      expect(res).toBe(true)\n      await nvim.input('<backspace>')\n      await helper.waitFor('pumvisible', [], 0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on first letter insert","suites":["completion","trigger completion"],"updatePoint":{"line":858,"column":45},"line":858,"code":"    it('should trigger on first letter insert', async () => {\n      await nvim.setLine('foo bar')\n      await helper.wait(30)\n      await nvim.input('of')\n      let res = await helper.visible('foo', 'around')\n      expect(res).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on force refresh","suites":["completion","trigger completion"],"updatePoint":{"line":866,"column":39},"line":866,"code":"    it('should trigger on force refresh', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo f')\n      await doc.synchronize()\n      await nvim.input('A')\n      await nvim.call('coc#start')\n      let res = await helper.visible('foo', 'around')\n      expect(res).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter and sort on increment search","suites":["completion","trigger completion"],"updatePoint":{"line":876,"column":50},"line":876,"code":"    it('should filter and sort on increment search', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('forceDocumentSync format  fallback')\n      await doc.synchronize()\n      await nvim.input('of')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      await nvim.input('oa')\n      await helper.waitPopup()\n      items = await helper.getItems()\n      expect(items.findIndex(o => o.word == 'fallback')).toBe(-1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger on insert enter","suites":["completion","trigger completion"],"updatePoint":{"line":889,"column":42},"line":889,"code":"    it('should not trigger on insert enter', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      await doc.synchronize()\n      await nvim.input('o')\n      let visible = await nvim.call('pumvisible')\n      expect(visible).toBe(0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter on fast input","suites":["completion","trigger completion"],"updatePoint":{"line":898,"column":35},"line":898,"code":"    it('should filter on fast input', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      await doc.synchronize()\n      await nvim.input('oba')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      let item = items.find(o => o.word == 'foo')\n      expect(item).toBeFalsy()\n      expect(items[0].word).toBe('bar')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter completion when type none trigger character","suites":["completion","trigger completion"],"updatePoint":{"line":910,"column":65},"line":910,"code":"    it('should filter completion when type none trigger character', async () => {\n      let source: ISource = {\n        name: 'test',\n        priority: 10,\n        enable: true,\n        firstMatch: false,\n        sourceType: SourceType.Native,\n        triggerCharacters: [],\n        doComplete: async (): Promise<CompleteResult> => {\n          let result: CompleteResult = {\n            items: [{ word: 'if(' }]\n          }\n          return Promise.resolve(result)\n        }\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.setLine('')\n      await nvim.input('iif')\n      await helper.waitPopup()\n      await nvim.input('(')\n      await helper.wait(50)\n      let res = await helper.pumvisible()\n      expect(res).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on triggerCharacters","suites":["completion","trigger completion"],"updatePoint":{"line":935,"column":43},"line":935,"code":"    it('should trigger on triggerCharacters', async () => {\n      let source: ISource = {\n        name: 'trigger',\n        enable: true,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      let source1: ISource = {\n        name: 'trigger1',\n        enable: true,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'bar' }]\n        })\n      }\n      disposables.push(sources.addSource(source1))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items.length).toBe(2)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix start column","suites":["completion","trigger completion"],"updatePoint":{"line":960,"column":31},"line":960,"code":"    it('should fix start column', async () => {\n      let source: ISource = {\n        name: 'test',\n        priority: 10,\n        enable: true,\n        firstMatch: false,\n        sourceType: SourceType.Native,\n        triggerCharacters: [],\n        doComplete: async (): Promise<CompleteResult> => {\n          let result: CompleteResult = {\n            startcol: 0,\n            items: [{ word: 'foo.bar' }]\n          }\n          return Promise.resolve(result)\n        }\n      }\n      let disposable = sources.addSource(source)\n      await nvim.setLine('foo.')\n      await nvim.input('Ab')\n      await helper.waitPopup()\n      let val = await nvim.getVar('coc#_context') as any\n      expect(val.start).toBe(0)\n      disposable.dispose()\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should complete items without input","suites":["completion","trigger completion"],"updatePoint":{"line":985,"column":50},"line":985,"code":"    it('should should complete items without input', async () => {\n      await workspace.document\n      let source: ISource = {\n        enable: true,\n        name: 'trigger',\n        priority: 10,\n        sourceType: SourceType.Native,\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo' }, { word: 'bar' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.command('inoremap <silent><nowait><expr> <c-space> coc#refresh()')\n      await nvim.input('i')\n      await helper.wait(30)\n      await nvim.input('<c-space>')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items.length).toBeGreaterThan(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show float window","suites":["completion","trigger completion"],"updatePoint":{"line":1006,"column":32},"line":1006,"code":"    it('should show float window', async () => {\n      let source: ISource = {\n        name: 'float',\n        priority: 10,\n        enable: true,\n        sourceType: SourceType.Native,\n        doComplete: (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo', info: 'bar' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await helper.wait(30)\n      await nvim.input('f')\n      await helper.waitPopup()\n      await helper.wait(100)\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(1)\n      let res = await helper.visible('foo', 'float')\n      expect(res).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger on triggerPatterns","suites":["completion","trigger completion"],"updatePoint":{"line":1028,"column":41},"line":1028,"code":"    it('should trigger on triggerPatterns', async () => {\n      let source: ISource = {\n        name: 'pattern',\n        priority: 10,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerPatterns: [/\\w+\\.$/],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await helper.wait(10)\n      await nvim.input('.')\n      await helper.wait(30)\n      let pumvisible = await nvim.call('pumvisible')\n      expect(pumvisible).toBe(0)\n      await nvim.input('a')\n      await helper.wait(30)\n      await nvim.input('.')\n      await helper.waitPopup()\n      let res = await helper.visible('foo', 'pattern')\n      expect(res).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger triggerOnly source","suites":["completion","trigger completion"],"updatePoint":{"line":1054,"column":45},"line":1054,"code":"    it('should not trigger triggerOnly source', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      await doc.synchronize()\n      let source: ISource = {\n        name: 'pattern',\n        triggerOnly: true,\n        priority: 10,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerPatterns: [/^From:\\s*/],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('of')\n      let res = await helper.visible('foo', 'around')\n      expect(res).toBe(true)\n      let items = await helper.items()\n      expect(items.length).toBe(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not trigger when cursor moved","suites":["completion","trigger completion"],"updatePoint":{"line":1077,"column":44},"line":1077,"code":"    it('should not trigger when cursor moved', async () => {\n      let source: ISource = {\n        name: 'trigger',\n        priority: 10,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo' }]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.setLine('.a')\n      await nvim.input('A')\n      await nvim.eval('feedkeys(\"\\\\<bs>\")')\n      await helper.wait(10)\n      await nvim.eval('feedkeys(\"\\\\<left>\")')\n      await helper.wait(20)\n      let visible = await nvim.call('pumvisible')\n      expect(visible).toBe(0)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger when completion is not completed","suites":["completion","trigger completion"],"updatePoint":{"line":1099,"column":55},"line":1099,"code":"    it('should trigger when completion is not completed', async () => {\n      let token: CancellationToken\n      let promise = new Promise(resolve => {\n        let source: ISource = {\n          name: 'completion',\n          priority: 10,\n          enable: true,\n          sourceType: SourceType.Native,\n          triggerCharacters: ['.'],\n          doComplete: async (opt, cancellationToken): Promise<CompleteResult> => {\n            if (opt.triggerCharacter != '.') {\n              token = cancellationToken\n              resolve(undefined)\n              return new Promise<CompleteResult>((resolve, reject) => {\n                let timer = setTimeout(() => {\n                  resolve({ items: [{ word: 'foo' }] })\n                }, 200)\n                if (cancellationToken.isCancellationRequested) {\n                  clearTimeout(timer)\n                  reject(new Error('Cancelled'))\n                }\n              })\n            }\n            return Promise.resolve({\n              items: [{ word: 'bar' }]\n            })\n          }\n        }\n        disposables.push(sources.addSource(source))\n      })\n      await nvim.input('if')\n      await promise\n      await nvim.input('.')\n      await helper.waitPopup()\n      await helper.visible('bar', 'completion')\n      expect(token).toBeDefined()\n      expect(token.isCancellationRequested).toBe(true)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should limit results for low priority source","suites":["completion","completion results"],"updatePoint":{"line":1140,"column":52},"line":1140,"code":"    it('should limit results for low priority source', async () => {\n      let doc = await workspace.document\n      helper.updateConfiguration('suggest.lowPrioritySourceLimit', 2)\n      await nvim.setLine('filename filepath find filter findIndex')\n      await doc.synchronize()\n      await nvim.input('of')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      items = items.filter(o => o.source == 'around')\n      expect(items.length).toBe(2)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should limit result for high priority source","suites":["completion","completion results"],"updatePoint":{"line":1152,"column":52},"line":1152,"code":"    it('should limit result for high priority source', async () => {\n      helper.updateConfiguration('suggest.highPrioritySourceLimit', 2)\n      let source: ISource = {\n        name: 'high',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: ['filename', 'filepath', 'filter', 'file'].map(key => ({ word: key }))\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items.length).toBeGreaterThan(1)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should truncate label of complete items","suites":["completion","completion results"],"updatePoint":{"line":1171,"column":47},"line":1171,"code":"    it('should truncate label of complete items', async () => {\n      helper.updateConfiguration('suggest.formatItems', ['abbr'])\n      helper.updateConfiguration('suggest.labelMaxLength', 10)\n      let source: ISource = {\n        name: 'high',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: ['a', 'b', 'c', 'd'].map(key => ({ word: key.repeat(20) }))\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      let winid = await nvim.call('coc#float#get_float_by_kind', ['pum'])\n      let win = nvim.createWindow(winid)\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines[0].trim().length).toBe(10)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render labelDetails","suites":["completion","completion results"],"updatePoint":{"line":1194,"column":34},"line":1194,"code":"    it('should render labelDetails', async () => {\n      helper.updateConfiguration('suggest.formatItems', ['abbr'])\n      helper.updateConfiguration('suggest.labelMaxLength', 10)\n      disposables.push(sources.createSource({\n        name: 'test',\n        doComplete: (_opt: CompleteOption): Promise<CompleteResult> => new Promise(resolve => {\n          resolve({\n            items: [{\n              word: 'x',\n              labelDetails: {\n                detail: 'foo',\n                description: 'bar'\n              }\n            }, {\n              word: 'y'.repeat(8),\n              labelDetails: {\n                detail: 'a'.repeat(20),\n                description: 'b'.repeat(20)\n              }\n            }]\n          })\n        })\n      }))\n      await nvim.input('i')\n      await triggerCompletion('test')\n      await helper.waitPopup()\n      let winid = await nvim.call('coc#float#get_float_by_kind', ['pum'])\n      let win = nvim.createWindow(winid)\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines.length).toBe(2)\n      expect(lines[0]).toMatch(/xfoo bar/)\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete previous items when complete items is null","suites":["completion","completion results"],"updatePoint":{"line":1228,"column":64},"line":1228,"code":"    it('should delete previous items when complete items is null', async () => {\n      let source1: ISource = {\n        name: 'source1',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerCharacters: ['.'],\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [{ word: 'foo', dup: 1 }]\n        })\n      }\n      let source2: ISource = {\n        name: 'source2',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        triggerCharacters: ['.'],\n        doComplete: async (opt: CompleteOption): Promise<CompleteResult> => {\n          let result: CompleteResult = opt.input == 'foo' ? null : {\n            items: [{ word: 'foo', dup: 1 }], isIncomplete: true\n          }\n          return Promise.resolve(result)\n        }\n      }\n      disposables.push(sources.addSource(source1))\n      disposables.push(sources.addSource(source2))\n      await nvim.input('i')\n      await nvim.input('.f')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      expect(items.length).toEqual(2)\n      await nvim.input('oo')\n      await helper.waitValue(() => {\n        return completion.activeItems?.length\n      }, 1)\n      items = await helper.getItems()\n      expect(items.length).toEqual(1)\n      expect(items[0].word).toBe('foo')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent line after completion #1","suites":["completion","indent change"],"updatePoint":{"line":1270,"column":46},"line":1270,"code":"    it('should indent line after completion #1', async () => {\n      let doc = await workspace.document as any\n      doc._indentkeys = '=~end,0=\\\\item'\n      let source: ISource = {\n        name: 'source1',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [\n            { word: 'item' },\n            { word: 'items' },\n            { word: 'END' },\n            { word: 'ENDIF' }\n          ]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await helper.wait(10)\n      await nvim.input('  \\\\ite')\n      await helper.waitPopup()\n      let idx = completion.activeItems.findIndex(o => o.word == 'item')\n      await helper.confirmCompletion(idx)\n      await helper.waitFor('getline', ['.'], '\\\\item')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger completion after indent change","suites":["completion","indent change"],"updatePoint":{"line":1297,"column":53},"line":1297,"code":"    it('should trigger completion after indent change', async () => {\n      await helper.createDocument('t.vim')\n      // doc._indentkeys = '=end'\n      let source: ISource = {\n        name: 'source1',\n        priority: 90,\n        enable: true,\n        sourceType: SourceType.Native,\n        doComplete: async (): Promise<CompleteResult> => Promise.resolve({\n          items: [\n            { word: 'endif' },\n            { word: 'endfunction' }\n          ]\n        })\n      }\n      disposables.push(sources.addSource(source))\n      await nvim.input('i')\n      await helper.wait(10)\n      await nvim.input('  endi')\n      await helper.waitPopup()\n      await nvim.input('f')\n      await helper.wait(10)\n      await nvim.command('normal! ==')\n      await helper.waitFor('getline', ['.'], 'endif')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep selected text after text change","suites":["completion","Character insert"],"updatePoint":{"line":1347,"column":51},"line":1347,"code":"    it('should keep selected text after text change', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('f')\n      await nvim.input('A')\n      await doc.synchronize()\n      await triggerCompletion('insert')\n      await helper.waitPopup()\n      let line = await nvim.line\n      expect(line).toBe('f')\n      await nvim.exec(`\n         noa call setline('.', 'foobar')\n         noa call cursor(1, 7)\n         `)\n      await helper.wait(50)\n      let res = await helper.pumvisible()\n      expect(res).toBe(false)\n      line = await nvim.line\n      expect(line).toBe('foobar')\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger specific sources by api","suites":["completion","Character insert"],"updatePoint":{"line":1367,"column":46},"line":1367,"code":"    it('should trigger specific sources by api', async () => {\n      let text = 'foo bar f'\n      await nvim.setLine(text)\n      await nvim.input('A')\n      await triggerCompletion('insert')\n      await helper.waitPopup()\n    })","file":"completion/basic.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel float window","suites":["completion float"],"updatePoint":{"line":43,"column":32},"line":43,"code":"  it('should cancel float window', async () => {\n    await helper.edit()\n    await nvim.input('if')\n    await helper.visible('foo', 'float')\n    let items = await helper.getItems()\n    expect(items[0].word).toBe('foo')\n    expect(items[0].info.length > 0).toBeTruthy()\n    await helper.confirmCompletion(0)\n    let hasFloat = await nvim.call('coc#float#has_float')\n    expect(hasFloat).toBe(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust float window position","suites":["completion float"],"updatePoint":{"line":55,"column":41},"line":55,"code":"  it('should adjust float window position', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    let floatWin = await helper.getFloat('pumdetail')\n    let config = await floatWin.getConfig()\n    expect(config.col + config.width).toBeLessThan(180)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should redraw float window on item change","suites":["completion float"],"updatePoint":{"line":65,"column":47},"line":65,"code":"  it('should redraw float window on item change', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.call('coc#pum#select', [1, 1, 0])\n    let floatWin = await helper.getFloat('pumdetail')\n    let buf = await floatWin.buffer\n    let lines = await buf.lines\n    expect(lines.length).toBeGreaterThan(0)\n    expect(lines[0]).toMatch('foot')\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide float window when item info is empty","suites":["completion float"],"updatePoint":{"line":78,"column":54},"line":78,"code":"  it('should hide float window when item info is empty', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.call('coc#pum#select', [2, 1, 0])\n    let floatWin = await helper.getFloat('pumdetail')\n    expect(floatWin).toBeUndefined()\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide float window after completion","suites":["completion float"],"updatePoint":{"line":88,"column":47},"line":88,"code":"  it('should hide float window after completion', async () => {\n    await helper.edit()\n    await nvim.setLine(' '.repeat(70))\n    await nvim.input('Af')\n    await helper.visible('foo', 'float')\n    await nvim.input('<C-n>')\n    await helper.wait(30)\n    await nvim.input('<C-y>')\n    await helper.wait(30)\n    let floatWin = await helper.getFloat('pumdetail')\n    expect(floatWin).toBeUndefined()\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not shown with empty lines","suites":["float config"],"updatePoint":{"line":138,"column":39},"line":138,"code":"  it('should not shown with empty lines', async () => {\n    await createFloat({}, [{ filetype: 'txt', content: '' }])\n    let floatWin = await helper.getFloat('pumdetail')\n    expect(floatWin).toBeUndefined()\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show window with border","suites":["float config"],"updatePoint":{"line":144,"column":36},"line":144,"code":"  it('should show window with border', async () => {\n    await createFloat({ border: true })\n    let winid = await getFloat()\n    expect(winid).toBeGreaterThan(0)\n    let id = await getRelated(winid, 'border')\n    expect(id).toBeGreaterThan(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change window highlights","suites":["float config"],"updatePoint":{"line":152,"column":37},"line":152,"code":"  it('should change window highlights', async () => {\n    await createFloat({ border: true, highlight: 'WarningMsg', borderhighlight: 'MoreMsg' })\n    let winid = await getFloat()\n    expect(winid).toBeGreaterThan(0)\n    let win = nvim.createWindow(winid)\n    let res = await win.getOption('winhl') as string\n    expect(res).toMatch('WarningMsg')\n    let id = await getRelated(winid, 'border')\n    expect(id).toBeGreaterThan(0)\n    win = nvim.createWindow(id)\n    res = await win.getOption('winhl') as string\n    expect(res).toMatch('MoreMsg')\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add shadow and winblend","suites":["float config"],"updatePoint":{"line":166,"column":36},"line":166,"code":"  it('should add shadow and winblend', async () => {\n    await createFloat({ shadow: true, winblend: 30 })\n    let winid = await getFloat()\n    expect(winid).toBeGreaterThan(0)\n  })","file":"completion/float.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get kind text","suites":["getKindString()"],"updatePoint":{"line":29,"column":26},"line":29,"code":"  it('should get kind text', async () => {\n    let map = new Map()\n    map.set(CompletionItemKind.Enum, 'E')\n    let res = getKindString(CompletionItemKind.Enum, map, '')\n    expect(res).toBe('E')\n  })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get default value","suites":["getKindString()"],"updatePoint":{"line":36,"column":30},"line":36,"code":"  it('should get default value', async () => {\n    let map = new Map()\n    let res = getKindString(CompletionItemKind.Enum, map, 'D')\n    expect(res).toBe('D')\n  })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get start col","suites":["getStartColumn()"],"updatePoint":{"line":44,"column":26},"line":44,"code":"  it('should get start col', async () => {\n    expect(getStartColumn('', [{ label: 'foo' }])).toBe(undefined)\n    expect(getStartColumn('', [{ label: 'foo' }], { editRange: Range.create(0, 0, 0, 3) })).toBe(0)\n    expect(getStartColumn('', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 0), 'a') },\n      { label: 'bar' }])).toBe(undefined)\n    expect(getStartColumn('foo', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 0), 'a') },\n      { label: 'bar', textEdit: TextEdit.insert(Position.create(0, 1), 'b') }])).toBe(undefined)\n    expect(getStartColumn('foo', [\n      { label: 'foo', textEdit: TextEdit.insert(Position.create(0, 2), 'a') },\n      { label: 'bar', textEdit: TextEdit.insert(Position.create(0, 2), 'b') }])).toBe(2)\n  })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use range from textEdit","suites":["getRange()"],"updatePoint":{"line":60,"column":36},"line":60,"code":"  it('should use range from textEdit', async () => {\n    let item = { label: 'foo', textEdit: TextEdit.replace(Range.create(0, 1, 0, 3), 'foo') }\n    let res = getRange(item, { editRange: Range.create(0, 0, 0, 0) })\n    expect(res).toEqual(Range.create(0, 1, 0, 3))\n  })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use range from itemDefaults","suites":["getRange()"],"updatePoint":{"line":66,"column":40},"line":66,"code":"  it('should use range from itemDefaults', async () => {\n    let item = { label: 'foo' }\n    expect(getRange(item, { editRange: Range.create(0, 0, 0, 1) })).toEqual(Range.create(0, 0, 0, 1))\n    expect(getRange(item, { editRange: InsertReplaceEdit.create('', Range.create(0, 0, 0, 0), Range.create(0, 0, 0, 1)) })).toEqual(Range.create(0, 0, 0, 1))\n  })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show labelDetails to documentation window","suites":["language source","labelDetails"],"updatePoint":{"line":75,"column":56},"line":75,"code":"    it('should show labelDetails to documentation window', async () => {\n      helper.updateConfiguration('suggest.labelMaxLength', 10)\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'foo',\n          labelDetails: {\n            detail: 'foo'.repeat(5)\n          }\n        }, {\n          label: 'bar',\n          labelDetails: {\n            description: 'bar'.repeat(5)\n          }\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('i')\n      await nvim.call('coc#start', { source: 'edits' })\n      let winid: number\n      await helper.waitValue(async () => {\n        winid = await nvim.call('coc#float#get_float_by_kind', ['pumdetail'])\n        return winid > 0\n      }, true)\n      let lines = await helper.getLines(winid)\n      expect(lines[0]).toMatch('foo')\n      await nvim.call('coc#pum#next', [1])\n      await helper.waitValue(async () => {\n        lines = await helper.getLines(winid)\n        return lines.join(' ').includes('bar')\n      }, true)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with plain text on additionalTextEdits","suites":["language source","additionalTextEdits"],"updatePoint":{"line":109,"column":73},"line":109,"code":"    it('should fix cursor position with plain text on additionalTextEdits', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'foo',\n          filterText: 'foo',\n          additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'a\\nbar')]\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'barfoo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with snippet on additionalTextEdits","suites":["language source","additionalTextEdits"],"updatePoint":{"line":124,"column":70},"line":124,"code":"    it('should fix cursor position with snippet on additionalTextEdits', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'if',\n          insertTextFormat: InsertTextFormat.Snippet,\n          textEdit: { range: Range.create(0, 0, 0, 1), newText: 'if($1)' },\n          additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n          preselect: true\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('ii')\n      await helper.waitPopup()\n      let res = await helper.getItems()\n      let idx = res.findIndex(o => o.source == 'edits')\n      await helper.confirmCompletion(idx)\n      await helper.waitFor('col', ['.'], 8)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with plain text snippet on additionalTextEdits","suites":["language source","additionalTextEdits"],"updatePoint":{"line":143,"column":81},"line":143,"code":"    it('should fix cursor position with plain text snippet on additionalTextEdits', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'if',\n          insertTextFormat: InsertTextFormat.Snippet,\n          textEdit: { range: Range.create(0, 0, 0, 2), newText: 'do$0' },\n          additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n          preselect: true\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('iif')\n      await helper.waitPopup()\n      let items = await helper.getItems()\n      let idx = items.findIndex(o => o.word == 'do' && o.source == 'edits')\n      await helper.confirmCompletion(idx)\n      await helper.waitFor('getline', ['.'], 'bar do')\n      await helper.waitFor('col', ['.'], 7)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position with nested snippet on additionalTextEdits","suites":["language source","additionalTextEdits"],"updatePoint":{"line":163,"column":77},"line":163,"code":"    it('should fix cursor position with nested snippet on additionalTextEdits', async () => {\n      let res = await snippetManager.insertSnippet('func($1)$0')\n      expect(res).toBe(true)\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'if',\n          insertTextFormat: InsertTextFormat.Snippet,\n          insertText: 'do$0',\n          additionalTextEdits: [TextEdit.insert(Position.create(0, 0), 'bar ')],\n          preselect: true\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'bar func(do)')\n      let [, lnum, col] = await nvim.call('getcurpos')\n      expect(lnum).toBe(1)\n      expect(col).toBe(12)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix cursor position and keep placeholder with snippet on additionalTextEdits","suites":["language source","additionalTextEdits"],"updatePoint":{"line":185,"column":91},"line":185,"code":"    it('should fix cursor position and keep placeholder with snippet on additionalTextEdits', async () => {\n      let text = 'foo0bar1'\n      await nvim.setLine(text)\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'var',\n          insertTextFormat: InsertTextFormat.Snippet,\n          textEdit: { range: Range.create(0, text.length + 1, 0, text.length + 1), newText: '${1:foo} = foo0bar1' },\n          additionalTextEdits: [TextEdit.del(Range.create(0, 0, 0, text.length + 1))],\n          preselect: true\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']))\n      await nvim.input('A.')\n      await helper.waitPopup()\n      let res = await helper.getItems()\n      let idx = res.findIndex(o => o.source == 'edits')\n      await helper.confirmCompletion(idx)\n      await helper.waitFor('getline', ['.'], 'foo = foo0bar1')\n      await helper.wait(50)\n      expect(snippetManager.session).toBeDefined()\n      let [, lnum, col] = await nvim.call('getcurpos')\n      expect(lnum).toBe(1)\n      expect(col).toBe(3)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel current snippet session when additionalTextEdits inside snippet","suites":["language source","additionalTextEdits"],"updatePoint":{"line":211,"column":85},"line":211,"code":"    it('should cancel current snippet session when additionalTextEdits inside snippet', async () => {\n      await nvim.input('i')\n      await snippetManager.insertSnippet('foo($1, $2)$0', true)\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'bar',\n          insertTextFormat: InsertTextFormat.Snippet,\n          textEdit: { range: Range.create(0, 4, 0, 5), newText: 'bar($1)' },\n          additionalTextEdits: [TextEdit.del(Range.create(0, 0, 0, 3))]\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']))\n      await nvim.input('b')\n      await helper.waitPopup()\n      let res = await helper.getItems()\n      let idx = res.findIndex(o => o.source == 'edits')\n      await helper.confirmCompletion(idx)\n      await helper.waitFor('getline', ['.'], '(bar(), )')\n      let col = await nvim.call('col', ['.'])\n      expect(col).toBe(6)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix input for snippet item","suites":["language source","filterText"],"updatePoint":{"line":235,"column":41},"line":235,"code":"    it('should fix input for snippet item', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'foo',\n          filterText: 'foo',\n          insertText: '${1:foo}($2)',\n          insertTextFormat: InsertTextFormat.Snippet,\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('snippets-test', 'st', null, provider))\n      await nvim.input('if')\n      await helper.waitPopup()\n      await helper.selectItem('foo')\n      await helper.waitFor('getline', ['.'], 'foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix filterText of complete item","suites":["language source","filterText"],"updatePoint":{"line":251,"column":46},"line":251,"code":"    it('should fix filterText of complete item', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'name',\n          sortText: '11',\n          textEdit: {\n            range: Range.create(0, 1, 0, 2),\n            newText: '?.name'\n          }\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('name', 'N', null, provider, ['.']))\n      await nvim.setLine('t')\n      await nvim.input('A.')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      let line = await nvim.line\n      expect(line).toBe('t?.name')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter in complete request","suites":["language source","inComplete result"],"updatePoint":{"line":273,"column":41},"line":273,"code":"    it('should filter in complete request', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (doc, pos, token, context): Promise<CompletionList> => {\n          let option = (context as any).option\n          if (context.triggerCharacter == '.') {\n            return {\n              isIncomplete: true,\n              items: [\n                {\n                  label: 'foo'\n                }, {\n                  label: 'bar'\n                }\n              ]\n            }\n          }\n          if (option.input == 'f') {\n            if (token.isCancellationRequested) return\n            return {\n              isIncomplete: true,\n              items: [\n                {\n                  label: 'foo'\n                }\n              ]\n            }\n          }\n          if (option.input == 'fo') {\n            if (token.isCancellationRequested) return\n            return {\n              isIncomplete: false,\n              items: [\n                {\n                  label: 'foo'\n                }\n              ]\n            }\n          }\n        }\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['.']))\n      await nvim.input('i.')\n      await helper.waitPopup()\n      await nvim.input('fo')\n      await helper.wait(50)\n      let res = await helper.getItems()\n      expect(res.length).toBe(1)\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use commitCharacters from itemDefaults","suites":["language source","itemDefaults"],"updatePoint":{"line":336,"column":53},"line":336,"code":"    it('should use commitCharacters from itemDefaults', async () => {\n      helper.updateConfiguration('suggest.acceptSuggestionOnCommitCharacter', true)\n      await start({ label: 'foo' }, { commitCharacters: ['.'] })\n      await nvim.input('.')\n      await helper.waitFor('getline', ['.'], 'foo.')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use range of editRange from itemDefaults","suites":["language source","itemDefaults"],"updatePoint":{"line":343,"column":55},"line":343,"code":"    it('should use range of editRange from itemDefaults', async () => {\n      await nvim.call('setline', ['.', 'bar'])\n      await start({ label: 'foo' }, {\n        editRange: Range.create(0, 0, 0, 3)\n      })\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use replace range of editRange from itemDefaults","suites":["language source","itemDefaults"],"updatePoint":{"line":352,"column":63},"line":352,"code":"    it('should use replace range of editRange from itemDefaults', async () => {\n      await nvim.call('setline', ['.', 'bar'])\n      await start({ label: 'foo' }, {\n        editRange: {\n          insert: Range.create(0, 0, 0, 0),\n          replace: Range.create(0, 0, 0, 3),\n        }\n      })\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use insertTextFormat from itemDefaults","suites":["language source","itemDefaults"],"updatePoint":{"line":364,"column":53},"line":364,"code":"    it('should use insertTextFormat from itemDefaults', async () => {\n      await start({ label: 'foo', insertText: 'foo($1)$0' }, {\n        insertTextFormat: InsertTextFormat.Snippet,\n        insertTextMode: InsertTextMode.asIs,\n        data: {}\n      })\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'foo()')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix bad range","suites":["language source","textEdit"],"updatePoint":{"line":376,"column":28},"line":376,"code":"    it('should fix bad range', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: 'foo',\n          filterText: 'foo',\n          textEdit: { range: Range.create(0, 0, 0, 0), newText: 'foo' },\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('i')\n      nvim.call('coc#start', [{ source: 'edits' }], true)\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits for empty word","suites":["language source","textEdit"],"updatePoint":{"line":392,"column":40},"line":392,"code":"    it('should applyEdits for empty word', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (): Promise<CompletionItem[]> => [{\n          label: '',\n          filterText: '!',\n          textEdit: { range: Range.create(0, 0, 0, 1), newText: 'foo' },\n          data: { word: '' }\n        }]\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider, ['!']))\n      await nvim.input('i!')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      await helper.waitFor('getline', ['.'], 'foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should provide word when textEdit after startcol","suites":["language source","textEdit"],"updatePoint":{"line":408,"column":56},"line":408,"code":"    it('should provide word when textEdit after startcol', async () => {\n      // some LS would send textEdit after first character,\n      // need fix the word from newText\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (_, position): Promise<CompletionItem[]> => {\n          if (position.line != 0) return null\n          return [{\n            label: 'bar',\n            textEdit: {\n              range: Range.create(0, 1, 0, 1),\n              newText: 'bar'\n            }\n          }, {\n            label: 'bad',\n            textEdit: {\n              replace: Range.create(0, 1, 0, 1),\n              insert: Range.create(0, 1, 0, 1),\n              newText: 'bad'\n            }\n          }]\n        }\n      }\n      disposables.push(languages.registerCompletionItemProvider('edits', 'edit', null, provider))\n      await nvim.input('ib')\n      await helper.waitPopup()\n      let items = completion.activeItems\n      expect(items[0].word).toBe('bar')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust completion position by textEdit start position","suites":["language source","textEdit"],"updatePoint":{"line":437,"column":68},"line":437,"code":"    it('should adjust completion position by textEdit start position', async () => {\n      let provider: CompletionItemProvider = {\n        provideCompletionItems: async (_document, _position, _token, context): Promise<CompletionItem[]> => {\n          if (!context.triggerCharacter) return\n          return [{\n            label: 'foo',\n            textEdit: {\n              range: Range.create(0, 0, 0, 1),\n              newText: '?foo'\n            }\n          }]\n        }\n      }\n      disposables.push(languages.registerCompletionItemProvider('fix', 'f', null, provider, ['?']))\n      await nvim.input('i?')\n      await helper.waitPopup()\n      await helper.confirmCompletion(0)\n      let line = await nvim.line\n      expect(line).toBe('?foo')\n    })","file":"completion/language.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for around source","suites":["native sources"],"updatePoint":{"line":21,"column":36},"line":21,"code":"  it('should works for around source', async () => {\n    let doc = await workspace.document\n    await nvim.setLine('foo ')\n    await doc.synchronize()\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.input('Af')\n    await helper.waitPopup()\n    let res = await helper.visible('foo', 'around')\n    expect(res).toBe(true)\n    await nvim.input('<esc>')\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works for buffer source","suites":["native sources"],"updatePoint":{"line":34,"column":36},"line":34,"code":"  it('should works for buffer source', async () => {\n    await helper.createDocument()\n    await nvim.command('set hidden')\n    let doc = await helper.createDocument()\n    await nvim.setLine('other')\n    await nvim.command('bp')\n    await doc.synchronize()\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.input('io')\n    let res = await helper.visible('other', 'buffer')\n    expect(res).toBe(true)\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should works with file source","suites":["native sources"],"updatePoint":{"line":48,"column":35},"line":48,"code":"  it('should works with file source', async () => {\n    await helper.edit()\n    await nvim.input('i/')\n    await helper.waitPopup()\n  })","file":"completion/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check stop","suites":["shouldStop"],"updatePoint":{"line":20,"column":23},"line":20,"code":"  it('should check stop', async () => {\n    let opt = createOption(1, 1, 'a', 2)\n    expect(shouldStop(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: '' }, opt)).toBe(true)\n    expect(shouldStop(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: ' ' }, opt)).toBe(true)\n    expect(shouldStop(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'fo' }, opt)).toBe(true)\n    expect(shouldStop(2, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'foob' }, opt)).toBe(true)\n    expect(shouldStop(1, 'foo', { line: '', col: 2, lnum: 2, changedtick: 1, pre: 'foob' }, opt)).toBe(true)\n    expect(shouldStop(1, 'foo', { line: '', col: 2, lnum: 1, changedtick: 1, pre: 'barb' }, opt)).toBe(true)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check indent","suites":["shouldIndent"],"updatePoint":{"line":32,"column":25},"line":32,"code":"  it('should check indent', async () => {\n    let res = shouldIndent('0{,0},0),0],!^F,o,O,e,=endif,=enddef,=endfu,=endfor', 'endfor')\n    expect(res).toBe(true)\n    res = shouldIndent('', 'endfor')\n    expect(res).toBe(false)\n    res = shouldIndent('0{,0},0),0],!^F,o,O,e,=endif,=enddef,=endfu,=endfor', 'foo bar')\n    expect(res).toBe(false)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider none word character as input","suites":["getInput"],"updatePoint":{"line":43,"column":50},"line":43,"code":"  it('should consider none word character as input', async () => {\n    let doc = await helper.createDocument('t.vim')\n    let res = getInput(doc, 'a#b#', false)\n    expect(res).toBe('a#b#')\n    res = getInput(doc, 'b#', true)\n    expect(res).toBe('b#')\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match score for last letter","suites":["matchScore"],"updatePoint":{"line":57,"column":40},"line":57,"code":"  it('should match score for last letter', () => {\n    expect(score('#!3', '3')).toBe(1)\n    expect(score('bar', 'f')).toBe(0)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match first letter","suites":["matchScore"],"updatePoint":{"line":62,"column":31},"line":62,"code":"  it('should match first letter', () => {\n    expect(score('abc', 'a')).toBe(5)\n    expect(score('Abc', 'a')).toBe(2.5)\n    expect(score('__abc', 'a')).toBe(2)\n    expect(score('$Abc', 'a')).toBe(1)\n    expect(score('$Abc', 'A')).toBe(2)\n    expect(score('$Abc', '$A')).toBe(6)\n    expect(score('$Abc', '$a')).toBe(5.5)\n    expect(score('foo_bar', 'b')).toBe(2)\n    expect(score('foo_Bar', 'b')).toBe(1)\n    expect(score('_foo_Bar', 'b')).toBe(0.5)\n    expect(score('_foo_Bar', 'f')).toBe(2)\n    expect(score('bar', 'a')).toBe(1)\n    expect(score('fooBar', 'B')).toBe(2)\n    expect(score('fooBar', 'b')).toBe(1)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match follow letters","suites":["matchScore"],"updatePoint":{"line":79,"column":33},"line":79,"code":"  it('should match follow letters', () => {\n    expect(score('abc', 'ab')).toBe(6)\n    expect(score('adB', 'ab')).toBe(5.75)\n    expect(score('adb', 'ab')).toBe(5.1)\n    expect(score('adCB', 'ab')).toBe(5.05)\n    expect(score('a_b_c', 'ab')).toBe(6)\n    expect(score('FooBar', 'fb')).toBe(3.25)\n    expect(score('FBar', 'fb')).toBe(3)\n    expect(score('FooBar', 'FB')).toBe(6)\n    expect(score('FBar', 'FB')).toBe(6)\n    expect(score('a__b', 'a__b')).toBe(8)\n    expect(score('aBc', 'ab')).toBe(5.5)\n    expect(score('a_B_c', 'ab')).toBe(5.75)\n    expect(score('abc', 'abc')).toBe(7)\n    expect(score('abc', 'aC')).toBe(0)\n    expect(score('abc', 'ac')).toBe(5.1)\n    expect(score('abC', 'ac')).toBe(5.75)\n    expect(score('abC', 'aC')).toBe(6)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only allow search once","suites":["matchScore"],"updatePoint":{"line":99,"column":35},"line":99,"code":"  it('should only allow search once', () => {\n    expect(score('foobar', 'fbr')).toBe(5.2)\n    expect(score('foobaRow', 'fbr')).toBe(5.85)\n    expect(score('foobaRow', 'fbR')).toBe(6.1)\n    expect(score('foobar', 'fa')).toBe(5.1)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have higher score for strict match","suites":["matchScore"],"updatePoint":{"line":106,"column":47},"line":106,"code":"  it('should have higher score for strict match', () => {\n    expect(score('language-client-protocol', 'lct')).toBe(6.1)\n    expect(score('language-client-types', 'lct')).toBe(7)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find highest score","suites":["matchScore"],"updatePoint":{"line":111,"column":31},"line":111,"code":"  it('should find highest score', () => {\n    expect(score('ArrayRotateTail', 'art')).toBe(3.6)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return undefined when not match found","suites":["matchScoreWithPositions"],"updatePoint":{"line":126,"column":50},"line":126,"code":"  it('should return undefined when not match found', async () => {\n    assertMatch('a', 'abc', undefined)\n    assertMatch('a', '', undefined)\n    assertMatch('ab', 'ac', undefined)\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find matches by position fix","suites":["matchScoreWithPositions"],"updatePoint":{"line":132,"column":41},"line":132,"code":"  it('should find matches by position fix', async () => {\n    assertMatch('this', 'tih', [5.6, [0, 1, 2]])\n    assertMatch('globalThis', 'tihs', [2.6, [6, 7, 8, 9]])\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find matched positions","suites":["matchScoreWithPositions"],"updatePoint":{"line":137,"column":35},"line":137,"code":"  it('should find matched positions', async () => {\n    assertMatch('this', 'th', [6, [0, 1]])\n    assertMatch('foo_bar', 'fb', [6, [0, 4]])\n    assertMatch('assertMatch', 'am', [5.75, [0, 6]])\n  })","file":"completion/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup autocmd on vim","suites":["setupDynamicAutocmd()"],"updatePoint":{"line":21,"column":33},"line":21,"code":"  it('should setup autocmd on vim', async () => {\n    await nvim.setLine('foo')\n    let fn = nvim.hasFunction\n    nvim.hasFunction = () => {\n      return false\n    }\n    let called = false\n    workspace.registerAutocmd({\n      event: 'CursorMoved',\n      request: true,\n      callback: () => {\n        called = true\n      }\n    })\n    await helper.wait(50)\n    await nvim.command('normal! $')\n    await helper.wait(100)\n    nvim.hasFunction = fn\n    expect(called).toBe(true)\n    nvim.command(`augroup coc_dynamic_autocmd|  autocmd!|augroup end`, true)\n  })","file":"core/autocmds.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup user autocmd","suites":["setupDynamicAutocmd()"],"updatePoint":{"line":43,"column":31},"line":43,"code":"  it('should setup user autocmd', async () => {\n    let called = false\n    workspace.registerAutocmd({\n      event: 'User CocJumpPlaceholder',\n      request: true,\n      callback: () => {\n        called = true\n      }\n    })\n    workspace.autocmds.setupDynamicAutocmd(true)\n    await helper.wait(50)\n    await nvim.command('doautocmd <nomodeline> User CocJumpPlaceholder')\n    await helper.wait(100)\n    expect(called).toBe(true)\n  })","file":"core/autocmds.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when command id does not exist","suites":["doAutocmd()"],"updatePoint":{"line":61,"column":53},"line":61,"code":"  it('should not throw when command id does not exist', async () => {\n    await workspace.autocmds.doAutocmd(999, [])\n  })","file":"core/autocmds.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose","suites":["doAutocmd()"],"updatePoint":{"line":65,"column":20},"line":65,"code":"  it('should dispose', async () => {\n    workspace.autocmds.dispose()\n  })","file":"core/autocmds.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get document","suites":["documents"],"updatePoint":{"line":29,"column":25},"line":29,"code":"  it('should get document', async () => {\n    await helper.createDocument('bar')\n    let doc = await helper.createDocument('foo')\n    let res = documents.getDocument(doc.uri)\n    expect(res.uri).toBe(doc.uri)\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create document","suites":["documents"],"updatePoint":{"line":36,"column":28},"line":36,"code":"  it('should create document', async () => {\n    await helper.createDocument()\n    let bufnrs = await nvim.call('coc#ui#open_files', [[__filename]]) as number[]\n    let bufnr = bufnrs[0]\n    let doc = workspace.getDocument(bufnr)\n    expect(doc).toBeUndefined()\n    doc = await documents.createDocument(bufnr)\n    expect(doc).toBeDefined()\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check buffer rename on save","suites":["documents"],"updatePoint":{"line":46,"column":40},"line":46,"code":"  it('should check buffer rename on save', async () => {\n    let doc = await workspace.document\n    let bufnr = doc.bufnr\n    let name = `${uuid()}.vim`\n    let tmpfile = path.join(os.tmpdir(), name)\n    await nvim.command(`write ${tmpfile}`)\n    doc = workspace.getDocument(bufnr)\n    expect(doc).toBeDefined()\n    expect(doc.filetype).toBe('vim')\n    expect(doc.bufname).toMatch(name)\n    fs.unlinkSync(tmpfile)\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current document","suites":["documents"],"updatePoint":{"line":59,"column":33},"line":59,"code":"  it('should get current document', async () => {\n    let p1 = workspace.document\n    let p2 = workspace.document\n    let arr = await Promise.all([p1, p2])\n    expect(arr[0]).toBe(arr[1])\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get bufnrs","suites":["documents"],"updatePoint":{"line":66,"column":23},"line":66,"code":"  it('should get bufnrs', async () => {\n    await workspace.document\n    let bufnrs = documents.bufnrs\n    expect(bufnrs.length).toBe(1)\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get uri","suites":["documents"],"updatePoint":{"line":72,"column":20},"line":72,"code":"  it('should get uri', async () => {\n    let doc = await workspace.document\n    expect(documents.uri).toBe(doc.uri)\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach events on vim","suites":["documents"],"updatePoint":{"line":77,"column":33},"line":77,"code":"  it('should attach events on vim', async () => {\n    await documents.attach(nvim, workspace.env)\n    let env = Object.assign(workspace.env, { isVim: true })\n    documents.detach()\n    await documents.attach(nvim, env)\n    documents.detach()\n    await events.fire('CursorMoved', [1, [1, 1]])\n  })","file":"core/documents.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have active editor","suites":["editors"],"updatePoint":{"line":37,"column":31},"line":37,"code":"  it('should have active editor', async () => {\n    let winid = await nvim.call('win_getid')\n    let editor = window.activeTextEditor\n    assertEditor(editor, 1, winid)\n    let editors = window.visibleTextEditors\n    expect(editors.length).toBe(1)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change active editor on split","suites":["editors"],"updatePoint":{"line":45,"column":42},"line":45,"code":"  it('should change active editor on split', async () => {\n    let promise = new Promise<TextEditor>(resolve => {\n      editors.onDidChangeActiveTextEditor(e => {\n        resolve(e)\n      }, null, disposables)\n    })\n    await nvim.command('vnew')\n    let editor = await promise\n    let winid = await nvim.call('win_getid')\n    expect(editor.winid).toBe(winid)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change active editor on tabe","suites":["editors"],"updatePoint":{"line":57,"column":41},"line":57,"code":"  it('should change active editor on tabe', async () => {\n    let promise = new Promise<TextEditor>(resolve => {\n      editors.onDidChangeActiveTextEditor(e => {\n        if (e.document.uri.includes('foo')) {\n          resolve(e)\n        }\n      }, null, disposables)\n    })\n    await nvim.command('tabe a | tabe b | tabe foo')\n    let editor = await promise\n    let winid = await nvim.call('win_getid')\n    expect(editor.winid).toBe(winid)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change active editor on edit","suites":["editors"],"updatePoint":{"line":71,"column":41},"line":71,"code":"  it('should change active editor on edit', async () => {\n    await nvim.call('win_getid')\n    let fn = jest.fn()\n    window.onDidChangeVisibleTextEditors(() => {\n      fn()\n    }, null, disposables)\n    let promise = new Promise<TextEditor>(resolve => {\n      editors.onDidChangeActiveTextEditor(e => {\n        resolve(e)\n      })\n    })\n    await nvim.command('edit foo')\n    let editor = await promise\n    expect(editor.document.uri).toMatch('foo')\n    expect(fn).toBeCalled()\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change active editor on window switch","suites":["editors"],"updatePoint":{"line":88,"column":50},"line":88,"code":"  it('should change active editor on window switch', async () => {\n    let winid = await nvim.call('win_getid')\n    await nvim.command('vs foo')\n    await nvim.command('wincmd p')\n    let curr = editors.activeTextEditor\n    expect(curr.winid).toBe(winid)\n    expect(editors.visibleTextEditors.length).toBe(2)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create editor for float window","suites":["editors"],"updatePoint":{"line":97,"column":47},"line":97,"code":"  it('should not create editor for float window', async () => {\n    let fn = jest.fn()\n    await nvim.call('win_getid')\n    editors.onDidChangeActiveTextEditor(e => {\n      fn()\n    })\n    let res = await nvim.call('coc#float#create_float_win', [0, 0, {\n      relative: 'editor',\n      row: 1,\n      col: 1,\n      width: 10,\n      height: 1,\n      lines: ['foo']\n    }])\n    await nvim.call('win_gotoid', [res[0]])\n    await events.fire('CursorHold', [res[1]])\n    await nvim.command('wincmd p')\n    expect(fn).toBeCalledTimes(0)\n    expect(editors.visibleTextEditors.length).toBe(1)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cleanup on CursorHold","suites":["editors"],"updatePoint":{"line":118,"column":34},"line":118,"code":"  it('should cleanup on CursorHold', async () => {\n    let winid = await nvim.call('win_getid')\n    let promise = new Promise<TextEditor>(resolve => {\n      editors.onDidChangeActiveTextEditor(e => {\n        if (e.document.uri.includes('foo')) {\n          resolve(e)\n        }\n      }, null, disposables)\n    })\n    await nvim.command('tabe foo')\n    await promise\n    await nvim.call('win_execute', [winid, 'noa close'])\n    let bufnr = await nvim.eval(\"bufnr('%')\")\n    await events.fire('CursorHold', [bufnr])\n    expect(editors.visibleTextEditors.length).toBe(1)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cleanup on create","suites":["editors"],"updatePoint":{"line":135,"column":30},"line":135,"code":"  it('should cleanup on create', async () => {\n    let winid = await nvim.call('win_getid')\n    let promise = new Promise<TextEditor>(resolve => {\n      editors.onDidChangeActiveTextEditor(e => {\n        if (e.document.uri.includes('foo')) {\n          resolve(e)\n        }\n      }, null, disposables)\n    })\n    await nvim.command('tabe foo')\n    await promise\n    await nvim.call('win_execute', [winid, 'noa close'])\n    await nvim.command('edit bar')\n    expect(editors.visibleTextEditors.length).toBe(2)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have corrent tabnr after tab changed","suites":["editors"],"updatePoint":{"line":151,"column":49},"line":151,"code":"  it('should have corrent tabnr after tab changed', async () => {\n    await nvim.command('tabe')\n    await helper.waitValue(() => {\n      return editors.visibleTextEditors.length\n    }, 2)\n    let editor = editors.visibleTextEditors.find(o => o.tabpagenr == 2)\n    await nvim.command('normal! 1gt')\n    await nvim.command('tabe')\n    await helper.waitValue(() => {\n      return editors.visibleTextEditors.length\n    }, 3)\n    expect(editor.tabpagenr).toBe(3)\n    await nvim.command('tabc')\n    await helper.waitValue(() => {\n      return editors.visibleTextEditors.length\n    }, 2)\n    expect(editor.tabpagenr).toBe(2)\n  })","file":"core/editors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid arguments","suites":["RelativePattern"],"updatePoint":{"line":47,"column":40},"line":47,"code":"  it('should throw for invalid arguments', async () => {\n    testThrow(() => {\n      new RelativePattern('', undefined)\n    })\n    testThrow(() => {\n      new RelativePattern({ uri: undefined } as any, '')\n    })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create relativePattern","suites":["RelativePattern"],"updatePoint":{"line":56,"column":35},"line":56,"code":"  it('should create relativePattern', async () => {\n    for (let base of [__filename, URI.file(__filename), { uri: URI.file(__dirname).toString(), name: 'test' }]) {\n      let p = new RelativePattern(base, '**/*')\n      expect(URI.isUri(p.baseUri)).toBe(true)\n      expect(p.toJSON()).toBeDefined()\n    }\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use glob pattern","suites":["findFiles()"],"updatePoint":{"line":70,"column":29},"line":70,"code":"  it('should use glob pattern', async () => {\n    let res = await workspace.findFiles('**/*.ts')\n    expect(res.length).toBeGreaterThan(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use relativePattern","suites":["findFiles()"],"updatePoint":{"line":75,"column":32},"line":75,"code":"  it('should use relativePattern', async () => {\n    let relativePattern = new RelativePattern(URI.file(__dirname), '**/*.ts')\n    let res = await workspace.findFiles(relativePattern)\n    expect(res.length).toBeGreaterThan(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect exclude as glob pattern","suites":["findFiles()"],"updatePoint":{"line":81,"column":44},"line":81,"code":"  it('should respect exclude as glob pattern', async () => {\n    let arr = await workspace.findFiles('**/*.ts', 'files*')\n    let res = arr.find(o => path.relative(__dirname, o.fsPath).startsWith('files'))\n    expect(res).toBeUndefined()\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect exclude as relativePattern","suites":["findFiles()"],"updatePoint":{"line":87,"column":47},"line":87,"code":"  it('should respect exclude as relativePattern', async () => {\n    let relativePattern = new RelativePattern(URI.file(__dirname), 'files*')\n    let arr = await workspace.findFiles('**/*.ts', relativePattern)\n    let res = arr.find(o => path.relative(__dirname, o.fsPath).startsWith('files'))\n    expect(res).toBeUndefined()\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect maxResults","suites":["findFiles()"],"updatePoint":{"line":94,"column":31},"line":94,"code":"  it('should respect maxResults', async () => {\n    let arr = await workspace.findFiles('**/*.ts', undefined, 1)\n    expect(arr.length).toBe(1)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect token","suites":["findFiles()"],"updatePoint":{"line":99,"column":26},"line":99,"code":"  it('should respect token', async () => {\n    let source = new CancellationTokenSource()\n    source.cancel()\n    let arr = await workspace.findFiles('**/*.ts', undefined, 1, source.token)\n    expect(arr.length).toBe(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel findFiles","suites":["findFiles()"],"updatePoint":{"line":106,"column":29},"line":106,"code":"  it('should cancel findFiles', async () => {\n    let source = new CancellationTokenSource()\n    let p = workspace.findFiles('**/*.ts', undefined, 1, source.token)\n    source.cancel()\n    let arr = await p\n    expect(arr.length).toBe(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when unable to undo & redo","suites":["applyEdits()"],"updatePoint":{"line":116,"column":49},"line":116,"code":"  it('should not throw when unable to undo & redo', async () => {\n    await workspace.files.undoWorkspaceEdit()\n    await workspace.files.redoWorkspaceEdit()\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply TextEdit of documentChanges","suites":["applyEdits()"],"updatePoint":{"line":121,"column":46},"line":121,"code":"  it('should apply TextEdit of documentChanges', async () => {\n    let doc = await helper.createDocument()\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, doc.version)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe('bar')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edit with out change buffers","suites":["applyEdits()"],"updatePoint":{"line":135,"column":47},"line":135,"code":"  it('should apply edit with out change buffers', async () => {\n    let doc = await helper.createDocument()\n    await nvim.setLine('bar')\n    await doc.synchronize()\n    let version = doc.version\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, doc.version)\n    let edit = TextEdit.replace(Range.create(0, 0, 0, 3), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    expect(doc.version).toBe(version)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not apply TextEdit if version miss match","suites":["applyEdits()"],"updatePoint":{"line":151,"column":53},"line":151,"code":"  it('should not apply TextEdit if version miss match', async () => {\n    let doc = await helper.createDocument()\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, 10)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(false)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits with changes to buffer","suites":["applyEdits()"],"updatePoint":{"line":163,"column":47},"line":163,"code":"  it('should apply edits with changes to buffer', async () => {\n    let doc = await helper.createDocument()\n    let changes = {\n      [doc.uri]: [TextEdit.insert(Position.create(0, 0), 'bar')]\n    }\n    let workspaceEdit: WorkspaceEdit = { changes }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let line = await nvim.getLine()\n    expect(line).toBe('bar')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits with changes to file not in buffer list","suites":["applyEdits()"],"updatePoint":{"line":175,"column":64},"line":175,"code":"  it('should apply edits with changes to file not in buffer list', async () => {\n    let filepath = await createTmpFile('bar')\n    let uri = URI.file(filepath).toString()\n    let changes = {\n      [uri]: [TextEdit.insert(Position.create(0, 0), 'foo')]\n    }\n    let res = await workspace.applyEdit({ changes })\n    expect(res).toBe(true)\n    let doc = workspace.getDocument(uri)\n    let content = doc.getDocumentContent()\n    expect(content).toMatch(/^foobar/)\n    await nvim.command('silent! %bwipeout!')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits when file does not exist","suites":["applyEdits()"],"updatePoint":{"line":189,"column":49},"line":189,"code":"  it('should apply edits when file does not exist', async () => {\n    let filepath = path.join(__dirname, 'not_exists')\n    disposables.push({\n      dispose: () => {\n        if (fs.existsSync(filepath)) {\n          fs.unlinkSync(filepath)\n        }\n      }\n    })\n    let uri = URI.file(filepath).toString()\n    let changes = {\n      [uri]: [TextEdit.insert(Position.create(0, 0), 'foo')]\n    }\n    let res = await workspace.applyEdit({ changes })\n    expect(res).toBe(true)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor position after applyEdits","suites":["applyEdits()"],"updatePoint":{"line":206,"column":52},"line":206,"code":"  it('should adjust cursor position after applyEdits', async () => {\n    let doc = await helper.createDocument()\n    let pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 0, character: 0 })\n    let edit = TextEdit.insert(Position.create(0, 0), 'foo\\n')\n    let versioned = VersionedTextDocumentIdentifier.create(doc.uri, null)\n    let documentChanges = [TextDocumentEdit.create(versioned, [edit])]\n    let res = await workspace.applyEdit({ documentChanges })\n    expect(res).toBe(true)\n    pos = await window.getCursorPosition()\n    expect(pos).toEqual({ line: 1, character: 0 })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support null version of documentChanges","suites":["applyEdits()"],"updatePoint":{"line":219,"column":52},"line":219,"code":"  it('should support null version of documentChanges', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let uri = URI.file(file).toString()\n    let versioned = VersionedTextDocumentIdentifier.create(uri, null)\n    let edit = TextEdit.insert(Position.create(0, 0), 'bar')\n    let change = TextDocumentEdit.create(versioned, [edit])\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [change]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await nvim.command('wa')\n    let content = await readFile(file, 'utf8')\n    expect(content).toMatch(/^bar/)\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support CreateFile edit","suites":["applyEdits()"],"updatePoint":{"line":237,"column":36},"line":237,"code":"  it('should support CreateFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [CreateFile.create(uri, { overwrite: true })]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support DeleteFile edit","suites":["applyEdits()"],"updatePoint":{"line":248,"column":36},"line":248,"code":"  it('should support DeleteFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [DeleteFile.create(uri)]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check uri for CreateFile edit","suites":["applyEdits()"],"updatePoint":{"line":259,"column":42},"line":259,"code":"  it('should check uri for CreateFile edit', async () => {\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [CreateFile.create('term://.', { overwrite: true })]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(false)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support RenameFile edit","suites":["applyEdits()"],"updatePoint":{"line":267,"column":36},"line":267,"code":"  it('should support RenameFile edit', async () => {\n    let file = path.join(__dirname, 'foo')\n    await workspace.createFile(file, { ignoreIfExists: true, overwrite: true })\n    let newFile = path.join(__dirname, 'bar')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [RenameFile.create(uri, URI.file(newFile).toString())]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    await workspace.deleteFile(newFile, { ignoreIfNotExists: true })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support changes with edit and rename","suites":["applyEdits()"],"updatePoint":{"line":280,"column":49},"line":280,"code":"  it('should support changes with edit and rename', async () => {\n    let fsPath = await createTmpFile('test')\n    let doc = await helper.createDocument(fsPath)\n    let newFile = path.join(os.tmpdir(), `coc-${process.pid}/new-${uuid()}`)\n    let newUri = URI.file(newFile).toString()\n    let edit: WorkspaceEdit = {\n      documentChanges: [\n        {\n          textDocument: {\n            version: null,\n            uri: doc.uri,\n          },\n          edits: [\n            {\n              range: {\n                start: {\n                  line: 0,\n                  character: 0\n                },\n                end: {\n                  line: 0,\n                  character: 4\n                }\n              },\n              newText: 'bar'\n            }\n          ]\n        },\n        {\n          oldUri: doc.uri,\n          newUri,\n          kind: 'rename'\n        }\n      ]\n    }\n    let res = await workspace.applyEdit(edit)\n    expect(res).toBe(true)\n    let curr = await workspace.document\n    expect(curr.uri).toBe(newUri)\n    expect(curr.getline(0)).toBe('bar')\n    let line = await nvim.line\n    expect(line).toBe('bar')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support edit new file with CreateFile","suites":["applyEdits()"],"updatePoint":{"line":324,"column":50},"line":324,"code":"  it('should support edit new file with CreateFile', async () => {\n    let file = path.join(os.tmpdir(), 'foo')\n    let uri = URI.file(file).toString()\n    let workspaceEdit: WorkspaceEdit = {\n      documentChanges: [\n        CreateFile.create(uri, { overwrite: true }),\n        TextDocumentEdit.create({ uri, version: 0 }, [\n          TextEdit.insert(Position.create(0, 0), 'foo bar')\n        ])\n      ]\n    }\n    let res = await workspace.applyEdit(workspaceEdit)\n    expect(res).toBe(true)\n    let doc = workspace.getDocument(uri)\n    expect(doc).toBeDefined()\n    let line = doc.getline(0)\n    expect(line).toBe('foo bar')\n    await workspace.deleteFile(file, { ignoreIfNotExists: true })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should undo and redo workspace edit","suites":["applyEdits()"],"updatePoint":{"line":344,"column":41},"line":344,"code":"  it('should undo and redo workspace edit', async () => {\n    const folder = path.join(os.tmpdir(), uuid())\n    const pathone = path.join(folder, 'a')\n    const pathtwo = path.join(folder, 'b')\n    await workspace.files.createFile(pathone, { overwrite: true })\n    await workspace.files.createFile(pathtwo, { overwrite: true })\n    let uris = [URI.file(pathone).toString(), URI.file(pathtwo).toString()]\n    const assertContent = (one: string, two: string) => {\n      let doc = workspace.getDocument(uris[0])\n      expect(doc.getDocumentContent()).toBe(one)\n      doc = workspace.getDocument(uris[1])\n      expect(doc.getDocumentContent()).toBe(two)\n    }\n    let edits: TextDocumentEdit[] = []\n    edits.push(TextDocumentEdit.create({ uri: uris[0], version: null }, [\n      TextEdit.insert(Position.create(0, 0), 'foo')\n    ]))\n    edits.push(TextDocumentEdit.create({ uri: uris[1], version: null }, [\n      TextEdit.insert(Position.create(0, 0), 'bar')\n    ]))\n    await workspace.applyEdit({ documentChanges: edits })\n    assertContent('foo\\n', 'bar\\n')\n    await workspace.files.undoWorkspaceEdit()\n    assertContent('\\n', '\\n')\n    await workspace.files.redoWorkspaceEdit()\n    assertContent('foo\\n', 'bar\\n')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should support annotations","suites":["applyEdits()"],"updatePoint":{"line":372,"column":39},"line":372,"code":"  it('should should support annotations', async () => {\n    async function assertEdit(confirm: boolean): Promise<void> {\n      let doc = await helper.createDocument(uuid())\n      let edit: WorkspaceEdit = {\n        documentChanges: [\n          {\n            textDocument: { version: doc.version, uri: doc.uri },\n            edits: [\n              {\n                range: Range.create(0, 0, 0, 0),\n                newText: 'bar',\n                annotationId: '85bc78e2-5ef0-4949-b10c-13f476faf430'\n              }\n            ]\n          },\n        ],\n        changeAnnotations: {\n          '85bc78e2-5ef0-4949-b10c-13f476faf430': {\n            needsConfirmation: true,\n            label: 'Text changes',\n            description: 'description'\n          }\n        }\n      }\n      let p = workspace.files.applyEdit(edit)\n      await helper.waitPrompt()\n      if (confirm) {\n        await nvim.input('<cr>')\n      } else {\n        await nvim.input('<esc>')\n      }\n      await p\n      let content = doc.getDocumentContent()\n      if (confirm) {\n        expect(content).toBe('bar\\n')\n      } else {\n        expect(content).toBe('\\n')\n      }\n    }\n    await assertEdit(true)\n    await assertEdit(false)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show wanring when edit not exists","suites":["inspectEdit"],"updatePoint":{"line":424,"column":46},"line":424,"code":"  it('should show wanring when edit not exists', async () => {\n    (workspace.files as any).editState = undefined\n    await workspace.files.inspectEdit()\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render with changes","suites":["inspectEdit"],"updatePoint":{"line":429,"column":32},"line":429,"code":"  it('should render with changes', async () => {\n    let fsPath = await createTmpFile('foo\\n1\\n2\\nbar')\n    let doc = await helper.createDocument(fsPath)\n    let newFile = path.join(os.tmpdir(), `coc-${process.pid}/new-${uuid()}`)\n    let newUri = URI.file(newFile).toString()\n    let createFile = path.join(os.tmpdir(), `coc-${process.pid}/create-${uuid()}`)\n    let deleteFile = await createTmpFile('delete')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(newFile)) fs.unlinkSync(newFile)\n      if (fs.existsSync(createFile)) fs.unlinkSync(createFile)\n      if (fs.existsSync(deleteFile)) fs.unlinkSync(deleteFile)\n    }))\n    let edit: WorkspaceEdit = {\n      documentChanges: [\n        {\n          textDocument: { version: null, uri: doc.uri, },\n          edits: [\n            TextEdit.del(Range.create(0, 0, 1, 0)),\n            TextEdit.replace(Range.create(3, 0, 3, 3), 'xyz'),\n          ]\n        },\n        {\n          kind: 'rename',\n          oldUri: doc.uri,\n          newUri\n        }, {\n          kind: 'create',\n          uri: URI.file(createFile).toString()\n        }, {\n          kind: 'delete',\n          uri: URI.file(deleteFile).toString()\n        }\n      ]\n    }\n    let buf = await inspect(edit)\n    let lines = await buf.lines\n    let content = lines.join('\\n')\n    expect(content).toMatch('Change')\n    expect(content).toMatch('Rename')\n    expect(content).toMatch('Create')\n    expect(content).toMatch('Delete')\n    await nvim.command('exe 5')\n    await nvim.input('<CR>')\n    await helper.waitFor('expand', ['%:p'], newFile)\n    let line = await nvim.call('line', ['.'])\n    expect(line).toBe(3)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render annotation label","suites":["inspectEdit"],"updatePoint":{"line":477,"column":36},"line":477,"code":"  it('should render annotation label', async () => {\n    let doc = await helper.createDocument(uuid())\n    let edit: WorkspaceEdit = {\n      documentChanges: [\n        {\n          textDocument: { version: doc.version, uri: doc.uri },\n          edits: [\n            {\n              range: Range.create(0, 0, 0, 0),\n              newText: 'bar',\n              annotationId: 'dd866f37-a24c-4503-9c35-c139fb28e25b'\n            }\n          ]\n        },\n      ],\n      changeAnnotations: {\n        'dd866f37-a24c-4503-9c35-c139fb28e25b': {\n          needsConfirmation: false,\n          label: 'Text changes'\n        }\n      }\n    }\n    let buf = await inspect(edit)\n    await events.fire('BufUnload', [buf.id + 1])\n    let winid = await nvim.call('win_getid')\n    let lines = await buf.lines\n    expect(lines[0]).toBe('Text changes')\n    await nvim.command('exe 1')\n    await nvim.input('<CR>')\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBe(buf.id)\n    await nvim.command('exe 3')\n    await nvim.input('<CR>')\n    let fsPath = URI.parse(doc.uri).fsPath\n    await helper.waitFor('expand', ['%:p'], fsPath)\n    await nvim.call('win_gotoid', [winid])\n    await nvim.input('<esc>')\n    await helper.wait(10)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create and revert parent folder","suites":["createFile()"],"updatePoint":{"line":519,"column":44},"line":519,"code":"  it('should create and revert parent folder', async () => {\n    const folder = path.join(os.tmpdir(), uuid())\n    const filepath = path.join(folder, 'bar')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(folder)) fs.removeSync(folder)\n    }))\n    let fns: RecoverFunc[] = []\n    expect(fs.existsSync(folder)).toBe(false)\n    await workspace.files.createFile(filepath, {}, fns)\n    expect(fs.existsSync(filepath)).toBe(true)\n    for (let i = fns.length - 1; i >= 0; i--) {\n      await fns[i]()\n    }\n    expect(fs.existsSync(folder)).toBe(false)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file already exists","suites":["createFile()"],"updatePoint":{"line":535,"column":43},"line":535,"code":"  it('should throw when file already exists', async () => {\n    let filepath = await createTmpFile('foo', disposables)\n    let fn = async () => {\n      await workspace.createFile(filepath, {})\n    }\n    await expect(fn()).rejects.toThrow(Error)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create file if file exists with ignoreIfExists","suites":["createFile()"],"updatePoint":{"line":543,"column":63},"line":543,"code":"  it('should not create file if file exists with ignoreIfExists', async () => {\n    let file = await createTmpFile('foo')\n    await workspace.createFile(file, { ignoreIfExists: true })\n    let content = fs.readFileSync(file, 'utf8')\n    expect(content).toBe('foo')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file if does not exist","suites":["createFile()"],"updatePoint":{"line":550,"column":42},"line":550,"code":"  it('should create file if does not exist', async () => {\n    await helper.edit()\n    let filepath = path.join(__dirname, 'foo')\n    await workspace.createFile(filepath, { ignoreIfExists: true })\n    let exists = fs.existsSync(filepath)\n    expect(exists).toBe(true)\n    fs.unlinkSync(filepath)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should revert file create","suites":["createFile()"],"updatePoint":{"line":559,"column":31},"line":559,"code":"  it('should revert file create', async () => {\n    let filepath = path.join(os.tmpdir(), uuid())\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(filepath)) fs.unlinkSync(filepath)\n    }))\n    let fns: RecoverFunc[] = []\n    await workspace.files.createFile(filepath, { overwrite: true }, fns)\n    expect(fs.existsSync(filepath)).toBe(true)\n    let bufnr = await nvim.call('bufnr', [filepath])\n    expect(bufnr).toBeGreaterThan(0)\n    let doc = workspace.getDocument(bufnr)\n    expect(doc).toBeDefined()\n    for (let fn of fns) {\n      await fn()\n    }\n    expect(fs.existsSync(filepath)).toBe(false)\n    let loaded = await nvim.call('bufloaded', [filepath])\n    expect(loaded).toBe(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when oldPath not exists","suites":["renameFile"],"updatePoint":{"line":581,"column":42},"line":581,"code":"  it('should throw when oldPath not exists', async () => {\n    let filepath = path.join(__dirname, 'not_exists_file')\n    let newPath = path.join(__dirname, 'bar')\n    let fn = async () => {\n      await workspace.renameFile(filepath, newPath)\n    }\n    await expect(fn()).rejects.toThrow(Error)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename file on disk","suites":["renameFile"],"updatePoint":{"line":590,"column":32},"line":590,"code":"  it('should rename file on disk', async () => {\n    let filepath = await createTmpFile('test')\n    let newPath = path.join(path.dirname(filepath), 'new_file')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(newPath)) fs.unlinkSync(newPath)\n      if (fs.existsSync(filepath)) fs.unlinkSync(filepath)\n    }))\n    let fns: RecoverFunc[] = []\n    await workspace.files.renameFile(filepath, newPath, { overwrite: true }, fns)\n    expect(fs.existsSync(newPath)).toBe(true)\n    for (let fn of fns) {\n      await fn()\n    }\n    expect(fs.existsSync(newPath)).toBe(false)\n    expect(fs.existsSync(filepath)).toBe(true)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename if file does not exist","suites":["renameFile"],"updatePoint":{"line":607,"column":42},"line":607,"code":"  it('should rename if file does not exist', async () => {\n    let filepath = path.join(__dirname, 'foo')\n    let newPath = path.join(__dirname, 'bar')\n    await workspace.createFile(filepath)\n    await workspace.renameFile(filepath, newPath)\n    expect(fs.existsSync(newPath)).toBe(true)\n    expect(fs.existsSync(filepath)).toBe(false)\n    fs.unlinkSync(newPath)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename current buffer with same bufnr","suites":["renameFile"],"updatePoint":{"line":617,"column":50},"line":617,"code":"  it('should rename current buffer with same bufnr', async () => {\n    let file = await createTmpFile('test')\n    let doc = await helper.createDocument(file)\n    await nvim.setLine('bar')\n    await doc.patchChange()\n    let newFile = path.join(os.tmpdir(), `coc-${process.pid}/new-${uuid()}`)\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(newFile)) fs.unlinkSync(newFile)\n    }))\n    await workspace.renameFile(file, newFile)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBe(doc.bufnr)\n    let line = await nvim.line\n    expect(line).toBe('bar')\n    let exists = fs.existsSync(newFile)\n    expect(exists).toBe(true)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should overwrite if file exists","suites":["renameFile"],"updatePoint":{"line":635,"column":37},"line":635,"code":"  it('should overwrite if file exists', async () => {\n    let filepath = path.join(os.tmpdir(), uuid())\n    let newPath = path.join(os.tmpdir(), uuid())\n    await workspace.createFile(filepath)\n    await workspace.createFile(newPath)\n    await workspace.renameFile(filepath, newPath, { overwrite: true })\n    expect(fs.existsSync(newPath)).toBe(true)\n    expect(fs.existsSync(filepath)).toBe(false)\n    fs.unlinkSync(newPath)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename buffer in directory and revert","suites":["renameFile"],"updatePoint":{"line":646,"column":50},"line":646,"code":"  it('should rename buffer in directory and revert', async () => {\n    let folder = path.join(os.tmpdir(), uuid())\n    let newFolder = path.join(os.tmpdir(), uuid())\n    fs.mkdirSync(folder)\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(folder)) fs.removeSync(folder)\n      if (fs.existsSync(newFolder)) fs.removeSync(newFolder)\n    }))\n    let filepath = path.join(folder, 'new_file')\n    await workspace.createFile(filepath)\n    let bufnr = await nvim.call('bufnr', [filepath])\n    expect(bufnr).toBeGreaterThan(0)\n    let fns: RecoverFunc[] = []\n    await workspace.files.renameFile(folder, newFolder, { overwrite: true }, fns)\n    bufnr = await nvim.call('bufnr', [path.join(newFolder, 'new_file')])\n    expect(bufnr).toBeGreaterThan(0)\n    for (let i = fns.length - 1; i >= 0; i--) {\n      await fns[i]()\n    }\n    bufnr = await nvim.call('bufnr', [filepath])\n    expect(bufnr).toBeGreaterThan(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load file as hidden buffer","suites":["loadResource()"],"updatePoint":{"line":671,"column":39},"line":671,"code":"  it('should load file as hidden buffer', async () => {\n    helper.updateConfiguration('workspace.openResourceCommand', '')\n    let filepath = await createTmpFile('foo')\n    let uri = URI.file(filepath).toString()\n    let doc = await workspace.files.loadResource(uri)\n    let bufnrs = await nvim.call('coc#window#bufnrs') as number[]\n    expect(bufnrs.indexOf(doc.bufnr)).toBe(-1)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file not exists","suites":["deleteFile()"],"updatePoint":{"line":682,"column":39},"line":682,"code":"  it('should throw when file not exists', async () => {\n    let filepath = path.join(__dirname, 'not_exists')\n    let fn = async () => {\n      await workspace.deleteFile(filepath)\n    }\n    await expect(fn()).rejects.toThrow(Error)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore when ignoreIfNotExists set","suites":["deleteFile()"],"updatePoint":{"line":690,"column":46},"line":690,"code":"  it('should ignore when ignoreIfNotExists set', async () => {\n    let filepath = path.join(__dirname, 'not_exists')\n    let fns: RecoverFunc[] = []\n    await workspace.files.deleteFile(filepath, { ignoreIfNotExists: true }, fns)\n    expect(fns.length).toBe(0)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should unload loaded buffer","suites":["deleteFile()"],"updatePoint":{"line":697,"column":33},"line":697,"code":"  it('should unload loaded buffer', async () => {\n    let filepath = await createTmpFile('file to delete')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(filepath)) fs.unlinkSync(filepath)\n    }))\n    await workspace.files.loadResource(URI.file(filepath).toString())\n    let fns: RecoverFunc[] = []\n    await workspace.files.deleteFile(filepath, {}, fns)\n    let loaded = await nvim.call('bufloaded', [filepath])\n    expect(loaded).toBe(0)\n    for (let i = fns.length - 1; i >= 0; i--) {\n      await fns[i]()\n    }\n    expect(fs.existsSync(filepath)).toBe(true)\n    loaded = await nvim.call('bufloaded', [filepath])\n    expect(loaded).toBe(1)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete and recover folder","suites":["deleteFile()"],"updatePoint":{"line":715,"column":38},"line":715,"code":"  it('should delete and recover folder', async () => {\n    let folder = path.join(os.tmpdir(), uuid())\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(folder)) fs.rmdirSync(folder)\n    }))\n    fs.mkdirSync(folder)\n    expect(fs.existsSync(folder)).toBe(true)\n    let fns: RecoverFunc[] = []\n    await workspace.files.deleteFile(folder, {}, fns)\n    expect(fs.existsSync(folder)).toBe(false)\n    for (let i = fns.length - 1; i >= 0; i--) {\n      await fns[i]()\n    }\n    expect(fs.existsSync(folder)).toBe(true)\n    await workspace.files.deleteFile(folder, {})\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete and recover folder recursive","suites":["deleteFile()"],"updatePoint":{"line":732,"column":48},"line":732,"code":"  it('should delete and recover folder recursive', async () => {\n    let folder = path.join(os.tmpdir(), uuid())\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(folder)) fs.removeSync(folder)\n    }))\n    fs.mkdirSync(folder)\n    await fs.writeFile(path.join(folder, 'new_file'), '', 'utf8')\n    let fns: RecoverFunc[] = []\n    await workspace.files.deleteFile(folder, { recursive: true }, fns)\n    expect(fs.existsSync(folder)).toBe(false)\n    for (let i = fns.length - 1; i >= 0; i--) {\n      await fns[i]()\n    }\n    expect(fs.existsSync(folder)).toBe(true)\n    expect(fs.existsSync(path.join(folder, 'new_file'))).toBe(true)\n    await workspace.files.deleteFile(folder, { recursive: true })\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete file if exists","suites":["deleteFile()"],"updatePoint":{"line":750,"column":34},"line":750,"code":"  it('should delete file if exists', async () => {\n    let filepath = path.join(__dirname, 'foo')\n    await workspace.createFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(true)\n    await workspace.deleteFile(filepath)\n    expect(fs.existsSync(filepath)).toBe(false)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should single loadFile","suites":["loadFile()"],"updatePoint":{"line":760,"column":28},"line":760,"code":"  it('should single loadFile', async () => {\n    let doc = await helper.createDocument()\n    let newFile = URI.file(path.join(__dirname, 'abc')).toString()\n    let document = await workspace.loadFile(newFile)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(document.uri.endsWith('abc')).toBe(true)\n    expect(bufnr).toBe(doc.bufnr)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should loadFiles","suites":["loadFiles"],"updatePoint":{"line":771,"column":22},"line":771,"code":"  it('should loadFiles', async () => {\n    let files = ['a', 'b', 'c'].map(key => URI.file(path.join(__dirname, key)).toString())\n    let docs = await workspace.loadFiles(files)\n    let uris = docs.map(o => o.uri)\n    expect(uris).toEqual(files)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load empty files array","suites":["loadFiles"],"updatePoint":{"line":778,"column":35},"line":778,"code":"  it('should load empty files array', async () => {\n    await workspace.loadFiles([])\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open document already exists","suites":["openTextDocument()"],"updatePoint":{"line":784,"column":41},"line":784,"code":"  it('should open document already exists', async () => {\n    let doc = await helper.createDocument('a')\n    await nvim.command('enew')\n    await workspace.openTextDocument(URI.parse(doc.uri))\n    let curr = await workspace.document\n    expect(curr.uri).toBe(doc.uri)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file does not exist","suites":["openTextDocument()"],"updatePoint":{"line":792,"column":43},"line":792,"code":"  it('should throw when file does not exist', async () => {\n    let err\n    try {\n      await workspace.openTextDocument('/a/b/c')\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open untitled document","suites":["openTextDocument()"],"updatePoint":{"line":802,"column":35},"line":802,"code":"  it('should open untitled document', async () => {\n    let doc = await workspace.openTextDocument(URI.parse(`untitled:///a/b.js`))\n    expect(doc.uri).toBe('file:///a/b.js')\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load file that exists","suites":["openTextDocument()"],"updatePoint":{"line":807,"column":34},"line":807,"code":"  it('should load file that exists', async () => {\n    let doc = await workspace.openTextDocument(URI.file(__filename))\n    expect(URI.parse(doc.uri).fsPath).toBe(__filename)\n    let curr = await workspace.document\n    expect(curr.uri).toBe(doc.uri)\n  })","file":"core/files.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when not watching","suites":["watchman"],"updatePoint":{"line":122,"column":42},"line":122,"code":"  it('should throw error when not watching', async () => {\n    let client = new Watchman(null)\n    disposables.push(client)\n    let fn = async () => {\n      await client.subscribe('**/*', () => {})\n    }\n    await expect(fn()).rejects.toThrow(/not watching/)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should checkCapability","suites":["watchman"],"updatePoint":{"line":131,"column":28},"line":131,"code":"  it('should checkCapability', async () => {\n    let client = new Watchman(null)\n    let res = await client.checkCapability()\n    expect(res).toBe(true)\n    capabilities = { relative_root: false }\n    res = await client.checkCapability()\n    expect(res).toBe(false)\n    client.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watchProject","suites":["watchman"],"updatePoint":{"line":141,"column":25},"line":141,"code":"  it('should watchProject', async () => {\n    let client = new Watchman(null)\n    disposables.push(client)\n    let res = await client.watchProject(__dirname)\n    expect(res).toBe(true)\n    client.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should unsubscribe","suites":["watchman"],"updatePoint":{"line":149,"column":24},"line":149,"code":"  it('should unsubscribe', async () => {\n    let client = new Watchman(null)\n    disposables.push(client)\n    await client.watchProject(cwd)\n    let fn = jest.fn()\n    let disposable = await client.subscribe(`${cwd}/*`, fn)\n    disposable.dispose()\n    client.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should subscribe file change","suites":["Watchman#subscribe"],"updatePoint":{"line":162,"column":34},"line":162,"code":"  it('should subscribe file change', async () => {\n    let client = new Watchman(null, helper.createNullChannel())\n    disposables.push(client)\n    await client.watchProject(cwd)\n    let fn = jest.fn()\n    let disposable = await client.subscribe(`${cwd}/*`, fn)\n    let changes: FileChangeItem[] = [createFileChange(`${cwd}/a`)]\n    sendSubscription(disposable.subscribe, cwd, changes)\n    await wait(30)\n    expect(fn).toBeCalled()\n    let call = fn.mock.calls[0][0]\n    disposable.dispose()\n    expect(call.root).toBe(cwd)\n    client.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should subscribe with relative_path","suites":["Watchman#subscribe"],"updatePoint":{"line":178,"column":41},"line":178,"code":"  it('should subscribe with relative_path', async () => {\n    let client = new Watchman(null, helper.createNullChannel())\n    watchResponse = { watch: cwd, relative_path: 'foo' }\n    await client.watchProject(cwd)\n    let fn = jest.fn()\n    let disposable = await client.subscribe(`${cwd}/*`, fn)\n    let changes: FileChangeItem[] = [createFileChange(`${cwd}/a`)]\n    sendSubscription(disposable.subscribe, cwd, changes)\n    await wait(30)\n    expect(fn).toBeCalled()\n    let call = fn.mock.calls[0][0]\n    disposable.dispose()\n    expect(call.root).toBe(path.join(cwd, 'foo'))\n    client.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not subscribe invalid response","suites":["Watchman#subscribe"],"updatePoint":{"line":194,"column":43},"line":194,"code":"  it('should not subscribe invalid response', async () => {\n    let c = new Watchman(null, helper.createNullChannel())\n    disposables.push(c)\n    watchResponse = { watch: cwd, relative_path: 'foo' }\n    await c.watchProject(cwd)\n    let fn = jest.fn()\n    let disposable = await c.subscribe(`${cwd}/*`, fn)\n    let changes: FileChangeItem[] = [createFileChange(`${cwd}/a`)]\n    sendSubscription('uuid', cwd, changes)\n    await wait(10)\n    sendSubscription(disposable.subscribe, cwd, [])\n    await wait(10)\n    client.write(bser.dumpToBuffer({\n      subscription: disposable.subscribe,\n      root: cwd\n    }))\n    await wait(10)\n    expect(fn).toBeCalledTimes(0)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create client when capabilities not match","suites":["Watchman#createClient"],"updatePoint":{"line":216,"column":58},"line":216,"code":"  it('should not create client when capabilities not match', async () => {\n    capabilities = { relative_root: false }\n    await expect(async () => {\n      await Watchman.createClient(null, cwd)\n    }).rejects.toThrow(Error)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create when watch failed","suites":["Watchman#createClient"],"updatePoint":{"line":223,"column":41},"line":223,"code":"  it('should not create when watch failed', async () => {\n    watchResponse = {}\n    await expect(async () => {\n      await Watchman.createClient(null, cwd)\n    }).rejects.toThrow(Error)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create client","suites":["Watchman#createClient"],"updatePoint":{"line":230,"column":26},"line":230,"code":"  it('should create client', async () => {\n    let client = await Watchman.createClient(null, cwd)\n    disposables.push(client)\n    expect(client).toBeDefined()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create client for root","suites":["Watchman#createClient"],"updatePoint":{"line":236,"column":39},"line":236,"code":"  it('should not create client for root', async () => {\n    await expect(async () => {\n      await Watchman.createClient(null, '/')\n    }).rejects.toThrow(Error)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check valid root","suites":["isValidWatchRoot()"],"updatePoint":{"line":244,"column":29},"line":244,"code":"  it('should check valid root', async () => {\n    expect(isValidWatchRoot('/')).toBe(false)\n    expect(isValidWatchRoot(os.homedir())).toBe(false)\n    expect(isValidWatchRoot('/tmp/a/b/c')).toBe(false)\n    expect(isValidWatchRoot(os.tmpdir())).toBe(false)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use relative pattern #1","suites":["fileSystemWatcher"],"updatePoint":{"line":270,"column":36},"line":270,"code":"  it('should use relative pattern #1', async () => {\n    let folder = workspaceFolder.workspaceFolders[0]\n    expect(folder).toBeDefined()\n    let pattern = new RelativePattern(folder, '**/*')\n    let watcher = createWatcher(pattern, false, true, true)\n    let fn = jest.fn()\n    watcher.onDidCreate(fn)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use relative pattern #2","suites":["fileSystemWatcher"],"updatePoint":{"line":284,"column":36},"line":284,"code":"  it('should use relative pattern #2', async () => {\n    let called = false\n    let pattern = new RelativePattern(__dirname, '**/*')\n    let watcher = createWatcher(pattern, false, true, true)\n    watcher.onDidCreate(() => {\n      called = true\n    })\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(called).toBe(false)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use relative pattern #3","suites":["fileSystemWatcher"],"updatePoint":{"line":298,"column":36},"line":298,"code":"  it('should use relative pattern #3', async () => {\n    let called = false\n    let root = path.join(os.tmpdir(), 'not_exists')\n    let pattern = new RelativePattern(root, '**/*')\n    let watcher = createWatcher(pattern, false, true, true)\n    watcher.onDidCreate(() => {\n      called = true\n    })\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(called).toBe(false)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for file create","suites":["fileSystemWatcher"],"updatePoint":{"line":313,"column":34},"line":313,"code":"  it('should watch for file create', async () => {\n    let watcher = createWatcher('**/*', false, true, true)\n    let fn = jest.fn()\n    watcher.onDidCreate(fn)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for file delete","suites":["fileSystemWatcher"],"updatePoint":{"line":324,"column":34},"line":324,"code":"  it('should watch for file delete', async () => {\n    let watcher = createWatcher('**/*', true, true, false)\n    let fn = jest.fn()\n    watcher.onDidDelete(fn)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`, false, false)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for file change","suites":["fileSystemWatcher"],"updatePoint":{"line":335,"column":34},"line":335,"code":"  it('should watch for file change', async () => {\n    let watcher = createWatcher('**/*', false, false, false)\n    let fn = jest.fn()\n    watcher.onDidChange(fn)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`, false, true)]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for file rename","suites":["fileSystemWatcher"],"updatePoint":{"line":346,"column":34},"line":346,"code":"  it('should watch for file rename', async () => {\n    let watcher = createWatcher('**/*', false, false, false)\n    let fn = jest.fn()\n    watcher.onDidRename(fn)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [\n      createFileChange(`a`, false, false),\n      createFileChange(`b`, true, true),\n    ]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(fn).toBeCalled()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not watch for events","suites":["fileSystemWatcher"],"updatePoint":{"line":360,"column":33},"line":360,"code":"  it('should not watch for events', async () => {\n    let watcher = createWatcher('**/*', true, true, true)\n    let called = false\n    let onChange = () => { called = true }\n    watcher.onDidCreate(onChange)\n    watcher.onDidChange(onChange)\n    watcher.onDidDelete(onChange)\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [\n      createFileChange(`a`, false, false),\n      createFileChange(`b`, true, true),\n      createFileChange(`c`, false, true),\n    ]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.wait(50)\n    expect(called).toBe(false)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for folder rename","suites":["fileSystemWatcher"],"updatePoint":{"line":378,"column":36},"line":378,"code":"  it('should watch for folder rename', async () => {\n    let watcher = createWatcher('**/*')\n    let newFiles: string[] = []\n    let count = 0\n    watcher.onDidRename(e => {\n      count++\n      newFiles.push(e.newUri.fsPath)\n    })\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [\n      createFileChange(`a/1`, false, false),\n      createFileChange(`a/2`, false, false),\n      createFileChange(`b/1`, true, true),\n      createFileChange(`b/2`, true, true),\n    ]\n    sendSubscription(watcher.subscribe, cwd, changes)\n    await helper.waitValue(() => {\n      return count\n    }, 2)\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch for new folder","suites":["fileSystemWatcher"],"updatePoint":{"line":399,"column":33},"line":399,"code":"  it('should watch for new folder', async () => {\n    let watcher = createWatcher('**/*')\n    expect(watcher).toBeDefined()\n    workspaceFolder.renameWorkspaceFolder(cwd, __dirname)\n    await helper.wait(50)\n    let uri: URI\n    watcher.onDidCreate(e => {\n      uri = e\n    })\n    await helper.wait(50)\n    let changes: FileChangeItem[] = [createFileChange(`a`)]\n    sendSubscription(watcher.subscribe, __dirname, changes)\n    await helper.wait(50)\n    expect(uri.fsPath).toEqual(path.join(__dirname, 'a'))\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach to existing workspace folder","suites":["create FileSystemWatcherManager"],"updatePoint":{"line":417,"column":48},"line":417,"code":"  it('should attach to existing workspace folder', async () => {\n    let workspaceFolder = new WorkspaceFolderController(configurations)\n    workspaceFolder.addWorkspaceFolder(cwd, false)\n    let watcherManager = new FileSystemWatcherManager(workspaceFolder, '')\n    watcherManager.attach(helper.createNullChannel())\n    await helper.wait(100)\n    await watcherManager.createClient(os.tmpdir())\n    await watcherManager.createClient(cwd)\n    await watcherManager.waitClient(cwd)\n    watcherManager.dispose()\n  })","file":"core/fileSystemWatcher.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid argument","suites":["has()"],"updatePoint":{"line":16,"column":39},"line":16,"code":"  it('should throw for invalid argument', async () => {\n    let env = {\n      isVim: true,\n      version: '8023956'\n    }\n    let err\n    try {\n      expect(funcs.has(env, '0.5.0')).toBe(true)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should detect version on vim8","suites":["has()"],"updatePoint":{"line":30,"column":35},"line":30,"code":"  it('should detect version on vim8', async () => {\n    let env = {\n      isVim: true,\n      version: '8023956'\n    }\n    expect(funcs.has(env, 'patch-7.4.248')).toBe(true)\n    expect(funcs.has(env, 'patch-8.5.1')).toBe(false)\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete version on neovim","suites":["has()"],"updatePoint":{"line":39,"column":37},"line":39,"code":"  it('should delete version on neovim', async () => {\n    let env = {\n      isVim: false,\n      version: '0.6.1'\n    }\n    expect(funcs.has(env, 'nvim-0.5.0')).toBe(true)\n    expect(funcs.has(env, 'nvim-0.7.0')).toBe(false)\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create namespace","suites":["createNameSpace()"],"updatePoint":{"line":50,"column":29},"line":50,"code":"  it('should create namespace', async () => {\n    let nr = funcs.createNameSpace('ns')\n    expect(nr).toBeDefined()\n    expect(nr).toBe(funcs.createNameSpace('ns'))\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get watchman path","suites":["getWatchmanPath()"],"updatePoint":{"line":58,"column":30},"line":58,"code":"  it('should get watchman path', async () => {\n    let res = funcs.getWatchmanPath(configurations)\n    expect(typeof res === 'string' || res == null).toBe(true)\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when can not find ","suites":["findUp()"],"updatePoint":{"line":65,"column":43},"line":65,"code":"  it('should return null when can not find ', async () => {\n    let nvim: any = {\n      call: () => {\n        return __filename\n      }\n    }\n    let res = await funcs.findUp(nvim, os.homedir(), ['file_not_exists'])\n    expect(res).toBeNull()\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when unable find cwd in cwd","suites":["findUp()"],"updatePoint":{"line":75,"column":52},"line":75,"code":"  it('should return null when unable find cwd in cwd', async () => {\n    let nvim: any = {\n      call: () => {\n        return ''\n      }\n    }\n    let res = await funcs.findUp(nvim, os.homedir(), ['file_not_exists'])\n    expect(res).toBeNull()\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return score","suites":["score()"],"updatePoint":{"line":87,"column":25},"line":87,"code":"  it('should return score', async () => {\n    expect(funcs.score(undefined, 'untitled:///1', '')).toBe(0)\n    expect(funcs.score({ scheme: '*' }, 'untitled:///1', '')).toBe(3)\n    expect(funcs.score('vim', 'untitled:///1', 'vim')).toBe(10)\n    expect(funcs.score('*', 'untitled:///1', '')).toBe(5)\n    expect(funcs.score('', 'untitled:///1', 'vim')).toBe(0)\n  })","file":"core/funcs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when key not mapped","suites":["doKeymap()"],"updatePoint":{"line":28,"column":42},"line":28,"code":"  it('should not throw when key not mapped', async () => {\n    await keymaps.doKeymap('<C-a>', '', '{C-a}')\n  })","file":"core/keymaps.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid key","suites":["registerKeymap()"],"updatePoint":{"line":34,"column":34},"line":34,"code":"  it('should throw for invalid key', async () => {\n    let err\n    try {\n      keymaps.registerKeymap(['i'], '', jest.fn())\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"core/keymaps.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for duplicated key","suites":["registerKeymap()"],"updatePoint":{"line":44,"column":37},"line":44,"code":"  it('should throw for duplicated key', async () => {\n    keymaps.registerKeymap(['i'], 'tmp', jest.fn())\n    let err\n    try {\n      keymaps.registerKeymap(['i'], 'tmp', jest.fn())\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"core/keymaps.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register insert key mapping","suites":["registerKeymap()"],"updatePoint":{"line":55,"column":40},"line":55,"code":"  it('should register insert key mapping', async () => {\n    let fn = jest.fn()\n    disposables.push(keymaps.registerKeymap(['i'], 'test', fn))\n    await helper.wait(10)\n    let res = await nvim.call('execute', ['verbose imap <Plug>(coc-test)'])\n    expect(res).toMatch('coc#_insert_key')\n  })","file":"core/keymaps.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should visual key mapping","suites":["registerExprKeymap()"],"updatePoint":{"line":65,"column":31},"line":65,"code":"  it('should visual key mapping', async () => {\n    await nvim.setLine('foo')\n    let called = false\n    let fn = () => {\n      called = true\n      return ''\n    }\n    disposables.push(keymaps.registerExprKeymap('x', 'x', fn, true))\n    await helper.wait(50)\n    await nvim.command('normal! viw')\n    await nvim.input('x<esc>')\n    await helper.wait(50)\n    expect(called).toBe(true)\n  })","file":"core/keymaps.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show location list by default","suites":["showLocations()"],"updatePoint":{"line":31,"column":42},"line":31,"code":"  it('should show location list by default', async () => {\n    let locations = createLocations()\n    await workspace.showLocations(locations)\n    await helper.waitFor('bufname', ['%'], 'list:///location')\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire autocmd when location list disabled","suites":["showLocations()"],"updatePoint":{"line":37,"column":53},"line":37,"code":"  it('should fire autocmd when location list disabled', async () => {\n    Object.assign(workspace.env, {\n      locationlist: false\n    })\n    await nvim.exec(`\nfunction OnLocationsChange()\n  let g:called = 1\nendfunction\nautocmd User CocLocationsChange :call OnLocationsChange()`)\n    let locations = createLocations()\n    await workspace.showLocations(locations)\n    await helper.waitFor('eval', [`get(g:,'called',0)`], 1)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show quickfix when quickfix enabled","suites":["showLocations()"],"updatePoint":{"line":51,"column":48},"line":51,"code":"  it('should show quickfix when quickfix enabled', async () => {\n    helper.updateConfiguration('coc.preferences.useQuickfixForLocations', true)\n    let locations = createLocations()\n    await workspace.showLocations(locations)\n    await helper.waitFor('eval', [`&buftype`], 'quickfix')\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use customized quickfix open command","suites":["showLocations()"],"updatePoint":{"line":58,"column":49},"line":58,"code":"  it('should use customized quickfix open command', async () => {\n    await nvim.setVar('coc_quickfix_open_command', 'copen 1')\n    helper.updateConfiguration('coc.preferences.useQuickfixForLocations', true)\n    let locations = createLocations()\n    await workspace.showLocations(locations)\n    await helper.waitFor('eval', [`&buftype`], 'quickfix')\n    let win = await nvim.window\n    let height = await win.height\n    expect(height).toBe(1)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo position","suites":["jumpTo()"],"updatePoint":{"line":71,"column":28},"line":71,"code":"  it('should jumpTo position', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    await nvim.command('setl buftype=nofile')\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('/foo')\n    await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    let pos = await nvim.call('getcurpos')\n    expect(pos.slice(1, 3)).toEqual([2, 2])\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo uri without normalize","suites":["jumpTo()"],"updatePoint":{"line":84,"column":41},"line":84,"code":"  it('should jumpTo uri without normalize', async () => {\n    let uri = 'zipfile:///tmp/clojure-1.9.0.jar::clojure/core.clj'\n    await workspace.jumpTo(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe(uri)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump without position","suites":["jumpTo()"],"updatePoint":{"line":92,"column":34},"line":92,"code":"  it('should jump without position', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    await workspace.jumpTo(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('/foo')\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jumpTo custom uri scheme","suites":["jumpTo()"],"updatePoint":{"line":100,"column":37},"line":100,"code":"  it('should jumpTo custom uri scheme', async () => {\n    let uri = 'jdt://foo'\n    await workspace.jumpTo(uri, { line: 1, character: 1 })\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe(uri)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open resource","suites":["openResource()"],"updatePoint":{"line":111,"column":26},"line":111,"code":"  it('should open resource', async () => {\n    let uri = URI.file(path.join(os.tmpdir(), 'bar')).toString()\n    await workspace.openResource(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toMatch('bar')\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open none file uri","suites":["openResource()"],"updatePoint":{"line":119,"column":31},"line":119,"code":"  it('should open none file uri', async () => {\n    workspace.registerTextDocumentContentProvider('jd', {\n      provideTextDocumentContent: () => 'jd'\n    })\n    let uri = 'jd://abc'\n    await workspace.openResource(uri)\n    let buf = await nvim.buffer\n    let name = await buf.name\n    expect(name).toBe('jd://abc')\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open opened buffer","suites":["openResource()"],"updatePoint":{"line":130,"column":31},"line":130,"code":"  it('should open opened buffer', async () => {\n    let buf = await helper.edit()\n    let doc = workspace.getDocument(buf.id)\n    await workspace.openResource(doc.uri)\n    await helper.wait(30)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(bufnr).toBe(buf.id)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open url","suites":["openResource()"],"updatePoint":{"line":139,"column":21},"line":139,"code":"  it('should open url', async () => {\n    await helper.mockFunction('coc#ui#open_url', 0)\n    let buf = await helper.edit()\n    let uri = 'http://example.com'\n    await workspace.openResource(uri)\n    await helper.wait(30)\n    let bufnr = await nvim.call('bufnr', '%')\n    expect(bufnr).toBe(buf.id)\n  })","file":"core/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use cleaned env","suites":["create terminal"],"updatePoint":{"line":27,"column":28},"line":27,"code":"  it('should use cleaned env', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash'),\n      strictEnv: true\n    })\n    await helper.wait(50)\n    terminal.sendText(`echo $NODE_ENV`, true)\n    await helper.wait(50)\n    let buf = nvim.createBuffer(terminal.bufnr)\n    let lines = await buf.lines\n    expect(lines.includes('test')).toBe(false)\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use custom shell command","suites":["create terminal"],"updatePoint":{"line":41,"column":37},"line":41,"code":"  it('should use custom shell command', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash')\n    })\n    let bufnr = terminal.bufnr\n    let bufname = await nvim.call('bufname', [bufnr]) as string\n    expect(bufname.includes('bash')).toBe(true)\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use custom cwd","suites":["create terminal"],"updatePoint":{"line":51,"column":27},"line":51,"code":"  it('should use custom cwd', async () => {\n    let basename = path.basename(os.tmpdir())\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      cwd: os.tmpdir()\n    })\n    let bufnr = terminal.bufnr\n    let bufname = await nvim.call('bufname', [bufnr]) as string\n    expect(bufname.includes(basename)).toBe(true)\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have exit code","suites":["create terminal"],"updatePoint":{"line":62,"column":27},"line":62,"code":"  it('should have exit code', async () => {\n    let exitStatus\n    terminals.onDidCloseTerminal(terminal => {\n      exitStatus = terminal.exitStatus\n    })\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash'),\n      strictEnv: true\n    })\n    await helper.wait(50)\n    terminal.sendText('exit', true)\n    await helper.waitFor('bufloaded', [terminal.bufnr], 0)\n    await helper.wait(50)\n    expect(exitStatus).toBeDefined()\n    expect(exitStatus.code).toBeDefined()\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when show & hide disposed terminal","suites":["create terminal"],"updatePoint":{"line":80,"column":57},"line":80,"code":"  it('should not throw when show & hide disposed terminal', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash')\n    })\n    terminal.dispose()\n    await terminal.show()\n    await terminal.hide()\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show terminal on current window","suites":["create terminal"],"updatePoint":{"line":90,"column":44},"line":90,"code":"  it('should show terminal on current window', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash')\n    })\n    let winid = await nvim.call('bufwinid', [terminal.bufnr])\n    expect(winid).toBeGreaterThan(0)\n    await nvim.call('win_gotoid', [winid])\n    await terminal.show()\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show terminal that shown","suites":["create terminal"],"updatePoint":{"line":101,"column":37},"line":101,"code":"  it('should show terminal that shown', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash')\n    })\n    let res = await terminal.show(true)\n    expect(res).toBe(true)\n    expect(terminal.bufnr).toBeDefined()\n    let winid = await nvim.call('bufwinid', [terminal.bufnr])\n    let curr = await nvim.call('win_getid', [])\n    expect(winid != curr).toBe(true)\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show hidden terminal","suites":["create terminal"],"updatePoint":{"line":114,"column":33},"line":114,"code":"  it('should show hidden terminal', async () => {\n    let terminal = await terminals.createTerminal(nvim, {\n      name: 'test',\n      shellPath: which.sync('bash')\n    })\n    await terminal.hide()\n    await terminal.show()\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create terminal","suites":["create terminal"],"updatePoint":{"line":123,"column":28},"line":123,"code":"  it('should create terminal', async () => {\n    let terminal = await window.createTerminal({\n      name: 'test',\n    })\n    expect(terminal).toBeDefined()\n    expect(terminal.processId).toBeDefined()\n    expect(terminal.name).toBeDefined()\n    terminal.dispose()\n    await helper.wait(30)\n    expect(terminal.exitStatus).toEqual({ code: undefined })\n  })","file":"core/terminals.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get cursor position","suites":["getCursorPosition()"],"updatePoint":{"line":22,"column":32},"line":22,"code":"  it('should get cursor position', async () => {\n    await nvim.call('cursor', [1, 1])\n    let res = await ui.getCursorPosition(nvim)\n    expect(res).toEqual({\n      line: 0,\n      character: 0\n    })\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should moveTo position","suites":["moveTo()"],"updatePoint":{"line":33,"column":28},"line":33,"code":"  it('should moveTo position', async () => {\n    await nvim.setLine('foo')\n    await ui.moveTo(nvim, Position.create(0, 1), true)\n    let res = await ui.getCursorPosition(nvim)\n    expect(res).toEqual({ line: 0, character: 1 })\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get cursor screen position","suites":["getCursorScreenPosition()"],"updatePoint":{"line":42,"column":39},"line":42,"code":"  it('should get cursor screen position', async () => {\n    let res = await ui.getCursorScreenPosition(nvim)\n    expect(res).toBeDefined()\n    expect(typeof res.row).toBe('number')\n    expect(typeof res.col).toBe('number')\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create FloatFactory","suites":["createFloatFactory()"],"updatePoint":{"line":51,"column":32},"line":51,"code":"  it('should create FloatFactory', async () => {\n    let f = ui.createFloatFactory(nvim, { border: true, autoHide: false }, { close: true })\n    await f.show([{ content: 'shown', filetype: 'txt' }])\n    let activated = await f.activated()\n    expect(activated).toBe(true)\n    let win = await helper.getFloat()\n    expect(win).toBeDefined()\n    let id = await nvim.call('coc#float#get_related', [win.id, 'border', 0]) as number\n    expect(id).toBeGreaterThan(0)\n    id = await nvim.call('coc#float#get_related', [win.id, 'close', 0]) as number\n    expect(id).toBeGreaterThan(0)\n    await f.show([{ content: 'shown', filetype: 'txt' }], { offsetX: 10 })\n    let curr = await helper.getFloat()\n    expect(curr.id).toBe(win.id)\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should showMessage on vim","suites":["showMessage()"],"updatePoint":{"line":69,"column":31},"line":69,"code":"  it('should showMessage on vim', async () => {\n    ui.showMessage(nvim, 'my message', 'MoreMsg', true)\n    await helper.wait(100)\n    let cmdline = await helper.getCmdline()\n    expect(cmdline).toMatch(/my message/)\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when no selection exists","suites":["getSelection()"],"updatePoint":{"line":78,"column":49},"line":78,"code":"  it('should return null when no selection exists', async () => {\n    let res = await ui.getSelection(nvim, 'v')\n    expect(res).toBeNull()\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return range for line selection","suites":["getSelection()"],"updatePoint":{"line":83,"column":44},"line":83,"code":"  it('should return range for line selection', async () => {\n    await nvim.setLine('foo')\n    await nvim.input('V')\n    await nvim.input('<esc>')\n    let res = await ui.getSelection(nvim, 'V')\n    expect(res).toEqual({ start: { line: 0, character: 0 }, end: { line: 1, character: 0 } })\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return range of current line","suites":["getSelection()"],"updatePoint":{"line":91,"column":41},"line":91,"code":"  it('should return range of current line', async () => {\n    await nvim.command('normal! gg')\n    let res = await ui.getSelection(nvim, 'currline')\n    expect(res).toEqual(Range.create(0, 0, 1, 0))\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select range #1","suites":["selectRange()"],"updatePoint":{"line":99,"column":28},"line":99,"code":"  it('should select range #1', async () => {\n    await nvim.call('setline', [1, ['foo', 'b']])\n    await nvim.command('set selection=inclusive')\n    await nvim.command('set virtualedit=onemore')\n    await ui.selectRange(nvim, Range.create(0, 0, 1, 1), true)\n    await nvim.input('<esc>')\n    let res = await ui.getSelection(nvim, 'v')\n    expect(res).toEqual(Range.create(0, 0, 1, 1))\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select range #2","suites":["selectRange()"],"updatePoint":{"line":109,"column":28},"line":109,"code":"  it('should select range #2', async () => {\n    await nvim.call('setline', [1, ['foo', 'b']])\n    await ui.selectRange(nvim, Range.create(0, 0, 1, 0), true)\n    await nvim.input('<esc>')\n    let res = await ui.getSelection(nvim, 'v')\n    expect(res).toEqual(Range.create(0, 0, 0, 3))\n  })","file":"core/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get relative path","suites":["WorkspaceFolderController","asRelativePath()"],"updatePoint":{"line":56,"column":32},"line":56,"code":"    it('should get relative path', async () => {\n      workspaceFolder.addWorkspaceFolder(`/Coding/Applications/NewsWoWBot`, false)\n      assertAsRelativePath('/Coding/Applications/NewsWoWBot/bernd/das/brot', 'bernd/das/brot')\n      assertAsRelativePath('/Apps/DartPubCache/hosted/pub.dartlang.org/convert-2.0.1/lib/src/hex.dart',\n        '/Apps/DartPubCache/hosted/pub.dartlang.org/convert-2.0.1/lib/src/hex.dart')\n      assertAsRelativePath('', '')\n      assertAsRelativePath('/foo/bar', '/foo/bar')\n      assertAsRelativePath('in/out', 'in/out')\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asRelativePath, same paths, #11402","suites":["WorkspaceFolderController","asRelativePath()"],"updatePoint":{"line":66,"column":49},"line":66,"code":"    it('should asRelativePath, same paths, #11402', async () => {\n      const root = '/home/aeschli/workspaces/samples/docker'\n      const input = '/home/aeschli/workspaces/samples/docker'\n      workspaceFolder.addWorkspaceFolder(root, false)\n      assertAsRelativePath(input, input)\n      const input2 = '/home/aeschli/workspaces/samples/docker/a.file'\n      assertAsRelativePath(input2, 'a.file')\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asRelativePath, not workspaceFolder","suites":["WorkspaceFolderController","asRelativePath()"],"updatePoint":{"line":75,"column":50},"line":75,"code":"    it('should asRelativePath, not workspaceFolder', async () => {\n      expect(workspace.getRelativePath('')).toBe('')\n      assertAsRelativePath('/foo/bar', '/foo/bar')\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should asRelativePath, multiple folders","suites":["WorkspaceFolderController","asRelativePath()"],"updatePoint":{"line":80,"column":47},"line":80,"code":"    it('should asRelativePath, multiple folders', () => {\n      workspaceFolder.addWorkspaceFolder(`/Coding/One`, false)\n      workspaceFolder.addWorkspaceFolder(`/Coding/Two`, false)\n      assertAsRelativePath('/Coding/One/file.txt', 'One/file.txt')\n      assertAsRelativePath('/Coding/Two/files/out.txt', 'Two/files/out.txt')\n      assertAsRelativePath('/Coding/Two2/files/out.txt', '/Coding/Two2/files/out.txt')\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should slightly inconsistent behaviour of asRelativePath and getWorkspaceFolder, #31553","suites":["WorkspaceFolderController","asRelativePath()"],"updatePoint":{"line":88,"column":95},"line":88,"code":"    it('should slightly inconsistent behaviour of asRelativePath and getWorkspaceFolder, #31553', async () => {\n      workspaceFolder.addWorkspaceFolder(`/Coding/One`, false)\n      workspaceFolder.addWorkspaceFolder(`/Coding/Two`, false)\n\n      assertAsRelativePath('/Coding/One/file.txt', 'One/file.txt')\n      assertAsRelativePath('/Coding/One/file.txt', 'One/file.txt', true)\n      assertAsRelativePath('/Coding/One/file.txt', 'file.txt', false)\n      assertAsRelativePath('/Coding/Two/files/out.txt', 'Two/files/out.txt')\n      assertAsRelativePath('/Coding/Two/files/out.txt', 'Two/files/out.txt', true)\n      assertAsRelativePath('/Coding/Two/files/out.txt', 'files/out.txt', false)\n      assertAsRelativePath('/Coding/Two2/files/out.txt', '/Coding/Two2/files/out.txt')\n      assertAsRelativePath('/Coding/Two2/files/out.txt', '/Coding/Two2/files/out.txt', true)\n      assertAsRelativePath('/Coding/Two2/files/out.txt', '/Coding/Two2/files/out.txt', false)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set valid folders","suites":["WorkspaceFolderController","setWorkspaceFolders()"],"updatePoint":{"line":105,"column":32},"line":105,"code":"    it('should set valid folders', async () => {\n      workspaceFolder.setWorkspaceFolders([os.tmpdir(), '/a/not_exists'])\n      let folders = workspaceFolder.workspaceFolders\n      expect(folders.length).toBe(2)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get workspaceFolder by uri","suites":["WorkspaceFolderController","getWorkspaceFolder()"],"updatePoint":{"line":113,"column":41},"line":113,"code":"    it('should get workspaceFolder by uri', async () => {\n      let res = workspaceFolder.getWorkspaceFolder(URI.parse('untitled://1'))\n      expect(res).toBeUndefined()\n      res = workspaceFolder.getWorkspaceFolder(URI.file('/a/b'))\n      expect(res).toBeUndefined()\n      let filepath = path.join(process.cwd(), 'a/b')\n      workspaceFolder.setWorkspaceFolders([process.cwd()])\n      res = workspaceFolder.getWorkspaceFolder(URI.file(filepath))\n      expect(URI.parse(res.uri).fsPath).toBe(process.cwd())\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get patterns from b:coc_root_patterns","suites":["WorkspaceFolderController","getRootPatterns()"],"updatePoint":{"line":126,"column":52},"line":126,"code":"    it('should get patterns from b:coc_root_patterns', async () => {\n      await nvim.command('edit t.vim | let b:coc_root_patterns=[\"foo\"]')\n      await nvim.command('setf vim')\n      let doc = await workspace.document\n      let res = workspaceFolder.getRootPatterns(doc, PatternType.Buffer)\n      expect(res).toEqual(['foo'])\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get patterns from languageserver","suites":["WorkspaceFolderController","getRootPatterns()"],"updatePoint":{"line":134,"column":47},"line":134,"code":"    it('should get patterns from languageserver', async () => {\n      updateConfiguration('languageserver', {\n        test: {\n          filetypes: ['vim'],\n          rootPatterns: ['bar']\n        }\n      }, {})\n      workspaceFolder.addRootPattern('vim', ['foo'])\n      await nvim.command('edit t.vim')\n      await nvim.command('setf vim')\n      let doc = await workspace.document\n      let res = workspaceFolder.getRootPatterns(doc, PatternType.LanguageServer)\n      expect(res).toEqual(['bar', 'foo'])\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get patterns from user configuration","suites":["WorkspaceFolderController","getRootPatterns()"],"updatePoint":{"line":149,"column":51},"line":149,"code":"    it('should get patterns from user configuration', async () => {\n      let doc = await workspace.document\n      let res = workspaceFolder.getRootPatterns(doc, PatternType.Global)\n      expect(res.includes('.git')).toBe(true)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve to cwd for file in cwd","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":162,"column":45},"line":162,"code":"    it('should resolve to cwd for file in cwd', async () => {\n      updateConfiguration('coc.preferences.rootPatterns', [], ['.git', '.hg', '.projections.json'])\n      let file = path.join(os.tmpdir(), 'foo')\n      await nvim.command(`edit ${file}`)\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, os.tmpdir(), false, expand)\n      expect(res).toBe(os.tmpdir())\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not fallback to cwd as workspace folder","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":171,"column":54},"line":171,"code":"    it('should not fallback to cwd as workspace folder', async () => {\n      updateConfiguration('coc.preferences.rootPatterns', [], ['.git', '.hg', '.projections.json'])\n      updateConfiguration('workspace.workspaceFolderFallbackCwd', false, true)\n      let file = path.join(os.tmpdir(), 'foo')\n      await nvim.command(`edit ${file}`)\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, os.tmpdir(), false, expand)\n      expect(res).toBe(null)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null for untitled buffer","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":181,"column":46},"line":181,"code":"    it('should return null for untitled buffer', async () => {\n      await nvim.command('enew')\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, cwd, false, expand)\n      expect(res).toBe(null)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect ignored filetypes","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":188,"column":40},"line":188,"code":"    it('should respect ignored filetypes', async () => {\n      updateConfiguration('workspace.ignoredFiletypes', ['vim'], [])\n      await nvim.command('edit t.vim')\n      await nvim.command('setf vim')\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, cwd, false, expand)\n      expect(res).toBe(null)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect workspaceFolderCheckCwd","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":197,"column":46},"line":197,"code":"    it('should respect workspaceFolderCheckCwd', async () => {\n      let called = 0\n      disposables.push(workspaceFolder.onDidChangeWorkspaceFolders(() => {\n        called++\n      }))\n      workspaceFolder.addRootPattern('vim', ['.vim'])\n      await nvim.command('edit a/.vim/t.vim')\n      await nvim.command('setf vim')\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, cwd, true, expand)\n      expect(res).toBe(process.cwd())\n      await nvim.command('edit a/foo')\n      doc = await workspace.document\n      res = workspaceFolder.resolveRoot(doc, cwd, true, expand)\n      expect(res).toBe(process.cwd())\n      expect(called).toBe(1)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect ignored folders","suites":["WorkspaceFolderController","resolveRoot()"],"updatePoint":{"line":215,"column":38},"line":215,"code":"    it('should respect ignored folders', async () => {\n      updateConfiguration('workspace.ignoredFolders', ['$HOME/foo', '$HOME'], [])\n      let file = path.join(os.homedir(), '.vim/bar')\n      workspaceFolder.addRootPattern('vim', ['.vim'])\n      await nvim.command(`edit ${file}`)\n      await nvim.command('setf vim')\n      let doc = await workspace.document\n      let res = workspaceFolder.resolveRoot(doc, path.join(os.homedir(), 'foo'), true, expand)\n      expect(res).toBe(null)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect specific filetype","suites":["WorkspaceFolderController","resolveRoot()","bottomUpFileTypes"],"updatePoint":{"line":227,"column":42},"line":227,"code":"      it('should respect specific filetype', async () => {\n        updateConfiguration('coc.preferences.rootPatterns', ['.vim'], ['.git', '.hg', '.projections.json'])\n        updateConfiguration('workspace.bottomUpFiletypes', ['vim'], [])\n        let root = path.join(os.tmpdir(), 'a')\n        let dir = path.join(root, '.vim')\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true })\n        }\n        let file = path.join(dir, 'foo.vim')\n        await nvim.command(`edit ${file}`)\n        let doc = await workspace.document\n        expect(doc.filetype).toBe('vim')\n        let res = workspaceFolder.resolveRoot(doc, file, true, expand)\n        expect(res).toBe(root)\n      })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect wildcard","suites":["WorkspaceFolderController","resolveRoot()","bottomUpFileTypes"],"updatePoint":{"line":243,"column":33},"line":243,"code":"      it('should respect wildcard', async () => {\n        updateConfiguration('coc.preferences.rootPatterns', ['.vim'], ['.git', '.hg', '.projections.json'])\n        updateConfiguration('workspace.bottomUpFiletypes', ['*'], [])\n        let root = path.join(os.tmpdir(), 'a')\n        let dir = path.join(root, '.vim')\n        if (!fs.existsSync(dir)) {\n          fs.mkdirSync(dir, { recursive: true })\n          await helper.wait(30)\n        }\n        let file = path.join(dir, 'foo')\n        await nvim.command(`edit ${file}`)\n        let doc = await workspace.document\n        let res = workspaceFolder.resolveRoot(doc, file, true, expand)\n        expect(res).toBe(root)\n      })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename workspaceFolder","suites":["WorkspaceFolderController","renameWorkspaceFolder()"],"updatePoint":{"line":262,"column":37},"line":262,"code":"    it('should rename workspaceFolder', async () => {\n      let e: WorkspaceFoldersChangeEvent\n      disposables.push(workspaceFolder.onDidChangeWorkspaceFolders(ev => {\n        e = ev\n      }))\n      let cwd = process.cwd()\n      workspaceFolder.addWorkspaceFolder(cwd, false)\n      workspaceFolder.addWorkspaceFolder(cwd, false)\n      workspaceFolder.renameWorkspaceFolder(cwd, path.join(cwd, '.vim'))\n      expect(e.removed.length).toBe(1)\n      expect(e.added.length).toBe(1)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remote workspaceFolder","suites":["WorkspaceFolderController","removeWorkspaceFolder()"],"updatePoint":{"line":277,"column":37},"line":277,"code":"    it('should remote workspaceFolder', async () => {\n      let e: WorkspaceFoldersChangeEvent\n      disposables.push(workspaceFolder.onDidChangeWorkspaceFolders(ev => {\n        e = ev\n      }))\n      let cwd = process.cwd()\n      workspaceFolder.addWorkspaceFolder(cwd, false)\n      workspaceFolder.removeWorkspaceFolder(cwd)\n      workspaceFolder.removeWorkspaceFolder('/a/b')\n      expect(e.removed.length).toBe(1)\n      expect(e.added.length).toBe(0)\n    })","file":"core/workspaceFolder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for when provider does not exist","suites":["CallHierarchy"],"updatePoint":{"line":39,"column":51},"line":39,"code":"  it('should throw for when provider does not exist', async () => {\n    let err\n    try {\n      await callHierarchy.getIncoming()\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined when prepare failed","suites":["CallHierarchy"],"updatePoint":{"line":49,"column":46},"line":49,"code":"  it('should get undefined when prepare failed', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return undefined\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    let res = await callHierarchy.getOutgoing()\n    expect(res).toBeUndefined()\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get incoming & outgoing callHierarchy items","suites":["CallHierarchy"],"updatePoint":{"line":65,"column":56},"line":65,"code":"  it('should get incoming & outgoing callHierarchy items', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, 'test:///foo', Range.create(0, 0, 0, 5))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('bar', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return [{\n          to: createCallItem('bar', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(1, 0, 1, 5)]\n        }]\n      }\n    }))\n    let res = await callHierarchy.getIncoming()\n    expect(res.length).toBe(1)\n    expect(res[0].from.name).toBe('bar')\n    let outgoing = await callHierarchy.getOutgoing()\n    expect(outgoing.length).toBe(1)\n    res = await callHierarchy.getIncoming(outgoing[0].to)\n    expect(res.length).toBe(1)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when provider does not exist","suites":["CallHierarchy"],"updatePoint":{"line":92,"column":54},"line":92,"code":"  it('should show message when provider does not exist', async () => {\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toMatch('callHierarchy provider not found')\n    await nvim.command('wincmd p')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should no results when no result returned.","suites":["CallHierarchy"],"updatePoint":{"line":100,"column":48},"line":100,"code":"  it('should no results when no result returned.', async () => {\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return []\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toBe('No results')\n    await nvim.command('wincmd p')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render description and support default action","suites":["CallHierarchy"],"updatePoint":{"line":119,"column":58},"line":119,"code":"  it('should render description and support default action', async () => {\n    let doc = await workspace.document\n    let bufnr = doc.bufnr\n    await doc.buffer.setLines(['foo'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(1, 0, 1, 3))\n        item.detail = 'Detail'\n        item.tags = [SymbolTag.Deprecated]\n        return [{\n          from: item,\n          fromRanges: [Range.create(2, 0, 2, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        return []\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('t')\n    await helper.waitFor('getline', ['.'], '  - c bar Detail')\n    await nvim.input('<cr>')\n    await helper.waitFor('expand', ['%:p'], fsPath)\n    let res = await nvim.call('coc#cursor#position')\n    expect(res).toEqual([1, 0])\n    let matches = await nvim.call('getmatches') as any[]\n    expect(matches.length).toBe(2)\n    await nvim.command(`b ${bufnr}`)\n    await helper.wait(50)\n    matches = await nvim.call('getmatches')\n    expect(matches.length).toBe(0)\n    await nvim.command(`wincmd o`)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke open in new tab action","suites":["CallHierarchy"],"updatePoint":{"line":166,"column":42},"line":166,"code":"  it('should invoke open in new tab action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    let win = await nvim.window\n    let tab = await nvim.call('tabpagenr')\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(100)\n    await nvim.input('<cr>')\n    await helper.wait(200)\n    let newTab = await nvim.call('tabpagenr')\n    expect(newTab != tab).toBe(true)\n    doc = await workspace.document\n    expect(doc.uri).toBe(uri)\n    let res = await nvim.call('getmatches', [win.id])\n    expect(res.length).toBe(1)\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke show incoming calls action","suites":["CallHierarchy"],"updatePoint":{"line":210,"column":46},"line":210,"code":"  it('should invoke show incoming calls action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('test', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('2')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c bar Detail',\n      '  + c test'\n    ])\n    await nvim.command('bd!')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke show outgoing calls action","suites":["CallHierarchy"],"updatePoint":{"line":256,"column":46},"line":256,"code":"  it('should invoke show outgoing calls action', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return [{\n          from: createCallItem('test', SymbolKind.Class, 'test:///bar', Range.create(1, 0, 1, 5)),\n          fromRanges: [Range.create(0, 0, 0, 5)]\n        }]\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('incoming')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'INCOMING CALLS',\n      '- c foo',\n      '  + c test'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('3')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c test',\n      '  + c bar Detail'\n    ])\n    await nvim.command('bd!')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke dismiss action #1","suites":["CallHierarchy"],"updatePoint":{"line":302,"column":37},"line":302,"code":"  it('should invoke dismiss action #1', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('4')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo'\n    ])\n    await nvim.command('wincmd c')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke dismiss action #2","suites":["CallHierarchy"],"updatePoint":{"line":344,"column":37},"line":344,"code":"  it('should invoke dismiss action #2', async () => {\n    let doc = await workspace.document\n    await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    let fsPath = await createTmpFile('foo\\nbar\\ncontent\\n')\n    let uri = URI.file(fsPath).toString()\n    disposables.push(languages.registerCallHierarchyProvider([{ language: '*' }], {\n      prepareCallHierarchy() {\n        return createCallItem('foo', SymbolKind.Class, doc.uri, Range.create(0, 0, 0, 3))\n      },\n      provideCallHierarchyIncomingCalls() {\n        return []\n      },\n      provideCallHierarchyOutgoingCalls() {\n        let item = createCallItem('bar', SymbolKind.Class, uri, Range.create(0, 0, 0, 1))\n        item.detail = 'Detail'\n        return [{\n          to: item,\n          fromRanges: [Range.create(1, 0, 1, 3)]\n        }]\n      }\n    }))\n    await callHierarchy.showCallHierarchyTree('outgoing')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  + c bar Detail'\n    ])\n    await nvim.command('exe 3')\n    await nvim.input('t')\n    await helper.wait(50)\n    await nvim.command('exe 4')\n    await nvim.input('<tab>')\n    await helper.wait(50)\n    await nvim.input('4')\n    await helper.wait(200)\n    lines = await buf.lines\n    expect(lines).toEqual([\n      'OUTGOING CALLS',\n      '- c foo',\n      '  - c bar Detail'\n    ])\n    await nvim.command('wincmd c')\n  })","file":"handler/callHierarchy.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when organize import action not found","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":49,"column":64},"line":49,"code":"    it('should throw error when organize import action not found', async () => {\n      currActions = []\n      await helper.createDocument()\n      let err\n      try {\n        await codeActions.organizeImport()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should perform organize import action","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":61,"column":45},"line":61,"code":"    it('should perform organize import action', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.replace(Range.create(0, 0, 0, 3), 'bar'))\n      edits.push(TextEdit.replace(Range.create(1, 0, 1, 3), 'foo'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('organize import', edit, CodeActionKind.SourceOrganizeImports)\n      currActions = [action, CodeAction.create('another action')]\n      await codeActions.organizeImport()\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar', 'foo'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.organizeImport command","suites":["handler codeActions","organizeImport"],"updatePoint":{"line":75,"column":60},"line":75,"code":"    it('should register editor.action.organizeImport command', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.replace(Range.create(0, 0, 0, 3), 'bar'))\n      edits.push(TextEdit.replace(Range.create(1, 0, 1, 3), 'foo'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('organize import', edit, CodeActionKind.SourceOrganizeImports)\n      currActions = [action, CodeAction.create('another action')]\n      await commands.executeCommand('editor.action.organizeImport')\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar', 'foo'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when no action available","suites":["handler codeActions","codeActionRange"],"updatePoint":{"line":91,"column":52},"line":91,"code":"    it('should show warning when no action available', async () => {\n      await helper.createDocument()\n      currActions = []\n      await codeActions.codeActionRange(1, 2, CodeActionKind.QuickFix)\n      let line = await helper.getCmdline()\n      expect(line).toMatch(/No quickfix code action/)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply chosen action","suites":["handler codeActions","codeActionRange"],"updatePoint":{"line":99,"column":34},"line":99,"code":"    it('should apply chosen action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      let p = codeActions.codeActionRange(1, 2, CodeActionKind.QuickFix)\n      await helper.waitPrompt()\n      await nvim.input('<CR>')\n      await p\n      let buf = nvim.createBuffer(doc.bufnr)\n      let lines = await buf.lines\n      expect(lines[0]).toBe('bar')\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":117,"column":32},"line":117,"code":"    it('should get empty actions', async () => {\n      currActions = []\n      let doc = await helper.createDocument()\n      let res = await codeActions.getCodeActions(doc)\n      expect(res.length).toBe(0)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not filter disabled actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":124,"column":42},"line":124,"code":"    it('should not filter disabled actions', async () => {\n      currActions = []\n      let action = CodeAction.create('foo', CodeActionKind.QuickFix)\n      action.disabled = { reason: 'disabled' }\n      currActions.push(action)\n      action = CodeAction.create('foo', CodeActionKind.QuickFix)\n      action.disabled = { reason: 'disabled' }\n      currActions.push(action)\n      let doc = await helper.createDocument()\n      let res = await codeActions.getCodeActions(doc)\n      expect(res.length).toBe(1)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all actions","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":137,"column":30},"line":137,"code":"    it('should get all actions', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false })\n      let action = CodeAction.create('curr action', CodeActionKind.Empty)\n      currActions = [action]\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          return [CodeAction.create('a'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      let res = await codeActions.getCodeActions(doc)\n      expect(range).toEqual(Range.create(0, 0, 3, 0))\n      expect(res.length).toBe(4)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions by range","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":158,"column":38},"line":158,"code":"    it('should filter actions by range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['', '', ''], { start: 0, end: -1, strictIndexing: false })\n      currActions = []\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          if (rangeInRange(r, Range.create(0, 0, 1, 0))) return [CodeAction.create('a')]\n          return [CodeAction.create('a'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      let res = await codeActions.getCodeActions(doc, Range.create(0, 0, 0, 0))\n      expect(range).toEqual(Range.create(0, 0, 0, 0))\n      expect(res.length).toBe(1)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions by kind prefix","suites":["handler codeActions","getCodeActions"],"updatePoint":{"line":179,"column":44},"line":179,"code":"    it('should filter actions by kind prefix', async () => {\n      let doc = await helper.createDocument()\n      let action = CodeAction.create('my action', CodeActionKind.SourceFixAll)\n      currActions = [action]\n      let res = await codeActions.getCodeActions(doc, undefined, [CodeActionKind.Source])\n      expect(res.length).toBe(1)\n      expect(res[0].kind).toBe(CodeActionKind.SourceFixAll)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by line","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":204,"column":38},"line":204,"code":"    it('should get codeActions by line', async () => {\n      currActions = []\n      await helper.createDocument()\n      let res = await codeActions.getCurrentCodeActions('line')\n      expect(range).toEqual(Range.create(0, 0, 1, 0))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by cursor","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":212,"column":40},"line":212,"code":"    it('should get codeActions by cursor', async () => {\n      currActions = []\n      await helper.createDocument()\n      let res = await codeActions.getCurrentCodeActions('cursor')\n      expect(range).toEqual(Range.create(0, 0, 0, 0))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get codeActions by visual mode","suites":["handler codeActions","getCurrentCodeActions"],"updatePoint":{"line":220,"column":45},"line":220,"code":"    it('should get codeActions by visual mode', async () => {\n      currActions = []\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      await nvim.command('normal! 0v$')\n      await nvim.input('<esc>')\n      let res = await codeActions.getCurrentCodeActions('v')\n      expect(range).toEqual(Range.create(0, 0, 0, 3))\n      expect(res.length).toBe(3)\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when no action exists","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":233,"column":46},"line":233,"code":"    it('should not throw when no action exists', async () => {\n      currActions = []\n      await helper.createDocument()\n      let err\n      try {\n        await codeActions.doCodeAction(undefined)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeUndefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply single code action when only is title","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":245,"column":58},"line":245,"code":"    it('should apply single code action when only is title', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      await codeActions.doCodeAction(undefined, 'code fix')\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply single code action when only is codeAction array","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":257,"column":69},"line":257,"code":"    it('should apply single code action when only is codeAction array', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action]\n      await codeActions.doCodeAction(undefined, [CodeActionKind.QuickFix])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show disabled code action","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":269,"column":40},"line":269,"code":"    it('should show disabled code action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let refactorAction = CodeAction.create('code refactor', edit, CodeActionKind.Refactor)\n      refactorAction.disabled = { reason: 'invalid position' }\n      let fixAction = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [refactorAction, fixAction]\n      let p = codeActions.doCodeAction(undefined)\n      let winid = await helper.waitFloat()\n      let win = nvim.createWindow(winid)\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines.length).toBe(2)\n      expect(lines[1]).toMatch(/code refactor/)\n      await nvim.input('2')\n      await helper.wait(50)\n      await nvim.input('j')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      let valid = await win.valid\n      expect(valid).toBe(true)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch(/invalid position/)\n      await nvim.input('<esc>')\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should action dialog to choose action","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":297,"column":45},"line":297,"code":"    it('should action dialog to choose action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      currActions = [action, CodeAction.create('foo')]\n      let promise = codeActions.doCodeAction(null)\n      await helper.wait(50)\n      let ids = await nvim.call('coc#float#get_float_win_list') as number[]\n      expect(ids.length).toBeGreaterThan(0)\n      await nvim.input('<CR>')\n      await promise\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should choose code actions by range","suites":["handler codeActions","doCodeAction"],"updatePoint":{"line":314,"column":43},"line":314,"code":"    it('should choose code actions by range', async () => {\n      let range: Range\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: (\n          _document: TextDocument,\n          r: Range,\n          _context: CodeActionContext, _token: CancellationToken\n        ) => {\n          range = r\n          return [CodeAction.create('my title'), CodeAction.create('b'), CodeAction.create('c')]\n        },\n      }, undefined))\n      await helper.createDocument()\n      await nvim.setLine('abc')\n      await nvim.command('normal! 0v$')\n      await nvim.input('<esc>')\n      await codeActions.doCodeAction('v', 'my title')\n      expect(range).toEqual({ start: { line: 0, character: 0 }, end: { line: 0, character: 3 } })\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when quickfix action does not exist","suites":["handler codeActions","doQuickfix"],"updatePoint":{"line":336,"column":56},"line":336,"code":"    it('should throw when quickfix action does not exist', async () => {\n      let err\n      currActions = []\n      await helper.createDocument()\n      try {\n        await codeActions.doQuickfix()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do preferred quickfix action","suites":["handler codeActions","doQuickfix"],"updatePoint":{"line":348,"column":43},"line":348,"code":"    it('should do preferred quickfix action', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', edit, CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [CodeAction.create('foo', CodeActionKind.QuickFix), action, CodeAction.create('bar')]\n      await codeActions.doQuickfix()\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve codeAction","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":363,"column":33},"line":363,"code":"    it('should resolve codeAction', async () => {\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [action]\n      resolvedAction = Object.assign({ edit }, action)\n      let arr = await codeActions.getCurrentCodeActions('line', [CodeActionKind.QuickFix])\n      await codeActions.applyCodeAction(arr[0])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for disabled action","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":378,"column":40},"line":378,"code":"    it('should throw for disabled action', async () => {\n      let action: any = CodeAction.create('my action', CodeActionKind.Empty)\n      action.disabled = { reason: 'disabled', providerId: 'x' }\n      let err\n      try {\n        await codeActions.applyCodeAction(action)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke registered command after apply edit","suites":["handler codeActions","applyCodeAction"],"updatePoint":{"line":390,"column":57},"line":390,"code":"    it('should invoke registered command after apply edit', async () => {\n      let called\n      disposables.push(commands.registerCommand('test.execute', async (s: string) => {\n        called = s\n        await nvim.command(s)\n      }))\n      let doc = await helper.createDocument()\n      let edits: TextEdit[] = []\n      edits.push(TextEdit.insert(Position.create(0, 0), 'bar'))\n      let edit = { changes: { [doc.uri]: edits } }\n      let action = CodeAction.create('code fix', CodeActionKind.QuickFix)\n      action.isPreferred = true\n      currActions = [action]\n      resolvedAction = Object.assign({\n        edit,\n        command: Command.create('run vim command', 'test.execute', 'normal! $')\n      }, action)\n      let arr = await codeActions.getCurrentCodeActions('line', [CodeActionKind.QuickFix])\n      await codeActions.applyCodeAction(arr[0])\n      let lines = await doc.buffer.lines\n      expect(lines).toEqual(['bar'])\n      expect(called).toBe('normal! $')\n    })","file":"handler/codeActions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do codeLenes request and resolve codeLenes","suites":["codeLenes featrue"],"updatePoint":{"line":58,"column":55},"line":58,"code":"  it('should do codeLenes request and resolve codeLenes', async () => {\n    let buf = await createBufferWithCodeLens()\n    let doc = await workspace.document\n    let codelens = buf.currentCodeLens\n    expect(codelens).toBeDefined()\n    expect(codelens[0].command).toBeDefined()\n    let markers = await helper.getMarkers(doc.bufnr, srcId)\n    expect(markers.length).toBe(1)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on empty changes","suites":["codeLenes featrue"],"updatePoint":{"line":68,"column":37},"line":68,"code":"  it('should refresh on empty changes', async () => {\n    await createBufferWithCodeLens()\n    let doc = await workspace.document\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    let markers = await helper.getMarkers(doc.bufnr, srcId)\n    expect(markers.length).toBe(1)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with empty codeLens","suites":["codeLenes featrue"],"updatePoint":{"line":77,"column":37},"line":77,"code":"  it('should work with empty codeLens', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return []\n      }\n    }))\n    let doc = await helper.createDocument('t.js')\n    let buf = codeLens.buffers.getItem(doc.bufnr)\n    let codelens = buf.currentCodeLens\n    expect(codelens).toBeUndefined()\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change codeLenes position","suites":["codeLenes featrue"],"updatePoint":{"line":89,"column":38},"line":89,"code":"  it('should change codeLenes position', async () => {\n    let fn = jest.fn()\n    helper.updateConfiguration('codeLens.position', 'eol')\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1)\n        }]\n      },\n      resolveCodeLens: codeLens => {\n        codeLens.command = Command.create('save', '__save', 1, 2, 3)\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await codeLens.checkProvider()\n    let res = await doc.buffer.getExtMarks(srcId, 0, -1, { details: true })\n    expect(res.length).toBeGreaterThan(0)\n    let arr = res[0][3]['virt_text']\n    expect(arr[0][0]).toBe('save')\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh codeLens on CursorHold","suites":["codeLenes featrue"],"updatePoint":{"line":115,"column":43},"line":115,"code":"  it('should refresh codeLens on CursorHold', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: document => {\n        let n = document.lineCount\n        let arr: any[] = []\n        for (let i = 0; i <= n - 2; i++) {\n          arr.push({\n            range: Range.create(i, 0, i, 1),\n            command: Command.create('save', '__save', i)\n          })\n        }\n        return arr\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await helper.wait(100)\n    let markers = await helper.getMarkers(doc.bufnr, srcId)\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    await events.fire('CursorHold', [doc.bufnr])\n    await helper.wait(200)\n    markers = await helper.getMarkers(doc.bufnr, srcId)\n    expect(markers.length).toBe(3)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel codeLenes request on document change","suites":["codeLenes featrue"],"updatePoint":{"line":140,"column":56},"line":140,"code":"  it('should cancel codeLenes request on document change', async () => {\n    let cancelled = false\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: (_, token) => {\n        return new Promise(resolve => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            resolve(null)\n          })\n          let timer = setTimeout(() => {\n            resolve([{\n              range: Range.create(0, 0, 0, 1)\n            }, {\n              range: Range.create(1, 0, 1, 1)\n            }])\n          }, 2000)\n          disposables.push({\n            dispose: () => {\n              clearTimeout(timer)\n            }\n          })\n        })\n      },\n      resolveCodeLens: codeLens => {\n        codeLens.command = Command.create('save', '__save')\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('codelens.js')\n    await helper.wait(50)\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'a\\nb\\nc')])\n    expect(cancelled).toBe(true)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve on CursorMoved","suites":["codeLenes featrue"],"updatePoint":{"line":175,"column":35},"line":175,"code":"  it('should resolve on CursorMoved', async () => {\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(90, 0, 90, 1)\n        }, {\n          range: Range.create(91, 0, 91, 1)\n        }]\n      },\n      resolveCodeLens: async codeLens => {\n        codeLens.command = Command.create('save', '__save')\n        return codeLens\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    let arr = new Array(100)\n    arr.fill('')\n    await nvim.call('setline', [1, arr])\n    await doc.synchronize()\n    await codeLens.checkProvider()\n    await nvim.command('normal! gg')\n    await nvim.command('normal! G')\n    await helper.wait(100)\n    let buf = codeLens.buffers.getItem(doc.bufnr)\n    let codelens = buf.currentCodeLens\n    expect(codelens).toBeDefined()\n    expect(codelens[0].command).toBeDefined()\n    expect(codelens[1].command).toBeDefined()\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke codeLenes action","suites":["codeLenes featrue"],"updatePoint":{"line":205,"column":36},"line":205,"code":"  it('should invoke codeLenes action', async () => {\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    await createBufferWithCodeLens()\n    await helper.doAction('codeLensAction')\n    expect(fn).toBeCalledWith(1, 2, 3)\n    await nvim.command('normal! G')\n    await helper.doAction('codeLensAction')\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use picker for multiple codeLenses","suites":["codeLenes featrue"],"updatePoint":{"line":217,"column":47},"line":217,"code":"  it('should use picker for multiple codeLenses', async () => {\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(commands.registerCommand('__delete', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: 'javascript' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('save', '__save', 1, 2, 3)\n        }, {\n          range: Range.create(0, 1, 0, 2),\n          command: Command.create('save', '__delete', 4, 5, 6)\n        }]\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    await codeLens.checkProvider()\n    let p = helper.doAction('codeLensAction')\n    await helper.waitPrompt()\n    await nvim.input('<cr>')\n    await p\n    expect(fn).toBeCalledWith(1, 2, 3)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh for failed codeLens request","suites":["codeLenes featrue"],"updatePoint":{"line":247,"column":48},"line":247,"code":"  it('should refresh for failed codeLens request', async () => {\n    let called = 0\n    let fn = jest.fn()\n    disposables.push(commands.registerCommand('__save', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(commands.registerCommand('__foo', (...args) => {\n      fn(...args)\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        called++\n        if (called == 1) {\n          return null\n        }\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('foo', '__foo')\n        }]\n      }\n    }))\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 0, 1),\n          command: Command.create('save', '__save')\n        }]\n      }\n    }))\n    let doc = await helper.createDocument('example.js')\n    await helper.wait(50)\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await codeLens.checkProvider()\n    let markers = await helper.getMarkers(doc.buffer.id, srcId)\n    expect(markers.length).toBeGreaterThan(0)\n    let codeLensBuffer = codeLens.buffers.getItem(doc.buffer.id)\n    await codeLensBuffer.forceFetch()\n    let curr = codeLensBuffer.currentCodeLens\n    expect(curr.length).toBeGreaterThan(1)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use custom separator & position","suites":["codeLenes featrue"],"updatePoint":{"line":288,"column":44},"line":288,"code":"  it('should use custom separator & position', async () => {\n    helper.updateConfiguration('codeLens.separator', '|')\n    helper.updateConfiguration('codeLens.position', 'eol')\n    let doc = await helper.createDocument('example.js')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await doc.synchronize()\n    disposables.push(languages.registerCodeLensProvider([{ language: '*' }], {\n      provideCodeLenses: () => {\n        return [{\n          range: Range.create(0, 0, 1, 0),\n          command: Command.create('save', '__save')\n        }, {\n          range: Range.create(0, 0, 1, 0),\n          command: Command.create('save', '__save')\n        }]\n      }\n    }))\n    await codeLens.checkProvider()\n    let res = await doc.buffer.getExtMarks(srcId, 0, -1, { details: true })\n    expect(res.length).toBe(1)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get commands from codeLenses","suites":["codeLenes featrue"],"updatePoint":{"line":310,"column":41},"line":310,"code":"  it('should get commands from codeLenses', async () => {\n    expect(getCommands(1, undefined)).toEqual([])\n    let codeLenses = [CodeLens.create(Range.create(0, 0, 0, 0))]\n    expect(getCommands(0, codeLenses)).toEqual([])\n    codeLenses = [CodeLens.create(Range.create(0, 0, 1, 0)), CodeLens.create(Range.create(2, 0, 3, 0))]\n    codeLenses[0].command = Command.create('save', '__save')\n    expect(getCommands(0, codeLenses).length).toEqual(1)\n  })","file":"handler/codelens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get hex string","suites":["Colors","utils"],"updatePoint":{"line":68,"column":29},"line":68,"code":"    it('should get hex string', () => {\n      let color = getColor(255, 255, 255)\n      let hex = toHexString(color)\n      expect(hex).toBe('ffffff')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle enable state on configuration change","suites":["Colors","configuration"],"updatePoint":{"line":76,"column":58},"line":76,"code":"    it('should toggle enable state on configuration change', async () => {\n      let doc = await helper.createDocument()\n      helper.updateConfiguration('colors.filetypes', [])\n      let enabled = colors.isEnabled(doc.bufnr)\n      helper.updateConfiguration('colors.filetypes', ['*'])\n      expect(enabled).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.pickColor command","suites":["Colors","commands"],"updatePoint":{"line":86,"column":55},"line":86,"code":"    it('should register editor.action.pickColor command', async () => {\n      await helper.mockFunction('coc#color#pick_color', [0, 0, 0])\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await commands.executeCommand('editor.action.pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#000000')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register editor.action.colorPresentation command","suites":["Colors","commands"],"updatePoint":{"line":97,"column":63},"line":97,"code":"    it('should register editor.action.colorPresentation command', async () => {\n      colorPresentations = [ColorPresentation.create('red'), ColorPresentation.create('#ff0000')]\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      await doc.synchronize()\n      await colors.doHighlight(doc.bufnr)\n      let p = commands.executeCommand('editor.action.colorPresentation')\n      await helper.waitPrompt()\n      await nvim.input('1')\n      await p\n      let line = await nvim.getLine()\n      expect(line).toBe('red')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clearHighlight on empty result","suites":["Colors","doHighlight"],"updatePoint":{"line":113,"column":45},"line":113,"code":"    it('should clearHighlight on empty result', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      state = 'empty'\n      await colors.doHighlight(doc.bufnr)\n      let res = colors.hasColor(doc.bufnr)\n      expect(res).toBe(false)\n      state = 'normal'\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on error result","suites":["Colors","doHighlight"],"updatePoint":{"line":123,"column":40},"line":123,"code":"    it('should not throw on error result', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      state = 'error'\n      let err\n      try {\n        await colors.doHighlight(doc.bufnr)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeUndefined()\n      state = 'normal'\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight after document changed","suites":["Colors","doHighlight"],"updatePoint":{"line":137,"column":47},"line":137,"code":"    it('should highlight after document changed', async () => {\n      let doc = await helper.createDocument()\n      await colors.doHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(false)\n      expect(colors.hasColorAtPosition(doc.bufnr, Position.create(0, 1))).toBe(false)\n      await nvim.setLine('#ffffff #ff0000')\n      await doc.synchronize()\n      await helper.waitValue(() => {\n        return colors.hasColorAtPosition(doc.bufnr, Position.create(0, 1))\n      }, true)\n      expect(colors.hasColor(doc.bufnr)).toBe(true)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clearHighlight on clearHighlight","suites":["Colors","doHighlight"],"updatePoint":{"line":150,"column":47},"line":150,"code":"    it('should clearHighlight on clearHighlight', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff #ff0000')\n      await doc.synchronize()\n      await colors.doHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(true)\n      colors.clearHighlight(doc.bufnr)\n      expect(colors.hasColor(doc.bufnr)).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight colors","suites":["Colors","doHighlight"],"updatePoint":{"line":160,"column":31},"line":160,"code":"    it('should highlight colors', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      await colors.doHighlight(doc.bufnr)\n      let exists = await nvim.call('hlexists', 'BGffffff')\n      expect(exists).toBe(1)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when bufnr does not exist","suites":["Colors","hasColor()"],"updatePoint":{"line":170,"column":53},"line":170,"code":"    it('should return false when bufnr does not exist', async () => {\n      let res = colors.hasColor(99)\n      colors.clearHighlight(99)\n      expect(res).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when highlighter does not exist","suites":["Colors","getColorInformation()"],"updatePoint":{"line":178,"column":58},"line":178,"code":"    it('should return null when highlighter does not exist', async () => {\n      let res = await colors.getColorInformation(99)\n      expect(res).toBe(null)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when color not found","suites":["Colors","getColorInformation()"],"updatePoint":{"line":183,"column":47},"line":183,"code":"    it('should return null when color not found', async () => {\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff foo ')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await nvim.call('cursor', [1, 12])\n      let res = await colors.getColorInformation(doc.bufnr)\n      expect(res).toBe(null)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when bufnr does not exist","suites":["Colors","hasColorAtPosition()"],"updatePoint":{"line":195,"column":53},"line":195,"code":"    it('should return false when bufnr does not exist', async () => {\n      let res = colors.hasColorAtPosition(99, Position.create(0, 0))\n      expect(res).toBe(false)\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when color does not exist","suites":["Colors","pickPresentation()"],"updatePoint":{"line":202,"column":53},"line":202,"code":"    it('should show warning when color does not exist', async () => {\n      await helper.createDocument()\n      await colors.pickPresentation()\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Color not found')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when presentations do not exist","suites":["Colors","pickPresentation()"],"updatePoint":{"line":209,"column":56},"line":209,"code":"    it('should not throw when presentations do not exist', async () => {\n      colorPresentations = []\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(99)\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('colorPresentation')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pick presentations","suites":["Colors","pickPresentation()"],"updatePoint":{"line":219,"column":33},"line":219,"code":"    it('should pick presentations', async () => {\n      colorPresentations = [ColorPresentation.create('red'), ColorPresentation.create('#ff0000')]\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      let p = helper.doAction('colorPresentation')\n      await helper.waitPrompt()\n      await nvim.input('1')\n      await p\n      let line = await nvim.getLine()\n      expect(line).toBe('red')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when color does not exist","suites":["Colors","pickColor()"],"updatePoint":{"line":235,"column":53},"line":235,"code":"    it('should show warning when color does not exist', async () => {\n      await helper.createDocument()\n      await colors.pickColor()\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('not found')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should pickColor","suites":["Colors","pickColor()"],"updatePoint":{"line":242,"column":24},"line":242,"code":"    it('should pickColor', async () => {\n      await helper.mockFunction('coc#color#pick_color', [0, 0, 0])\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#000000')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when pick color return 0","suites":["Colors","pickColor()"],"updatePoint":{"line":253,"column":49},"line":253,"code":"    it('should not throw when pick color return 0', async () => {\n      await helper.mockFunction('coc#color#pick_color', 0)\n      let doc = await helper.createDocument()\n      await nvim.setLine('#ffffff')\n      doc.forceSync()\n      await colors.doHighlight(doc.bufnr)\n      await helper.doAction('pickColor')\n      let line = await nvim.getLine()\n      expect(line).toBe('#ffffff')\n    })","file":"handler/colors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register global vim commands","suites":["Commands","addVimCommand"],"updatePoint":{"line":32,"column":43},"line":32,"code":"    it('should register global vim commands', async () => {\n      await commandManager.executeCommand('vim.config')\n      await helper.wait(50)\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('coc-settings.json')\n      let list = commands.getCommandList()\n      expect(list.includes('vim.config')).toBe(true)\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add vim command with title","suites":["Commands","addVimCommand"],"updatePoint":{"line":41,"column":41},"line":41,"code":"    it('should add vim command with title', async () => {\n      commands.addVimCommand({ id: 'list', cmd: 'CocList', title: 'list of coc.nvim' })\n      let res = commandManager.titles.get('vim.list')\n      expect(res).toBe('list of coc.nvim')\n      commandManager.unregister('vim.list')\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get command items","suites":["Commands","getCommands"],"updatePoint":{"line":50,"column":32},"line":50,"code":"    it('should get command items', async () => {\n      let res = commands.getCommands()\n      let idx = res.findIndex(o => o.id == 'workspace.showOutput')\n      expect(idx != -1).toBe(true)\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should repeat command","suites":["Commands","repeat"],"updatePoint":{"line":58,"column":29},"line":58,"code":"    it('should repeat command', async () => {\n      // let buf = await nvim.buffer\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.call('cursor', [1, 1])\n      commands.addVimCommand({ id: 'remove', cmd: 'normal! dd' })\n      await commands.runCommand('vim.remove')\n      await helper.wait(50)\n      let res = await nvim.call('getline', [1, '$'])\n      expect(res).toEqual(['b', 'c'])\n      await commands.repeat()\n      await helper.wait(50)\n      res = await nvim.call('getline', [1, '$'])\n      expect(res).toEqual(['c'])\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open command list without id","suites":["Commands","runCommand"],"updatePoint":{"line":75,"column":43},"line":75,"code":"    it('should open command list without id', async () => {\n      await commands.runCommand()\n      await helper.wait(100)\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('list:///commands')\n    })","file":"handler/commands.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when provider does not exist","suites":["Folds"],"updatePoint":{"line":32,"column":53},"line":32,"code":"  it('should return null when provider does not exist', async () => {\n    let doc = await workspace.document\n    let token = (new CancellationTokenSource()).token\n    expect(await languages.provideFoldingRanges(doc.textDocument, {}, token)).toBe(null)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when no fold ranges found","suites":["Folds"],"updatePoint":{"line":38,"column":51},"line":38,"code":"  it('should return false when no fold ranges found', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return []\n      }\n    }))\n    let res = await folds.fold()\n    expect(res).toBe(false)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fold all fold ranges","suites":["Folds"],"updatePoint":{"line":48,"column":33},"line":48,"code":"  it('should fold all fold ranges', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return [FoldingRange.create(1, 3), FoldingRange.create(4, 6, 0, 0, 'comment')]\n      }\n    }))\n    await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']])\n    let res = await folds.fold()\n    expect(res).toBe(true)\n    let closed = await nvim.call('foldclosed', [2])\n    expect(closed).toBe(2)\n    closed = await nvim.call('foldclosed', [5])\n    expect(closed).toBe(5)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge folds from all providers","suites":["Folds"],"updatePoint":{"line":63,"column":43},"line":63,"code":"  it('should merge folds from all providers', async () => {\n    let doc = await workspace.document\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges() {\n        return [FoldingRange.create(1, 3), FoldingRange.create(4, 6)]\n      }\n    }))\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges() {\n        return [FoldingRange.create(1, 2), FoldingRange.create(5, 6), FoldingRange.create(7, 8)]\n      }\n    }))\n    await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']])\n    await doc.synchronize()\n    let foldingRanges = await languages.provideFoldingRanges(doc.textDocument, {}, CancellationToken.None)\n    expect(foldingRanges.length).toBe(4)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fold comment ranges","suites":["Folds"],"updatePoint":{"line":81,"column":32},"line":81,"code":"  it('should fold comment ranges', async () => {\n    disposables.push(languages.registerFoldingRangeProvider([{ language: '*' }], {\n      provideFoldingRanges(_doc) {\n        return [FoldingRange.create(1, 3), FoldingRange.create(4, 6, 0, 0, 'comment')]\n      }\n    }))\n    await nvim.call('setline', [1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']])\n    let res = await folds.fold('comment')\n    expect(res).toBe(true)\n    let closed = await nvim.call('foldclosed', [2])\n    expect(closed).toBe(-1)\n    closed = await nvim.call('foldclosed', [5])\n    expect(closed).toBe(5)\n  })","file":"handler/fold.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provider not found","suites":["format handler","documentFormat"],"updatePoint":{"line":35,"column":44},"line":35,"code":"    it('should throw when provider not found', async () => {\n      let doc = await helper.createDocument()\n      let err\n      try {\n        await format.documentFormat(doc)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when get empty edits ","suites":["format handler","documentFormat"],"updatePoint":{"line":46,"column":49},"line":46,"code":"    it('should return false when get empty edits ', async () => {\n      disposables.push(languages.registerDocumentFormatProvider(['*'], {\n        provideDocumentFormattingEdits: () => {\n          return []\n        }\n      }))\n      let doc = await helper.createDocument()\n      let res = await format.documentFormat(doc)\n      expect(res).toBe(false)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["format handler","formatOnSave"],"updatePoint":{"line":59,"column":48},"line":59,"code":"    it('should not throw when provider not found', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['javascript'])\n      let filepath = await createTmpFile('')\n      await helper.edit(filepath)\n      await nvim.command('setf javascript')\n      await nvim.setLine('foo')\n      await nvim.command('silent w')\n      await helper.wait(100)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke format on save","suites":["format handler","formatOnSave"],"updatePoint":{"line":69,"column":36},"line":69,"code":"    it('should invoke format on save', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['text'])\n      disposables.push(languages.registerDocumentFormatProvider(['text'], {\n        provideDocumentFormattingEdits: document => {\n          let lines = document.getText().replace(/\\n$/, '').split(/\\n/)\n          let edits: TextEdit[] = []\n          for (let i = 0; i < lines.length; i++) {\n            let text = lines[i]\n            if (!text.startsWith(' ')) {\n              edits.push(TextEdit.insert(Position.create(i, 0), '  '))\n            }\n          }\n          return edits\n        }\n      }))\n      let filepath = await createTmpFile('a\\nb\\nc\\n')\n      let buf = await helper.edit(filepath)\n      await nvim.command('setf text')\n      await nvim.command('w')\n      let lines = await buf.lines\n      expect(lines).toEqual(['  a', '  b', '  c'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when timeout","suites":["format handler","formatOnSave"],"updatePoint":{"line":92,"column":34},"line":92,"code":"    it('should cancel when timeout', async () => {\n      helper.updateConfiguration('coc.preferences.formatOnSaveFiletypes', ['*'])\n      disposables.push(languages.registerDocumentFormatProvider(['*'], {\n        provideDocumentFormattingEdits: () => {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              resolve(undefined)\n            }, 2000)\n          })\n        }\n      }))\n      let filepath = await createTmpFile('a\\nb\\nc\\n')\n      await helper.edit(filepath)\n      let n = Date.now()\n      await nvim.command('w')\n      expect(Date.now() - n).toBeLessThan(1000)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when provider does not exist","suites":["format handler","rangeFormat"],"updatePoint":{"line":112,"column":55},"line":112,"code":"    it('should return null when provider does not exist', async () => {\n      let doc = (await workspace.document).textDocument\n      let range = Range.create(0, 0, 1, 0)\n      let options = await workspace.getFormatOptions()\n      let token = (new CancellationTokenSource()).token\n      expect(await languages.provideDocumentRangeFormattingEdits(doc, range, options, token)).toBe(null)\n      expect(languages.hasProvider('onTypeEdit', doc)).toBe(false)\n      let edits = await languages.provideDocumentFormattingEdits(doc, options, token)\n      expect(edits).toBe(null)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke range format","suites":["format handler","rangeFormat"],"updatePoint":{"line":123,"column":34},"line":123,"code":"    it('should invoke range format', async () => {\n      disposables.push(languages.registerDocumentRangeFormatProvider(['text'], {\n        provideDocumentRangeFormattingEdits: (_document, range) => {\n          let lines: number[] = []\n          for (let i = range.start.line; i <= range.end.line; i++) {\n            lines.push(i)\n          }\n          return lines.map(i => {\n            return TextEdit.insert(Position.create(i, 0), '  ')\n          })\n        }\n      }))\n      let doc = await helper.createDocument()\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.command('setf text')\n      await nvim.command('normal! ggvG')\n      await nvim.input('<esc>')\n      expect(languages.hasFormatProvider(doc.textDocument)).toBe(true)\n      expect(languages.hasProvider('format', doc.textDocument)).toBe(true)\n      await helper.doAction('formatSelected', 'v')\n      let buf = nvim.createBuffer(doc.bufnr)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  a', '  b', '  c'])\n      let options = await workspace.getFormatOptions(doc.uri)\n      let token = (new CancellationTokenSource()).token\n      let edits = await languages.provideDocumentFormattingEdits(doc.textDocument, options, token)\n      expect(edits.length).toBeGreaterThan(0)\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format range by formatexpr option","suites":["format handler","rangeFormat"],"updatePoint":{"line":152,"column":48},"line":152,"code":"    it('should format range by formatexpr option', async () => {\n      let range: Range\n      disposables.push(languages.registerDocumentRangeFormatProvider(['text'], {\n        provideDocumentRangeFormattingEdits: (_document, r) => {\n          range = r\n          return []\n        }\n      }))\n      await helper.createDocument()\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      await nvim.command('setf text')\n      await nvim.command(`setl formatexpr=CocAction('formatSelected')`)\n      await nvim.command('normal! ggvGgq')\n      expect(range).toEqual({\n        start: { line: 0, character: 0 }, end: { line: 3, character: 0 }\n      })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke format","suites":["format handler","formatOnType"],"updatePoint":{"line":172,"column":28},"line":172,"code":"    it('should invoke format', async () => {\n      disposables.push(languages.registerDocumentFormatProvider(['text'], {\n        provideDocumentFormattingEdits: () => {\n          return [TextEdit.insert(Position.create(0, 0), '  ')]\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      await nvim.command('setf text')\n      await helper.doAction('format')\n      let line = await nvim.line\n      expect(line).toEqual('  foo')\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should does format on type","suites":["format handler","formatOnType"],"updatePoint":{"line":186,"column":34},"line":186,"code":"    it('should does format on type', async () => {\n      disposables.push(languages.registerOnTypeFormattingEditProvider(['text'], {\n        provideOnTypeFormattingEdits: () => {\n          return [TextEdit.insert(Position.create(0, 0), '  ')]\n        }\n      }, ['|']))\n      await helper.edit()\n      await nvim.command('setf text')\n      await nvim.input('i|')\n      await helper.wait(200)\n      let line = await nvim.line\n      expect(line).toBe('  |')\n      let cursor = await window.getCursorPosition()\n      expect(cursor).toEqual({ line: 0, character: 3 })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor after format on type","suites":["format handler","formatOnType"],"updatePoint":{"line":202,"column":49},"line":202,"code":"    it('should adjust cursor after format on type', async () => {\n      disposables.push(languages.registerOnTypeFormattingEditProvider(['text'], {\n        provideOnTypeFormattingEdits: () => {\n          return [\n            TextEdit.insert(Position.create(0, 0), '  '),\n            TextEdit.insert(Position.create(0, 2), 'end')\n          ]\n        }\n      }, ['|']))\n      await helper.edit()\n      await nvim.command('setf text')\n      await nvim.setLine('\"')\n      await nvim.input('i|')\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toBe('  |\"end')\n      let cursor = await window.getCursorPosition()\n      expect(cursor).toEqual({ line: 0, character: 3 })\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format vim file on enter","suites":["format handler","bracketEnterImprove"],"updatePoint":{"line":228,"column":39},"line":228,"code":"    it('should format vim file on enter', async () => {\n      let buf = await helper.edit('foo.vim')\n      await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : \"\\\\<C-g>u\\\\<CR>\\\\<c-r>=coc#on_enter()\\\\<CR>\"`)\n      await nvim.setLine('let foo={}')\n      await nvim.command(`normal! gg$`)\n      await nvim.input('i')\n      await nvim.eval(`feedkeys(\"\\\\<CR>\", 'im')`)\n      await helper.wait(100)\n      let lines = await buf.lines\n      expect(lines).toEqual(['let foo={', '  \\\\ ', '  \\\\ }'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add new line between bracket","suites":["format handler","bracketEnterImprove"],"updatePoint":{"line":240,"column":43},"line":240,"code":"    it('should add new line between bracket', async () => {\n      let buf = await helper.edit()\n      await nvim.command(`inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : \"\\\\<C-g>u\\\\<CR>\\\\<c-r>=coc#on_enter()\\\\<CR>\"`)\n      await nvim.setLine('  {}')\n      await nvim.command(`normal! gg$`)\n      await nvim.input('i')\n      await nvim.eval(`feedkeys(\"\\\\<CR>\", 'im')`)\n      await helper.wait(100)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  {', '  ', '  }'])\n    })","file":"handler/format.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when highlights provide does not exist","suites":["document highlights"],"updatePoint":{"line":67,"column":63},"line":67,"code":"  it('should return null when highlights provide does not exist', async () => {\n    let doc = await helper.createDocument()\n    let res = await highlights.getHighlights(doc, Position.create(0, 0))\n    expect(res).toBeNull()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel request on CursorMoved","suites":["document highlights"],"updatePoint":{"line":73,"column":42},"line":73,"code":"  it('should cancel request on CursorMoved', async () => {\n    let fn = jest.fn()\n    registerTimerProvider(fn, 3000)\n    await helper.edit()\n    await nvim.setLine('foo')\n    let p = highlights.highlight()\n    await helper.wait(50)\n    await nvim.call('cursor', [1, 2])\n    await p\n    expect(fn).toBeCalled()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel on timeout","suites":["document highlights"],"updatePoint":{"line":85,"column":30},"line":85,"code":"  it('should cancel on timeout', async () => {\n    helper.updateConfiguration('documentHighlight.timeout', 10)\n    let fn = jest.fn()\n    registerTimerProvider(fn, 3000)\n    await helper.edit()\n    await nvim.setLine('foo')\n    await highlights.highlight()\n    expect(fn).toBeCalled()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlights to symbols","suites":["document highlights"],"updatePoint":{"line":95,"column":38},"line":95,"code":"  it('should add highlights to symbols', async () => {\n    registProvider()\n    await helper.createDocument()\n    await nvim.setLine('foo bar foo')\n    await helper.doAction('highlight')\n    let winid = await nvim.call('win_getid') as number\n    expect(highlights.hasHighlights(winid)).toBe(true)\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return highlight ranges","suites":["document highlights"],"updatePoint":{"line":104,"column":36},"line":104,"code":"  it('should return highlight ranges', async () => {\n    registProvider()\n    await helper.createDocument()\n    await nvim.setLine('foo bar foo')\n    let res = await helper.doAction('symbolRanges')\n    expect(res.length).toBe(2)\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when cursor not in word range","suites":["document highlights"],"updatePoint":{"line":112,"column":54},"line":112,"code":"  it('should return null when cursor not in word range', async () => {\n    disposables.push(languages.registerDocumentHighlightProvider([{ language: '*' }], {\n      provideDocumentHighlights: () => {\n        return [{ range: Range.create(0, 0, 0, 3) }]\n      }\n    }))\n    let doc = await helper.createDocument()\n    await nvim.setLine('  oo')\n    await nvim.call('cursor', [1, 2])\n    let res = await highlights.getHighlights(doc, Position.create(0, 0))\n    expect(res).toBeNull()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when document is command line","suites":["document highlights"],"updatePoint":{"line":125,"column":52},"line":125,"code":"  it('should not throw when document is command line', async () => {\n    await nvim.call('feedkeys', ['q:', 'in'])\n    let doc = await workspace.document\n    expect(doc.isCommandLine).toBe(true)\n    await highlights.highlight()\n    await nvim.input('<C-c>')\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["document highlights"],"updatePoint":{"line":133,"column":46},"line":133,"code":"  it('should not throw when provider not found', async () => {\n    disposeAll(disposables)\n    await helper.createDocument()\n    await nvim.setLine('  oo')\n    await nvim.call('cursor', [1, 2])\n    await highlights.highlight()\n  })","file":"handler/highlights.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when hover not found","suites":["Hover","onHover"],"updatePoint":{"line":45,"column":48},"line":45,"code":"    it('should return false when hover not found', async () => {\n      hoverResult = null\n      let res = await hover.onHover('preview')\n      expect(res).toBe(false)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkupContent hover","suites":["Hover","onHover"],"updatePoint":{"line":51,"column":39},"line":51,"code":"    it('should show MarkupContent hover', async () => {\n      hoverResult = { contents: { kind: 'plaintext', value: 'my hover' } }\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('my hover')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge hover results","suites":["Hover","onHover"],"updatePoint":{"line":58,"column":34},"line":58,"code":"    it('should merge hover results', async () => {\n      hoverResult = { contents: { kind: 'plaintext', value: 'my hover' } }\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return null\n        }\n      }))\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: { kind: 'plaintext', value: 'my hover' } }\n        }\n      }))\n      let doc = await workspace.document\n      let hovers = await languages.getHover(doc.textDocument, Position.create(0, 0), CancellationToken.None)\n      expect(hovers.length).toBe(1)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkedString hover","suites":["Hover","onHover"],"updatePoint":{"line":75,"column":38},"line":75,"code":"    it('should show MarkedString hover', async () => {\n      hoverResult = { contents: 'string hover' }\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: { language: 'typescript', value: 'language hover' } }\n        }\n      }))\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('string hover')\n      expect(res).toMatch('language hover')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show MarkedString hover array","suites":["Hover","onHover"],"updatePoint":{"line":88,"column":44},"line":88,"code":"    it('should show MarkedString hover array', async () => {\n      hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] }\n      await hover.onHover('preview')\n      let res = await getDocumentText()\n      expect(res).toMatch('foo')\n      expect(res).toMatch('bar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight hover range","suites":["Hover","onHover"],"updatePoint":{"line":96,"column":36},"line":96,"code":"    it('should highlight hover range', async () => {\n      await nvim.setLine('var')\n      await nvim.command('normal! 0')\n      hoverResult = { contents: ['foo'], range: Range.create(0, 0, 0, 3) }\n      await hover.onHover('preview')\n      let res = await nvim.call('getmatches') as any[]\n      expect(res.length).toBe(1)\n      expect(res[0].group).toBe('CocHoverRange')\n      await helper.wait(600)\n      res = await nvim.call('getmatches')\n      expect(res.length).toBe(0)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo hover message","suites":["Hover","previewHover"],"updatePoint":{"line":111,"column":33},"line":111,"code":"    it('should echo hover message', async () => {\n      hoverResult = { contents: ['foo'] }\n      let res = await hover.onHover('echo')\n      expect(res).toBe(true)\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('foo')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show hover in float window","suites":["Hover","previewHover"],"updatePoint":{"line":119,"column":41},"line":119,"code":"    it('should show hover in float window', async () => {\n      hoverResult = { contents: { kind: 'markdown', value: '```typescript\\nconst foo:number\\n```' } }\n      await hover.onHover('float')\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await nvim.eval(`getbufline(winbufnr(${win.id}),1,'$')`)\n      expect(lines).toEqual(['const foo:number'])\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get hover from MarkedString array","suites":["Hover","getHover"],"updatePoint":{"line":130,"column":48},"line":130,"code":"    it('should get hover from MarkedString array', async () => {\n      hoverResult = { contents: ['foo', { language: 'typescript', value: 'bar' }] }\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: { language: 'typescript', value: 'MarkupContent hover' } }\n        }\n      }))\n      disposables.push(languages.registerHoverProvider([{ language: '*' }], {\n        provideHover: (_doc, _pos, _token) => {\n          return { contents: MarkedString.fromPlainText('MarkedString hover') }\n        }\n      }))\n      let res = await hover.getHover()\n      expect(res.includes('foo')).toBe(true)\n      expect(res.includes('bar')).toBe(true)\n      expect(res.includes('MarkupContent hover')).toBe(true)\n      expect(res.includes('MarkedString hover')).toBe(true)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter empty hover message","suites":["Hover","getHover"],"updatePoint":{"line":149,"column":41},"line":149,"code":"    it('should filter empty hover message', async () => {\n      hoverResult = { contents: [''] }\n      let res = await hover.getHover()\n      expect(res.length).toBe(0)\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load definition from buffer","suites":["Hover","definitionHover"],"updatePoint":{"line":157,"column":42},"line":157,"code":"    it('should load definition from buffer', async () => {\n      hoverResult = { contents: 'string hover' }\n      let doc = await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar')])\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition() {\n          return [{\n            targetUri: doc.uri,\n            targetRange: Range.create(0, 0, 1, 3),\n            targetSelectionRange: Range.create(0, 0, 0, 3),\n          }]\n        }\n      }))\n      await hover.definitionHover('preview')\n      let res = await getDocumentText()\n      expect(res).toBe('string hover\\n\\nfoo\\nbar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load definition link from file","suites":["Hover","definitionHover"],"updatePoint":{"line":176,"column":45},"line":176,"code":"    it('should load definition link from file', async () => {\n      let fsPath = await createTmpFile('foo\\nbar\\n')\n      hoverResult = { contents: 'string hover' }\n      let doc = await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar')])\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition() {\n          return [{\n            targetUri: URI.file(fsPath).toString(),\n            targetRange: Range.create(0, 0, 1, 3),\n            targetSelectionRange: Range.create(0, 0, 0, 3),\n          }]\n        }\n      }))\n      await hover.definitionHover('preview')\n      let res = await getDocumentText()\n      expect(res).toBe('string hover\\n\\nfoo\\nbar')\n    })","file":"handler/hover.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check provider for document","suites":["Handler","hasProvider"],"updatePoint":{"line":31,"column":42},"line":31,"code":"    it('should check provider for document', async () => {\n      let res = await handler.hasProvider('definition')\n      expect(res).toBe(false)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when provider not found","suites":["Handler","checkProvier"],"updatePoint":{"line":38,"column":50},"line":38,"code":"    it('should throw error when provider not found', async () => {\n      let doc = await helper.createDocument()\n      let err\n      try {\n        handler.checkProvier('definition', doc.textDocument)\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel previous request when called again","suites":["Handler","withRequestToken"],"updatePoint":{"line":51,"column":56},"line":51,"code":"    it('should cancel previous request when called again', async () => {\n      let cancelled = false\n      let p = handler.withRequestToken('test', token => {\n        return new Promise(s => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            s(undefined)\n          })\n          let timer = setTimeout(() => {\n            s(undefined)\n          }, 3000)\n        })\n      }, false)\n      setTimeout(async () => {\n        await handler.withRequestToken('test', () => {\n          return Promise.resolve(undefined)\n        }, false)\n      }, 50)\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel request on insert start","suites":["Handler","withRequestToken"],"updatePoint":{"line":74,"column":45},"line":74,"code":"    it('should cancel request on insert start', async () => {\n      let cancelled = false\n      let p = handler.withRequestToken('test', token => {\n        return new Promise(s => {\n          token.onCancellationRequested(() => {\n            cancelled = true\n            clearTimeout(timer)\n            s(undefined)\n          })\n          let timer = setTimeout(() => {\n            s(undefined)\n          }, 3000)\n        })\n      }, false)\n      await nvim.input('i')\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check same hint","suites":["InlayHint","utils"],"updatePoint":{"line":32,"column":30},"line":32,"code":"    it('should check same hint', () => {\n      let hint = InlayHint.create(Position.create(0, 0), 'foo')\n      expect(sameHint(hint, InlayHint.create(Position.create(0, 0), 'bar'))).toBe(false)\n      expect(sameHint(hint, InlayHint.create(Position.create(0, 0), [{ value: 'foo' }]))).toBe(true)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check valid hint","suites":["InlayHint","utils"],"updatePoint":{"line":38,"column":31},"line":38,"code":"    it('should check valid hint', () => {\n      let hint = InlayHint.create(Position.create(0, 0), 'foo')\n      expect(isValidInlayHint(hint, Range.create(0, 0, 1, 0))).toBe(true)\n      expect(isValidInlayHint(InlayHint.create(Position.create(0, 0), ''), Range.create(0, 0, 1, 0))).toBe(false)\n      expect(isValidInlayHint(InlayHint.create(Position.create(3, 0), 'foo'), Range.create(0, 0, 1, 0))).toBe(false)\n      expect(isValidInlayHint({ label: 'f' } as any, Range.create(0, 0, 1, 0))).toBe(false)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when failed","suites":["InlayHint","provideInlayHints"],"updatePoint":{"line":48,"column":36},"line":48,"code":"    it('should not throw when failed', async () => {\n      disposables.push(languages.registerInlayHintsProvider([{ language: '*' }], {\n        provideInlayHints: () => {\n          return Promise.reject(new Error('Test failure'))\n        }\n      }))\n      let doc = await workspace.document\n      let tokenSource = new CancellationTokenSource()\n      let res = await languages.provideInlayHints(doc.textDocument, Range.create(0, 0, 1, 0), tokenSource.token)\n      expect(res).toEqual([])\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge provide results","suites":["InlayHint","provideInlayHints"],"updatePoint":{"line":60,"column":36},"line":60,"code":"    it('should merge provide results', async () => {\n      disposables.push(languages.registerInlayHintsProvider([{ language: '*' }], {\n        provideInlayHints: () => {\n          return [InlayHint.create(Position.create(0, 0), 'foo')]\n        }\n      }))\n      disposables.push(languages.registerInlayHintsProvider([{ language: '*' }], {\n        provideInlayHints: () => {\n          return [\n            InlayHint.create(Position.create(0, 0), 'foo'),\n            InlayHint.create(Position.create(1, 0), 'bar'),\n            InlayHint.create(Position.create(5, 0), 'bad')]\n        }\n      }))\n      let doc = await workspace.document\n      let tokenSource = new CancellationTokenSource()\n      let res = await languages.provideInlayHints(doc.textDocument, Range.create(0, 0, 3, 0), tokenSource.token)\n      expect(res.length).toBe(2)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve inlay hint","suites":["InlayHint","provideInlayHints"],"updatePoint":{"line":80,"column":33},"line":80,"code":"    it('should resolve inlay hint', async () => {\n      disposables.push(languages.registerInlayHintsProvider([{ language: '*' }], {\n        provideInlayHints: () => {\n          return [InlayHint.create(Position.create(0, 0), 'foo')]\n        },\n        resolveInlayHint: hint => {\n          hint.tooltip = 'tooltip'\n          return hint\n        }\n      }))\n      let doc = await workspace.document\n      let tokenSource = new CancellationTokenSource()\n      let res = await languages.provideInlayHints(doc.textDocument, Range.create(0, 0, 1, 0), tokenSource.token)\n      let resolved = await languages.resolveInlayHint(res[0], tokenSource.token)\n      expect(resolved.tooltip).toBe('tooltip')\n      resolved = await languages.resolveInlayHint(resolved, tokenSource.token)\n      expect(resolved.tooltip).toBe('tooltip')\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve when cancelled","suites":["InlayHint","provideInlayHints"],"updatePoint":{"line":99,"column":41},"line":99,"code":"    it('should not resolve when cancelled', async () => {\n      disposables.push(languages.registerInlayHintsProvider([{ language: '*' }], {\n        provideInlayHints: () => {\n          return [InlayHint.create(Position.create(0, 0), 'foo')]\n        },\n        resolveInlayHint: (hint, token) => {\n          return new Promise(resolve => {\n            token.onCancellationRequested(() => {\n              clearTimeout(timer)\n              resolve(null)\n            })\n            let timer = setTimeout(() => {\n              resolve(Object.assign({}, hint, { tooltip: 'tooltip' }))\n            }, 200)\n          })\n        }\n      }))\n      let doc = await workspace.document\n      let tokenSource = new CancellationTokenSource()\n      let res = await languages.provideInlayHints(doc.textDocument, Range.create(0, 0, 1, 0), tokenSource.token)\n      let p = languages.resolveInlayHint(res[0], tokenSource.token)\n      tokenSource.cancel()\n      let resolved = await p\n      expect(resolved.tooltip).toBeUndefined()\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create when virtualText not supported","suites":["InlayHint","env & options"],"updatePoint":{"line":127,"column":56},"line":127,"code":"    it('should not create when virtualText not supported', async () => {\n      Object.assign(workspace.env, {\n        virtualText: false\n      })\n      disposables.push(Disposable.create(() => {\n        Object.assign(workspace.env, {\n          virtualText: true\n        })\n      }))\n      let doc = await helper.createDocument()\n      let item = handler.getItem(doc.bufnr)\n      expect(item).toBeUndefined()\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not enabled when disabled by configuration","suites":["InlayHint","env & options"],"updatePoint":{"line":141,"column":57},"line":141,"code":"    it('should not enabled when disabled by configuration', async () => {\n      helper.updateConfiguration('inlayHint.filetypes', [])\n      let doc = await workspace.document\n      let item = handler.getItem(doc.bufnr)\n      expect(item.enabled).toBe(false)\n      helper.updateConfiguration('inlayHint.filetypes', ['dos'])\n      doc = await helper.createDocument()\n      item = handler.getItem(doc.bufnr)\n      expect(item.enabled).toBe(false)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on vim mode","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":188,"column":34},"line":188,"code":"    it('should refresh on vim mode', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      let item = handler.getItem(doc.bufnr)\n      let r = Range.create(0, 0, 1, 0)\n      item.setVirtualText(r, [], true)\n      let hint: InlayHintWithProvider = {\n        label: 'string',\n        position: Position.create(0, 0),\n        providerId: ''\n      }\n      let paddingHint: InlayHintWithProvider = {\n        label: 'string',\n        position: Position.create(0, 3),\n        providerId: '',\n        paddingLeft: true,\n        paddingRight: true\n      }\n      item.setVirtualText(r, [hint, paddingHint], true)\n      await helper.waitValue(async () => {\n        let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true })\n        return markers.length\n      }, 2)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not refresh when languageId not match","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":213,"column":52},"line":213,"code":"    it('should not refresh when languageId not match', async () => {\n      let doc = await workspace.document\n      disposables.push(languages.registerInlayHintsProvider([{ language: 'javascript' }], {\n        provideInlayHints: () => {\n          let hint = InlayHint.create(Position.create(0, 0), 'foo')\n          return [hint]\n        }\n      }))\n      await nvim.setLine('foo')\n      await doc.synchronize()\n      await helper.wait(30)\n      let markers = await doc.buffer.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBe(0)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on text change","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":228,"column":37},"line":228,"code":"    it('should refresh on text change', async () => {\n      let buf = await nvim.buffer\n      let disposable = await registerProvider('foo')\n      disposables.push(disposable)\n      await waitRefresh(buf.id)\n      await buf.setLines(['a', 'b', 'c'], { start: 0, end: -1 })\n      await waitRefresh(buf.id)\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBe(3)\n      let item = handler.getItem(buf.id)\n      await item.renderRange()\n      expect(item.current.length).toBe(3)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on provider dispose","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":242,"column":42},"line":242,"code":"    it('should refresh on provider dispose', async () => {\n      let buf = await nvim.buffer\n      let disposable = await registerProvider('foo bar')\n      await waitRefresh(buf.id)\n      disposable.dispose()\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBe(0)\n      let item = handler.getItem(buf.id)\n      expect(item.current.length).toBe(0)\n      await item.renderRange()\n      expect(item.current.length).toBe(0)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on scroll","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":255,"column":32},"line":255,"code":"    it('should refresh on scroll', async () => {\n      let arr = new Array(200)\n      let content = arr.fill('foo').join('\\n')\n      let buf = await nvim.buffer\n      let disposable = await registerProvider(content)\n      disposables.push(disposable)\n      await waitRefresh(buf.id)\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      let len = markers.length\n      await nvim.command('normal! G')\n      await waitRefresh(buf.id)\n      await nvim.input('<C-y>')\n      await waitRefresh(buf.id)\n      markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBeGreaterThan(len)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel previous render","suites":["InlayHint","setVirtualText"],"updatePoint":{"line":272,"column":37},"line":272,"code":"    it('should cancel previous render', async () => {\n      let buf = await nvim.buffer\n      let disposable = await registerProvider('foo')\n      disposables.push(disposable)\n      await waitRefresh(buf.id)\n      let item = handler.getItem(buf.id)\n      await item.renderRange()\n      await item.renderRange()\n      expect(item.current.length).toBe(1)\n    })","file":"handler/inlayHint.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should active and cancel on cursor moved","suites":["LinkedEditing"],"updatePoint":{"line":56,"column":46},"line":56,"code":"  it('should active and cancel on cursor moved', async () => {\n    await registerProvider('foo foo a ', Position.create(0, 0))\n    await assertMatches(2)\n    await nvim.command(`normal! $`)\n    await helper.wait(50)\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should active when moved to another word","suites":["LinkedEditing"],"updatePoint":{"line":64,"column":46},"line":64,"code":"  it('should active when moved to another word', async () => {\n    await registerProvider('foo foo bar bar bar', Position.create(0, 0))\n    await nvim.call('cursor', [1, 9])\n    await helper.wait(50)\n    await assertMatches(3)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should active on text change","suites":["LinkedEditing"],"updatePoint":{"line":71,"column":34},"line":71,"code":"  it('should active on text change', async () => {\n    let doc = await workspace.document\n    await registerProvider('foo foo a ', Position.create(0, 0))\n    await assertMatches(2)\n    await nvim.call('cursor', [1, 1])\n    await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 0, ['i']])\n    await doc.synchronize()\n    let line = await nvim.line\n    expect(line).toBe('ifoo ifoo a ')\n    await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 1, []])\n    await doc.synchronize()\n    line = await nvim.line\n    expect(line).toBe('foo foo a ')\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when change out of range","suites":["LinkedEditing"],"updatePoint":{"line":86,"column":44},"line":86,"code":"  it('should cancel when change out of range', async () => {\n    let doc = await workspace.document\n    await registerProvider('foo foo bar', Position.create(0, 0))\n    await assertMatches(2)\n    await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 9, 0, 10, ['']])\n    await doc.synchronize()\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel on editor change","suites":["LinkedEditing"],"updatePoint":{"line":95,"column":36},"line":95,"code":"  it('should cancel on editor change', async () => {\n    await registerProvider('foo foo a ', Position.create(0, 0))\n    await nvim.command(`enew`)\n    await helper.wait(50)\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when insert none word character","suites":["LinkedEditing"],"updatePoint":{"line":102,"column":51},"line":102,"code":"  it('should cancel when insert none word character', async () => {\n    await registerProvider('foo foo a ', Position.create(0, 0))\n    await nvim.call('cursor', [1, 4])\n    await nvim.input('i')\n    await nvim.input('a')\n    await helper.wait(50)\n    await assertMatches(2)\n    await nvim.input('i')\n    await nvim.input('@')\n    await helper.wait(50)\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when insert not match wordPattern","suites":["LinkedEditing"],"updatePoint":{"line":115,"column":53},"line":115,"code":"  it('should cancel when insert not match wordPattern', async () => {\n    wordPattern = '[A-Z]'\n    await registerProvider('foo foo a ', Position.create(0, 0))\n    await nvim.call('cursor', [1, 4])\n    await nvim.input('i')\n    await nvim.input('A')\n    await helper.wait(50)\n    await assertMatches(2)\n    await nvim.input('i')\n    await nvim.input('3')\n    await helper.wait(50)\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel request on cursor moved","suites":["LinkedEditing"],"updatePoint":{"line":129,"column":43},"line":129,"code":"  it('should cancel request on cursor moved', async () => {\n    disposables.push(languages.registerLinkedEditingRangeProvider([{ language: '*' }], {\n      provideLinkedEditingRanges: (doc, pos, token) => {\n        return new Promise(resolve => {\n          token.onCancellationRequested(() => {\n            clearTimeout(timer)\n            resolve(null)\n          })\n          let timer = setTimeout(() => {\n            let document = workspace.getDocument(doc.uri)\n            let range = document.getWordRangeAtPosition(pos)\n            if (!range) return resolve(null)\n            let text = doc.getText(range)\n            let ranges: Range[] = document.getSymbolRanges(text)\n            resolve({ ranges, wordPattern })\n          }, 1000)\n        })\n      }\n    }))\n    let doc = await workspace.document\n    await nvim.setLine('foo foo  ')\n    await doc.synchronize()\n    await nvim.call('cursor', [1, 2])\n    await helper.wait(30)\n    await nvim.call('cursor', [1, 9])\n    await helper.wait(30)\n    await assertMatches(0)\n  })","file":"handler/linkedEditing.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get document links","suites":["Links"],"updatePoint":{"line":29,"column":31},"line":29,"code":"  it('should get document links', async () => {\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks: (_doc, _token) => {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5), 'test:///foo'),\n          DocumentLink.create(Range.create(1, 0, 1, 5), 'test:///bar')\n        ]\n      }\n    }))\n    let res = await links.getLinks()\n    expect(res.length).toBe(2)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge link results","suites":["Links"],"updatePoint":{"line":42,"column":31},"line":42,"code":"  it('should merge link results', async () => {\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks: () => {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5), 'test:///foo'),\n          DocumentLink.create(Range.create(1, 0, 1, 5), 'test:///bar')\n        ]\n      }\n    }))\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks: () => {\n        return [\n          DocumentLink.create(Range.create(1, 0, 1, 5), 'test:///bar')\n        ]\n      }\n    }))\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks: () => {\n        return null\n      }\n    }))\n    let res = await links.getLinks()\n    expect(res.length).toBe(2)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when link target not resolved","suites":["Links"],"updatePoint":{"line":67,"column":54},"line":67,"code":"  it('should throw error when link target not resolved', async () => {\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5))\n        ]\n      },\n      resolveDocumentLink(link) {\n        return link\n      }\n    }))\n    let res = await links.getLinks()\n    let err\n    try {\n      await links.openLink(res[0])\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open link at current position","suites":["Links"],"updatePoint":{"line":88,"column":42},"line":88,"code":"  it('should open link at current position', async () => {\n    await nvim.setLine('foo')\n    await nvim.command('normal! 0')\n    disposables.push(workspace.registerTextDocumentContentProvider('test', {\n      provideTextDocumentContent: () => {\n        return 'test'\n      }\n    }))\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return [\n          DocumentLink.create(Range.create(0, 0, 0, 5)),\n        ]\n      },\n      resolveDocumentLink(link) {\n        link.target = 'test:///foo'\n        return link\n      }\n    }))\n    await links.openCurrentLink()\n    let bufname = await nvim.call('bufname', '%')\n    expect(bufname).toBe('test:///foo')\n    await nvim.call('setline', [1, ['a', 'b', 'c']])\n    await nvim.call('cursor', [3, 1])\n    let res = await links.openCurrentLink()\n    expect(res).toBe(false)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when current links not found","suites":["Links"],"updatePoint":{"line":116,"column":54},"line":116,"code":"  it('should return false when current links not found', async () => {\n    await nvim.setLine('foo')\n    await nvim.command('normal! 0')\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        return []\n      }\n    }))\n    let res = await links.openCurrentLink()\n    expect(res).toBe(false)\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show tooltip","suites":["Links"],"updatePoint":{"line":128,"column":25},"line":128,"code":"  it('should show tooltip', async () => {\n    await nvim.setLine('foo')\n    await nvim.call('cursor', [1, 1])\n    disposables.push(languages.registerDocumentLinkProvider([{ language: '*' }], {\n      provideDocumentLinks(_doc, _token) {\n        let link = DocumentLink.create(Range.create(0, 0, 0, 5))\n        link.tooltip = 'test'\n        return [link]\n      },\n      resolveDocumentLink(link) {\n        link.target = 'http://example.com'\n        return link\n      }\n    }))\n    await links.showTooltip()\n    let win = await helper.getFloat()\n    let buf = await win.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toMatch('test')\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should enable tooltip on CursorHold","suites":["Links"],"updatePoint":{"line":149,"column":41},"line":149,"code":"  it('should enable tooltip on CursorHold', async () => {\n    let doc = await workspace.document\n    helper.updateConfiguration('links.tooltip', true)\n    await nvim.setLine('http://www.baidu.com')\n    await nvim.call('cursor', [1, 1])\n    let link = await links.getCurrentLink()\n    expect(link).toBeDefined()\n    await events.fire('CursorHold', [doc.bufnr])\n    let win = await helper.getFloat()\n    let buf = await win.buffer\n    let lines = await buf.lines\n    expect(lines[0]).toMatch('Press')\n  })","file":"handler/links.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when provider does not exist","suites":["locations","no provider"],"updatePoint":{"line":43,"column":55},"line":43,"code":"    it('should return null when provider does not exist', async () => {\n      let doc = (await workspace.document).textDocument\n      let pos = Position.create(0, 0)\n      let tokenSource = new CancellationTokenSource()\n      let token = tokenSource.token\n      expect(await languages.getDefinition(doc, pos, token)).toBe(null)\n      expect(await languages.getDefinitionLinks(doc, pos, token)).toBe(null)\n      expect(await languages.getDeclaration(doc, pos, token)).toBe(null)\n      expect(await languages.getTypeDefinition(doc, pos, token)).toBe(null)\n      expect(await languages.getImplementation(doc, pos, token)).toBe(null)\n      expect(await languages.getReferences(doc, { includeDeclaration: false }, pos, token)).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get references","suites":["locations","reference"],"updatePoint":{"line":66,"column":29},"line":66,"code":"    it('should get references', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.references()\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to references","suites":["locations","reference"],"updatePoint":{"line":72,"column":33},"line":72,"code":"    it('should jump to references', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoReferences('edit', true)\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when references not found","suites":["locations","reference"],"updatePoint":{"line":80,"column":53},"line":80,"code":"    it('should return false when references not found', async () => {\n      currLocations = []\n      let res = await locations.gotoReferences('edit', true)\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get definitions","suites":["locations","definition"],"updatePoint":{"line":96,"column":30},"line":96,"code":"    it('should get definitions', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.definitions()\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return empty locations when no definitions exist","suites":["locations","definition"],"updatePoint":{"line":102,"column":63},"line":102,"code":"    it('should return empty locations when no definitions exist', async () => {\n      currLocations = null\n      let doc = await workspace.document\n      let res = await languages.getDefinitionLinks(doc.textDocument, Position.create(0, 0), CancellationToken.None)\n      expect(res.length).toBe(0)\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      res = await languages.getDefinitionLinks(doc.textDocument, Position.create(0, 0), CancellationToken.None)\n      expect(res.length).toBe(0)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to definitions","suites":["locations","definition"],"updatePoint":{"line":112,"column":34},"line":112,"code":"    it('should jump to definitions', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoDefinition('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when definitions not found","suites":["locations","definition"],"updatePoint":{"line":120,"column":54},"line":120,"code":"    it('should return false when definitions not found', async () => {\n      currLocations = []\n      let res = await locations.gotoDefinition('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get declarations","suites":["locations","declaration"],"updatePoint":{"line":136,"column":31},"line":136,"code":"    it('should get declarations', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.declarations() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to declaration","suites":["locations","declaration"],"updatePoint":{"line":142,"column":34},"line":142,"code":"    it('should jump to declaration', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoDeclaration('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when declaration not found","suites":["locations","declaration"],"updatePoint":{"line":150,"column":54},"line":150,"code":"    it('should return false when declaration not found', async () => {\n      currLocations = []\n      let res = await locations.gotoDeclaration('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get type definition","suites":["locations","typeDefinition"],"updatePoint":{"line":166,"column":34},"line":166,"code":"    it('should get type definition', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.typeDefinitions() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to type definition","suites":["locations","typeDefinition"],"updatePoint":{"line":172,"column":38},"line":172,"code":"    it('should jump to type definition', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoTypeDefinition('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when type definition not found","suites":["locations","typeDefinition"],"updatePoint":{"line":180,"column":58},"line":180,"code":"    it('should return false when type definition not found', async () => {\n      currLocations = []\n      let res = await locations.gotoTypeDefinition('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get implementations","suites":["locations","implementation"],"updatePoint":{"line":196,"column":34},"line":196,"code":"    it('should get implementations', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0), createLocation('bar', 0, 0, 0, 0)]\n      let res = await locations.implementations() as Location[]\n      expect(res.length).toBe(2)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to implementation","suites":["locations","implementation"],"updatePoint":{"line":202,"column":37},"line":202,"code":"    it('should jump to implementation', async () => {\n      currLocations = [createLocation('foo', 0, 0, 0, 0)]\n      let res = await locations.gotoImplementation('edit')\n      expect(res).toBe(true)\n      let name = await nvim.call('bufname', ['%'])\n      expect(name).toBe('test://foo')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when implementation not found","suites":["locations","implementation"],"updatePoint":{"line":210,"column":57},"line":210,"code":"    it('should return false when implementation not found', async () => {\n      currLocations = []\n      let res = await locations.gotoImplementation('edit')\n      expect(res).toBe(false)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when cword does not exist","suites":["locations","getTagList"],"updatePoint":{"line":218,"column":52},"line":218,"code":"    it('should return null when cword does not exist', async () => {\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when provider does not exist","suites":["locations","getTagList"],"updatePoint":{"line":223,"column":55},"line":223,"code":"    it('should return null when provider does not exist', async () => {\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when result is empty","suites":["locations","getTagList"],"updatePoint":{"line":230,"column":47},"line":230,"code":"    it('should return null when result is empty', async () => {\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition: () => {\n          return []\n        }\n      }))\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toBe(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return tag definitions","suites":["locations","getTagList"],"updatePoint":{"line":242,"column":37},"line":242,"code":"    it('should return tag definitions', async () => {\n      disposables.push(languages.registerDefinitionProvider([{ language: '*' }], {\n        provideDefinition: () => {\n          return [createLocation('bar', 2, 0, 2, 5), Location.create(URI.file('/foo').toString(), Range.create(1, 0, 1, 5))]\n        }\n      }))\n      await nvim.setLine('foo')\n      await nvim.command('normal! ^')\n      let res = await locations.getTagList()\n      expect(res).toEqual([\n        {\n          name: 'foo',\n          cmd: 'keepjumps 3 | normal 1|',\n          filename: 'test://bar'\n        },\n        { name: 'foo', cmd: 'keepjumps 2 | normal 1|', filename: '/foo' }\n      ])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle locations from language client","suites":["locations","findLocations"],"updatePoint":{"line":277,"column":52},"line":277,"code":"    it('should handle locations from language client', async () => {\n      result = [createLocation('bar', 2, 0, 2, 5)]\n      await locations.findLocations('foo', 'mylocation', {}, false)\n      let res = await nvim.getVar('coc_jump_locations')\n      expect(res).toEqual([{\n        uri: 'test://bar',\n        lnum: 3,\n        end_lnum: 3,\n        col: 1,\n        end_col: 6,\n        filename: 'test://bar',\n        text: '',\n        range: Range.create(2, 0, 2, 5)\n      }])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle nested locations","suites":["locations","findLocations"],"updatePoint":{"line":293,"column":38},"line":293,"code":"    it('should handle nested locations', async () => {\n      let location: any = {\n        location: createLocation('file', 0, 0, 0, 0),\n        children: [{\n          location: createLocation('foo', 3, 0, 3, 5),\n          children: []\n        }, {\n          location: createLocation('bar', 4, 0, 4, 5),\n          children: []\n        }]\n      }\n      result = location\n      await locations.findLocations('foo', 'mylocation', {}, false)\n      let res = await nvim.getVar('coc_jump_locations') as any[]\n      expect(res.length).toBe(3)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when location is undefined","suites":["locations","handleLocations"],"updatePoint":{"line":312,"column":51},"line":312,"code":"    it('should not throw when location is undefined', async () => {\n      await locations.handleLocations(null)\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when locations is empty array","suites":["locations","handleLocations"],"updatePoint":{"line":316,"column":54},"line":316,"code":"    it('should not throw when locations is empty array', async () => {\n      await locations.handleLocations([])\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle single location","suites":["locations","handleLocations"],"updatePoint":{"line":320,"column":37},"line":320,"code":"    it('should handle single location', async () => {\n      await locations.handleLocations(createLocation('single', 0, 0, 0, 0))\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('test://single')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle location link","suites":["locations","handleLocations"],"updatePoint":{"line":326,"column":35},"line":326,"code":"    it('should handle location link', async () => {\n      let link = LocationLink.create('test://link', Range.create(0, 0, 0, 3), Range.create(1, 0, 1, 3))\n      await locations.handleLocations([link])\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toBe('test://link')\n    })","file":"handler/locations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should follow cursor","suites":["symbols outline","configuration"],"updatePoint":{"line":75,"column":28},"line":75,"code":"    it('should follow cursor', async () => {\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await nvim.command('wincmd p')\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [curr])\n      await helper.wait(50)\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.getLines()\n      expect(lines.slice(1)).toEqual([\n        '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n      let signs = await buf.getSigns({ group: 'CocTree' })\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 2,\n        id: 3001,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not follow cursor","suites":["symbols outline","configuration"],"updatePoint":{"line":100,"column":32},"line":100,"code":"    it('should not follow cursor', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.followCursor': false,\n      })\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await nvim.command('wincmd p')\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [curr])\n      await helper.wait(50)\n      let buf = nvim.createBuffer(bufnr)\n      let signs = await buf.getSigns({ group: 'CocTree' })\n      expect(signs.length).toBe(0)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep current window","suites":["symbols outline","configuration"],"updatePoint":{"line":117,"column":34},"line":117,"code":"    it('should keep current window', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.keepWindow': true,\n      })\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      expect(curr).toBe(bufnr)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check on buffer switch","suites":["symbols outline","configuration"],"updatePoint":{"line":128,"column":37},"line":128,"code":"    it('should check on buffer switch', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': true,\n      })\n      await createBuffer()\n      await symbols.showOutline(1)\n      await helper.edit('unnamed')\n      await helper.wait(200)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines[0]).toMatch('Document symbol provider not found')\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not check on buffer switch","suites":["symbols outline","configuration"],"updatePoint":{"line":141,"column":41},"line":141,"code":"    it('should not check on buffer switch', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': false\n      })\n      await helper.wait(30)\n      await createBuffer()\n      await symbols.showOutline(1)\n      await helper.edit('unnamed')\n      await helper.wait(100)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines.slice(1)).toEqual([\n        '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not check on buffer reload","suites":["symbols outline","configuration"],"updatePoint":{"line":157,"column":41},"line":157,"code":"    it('should not check on buffer reload', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.checkBufferSwitch': false\n      })\n      await symbols.showOutline(1)\n      await helper.wait(50)\n      await createBuffer()\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by position","suites":["symbols outline","configuration"],"updatePoint":{"line":169,"column":31},"line":169,"code":"    it('should sort by position', async () => {\n      let code = `class myClass {\n  fun2() { }\n  fun1() {}\n}`\n      workspace.configurations.updateUserConfig({\n        'outline.sortBy': 'position',\n      })\n      await createBuffer(code)\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE Position', '- c myClass 1', '    m fun2 2', '    m fun1 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by name","suites":["symbols outline","configuration"],"updatePoint":{"line":186,"column":27},"line":186,"code":"    it('should sort by name', async () => {\n      let code = `class myClass {\n  fun2() {}\n  fun1() {}\n}`\n      workspace.configurations.updateUserConfig({\n        'outline.sortBy': 'name',\n      })\n      await createBuffer(code)\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'OUTLINE Name', '- c myClass 1', '    m fun1 3', '    m fun2 2'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change sort method","suites":["symbols outline","configuration"],"updatePoint":{"line":203,"column":33},"line":203,"code":"    it('should change sort method', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.detailAsDescription': false\n      })\n      let code = `class detail {\n  fun2() {}\n  fun1() {}\n}`\n      await createBuffer(code)\n      await symbols.showOutline(0)\n      await helper.wait(30)\n      await nvim.input('<C-s>')\n      await helper.waitFloat()\n      await nvim.input('<esc>')\n      await helper.wait(30)\n      await nvim.input('<C-s>')\n      await helper.waitFloat()\n      await nvim.input('3')\n      await helper.waitFor('getline', [1], 'OUTLINE Position')\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show detail as description","suites":["symbols outline","configuration"],"updatePoint":{"line":224,"column":41},"line":224,"code":"    it('should show detail as description', async () => {\n      workspace.configurations.updateUserConfig({\n        'outline.detailAsDescription': true\n      })\n      let code = `class detail {\n  fun2() {}\n}`\n      await createBuffer(code)\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      let lines = await buf.lines\n      expect(lines.slice(1)).toEqual([\n        '- c detail 1', '    m fun2 () 2'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not close TreeView on buffer reload","suites":["symbols outline","events"],"updatePoint":{"line":243,"column":50},"line":243,"code":"    it('should not close TreeView on buffer reload', async () => {\n      await createBuffer()\n      await symbols.showOutline(0)\n      await nvim.command('edit')\n      await helper.wait(30)\n      let winid = await nvim.call('coc#window#find', ['cocViewId', 'OUTLINE'])\n      expect(winid).toBeGreaterThan(0)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose on buffer unload","suites":["symbols outline","events"],"updatePoint":{"line":252,"column":39},"line":252,"code":"    it('should dispose on buffer unload', async () => {\n      await createBuffer()\n      let curr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await nvim.command('tabe')\n      await nvim.command(`bd! ${curr}`)\n      await helper.wait(30)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check current window on BufEnter","suites":["symbols outline","events"],"updatePoint":{"line":263,"column":47},"line":263,"code":"    it('should check current window on BufEnter', async () => {\n      await createBuffer()\n      await symbols.showOutline(1)\n      let winid = await nvim.call('win_getid', [])\n      await nvim.command('enew')\n      await helper.wait(100)\n      let win = await nvim.window\n      expect(win.id).toBe(winid)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should recreated when original window exists","suites":["symbols outline","events"],"updatePoint":{"line":273,"column":52},"line":273,"code":"    it('should recreated when original window exists', async () => {\n      await symbols.showOutline(1)\n      await helper.wait(50)\n      await createBuffer()\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep old outline when new buffer not attached","suites":["symbols outline","events"],"updatePoint":{"line":282,"column":60},"line":282,"code":"    it('should keep old outline when new buffer not attached', async () => {\n      await createBuffer()\n      await symbols.showOutline(1)\n      await nvim.command(`vnew +setl\\\\ buftype=nofile`)\n      await helper.wait(50)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n      let lines = await buf.lines\n      expect(lines.slice(1)).toEqual([\n        '- c myClass 1', '    m fun1 2', '    m fun2 3'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not reload when switch to original buffer","suites":["symbols outline","events"],"updatePoint":{"line":295,"column":56},"line":295,"code":"    it('should not reload when switch to original buffer', async () => {\n      await createBuffer()\n      await symbols.showOutline(0)\n      let buf = await getOutlineBuffer()\n      let name = await buf.name\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      buf = await getOutlineBuffer()\n      let curr = await buf.name\n      expect(curr).toBe(name)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when document not attached","suites":["symbols outline","show()"],"updatePoint":{"line":309,"column":51},"line":309,"code":"    it('should not throw when document not attached', async () => {\n      await nvim.command(`edit +setl\\\\ buftype=nofile t`)\n      await workspace.document\n      await symbols.showOutline(1)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider does not exist","suites":["symbols outline","show()"],"updatePoint":{"line":315,"column":53},"line":315,"code":"    it('should not throw when provider does not exist', async () => {\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when symbols is empty","suites":["symbols outline","show()"],"updatePoint":{"line":321,"column":46},"line":321,"code":"    it('should not throw when symbols is empty', async () => {\n      await createBuffer('')\n      await symbols.showOutline(1)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeDefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to selected symbol","suites":["symbols outline","show()"],"updatePoint":{"line":328,"column":38},"line":328,"code":"    it('should jump to selected symbol', async () => {\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await helper.waitFor('getline', [3], '    m fun1 2')\n      await nvim.command('exe 3')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      let curr = await nvim.call('bufnr', ['%'])\n      expect(curr).toBe(bufnr)\n      let cursor = await nvim.call('coc#cursor#position')\n      expect(cursor).toEqual([1, 2])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update symbols","suites":["symbols outline","show()"],"updatePoint":{"line":342,"column":29},"line":342,"code":"    it('should update symbols', async () => {\n      await createBuffer()\n      let doc = await workspace.document\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(1)\n      await helper.wait(10)\n      let buf = nvim.createBuffer(bufnr)\n      let code = 'class foo{}'\n      await buf.setLines(code.split('\\n'), {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await doc.synchronize()\n      buf = await getOutlineBuffer()\n      await helper.waitFor('eval', [`getbufline(${buf.id},1)[0]`], /No\\sresults/)\n      let lines = await buf.lines\n      expect(lines).toEqual([\n        'No results',\n        '',\n        'OUTLINE Category'\n      ])\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show label in description","suites":["symbols outline","show()"],"updatePoint":{"line":366,"column":40},"line":366,"code":"    it('should show label in description', async () => {\n      disposables.push(languages.registerDocumentSymbolProvider([{ language: 'vim' }], {\n        meta: {\n          label: 'vimlsp'\n        },\n        provideDocumentSymbols: _ => {\n          let res: DocumentSymbol[] = [{\n            name: 'let',\n            range: Range.create(0, 0, 0, 3),\n            kind: SymbolKind.Constant,\n            selectionRange: Range.create(0, 0, 0, 3),\n            tags: [SymbolTag.Deprecated]\n          }]\n          return Promise.resolve(res)\n        }\n      }))\n      let doc = await helper.createDocument('t.vim')\n      await nvim.command('setf vim')\n      let buf = await nvim.buffer\n      await buf.setLines(['let'], { start: 0, end: -1, strictIndexing: false })\n      await doc.synchronize()\n      await symbols.showOutline(0)\n      await helper.waitFor('getline', [1], 'OUTLINE vimlsp')\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke visual select","suites":["symbols outline","actions"],"updatePoint":{"line":393,"column":35},"line":393,"code":"    it('should invoke visual select', async () => {\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(0)\n      await helper.waitFor('getline', [3], /fun1/)\n      await nvim.command('exe 3')\n      await nvim.input('<tab>')\n      await helper.waitPrompt()\n      await nvim.input('<cr>')\n      await helper.waitFor('mode', [], 'v')\n      let buf = await nvim.buffer\n      expect(buf.id).toBe(bufnr)\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke selected code action","suites":["symbols outline","actions"],"updatePoint":{"line":407,"column":42},"line":407,"code":"    it('should invoke selected code action', async () => {\n      const codeAction = CodeAction.create('my action', CodeActionKind.Refactor)\n      let uri: string\n      disposables.push(languages.registerCodeActionProvider([{ language: '*' }], {\n        provideCodeActions: () => [codeAction],\n        resolveCodeAction: (action): ProviderResult<CodeAction> => {\n          action.edit = {\n            changes: {\n              [uri]: [TextEdit.del(Range.create(0, 0, 0, 5))]\n            }\n          }\n          return action\n        }\n      }, undefined))\n      await createBuffer()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let doc = workspace.getDocument(bufnr)\n      uri = doc.uri\n      await symbols.showOutline(0)\n      await helper.wait(200)\n      await nvim.command('exe 3')\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(200)\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines[0]).toBe(' myClass {')\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide outline","suites":["symbols outline","hide()"],"updatePoint":{"line":439,"column":27},"line":439,"code":"    it('should hide outline', async () => {\n      await createBuffer('')\n      await symbols.showOutline(1)\n      await helper.wait(50)\n      await symbols.hideOutline()\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when outline does not exist","suites":["symbols outline","hide()"],"updatePoint":{"line":448,"column":52},"line":448,"code":"    it('should not throw when outline does not exist', async () => {\n      await symbols.hideOutline()\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose provider and views","suites":["symbols outline","dispose"],"updatePoint":{"line":456,"column":41},"line":456,"code":"    it('should dispose provider and views', async () => {\n      await createBuffer('')\n      let bufnr = await nvim.call('bufnr', ['%'])\n      await symbols.showOutline(1)\n      symbols.dispose()\n      await helper.wait(50)\n      expect(symbols.hasOutline(bufnr)).toBe(false)\n      let buf = await getOutlineBuffer()\n      expect(buf).toBeUndefined()\n    })","file":"handler/outline.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix delete change params","suites":["fixChangeParams"],"updatePoint":{"line":73,"column":37},"line":73,"code":"  it('should fix delete change params', async () => {\n    let e = createChangeParams(Range.create(0, 4, 2, 4), '', 'x\\nfoo\\n\\u3000bar', [\n      '\\u3000barx',\n      'foo',\n      '\\u3000bara'\n    ])\n    e = fixChangeParams(e)\n    expect(e.original).toBe('\\u3000barx\\nfoo\\n')\n    expect(e.contentChanges[0].range).toEqual(Range.create(0, 0, 2, 0))\n  })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix insert change params","suites":["fixChangeParams"],"updatePoint":{"line":84,"column":37},"line":84,"code":"  it('should fix insert change params', async () => {\n    let e = createChangeParams(Range.create(0, 4, 0, 4), 'x\\nfoo\\n\\u3000bar', '', [\n      '\\u3000bara'\n    ])\n    e = fixChangeParams(e)\n    expect(e.original).toBe('')\n    let change = e.contentChanges[0]\n    expect(change.range).toEqual(Range.create(0, 0, 0, 0))\n    expect(change.text).toBe('\\u3000barx\\nfoo\\n')\n  })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check inserted ranges","suites":["refactor","checkInsert()"],"updatePoint":{"line":98,"column":36},"line":98,"code":"    it('should check inserted ranges', async () => {\n      let c = new Changes()\n      expect(c.checkInsert([1])).toBeUndefined()\n      c.add([{ filepath: __filename, start: 1, lnum: 1, lines: [''] }])\n      expect(c.checkInsert([2])).toBeUndefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when range does not exist","suites":["refactor","getFileRange()"],"updatePoint":{"line":107,"column":46},"line":107,"code":"    it('should throw when range does not exist', async () => {\n      let uri = URI.file(__filename).toString()\n      let locations = [{ uri, range: Range.create(0, 0, 0, 6) }]\n      let buf = await refactor.fromLocations(locations)\n      let fn = () => {\n        buf.getFileRange(1)\n      }\n      expect(fn).toThrow(Error)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find file range","suites":["refactor","getFileRange()"],"updatePoint":{"line":117,"column":30},"line":117,"code":"    it('should find file range', async () => {\n      let uri = URI.file(__filename).toString()\n      let locations = [{ uri, range: Range.create(0, 0, 0, 6) }]\n      let buf = await refactor.fromLocations(locations)\n      let res = buf.getFileRange(4)\n      expect(res).toBeDefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get delete range","suites":["refactor","getRange()"],"updatePoint":{"line":127,"column":31},"line":127,"code":"    it('should get delete range', async () => {\n      let filename = await createTmpFile('foo\\n\\nbar\\n')\n      let fileItem: FileItemDef = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 1 }, { start: 2, end: 3 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      await buf.addFileItems([fileItem])\n      let res = buf.getFileRange(4)\n      let r = buf.getDeleteRange(res)\n      expect(r).toEqual(Range.create(3, 0, 6, 0))\n      res = buf.getFileRange(7)\n      r = buf.getDeleteRange(res)\n      expect(r).toEqual(Range.create(6, 0, 8, 0))\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get replace range","suites":["refactor","getRange()"],"updatePoint":{"line":143,"column":32},"line":143,"code":"    it('should get replace range', async () => {\n      let filename = await createTmpFile('foo\\n\\nbar\\n')\n      let fileItem: FileItemDef = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 1 }, { start: 2, end: 3 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      await buf.addFileItems([fileItem])\n      let res = buf.getFileRange(4)\n      let r = buf.getReplaceRange(res)\n      expect(r).toEqual(Range.create(4, 0, 4, 3))\n      res = buf.getFileRange(7)\n      r = buf.getReplaceRange(res)\n      expect(r).toEqual(Range.create(7, 0, 7, 3))\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create from invalid workspaceEdit","suites":["refactor","fromWorkspaceEdit()"],"updatePoint":{"line":161,"column":52},"line":161,"code":"    it('should not create from invalid workspaceEdit', async () => {\n      let res = await refactor.fromWorkspaceEdit(undefined)\n      expect(res).toBeUndefined()\n      res = await refactor.fromWorkspaceEdit({ documentChanges: [] })\n      expect(res).toBeUndefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create from document changes","suites":["refactor","fromWorkspaceEdit()"],"updatePoint":{"line":168,"column":43},"line":168,"code":"    it('should create from document changes', async () => {\n      let edit = createEdit(URI.file(__filename).toString())\n      let buf = await refactor.fromWorkspaceEdit(edit)\n      let shown = await buf.valid\n      expect(shown).toBe(true)\n      let items = buf.fileItems\n      expect(items.length).toBe(1)\n      await nvim.command(`bd! ${buf.bufnr}`)\n      await helper.wait(30)\n      let has = refactor.has(buf.bufnr)\n      expect(has).toBe(false)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create from workspaceEdit","suites":["refactor","fromWorkspaceEdit()"],"updatePoint":{"line":181,"column":40},"line":181,"code":"    it('should create from workspaceEdit', async () => {\n      let changes = {\n        [URI.file(__filename).toString()]: [{\n          range: Range.create(0, 0, 0, 6),\n          newText: ''\n        }, {\n          range: Range.create(1, 0, 1, 6),\n          newText: ''\n        }, {\n          range: Range.create(50, 0, 50, 1),\n          newText: ' '\n        }, {\n          range: Range.create(60, 0, 60, 1),\n          newText: ' '\n        }]\n      }\n      let edit: WorkspaceEdit = { changes }\n      let buf = await refactor.fromWorkspaceEdit(edit)\n      let shown = await buf.valid\n      expect(shown).toBe(true)\n      let items = buf.fileItems\n      expect(items.length).toBe(1)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create from locations","suites":["refactor","fromLocations()"],"updatePoint":{"line":207,"column":36},"line":207,"code":"    it('should create from locations', async () => {\n      let uri = URI.file(__filename).toString()\n      let locations = [{\n        uri,\n        range: Range.create(0, 0, 0, 6),\n      }, {\n        uri,\n        range: Range.create(1, 0, 1, 6),\n      }]\n      let buf = await refactor.fromLocations(locations)\n      let shown = await buf.valid\n      expect(shown).toBe(true)\n      let items = buf.fileItems\n      expect(items.length).toBe(1)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create from empty locations","suites":["refactor","fromLocations()"],"updatePoint":{"line":223,"column":46},"line":223,"code":"    it('should not create from empty locations', async () => {\n      let buf = await refactor.fromLocations([])\n      expect(buf).toBeUndefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on empty text change","suites":["refactor","onChange()"],"updatePoint":{"line":245,"column":43},"line":245,"code":"    it('should refresh on empty text change', async () => {\n      let buf = await setup()\n      let line = await nvim.call('getline', [4])\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.call('setline', [4, line])\n      doc._forceSync()\n      let srcId = await nvim.createNamespace('coc-refactor')\n      let markers = await helper.getMarkers(doc.bufnr, srcId)\n      expect(markers.length).toBe(2)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should detect range delete and undo","suites":["refactor","onChange()"],"updatePoint":{"line":256,"column":43},"line":256,"code":"    it('should detect range delete and undo', async () => {\n      let buf = await setup()\n      let doc = workspace.getDocument(buf.bufnr)\n      let r = buf.getFileRange(4)\n      let end = r.lnum + r.lines.length\n      await nvim.command(`${r.lnum},${end + 1}d`)\n      await doc.synchronize()\n      await assertSynchronized(buf)\n      await nvim.command('undo')\n      await doc.synchronize()\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should detect normal delete","suites":["refactor","onChange()"],"updatePoint":{"line":269,"column":35},"line":269,"code":"    it('should detect normal delete', async () => {\n      let buf = await setup()\n      let doc = workspace.getDocument(buf.bufnr)\n      let r = buf.getFileRange(4)\n      await nvim.command(`${r.lnum + 1},${r.lnum + 1}d`)\n      await doc.synchronize()\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should detect insert","suites":["refactor","onChange()"],"updatePoint":{"line":278,"column":28},"line":278,"code":"    it('should detect insert', async () => {\n      let buf = await setup()\n      let doc = workspace.getDocument(buf.bufnr)\n      let buffer = nvim.createBuffer(buf.bufnr)\n      await buffer.append(['foo'])\n      await doc.synchronize()\n      await assertSynchronized(buf)\n      await buffer.append(['foo', '\\u3000'])\n      await doc.synchronize()\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore when change after range","suites":["refactor","onDocumentChange()"],"updatePoint":{"line":292,"column":45},"line":292,"code":"    it('should ignore when change after range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['foo', 'bar'])\n      await doc.synchronize()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(0, 0, 0, 3) }])\n      let lines = await nvim.call('getline', [1, '$'])\n      await doc.buffer.append(['def'])\n      await doc.synchronize()\n      let newLines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(newLines)\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust when change before range","suites":["refactor","onDocumentChange()"],"updatePoint":{"line":305,"column":46},"line":305,"code":"    it('should adjust when change before range', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await doc.synchronize()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines(['def'], { start: 0, end: 0, strictIndexing: false })\n      await doc.synchronize()\n      let fileRange = buf.getFileRange(4)\n      expect(fileRange.start).toBe(2)\n      expect(fileRange.lines.length).toBe(6)\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove ranges when lines empty","suites":["refactor","onDocumentChange()"],"updatePoint":{"line":318,"column":45},"line":318,"code":"    it('should remove ranges when lines empty', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await doc.synchronize()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines([], { start: 0, end: -1, strictIndexing: false })\n      await doc.synchronize()\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines.length).toBe(3)\n      let items = buf.fileItems\n      expect(items.length).toBe(0)\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change when liens changed","suites":["refactor","onDocumentChange()"],"updatePoint":{"line":332,"column":40},"line":332,"code":"    it('should change when liens changed', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.append(['', '', '', '', 'foo', 'bar'])\n      await doc.synchronize()\n      let buf = await refactor.fromLocations([{ uri: doc.uri, range: Range.create(4, 0, 4, 3) }])\n      await doc.buffer.setLines(['def', 'def'], { start: 5, end: 6, strictIndexing: false })\n      await doc.synchronize()\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines[lines.length - 2]).toBe('def')\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #1","suites":["refactor","getFileChanges()"],"updatePoint":{"line":346,"column":29},"line":346,"code":"    it('should get changes #1', async () => {\n      await helper.createDocument()\n      let lines = `\nSave current buffer to make changes\n\\u3000\n\\u3000\n\\u3000/a.ts\n    })\n  } `\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 5, filepath: '/a.ts', lines: ['    })', '  } '] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #2","suites":["refactor","getFileChanges()"],"updatePoint":{"line":360,"column":29},"line":360,"code":"    it('should get changes #2', async () => {\n      let lines = `\n\\u3000/a.ts\n    })\n  } `\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 2, filepath: '/a.ts', lines: ['    })', '  } '] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #3","suites":["refactor","getFileChanges()"],"updatePoint":{"line":370,"column":29},"line":370,"code":"    it('should get changes #3', async () => {\n      let lines = `\n\\u3000/a.ts\n    })\n  }\n\\u3000`\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([{ lnum: 2, filepath: '/a.ts', lines: ['    })', '  }'] }])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changes #4","suites":["refactor","getFileChanges()"],"updatePoint":{"line":381,"column":29},"line":381,"code":"    it('should get changes #4', async () => {\n      let lines = `\n\\u3000/a.ts\nfoo\n\\u3000/b.ts\nbar\n\\u3000`\n      let buf = await refactor.fromLines(lines.split('\\n'))\n      let changes = await buf.getFileChanges()\n      expect(changes).toEqual([\n        { filepath: '/a.ts', lnum: 2, lines: ['foo'] },\n        { filepath: '/b.ts', lnum: 4, lines: ['bar'] }\n      ])\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create refactor buffer","suites":["refactor","createRefactorBuffer()"],"updatePoint":{"line":398,"column":37},"line":398,"code":"    it('should create refactor buffer', async () => {\n      let winid = await nvim.call('win_getid')\n      let buf = await refactor.createRefactorBuffer()\n      let curr = await nvim.call('win_getid')\n      expect(curr).toBeGreaterThan(winid)\n      let valid = await buf.valid\n      expect(valid).toBe(true)\n      buf = await refactor.createRefactorBuffer('vim')\n      valid = await buf.valid\n      expect(valid).toBe(true)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use conceal for line numbers","suites":["refactor","createRefactorBuffer()"],"updatePoint":{"line":410,"column":43},"line":410,"code":"    it('should use conceal for line numbers', async () => {\n      let buf = await refactor.createRefactorBuffer(undefined, true)\n      let fileItem: FileItemDef = {\n        filepath: __filename,\n        ranges: [{ start: 10, end: 11 }, { start: 15, end: 20 }]\n      }\n      await buf.addFileItems([fileItem])\n      let arr = await nvim.call('getmatches') as any[]\n      arr = arr.filter(o => o.group == 'Conceal')\n      expect(arr.length).toBeGreaterThan(0)\n      await buf.addFileItems([{\n        filepath: __filename,\n        ranges: [{ start: 1, end: 3 }]\n      }])\n      await nvim.command('normal! ggdG')\n      let doc = workspace.getDocument(buf.bufnr)\n      await doc.synchronize()\n      let b = nvim.createBuffer(buf.bufnr)\n      let res = await b.getVar('line_infos')\n      expect(res).toEqual({})\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to position by <CR>","suites":["refactor","splitOpen()"],"updatePoint":{"line":445,"column":39},"line":445,"code":"    it('should jump to position by <CR>', async () => {\n      let buf = await setup()\n      await buf.splitOpen()\n      let line = await nvim.eval('line(\".\")')\n      let bufname = await nvim.eval('bufname(\"%\")')\n      expect(bufname).toMatch('refactor.test.ts')\n      expect(line).toBe(11)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump split window when original window not valid","suites":["refactor","splitOpen()"],"updatePoint":{"line":454,"column":63},"line":454,"code":"    it('should jump split window when original window not valid', async () => {\n      let win = await nvim.window\n      let buf = await setup()\n      await nvim.call('nvim_win_close', [win.id, true])\n      await buf.splitOpen()\n      let line = await nvim.eval('line(\".\")')\n      let bufname = await nvim.eval('bufname(\"%\")')\n      expect(bufname).toMatch('refactor.test.ts')\n      expect(line).toBe(11)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do nothing when cancelled or range not found","suites":["refactor","showMenu()"],"updatePoint":{"line":478,"column":59},"line":478,"code":"    it('should do nothing when cancelled or range not found', async () => {\n      let buf = await setup()\n      let p = buf.showMenu()\n      await helper.waitPrompt()\n      await nvim.input('<esc>')\n      await p\n      let bufnr = await nvim.call('bufnr', ['%'])\n      expect(bufnr).toBe(buf.bufnr)\n      await nvim.call('cursor', [1, 1])\n      p = buf.showMenu()\n      await helper.waitPrompt()\n      await nvim.input('1')\n      await p\n      bufnr = await nvim.call('bufnr', ['%'])\n      expect(bufnr).toBe(buf.bufnr)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open file in new tab","suites":["refactor","showMenu()"],"updatePoint":{"line":495,"column":35},"line":495,"code":"    it('should open file in new tab', async () => {\n      let buf = await setup()\n      await nvim.call('cursor', [4, 1])\n      let p = buf.showMenu()\n      await helper.wait(30)\n      await nvim.input('1')\n      await p\n      let nr = await nvim.call('tabpagenr')\n      expect(nr).toBe(2)\n      let lnum = await nvim.call('line', ['.'])\n      expect(lnum).toBe(11)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove current block","suites":["refactor","showMenu()"],"updatePoint":{"line":508,"column":35},"line":508,"code":"    it('should remove current block', async () => {\n      let buf = await setup()\n      await nvim.call('cursor', [4, 1])\n      let p = buf.showMenu()\n      await helper.wait(30)\n      await nvim.input('2')\n      await p\n      let items = buf.fileItems\n      expect(items[0].ranges.length).toBe(1)\n      await assertSynchronized(buf)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust line ranges after change","suites":["refactor","saveRefactor()"],"updatePoint":{"line":522,"column":46},"line":522,"code":"    it('should adjust line ranges after change', async () => {\n      let filename = await createTmpFile('foo\\n\\nbar\\n')\n      let fileItem: FileItemDef = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 1 }, { start: 2, end: 3 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      const getRanges = () => {\n        let items = buf.fileItems\n        let item = items.find(o => o.filepath == filename)\n        return item.ranges.map(o => {\n          return [o.start, o.start + o.lines.length]\n        })\n      }\n      await buf.addFileItems([fileItem, {\n        filepath: __filename,\n        ranges: [{ start: 1, end: 5 }]\n      }])\n      expect(getRanges()).toEqual([[0, 1], [2, 3]])\n      nvim.pauseNotification()\n      nvim.call('setline', [5, ['xyoo']], true)\n      nvim.command('undojoin', true)\n      nvim.call('append', [5, ['de']], true)\n      nvim.command('undojoin', true)\n      nvim.call('setline', [9, ['b']], true)\n      await nvim.resumeNotification()\n      let doc = workspace.getDocument(buf.bufnr)\n      await doc.synchronize()\n      let res = await refactor.save(buf.buffer.id)\n      expect(res).toBe(true)\n      expect(getRanges()).toEqual([[0, 2], [3, 4]])\n      let content = fs.readFileSync(filename, 'utf8')\n      expect(content).toBe('xyoo\\nde\\n\\nb\\n')\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not save when no change made","suites":["refactor","saveRefactor()"],"updatePoint":{"line":557,"column":43},"line":557,"code":"    it('should not save when no change made', async () => {\n      let buf = await refactor.createRefactorBuffer()\n      let fileItem: FileItemDef = {\n        filepath: __filename,\n        ranges: [{ start: 10, end: 11 }, { start: 15, end: 20 }]\n      }\n      await buf.addFileItems([fileItem])\n      let res = await buf.save()\n      expect(res).toBe(false)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sync buffer change to file","suites":["refactor","saveRefactor()"],"updatePoint":{"line":568,"column":41},"line":568,"code":"    it('should sync buffer change to file', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.replace(['foo', 'bar', 'line'], 0)\n      await helper.wait(30)\n      let filename = URI.parse(doc.uri).fsPath\n      let fileItem: FileItemDef = {\n        filepath: filename,\n        ranges: [{ start: 0, end: 2 }]\n      }\n      let buf = await refactor.createRefactorBuffer()\n      await buf.addFileItems([fileItem])\n      await nvim.call('setline', [5, 'changed'])\n      let res = await buf.save()\n      expect(res).toBe(true)\n      expect(fs.existsSync(filename)).toBe(true)\n      let content = fs.readFileSync(filename, 'utf8')\n      let lines = content.split('\\n')\n      expect(lines).toEqual(['changed', 'bar', 'line', ''])\n      fs.unlinkSync(filename)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when rename provider not found","suites":["refactor","doRefactor"],"updatePoint":{"line":598,"column":51},"line":598,"code":"    it('should throw when rename provider not found', async () => {\n      await helper.createDocument()\n      let err\n      try {\n        await refactor.doRefactor()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when prepare failed","suites":["refactor","doRefactor"],"updatePoint":{"line":609,"column":47},"line":609,"code":"    it('should show message when prepare failed', async () => {\n      await helper.createDocument()\n      disposable = languages.registerRenameProvider(['*'], {\n        prepareRename: () => {\n          return undefined\n        },\n        provideRenameEdits: () => {\n          return null\n        }\n      })\n      await refactor.doRefactor()\n      let res = await helper.getCmdline()\n      expect(res).toMatch(/unable to rename/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when returned edits is null","suites":["refactor","doRefactor"],"updatePoint":{"line":624,"column":55},"line":624,"code":"    it('should show message when returned edits is null', async () => {\n      await helper.createDocument()\n      disposable = languages.registerRenameProvider(['*'], {\n        provideRenameEdits: () => {\n          return null\n        }\n      })\n      await refactor.doRefactor()\n      let res = await helper.getCmdline()\n      expect(res).toMatch(/returns null/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor window when edits is valid","suites":["refactor","doRefactor"],"updatePoint":{"line":636,"column":55},"line":636,"code":"    it('should open refactor window when edits is valid', async () => {\n      let filepath = __filename\n      disposable = languages.registerRenameProvider(['*'], {\n        provideRenameEdits: () => {\n          let changes = {\n            [URI.file(filepath).toString()]: [{\n              range: Range.create(0, 0, 0, 6),\n              newText: ''\n            }, {\n              range: Range.create(1, 0, 1, 6),\n              newText: ''\n            }]\n          }\n          let edit: WorkspaceEdit = { changes }\n          return edit\n        }\n      })\n      await helper.createDocument(filepath)\n      let winid = await nvim.call('win_getid')\n      await refactor.doRefactor()\n      let currWin = await nvim.call('win_getid')\n      expect(currWin - winid).toBeGreaterThan(0)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let b = refactor.getBuffer(bufnr)\n      expect(b).toBeDefined()\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor buffer from search result","suites":["refactor","search"],"updatePoint":{"line":665,"column":54},"line":665,"code":"    it('should open refactor buffer from search result', async () => {\n      let escaped = await nvim.call('fnameescape', [__dirname])\n      await nvim.command(`cd ${escaped}`)\n      await helper.createDocument()\n      await refactor.search(['registerRenameProvider'])\n      let buf = await nvim.buffer\n      let name = await buf.name\n      expect(name).toMatch(/__coc_refactor__/)\n      let lines = await buf.lines\n      expect(lines[0]).toMatch(/Save current buffer/)\n    })","file":"handler/refactor.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when provider not found","suites":["rename handler","getWordEdit"],"updatePoint":{"line":101,"column":48},"line":101,"code":"    it('should not throw when provider not found', async () => {\n      await helper.edit()\n      let res = await rename.getWordEdit()\n      expect(res).toBe(null)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use document symbols when prepare failed","suites":["rename handler","getWordEdit"],"updatePoint":{"line":107,"column":55},"line":107,"code":"    it('should use document symbols when prepare failed', async () => {\n      let doc = await helper.createDocument('t.js')\n      await nvim.setLine('')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res != null).toBe(true)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return workspace edit","suites":["rename handler","getWordEdit"],"updatePoint":{"line":115,"column":36},"line":115,"code":"    it('should return workspace edit', async () => {\n      let doc = await helper.createDocument('t.js')\n      await nvim.setLine('foo foo')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res).toBeDefined()\n      expect(res.changes[doc.uri].length).toBe(2)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extract words from buffer","suites":["rename handler","getWordEdit"],"updatePoint":{"line":124,"column":40},"line":124,"code":"    it('should extract words from buffer', async () => {\n      let doc = await helper.createDocument('t')\n      await nvim.setLine('  ')\n      await doc.synchronize()\n      let res = await rename.getWordEdit()\n      expect(res).toBeDefined()\n      expect(res.changes[doc.uri].length).toBe(3)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provider not found","suites":["rename handler","rename"],"updatePoint":{"line":135,"column":44},"line":135,"code":"    it('should throw when provider not found', async () => {\n      await helper.edit()\n      let err\n      try {\n        await rename.rename('foo')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for invalid position","suites":["rename handler","rename"],"updatePoint":{"line":146,"column":48},"line":146,"code":"    it('should return false for invalid position', async () => {\n      await helper.createDocument('t.js')\n      let res = await rename.rename('foo')\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from placeholder","suites":["rename handler","rename"],"updatePoint":{"line":152,"column":43},"line":152,"code":"    it('should use newName from placeholder', async () => {\n      await helper.createDocument('t.js')\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for empty name","suites":["rename handler","rename"],"updatePoint":{"line":165,"column":42},"line":165,"code":"    it('should return false for empty name', async () => {\n      await helper.createDocument('t.js')\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(20)\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from range","suites":["rename handler","rename"],"updatePoint":{"line":177,"column":37},"line":177,"code":"    it('should use newName from range', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: (doc, position: Position, newName: string) => {\n          let range = getWordRangeAtPosition(doc, position)\n          if (range) {\n            let word = doc.getText(range)\n            if (word) {\n              let ranges = getSymbolRanges(doc, word)\n              return {\n                changes: {\n                  [doc.uri]: ranges.map(o => TextEdit.replace(o, newName))\n                }\n              }\n            }\n          }\n          return undefined\n        },\n        prepareRename: (doc, position) => {\n          let range = getWordRangeAtPosition(doc, position)\n          return range ? range : null\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n      await helper.waitFor('getline', ['.'], 'bar bar bar')\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use newName from cword","suites":["rename handler","rename"],"updatePoint":{"line":212,"column":37},"line":212,"code":"    it('should use newName from cword', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: (doc, position: Position, newName: string) => {\n          let range = getWordRangeAtPosition(doc, position)\n          if (range) {\n            let word = doc.getText(range)\n            if (word) {\n              let ranges = getSymbolRanges(doc, word)\n              return {\n                changes: {\n                  [doc.uri]: ranges.map(o => TextEdit.replace(o, newName))\n                }\n              }\n            }\n          }\n          return undefined\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(50)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('bar bar bar')\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when result is empty","suites":["rename handler","rename"],"updatePoint":{"line":244,"column":48},"line":244,"code":"    it('should return false when result is empty', async () => {\n      disposables.push(languages.registerRenameProvider([{ language: '*' }], {\n        provideRenameEdits: () => {\n          return null\n        }\n      }))\n      await helper.createDocument()\n      await nvim.setLine('foo foo foo')\n      let p = rename.rename()\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(10)\n      await nvim.input('bar')\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/rename.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined path","suites":["getPathFromArgs"],"updatePoint":{"line":29,"column":31},"line":29,"code":"  it('should get undefined path', async () => {\n    let res = getPathFromArgs(['a'])\n    expect(res).toBeUndefined()\n    res = getPathFromArgs(['a', 'b', '-c'])\n    expect(res).toBeUndefined()\n    res = getPathFromArgs(['a', '-b', 'c'])\n    expect(res).toBeUndefined()\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open refactor window","suites":["search"],"updatePoint":{"line":41,"column":33},"line":41,"code":"  it('should open refactor window', async () => {\n    let search = new Search(nvim, cmd)\n    let buf = await refactor.createRefactorBuffer()\n    await search.run([], cwd, buf)\n    await helper.wait(50)\n    let fileItems = buf.fileItems\n    expect(fileItems.length).toBe(2)\n    expect(fileItems[0].ranges.length).toBe(2)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should abort task","suites":["search"],"updatePoint":{"line":51,"column":23},"line":51,"code":"  it('should abort task', async () => {\n    let search = new Search(nvim, cmd)\n    let buf = await refactor.createRefactorBuffer()\n    let p = search.run(['--sleep', '1000'], cwd, buf)\n    search.abort()\n    await p\n    let fileItems = buf.fileItems\n    expect(fileItems.length).toBe(0)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with CocAction search","suites":["search"],"updatePoint":{"line":61,"column":39},"line":61,"code":"  it('should work with CocAction search', async () => {\n    await helper.doAction('search', ['CocAction'])\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let buf = refactor.getBuffer(bufnr)\n    expect(buf).toBeDefined()\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fail on invalid command","suites":["search"],"updatePoint":{"line":68,"column":36},"line":68,"code":"  it('should fail on invalid command', async () => {\n    let search = new Search(nvim, 'rrg')\n    let buf = await refactor.createRefactorBuffer()\n    let err\n    try {\n      await search.run([], cwd, buf)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n    let msg = await helper.getCmdline()\n    expect(msg).toMatch(/Error on command \"rrg\"/)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show empty result when no result found","suites":["search"],"updatePoint":{"line":82,"column":51},"line":82,"code":"  it('should show empty result when no result found', async () => {\n    await helper.doAction('search', ['should found ' + ' no result'])\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let buf = refactor.getBuffer(bufnr)\n    expect(buf).toBeDefined()\n    let buffer = await nvim.buffer\n    let lines = await buffer.lines\n    expect(lines[1]).toMatch(/No match found/)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use corrent search folder for rg","suites":["search"],"updatePoint":{"line":92,"column":45},"line":92,"code":"  it('should use corrent search folder for rg', async () => {\n    let search = new Search(nvim, 'rg')\n    await helper.createDocument()\n    let buf = await refactor.createRefactorBuffer()\n    await search.run(['-w', 'createRefactorBuffer', 'src/__tests__'], cwd, buf)\n    let buffer = await nvim.buffer\n    let lines = await buffer.lines\n    expect(lines[1].startsWith('Files: ')).toBe(true)\n  })","file":"handler/search.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when selectionRange provider does not exist","suites":["selectionRange","getSelectionRanges()"],"updatePoint":{"line":32,"column":70},"line":32,"code":"    it('should throw error when selectionRange provider does not exist', async () => {\n      let doc = await helper.createDocument()\n      await doc.synchronize()\n      let err\n      try {\n        await selection.getSelectionRanges()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return ranges","suites":["selectionRange","getSelectionRanges()"],"updatePoint":{"line":44,"column":28},"line":44,"code":"    it('should return ranges', async () => {\n      await helper.createDocument()\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{\n            range: Range.create(0, 0, 0, 1)\n          }]\n        }\n      }))\n      let res = await selection.getSelectionRanges()\n      expect(res).toBeDefined()\n      expect(Array.isArray(res)).toBe(true)\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select ranges forward","suites":["selectionRange","selectRange()"],"updatePoint":{"line":69,"column":36},"line":69,"code":"    it('should select ranges forward', async () => {\n      let doc = await helper.createDocument()\n      let called = 0\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar\\ntest\\n')])\n      await nvim.call('cursor', [1, 1])\n      await doc.synchronize()\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          called += 1\n          let arr = [{\n            range: Range.create(0, 0, 0, 1)\n          }, {\n            range: Range.create(0, 0, 0, 3)\n          }, {\n            range: Range.create(0, 0, 1, 3)\n          }]\n          return arr\n        }\n      }))\n      await doc.synchronize()\n      await selection.selectRange('', false)\n      await selection.selectRange('', true)\n      expect(called).toBe(1)\n      let res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 0, 1))\n      await selection.selectRange('v', true)\n      expect(called).toBe(2)\n      res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 0, 3))\n      await selection.selectRange('v', true)\n      expect(called).toBe(3)\n      res = await getSelectedRange()\n      expect(res).toEqual(Range.create(0, 0, 1, 3))\n      await selection.selectRange('v', true)\n      expect(called).toBe(4)\n      let m = await nvim.mode\n      expect(m.mode).toBe('n')\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select ranges backward","suites":["selectionRange","selectRange()"],"updatePoint":{"line":108,"column":37},"line":108,"code":"    it('should select ranges backward', async () => {\n      let doc = await helper.createDocument()\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar\\ntest\\n')])\n      await nvim.call('cursor', [1, 1])\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          let arr = [{\n            range: Range.create(0, 0, 0, 1)\n          }, {\n            range: Range.create(0, 0, 0, 3)\n          }, {\n            range: Range.create(0, 0, 1, 3)\n          }]\n          return arr\n        }\n      }))\n      await doc.synchronize()\n      await selection.selectRange('', true)\n      let mode = await nvim.call('mode')\n      expect(mode).toBe('v')\n      await nvim.input('<esc>')\n      await window.selectRange(Range.create(0, 0, 1, 3))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      let r = await getSelectedRange()\n      expect(r).toEqual(Range.create(0, 0, 0, 3))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      r = await getSelectedRange()\n      expect(r).toEqual(Range.create(0, 0, 0, 1))\n      await nvim.input('<esc>')\n      await selection.selectRange('v', false)\n      mode = await nvim.call('mode')\n      expect(mode).toBe('n')\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when no provider available","suites":["selectionRange","provideSelectionRanges()"],"updatePoint":{"line":146,"column":53},"line":146,"code":"    it('should return null when no provider available', async () => {\n      let doc = await workspace.document\n      let res = await languages.getSelectionRanges(doc.textDocument, [Position.create(0, 0)], CancellationToken.None)\n      expect(res).toBeNull()\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null when no result available","suites":["selectionRange","provideSelectionRanges()"],"updatePoint":{"line":152,"column":51},"line":152,"code":"    it('should return null when no result available', async () => {\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return []\n        }\n      }))\n      let doc = await workspace.document\n      let res = await languages.getSelectionRanges(doc.textDocument, [Position.create(0, 0)], CancellationToken.None)\n      expect(res).toBeNull()\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append/prepend selection ranges","suites":["selectionRange","provideSelectionRanges()"],"updatePoint":{"line":163,"column":46},"line":163,"code":"    it('should append/prepend selection ranges', async () => {\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{ range: Range.create(1, 1, 1, 4) }, { range: Range.create(1, 0, 1, 6) }]\n        }\n      }))\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{ range: Range.create(1, 2, 1, 3) }]\n        }\n      }))\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{ range: Range.create(1, 2, 1, 3) }]\n        }\n      }))\n      disposables.push(languages.registerSelectionRangeProvider([{ language: '*' }], {\n        provideSelectionRanges: _doc => {\n          return [{ range: Range.create(0, 0, 3, 0) }]\n        }\n      }))\n      let doc = await workspace.document\n      let res = await languages.getSelectionRanges(doc.textDocument, [Position.create(0, 0)], CancellationToken.None)\n      expect(res.length).toBe(4)\n      expect(res[0].range).toEqual(Range.create(1, 2, 1, 3))\n      expect(res[3].range).toEqual(Range.create(0, 0, 3, 0))\n    })","file":"handler/selectionRange.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error when buffer not attached","suites":["semanticTokens","showHighlightInfo()"],"updatePoint":{"line":174,"column":50},"line":174,"code":"    it('should show error when buffer not attached', async () => {\n      await nvim.command('h')\n      await highlighter.showHighlightInfo()\n      let line = await helper.getCmdline()\n      expect(line).toMatch('not attached')\n      await highlighter.inspectSemanticToken()\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show message when not enabled","suites":["semanticTokens","showHighlightInfo()"],"updatePoint":{"line":182,"column":44},"line":182,"code":"    it('should show message when not enabled', async () => {\n      await helper.edit('t.txt')\n      await highlighter.showHighlightInfo()\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines[2]).toMatch('not enabled for current filetype')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show semantic tokens info","suites":["semanticTokens","showHighlightInfo()"],"updatePoint":{"line":190,"column":40},"line":190,"code":"    it('should show semantic tokens info', async () => {\n      await createRustBuffer()\n      await highlighter.highlightCurrent()\n      await commandManager.executeCommand('semanticTokens.checkCurrent')\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      let content = lines.join('\\n')\n      expect(content).toMatch('Semantic highlight groups used by current buffer')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show highlight info for empty legend","suites":["semanticTokens","showHighlightInfo()"],"updatePoint":{"line":200,"column":51},"line":200,"code":"    it('should show highlight info for empty legend', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      disposables.push(languages.registerDocumentRangeSemanticTokensProvider([{ language: '*' }], {\n        provideDocumentRangeSemanticTokens: (_, range) => {\n          return {\n            data: []\n          }\n        }\n      }, { tokenModifiers: [], tokenTypes: [] }))\n      await highlighter.showHighlightInfo()\n      await highlighter.showHighlightInfo()\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      let content = lines.join('\\n')\n      expect(content).toMatch('No token')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh highlights","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":219,"column":33},"line":219,"code":"    it('should refresh highlights', async () => {\n      await createRustBuffer()\n      await nvim.command('hi link CocSemDeclarationFunction MoreMsg')\n      await nvim.command('hi link CocSemDocumentation Statement')\n      await window.moveTo({ line: 0, character: 4 })\n      await highlighter.highlightCurrent()\n      await commandManager.executeCommand('semanticTokens.inspect')\n      let win = await helper.getFloat()\n      let buf = await win.buffer\n      let lines = await buf.lines\n      let content = lines.join('\\n')\n      expect(content).toMatch('CocSemDeclarationFunction')\n      await window.moveTo({ line: 1, character: 0 })\n      await commandManager.executeCommand('semanticTokens.inspect')\n      win = await helper.getFloat()\n      expect(win).toBeUndefined()\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh highlights by command","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":237,"column":44},"line":237,"code":"    it('should refresh highlights by command', async () => {\n      await helper.edit()\n      let err\n      try {\n        await commandManager.executeCommand('semanticTokens.refreshCurrent')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh when buffer visible","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":248,"column":42},"line":248,"code":"    it('should refresh when buffer visible', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['rust'])\n      let code = `fn main() {\n    println!(\"H\");\n}`\n      let buf = await nvim.buffer\n      await nvim.command('setf rust')\n      await buf.setLines(code.split('\\n'), { start: 0, end: -1, strictIndexing: false })\n      let doc = await workspace.document\n      await doc.synchronize()\n      let item = await highlighter.getCurrentItem()\n      expect(item.enabled).toBe(false)\n      await nvim.command('edit bar')\n      registerProvider()\n      expect(item.enabled).toBe(true)\n      await nvim.command(`b ${buf.id}`)\n      await item.waitRefresh()\n      expect(item.highlights).toBeDefined()\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reuse exists tokens when version not changed","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":268,"column":59},"line":268,"code":"    it('should reuse exists tokens when version not changed', async () => {\n      let doc = await helper.createDocument('t.vim')\n      await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'let' }])\n      let fn = jest.fn()\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      disposables.push(languages.registerDocumentSemanticTokensProvider([{ language: 'vim' }], {\n        provideDocumentSemanticTokens: () => {\n          fn()\n          return new Promise(resolve => {\n            resolve({\n              resultId: '1',\n              data: [0, 0, 3, 1, 0]\n            })\n          })\n        }\n      }, legend))\n      let item = await highlighter.getCurrentItem()\n      item.cancel()\n      await item.doHighlight()\n      await item.doHighlight()\n      expect(fn).toBeCalledTimes(1)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only highlight limited range on update","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":291,"column":53},"line":291,"code":"    it('should only highlight limited range on update', async () => {\n      let doc = await helper.createDocument('t.vim')\n      let fn = jest.fn()\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      disposables.push(languages.registerDocumentSemanticTokensProvider([{ language: 'vim' }], {\n        provideDocumentSemanticTokens: (doc, token) => {\n          let text = doc.getText()\n          if (!text.trim()) {\n            return Promise.resolve({ resultId: '1', data: [] })\n          }\n          fn()\n          let lines = text.split('\\n')\n          let data = [0, 0, 1, 1, 0]\n          for (let i = 0; i < lines.length; i++) {\n            data.push(1, 0, 1, 1, 0)\n          }\n          return new Promise(resolve => {\n            token.onCancellationRequested(() => {\n              clearTimeout(timer)\n              resolve(undefined)\n            })\n            let timer = setTimeout(() => {\n              resolve({ resultId: '1', data })\n            }, 50)\n          })\n        }\n      }, legend))\n      let item = await highlighter.getCurrentItem()\n      await item.doHighlight()\n      let newLine = 'l\\n'\n      await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: `${newLine.repeat(2000)}` }])\n      await item.doHighlight()\n      await item.waitRefresh()\n      expect(fn).toBeCalled()\n      let buf = nvim.createBuffer(doc.bufnr)\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      let len = markers.length\n      expect(len).toBeLessThan(400)\n      await nvim.command('normal! gg')\n      await helper.waitValue(async () => {\n        let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n        return markers.length > 300\n      }, true)\n      await nvim.command('normal! 200G')\n      await helper.waitValue(async () => {\n        let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n        return markers.length > 500\n      }, true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight hidden buffer on shown","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":341,"column":47},"line":341,"code":"    it('should highlight hidden buffer on shown', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['rust'])\n      registerProvider()\n      let code = 'fn main() {\\n  println!(\"H\"); \\n}'\n      let filepath = path.join(os.tmpdir(), 'a.rs')\n      fs.writeFileSync(filepath, code, 'utf8')\n      let uri = URI.file(filepath).toString()\n      await workspace.loadFile(uri)\n      let doc = workspace.getDocument(uri)\n      let item = highlighter.getItem(doc.bufnr)\n      let called = false\n      item.onDidRefresh(() => {\n        called = true\n      })\n      let buf = doc.buffer\n      expect(doc.filetype).toBe('rust')\n      await nvim.command(`b ${buf.id}`)\n      await helper.waitValue(() => {\n        return called\n      }, true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not highlight on shown when document not changed","suites":["semanticTokens","highlightCurrent()"],"updatePoint":{"line":363,"column":63},"line":363,"code":"    it('should not highlight on shown when document not changed', async () => {\n      let called = false\n      let buf = await createRustBuffer()\n      let item = await highlighter.getCurrentItem()\n      await item.waitRefresh()\n      await nvim.command('enew')\n      item.doHighlight = async () => {\n        called = true\n      }\n      await nvim.command(`b ${buf.id}`)\n      await helper.waitValue(() => {\n        return called\n      }, true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear highlights of current buffer","suites":["semanticTokens","clear highlights"],"updatePoint":{"line":380,"column":49},"line":380,"code":"    it('should clear highlights of current buffer', async () => {\n      await createRustBuffer()\n      await highlighter.highlightCurrent()\n      let buf = await nvim.buffer\n      let markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBeGreaterThan(0)\n      await commandManager.executeCommand('semanticTokens.clearCurrent')\n      markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBe(0)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear all highlights","suites":["semanticTokens","clear highlights"],"updatePoint":{"line":391,"column":35},"line":391,"code":"    it('should clear all highlights', async () => {\n      await createRustBuffer()\n      await highlighter.highlightCurrent()\n      let buf = await nvim.buffer\n      await commandManager.executeCommand('semanticTokens.clearAll')\n      let markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBe(0)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke range provider first time when both kinds exist","suites":["semanticTokens","rangeProvider"],"updatePoint":{"line":402,"column":69},"line":402,"code":"    it('should invoke range provider first time when both kinds exist', async () => {\n      let called = false\n      disposables.push(registerRangeProvider('rust', () => {\n        called = true\n        return []\n      }))\n      let buf = await createRustBuffer()\n      let item = highlighter.getItem(buf.id)\n      await item.waitRefresh()\n      expect(called).toBe(true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do range highlight first time","suites":["semanticTokens","rangeProvider"],"updatePoint":{"line":414,"column":44},"line":414,"code":"    it('should do range highlight first time', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      let r: Range\n      disposables.push(registerRangeProvider('vim', range => {\n        r = range\n        return [0, 0, 3, 1, 0]\n      }))\n      let filepath = await createTmpFile('let')\n      fs.renameSync(filepath, filepath + '.vim')\n      let doc = await helper.createDocument(filepath + '.vim')\n      expect(doc.filetype).toBe('vim')\n      await helper.waitValue(() => {\n        return typeof r !== 'undefined'\n      }, true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do range highlight after cursor moved","suites":["semanticTokens","rangeProvider"],"updatePoint":{"line":430,"column":52},"line":430,"code":"    it('should do range highlight after cursor moved', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      let doc = await helper.createDocument('t.vim')\n      let r: Range\n      expect(doc.filetype).toBe('vim')\n      await nvim.call('setline', [2, (new Array(200).fill(''))])\n      await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'let' }])\n      disposables.push(registerRangeProvider('vim', range => {\n        r = range\n        return []\n      }))\n      await nvim.command('normal! G')\n      await helper.waitValue(() => {\n        return r && r.end.line == 201\n      }, true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when range request throws","suites":["semanticTokens","rangeProvider"],"updatePoint":{"line":447,"column":50},"line":447,"code":"    it('should not throw when range request throws', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      let doc = await workspace.document\n      let called = false\n      disposables.push(languages.registerDocumentRangeSemanticTokensProvider([{ language: '*' }], {\n        provideDocumentRangeSemanticTokens: (_, range) => {\n          called = true\n          throw new Error('custom error')\n        }\n      }, legend))\n      let item = highlighter.getItem(doc.bufnr)\n      await item.doRangeHighlight(CancellationToken.None)\n      expect(called).toBe(true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only cancel range highlight request","suites":["semanticTokens","rangeProvider"],"updatePoint":{"line":462,"column":50},"line":462,"code":"    it('should only cancel range highlight request', async () => {\n      let rangeCancelled = false\n      disposables.push(languages.registerDocumentRangeSemanticTokensProvider([{ language: 'vim' }], {\n        provideDocumentRangeSemanticTokens: (_, range, token) => {\n          return new Promise(resolve => {\n            token.onCancellationRequested(() => {\n              clearTimeout(timeout)\n              rangeCancelled = true\n              resolve(null)\n            })\n            let timeout = setTimeout(() => {\n              resolve({ data: [] })\n            }, 500)\n          })\n        }\n      }, legend))\n      disposables.push(languages.registerDocumentSemanticTokensProvider([{ language: 'vim' }], {\n        provideDocumentSemanticTokens: (_, token) => {\n          return new Promise(resolve => {\n            resolve({\n              resultId: '1',\n              data: [0, 0, 3, 1, 0]\n            })\n          })\n        }\n      }, legend))\n      let doc = await helper.createDocument('t.vim')\n      await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'let' }])\n      let item = await highlighter.getCurrentItem()\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      item.cancel()\n      let p = item.doHighlight()\n      await helper.wait(10)\n      item.cancel(true)\n      await p\n      expect(rangeCancelled).toBe(true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled by default","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":502,"column":37},"line":502,"code":"    it('should be disabled by default', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', [])\n      await workspace.document\n      const curr = await highlighter.getCurrentItem()\n      expect(curr.enabled).toBe(false)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be enabled","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":509,"column":25},"line":509,"code":"    it('should be enabled', async () => {\n      await createRustBuffer()\n      const curr = await highlighter.getCurrentItem()\n      expect(curr.enabled).toBe(true)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get legend by API","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":515,"column":32},"line":515,"code":"    it('should get legend by API', async () => {\n      await createRustBuffer()\n      const doc = await workspace.document\n      const l = languages.getLegend(doc.textDocument)\n      expect(l).toEqual(legend)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should doHighlight","suites":["semanticTokens","triggerSemanticTokens"],"updatePoint":{"line":522,"column":26},"line":522,"code":"    it('should doHighlight', async () => {\n      await createRustBuffer()\n      const doc = await workspace.document\n      await nvim.call('CocAction', 'semanticHighlight')\n      const highlights = await nvim.call(\"coc#highlight#get_highlights\", [doc.bufnr, 'semanticTokens'])\n      expect(highlights.length).toBeGreaterThan(0)\n      expect(highlights[0][0]).toBe('CocSemKeyword')\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should perform highlight update","suites":["semanticTokens","delta update"],"updatePoint":{"line":533,"column":39},"line":533,"code":"    it('should perform highlight update', async () => {\n      await createRustBuffer()\n      let buf = await nvim.buffer\n      await highlighter.highlightCurrent()\n      await window.moveTo({ line: 0, character: 0 })\n      let doc = await workspace.document\n      await nvim.input('if')\n      await doc.synchronize()\n      let curr = await highlighter.getCurrentItem()\n      await curr.forceHighlight()\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBeGreaterThan(0)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid state","suites":["semanticTokens","checkState"],"updatePoint":{"line":549,"column":38},"line":549,"code":"    it('should throw for invalid state', async () => {\n      let doc = await workspace.document\n      const toThrow = (cb: () => void) => {\n        expect(cb).toThrow(Error)\n      }\n      let item = highlighter.getItem(doc.bufnr)\n      toThrow(() => {\n        item.checkState()\n      })\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      toThrow(() => {\n        item.checkState()\n      })\n      toThrow(() => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        workspace._env.updateHighlight = false\n        item.checkState()\n      })\n      let enabled = item.enabled\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      workspace._env.updateHighlight = true\n      expect(enabled).toBe(false)\n      doc.detach()\n      toThrow(() => {\n        item.checkState()\n      })\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check if buffer enabled for semanticTokens","suites":["semanticTokens","enabled"],"updatePoint":{"line":581,"column":57},"line":581,"code":"    it('should check if buffer enabled for semanticTokens', async () => {\n      let doc = await workspace.document\n      let item = highlighter.getItem(doc.bufnr)\n      disposables.push(languages.registerDocumentRangeSemanticTokensProvider([{ language: '*' }], {\n        provideDocumentRangeSemanticTokens: (_, range) => {\n          return {\n            data: []\n          }\n        }\n      }, { tokenModifiers: [], tokenTypes: [] }))\n      expect(item.enabled).toBe(false)\n      helper.updateConfiguration('semanticTokens.filetypes', ['vim'])\n      expect(item.enabled).toBe(false)\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      expect(item.enabled).toBe(true)\n      doc.detach()\n      expect(item.enabled).toBe(false)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should retrigger range request on server cancel","suites":["semanticTokens","Server cancelled"],"updatePoint":{"line":602,"column":55},"line":602,"code":"    it('should retrigger range request on server cancel', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      await workspace.document\n      let times = 0\n      disposables.push(languages.registerDocumentRangeSemanticTokensProvider([{ language: '*' }], {\n        provideDocumentRangeSemanticTokens: () => {\n          times++\n          if (times == 1) {\n            throw new CancellationError()\n          }\n          return {\n            data: []\n          }\n        }\n      }, { tokenModifiers: [], tokenTypes: [] }))\n      await helper.waitValue(() => {\n        return times\n      }, 2)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should retrigger full request on server cancel","suites":["semanticTokens","Server cancelled"],"updatePoint":{"line":622,"column":54},"line":622,"code":"    it('should retrigger full request on server cancel', async () => {\n      helper.updateConfiguration('semanticTokens.filetypes', ['*'])\n      await workspace.document\n      let times = 0\n      disposables.push(languages.registerDocumentSemanticTokensProvider([{ language: '*' }], {\n        provideDocumentSemanticTokens: () => {\n          times++\n          if (times == 1) {\n            throw new CancellationError()\n          }\n          return {\n            data: []\n          }\n        }\n      }, { tokenModifiers: [], tokenTypes: [] }))\n      await helper.waitValue(() => {\n        return times\n      }, 2)\n    })","file":"handler/semanticTokens.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show signature by api","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":32,"column":36},"line":32,"code":"    it('should show signature by api', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use 0 when activeParameter is undefined","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":51,"column":54},"line":51,"code":"    it('should use 0 when activeParameter is undefined', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(a)', 'my signature', { label: 'a' })],\n            activeParameter: undefined,\n            activeSignature: null\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let highlights = await win.getVar('highlights')\n      expect(highlights).toBeDefined()\n      expect(highlights[0].hlGroup).toBe('CocUnderline')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger by space","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":71,"column":31},"line":71,"code":"    it('should trigger by space', async () => {\n      let promise = new Promise(resolve => {\n        disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n          provideSignatureHelp: (_doc, _position) => {\n            resolve(undefined)\n            return {\n              signatures: [SignatureInformation.create('foo()', 'my signature')],\n              activeParameter: null,\n              activeSignature: null\n            }\n          }\n        }, [' ']))\n      })\n      await helper.createDocument()\n      await nvim.input('i')\n      await helper.wait(30)\n      await nvim.input(' ')\n      await promise\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show signature help with param label as string","suites":["signatureHelp","triggerSignatureHelp"],"updatePoint":{"line":91,"column":61},"line":91,"code":"    it('should show signature help with param label as string', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [\n              SignatureInformation.create('foo()', 'my signature'),\n              SignatureInformation.create('foo(a, b)', 'my signature', ParameterInformation.create('a', 'description')),\n            ],\n            activeParameter: 0,\n            activeSignature: 1\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines.join('\\n')).toMatch(/description/)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should trigger signature help","suites":["signatureHelp","events"],"updatePoint":{"line":115,"column":37},"line":115,"code":"    it('should trigger signature help', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(x, y)', 'my signature')],\n            activeParameter: 0,\n            activeSignature: 0\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await nvim.input('(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel trigger on InsertLeave","suites":["signatureHelp","events"],"updatePoint":{"line":135,"column":44},"line":135,"code":"    it('should cancel trigger on InsertLeave', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: async (_doc, _position, token) => {\n          return new Promise(resolve => {\n            let timer = setTimeout(() => {\n              resolve({\n                signatures: [SignatureInformation.create('foo()', 'my signature')],\n                activeParameter: null,\n                activeSignature: null\n              })\n            }, 1000)\n            token.onCancellationRequested(() => {\n              clearTimeout(timer)\n              resolve(undefined)\n            })\n          })\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      let p = signature.triggerSignatureHelp()\n      await helper.wait(10)\n      await nvim.command('stopinsert')\n      await nvim.call('feedkeys', [String.fromCharCode(27), 'in'])\n      let res = await p\n      expect(res).toBe(false)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not close signature on type","suites":["signatureHelp","events"],"updatePoint":{"line":163,"column":42},"line":163,"code":"    it('should not close signature on type', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await helper.wait(100)\n      await nvim.input('bar')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close signature float when empty signatures returned","suites":["signatureHelp","events"],"updatePoint":{"line":184,"column":67},"line":184,"code":"    it('should close signature float when empty signatures returned', async () => {\n      let empty = false\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          if (empty) return undefined\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      empty = true\n      await signature.triggerSignatureHelp()\n      await helper.wait(50)\n      let res = await nvim.call('coc#float#valid', [win.id])\n      expect(res).toBe(0)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should align signature window to top","suites":["signatureHelp","float window"],"updatePoint":{"line":210,"column":44},"line":210,"code":"    it('should align signature window to top', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      let buf = await nvim.buffer\n      await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true })\n      await nvim.call('cursor', [5, 1])\n      await nvim.input('foo(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines[2]).toMatch('my signature')\n      let res = await nvim.call('GetFloatCursorRelative', [win.id]) as any\n      expect(res.row).toBeLessThan(0)\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show parameter docs","suites":["signatureHelp","float window"],"updatePoint":{"line":234,"column":34},"line":234,"code":"    it('should show parameter docs', async () => {\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(a, b)', 'my signature',\n              ParameterInformation.create('a', 'foo'),\n              ParameterInformation.create([7, 8], 'bar'))],\n            activeParameter: 1,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      let buf = await nvim.buffer\n      await buf.setLines(['', '', '', '', ''], { start: 0, end: -1, strictIndexing: true })\n      await nvim.call('cursor', [5, 1])\n      await nvim.input('foo(a,')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let lines = await helper.getWinLines(win.id)\n      expect(lines.join('\\n')).toMatch('bar')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel signature on timeout","suites":["signatureHelp","configurations"],"updatePoint":{"line":270,"column":42},"line":270,"code":"    it('should cancel signature on timeout', async () => {\n      configurations.updateUserConfig({ 'signature.triggerSignatureWait': 50 })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position, token) => {\n          return new Promise(resolve => {\n            token.onCancellationRequested(() => {\n              clearTimeout(timer)\n              resolve(undefined)\n            })\n            let timer = setTimeout(() => {\n              resolve({\n                signatures: [SignatureInformation.create('foo()', 'my signature')],\n                activeParameter: null,\n                activeSignature: null\n              })\n            }, 200)\n          })\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await signature.triggerSignatureHelp()\n      let win = await helper.getFloat()\n      expect(win).toBeUndefined()\n      configurations.updateUserConfig({ 'signature.triggerSignatureWait': 100 })\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide signature window on text change","suites":["signatureHelp","configurations"],"updatePoint":{"line":296,"column":51},"line":296,"code":"    it('should hide signature window on text change', async () => {\n      configurations.updateUserConfig({ 'signature.hideOnTextChange': true })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('ifoo(')\n      let winid = await helper.waitFloat()\n      await nvim.input('x')\n      await helper.wait(100)\n      let res = await nvim.call('coc#float#valid', [winid])\n      expect(res).toBe(0)\n      configurations.updateUserConfig({ 'signature.hideOnTextChange': false })\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable signature help trigger","suites":["signatureHelp","configurations"],"updatePoint":{"line":317,"column":45},"line":317,"code":"    it('should disable signature help trigger', async () => {\n      configurations.updateUserConfig({ 'signature.enable': false })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo()', 'my signature')],\n            activeParameter: null,\n            activeSignature: null\n          }\n        }\n      }, ['(', ',']))\n      await helper.createDocument()\n      await nvim.input('foo')\n      await nvim.input('(')\n      await helper.wait(100)\n      let win = await helper.getFloat()\n      expect(win).toBeUndefined()\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo simple signature help","suites":["signatureHelp","configurations"],"updatePoint":{"line":336,"column":41},"line":336,"code":"    it('should echo simple signature help', async () => {\n      let idx = 0\n      let activeSignature = null\n      configurations.updateUserConfig({ 'signature.target': 'echo' })\n      disposables.push(languages.registerSignatureHelpProvider([{ scheme: 'file' }], {\n        provideSignatureHelp: (_doc, _position) => {\n          return {\n            signatures: [SignatureInformation.create('foo(a, b)', 'my signature',\n              ParameterInformation.create('a', 'foo'),\n              ParameterInformation.create([7, 8], 'bar')),\n            SignatureInformation.create('a'.repeat(workspace.env.columns + 10))\n            ],\n            activeParameter: idx,\n            activeSignature\n          }\n        }\n      }, []))\n      await helper.createDocument()\n      await nvim.input('foo(')\n      await signature.triggerSignatureHelp()\n      let line = await helper.getCmdline()\n      expect(line).toMatch('(a, b)')\n      await nvim.input('a,')\n      idx = 1\n      await signature.triggerSignatureHelp()\n      line = await helper.getCmdline()\n      expect(line).toMatch('foo(a, b)')\n      activeSignature = 1\n      await signature.triggerSignatureHelp()\n      line = await helper.getCmdline()\n      expect(line).toMatch('aaaaaa')\n    })","file":"handler/signature.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse content","suites":["Parser"],"updatePoint":{"line":44,"column":26},"line":44,"code":"  it('should parse content', async () => {\n    let code = `class myClass {\n      fun1() { }\n    }`\n    let parser = new Parser(code)\n    let res = parser.parse()\n    expect(res.length).toBeGreaterThan(0)\n  })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get configuration","suites":["symbols handler","configuration"],"updatePoint":{"line":66,"column":32},"line":66,"code":"    it('should get configuration', async () => {\n      let functionUpdate = symbols.functionUpdate\n      expect(functionUpdate).toBe(false)\n      helper.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true)\n      functionUpdate = symbols.functionUpdate\n      expect(functionUpdate).toBe(true)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update symbols automatically","suites":["symbols handler","configuration"],"updatePoint":{"line":74,"column":43},"line":74,"code":"    it('should update symbols automatically', async () => {\n      helper.updateConfiguration('coc.preferences.currentFunctionSymbolAutoUpdate', true)\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [2, 8])\n      await events.fire('CursorHold', [buf.id])\n      let val = await buf.getVar('coc_current_function')\n      expect(val).toBe('fun1')\n      await nvim.call('cursor', [1, 8])\n      await events.fire('CursorHold', [buf.id])\n      val = await buf.getVar('coc_current_function')\n      expect(val).toBe('myClass')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get symbols of current buffer","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":93,"column":44},"line":93,"code":"    it('should get symbols of current buffer', async () => {\n      let code = `class detail {\n      fun1() { }\n    }`\n      await createBuffer(code)\n      let res = await helper.plugin.cocAction('documentSymbols')\n      expect(res.length).toBe(2)\n      expect(res[1].detail).toBeDefined()\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current function symbols","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":103,"column":43},"line":103,"code":"    it('should get current function symbols', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n      fun2() {\n      }\n    }\n    `\n      await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      let res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('fun1')\n      await nvim.command('normal! G')\n      res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset coc_current_function when symbols do not exist","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":120,"column":67},"line":120,"code":"    it('should reset coc_current_function when symbols do not exist', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      let res = await helper.doAction('getCurrentFunctionSymbol')\n      expect(res).toBe('fun1')\n      await nvim.command('normal! ggdG')\n      res = await symbols.getCurrentFunctionSymbol()\n      expect(res).toBe('')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support SymbolInformation","suites":["symbols handler","documentSymbols"],"updatePoint":{"line":134,"column":40},"line":134,"code":"    it('should support SymbolInformation', async () => {\n      disposables.push(languages.registerDocumentSymbolProvider(['*'], {\n        provideDocumentSymbols: () => {\n          return [\n            SymbolInformation.create('root', SymbolKind.Function, Range.create(0, 0, 0, 10), ''),\n            SymbolInformation.create('child', SymbolKind.Function, Range.create(0, 0, 0, 10), '', 'root')\n          ]\n        }\n      }))\n      await helper.createDocument()\n      let res = await symbols.getDocumentSymbols()\n      expect(res.length).toBe(2)\n      expect(res[0].text).toBe('root')\n      expect(res[1].text).toBe('child')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when no symbols exist","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":152,"column":49},"line":152,"code":"    it('should show warning when no symbols exist', async () => {\n      disposables.push(languages.registerDocumentSymbolProvider(['*'], {\n        provideDocumentSymbols: () => {\n          return []\n        }\n      }))\n      await helper.createDocument()\n      await nvim.call('cursor', [3, 0])\n      await symbols.selectSymbolRange(false, '', ['Function'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch(/No symbols found/)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select symbol range at cursor position","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":165,"column":53},"line":165,"code":"    it('should select symbol range at cursor position', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      await createBuffer(code)\n      await nvim.call('cursor', [3, 0])\n      await helper.doAction('selectSymbolRange', false, '', ['Function', 'Method'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      await nvim.input('<esc>')\n      let res = await window.getSelectedRange('v')\n      expect(res).toEqual({ start: { line: 1, character: 6 }, end: { line: 2, character: 6 } })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select inner range","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":180,"column":33},"line":180,"code":"    it('should select inner range', async () => {\n      let code = `class myClass {\n      fun1() {\n        let foo;\n      }\n}`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [3, 3])\n      await symbols.selectSymbolRange(true, '', ['Method'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      await nvim.input('<esc>')\n      let res = await window.getSelectedRange('v')\n      expect(res).toEqual({\n        start: { line: 2, character: 8 }, end: { line: 2, character: 16 }\n      })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset visualmode when selection not found","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":198,"column":56},"line":198,"code":"    it('should reset visualmode when selection not found', async () => {\n      let code = `class myClass {}`\n      await createBuffer(code)\n      await nvim.call('cursor', [1, 1])\n      await nvim.command('normal! gg0v$')\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      await nvim.input('<esc>')\n      await symbols.selectSymbolRange(true, 'v', ['Method'])\n      mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select symbol range from select range","suites":["symbols handler","selectSymbolRange"],"updatePoint":{"line":211,"column":52},"line":211,"code":"    it('should select symbol range from select range', async () => {\n      let code = `class myClass {\n      fun1() {\n      }\n    }`\n      let buf = await createBuffer(code)\n      await nvim.call('cursor', [2, 8])\n      await nvim.command('normal! viw')\n      await nvim.input('<esc>')\n      await helper.doAction('selectSymbolRange', false, 'v', ['Class'])\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('v')\n      let doc = workspace.getDocument(buf.id)\n      await nvim.input('<esc>')\n      let res = await window.getSelectedRange('v')\n      expect(res).toEqual({ start: { line: 0, character: 0 }, end: { line: 3, character: 4 } })\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel symbols request on insert","suites":["symbols handler","cancel"],"updatePoint":{"line":231,"column":47},"line":231,"code":"    it('should cancel symbols request on insert', async () => {\n      let cancelled = false\n      disposables.push(languages.registerDocumentSymbolProvider([{ language: 'text' }], {\n        provideDocumentSymbols: (_doc, token) => {\n          return new Promise(s => {\n            token.onCancellationRequested(() => {\n              if (timer) clearTimeout(timer)\n              cancelled = true\n              s(undefined)\n            })\n            let timer = setTimeout(() => {\n              s(undefined)\n            }, 3000)\n          })\n        }\n      }))\n      let doc = await helper.createDocument('t.txt')\n      let p = symbols.getDocumentSymbols(doc.bufnr)\n      setTimeout(async () => {\n        await nvim.input('i')\n      }, 500)\n      await p\n      expect(cancelled).toBe(true)\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get workspace symbols","suites":["symbols handler","workspaceSymbols"],"updatePoint":{"line":258,"column":36},"line":258,"code":"    it('should get workspace symbols', async () => {\n      disposables.push(languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: (_query, _token) => {\n          return [SymbolInformation.create('far', SymbolKind.Class, Range.create(0, 0, 0, 0), '')]\n        },\n        resolveWorkspaceSymbol: sym => {\n          let res = Object.assign({}, sym)\n          res.location.uri = 'test:///foo'\n          return res\n        }\n      }))\n      disposables.push(languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: (_query, _token) => {\n          return [SymbolInformation.create('bar', SymbolKind.Function, Range.create(0, 0, 0, 0), '')]\n        }\n      }))\n      let res = await symbols.getWorkspaceSymbols('a')\n      expect(res.length).toBe(2)\n      let resolved = await symbols.resolveWorkspaceSymbol(res[0])\n      expect(resolved?.location?.uri).toBe('test:///foo')\n    })","file":"handler/symbols.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open log","suites":["Workspace handler","methods"],"updatePoint":{"line":29,"column":23},"line":29,"code":"    it('should open log', async () => {\n      await handler.openLog()\n      let bufname = await nvim.call('bufname', ['%']) as string\n      expect(bufname).toMatch('coc-nvim')\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get configuration of current document","suites":["Workspace handler","methods"],"updatePoint":{"line":35,"column":52},"line":35,"code":"    it('should get configuration of current document', async () => {\n      let config = await handler.getConfiguration('suggest')\n      let wait = config.get<number>('triggerCompletionWait')\n      expect(wait).toBe(0)\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get root patterns","suites":["Workspace handler","methods"],"updatePoint":{"line":41,"column":32},"line":41,"code":"    it('should get root patterns', async () => {\n      let doc = await helper.createDocument()\n      let patterns = handler.getRootPatterns(doc.bufnr)\n      expect(patterns).toBeDefined()\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return default value when key mapping does not exist","suites":["Workspace handler","doKeymap()"],"updatePoint":{"line":49,"column":67},"line":49,"code":"    it('should return default value when key mapping does not exist', async () => {\n      let res = await handler.doKeymap('not_exists', '', '<C-a')\n      expect(res).toBe('')\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support repeat key mapping","suites":["Workspace handler","doKeymap()"],"updatePoint":{"line":54,"column":41},"line":54,"code":"    it('should support repeat key mapping', async () => {\n      let called = false\n      await nvim.command('nmap do <Plug>(coc-test)')\n      disposables.push(workspace.registerKeymap(['n'], 'test', () => {\n        called = true\n      }, { repeat: true, silent: true, sync: false }))\n      await helper.wait(100)\n      await nvim.call('feedkeys', ['do', 'i'])\n      await helper.wait(30)\n      expect(called).toBe(true)\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when coc-snippets not found","suites":["Workspace handler","snippetCheck()"],"updatePoint":{"line":68,"column":55},"line":68,"code":"    it('should return false when coc-snippets not found', async () => {\n      expect(await handler.snippetCheck(true, false)).toBe(false)\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check jump","suites":["Workspace handler","snippetCheck()"],"updatePoint":{"line":72,"column":25},"line":72,"code":"    it('should check jump', async () => {\n      expect(await handler.snippetCheck(false, true)).toBe(false)\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check expand by coc-snippets","suites":["Workspace handler","snippetCheck()"],"updatePoint":{"line":76,"column":43},"line":76,"code":"    it('should check expand by coc-snippets', async () => {\n      let has = extensions.has\n      let getExtensionApi = extensions.getExtensionApi\n      extensions.has = () => {\n        return true\n      }\n      extensions.getExtensionApi = () => {\n        return {\n          expandable: () => {\n            return true\n          }\n        }\n      }\n      disposables.push({\n        dispose: () => {\n          extensions.has = has\n          extensions.getExtensionApi = getExtensionApi\n        }\n      })\n      let res = await handler.snippetCheck(true, false)\n      expect(res).toBe(true)\n    })","file":"handler/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup","suites":["Helper"],"updatePoint":{"line":14,"column":18},"line":14,"code":"  it('should setup', () => {\n    expect(nvim).toBeTruthy()\n    expect(plugin.isReady).toBeTruthy()\n  })","file":"helper.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show stderr","suites":["Command task"],"updatePoint":{"line":94,"column":28},"line":94,"code":"  it('should not show stderr', async () => {\n    disposables.push(manager.registerList(new StderrList(nvim)))\n    await manager.start(['stderr'])\n    await manager.session.ui.ready\n    let lines = await nvim.call('getline', [1, '$']) as string[]\n    expect(lines).toEqual(['stdout'])\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for bad key","suites":["Command task"],"updatePoint":{"line":102,"column":35},"line":102,"code":"  it('should show error for bad key', async () => {\n    let list = new DataList(nvim)\n    list.config.fixKey('<X-a>')\n    await helper.wait(200)\n    await nvim.command('redraw')\n    let msg = await helper.getCmdline()\n    expect(msg).toMatch('not supported')\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show error","suites":["Command task"],"updatePoint":{"line":111,"column":27},"line":111,"code":"  it('should not show error', async () => {\n    disposables.push(manager.registerList(new ErrorTask(nvim)))\n    await manager.start(['error'])\n    await helper.wait(300)\n    await nvim.command('redraw')\n    let len = manager.session.ui.length\n    expect(len).toBe(0)\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create command task","suites":["Command task"],"updatePoint":{"line":120,"column":32},"line":120,"code":"  it('should create command task', async () => {\n    let list = new DataList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['data'])\n    await manager.session.ui.ready\n    await helper.wait(100)\n    let lines = await nvim.call('getline', [1, '$']) as string[]\n    expect(lines).toEqual(['foo', 'bar'])\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop command task","suites":["Command task"],"updatePoint":{"line":130,"column":30},"line":130,"code":"  it('should stop command task', async () => {\n    let list = new SleepList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['sleep'])\n    manager.session.stop()\n  })","file":"list/commandTask.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel and enable prompt","suites":["list","events"],"updatePoint":{"line":43,"column":39},"line":43,"code":"    it('should cancel and enable prompt', async () => {\n      let winid = await nvim.call('win_getid')\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await nvim.call('win_gotoid', [winid])\n      await helper.wait(50)\n      let res = await nvim.call('coc#prompt#activated')\n      expect(res).toBe(0)\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      res = await nvim.call('coc#prompt#activated')\n      expect(res).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be activated","suites":["list","list commands"],"updatePoint":{"line":59,"column":27},"line":59,"code":"    it('should be activated', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      expect(manager.isActivated).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toMatch(/manager.test.ts/)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get list names","suites":["list","list commands"],"updatePoint":{"line":68,"column":29},"line":68,"code":"    it('should get list names', () => {\n      let names = manager.names\n      expect(names.length > 0).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume list","suites":["list","list commands"],"updatePoint":{"line":73,"column":26},"line":73,"code":"    it('should resume list', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(30)\n      await nvim.eval('feedkeys(\"j\", \"in\")')\n      await helper.wait(30)\n      let line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n      await manager.cancel()\n      await helper.wait(30)\n      await manager.resume()\n      await helper.wait(30)\n      line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not quit list with --no-quit","suites":["list","list commands"],"updatePoint":{"line":89,"column":43},"line":89,"code":"    it('should not quit list with --no-quit', async () => {\n      await manager.start(['--normal', '--no-quit', 'location'])\n      await manager.session.ui.ready\n      let winnr = await nvim.eval('win_getid()') as number\n      await manager.doAction()\n      await helper.wait(100)\n      let wins = await nvim.windows\n      let ids = wins.map(o => o.id)\n      expect(ids).toContain(winnr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do default action for first item","suites":["list","list commands"],"updatePoint":{"line":100,"column":47},"line":100,"code":"    it('should do default action for first item', async () => {\n      await manager.start(['--normal', '--first', 'location'])\n      await helper.wait(300)\n      let name = await nvim.eval('bufname(\"%\")') as string\n      let filename = path.basename(__filename)\n      expect(name.includes(filename)).toBe(true)\n      let pos = await nvim.eval('getcurpos()')\n      expect(pos[1]).toBe(1)\n      expect(pos[2]).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next & previous","suites":["list","list commands"],"updatePoint":{"line":111,"column":35},"line":111,"code":"    it('should goto next & previous', async () => {\n      await manager.start(['location'])\n      await manager.session?.ui.ready\n      await helper.wait(60)\n      await manager.doAction()\n      await manager.cancel()\n      let bufname = await nvim.eval('expand(\"%:p\")')\n      expect(bufname).toMatch('manager.test.ts')\n      await manager.next()\n      let line = await nvim.call('line', '.')\n      expect(line).toBe(2)\n      await helper.wait(60)\n      await manager.previous()\n      line = await nvim.call('line', '.')\n      expect(line).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse arguments","suites":["list","list commands"],"updatePoint":{"line":128,"column":30},"line":128,"code":"    it('should parse arguments', async () => {\n      await manager.start(['--input=test', '--reverse', '--normal', '--no-sort', '--ignore-case', '--top', '--number-select', '--auto-preview', '--strict', 'location'])\n      await helper.wait(30)\n      let opts = manager.session?.listOptions\n      expect(opts).toEqual({\n        reverse: true,\n        numberSelect: true,\n        autoPreview: true,\n        first: false,\n        input: 'test',\n        interactive: false,\n        matcher: 'strict',\n        ignorecase: true,\n        position: 'top',\n        mode: 'normal',\n        noQuit: false,\n        sort: false\n      })\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change indicator","suites":["list","list configuration"],"updatePoint":{"line":150,"column":31},"line":150,"code":"    it('should change indicator', async () => {\n      helper.updateConfiguration('list.indicator', '>>')\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(200)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('>>')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should split right for preview window","suites":["list","list configuration"],"updatePoint":{"line":159,"column":45},"line":159,"code":"    it('should split right for preview window', async () => {\n      helper.updateConfiguration('list.previewSplitRight', true)\n      let win = await nvim.window\n      await manager.start(['location'])\n      await helper.wait(100)\n      await manager.doAction('preview')\n      await helper.wait(100)\n      manager.prompt.cancel()\n      await helper.wait(10)\n      await nvim.call('win_gotoid', [win.id])\n      await nvim.command('wincmd l')\n      let curr = await nvim.window\n      let isPreview = await curr.getVar('previewwindow')\n      expect(isPreview).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection mode","suites":["list","list configuration"],"updatePoint":{"line":175,"column":36},"line":175,"code":"    it('should toggle selection mode', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session?.ui.ready\n      await nvim.input('V')\n      await helper.wait(30)\n      await nvim.input('1')\n      await helper.wait(30)\n      await nvim.input('j')\n      await helper.wait(100)\n      await manager.session?.ui.toggleSelection()\n      let items = await manager.session?.ui.getItems()\n      expect(items.length).toBe(2)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change next/previous keymap","suites":["list","list configuration"],"updatePoint":{"line":189,"column":42},"line":189,"code":"    it('should change next/previous keymap', async () => {\n      helper.updateConfiguration('list.nextKeymap', '<tab>')\n      helper.updateConfiguration('list.previousKeymap', '<s-tab>')\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await nvim.eval('feedkeys(\"\\\\<tab>\", \"in\")')\n      await helper.wait(100)\n      let line = await nvim.line\n      expect(line).toMatch('Bar')\n      await nvim.eval('feedkeys(\"\\\\<s-tab>\", \"in\")')\n      await helper.wait(100)\n      line = await nvim.line\n      expect(line).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect mouse events","suites":["list","list configuration"],"updatePoint":{"line":205,"column":35},"line":205,"code":"    it('should respect mouse events', async () => {\n      async function setMouseEvent(line: number): Promise<void> {\n        let winid = manager.session?.ui.winid\n        await nvim.command(`let v:mouse_winid = ${winid}`)\n        await nvim.command(`let v:mouse_lnum = ${line}`)\n        await nvim.command(`let v:mouse_col = 1`)\n      }\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await setMouseEvent(1)\n      await manager.onNormalInput('<LeftMouse>')\n      await setMouseEvent(2)\n      await manager.onNormalInput('<LeftDrag>')\n      await setMouseEvent(3)\n      await manager.onNormalInput('<LeftRelease>')\n      await helper.wait(100)\n      let items = await manager.session?.ui.getItems()\n      expect(items.length).toBe(3)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle preview","suites":["list","list configuration"],"updatePoint":{"line":226,"column":29},"line":226,"code":"    it('should toggle preview', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await manager.togglePreview()\n      await helper.wait(100)\n      await manager.togglePreview()\n      await helper.wait(100)\n      let has = await nvim.call('coc#list#has_preview')\n      expect(has).toBeGreaterThan(0)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show help of current list","suites":["list","list configuration"],"updatePoint":{"line":238,"column":40},"line":238,"code":"    it('should show help of current list', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await helper.wait(200)\n      await manager.session?.showHelp()\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toBe('[LIST HELP]')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve list item","suites":["list","list configuration"],"updatePoint":{"line":246,"column":32},"line":246,"code":"    it('should resolve list item', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open', execute: _item => {\n            // noop\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }]),\n        resolveItem: item => {\n          item.label = item.label.slice(0, 1)\n          return Promise.resolve(item)\n        }\n      }\n      let disposable = manager.registerList(list)\n      await manager.start(['--normal', 'test'])\n      await manager.session.ui.ready\n      await helper.wait(50)\n      let line = await nvim.line\n      expect(line).toBe('f')\n      disposable.dispose()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get descriptions","suites":["list","descriptions"],"updatePoint":{"line":272,"column":31},"line":272,"code":"    it('should get descriptions', async () => {\n      let res = manager.descriptions\n      expect(res).toBeDefined()\n      expect(res.location).toBeDefined()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load items for list","suites":["list","loadItems()"],"updatePoint":{"line":280,"column":34},"line":280,"code":"    it('should load items for list', async () => {\n      let res = await manager.loadItems('location')\n      expect(res.length).toBeGreaterThan(0)\n        ; (manager as any).lastSession = undefined\n      manager.toggleMode()\n      manager.stop()\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle insert input","suites":["list","onInsertInput()"],"updatePoint":{"line":290,"column":34},"line":290,"code":"    it('should handle insert input', async () => {\n      await manager.onInsertInput('k')\n      await manager.onInsertInput('<LeftMouse>')\n      await manager.start(['--number-select', 'location'])\n      await manager.session.ui.ready\n      await manager.onInsertInput('1')\n      await helper.wait(300)\n      let bufname = await nvim.call('expand', ['%:p'])\n      expect(bufname).toMatch('manager.test.ts')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore invalid input","suites":["list","onInsertInput()"],"updatePoint":{"line":301,"column":35},"line":301,"code":"    it('should ignore invalid input', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await manager.onInsertInput('<X-y>')\n      await manager.onInsertInput(String.fromCharCode(65533))\n      await manager.onInsertInput(String.fromCharCode(30))\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore <plug> insert","suites":["list","onInsertInput()"],"updatePoint":{"line":310,"column":35},"line":310,"code":"    it('should ignore <plug> insert', async () => {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await nvim.eval('feedkeys(\"\\\\<plug>x\", \"in\")')\n      await helper.wait(50)\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for bad option","suites":["list","parseArgs()"],"updatePoint":{"line":320,"column":40},"line":320,"code":"    it('should show error for bad option', async () => {\n      manager.parseArgs(['$x', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Invalid list option')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for option that does not exist","suites":["list","parseArgs()"],"updatePoint":{"line":326,"column":56},"line":326,"code":"    it('should show error for option that does not exist', async () => {\n      manager.parseArgs(['-xyz', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('Invalid option')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error for interactive with list not support interactive","suites":["list","parseArgs()"],"updatePoint":{"line":332,"column":75},"line":332,"code":"    it('should show error for interactive with list not support interactive', async () => {\n      manager.parseArgs(['--interactive', 'location'])\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('not supported')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume by name","suites":["list","resume()"],"updatePoint":{"line":340,"column":29},"line":340,"code":"    it('should resume by name', async () => {\n      await events.fire('FocusGained', [])\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      await manager.session.hide()\n      await helper.wait(100)\n      await manager.resume('location')\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get session by name","suites":["list","first(), last()"],"updatePoint":{"line":352,"column":34},"line":352,"code":"    it('should get session by name', async () => {\n      let last: string\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open',\n          execute: (item: ListItem) => {\n            last = item.label\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }])\n      }\n      manager.registerList(list)\n      await manager.start(['test'])\n      await manager.session.ui.ready\n      await manager.first('a')\n      await manager.last('a')\n      await manager.first('test')\n      expect(last).toBe('foo')\n      await manager.last('test')\n      expect(last).toBe('bar')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should recreat list","suites":["list","registerList()"],"updatePoint":{"line":378,"column":27},"line":378,"code":"    it('should recreat list', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open', execute: _item => {\n            // noop\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => Promise.resolve([{ label: 'foo' }, { label: 'bar' }])\n      }\n      manager.registerList(list)\n      helper.updateConfiguration('list.source.test.defaultAction', 'open')\n      let disposable = manager.registerList(list)\n      disposable.dispose()\n      await helper.wait(30)\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('recreated')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error when loadItems throws","suites":["list","start()"],"updatePoint":{"line":400,"column":47},"line":400,"code":"    it('should show error when loadItems throws', async () => {\n      let list: IList = {\n        name: 'test',\n        actions: [{\n          name: 'open',\n          execute: (_item: ListItem) => {\n          }\n        }],\n        defaultAction: 'open',\n        loadItems: () => {\n          throw new Error('test error')\n        }\n      }\n      manager.registerList(list)\n      await manager.start(['test'])\n      await helper.wait(100)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect auto preview option","suites":["list","list options"],"updatePoint":{"line":420,"column":42},"line":420,"code":"    it('should respect auto preview option', async () => {\n      await manager.start(['--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.waitFor('winnr', ['$'], 3)\n      let previewWinnr = await nvim.call('coc#list#has_preview')\n      expect(previewWinnr).toBe(2)\n      let bufnr = await nvim.call('winbufnr', previewWinnr)\n      let buf = nvim.createBuffer(bufnr)\n      let name = await buf.name\n      expect(name).toMatch('manager.test.ts')\n      await nvim.eval('feedkeys(\"j\", \"in\")')\n      await helper.wait(100)\n      let winnr = await nvim.call('coc#list#has_preview')\n      expect(winnr).toBe(previewWinnr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect input option","suites":["list","list options"],"updatePoint":{"line":436,"column":35},"line":436,"code":"    it('should respect input option', async () => {\n      await manager.start(['--input=foo', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(30)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('foo')\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect regex filter","suites":["list","list options"],"updatePoint":{"line":445,"column":35},"line":445,"code":"    it('should respect regex filter', async () => {\n      await manager.start(['--input=f.o', '--regex', 'location'])\n      await helper.wait(200)\n      let item = await manager.session?.ui.item\n      expect(item.label).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect normal option","suites":["list","list options"],"updatePoint":{"line":452,"column":36},"line":452,"code":"    it('should respect normal option', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      let line = await helper.getCmdline()\n      expect(line).toBe('')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect nosort option","suites":["list","list options"],"updatePoint":{"line":459,"column":36},"line":459,"code":"    it('should respect nosort option', async () => {\n      await manager.start(['--ignore-case', '--no-sort', 'location'])\n      await manager.session.ui.ready\n      expect(manager.isActivated).toBe(true)\n      await nvim.input('oo')\n      await helper.wait(100)\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('foo')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect ignorecase option","suites":["list","list options"],"updatePoint":{"line":469,"column":40},"line":469,"code":"    it('should respect ignorecase option', async () => {\n      await manager.start(['--ignore-case', '--strict', 'location'])\n      await manager.session.ui.ready\n      expect(manager.isActivated).toBe(true)\n      await nvim.input('bar')\n      await helper.wait(100)\n      let n = manager.session?.ui.length\n      expect(n).toBe(1)\n      let line = await nvim.line\n      expect(line).toMatch('Bar')\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect top option","suites":["list","list options"],"updatePoint":{"line":481,"column":33},"line":481,"code":"    it('should respect top option', async () => {\n      await manager.start(['--top', 'location'])\n      await manager.session.ui.ready\n      let nr = await nvim.call('winnr')\n      expect(nr).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect number select option","suites":["list","list options"],"updatePoint":{"line":488,"column":43},"line":488,"code":"    it('should respect number select option', async () => {\n      await manager.start(['--number-select', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await nvim.eval('feedkeys(\"2\", \"in\")')\n      await helper.wait(100)\n      let lnum = locations[1].lnum\n      let curr = await nvim.call('line', '.')\n      expect(lnum).toBe(curr)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect tab option","suites":["list","list options"],"updatePoint":{"line":499,"column":33},"line":499,"code":"    it('should respect tab option', async () => {\n      await manager.start(['--tab', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(100)\n      await nvim.command('wincmd l')\n      let previewwindow = await nvim.eval('w:previewwindow')\n      expect(previewwindow).toBe(1)\n    })","file":"list/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check invalid action","suites":["isValidAction()"],"updatePoint":{"line":92,"column":33},"line":92,"code":"  it('should check invalid action', async () => {\n    let mappings = manager.mappings\n    expect(mappings.isValidAction('foo')).toBe(false)\n    expect(mappings.isValidAction('do:switch')).toBe(true)\n    expect(mappings.isValidAction('eval:@*')).toBe(true)\n    expect(mappings.isValidAction('undefined:undefined')).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning for invalid key","suites":["User mappings"],"updatePoint":{"line":102,"column":41},"line":102,"code":"  it('should show warning for invalid key', async () => {\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      xy: 'action:tabe',\n    })\n    await helper.wait(30)\n    let msg = await helper.getCmdline()\n    revert()\n    await nvim.command('echo \"\"')\n    expect(msg).toMatch('Invalid configuration')\n    revert = helper.updateConfiguration('list.insertMappings', {\n      '<M-x>': 'action:tabe',\n    })\n    await helper.wait(30)\n    msg = await helper.getCmdline()\n    revert()\n    expect(msg).toMatch('Invalid configuration')\n    revert = helper.updateConfiguration('list.insertMappings', {\n      '<C-a>': 'foo:bar',\n    })\n    await helper.wait(30)\n    msg = await helper.getCmdline()\n    revert()\n    expect(msg).toMatch('Invalid configuration')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute action keymap","suites":["User mappings"],"updatePoint":{"line":127,"column":34},"line":127,"code":"  it('should execute action keymap', async () => {\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      '<C-d>': 'action:quickfix',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-d>')\n    let buftype = await nvim.eval('&buftype')\n    expect(buftype).toBe('quickfix')\n    revert()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute expr keymap","suites":["User mappings"],"updatePoint":{"line":139,"column":32},"line":139,"code":"  it('should execute expr keymap', async () => {\n    await helper.mockFunction('TabOpen', 'quickfix')\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-t>': 'expr:TabOpen',\n    })\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'expr:TabOpen',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-t>')\n    let buftype = await nvim.eval('&buftype')\n    expect(buftype).toBe('quickfix')\n    await nvim.command('close')\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('t')\n    buftype = await nvim.eval('&buftype')\n    expect(buftype).toBe('quickfix')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute do mappings","suites":["User mappings"],"updatePoint":{"line":160,"column":32},"line":160,"code":"  it('should execute do mappings', async () => {\n    helper.updateConfiguration('list.previousKeymap', '<C-j>')\n    helper.updateConfiguration('list.nextKeymap', '<C-k>')\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-n>': 'do:next',\n      '<C-p>': 'do:previous',\n      '<C-d>': 'do:exit',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-n>')\n    let item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[1].text)\n    await helper.listInput('<C-p>')\n    item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[0].text)\n    await helper.listInput('<C-k>')\n    item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[1].text)\n    await helper.listInput('<C-j>')\n    item = await manager.session?.ui.item\n    expect(item.label).toMatch(locations[0].text)\n    await helper.listInput('<C-d>')\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute prompt mappings","suites":["User mappings"],"updatePoint":{"line":186,"column":36},"line":186,"code":"  it('should execute prompt mappings', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-p>': 'prompt:previous',\n      '<C-n>': 'prompt:next',\n      '<C-a>': 'prompt:start',\n      '<C-e>': 'prompt:end',\n      '<Left>': 'prompt:left',\n      '<Right>': 'prompt:right',\n      '<backspace>': 'prompt:deleteforward',\n      '<C-x>': 'prompt:deletebackward',\n      '<C-k>': 'prompt:removetail',\n      '<C-u>': 'prompt:removeahead',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    for (let key of ['<C-p>', '<C-n>', '<C-a>', '<C-e>', '<Left>', '<Right>', '<backspace>', '<C-x>', '<C-k>', '<C-u>']) {\n      await helper.listInput(key)\n    }\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute feedkeys keymap","suites":["User mappings"],"updatePoint":{"line":207,"column":36},"line":207,"code":"  it('should execute feedkeys keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-f>': 'feedkeys:\\\\<C-f>',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-f>')\n    let line = await nvim.call('line', '.')\n    expect(line).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute normal keymap","suites":["User mappings"],"updatePoint":{"line":218,"column":34},"line":218,"code":"  it('should execute normal keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-g>': 'normal:G',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-g>')\n    let line = await nvim.call('line', '.')\n    expect(line).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute command keymap","suites":["User mappings"],"updatePoint":{"line":229,"column":35},"line":229,"code":"  it('should execute command keymap', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-w>': 'command:wincmd p',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-w>')\n    expect(manager.isActivated).toBe(true)\n    let winnr = await nvim.call('winnr')\n    expect(winnr).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should execute call keymap","suites":["User mappings"],"updatePoint":{"line":241,"column":32},"line":241,"code":"  it('should execute call keymap', async () => {\n    await helper.mockFunction('Test', 1)\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-t>': 'call:Test',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-t>')\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert clipboard register to prompt","suites":["User mappings"],"updatePoint":{"line":252,"column":48},"line":252,"code":"  it('should insert clipboard register to prompt', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-r>': 'prompt:paste',\n    })\n    await nvim.command('let @* = \"foobar\"')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-r>')\n    let { input } = manager.prompt\n    expect(input).toMatch('foobar')\n    await nvim.command('let @* = \"\"')\n    await helper.listInput('<C-r>')\n    expect(manager.prompt.input).toMatch('foobar')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert text from default register to prompt","suites":["User mappings"],"updatePoint":{"line":267,"column":56},"line":267,"code":"  it('should insert text from default register to prompt', async () => {\n    helper.updateConfiguration('list.insertMappings', {\n      '<C-v>': 'eval:@@',\n    })\n    await nvim.command('let @@ = \"bar\"')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-v>')\n    let { input } = manager.prompt\n    expect(input).toMatch('bar')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when action not found","suites":["doAction()"],"updatePoint":{"line":281,"column":40},"line":281,"code":"  it('should throw when action not found', async () => {\n    let mappings = manager.mappings\n    let fn = async () => {\n      await mappings.doAction('foo:bar')\n    }\n    await expect(fn()).rejects.toThrow(/doesn't exist/)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when session does not exist","suites":["doAction()"],"updatePoint":{"line":289,"column":50},"line":289,"code":"  it('should not throw when session does not exist', async () => {\n    let mappings = manager.mappings\n    await mappings.doAction('do:selectall')\n    await mappings.doAction('do:help')\n    await mappings.doAction('do:refresh')\n    await mappings.doAction('do:toggle')\n    await mappings.doAction('do:jumpback')\n    await mappings.doAction('prompt:previous')\n    await mappings.doAction('prompt:next')\n    await mappings.doAction('do:refresh')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when action name does not exist","suites":["doAction()"],"updatePoint":{"line":301,"column":54},"line":301,"code":"  it('should not throw when action name does not exist', async () => {\n    await helper.mockFunction('MyExpr', '')\n    let mappings = manager.mappings\n    await mappings.doAction('expr', 'MyExpr')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid action","suites":["getAction()"],"updatePoint":{"line":309,"column":37},"line":309,"code":"  it('should throw for invalid action', async () => {\n    let mappings = manager.mappings\n    let fn = () => {\n      mappings.getAction('foo')\n    }\n    expect(fn).toThrow(Error)\n    fn = () => {\n      mappings.getAction('do:bar')\n    }\n    expect(fn).toThrow(Error)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke action","suites":["Default normal mappings"],"updatePoint":{"line":323,"column":26},"line":323,"code":"  it('should invoke action', async () => {\n    await manager.start(['--normal', '--no-quit', 'location'])\n    await manager.session.ui.ready\n    let winid = manager.session.ui.winid\n    await helper.listInput('t')\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n    await nvim.call('win_gotoid', [winid])\n    await helper.listInput('s')\n    let winnr = await nvim.call('winnr', ['$'])\n    expect(winnr).toBe(3)\n    await nvim.call('win_gotoid', [winid])\n    await helper.listInput('d')\n    let filename = await nvim.call('expand', ['%'])\n    expect(filename).toMatch(path.basename(__filename))\n    await nvim.call('win_gotoid', [winid])\n    await helper.listInput('<cr>')\n    filename = await nvim.call('expand', ['%'])\n    expect(filename).toMatch(path.basename(__filename))\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select all items by <C-a>","suites":["Default normal mappings"],"updatePoint":{"line":344,"column":38},"line":344,"code":"  it('should select all items by <C-a>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-a>')\n    let selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(locations.length)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop by <C-b>","suites":["Default normal mappings"],"updatePoint":{"line":352,"column":26},"line":352,"code":"  it('should stop by <C-b>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-b>')\n    let loading = manager.session?.worker.isLoading\n    expect(loading).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back by <C-o>","suites":["Default normal mappings"],"updatePoint":{"line":360,"column":31},"line":360,"code":"  it('should jump back by <C-o>', async () => {\n    let doc = await helper.createDocument()\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-o>')\n    let bufnr = await nvim.call('bufnr', ['%'])\n    expect(bufnr).toBe(doc.bufnr)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll preview window by <C-e>, <C-y>","suites":["Default normal mappings"],"updatePoint":{"line":369,"column":50},"line":369,"code":"  it('should scroll preview window by <C-e>, <C-y>', async () => {\n    await helper.createDocument()\n    await manager.start(['--auto-preview', '--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.waitPreviewWindow()\n    let winnr = await nvim.call('coc#list#has_preview') as number\n    let winid = await nvim.call('win_getid', [winnr])\n    await helper.listInput('<C-e>')\n    let res = await nvim.call('getwininfo', [winid])\n    expect(res[0].topline).toBeGreaterThan(1)\n    await helper.listInput('<C-y>')\n    res = await nvim.call('getwininfo', [winid])\n    expect(res[0].topline).toBeLessThan(7)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert command by :","suites":["Default normal mappings"],"updatePoint":{"line":384,"column":32},"line":384,"code":"  it('should insert command by :', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput(':')\n    await nvim.eval('feedkeys(\"let g:x = 1\\\\<cr>\", \"in\")')\n    let res = await nvim.getVar('x')\n    expect(res).toBe(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action by <tab>","suites":["Default normal mappings"],"updatePoint":{"line":393,"column":35},"line":393,"code":"  it('should select action by <tab>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    let p = helper.listInput('<tab>')\n    await helper.wait(50)\n    await nvim.input('t')\n    await p\n    let nr = await nvim.call('tabpagenr')\n    expect(nr).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview by p","suites":["Default normal mappings"],"updatePoint":{"line":404,"column":25},"line":404,"code":"  it('should preview by p', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('p')\n    let winnr = await nvim.call('coc#list#has_preview')\n    expect(winnr).toBe(2)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop task by <C-c>","suites":["Default normal mappings"],"updatePoint":{"line":412,"column":31},"line":412,"code":"  it('should stop task by <C-c>', async () => {\n    disposables.push(manager.registerList(new TestList(nvim)))\n    let p = manager.start(['--normal', 'test'])\n    await helper.wait(50)\n    await nvim.input('<C-c>')\n    await p\n    let len = manager.session?.ui.length\n    expect(len).toBe(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel list by <esc>","suites":["Default normal mappings"],"updatePoint":{"line":422,"column":33},"line":422,"code":"  it('should cancel list by <esc>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<esc>\", \"in\")')\n    await helper.waitValue(() => {\n      return manager.isActivated\n    }, false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload list by <C-l>","suites":["Default normal mappings"],"updatePoint":{"line":431,"column":33},"line":431,"code":"  it('should reload list by <C-l>', async () => {\n    let list = new TestList(nvim)\n    list.timeout = 0\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'test'])\n    await manager.session.ui.ready\n    list.text = 'new'\n    await helper.listInput('<C-l>')\n    await helper.wait(30)\n    let line = await nvim.line\n    expect(line).toMatch('new')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection <space>","suites":["Default normal mappings"],"updatePoint":{"line":444,"column":37},"line":444,"code":"  it('should toggle selection <space>', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput(' ')\n    let selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(1)\n    await helper.listInput('k')\n    await helper.listInput(' ')\n    selected = manager.session?.ui.selectedItems\n    expect(selected.length).toBe(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to insert mode by i, o, a","suites":["Default normal mappings"],"updatePoint":{"line":456,"column":45},"line":456,"code":"  it('should change to insert mode by i, o, a', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    let keys = ['i', 'I', 'o', 'O', 'a', 'A']\n    for (let key of keys) {\n      await helper.listInput(key)\n      let mode = manager.prompt.mode\n      expect(mode).toBe('insert')\n      await helper.listInput('<C-o>')\n      mode = manager.prompt.mode\n      expect(mode).toBe('normal')\n    }\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show help by ?","suites":["Default normal mappings"],"updatePoint":{"line":470,"column":27},"line":470,"code":"  it('should show help by ?', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('?')\n    let bufname = await nvim.call('bufname', '%')\n    expect(bufname).toBe('[LIST HELP]')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open by <cr>","suites":["list insert mappings"],"updatePoint":{"line":480,"column":25},"line":480,"code":"  it('should open by <cr>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<cr>')\n    let bufname = await nvim.call('expand', ['%:p'])\n    expect(bufname).toMatch('mappings.test.ts')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should paste input by <C-v>","suites":["list insert mappings"],"updatePoint":{"line":488,"column":33},"line":488,"code":"  it('should paste input by <C-v>', async () => {\n    await nvim.command('let @* = \"foo\"')\n    await nvim.command('let @@ = \"foo\"')\n    await nvim.call('setreg', ['*', 'foo'])\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-v>')\n    let input = manager.prompt.input\n    expect(input).toBe('foo')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert register content by <C-r>","suites":["list insert mappings"],"updatePoint":{"line":499,"column":45},"line":499,"code":"  it('should insert register content by <C-r>', async () => {\n    await nvim.command('let @* = \"foo\"')\n    await nvim.command('let @@ = \"foo\"')\n    await nvim.call('setreg', ['*', 'foo'])\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-r>')\n    await helper.listInput('*')\n    let input = manager.prompt.input\n    expect(input).toBe('foo')\n    await helper.listInput('<C-r>')\n    await helper.listInput('<')\n    input = manager.prompt.input\n    expect(input).toBe('foo')\n    manager.prompt.reset()\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["list insert mappings"],"updatePoint":{"line":516,"column":28},"line":516,"code":"  it('should cancel by <esc>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<esc>')\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action by insert <tab>","suites":["list insert mappings"],"updatePoint":{"line":523,"column":42},"line":523,"code":"  it('should select action by insert <tab>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    let p = helper.listInput('<tab>')\n    await helper.wait(50)\n    await nvim.input('d')\n    await p\n    let bufname = await nvim.call('bufname', ['%'])\n    expect(bufname).toMatch(path.basename(__filename))\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select action for visual selected items","suites":["list insert mappings"],"updatePoint":{"line":534,"column":52},"line":534,"code":"  it('should select action for visual selected items', async () => {\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.wait(50)\n    await nvim.input('V')\n    await helper.wait(30)\n    await nvim.input('2')\n    await helper.wait(30)\n    await nvim.input('j')\n    await helper.wait(30)\n    await manager.doAction('quickfix')\n    let buftype = await nvim.eval('&buftype')\n    expect(buftype).toBe('quickfix')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop loading by <C-c>","suites":["list insert mappings"],"updatePoint":{"line":549,"column":34},"line":549,"code":"  it('should stop loading by <C-c>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-c>')\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload by <C-l>","suites":["list insert mappings"],"updatePoint":{"line":556,"column":28},"line":556,"code":"  it('should reload by <C-l>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-l>')\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to normal mode by <C-o>","suites":["list insert mappings"],"updatePoint":{"line":563,"column":43},"line":563,"code":"  it('should change to normal mode by <C-o>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-o>')\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select line by <down> and <up>","suites":["list insert mappings"],"updatePoint":{"line":570,"column":43},"line":570,"code":"  it('should select line by <down> and <up>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await nvim.eval('feedkeys(\"\\\\<down>\", \"in\")')\n    await nvim.eval('feedkeys(\"\\\\<up>\", \"in\")')\n    expect(manager.isActivated).toBe(true)\n    let line = await nvim.line\n    expect(line).toMatch('foo')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <left> and <right>","suites":["list insert mappings"],"updatePoint":{"line":580,"column":46},"line":580,"code":"  it('should move cursor by <left> and <right>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('f')\n    await helper.listInput('<left>')\n    await helper.listInput('<left>')\n    await helper.listInput('a')\n    await helper.listInput('<right>')\n    await helper.listInput('<right>')\n    await helper.listInput('c')\n    let input = manager.prompt.input\n    expect(input).toBe('afc')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <end> and <home>","suites":["list insert mappings"],"updatePoint":{"line":594,"column":44},"line":594,"code":"  it('should move cursor by <end> and <home>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<home>')\n    await helper.listInput('<end>')\n    await helper.listInput('a')\n    let input = manager.prompt.input\n    expect(input).toBe('a')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by <PageUp> <PageDown> <C-d>","suites":["list insert mappings"],"updatePoint":{"line":604,"column":53},"line":604,"code":"  it('should move cursor by <PageUp> <PageDown> <C-d>', async () => {\n    disposables.push(manager.registerList(lineList))\n    await manager.start(['lines'])\n    await manager.session.ui.ready\n    await helper.listInput('<PageDown>')\n    await helper.listInput('<PageUp>')\n    await helper.listInput('<C-d>')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll window by <C-f> and <C-b>","suites":["list insert mappings"],"updatePoint":{"line":613,"column":45},"line":613,"code":"  it('should scroll window by <C-f> and <C-b>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-f>')\n    await helper.listInput('<C-b>')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <Backspace>","suites":["list insert mappings"],"updatePoint":{"line":620,"column":40},"line":620,"code":"  it('should change input by <Backspace>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('f')\n    await helper.listInput('<backspace>')\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-b>","suites":["list insert mappings"],"updatePoint":{"line":629,"column":34},"line":629,"code":"  it('should change input by <C-b>', async () => {\n    let revert = helper.updateConfiguration('list.insertMappings', {\n      '<C-b>': 'prompt:removetail',\n    })\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('f')\n    await helper.listInput('o')\n    await helper.listInput('o')\n    await helper.listInput('<C-a>')\n    await helper.listInput('<C-b>')\n    expect(manager.mappings.hasUserMapping('insert', '<C-b>')).toBe(true)\n    let input = manager.prompt.input\n    revert()\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-h>","suites":["list insert mappings"],"updatePoint":{"line":646,"column":34},"line":646,"code":"  it('should change input by <C-h>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('f')\n    await helper.listInput('<C-h>')\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-w>","suites":["list insert mappings"],"updatePoint":{"line":655,"column":34},"line":655,"code":"  it('should change input by <C-w>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('f')\n    await helper.listInput('a')\n    await helper.listInput('<C-w>')\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-u>","suites":["list insert mappings"],"updatePoint":{"line":665,"column":34},"line":665,"code":"  it('should change input by <C-u>', async () => {\n    await manager.start(['--input=a', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-u>')\n    let input = manager.prompt.input\n    expect(input).toBe('')\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change input by <C-n> and <C-p>","suites":["list insert mappings"],"updatePoint":{"line":673,"column":44},"line":673,"code":"  it('should change input by <C-n> and <C-p>', async () => {\n    async function session(input: string): Promise<void> {\n      await manager.start(['location'])\n      await manager.session.ui.ready\n      for (let ch of input) {\n        await helper.listInput(ch)\n      }\n      await manager.cancel()\n    }\n    await session('foo')\n    await session('bar')\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-n>')\n    let input = manager.prompt.input\n    expect(input.length).toBeGreaterThan(0)\n    await helper.listInput('<C-p>')\n    input = manager.prompt.input\n    expect(input.length).toBeGreaterThan(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change matcher by <C-s>","suites":["list insert mappings"],"updatePoint":{"line":694,"column":36},"line":694,"code":"  it('should change matcher by <C-s>', async () => {\n    await manager.start(['location'])\n    await manager.session.ui.ready\n    await helper.listInput('<C-s>')\n    let matcher = manager.session?.listOptions.matcher\n    expect(matcher).toBe('strict')\n    await helper.listInput('<C-s>')\n    matcher = manager.session?.listOptions.matcher\n    expect(matcher).toBe('regex')\n    await helper.listInput('f')\n    let len = manager.session?.ui.length\n    expect(len).toBeGreaterThan(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should exit list","suites":["evalExpression"],"updatePoint":{"line":710,"column":22},"line":710,"code":"  it('should exit list', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:exit',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    expect(manager.mappings.hasUserMapping('normal', 't')).toBe(true)\n    await helper.listInput('t')\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel prompt","suites":["evalExpression"],"updatePoint":{"line":721,"column":26},"line":721,"code":"  it('should cancel prompt', async () => {\n    helper.updateConfiguration('list.normalMappings', {\n      t: 'do:cancel',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('t')\n    let res = await nvim.call('coc#prompt#activated')\n    expect(res).toBe(0)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke normal command","suites":["evalExpression"],"updatePoint":{"line":732,"column":34},"line":732,"code":"  it('should invoke normal command', async () => {\n    let revert = helper.updateConfiguration('list.normalMappings', {\n      x: 'normal!:G'\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput('x')\n    revert()\n    let lnum = await nvim.call('line', ['.'])\n    expect(lnum).toBeGreaterThan(1)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle, scroll preview","suites":["evalExpression"],"updatePoint":{"line":744,"column":35},"line":744,"code":"  it('should toggle, scroll preview', async () => {\n    let revert = helper.updateConfiguration('list.normalMappings', {\n      '<space>': 'do:toggle',\n      a: 'do:toggle',\n      b: 'do:previewtoggle',\n      c: 'do:previewup',\n      d: 'do:previewdown',\n      e: 'prompt:insertregister',\n      f: 'do:stop',\n      g: 'do:togglemode',\n    })\n    await manager.start(['--normal', 'location'])\n    await manager.session.ui.ready\n    await helper.listInput(' ')\n    for (let key of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {\n      await helper.listInput(key)\n    }\n    revert()\n    expect(manager.isActivated).toBe(true)\n  })","file":"list/mappings.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when default action does not exist","suites":["list session","doDefaultAction()"],"updatePoint":{"line":62,"column":61},"line":62,"code":"    it('should throw error when default action does not exist', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      list.defaultAction = 'foo'\n      let len = list.actions.length\n      list.actions.splice(0, len)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      let err\n      try {\n        await manager.session.first()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n      err = null\n      try {\n        await manager.session.last()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke multiple action","suites":["list session","doItemAction()"],"updatePoint":{"line":90,"column":37},"line":90,"code":"    it('should invoke multiple action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectAll()\n      await manager.doAction('multiple')\n      expect(lastItems.length).toBe(3)\n      lastItems = undefined\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke parallel action","suites":["list session","doItemAction()"],"updatePoint":{"line":103,"column":37},"line":103,"code":"    it('should invoke parallel action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectAll()\n      let d = Date.now()\n      await manager.doAction('parallel')\n      expect(Date.now() - d).toBeLessThan(300)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke reload action","suites":["list session","doItemAction()"],"updatePoint":{"line":116,"column":35},"line":116,"code":"    it('should invoke reload action', async () => {\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      labels = ['d', 'e']\n      await manager.doAction('reload')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines).toEqual(['d', 'e'])\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not reload items when window is hidden","suites":["list session","reloadItems()"],"updatePoint":{"line":133,"column":53},"line":133,"code":"    it('should not reload items when window is hidden', async () => {\n      let fn = jest.fn()\n      let list: IList = {\n        name: 'reload',\n        defaultAction: 'open',\n        actions: [{\n          name: 'open',\n          execute: () => {}\n        }],\n        loadItems: () => {\n          fn()\n          return Promise.resolve([])\n        }\n      }\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'reload'])\n      let ui = manager.session.ui\n      await ui.ready\n      await manager.cancel(true)\n      let ses = manager.getSession('reload')\n      await ses.reloadItems()\n      expect(fn).toBeCalledTimes(1)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do preview on resume","suites":["list session","resume()"],"updatePoint":{"line":159,"column":35},"line":159,"code":"    it('should do preview on resume', async () => {\n      labels = ['a', 'b', 'c']\n      let lastItem\n      let list = new SimpleList(nvim)\n      list.actions.push({\n        name: 'preview',\n        execute: item => {\n          lastItem = item\n        }\n      })\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', '--auto-preview', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(1, 2)\n      await helper.wait(50)\n      await nvim.call('coc#window#close', [ui.winid])\n      await helper.wait(100)\n      await manager.session.resume()\n      await helper.wait(100)\n      expect(lastItem).toBeDefined()\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back","suites":["list session","jumpBack()"],"updatePoint":{"line":184,"column":24},"line":184,"code":"    it('should jump back', async () => {\n      let win = await nvim.window\n      labels = ['a', 'b', 'c']\n      let list = new SimpleList(nvim)\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      manager.session.jumpBack()\n      await helper.wait(50)\n      let winid = await nvim.call('win_getid')\n      expect(winid).toBe(win.id)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false for invalid number","suites":["list session","doNumberSelect()"],"updatePoint":{"line":214,"column":46},"line":214,"code":"    it('should return false for invalid number', async () => {\n      let session = await create(5)\n      let res = await session.doNumberSelect('a')\n      expect(res).toBe(false)\n      res = await session.doNumberSelect('8')\n      expect(res).toBe(false)\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider 0 as 10","suites":["list session","doNumberSelect()"],"updatePoint":{"line":222,"column":31},"line":222,"code":"    it('should consider 0 as 10', async () => {\n      let session = await create(15)\n      let res = await session.doNumberSelect('0')\n      expect(res).toBe(true)\n      expect(lastItem).toBe('j')\n    })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show description and options in help","suites":["showHelp()"],"updatePoint":{"line":232,"column":49},"line":232,"code":"  it('should show description and options in help', async () => {\n    labels = ['a', 'b', 'c']\n    let list = new SimpleList(nvim)\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    await manager.session.showHelp()\n    let lines = await nvim.call('getline', [1, '$'])\n    expect(lines.indexOf('DESCRIPTION')).toBeGreaterThan(0)\n    expect(lines.indexOf('ARGUMENTS')).toBeGreaterThan(0)\n  })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter actions not have shortcuts","suites":["chooseAction()"],"updatePoint":{"line":247,"column":46},"line":247,"code":"  it('should filter actions not have shortcuts', async () => {\n    labels = ['a', 'b', 'c']\n    let fn = jest.fn()\n    let list = new SimpleList(nvim)\n    list.actions.push({\n      name: 'a',\n      execute: () => {\n        fn()\n      }\n    })\n    list.actions.push({\n      name: 'b',\n      execute: () => {\n      }\n    })\n    list.actions.push({\n      name: 'ab',\n      execute: () => {\n      }\n    })\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'simple'])\n    await manager.session.ui.ready\n    let p = manager.session.chooseAction()\n    await helper.wait(50)\n    await nvim.input('a')\n    await p\n    expect(fn).toBeCalled()\n  })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should choose action by menu picker","suites":["chooseAction()"],"updatePoint":{"line":277,"column":41},"line":277,"code":"  it('should choose action by menu picker', async () => {\n    helper.updateConfiguration('list.menuAction', true)\n    labels = ['a', 'b', 'c']\n    let fn = jest.fn()\n    let list = new SimpleList(nvim)\n    let len = list.actions.length\n    list.actions.splice(0, len)\n    list.actions.push({\n      name: 'a',\n      execute: () => {\n        fn()\n      }\n    })\n    list.actions.push({\n      name: 'b',\n      execute: () => {\n        fn()\n      }\n    })\n    disposables.push(manager.registerList(list))\n    await manager.start(['--normal', 'simple'])\n    await manager.session.ui.ready\n    let p = manager.session.chooseAction()\n    await helper.waitPrompt()\n    await nvim.input('<cr>')\n    await p\n  })","file":"list/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format path","suites":["formatting","formatPath()"],"updatePoint":{"line":89,"column":26},"line":89,"code":"    it('should format path', async () => {\n      expect(formatPath('hidden', 'path')).toBe('')\n      expect(formatPath('full', __filename)).toMatch('sources.test.ts')\n      expect(formatPath('short', __filename)).toMatch('sources.test.ts')\n      expect(formatPath('filename', __filename)).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should format list items","suites":["formatting","formatListItems"],"updatePoint":{"line":98,"column":32},"line":98,"code":"    it('should format list items', async () => {\n      expect(formatListItems(false, [])).toEqual([])\n      let items: UnformattedListItem[] = [{\n        label: ['a', 'b', 'c']\n      }]\n      expect(formatListItems(false, items)).toEqual([{\n        label: 'a\\tb\\tc'\n      }])\n      items = [{\n        label: ['a', 'b', 'c']\n      }, {\n        label: ['foo', 'bar', 'go']\n      }]\n      expect(formatListItems(true, items)).toEqual([{\n        label: 'a  \\tb  \\tc '\n      }, {\n        label: 'foo\\tbar\\tgo'\n      }])\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change default options","suites":["configuration"],"updatePoint":{"line":126,"column":35},"line":126,"code":"  it('should change default options', async () => {\n    helper.updateConfiguration('list.source.option.defaultOptions', ['--normal'])\n    await manager.start(['option'])\n    await manager.session.ui.ready\n    const mode = manager.prompt.mode\n    expect(mode).toBe('normal')\n  })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change default action","suites":["configuration"],"updatePoint":{"line":134,"column":34},"line":134,"code":"  it('should change default action', async () => {\n    helper.updateConfiguration('list.source.option.defaultAction', 'split')\n    await manager.start(['option'])\n    await manager.session.ui.ready\n    const action = manager.session.defaultAction\n    expect(action.name).toBe('split')\n    await manager.session.doAction()\n    let tab = await nvim.tabpage\n    let wins = await tab.windows\n    expect(wins.length).toBeGreaterThan(1)\n  })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change default arguments","suites":["configuration"],"updatePoint":{"line":146,"column":37},"line":146,"code":"  it('should change default arguments', async () => {\n    helper.updateConfiguration('list.source.option.defaultArgs', ['-word'])\n    await manager.start(['option'])\n    await manager.session.ui.ready\n    const context = manager.session.context\n    expect(context.args).toEqual(['-word'])\n  })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get filetype","suites":["BasicList","getFiletype()"],"updatePoint":{"line":157,"column":27},"line":157,"code":"    it('should get filetype', async () => {\n      expect(toVimFiletype('latex')).toBe('tex')\n      expect(toVimFiletype('foo')).toBe('foo')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #1","suites":["BasicList","parse arguments"],"updatePoint":{"line":164,"column":28},"line":164,"code":"    it('should parse args #1', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-w'])\n      expect(res).toEqual({ word: true })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #2","suites":["BasicList","parse arguments"],"updatePoint":{"line":170,"column":28},"line":170,"code":"    it('should parse args #2', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-word'])\n      expect(res).toEqual({ word: true })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse args #3","suites":["BasicList","parse arguments"],"updatePoint":{"line":176,"column":28},"line":176,"code":"    it('should parse args #3', () => {\n      let list = new OptionList(nvim)\n      let res = list.parseArguments(['-input', 'foo'])\n      expect(res).toEqual({ input: 'foo' })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to uri","suites":["BasicList","jumpTo()"],"updatePoint":{"line":188,"column":26},"line":188,"code":"    it('should jump to uri', async () => {\n      let uri = URI.file(__filename).toString()\n      await list.jumpTo(uri, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to location","suites":["BasicList","jumpTo()"],"updatePoint":{"line":195,"column":31},"line":195,"code":"    it('should jump to location', async () => {\n      let uri = URI.file(__filename).toString()\n      let loc = Location.create(uri, Range.create(0, 0, 1, 0))\n      await list.jumpTo(loc, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to location with empty range","suites":["BasicList","jumpTo()"],"updatePoint":{"line":203,"column":48},"line":203,"code":"    it('should jump to location with empty range', async () => {\n      let uri = URI.file(__filename).toString()\n      let loc = Location.create(uri, Range.create(0, 0, 0, 0))\n      await list.jumpTo(loc, 'edit')\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert uri","suites":["BasicList","convertLocation()"],"updatePoint":{"line":217,"column":26},"line":217,"code":"    it('should convert uri', async () => {\n      let uri = URI.file(__filename).toString()\n      let res = await list.convertLocation(uri)\n      expect(res.uri).toBe(uri)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert location with line","suites":["BasicList","convertLocation()"],"updatePoint":{"line":223,"column":41},"line":223,"code":"    it('should convert location with line', async () => {\n      let uri = URI.file(__filename).toString()\n      let res = await list.convertLocation({ uri, line: 'convertLocation()', text: 'convertLocation' })\n      expect(res.uri).toBe(uri)\n      res = await list.convertLocation({ uri, line: 'convertLocation()' })\n      expect(res.uri).toBe(uri)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert location with custom schema","suites":["BasicList","convertLocation()"],"updatePoint":{"line":231,"column":50},"line":231,"code":"    it('should convert location with custom schema', async () => {\n      let uri = 'test:///foo'\n      let res = await list.convertLocation({ uri, line: 'convertLocation()' })\n      expect(res.uri).toBe(uri)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should overwrite action","suites":["BasicList","createAction()"],"updatePoint":{"line":239,"column":31},"line":239,"code":"    it('should overwrite action', async () => {\n      let idx: number\n      let list = new OptionList(nvim)\n      listItems.push({\n        label: 'foo',\n        location: Location.create('untitled:///1', Range.create(0, 0, 0, 0))\n      })\n      list.createAction({\n        name: 'foo',\n        execute: () => { idx = 0 }\n      })\n      list.createAction({\n        name: 'foo',\n        execute: () => { idx = 1 }\n      })\n      disposables.push(manager.registerList(list))\n      await manager.start(['--normal', 'option'])\n      await manager.session.ui.ready\n      await manager.doAction('foo')\n      expect(idx).toBe(1)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview lines","suites":["BasicList","preview()"],"updatePoint":{"line":279,"column":28},"line":279,"code":"    it('should preview lines', async () => {\n      await doPreview({ filetype: '', lines: ['foo', 'bar'] })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview with bufname","suites":["BasicList","preview()"],"updatePoint":{"line":283,"column":35},"line":283,"code":"    it('should preview with bufname', async () => {\n      await doPreview({\n        bufname: 't.js',\n        filetype: 'typescript',\n        lines: ['foo', 'bar']\n      })\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview with range highlight","suites":["BasicList","preview()"],"updatePoint":{"line":291,"column":43},"line":291,"code":"    it('should preview with range highlight', async () => {\n      let winid = await doPreview({\n        bufname: 't.js',\n        filetype: 'typescript',\n        lines: ['foo', 'bar'],\n        range: Range.create(0, 0, 0, 3)\n      })\n      let res = await nvim.call('getmatches', [winid])\n      expect(res.length).toBeGreaterThan(0)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preview sketch buffer","suites":["BasicList","previewLocation()"],"updatePoint":{"line":304,"column":36},"line":304,"code":"    it('should preview sketch buffer', async () => {\n      await nvim.command('new')\n      await nvim.setLine('foo')\n      let doc = await workspace.document\n      expect(doc.uri).toMatch('untitled')\n      let list = new OptionList(nvim)\n      listItems.push({\n        label: 'foo',\n        location: Location.create(doc.uri, Range.create(0, 0, 0, 0))\n      })\n      disposables.push(manager.registerList(list))\n      await manager.start(['option'])\n      await manager.session.ui.ready\n      await helper.wait(30)\n      await manager.doAction('preview')\n      await nvim.command('wincmd p')\n      let win = await nvim.window\n      let isPreview = await win.getVar('previewwindow')\n      expect(isPreview).toBe(1)\n      let line = await nvim.line\n      expect(line).toBe('foo')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight ranges","suites":["list sources","locations"],"updatePoint":{"line":335,"column":31},"line":335,"code":"    it('should highlight ranges', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await helper.wait(200)\n      manager.prompt.cancel()\n      await nvim.command('wincmd k')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('sources.test.ts')\n      let res = await nvim.call('getmatches')\n      expect(res.length).toBe(1)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change highlight on cursor move","suites":["list sources","locations"],"updatePoint":{"line":347,"column":46},"line":347,"code":"    it('should change highlight on cursor move', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await nvim.command('exe 2')\n      let bufnr = await nvim.eval('bufnr(\"%\")')\n      await events.fire('CursorMoved', [bufnr, [2, 1]])\n      await helper.waitFor('winnr', ['$'], 3)\n      await nvim.command('wincmd k')\n      let res = await nvim.call('getmatches')\n      expect(res.length).toBe(1)\n      expect(res[0]['pos1']).toEqual([3, 1, 6])\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight multiple line range","suites":["list sources","locations"],"updatePoint":{"line":360,"column":44},"line":360,"code":"    it('should highlight multiple line range', async () => {\n      await manager.start(['--normal', '--auto-preview', 'location'])\n      await manager.session.ui.ready\n      await nvim.command('exe 3')\n      let bufnr = await nvim.eval('bufnr(\"%\")')\n      await events.fire('CursorMoved', [bufnr, [2, 1]])\n      await helper.waitFor('winnr', ['$'], 3)\n      await nvim.command('wincmd k')\n      let res = await nvim.call('getmatches')\n      expect(res.length).toBe(1)\n      expect(res[0]['pos1']).toBeDefined()\n      expect(res[0]['pos2']).toBeDefined()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do open action","suites":["list sources","locations"],"updatePoint":{"line":374,"column":29},"line":374,"code":"    it('should do open action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.doAction('open')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do quickfix action","suites":["list sources","locations"],"updatePoint":{"line":382,"column":33},"line":382,"code":"    it('should do quickfix action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.session.ui.selectAll()\n      await manager.doAction('quickfix')\n      let buftype = await nvim.eval('&buftype')\n      expect(buftype).toBe('quickfix')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do refactor action","suites":["list sources","locations"],"updatePoint":{"line":391,"column":33},"line":391,"code":"    it('should do refactor action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.session.ui.selectAll()\n      await manager.doAction('refactor')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('coc_refactor')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do tabe action","suites":["list sources","locations"],"updatePoint":{"line":400,"column":29},"line":400,"code":"    it('should do tabe action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.doAction('tabe')\n      let tabs = await nvim.tabpages\n      expect(tabs.length).toBe(2)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do drop action","suites":["list sources","locations"],"updatePoint":{"line":408,"column":29},"line":408,"code":"    it('should do drop action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.doAction('drop')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do vsplit action","suites":["list sources","locations"],"updatePoint":{"line":416,"column":31},"line":416,"code":"    it('should do vsplit action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.doAction('vsplit')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do split action","suites":["list sources","locations"],"updatePoint":{"line":424,"column":30},"line":424,"code":"    it('should do split action', async () => {\n      await manager.start(['--normal', 'location'])\n      await manager.session.ui.ready\n      await manager.doAction('split')\n      let name = await nvim.eval('bufname(\"%\")')\n      expect(name).toMatch('sources.test.ts')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load commands source","suites":["list sources","commands"],"updatePoint":{"line":434,"column":35},"line":434,"code":"    it('should load commands source', async () => {\n      await manager.start(['commands'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do run action","suites":["list sources","commands"],"updatePoint":{"line":440,"column":28},"line":440,"code":"    it('should do run action', async () => {\n      await manager.start(['commands'])\n      await manager.session?.ui.ready\n      await manager.doAction()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load diagnostics source","suites":["list sources","diagnostics"],"updatePoint":{"line":479,"column":38},"line":479,"code":"    it('should load diagnostics source', async () => {\n      await createDocument('a')\n      await manager.start(['diagnostics'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not include code","suites":["list sources","diagnostics"],"updatePoint":{"line":486,"column":31},"line":486,"code":"    it('should not include code', async () => {\n      let fn = helper.updateConfiguration('list.source.diagnostics.includeCode', false)\n      disposables.push({ dispose: fn })\n      await createDocument('a')\n      await manager.start(['diagnostics'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let line = await nvim.line\n      expect(line.match(/100/)).toBeNull()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide file path","suites":["list sources","diagnostics"],"updatePoint":{"line":497,"column":29},"line":497,"code":"    it('should hide file path', async () => {\n      helper.updateConfiguration('list.source.diagnostics.pathFormat', 'hidden')\n      await createDocument('foo')\n      await manager.start(['diagnostics'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let line = await nvim.line\n      expect(line.match(/foo/)).toBeNull()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on diagnostics refresh","suites":["list sources","diagnostics"],"updatePoint":{"line":507,"column":45},"line":507,"code":"    it('should refresh on diagnostics refresh', async () => {\n      let doc = await createDocument('bar')\n      await manager.start(['diagnostics'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let diagnostics: Diagnostic[] = []\n      let collection = diagnosticManager.create('test')\n      diagnostics.push(createDiagnostic('error', Range.create(2, 0, 2, 2), DiagnosticSeverity.Error, 1009))\n      collection.set(doc.uri, diagnostics)\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let lines = await buf.lines\n      expect(lines.length).toBeGreaterThan(0)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load extensions source","suites":["list sources","extensions"],"updatePoint":{"line":524,"column":37},"line":524,"code":"    it('should load extensions source', async () => {\n      await manager.start(['extensions'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load folders source","suites":["list sources","folders"],"updatePoint":{"line":532,"column":34},"line":532,"code":"    it('should load folders source', async () => {\n      await manager.start(['folders'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load lists source","suites":["list sources","lists"],"updatePoint":{"line":540,"column":32},"line":540,"code":"    it('should load lists source', async () => {\n      await manager.start(['lists'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      await helper.listInput('<cr>')\n      await helper.wait(50)\n      let s = manager.getSession()\n      expect(s.name != 'lists').toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load outline source","suites":["list sources","outline"],"updatePoint":{"line":552,"column":34},"line":552,"code":"    it('should load outline source', async () => {\n      await manager.start(['outline'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load services source","suites":["list sources","services"],"updatePoint":{"line":589,"column":35},"line":589,"code":"    it('should load services source', async () => {\n      createService('foo')\n      createService('bar')\n      await manager.start(['services'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let lines = await nvim.call('getline', [1, '$']) as string[]\n      expect(lines.length).toBe(2)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle service state","suites":["list sources","services"],"updatePoint":{"line":599,"column":35},"line":599,"code":"    it('should toggle service state', async () => {\n      let service = createService('foo')\n      await service.start()\n      await manager.start(['services'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let ses = manager.session\n      expect(ses.name).toBe('services')\n      await ses.doAction('toggle')\n      expect(service.state).toBe(ServiceStat.Stopped)\n      await ses.doAction('toggle')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load sources source","suites":["list sources","sources"],"updatePoint":{"line":614,"column":34},"line":614,"code":"    it('should load sources source', async () => {\n      await manager.start(['sources'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let session = manager.getSession()\n      await session.doAction('open')\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toMatch(/native/)\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle source state","suites":["list sources","sources"],"updatePoint":{"line":624,"column":34},"line":624,"code":"    it('should toggle source state', async () => {\n      await manager.start(['sources'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let session = manager.getSession()\n      await session.doAction('toggle')\n      await session.doAction('toggle')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh source","suites":["list sources","sources"],"updatePoint":{"line":633,"column":29},"line":633,"code":"    it('should refresh source', async () => {\n      await manager.start(['sources'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      let session = manager.getSession()\n      await session.doAction('refresh')\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load symbols source","suites":["list sources","symbols"],"updatePoint":{"line":643,"column":34},"line":643,"code":"    it('should load symbols source', async () => {\n      await helper.createDocument()\n      let disposable = languages.registerWorkspaceSymbolProvider({\n        provideWorkspaceSymbols: () => []\n      })\n      await manager.start(['--interactive', 'symbols'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      disposable.dispose()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load links source","suites":["list sources","links"],"updatePoint":{"line":656,"column":32},"line":656,"code":"    it('should load links source', async () => {\n      let disposable = languages.registerDocumentLinkProvider([{ scheme: 'file' }, { scheme: 'untitled' }], {\n        provideDocumentLinks: () => []\n      })\n      await manager.start(['links'])\n      await manager.session?.ui.ready\n      expect(manager.isActivated).toBe(true)\n      disposable.dispose()\n    })","file":"list/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select lines","suites":["list ui","selectLines()"],"updatePoint":{"line":74,"column":27},"line":74,"code":"    it('should select lines', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(3, 1)\n      let buf = await nvim.buffer\n      let res = await buf.getSigns({ group: 'coc-list' })\n      expect(res.length).toBe(2)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select preselect item","suites":["list ui","preselect"],"updatePoint":{"line":88,"column":36},"line":88,"code":"    it('should select preselect item', async () => {\n      let list: IList = {\n        actions: [{\n          name: 'open',\n          execute: () => {}\n        }],\n        name: 'preselect',\n        defaultAction: 'open',\n        loadItems: () => {\n          return Promise.resolve([{ label: 'foo' }, { label: 'bar', preselect: true }])\n        }\n      }\n      disposables.push(manager.registerList(list))\n      await manager.start(['preselect'])\n      let ui = manager.session.ui\n      await ui.ready\n      let line = await nvim.line\n      expect(line).toBe('bar')\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resume with selected lines","suites":["list ui","resume()"],"updatePoint":{"line":110,"column":41},"line":110,"code":"    it('should resume with selected lines', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await ui.selectLines(1, 2)\n      await nvim.call('coc#window#close', [ui.winid])\n      await helper.wait(100)\n      await manager.session.resume()\n      await helper.wait(100)\n      let buf = await nvim.buffer\n      let res = await buf.getSigns({ group: 'coc-list' })\n      expect(res.length).toBe(2)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire action on double click","suites":["list ui","events"],"updatePoint":{"line":134,"column":42},"line":134,"code":"    it('should fire action on double click', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(ui.winid, 1)\n      await manager.session.onMouseEvent('<2-LeftMouse>')\n      await helper.wait(100)\n      expect(lastItem).toBe('foo')\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select clicked line","suites":["list ui","events"],"updatePoint":{"line":146,"column":34},"line":146,"code":"    it('should select clicked line', async () => {\n      labels = ['foo', 'bar']\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(ui.winid, 2)\n      await ui.onMouse('mouseDown')\n      await helper.wait(50)\n      await mockMouse(ui.winid, 2)\n      await ui.onMouse('mouseUp')\n      await helper.wait(50)\n      let item = await ui.item\n      expect(item.label).toBe('bar')\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to original window on click","suites":["list ui","events"],"updatePoint":{"line":162,"column":47},"line":162,"code":"    it('should jump to original window on click', async () => {\n      labels = ['foo', 'bar']\n      let win = await nvim.window\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await mockMouse(win.id, 1)\n      await ui.onMouse('mouseUp')\n      await helper.wait(50)\n      let curr = await nvim.window\n      expect(curr.id).toBe(win.id)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlights items on CursorMoved","suites":["list ui","events"],"updatePoint":{"line":176,"column":46},"line":176,"code":"    it('should highlights items on CursorMoved', async () => {\n      labels = (new Array(400)).fill('a')\n      disposables.push(manager.registerList(new SimpleList(nvim)))\n      await manager.start(['--normal', 'simple'])\n      let ui = manager.session.ui\n      await ui.ready\n      await nvim.call('cursor', [350, 1])\n      await events.fire('CursorMoved', [ui.bufnr, [350, 1]])\n      await helper.wait(100)\n      let res = await nvim.call('coc#highlight#get_highlights', [ui.bufnr, 'list'])\n      expect(res.length).toBeGreaterThan(300)\n    })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render and add highlights","suites":["reversed list"],"updatePoint":{"line":192,"column":38},"line":192,"code":"  it('should render and add highlights', async () => {\n    labels = ['a', 'b', 'c', 'd']\n    disposables.push(manager.registerList(new SimpleList(nvim)))\n    await manager.start(['--reverse', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    let buf = nvim.createBuffer(ui.bufnr)\n    let lines = await buf.lines\n    expect(lines).toEqual(['d', 'c', 'b', 'a'])\n    await helper.listInput('a')\n    await helper.wait(50)\n    lines = await buf.lines\n    expect(lines).toEqual(['a'])\n    let res = await nvim.call('coc#highlight#get_highlights', [ui.bufnr, 'list'])\n    expect(res.length).toBe(2)\n    let win = nvim.createWindow(ui.winid)\n    let height = await win.height\n    expect(height).toBe(1)\n  })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should moveUp and moveDown","suites":["reversed list"],"updatePoint":{"line":212,"column":32},"line":212,"code":"  it('should moveUp and moveDown', async () => {\n    labels = ['a', 'b', 'c', 'd']\n    disposables.push(manager.registerList(new SimpleList(nvim)))\n    await manager.start(['--reverse', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    ui.moveUp()\n    await helper.waitFor('line', ['.'], 3)\n    ui.moveDown()\n    await helper.waitFor('line', ['.'], 4)\n  })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection","suites":["reversed list"],"updatePoint":{"line":224,"column":29},"line":224,"code":"  it('should toggle selection', async () => {\n    labels = ['a', 'b', 'c', 'd']\n    disposables.push(manager.registerList(new SimpleList(nvim)))\n    await manager.start(['--reverse', '--normal', 'simple'])\n    let ui = manager.session.ui\n    await ui.ready\n    await ui.toggleSelection()\n    let items = ui.selectedItems\n    expect(items.length).toBeGreaterThan(0)\n    expect(items[0].label).toBe('a')\n    let lnum = await nvim.call('line', ['.'])\n    expect(lnum).toBe(3)\n    await helper.listInput('j')\n    await ui.toggleSelection()\n    items = ui.selectedItems\n    expect(items.length).toBe(0)\n  })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prepend list items","suites":["reversed list"],"updatePoint":{"line":242,"column":31},"line":242,"code":"  it('should prepend list items', async () => {\n    let o: any\n    let p = new Promise(resolve => {\n      let list: IList = {\n        actions: [{\n          name: 'open',\n          execute: item => {\n            o = item\n          }\n        }],\n        name: 'slow',\n        defaultAction: 'open',\n        loadItems: () => {\n          let task = new SlowTask()\n          task.on('end', () => {\n            resolve(undefined)\n          })\n          return Promise.resolve(task)\n        }\n      }\n      disposables.push(manager.registerList(list))\n      void manager.start(['--reverse', '--normal', 'slow'])\n    })\n    await p\n    await helper.wait(50)\n    let ui = manager.session.ui\n    let buf = nvim.createBuffer(ui.bufnr)\n    let lines = await buf.lines\n    expect(lines).toEqual(['5', '4', '3', '2', '1'])\n    let lnum = await nvim.call('line', ['.'])\n    expect(lnum).toBe(5)\n  })","file":"list/ui.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse input with space","suites":["parseInput"],"updatePoint":{"line":128,"column":35},"line":128,"code":"  it('should parse input with space', async () => {\n    let res = parseInput('a b')\n    expect(res).toEqual(['a', 'b'])\n    res = parseInput('a b ')\n    expect(res).toEqual(['a', 'b'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse input with escaped space","suites":["parseInput"],"updatePoint":{"line":135,"column":43},"line":135,"code":"  it('should parse input with escaped space', async () => {\n    let res = parseInput('a\\\\ b')\n    expect(res).toEqual(['a b'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with long running task","suites":["list worker"],"updatePoint":{"line":143,"column":40},"line":143,"code":"  it('should work with long running task', async () => {\n    disposables.push(manager.registerList(new IntervalTaskList(nvim)))\n    await manager.start(['task'])\n    await manager.session.ui.ready\n    await helper.wait(200)\n    let len = manager.session?.length\n    expect(len > 2).toBe(true)\n    await manager.cancel()\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should sort by sortText","suites":["list worker"],"updatePoint":{"line":153,"column":29},"line":153,"code":"  it('should sort by sortText', async () => {\n    items = [{\n      label: 'abc',\n      sortText: 'b'\n    }, {\n      label: 'ade',\n      sortText: 'a'\n    }]\n    disposables.push(manager.registerList(new DataList(nvim)))\n    await manager.start(['data'])\n    await manager.session.ui.ready\n    await nvim.input('a')\n    await helper.wait(50)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['ade', 'abc'])\n    await manager.cancel()\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show empty line for empty task","suites":["list worker"],"updatePoint":{"line":172,"column":43},"line":172,"code":"  it('should show empty line for empty task', async () => {\n    disposables.push(manager.registerList(new EmptyList(nvim)))\n    await manager.start(['empty'])\n    await manager.session.ui.ready\n    let line = await nvim.call('getline', [1])\n    expect(line).toMatch('No results')\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel task by use CancellationToken","suites":["list worker"],"updatePoint":{"line":180,"column":49},"line":180,"code":"  it('should cancel task by use CancellationToken', async () => {\n    disposables.push(manager.registerList(new IntervalTaskList(nvim)))\n    await manager.start(['task'])\n    expect(manager.session?.worker.isLoading).toBe(true)\n    await helper.wait(100)\n    manager.session?.stop()\n    expect(manager.session?.worker.isLoading).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render slow interactive list","suites":["list worker"],"updatePoint":{"line":189,"column":41},"line":189,"code":"  it('should render slow interactive list', async () => {\n    disposables.push(manager.registerList(new DelayTask(nvim)))\n    await manager.start(['delay'])\n    await nvim.input('a')\n    await helper.wait(600)\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['ahead', 'abort'])\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with interactive list","suites":["list worker"],"updatePoint":{"line":199,"column":39},"line":199,"code":"  it('should work with interactive list', async () => {\n    disposables.push(manager.registerList(new InteractiveList(nvim)))\n    await manager.start(['-I', 'test'])\n    await manager.session?.ui.ready\n    expect(manager.isActivated).toBe(true)\n    await nvim.eval('feedkeys(\"f\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"a\", \"in\")')\n    await helper.wait(100)\n    await nvim.eval('feedkeys(\"x\", \"in\")')\n    await helper.wait(300)\n    let item = await manager.session?.ui.item\n    expect(item.label).toBe('fax')\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not activate on load error","suites":["list worker"],"updatePoint":{"line":214,"column":39},"line":214,"code":"  it('should not activate on load error', async () => {\n    disposables.push(manager.registerList(new ErrorList(nvim)))\n    await manager.start(['test'])\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on task error","suites":["list worker"],"updatePoint":{"line":220,"column":37},"line":220,"code":"  it('should deactivate on task error', async () => {\n    disposables.push(manager.registerList(new ErrorTaskList(nvim)))\n    await manager.start(['task'])\n    await helper.wait(300)\n    expect(manager.isActivated).toBe(false)\n  })","file":"list/worker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights in single line","suites":["getHighlightItems"],"updatePoint":{"line":5,"column":42},"line":5,"code":"  it('should get highlights in single line', async () => {\n    let res = getHighlightItems('this line has highlights', 0, [10, 15])\n    expect(res).toEqual([{\n      colStart: 10,\n      colEnd: 15,\n      lnum: 0,\n      hlGroup: 'CocUnderline'\n    }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights when active end extended","suites":["getHighlightItems"],"updatePoint":{"line":15,"column":52},"line":15,"code":"  it('should get highlights when active end extended', async () => {\n    let res = getHighlightItems('this line', 0, [5, 30])\n    expect(res).toEqual([{\n      colStart: 5,\n      colEnd: 9,\n      lnum: 0,\n      hlGroup: 'CocUnderline'\n    }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights across line","suites":["getHighlightItems"],"updatePoint":{"line":25,"column":39},"line":25,"code":"  it('should get highlights across line', async () => {\n    let res = getHighlightItems('this line\\nhas highlights', 0, [5, 15])\n    expect(res).toEqual([{\n      colStart: 5, colEnd: 9, lnum: 0, hlGroup: 'CocUnderline'\n    }, {\n      colStart: 0, colEnd: 5, lnum: 1, hlGroup: 'CocUnderline'\n    }])\n    res = getHighlightItems('a\\nb\\nc\\nd', 0, [2, 5])\n    expect(res).toEqual([\n      { colStart: 0, colEnd: 1, lnum: 1, hlGroup: 'CocUnderline' },\n      { colStart: 0, colEnd: 1, lnum: 2, hlGroup: 'CocUnderline' },\n      { colStart: 0, colEnd: 0, lnum: 3, hlGroup: 'CocUnderline' }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse code blocks","suites":["parseMarkdown"],"updatePoint":{"line":42,"column":30},"line":42,"code":"  it('should parse code blocks', async () => {\n    let content = `\n\\`\\`\\`js\nvar global = globalThis\n\\`\\`\\`\n\\`\\`\\`ts\nlet str:string\n\\`\\`\\`\n\\`\\`\\`bash\nif\n\\`\\`\\`\n`\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual([\n      'var global = globalThis',\n      '',\n      'let str:string',\n      '',\n      'if'\n    ])\n    expect(res.codes).toEqual([\n      { filetype: 'javascript', startLine: 0, endLine: 1 },\n      { filetype: 'typescript', startLine: 2, endLine: 3 },\n      { filetype: 'sh', startLine: 4, endLine: 5 },\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge empty lines","suites":["parseMarkdown"],"updatePoint":{"line":69,"column":30},"line":69,"code":"  it('should merge empty lines', async () => {\n    let content = `\n![img](http://img.io)\n![img](http://img.io)\n[link](http://example.com)\n[link](javascript:void(0))\n`\n    let res = parseMarkdown(content, { excludeImages: true })\n    expect(res.lines).toEqual([\n      'link',\n      '',\n      'link: http://example.com'\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse html code block","suites":["parseMarkdown"],"updatePoint":{"line":84,"column":34},"line":84,"code":"  it('should parse html code block', async () => {\n    let content = `\nexample:\n\\`\\`\\`html\n<div>code</div>\n\\`\\`\\`\n    `\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['example:', '<div>code</div>'])\n    expect(res.codes).toEqual([{ filetype: 'html', startLine: 1, endLine: 2 }])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should compose empty lines","suites":["parseMarkdown"],"updatePoint":{"line":96,"column":32},"line":96,"code":"  it('should compose empty lines', async () => {\n    let content = 'foo\\n\\n\\nbar\\n\\n\\n'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo', 'bar'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge lines","suites":["parseMarkdown"],"updatePoint":{"line":102,"column":24},"line":102,"code":"  it('should merge lines', async () => {\n    let content = 'first\\nsecond'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['first', 'second'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse ansi highlights","suites":["parseMarkdown"],"updatePoint":{"line":108,"column":34},"line":108,"code":"  it('should parse ansi highlights', async () => {\n    let content = '__foo__\\n[link](link)'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo', 'link'])\n    expect(res.highlights).toEqual([\n      { hlGroup: 'CocBold', lnum: 0, colStart: 0, colEnd: 3 },\n      { hlGroup: 'CocUnderline', lnum: 1, colStart: 0, colEnd: 4 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should exclude images by option","suites":["parseMarkdown"],"updatePoint":{"line":118,"column":37},"line":118,"code":"  it('should exclude images by option', async () => {\n    let content = 'head\\n![img](img)\\ncontent ![img](img) ![img](img)'\n    let res = parseMarkdown(content, { excludeImages: false })\n    expect(res.lines).toEqual(['head', '![img](img)', 'content ![img](img) ![img](img)'])\n    content = 'head\\n![img](img)\\ncontent ![img](img) ![img](img)'\n    res = parseMarkdown(content, { excludeImages: true })\n    expect(res.lines).toEqual(['head', 'content'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render hr","suites":["parseMarkdown"],"updatePoint":{"line":127,"column":22},"line":127,"code":"  it('should render hr', async () => {\n    let content = 'foo\\n***\\nbar'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo', '', 'bar'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render deleted text","suites":["parseMarkdown"],"updatePoint":{"line":133,"column":32},"line":133,"code":"  it('should render deleted text', async () => {\n    let content = '~foo~'\n    let res = parseMarkdown(content, {})\n    expect(res.highlights).toEqual([\n      { hlGroup: 'CocStrikeThrough', lnum: 0, colStart: 0, colEnd: 3 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render br","suites":["parseMarkdown"],"updatePoint":{"line":141,"column":22},"line":141,"code":"  it('should render br', async () => {\n    let content = 'a  \\nb'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['a', 'b'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render code span","suites":["parseMarkdown"],"updatePoint":{"line":147,"column":29},"line":147,"code":"  it('should render code span', async () => {\n    let content = '`foo`'\n    let res = parseMarkdown(content, {})\n    expect(res.highlights).toEqual([\n      { hlGroup: 'CocMarkdownCode', lnum: 0, colStart: 0, colEnd: 3 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render html","suites":["parseMarkdown"],"updatePoint":{"line":155,"column":24},"line":155,"code":"  it('should render html', async () => {\n    let content = '<div>foo</div>'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual(['foo'])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render checkbox","suites":["parseMarkdown"],"updatePoint":{"line":161,"column":28},"line":161,"code":"  it('should render checkbox', async () => {\n    let content = '- [x] first\\n- [ ] second'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual([\n      '  * [X] first', '  * [ ] second'\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render numbered list","suites":["parseMarkdown"],"updatePoint":{"line":169,"column":33},"line":169,"code":"  it('should render numbered list', async () => {\n    let content = '1. one\\n2. two\\n3. three'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual([\n      '  1. one', '  2. two', '  3. three'\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render nested list","suites":["parseMarkdown"],"updatePoint":{"line":177,"column":31},"line":177,"code":"  it('should render nested list', async () => {\n    let content = '- foo\\n- bar\\n    - one\\n    - two'\n    let res = parseMarkdown(content, {})\n    expect(res.lines).toEqual([\n      '  * foo', '  * bar', '    * one', '    * two'\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse documents with diagnostic filetypes","suites":["parseDocuments"],"updatePoint":{"line":187,"column":54},"line":187,"code":"  it('should parse documents with diagnostic filetypes', async () => {\n    let docs = [{\n      filetype: 'Error',\n      content: 'Error text'\n    }, {\n      filetype: 'Warning',\n      content: 'Warning text'\n    }]\n    let res = parseDocuments(docs)\n    expect(res.lines).toEqual([\n      'Error text',\n      '',\n      'Warning text'\n    ])\n    expect(res.codes).toEqual([\n      { hlGroup: 'CocErrorFloat', startLine: 0, endLine: 1 },\n      { hlGroup: 'CocWarningFloat', startLine: 2, endLine: 3 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse markdown document with filetype document","suites":["parseDocuments"],"updatePoint":{"line":207,"column":59},"line":207,"code":"  it('should parse markdown document with filetype document', async () => {\n    let docs = [{\n      filetype: 'typescript',\n      content: 'const workspace'\n    }, {\n      filetype: 'markdown',\n      content: '**header**'\n    }]\n    let res = parseDocuments(docs)\n    expect(res.lines).toEqual([\n      'const workspace',\n      '',\n      'header'\n    ])\n    expect(res.highlights).toEqual([{\n      colEnd: -1,\n      colStart: 0,\n      hlGroup: \"CocFloatDividingLine\",\n      lnum: 1,\n    }, {\n      hlGroup: 'CocBold',\n      lnum: 2,\n      colStart: 0,\n      colEnd: 6\n    }])\n    expect(res.codes).toEqual([\n      { filetype: 'typescript', startLine: 0, endLine: 1 }\n    ])\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse document with highlights","suites":["parseDocuments"],"updatePoint":{"line":237,"column":43},"line":237,"code":"  it('should parse document with highlights', async () => {\n    let docs: Documentation[] = [{\n      filetype: 'txt',\n      content: 'foo'\n    }, {\n      filetype: 'txt',\n      content: 'foo bar',\n      highlights: [{\n        lnum: 0,\n        colStart: 4,\n        colEnd: 7,\n        hlGroup: 'String'\n      }]\n    }]\n    let res = parseDocuments(docs)\n    let { highlights } = res\n    expect(highlights[1]).toEqual({ lnum: 2, colStart: 4, colEnd: 7, hlGroup: 'String' })\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse documents with active highlights","suites":["parseDocuments"],"updatePoint":{"line":256,"column":51},"line":256,"code":"  it('should parse documents with active highlights', async () => {\n    let docs = [{\n      filetype: 'javascript',\n      content: 'func(foo, bar)',\n      active: [5, 8]\n    }, {\n      filetype: 'javascript',\n      content: 'func()',\n      active: [15, 20]\n    }]\n    let res = parseDocuments(docs as any)\n    expect(res.highlights[0]).toEqual({ colStart: 5, colEnd: 8, lnum: 0, hlGroup: 'CocUnderline' })\n  })","file":"markdown/index.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add styles","suites":["styles"],"updatePoint":{"line":17,"column":23},"line":17,"code":"  it('should add styles', async () => {\n    let keys = ['gray', 'magenta', 'bold', 'underline', 'italic', 'strikethrough', 'yellow', 'green', 'blue']\n    for (let key of keys) {\n      let res = styles[key]('text')\n      expect(res).toContain('text')\n    }\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create bold highlights","suites":["Renderer of marked"],"updatePoint":{"line":27,"column":35},"line":27,"code":"  it('should create bold highlights', async () => {\n    let res = parse('**note**.')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 4],\n      hlGroup: 'CocBold'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create italic highlights","suites":["Renderer of marked"],"updatePoint":{"line":35,"column":37},"line":35,"code":"  it('should create italic highlights', async () => {\n    let res = parse('_note_.')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 4],\n      hlGroup: 'CocItalic'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create underline highlights for link","suites":["Renderer of marked"],"updatePoint":{"line":43,"column":49},"line":43,"code":"  it('should create underline highlights for link', async () => {\n    let res = parse('[baidu](https://baidu.com)')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 5],\n      hlGroup: 'CocMarkdownLink'\n    })\n    res = parse('https://baidu.com')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 17],\n      hlGroup: 'CocUnderline'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse link","suites":["Renderer of marked"],"updatePoint":{"line":56,"column":23},"line":56,"code":"  it('should parse link', async () => {\n    // let res = parse('https://doc.rust-lang.org/nightly/core/iter/traits/iterator/Iterator.t.html#map.v')\n    // console.log(JSON.stringify(res, null, 2))\n    let link = 'https://doc.rust-lang.org/nightly/core/iter/traits/iterator/Iterator.t.html#map.v'\n    let parsed = marked(link)\n    let res = parseAnsiHighlights(parsed.split(/\\n/)[0], true)\n    expect(res.line).toEqual(link)\n    expect(res.highlights.length).toBeGreaterThan(0)\n    expect(res.highlights[0].hlGroup).toBe('CocUnderline')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create highlight for code span","suites":["Renderer of marked"],"updatePoint":{"line":67,"column":43},"line":67,"code":"  it('should create highlight for code span', async () => {\n    let res = parse('`let foo = \"bar\"`')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 15],\n      hlGroup: 'CocMarkdownCode'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create header highlights","suites":["Renderer of marked"],"updatePoint":{"line":75,"column":37},"line":75,"code":"  it('should create header highlights', async () => {\n    let res = parse('# header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 6],\n      hlGroup: 'CocMarkdownHeader'\n    })\n    res = parse('## header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 6],\n      hlGroup: 'CocMarkdownHeader'\n    })\n    res = parse('### header')\n    expect(res.highlights[0]).toEqual({\n      span: [0, 6],\n      hlGroup: 'CocMarkdownHeader'\n    })\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent blockquote","suites":["Renderer of marked"],"updatePoint":{"line":93,"column":30},"line":93,"code":"  it('should indent blockquote', async () => {\n    let res = parse('> header')\n    expect(res.line).toBe('  header')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preserve code block","suites":["Renderer of marked"],"updatePoint":{"line":98,"column":32},"line":98,"code":"  it('should preserve code block', async () => {\n    let text = '``` js\\nconsole.log(\"foo\")\\n```'\n    let m = marked(text)\n    expect(m.split('\\n')).toEqual([\n      '``` js',\n      'console.log(\"foo\")',\n      '```',\n      ''\n    ])\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should renderer table","suites":["Renderer of marked"],"updatePoint":{"line":109,"column":27},"line":109,"code":"  it('should renderer table', async () => {\n    let text = `\n| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\n`\n    let res = marked(text)\n    expect(res).toContain('Syntax')\n  })","file":"markdown/renderer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should listen CocInstalled","suites":["attach"],"updatePoint":{"line":28,"column":32},"line":28,"code":"  it('should listen CocInstalled', async () => {\n    nvim.emit('notification', 'VimEnter')\n    await helper.wait(100)\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw on event handler error","suites":["attach"],"updatePoint":{"line":33,"column":45},"line":33,"code":"  it('should not throw on event handler error', async () => {\n    events.on('CursorHold', async () => {\n      throw new Error('error')\n    })\n    let fn = jest.fn()\n    nvim.emit('request', 'CocAutocmd', ['CursorHold'], {\n      send: fn\n    })\n    await wait(100)\n    expect(fn).toBeCalled()\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when plugin method not found","suites":["attach"],"updatePoint":{"line":45,"column":51},"line":45,"code":"  it('should not throw when plugin method not found', async () => {\n    let fn = jest.fn()\n    nvim.emit('request', 'NotExists', [], {\n      send: fn\n    })\n    await wait(100)\n    expect(fn).toBeCalled()\n  })","file":"modules/attach.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match @","suites":["chars keyword option"],"updatePoint":{"line":5,"column":20},"line":5,"code":"  it('should match @', () => {\n    let chars = new Chars('@')\n    expect(chars.isKeywordChar('a')).toBe(true)\n    expect(chars.isKeywordChar('z')).toBe(true)\n    expect(chars.isKeywordChar('A')).toBe(true)\n    expect(chars.isKeywordChar('Z')).toBe(true)\n    expect(chars.isKeywordChar('\\u205f')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match code range","suites":["chars keyword option"],"updatePoint":{"line":14,"column":29},"line":14,"code":"  it('should match code range', () => {\n    let chars = new Chars('48-57')\n    expect(chars.isKeywordChar('0')).toBe(true)\n    expect(chars.isKeywordChar('9')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match @-@","suites":["chars keyword option"],"updatePoint":{"line":20,"column":22},"line":20,"code":"  it('should match @-@', () => {\n    let chars = new Chars('@-@')\n    expect(chars.isKeywordChar('@')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match single code","suites":["chars keyword option"],"updatePoint":{"line":25,"column":30},"line":25,"code":"  it('should match single code', () => {\n    let chars = new Chars('58')\n    expect(chars.isKeywordChar(':')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match single character","suites":["chars keyword option"],"updatePoint":{"line":30,"column":35},"line":30,"code":"  it('should match single character', () => {\n    let chars = new Chars('_')\n    expect(chars.isKeywordChar('_')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add keyword","suites":["chars addKeyword"],"updatePoint":{"line":37,"column":24},"line":37,"code":"  it('should add keyword', () => {\n    let chars = new Chars('_')\n    chars.addKeyword(':')\n    expect(chars.isKeywordChar(':')).toBe(true)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change keyword","suites":["chars change keyword"],"updatePoint":{"line":45,"column":27},"line":45,"code":"  it('should change keyword', () => {\n    let chars = new Chars('_')\n    chars.setKeywordOption(':')\n    expect(chars.isKeywordChar(':')).toBe(true)\n    expect(chars.isKeywordChar('_')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match keywords","suites":["chars match keywords"],"updatePoint":{"line":54,"column":27},"line":54,"code":"  it('should match keywords', async () => {\n    let chars = new Chars('@')\n    let source = new CancellationTokenSource()\n    let res = await chars.matchLines(['foo bar'], 3, source.token)\n    expect(Array.from(res)).toEqual(['foo', 'bar'])\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider unicode character as word","suites":["chars match keywords"],"updatePoint":{"line":61,"column":47},"line":61,"code":"  it('should consider unicode character as word', async () => {\n    let chars = new Chars('@')\n    let res = await chars.matchLines(['black'], 3)\n    expect(Array.from(res)).toEqual(['black'])\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check isKeyword","suites":["chars isKeyword"],"updatePoint":{"line":69,"column":28},"line":69,"code":"  it('should check isKeyword', () => {\n    let chars = new Chars('@')\n    expect(chars.isKeyword('foo')).toBe(true)\n    expect(chars.isKeyword('f@')).toBe(false)\n  })","file":"modules/chars.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when URI is not valid","suites":["ConfigurationProxy"],"updatePoint":{"line":41,"column":44},"line":41,"code":"  it('should not throw when URI is not valid', async () => {\n    let proxy = new ConfigurationProxy({})\n    proxy.modifyConfiguration(undefined, 'foo')\n    proxy.modifyConfiguration(URI.parse('ftp:///f'), 'foo')\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file and parent folder when necessary","suites":["ConfigurationProxy"],"updatePoint":{"line":47,"column":57},"line":47,"code":"  it('should create file and parent folder when necessary', async () => {\n    let folder = path.join(os.tmpdir(), 'a')\n    if (fs.existsSync(folder)) {\n      let isFile = fs.statSync(folder).isFile()\n      if (isFile) {\n        fs.unlinkSync(folder)\n      } else {\n        rmdir(folder)\n      }\n    }\n    let uri = URI.file(path.join(os.tmpdir(), 'a/b/settings.json'))\n    let proxy = new ConfigurationProxy({})\n    proxy.modifyConfiguration(uri, 'foo', true)\n    let content = fs.readFileSync(uri.fsPath, 'utf8')\n    expect(JSON.parse(content)).toEqual({ foo: true })\n    rmdir(folder)\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get folder from resolver","suites":["ConfigurationProxy"],"updatePoint":{"line":65,"column":37},"line":65,"code":"  it('should get folder from resolver', async () => {\n    let proxy = new ConfigurationProxy({\n      getWorkspaceFolder: (uri: string) => {\n        let fsPath = URI.parse(uri).fsPath\n        if (fsPath.startsWith(os.tmpdir())) {\n          return { uri: URI.file(os.tmpdir()).toString(), name: 'tmp' }\n        }\n        if (fsPath.startsWith(os.homedir())) {\n          return { uri: URI.file(os.homedir()).toString(), name: 'home' }\n        }\n        return undefined\n      },\n      root: __dirname\n    })\n    let uri = proxy.getWorkspaceConfig(URI.file(__filename).toString())\n    expect(uri).toBeUndefined()\n    uri = proxy.getWorkspaceConfig(URI.file(path.join(os.tmpdir(), 'foo')).toString())\n    expect(uri.fsPath.startsWith(os.tmpdir())).toBe(true)\n    uri = proxy.getWorkspaceConfig()\n    expect(uri.fsPath.startsWith(__dirname)).toBe(true)\n    uri = proxy.getWorkspaceConfig(URI.file(path.join(os.homedir(), 'tmp')).toString())\n    expect(uri).toBeUndefined()\n    proxy = new ConfigurationProxy({})\n    uri = proxy.getWorkspaceConfig(URI.file(path.join(os.tmpdir(), 'foo')).toString())\n    expect(uri).toBeUndefined()\n    uri = proxy.getWorkspaceConfig()\n    expect(uri).toBeUndefined()\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update and remove configuration option","suites":["ConfigurationProxy"],"updatePoint":{"line":94,"column":51},"line":94,"code":"  it('should update and remove configuration option', async () => {\n    let fsPath = path.join(os.tmpdir(), 'my-settings.json')\n    fs.writeFileSync(fsPath, '{\"foo\": false}')\n    let proxy = new ConfigurationProxy({})\n    proxy.$updateConfigurationOption(ConfigurationTarget.Workspace, 'bar', true, { resource: URI.file(fsPath) })\n\n    let content = fs.readFileSync(fsPath, 'utf8')\n    expect(JSON.parse(content)).toEqual({ foo: false, bar: true })\n    proxy.$removeConfigurationOption(ConfigurationTarget.Workspace, 'bar', { resource: URI.file(fsPath) })\n    content = fs.readFileSync(fsPath, 'utf8')\n    expect(JSON.parse(content)).toEqual({ foo: false })\n    fs.unlinkSync(fsPath)\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only split top level dot keys","suites":["parse configuration"],"updatePoint":{"line":110,"column":42},"line":110,"code":"  it('should only split top level dot keys', () => {\n    let o = { 'x.y': 'foo' }\n    let [, contents] = parseConfiguration(JSON.stringify(o))\n    expect(contents).toEqual({ x: { y: 'foo' } })\n    let schema = { 'my.schema': { 'foo.bar': 1 } }\n    let [, obj] = parseConfiguration(JSON.stringify(schema))\n    expect(obj).toEqual({ my: { schema: { 'foo.bar': 1 } } })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not parse uri properties","suites":["parse configuration"],"updatePoint":{"line":119,"column":37},"line":119,"code":"  it('should not parse uri properties', async () => {\n    let o: any = {\n      foo: {\n        'bar://x': '',\n        'file://y': ''\n      }\n    }\n    let [, contents] = parseConfiguration(JSON.stringify(o))\n    expect(contents).toEqual({\n      foo: {\n        'bar://x': '',\n        'file://y': ''\n      }\n    })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge preperties","suites":["parse configuration"],"updatePoint":{"line":135,"column":29},"line":135,"code":"  it('should merge preperties', async () => {\n    let res = mergeConfigProperties({\n      foo: 'bar',\n      \"x.y.a\": \"x\",\n      \"x.y.b\": \"y\",\n      \"x.t\": \"z\"\n    })\n    expect(res).toEqual({\n      foo: 'bar', x: { y: { a: 'x', b: 'y' }, t: 'z' }\n    })\n  })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a non existing key","suites":["Configurations","utils"],"updatePoint":{"line":150,"column":54},"line":150,"code":"    it('removeFromValueTree: remove a non existing key', () => {\n      let target = { a: { b: 2 } }\n\n      removeFromValueTree(target, 'c')\n\n      assert.deepStrictEqual(target, { a: { b: 2 } })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key from an object that has only sub sections of the key","suites":["Configurations","utils"],"updatePoint":{"line":158,"column":110},"line":158,"code":"    it('removeFromValueTree: remove a multi segmented key from an object that has only sub sections of the key', () => {\n      let target = { a: { b: 2 } }\n\n      removeFromValueTree(target, 'a.b.c')\n\n      assert.deepStrictEqual(target, { a: { b: 2 } })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a single segmented key","suites":["Configurations","utils"],"updatePoint":{"line":166,"column":58},"line":166,"code":"    it('removeFromValueTree: remove a single segmented key', () => {\n      let target = { a: 1 }\n\n      removeFromValueTree(target, 'a')\n\n      assert.deepStrictEqual(target, {})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a single segmented key when its value is undefined","suites":["Configurations","utils"],"updatePoint":{"line":174,"column":86},"line":174,"code":"    it('removeFromValueTree: remove a single segmented key when its value is undefined', () => {\n      let target = { a: undefined }\n\n      removeFromValueTree(target, 'a')\n\n      assert.deepStrictEqual(target, {})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key when its value is undefined","suites":["Configurations","utils"],"updatePoint":{"line":182,"column":85},"line":182,"code":"    it('removeFromValueTree: remove a multi segmented key when its value is undefined', () => {\n      let target = { a: { b: 1 } }\n\n      removeFromValueTree(target, 'a.b')\n\n      assert.deepStrictEqual(target, {})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key when its value is array","suites":["Configurations","utils"],"updatePoint":{"line":190,"column":81},"line":190,"code":"    it('removeFromValueTree: remove a multi segmented key when its value is array', () => {\n      let target = { a: { b: [1] } }\n\n      removeFromValueTree(target, 'a.b')\n\n      assert.deepStrictEqual(target, {})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key first segment value is array","suites":["Configurations","utils"],"updatePoint":{"line":198,"column":86},"line":198,"code":"    it('removeFromValueTree: remove a multi segmented key first segment value is array', () => {\n      let target = { a: [1] }\n\n      removeFromValueTree(target, 'a.0')\n\n      assert.deepStrictEqual(target, { a: [1] })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove when key is the first segment","suites":["Configurations","utils"],"updatePoint":{"line":206,"column":65},"line":206,"code":"    it('removeFromValueTree: remove when key is the first segment', () => {\n      let target = { a: { b: 1 } }\n\n      removeFromValueTree(target, 'a')\n\n      assert.deepStrictEqual(target, {})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key when the first node has more values","suites":["Configurations","utils"],"updatePoint":{"line":214,"column":93},"line":214,"code":"    it('removeFromValueTree: remove a multi segmented key when the first node has more values', () => {\n      let target = { a: { b: { c: 1 }, d: 1 } }\n\n      removeFromValueTree(target, 'a.b.c')\n\n      assert.deepStrictEqual(target, { a: { d: 1 } })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key when in between node has more values","suites":["Configurations","utils"],"updatePoint":{"line":222,"column":94},"line":222,"code":"    it('removeFromValueTree: remove a multi segmented key when in between node has more values', () => {\n      let target = { a: { b: { c: { d: 1 }, d: 1 } } }\n\n      removeFromValueTree(target, 'a.b.c.d')\n\n      assert.deepStrictEqual(target, { a: { b: { d: 1 } } })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"removeFromValueTree: remove a multi segmented key when the last but one node has more values","suites":["Configurations","utils"],"updatePoint":{"line":230,"column":100},"line":230,"code":"    it('removeFromValueTree: remove a multi segmented key when the last but one node has more values', () => {\n      let target = { a: { b: { c: 1, d: 1 } } }\n\n      removeFromValueTree(target, 'a.b.c')\n\n      assert.deepStrictEqual(target, { a: { b: { d: 1 } } })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse content from file","suites":["Configurations","utils"],"updatePoint":{"line":238,"column":38},"line":238,"code":"    it('should parse content from file', async () => {\n      let res = parseContentFromFile('')\n      expect(res).toEqual({ contents: {} })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert errors","suites":["Configurations","utils"],"updatePoint":{"line":243,"column":29},"line":243,"code":"    it('should convert errors', () => {\n      let errors: ParseError[] = []\n      for (let i = 0; i < 17; i++) {\n        errors.push({\n          error: i,\n          offset: 0,\n          length: 10\n        })\n      }\n      let res = convertErrors('file:///1', 'abc', errors)\n      expect(res.length).toBe(17)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all keys","suites":["Configurations","utils"],"updatePoint":{"line":256,"column":27},"line":256,"code":"    it('should get all keys', () => {\n      let res = getKeys({\n        foo: {\n          bar: 1,\n          from: {\n            to: 2\n          }\n        },\n        bar: [1, 2]\n      })\n      expect(res).toEqual(['foo', 'foo.bar', 'foo.from', 'foo.from.to', 'bar'])\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get configuration value","suites":["Configurations","utils"],"updatePoint":{"line":269,"column":38},"line":269,"code":"    it('should get configuration value', () => {\n      let root = {\n        foo: {\n          bar: 1,\n          from: {\n            to: 2\n          }\n        },\n        bar: [1, 2]\n      }\n      let res = getConfigurationValue(root, 'foo.from.to', 1)\n      expect(res).toBe(2)\n      res = getConfigurationValue(root, 'foo.from', 1)\n      expect(res).toEqual({ to: 2 })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get json object","suites":["Configurations","utils"],"updatePoint":{"line":285,"column":30},"line":285,"code":"    it('should get json object', async () => {\n      let obj = [{ x: 1 }, { y: 2 }]\n      expect(toJSONObject(obj)).toEqual(obj)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changed keys #1","suites":["Configurations","utils"],"updatePoint":{"line":290,"column":34},"line":290,"code":"    it('should get changed keys #1', () => {\n      let res = getChangedKeys({ y: 2 }, { x: 1 })\n      expect(res).toEqual(['x', 'y'])\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get changed keys #2","suites":["Configurations","utils"],"updatePoint":{"line":295,"column":34},"line":295,"code":"    it('should get changed keys #2', () => {\n      let res = getChangedKeys({ x: 1, c: { d: 4 } }, { x: 1, b: { x: 5 } })\n      expect(res).toEqual(['b', 'b.x', 'c', 'c.d'])\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse configurations","suites":["Configurations","utils"],"updatePoint":{"line":300,"column":35},"line":300,"code":"    it('should parse configurations', () => {\n      let { contents } = getConfigurationModel()\n      expect(contents.foo.bar).toBe(1)\n      expect(contents.bar.foo).toBe(2)\n      expect(contents.schema).toEqual({ 'https://example.com': '*.yaml' })\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add folder as workspace configuration","suites":["Configurations","addFolderFile()"],"updatePoint":{"line":309,"column":52},"line":309,"code":"    it('should add folder as workspace configuration', () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.onDidChange(e => {\n        let affects = e.affectsConfiguration('coc')\n        expect(affects).toBe(true)\n      })\n      configurations.addFolderFile(workspaceConfigFile)\n      let o = configurations.configuration.workspace.contents\n      expect(o.coc.preferences.rootPath).toBe('./src')\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not add invalid folders","suites":["Configurations","addFolderFile()"],"updatePoint":{"line":321,"column":38},"line":321,"code":"    it('should not add invalid folders', async () => {\n      let configurations = createConfigurations()\n      expect(configurations.addFolderFile('ab')).toBe(false)\n      let configFile = path.join(__dirname, 'settings.json')\n      expect(configurations.addFolderFile(configFile)).toBe(false)\n      configFile = path.join(os.homedir(), '.vim/coc-settings.json')\n      expect(configurations.addFolderFile(configFile)).toBe(false)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve folder configuration when possible","suites":["Configurations","addFolderFile()"],"updatePoint":{"line":330,"column":57},"line":330,"code":"    it('should resolve folder configuration when possible', async () => {\n      let configurations = createConfigurations()\n      expect(configurations.resolveFolderConfigution('test:///foo')).toBeUndefined()\n      expect(configurations.resolveFolderConfigution(URI.file(path.join(os.tmpdir(), 'foo')).toString())).toBeUndefined()\n      let fsPath = path.join(__dirname, `../sample/abc`)\n      expect(configurations.resolveFolderConfigution(URI.file(fsPath).toString())).toBeDefined()\n      fsPath = path.join(__dirname, `../sample/foo`)\n      expect(configurations.resolveFolderConfigution(URI.file(fsPath).toString())).toBeDefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load default configurations","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":342,"column":42},"line":342,"code":"    it('should load default configurations', () => {\n      let conf = new Configurations()\n      disposables.push(conf)\n      expect(conf.defaults.contents.coc).toBeDefined()\n      let c = conf.getConfiguration('languageserver')\n      expect(c).toEqual({})\n      expect(c.has('not_exists')).toBe(false)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should inspect configuration","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":351,"column":36},"line":351,"code":"    it('should inspect configuration', async () => {\n      let conf = new Configurations()\n      let c = conf.getConfiguration('suggest')\n      let res = c.inspect('not_exists')\n      expect(res.defaultValue).toBeUndefined()\n      expect(res.globalValue).toBeUndefined()\n      expect(res.workspaceValue).toBeUndefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update user config #1","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":360,"column":36},"line":360,"code":"    it('should update user config #1', () => {\n      let conf = new Configurations()\n      let fn = jest.fn()\n      conf.onDidChange(e => {\n        expect(e.affectsConfiguration('x')).toBe(true)\n        fn()\n      })\n      conf.updateUserConfig({ x: 1 })\n      let config = conf.configuration.user\n      expect(config.contents).toEqual({ x: 1 })\n      expect(fn).toBeCalled()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update user config #2","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":373,"column":36},"line":373,"code":"    it('should update user config #2', () => {\n      let conf = new Configurations()\n      conf.updateUserConfig({ x: 1 })\n      conf.updateUserConfig({ x: undefined })\n      let config = conf.configuration.user\n      expect(config.contents).toEqual({})\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update workspace config #1","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":381,"column":41},"line":381,"code":"    it('should update workspace config #1', () => {\n      let conf = new Configurations()\n      conf.updateUserConfig({ foo: { bar: 1 } })\n      let curr = conf.getConfiguration('foo')\n      curr.update('bar', 2, false)\n      curr = conf.getConfiguration('foo')\n      let n = curr.get<number>('bar')\n      expect(n).toBe(2)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update workspace config by create workspace folder settings","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":391,"column":74},"line":391,"code":"    it('should update workspace config by create workspace folder settings', async () => {\n      let folder = path.join(os.tmpdir(), 'a')\n      let proxy = new ConfigurationProxy({\n        getWorkspaceFolder: (uri: string) => {\n          let fsPath = URI.parse(uri).fsPath\n          if (fsPath.startsWith(folder)) {\n            return { uri: U(folder), name: 'tmp' }\n          }\n          return undefined\n        },\n        root: __dirname\n      })\n      let conf = new Configurations('', proxy)\n      let fn = jest.fn()\n      let resource = U(path.join(folder, 'foo'))\n      conf.onDidChange(e => {\n        if (e.affectsConfiguration('foo', resource.toString())) {\n          fn()\n        }\n      })\n      global.__TEST__ = false\n      let curr = conf.getConfiguration(undefined, resource)\n      curr.update('foo', true)\n      expect(fn).toBeCalled()\n      let filepath = path.join(folder, '.vim/coc-settings.json')\n      let content = fs.readFileSync(filepath, 'utf8')\n      expect(JSON.parse(content)).toEqual({ foo: true })\n      let res = conf.getConfiguration(undefined, resource)\n      expect(res.foo).toBe(true)\n      curr = conf.getConfiguration(undefined, resource)\n      curr.update('foo', undefined)\n      content = fs.readFileSync(filepath, 'utf8')\n      expect(JSON.parse(content)).toEqual({})\n      rmdir(folder)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle errors","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":427,"column":28},"line":427,"code":"    it('should handle errors', () => {\n      let tmpFile = path.join(os.tmpdir(), uuidv1())\n      fs.writeFileSync(tmpFile, '{\"x\":', 'utf8')\n      let conf = new Configurations(tmpFile)\n      disposables.push(conf)\n      let errors = conf.errorItems\n      expect(errors.length > 1).toBe(true)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change to new folder configuration","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":436,"column":49},"line":436,"code":"    it('should change to new folder configuration', () => {\n      let conf = new Configurations()\n      disposables.push(conf)\n      conf.addFolderFile(workspaceConfigFile)\n      let configFile = path.join(__dirname, './settings.json')\n      conf.addFolderFile(configFile)\n      let file = path.resolve(__dirname, '../sample/tmp.js')\n      let fn = jest.fn()\n      conf.onDidChange(fn)\n      conf.setFolderConfiguration(URI.file(file).toString())\n      let { contents } = conf.workspace\n      expect(contents.foo).toBeUndefined()\n      expect(fn).toBeCalled()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get nested property","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":451,"column":34},"line":451,"code":"    it('should get nested property', () => {\n      let config = createConfigurations()\n      disposables.push(config)\n      let conf = config.getConfiguration('servers.c')\n      let res = conf.get<string>('trace.server', '')\n      expect(res).toBe('verbose')\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get user and workspace configuration","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":459,"column":51},"line":459,"code":"    it('should get user and workspace configuration', () => {\n      let userConfigFile = path.join(__dirname, './settings.json')\n      let configurations = new Configurations(userConfigFile)\n      disposables.push(configurations)\n      let data = configurations.configuration.toData()\n      expect(data.user).toBeDefined()\n      expect(data.workspace).toBeDefined()\n      expect(data.defaults).toBeDefined()\n      let value = configurations.configuration.getValue()\n      expect(value.foo).toBeDefined()\n      expect(value.foo.bar).toBe(1)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should override with new value","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":472,"column":38},"line":472,"code":"    it('should override with new value', () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.configuration.defaults.setValue('foo', 1)\n      let { contents } = configurations.defaults\n      expect(contents.foo).toBe(1)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extends defaults","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":480,"column":31},"line":480,"code":"    it('should extends defaults', () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.extendsDefaults({ 'a.b': 1 })\n      configurations.extendsDefaults({ 'a.b': 2 })\n      let o = configurations.defaults.contents\n      expect(o.a.b).toBe(2)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not extends builtin keys","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":489,"column":39},"line":489,"code":"    it('should not extends builtin keys', async () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.extendsDefaults({ 'npm.binPath': 'cnpm' }, 'test')\n      let o = configurations.defaults.contents\n      expect(o.npm.binPath).toBe('npm')\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update configuration","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":497,"column":35},"line":497,"code":"    it('should update configuration', async () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.addFolderFile(workspaceConfigFile)\n      let fn = jest.fn()\n      configurations.onDidChange(e => {\n        expect(e.affectsConfiguration('foo')).toBe(true)\n        expect(e.affectsConfiguration('foo.bar')).toBe(true)\n        expect(e.affectsConfiguration('foo.bar', 'file://tmp/foo.js')).toBe(false)\n        fn()\n      })\n      let config = configurations.getConfiguration('foo')\n      let o = config.get<number>('bar')\n      expect(o).toBe(1)\n      config.update('bar', 6)\n      config = configurations.getConfiguration('foo')\n      expect(config.get<number>('bar')).toBe(6)\n      expect(fn).toBeCalledTimes(1)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove configuration","suites":["Configurations","getConfiguration()"],"updatePoint":{"line":517,"column":35},"line":517,"code":"    it('should remove configuration', async () => {\n      let configurations = createConfigurations()\n      disposables.push(configurations)\n      configurations.addFolderFile(workspaceConfigFile)\n      let fn = jest.fn()\n      configurations.onDidChange(e => {\n        expect(e.affectsConfiguration('foo')).toBe(true)\n        expect(e.affectsConfiguration('foo.bar')).toBe(true)\n        fn()\n      })\n      let config = configurations.getConfiguration('foo')\n      let o = config.get<number>('bar')\n      expect(o).toBe(1)\n      config.update('bar', null, true)\n      config = configurations.getConfiguration('foo')\n      expect(config.get<any>('bar')).toBeUndefined()\n      expect(fn).toBeCalledTimes(1)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch user config file","suites":["Configurations","watchFile"],"updatePoint":{"line":538,"column":37},"line":538,"code":"    it('should watch user config file', async () => {\n      global.__TEST__ = false\n      let userConfigFile = path.join(os.tmpdir(), 'settings.json')\n      fs.writeFileSync(userConfigFile, '{\"foo.bar\": true}', { encoding: 'utf8' })\n      let conf = new Configurations(userConfigFile)\n      disposables.push(conf)\n      await wait(20)\n      fs.writeFileSync(userConfigFile, '{\"foo.bar\": false}', { encoding: 'utf8' })\n      await helper.waitValue(() => {\n        let c = conf.getConfiguration('foo')\n        return c.get('bar')\n      }, false)\n      fs.unlinkSync(userConfigFile)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch workspace config file","suites":["Configurations","watchFile"],"updatePoint":{"line":553,"column":42},"line":553,"code":"    it('should watch workspace config file', async () => {\n      global.__TEST__ = false\n      let configFile = path.join(os.tmpdir(), '.vim/coc-settings.json')\n      fs.mkdirSync(path.join(os.tmpdir(), '.vim'), { recursive: true })\n      fs.writeFileSync(configFile, '{\"foo.bar\": true}', { encoding: 'utf8' })\n      let conf = new Configurations('', {\n        $updateConfigurationOption: () => {},\n        $removeConfigurationOption: () => {},\n        getWorkspaceConfig: () => {\n          return URI.file(configFile)\n        }\n      })\n      disposables.push(conf)\n      let uri = U(path.join(os.tmpdir(), 'foo'))\n      let resolved = conf.resolveFolderConfigution(uri)\n      conf.setFolderConfiguration(uri)\n      expect(resolved).toBeDefined()\n      await wait(20)\n      fs.writeFileSync(configFile, '{\"foo.bar\": false}', { encoding: 'utf8' })\n      await helper.waitValue(() => {\n        let c = conf.getConfiguration('foo')\n        return c.get('bar')\n      }, false)\n      if (fs.existsSync(configFile)) fs.unlinkSync(configFile)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get folder configuration from uri","suites":["Configurations","getFolderConfiguration()"],"updatePoint":{"line":581,"column":48},"line":581,"code":"    it('should get folder configuration from uri', async () => {\n      let conf = new Configurations()\n      conf.cwd = os.tmpdir()\n      let res = conf.getFolderConfiguration('untitled:///1')\n      expect(res[0]).toBeUndefined()\n      conf = createConfigurations()\n      res = conf.getFolderConfiguration('untitled:///1')\n      expect(res[0]).toBeDefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get folder configuration from file","suites":["Configurations","getFolderConfiguration()"],"updatePoint":{"line":591,"column":49},"line":591,"code":"    it('should get folder configuration from file', async () => {\n      let conf = createConfigurations()\n      let fsPath = path.join(os.tmpdir(), 'a')\n      let res = conf.getFolderConfiguration(U(fsPath))\n      expect(res[0]).toBeUndefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when workspace config not resolved","suites":["Configurations","getFolderConfiguration()"],"updatePoint":{"line":598,"column":59},"line":598,"code":"    it('should not throw when workspace config not resolved', async () => {\n      let userConfigFile = path.join(__dirname, './settings.json')\n      let conf = new Configurations(userConfigFile, {\n        $updateConfigurationOption: () => {},\n        $removeConfigurationOption: () => {},\n        getWorkspaceConfig: () => {\n          return URI.file(userConfigFile)\n        }\n      })\n      let fsPath = path.join(os.tmpdir(), 'a')\n      let c = conf.getConfiguration(undefined, U(fsPath))\n      c.update('foo', false)\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get config uri for undefined resource","suites":["Configurations","getWorkspaceConfigUri()"],"updatePoint":{"line":614,"column":52},"line":614,"code":"    it('should get config uri for undefined resource', async () => {\n      let conf = createConfigurations()\n      let res = conf.getWorkspaceConfigUri()\n      expect(res).toBeDefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not get config uri same as user config","suites":["Configurations","getWorkspaceConfigUri()"],"updatePoint":{"line":620,"column":53},"line":620,"code":"    it('should not get config uri same as user config', async () => {\n      let userConfigFile = path.join(__dirname, './settings.json')\n      let conf = new Configurations(userConfigFile, {\n        $updateConfigurationOption: () => {},\n        $removeConfigurationOption: () => {},\n        getWorkspaceConfig: () => {\n          return URI.file(userConfigFile)\n        }\n      })\n      let uri = U(__filename)\n      let res = conf.getWorkspaceConfigUri(uri)\n      expect(res).toBeUndefined()\n    })","file":"modules/configurations.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check surrond changes","suites":["cursors","surrondChanges()"],"updatePoint":{"line":40,"column":36},"line":40,"code":"    it('should check surrond changes', async () => {\n      expect(surrondChanges([], 0)).toBe(false)\n      expect(surrondChanges([{ offset: 1, add: 'f' }, { offset: 3, add: 'f' }], 0)).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get delta count","suites":["cursors","getDelta()"],"updatePoint":{"line":47,"column":30},"line":47,"code":"    it('should get delta count', async () => {\n      expect(getDelta({ prepend: [1, 'foo'], append: [1, 'bar'] })).toBe(4)\n      expect(getDelta({ offset: 0, remove: 2, insert: 'foo' })).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get surrond change","suites":["cursors","getChange()"],"updatePoint":{"line":54,"column":33},"line":54,"code":"    it('should get surrond change', async () => {\n      const getText = (newText: string): string => {\n        let r = new TextRange(0, 0, 'foo')\n        let res = getChange(r, Range.create(0, 0, 0, 3), newText) as SurrondChange\n        expect(isSurrondChange(res)).toBe(true)\n        r.applySurrondChange(res)\n        return r.text\n      }\n      expect(getText('\"foo\"')).toBe('\"foo\"')\n      expect(getText('o')).toBe('o')\n      expect(getText('')).toBe('')\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get end change","suites":["cursors","getChange()"],"updatePoint":{"line":67,"column":29},"line":67,"code":"    it('should get end change', async () => {\n      const getText = (character: number, newText: string) => {\n        let start = Position.create(0, character)\n        let r = new TextRange(0, 0, 'foo')\n        let res = getChange(r, Range.create(start, r.range.end), newText) as TextChange\n        expect(isTextChange(res)).toBe(true)\n        r.applyTextChange(res)\n        return r.text\n      }\n      expect(getText(3, 'bar')).toBe('foobar')\n      expect(getText(1, '')).toBe('f')\n      expect(getText(2, 'ba')).toBe('foba')\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get normal change","suites":["cursors","getChange()"],"updatePoint":{"line":81,"column":32},"line":81,"code":"    it('should get normal change', async () => {\n      const getText = (start: number, end: number, newText: string) => {\n        let r = new TextRange(0, 0, 'foo')\n        let res = getChange(r, Range.create(0, start, 0, end), newText) as TextChange\n        expect(isTextChange(res)).toBe(true)\n        r.applyTextChange(res)\n        return r.text\n      }\n      expect(getText(0, 0, 'a')).toBe('afoo')\n      expect(getText(0, 1, '')).toBe('oo')\n      expect(getText(0, 2, 'ba')).toBe('bao')\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel cursors session","suites":["cursors","cancel()"],"updatePoint":{"line":96,"column":37},"line":96,"code":"    it('should cancel cursors session', async () => {\n      cursors.cancel(999)\n      let doc = await workspace.document\n      cursors.cancel(doc.bufnr)\n      await nvim.call('setline', [1, ['a', 'b']])\n      await nvim.call('cursor', [1, 1])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'position', 'n')\n      let activated = await cursors.isActivated()\n      expect(activated).toBe(true)\n      cursors.cancel(doc.bufnr)\n      activated = await cursors.isActivated()\n      expect(activated).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw with unsupported kind","suites":["cursors","select()"],"updatePoint":{"line":113,"column":42},"line":113,"code":"    it('should throw with unsupported kind', async () => {\n      let doc = await workspace.document\n      let fn = async () => {\n        await cursors.select(doc.bufnr, 'undefined', 'n')\n      }\n      await expect(fn()).rejects.toThrow(/not supported/)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by position","suites":["cursors","select()"],"updatePoint":{"line":121,"column":33},"line":121,"code":"    it('should select by position', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['a', 'b']])\n      await nvim.call('cursor', [1, 1])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'position', 'n')\n      await helper.wait(30)\n      let n = await rangeCount()\n      expect(n).toBe(1)\n      await nvim.setOption('virtualedit', 'onemore')\n      await nvim.call('cursor', [2, 2])\n      await cursors.select(doc.bufnr, 'position', 'n')\n      n = await rangeCount()\n      expect(n).toBe(2)\n      await cursors.select(doc.bufnr, 'position', 'n')\n      n = await rangeCount()\n      expect(n).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by word","suites":["cursors","select()"],"updatePoint":{"line":140,"column":29},"line":140,"code":"    it('should select by word', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['foo', 'bar']])\n      await nvim.call('cursor', [1, 1])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'word', 'n')\n      let n = await rangeCount()\n      expect(n).toBe(1)\n      await nvim.call('cursor', [2, 2])\n      await cursors.select(doc.bufnr, 'word', 'n')\n      n = await rangeCount()\n      expect(n).toBe(2)\n      await cursors.select(doc.bufnr, 'word', 'n')\n      n = await rangeCount()\n      expect(n).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle select","suites":["cursors","select()"],"updatePoint":{"line":157,"column":28},"line":157,"code":"    it('should toggle select', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['foo', 'bar']])\n      await nvim.call('cursor', [1, 1])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'word', 'n')\n      let n = await rangeCount()\n      expect(n).toBe(1)\n      await cursors.select(doc.bufnr, 'word', 'n')\n      n = await rangeCount()\n      expect(n).toBe(0)\n      let activated = await doc.buffer.getVar('coc_cursors_activated')\n      expect(activated).toBe(0)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select last character","suites":["cursors","select()"],"updatePoint":{"line":172,"column":36},"line":172,"code":"    it('should select last character', async () => {\n      let doc = await workspace.document\n      await nvim.setOption('virtualedit', 'onemore')\n      await nvim.call('setline', [1, ['}', '{']])\n      await nvim.call('cursor', [1, 2])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'word', 'n')\n      let n = await rangeCount()\n      expect(n).toBe(1)\n      await nvim.call('cursor', [2, 1])\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'word', 'n')\n      n = await rangeCount()\n      expect(n).toBe(2)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by visual range","suites":["cursors","select()"],"updatePoint":{"line":188,"column":37},"line":188,"code":"    it('should select by visual range', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['\"foo\"', '\"bar\"']])\n      await nvim.call('cursor', [1, 1])\n      await nvim.command('normal! vE')\n      await doc.synchronize()\n      await cursors.select(doc.bufnr, 'range', 'v')\n      let n = await rangeCount()\n      expect(n).toBe(1)\n      await nvim.call('cursor', [2, 1])\n      await nvim.command('normal! vE')\n      await cursors.select(doc.bufnr, 'range', 'v')\n      n = await rangeCount()\n      expect(n).toBe(2)\n      await cursors.select(doc.bufnr, 'range', 'v')\n      n = await rangeCount()\n      expect(n).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select visual blocks","suites":["cursors","select()"],"updatePoint":{"line":207,"column":35},"line":207,"code":"    it('should select visual blocks', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['let x = \"foo\"', 'let y = \"bar\"']])\n      await doc.synchronize()\n      await nvim.call('cursor', [1, 1])\n      await nvim.input('<C-v>')\n      await nvim.input('je')\n      await cursors.select(doc.bufnr, 'range', '\\x16')\n      let n = await rangeCount()\n      expect(n).toBe(2)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by operator","suites":["cursors","select()"],"updatePoint":{"line":219,"column":33},"line":219,"code":"    it('should select by operator', async () => {\n      await nvim.command('nmap x  <Plug>(coc-cursors-operator)')\n      await nvim.call('setline', [1, ['\"short\"', '\"long\"']])\n      await nvim.call('cursor', [1, 2])\n      await nvim.input('xa\"')\n      await helper.wait(30)\n      await nvim.call('cursor', [2, 2])\n      await nvim.input('xa\"')\n      await helper.wait(30)\n      await nvim.command('nunmap x')\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add ranges","suites":["cursors","addRanges()"],"updatePoint":{"line":233,"column":25},"line":233,"code":"    it('should add ranges', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['foo foo foo', 'bar bar']])\n      await doc.synchronize()\n      let ranges = [\n        Range.create(0, 0, 0, 3),\n        Range.create(0, 4, 0, 7),\n        Range.create(0, 8, 0, 11),\n        Range.create(1, 0, 1, 3),\n        Range.create(1, 4, 1, 7)\n      ]\n      await cursors.addRanges(ranges)\n      let n = await rangeCount()\n      expect(n).toBe(5)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check valid change","suites":["cursors","validChange()"],"updatePoint":{"line":251,"column":33},"line":251,"code":"    it('should check valid change', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['foo', 'foo', '']])\n      await doc.synchronize()\n      let ranges = [\n        Range.create(0, 0, 0, 3),\n        Range.create(1, 0, 1, 3),\n      ]\n      await cursors.addRanges(ranges)\n      let session = cursors.getSession(doc.bufnr)\n      expect(session.validChange(Range.create(0, 0, 1, 0), '')).toBe(false)\n      expect(session.validChange(Range.create(0, 0, 2, 0), '\\n\\n')).toBe(false)\n      expect(session.validChange(Range.create(1, 0, 1, 3), 'bar')).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust on text insert","suites":["cursors","onChange()"],"updatePoint":{"line":305,"column":36},"line":305,"code":"    it('should adjust on text insert', async () => {\n      await assertEdits([edit(0, 0, 0, 0, 'bar\\n')], [0, 3, 4, 7, 8, 11])\n      await assertEdits([edit(0, 0, 0, 0, 'b')], [0, 4, 5, 9, 10, 14], 'bfoo bfoo bfoo')\n      await assertEdits([edit(0, 1, 0, 1, 'b')], [0, 4, 5, 9, 10, 14], 'fboo fboo fboo')\n      await assertEdits([edit(0, 3, 0, 3, 'b')], [0, 4, 5, 9, 10, 14], 'foob foob foob')\n      await assertEdits([edit(0, 3, 0, 4, '\\n')], [0, 3, 0, 3, 4, 7], 'foo')\n      await assertEdits([edit(1, 0, 1, 0, 'bar')], [0, 3, 4, 7, 8, 11])\n      await nvim.call('setline', [1, ['foo foo foo', '']])\n      await nvim.call('cursor', [1, 4])\n      await assertEdits([edit(0, 8, 0, 8, 'b')], [0, 4, 5, 9, 10, 14], 'bfoo bfoo bfoo')\n      let col = await nvim.call('col', ['.'])\n      expect(col).toBe(5)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust on text detete","suites":["cursors","onChange()"],"updatePoint":{"line":319,"column":36},"line":319,"code":"    it('should adjust on text detete', async () => {\n      await assertEdits([edit(0, 2, 0, 3, '')], [0, 2, 3, 5, 6, 8], 'fo fo fo')\n      await assertEdits([edit(0, 3, 0, 4, '')], [0, 3, 3, 6, 7, 10], 'foofoo foo')\n      await assertEdits([edit(0, 4, 0, 7, '')], [0, 0, 1, 1, 2, 2], '  ')\n      await nvim.setLine('foo foo')\n      await nvim.call('cursor', [1, 4])\n      await assertEdits([edit(0, 3, 0, 7, '')], [0, 3, 4, 7], 'foo foo')\n      await assertEdits([edit(0, 1, 0, 11, '')], [], 'f')\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust on text change","suites":["cursors","onChange()"],"updatePoint":{"line":329,"column":36},"line":329,"code":"    it('should adjust on text change', async () => {\n      await assertEdits([edit(0, 0, 0, 0, '\"'), edit(0, 3, 0, 3, '\"')], [0, 5, 6, 11, 12, 17], '\"foo\" \"foo\" \"foo\"')\n      await assertEdits([edit(0, 0, 0, 1, 'b')], [0, 3, 4, 7, 8, 11], 'boo boo boo')\n      await assertEdits([edit(0, 0, 0, 3, 'ba')], [0, 2, 3, 5, 6, 8], 'ba ba ba')\n      await nvim.call('setline', [1, ['', '']])\n      await nvim.call('cursor', [2, 1])\n      await assertEdits([edit(0, 4, 0, 5, 'ba')], [0, 4, 5, 9, 10, 14], 'baoo baoo baoo')\n      let col = await nvim.call('col', ['.'])\n      expect(col).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust on undo & redo","suites":["cursors","onChange()"],"updatePoint":{"line":340,"column":36},"line":340,"code":"    it('should adjust on undo & redo', async () => {\n      let doc = await workspace.document\n      let edits = [edit(0, 0, 0, 0, '\"'), edit(0, 3, 0, 3, '\"')]\n      await nvim.call('setline', [1, ['foo foo foo', '']])\n      await doc.synchronize()\n      let ranges = [\n        Range.create(0, 0, 0, 3),\n        Range.create(0, 4, 0, 7),\n        Range.create(0, 8, 0, 11),\n      ]\n      await cursors.addRanges(ranges)\n      session = cursors.getSession(doc.bufnr)\n      let p = new Promise(resolve => {\n        let disposable = session.onDidUpdate(() => {\n          disposable.dispose()\n          resolve(undefined)\n        })\n        void doc.applyEdits(edits)\n      })\n      await p\n      await nvim.command('undo')\n      await helper.wait(50)\n      expect(session.currentRanges).toEqual(ranges)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should highlight on empty content change","suites":["cursors","onChange()"],"updatePoint":{"line":365,"column":48},"line":365,"code":"    it('should highlight on empty content change', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['foo', '']])\n      await doc.synchronize()\n      let ranges = [Range.create(0, 0, 0, 3)]\n      await cursors.addRanges(ranges)\n      session = cursors.getSession(doc.bufnr)\n      await nvim.call('setline', [1, ['foo', '']])\n      await doc.synchronize()\n      let c = await rangeCount()\n      expect(c).toBe(1)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check change before first range","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":393,"column":46},"line":393,"code":"    it('should check change before first range', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['abc foob foob', 'foob'])\n      expect(res).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check change of first range","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":400,"column":42},"line":400,"code":"    it('should check change of first range', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foo foob', 'foob'])\n      expect(res).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check delete exceed range","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":407,"column":40},"line":407,"code":"    it('should check delete exceed range', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fofoo', 'foo'])\n      expect(res).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content prepend","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":414,"column":36},"line":414,"code":"    it('should check content prepend', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar bfoo bfoo', 'bfoo'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 8),\n        Range.create(0, 9, 0, 13),\n        Range.create(1, 0, 1, 4),\n      ])\n      s = await setup()\n      doc = await workspace.document\n      res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar bfoo bfoo', 'xfoo'])\n      expect(res).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content insert","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":430,"column":35},"line":430,"code":"    it('should check content insert', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fboo fboo', 'fboo'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 8),\n        Range.create(0, 9, 0, 13),\n        Range.create(1, 0, 1, 4),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content append","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":442,"column":35},"line":442,"code":"    it('should check content append', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foob foob', 'foob'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 8),\n        Range.create(0, 9, 0, 13),\n        Range.create(1, 0, 1, 4),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content detete #1","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":454,"column":38},"line":454,"code":"    it('should check content detete #1', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar oo oo', 'oo'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 6),\n        Range.create(0, 7, 0, 9),\n        Range.create(1, 0, 1, 2),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content delete #2","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":466,"column":38},"line":466,"code":"    it('should check content delete #2', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar  ', ''])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 4),\n        Range.create(0, 5, 0, 5),\n        Range.create(1, 0, 1, 0),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content delete #3","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":478,"column":38},"line":478,"code":"    it('should check content delete #3', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fo fo', 'fo'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 6),\n        Range.create(0, 7, 0, 9),\n        Range.create(1, 0, 1, 2),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content change #1","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":490,"column":38},"line":490,"code":"    it('should check content change #1', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fa fa', 'fa'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 6),\n        Range.create(0, 7, 0, 9),\n        Range.create(1, 0, 1, 2),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content change #1","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":502,"column":38},"line":502,"code":"    it('should check content change #1', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar fa fa', 'fa'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 6),\n        Range.create(0, 7, 0, 9),\n        Range.create(1, 0, 1, 2),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content change #2","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":514,"column":38},"line":514,"code":"    it('should check content change #2', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar ab ab', 'ab'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 6),\n        Range.create(0, 7, 0, 9),\n        Range.create(1, 0, 1, 2),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content change #3","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":526,"column":38},"line":526,"code":"    it('should check content change #3', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar xfa xfa', 'xfa'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 7),\n        Range.create(0, 8, 0, 11),\n        Range.create(1, 0, 1, 3),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content change #4","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":538,"column":38},"line":538,"code":"    it('should check content change #4', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar xfao xfao', 'xfao'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 8),\n        Range.create(0, 9, 0, 13),\n        Range.create(1, 0, 1, 4),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check surrond add","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":550,"column":32},"line":550,"code":"    it('should check surrond add', async () => {\n      let s = await setup()\n      let doc = await workspace.document\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar \"foo\" \"foo\"', '\"foo\"'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 9),\n        Range.create(0, 10, 0, 15),\n        Range.create(1, 0, 1, 5),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check surrond remove","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":562,"column":35},"line":562,"code":"    it('should check surrond remove', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['bar \"foo\" \"foo\"', '\"foo\"']])\n      await doc.synchronize()\n      let s = cursors.createSession(doc)\n      s.addRanges([\n        Range.create(0, 4, 0, 9),\n        Range.create(0, 10, 0, 15),\n        Range.create(1, 0, 1, 5),\n      ])\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), ['bar foo foo', 'foo'])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 7),\n        Range.create(0, 8, 0, 11),\n        Range.create(1, 0, 1, 3),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check surrond change","suites":["cursors","applyComposedEdit()"],"updatePoint":{"line":581,"column":35},"line":581,"code":"    it('should check surrond change', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['bar \"foo\" \"foo\"', '\"foo\"']])\n      await doc.synchronize()\n      let s = cursors.createSession(doc)\n      s.addRanges([\n        Range.create(0, 4, 0, 9),\n        Range.create(0, 10, 0, 15),\n        Range.create(1, 0, 1, 5),\n      ])\n      let res = s.applyComposedEdit(doc.textDocument.lines.slice(), [`bar 'foo' 'foo'`, `'foo'`])\n      expect(res).toBe(true)\n      expect(s.currentRanges).toEqual([\n        Range.create(0, 4, 0, 9),\n        Range.create(0, 10, 0, 15),\n        Range.create(1, 0, 1, 5),\n      ])\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup cancel keymap","suites":["cursors","key mappings"],"updatePoint":{"line":620,"column":34},"line":620,"code":"    it('should setup cancel keymap', async () => {\n      await setup()\n      let count = await rangeCount()\n      expect(count).toBe(3)\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      count = await rangeCount()\n      expect(count).toBe(0)\n      let has = await hasKeymap('<Esc>')\n      expect(has).toBe(false)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should next key wrapscan","suites":["cursors","key mappings"],"updatePoint":{"line":632,"column":32},"line":632,"code":"    it('should next key wrapscan', async () => {\n      await setup()\n      await nvim.call('cursor', [1, 1])\n      const next = async (line: number, character: number) => {\n        await nvim.input('<C-n>')\n        await helper.wait(30)\n        let cursor = await nvim.call('coc#cursor#position')\n        expect(cursor).toEqual([line, character])\n      }\n      await next(1, 0)\n      await next(2, 0)\n      await next(0, 0)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should previous key wrapscan","suites":["cursors","key mappings"],"updatePoint":{"line":646,"column":36},"line":646,"code":"    it('should previous key wrapscan', async () => {\n      await setup()\n      await nvim.call('cursor', [3, 1])\n      const prev = async (line: number, character: number) => {\n        await nvim.input('<C-p>')\n        await helper.wait(30)\n        let cursor = await nvim.call('coc#cursor#position')\n        expect(cursor).toEqual([line, character])\n      }\n      await prev(1, 0)\n      await prev(0, 0)\n      await prev(2, 0)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should next key no wrapscan","suites":["cursors","key mappings"],"updatePoint":{"line":660,"column":35},"line":660,"code":"    it('should next key no wrapscan', async () => {\n      helper.updateConfiguration('cursors.wrapscan', false)\n      await setup()\n      await nvim.call('cursor', [3, 1])\n      const next = async (line: number, character: number) => {\n        await nvim.input('<C-n>')\n        await helper.wait(50)\n        let cursor = await nvim.call('coc#cursor#position')\n        expect(cursor).toEqual([line, character])\n      }\n      await next(2, 0)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should previous key no wrapscan","suites":["cursors","key mappings"],"updatePoint":{"line":673,"column":39},"line":673,"code":"    it('should previous key no wrapscan', async () => {\n      helper.updateConfiguration('cursors.wrapscan', false)\n      await setup()\n      await nvim.call('cursor', [1, 1])\n      const prev = async (line: number, character: number) => {\n        await nvim.input('<C-p>')\n        await helper.wait(30)\n        let cursor = await nvim.call('coc#cursor#position')\n        expect(cursor).toEqual([line, character])\n      }\n      await prev(0, 0)\n    })","file":"modules/cursors.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.exists()","suites":["DB"],"updatePoint":{"line":19,"column":19},"line":19,"code":"  test('db.exists()', async () => {\n    let exists = db.exists('a.b')\n    expect(exists).toBe(false)\n    db.push('a.b', { foo: 1 })\n    exists = db.exists('a.b.foo')\n    expect(exists).toBe(true)\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.fetch()","suites":["DB"],"updatePoint":{"line":27,"column":18},"line":27,"code":"  test('db.fetch()', async () => {\n    let res = await db.fetch('x')\n    expect(res).toBeUndefined()\n    db.push('x', 1)\n    res = await db.fetch('x')\n    expect(res).toBe(1)\n    db.push('x', { foo: 1 })\n    res = await db.fetch('x')\n    expect(res).toEqual({ foo: 1 })\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.delete()","suites":["DB"],"updatePoint":{"line":38,"column":19},"line":38,"code":"  test('db.delete()', async () => {\n    db.push('foo.bar', 1)\n    db.delete('foo.bar')\n    let exists = db.exists('foo.bar')\n    expect(exists).toBe(false)\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"db.push()","suites":["DB"],"updatePoint":{"line":45,"column":17},"line":45,"code":"  test('db.push()', async () => {\n    db.push('foo.x', 1)\n    db.push('foo.y', '2')\n    db.push('foo.z', true)\n    db.push('foo.n', null)\n    db.push('foo.o', { x: 1 })\n    let res = db.fetch('foo')\n    expect(res).toEqual({\n      x: 1,\n      y: '2',\n      z: true,\n      n: null,\n      o: { x: 1 }\n    })\n  })","file":"modules/db.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add signs","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":65,"column":24},"line":65,"code":"    it('should add signs', async () => {\n      let diagnostics = [createDiagnostic('foo'), createDiagnostic('bar')]\n      let buf = await createDiagnosticBuffer()\n      buf.addSigns('a', diagnostics)\n      await helper.wait(30)\n      let res = await nvim.call('sign_getplaced', [buf.bufnr, { group: 'CocDiagnostica' }])\n      let signs = res[0].signs\n      expect(signs).toBeDefined()\n      expect(signs[0].name).toBe('CocError')\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter sign by signLevel","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":76,"column":39},"line":76,"code":"    it('should filter sign by signLevel', async () => {\n      config.signLevel = DiagnosticSeverity.Error\n      let range = Range.create(0, 0, 0, 3)\n      let diagnostics = [createDiagnostic('foo', range, DiagnosticSeverity.Warning), createDiagnostic('bar', range, DiagnosticSeverity.Warning)]\n      let buf = await createDiagnosticBuffer()\n      buf.addSigns('a', diagnostics)\n      await helper.wait(30)\n      let res = await nvim.call('sign_getplaced', [buf.bufnr, { group: 'CocDiagnostica' }])\n      config.signLevel = undefined\n      let signs = res[0].signs\n      expect(signs).toBeDefined()\n      expect(signs.length).toBe(0)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostic info","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":90,"column":34},"line":90,"code":"    it('should set diagnostic info', async () => {\n      let r = Range.create(0, 1, 0, 2)\n      let diagnostics = [\n        createDiagnostic('foo', r, DiagnosticSeverity.Error),\n        createDiagnostic('bar', r, DiagnosticSeverity.Warning),\n        createDiagnostic('foo', r, DiagnosticSeverity.Hint),\n        createDiagnostic('bar', r, DiagnosticSeverity.Information)\n      ]\n      let buf = await createDiagnosticBuffer()\n      await buf.update('', diagnostics)\n      let buffer = await nvim.buffer\n      let res = await buffer.getVar('coc_diagnostic_info')\n      expect(res).toEqual({\n        lnums: [1, 1, 1, 1],\n        information: 1,\n        hint: 1,\n        warning: 1,\n        error: 1\n      })\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlight","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":111,"column":28},"line":111,"code":"    it('should add highlight', async () => {\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.setLine('abc')\n      await doc.patchChange(true)\n      nvim.pauseNotification()\n      buf.updateHighlights('', [\n        createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Error),\n        createDiagnostic('bar', Range.create(0, 0, 0, 1), DiagnosticSeverity.Warning)\n      ])\n      await nvim.resumeNotification()\n      let markers = await helper.getExtmarkers(buf.bufnr, ns)\n      expect(markers).toEqual([\n        [0, 0, 0, 1, 'CocWarningHighlight'],\n        [0, 0, 0, 1, 'CocErrorHighlight']\n      ])\n      nvim.pauseNotification()\n      buf.updateHighlights('', [])\n      await nvim.resumeNotification()\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any[]\n      expect(res.length).toBe(0)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add deprecated highlight","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":134,"column":39},"line":134,"code":"    it('should add deprecated highlight', async () => {\n      let diagnostic = createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Information, [DiagnosticTag.Deprecated])\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.setLine('foo')\n      await doc.patchChange(true)\n      nvim.pauseNotification()\n      buf.updateHighlights('', [diagnostic])\n      await nvim.resumeNotification()\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, {}]) as [number, number, number][]\n      expect(res.length).toBe(1)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not refresh for empty diagnostics","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":147,"column":48},"line":147,"code":"    it('should not refresh for empty diagnostics', async () => {\n      let buf: any = await createDiagnosticBuffer()\n      let fn = jest.fn()\n      buf.refresh = () => {\n        fn()\n      }\n      buf.update('c', [])\n      expect(fn).toBeCalledTimes(0)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh when content changes is empty","suites":["diagnostic buffer","refresh()"],"updatePoint":{"line":157,"column":52},"line":157,"code":"    it('should refresh when content changes is empty', async () => {\n      let diagnostic = createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Error)\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(buf.bufnr)\n      await nvim.setLine('foo')\n      doc._forceSync()\n      nvim.pauseNotification()\n      buf.updateHighlights('', [diagnostic])\n      await nvim.resumeNotification()\n      await nvim.setLine('foo')\n      await doc.patchChange(true)\n      doc._forceSync()\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show virtual text on current line","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":186,"column":48},"line":186,"code":"    it('should show virtual text on current line', async () => {\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.update('', diagnostics)\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n      let texts = res[0][3].virt_text\n      expect(texts[0]).toEqual([' foo', 'CocErrorVirtualText'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show virtual text at window column","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":198,"column":49},"line":198,"code":"    it('should show virtual text at window column', async () => {\n      config.virtualTextWinCol = 90\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.update('', diagnostics)\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n      let texts = res[0][3].virt_text\n      expect(texts[0]).toEqual([' foo', 'CocErrorVirtualText'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should virtual text on all lines","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":211,"column":40},"line":211,"code":"    it('should virtual text on all lines', async () => {\n      config.virtualTextCurrentLineOnly = false\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [\n        createDiagnostic('foo', Range.create(0, 0, 0, 1)),\n        createDiagnostic('bar', Range.create(1, 0, 1, 1)),\n      ]\n      await buf.update('', diagnostics)\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(2)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by virtualTextLevel","suites":["diagnostic buffer","showVirtualText()"],"updatePoint":{"line":224,"column":41},"line":224,"code":"    it('should filter by virtualTextLevel', async () => {\n      config.virtualTextLevel = DiagnosticSeverity.Error\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [\n        createDiagnostic('foo', Range.create(0, 0, 0, 1), DiagnosticSeverity.Error),\n        createDiagnostic('bar', Range.create(1, 0, 1, 1), DiagnosticSeverity.Warning),\n      ]\n      await buf.update('', diagnostics)\n      let ns = config.virtualTextSrcId\n      let res = await nvim.call('nvim_buf_get_extmarks', [buf.bufnr, ns, 0, -1, { details: true }]) as any\n      expect(res.length).toBe(1)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update location list","suites":["diagnostic buffer","updateLocationList()"],"updatePoint":{"line":246,"column":35},"line":246,"code":"    it('should update location list', async () => {\n      let buf = await createDiagnosticBuffer()\n      await nvim.call('setloclist', [0, [], 'r', { title: 'Diagnostics of coc', items: [] }])\n      await buf.update('a', [createDiagnostic('foo')])\n      let res = await nvim.eval(`getloclist(bufwinid(${buf.bufnr}))`) as any[]\n      expect(res.length).toBe(1)\n      expect(res[0].text).toBe('[test 999] foo [E]')\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear all diagnostics","suites":["diagnostic buffer","clear()"],"updatePoint":{"line":265,"column":36},"line":265,"code":"    it('should clear all diagnostics', async () => {\n      let diagnostic = createDiagnostic('foo')\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [diagnostic]\n      await buf.update('', diagnostics)\n      await helper.wait(50)\n      buf.clear()\n      await helper.wait(50)\n      let buffer = await nvim.buffer\n      let res = await buffer.getVar(\"coc_diagnostic_info\")\n      expect(res == null).toBe(true)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return false when buffer disposed","suites":["diagnostic buffer","isEnabled()"],"updatePoint":{"line":280,"column":48},"line":280,"code":"    it('should return false when buffer disposed', async () => {\n      let buf = await createDiagnosticBuffer()\n      await nvim.command(`bd! ${buf.bufnr}`)\n      buf.dispose()\n      let res = await buf.isEnabled()\n      expect(res).toBe(false)\n      let arr = buf.getHighlightItems([])\n      expect(arr.length).toBe(0)\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get highlights","suites":["diagnostic buffer","getHighlightItems()"],"updatePoint":{"line":292,"column":29},"line":292,"code":"    it('should get highlights', async () => {\n      let buf = await createDiagnosticBuffer()\n      let doc = workspace.getDocument(workspace.bufnr)\n      await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo\\nbar')])\n      let diagnostics = [\n        createDiagnostic('one', Range.create(0, 0, 0, 1), DiagnosticSeverity.Warning),\n        createDiagnostic('one', Range.create(0, 1, 0, 2), DiagnosticSeverity.Warning),\n        createDiagnostic('two', Range.create(0, 0, 2, 3), DiagnosticSeverity.Error),\n        createDiagnostic('three', Range.create(1, 0, 1, 2), DiagnosticSeverity.Hint),\n      ]\n      diagnostics[0].tags = [DiagnosticTag.Unnecessary]\n      diagnostics[1].tags = [DiagnosticTag.Deprecated]\n      let res = buf.getHighlightItems(diagnostics)\n      expect(res.length).toBe(5)\n      expect(res.map(o => o.hlGroup)).toEqual([\n        'CocUnusedHighlight',\n        'CocErrorHighlight',\n        'CocDeprecatedHighlight',\n        'CocHintHighlight',\n        'CocErrorHighlight'\n      ])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sorted diagnostics","suites":["diagnostic buffer","getDiagnostics()"],"updatePoint":{"line":317,"column":37},"line":317,"code":"    it('should get sorted diagnostics', async () => {\n      let buf = await createDiagnosticBuffer()\n      let diagnostics = [\n        createDiagnostic('three', Range.create(0, 1, 0, 2), DiagnosticSeverity.Error),\n        createDiagnostic('one', Range.create(0, 0, 0, 2), DiagnosticSeverity.Warning),\n        createDiagnostic('two', Range.create(0, 0, 0, 2), DiagnosticSeverity.Error),\n      ]\n      diagnostics[0].tags = [DiagnosticTag.Unnecessary]\n      await buf.reset({\n        x: diagnostics,\n        y: [createDiagnostic('four', Range.create(0, 0, 0, 2), DiagnosticSeverity.Error)]\n      })\n      let res = buf.getDiagnosticsAt(Position.create(0, 1), false)\n      let arr = res.map(o => o.message)\n      expect(arr).toEqual(['four', 'two', 'three', 'one'])\n    })","file":"modules/diagnosticBuffer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create collection","suites":["diagnostic collection"],"updatePoint":{"line":11,"column":30},"line":11,"code":"  it('should create collection', () => {\n    let collection = new DiagnosticCollection('test')\n    expect(collection.name).toBe('test')\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostic with uri","suites":["diagnostic collection"],"updatePoint":{"line":16,"column":36},"line":16,"code":"  it('should set diagnostic with uri', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    expect(collection.get(uri).length).toBe(1)\n    collection.set(uri, [])\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear diagnostics with null as diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":26,"column":55},"line":26,"code":"  it('should clear diagnostics with null as diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    expect(collection.get(uri).length).toBe(1)\n    collection.set(uri, null)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear diagnostics with undefined as diagnostics in entries","suites":["diagnostic collection"],"updatePoint":{"line":36,"column":71},"line":36,"code":"  it('should clear diagnostics with undefined as diagnostics in entries', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let entries: [string, Diagnostic[] | null][] = [\n      ['file:1', [diagnostic]],\n      ['file:1', undefined]\n    ]\n    let uri = 'file:///1'\n    collection.set(entries)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set diagnostics with entries","suites":["diagnostic collection"],"updatePoint":{"line":48,"column":41},"line":48,"code":"  it('should set diagnostics with entries', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    let other = 'file:///2'\n    let entries: [string, Diagnostic[]][] = [\n      [uri, [diagnostic]],\n      [other, [diagnostic]],\n      [uri, [createDiagnostic('other')]]\n    ]\n    collection.set(entries)\n    expect(collection.get(uri).length).toBe(2)\n    expect(collection.get(other).length).toBe(1)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete diagnostics for uri","suites":["diagnostic collection"],"updatePoint":{"line":63,"column":39},"line":63,"code":"  it('should delete diagnostics for uri', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    collection.set(uri, [diagnostic])\n    collection.delete(uri)\n    expect(collection.get(uri).length).toBe(0)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear all diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":72,"column":34},"line":72,"code":"  it('should clear all diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    let fn = jest.fn()\n    collection.set(uri, [diagnostic])\n    collection.onDidDiagnosticsChange(fn)\n    collection.clear()\n    expect(collection.get(uri).length).toBe(0)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call for every uri with diagnostics","suites":["diagnostic collection"],"updatePoint":{"line":84,"column":48},"line":84,"code":"  it('should call for every uri with diagnostics', () => {\n    let collection = new DiagnosticCollection('test')\n    let diagnostic = createDiagnostic('error')\n    let uri = 'file:///1'\n    let other = 'file:///2'\n    let entries: [string, Diagnostic[]][] = [\n      [uri, [diagnostic]],\n      [other, [diagnostic]],\n      [uri, [createDiagnostic('other')]]\n    ]\n    collection.set(entries)\n    let arr: string[] = []\n    collection.forEach(uri => {\n      arr.push(uri)\n    })\n    expect(arr).toEqual([uri, other])\n  })","file":"modules/diagnosticCollection.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set location list","suites":["diagnostic manager","setLocationlist()"],"updatePoint":{"line":54,"column":32},"line":54,"code":"    it('should set location list', async () => {\n      let doc = await createDocument()\n      await manager.setLocationlist(doc.bufnr)\n      let res = await nvim.call('getloclist', [doc.bufnr]) as any[]\n      expect(res.length).toBeGreaterThan(2)\n      helper.updateConfiguration('diagnostic.locationlistLevel', 'error')\n      await manager.setLocationlist(doc.bufnr)\n      res = await nvim.call('getloclist', [doc.bufnr]) as any[]\n      expect(res.length).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when diagnostic disabled","suites":["diagnostic manager","setLocationlist()"],"updatePoint":{"line":65,"column":45},"line":65,"code":"    it('should throw when diagnostic disabled', async () => {\n      helper.updateConfiguration('diagnostic.enable', false)\n      let fn = async () => {\n        let bufnr = await nvim.call('bufnr', ['%'])\n        await manager.setLocationlist(bufnr)\n      }\n      await expect(fn()).rejects.toThrow(/not enabled/)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when buffer not attached","suites":["diagnostic manager","setLocationlist()"],"updatePoint":{"line":74,"column":45},"line":74,"code":"    it('should throw when buffer not attached', async () => {\n      await nvim.command(`vnew +setl\\\\ buftype=nofile`)\n      let doc = await workspace.document\n      let fn = async () => {\n        await manager.setLocationlist(doc.bufnr)\n      }\n      await expect(fn()).rejects.toThrow(/not/)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delay refresh when buffer visible","suites":["diagnostic manager","events"],"updatePoint":{"line":85,"column":48},"line":85,"code":"    it('should delay refresh when buffer visible', async () => {\n      let doc = await helper.createDocument()\n      await helper.edit()\n      let collection = manager.create('foo')\n      let diagnostics: Diagnostic[] = []\n      await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await doc.synchronize()\n      diagnostics.push(createDiagnostic('error', Range.create(0, 2, 0, 4), DiagnosticSeverity.Error))\n      collection.set(doc.uri, diagnostics)\n      await helper.wait(20)\n      let buf = doc.buffer\n      let val = await buf.getVar('coc_diagnostic_info') as any\n      expect(val == null).toBe(true)\n      let ns = await nvim.createNamespace('coc-diagnosticfoo')\n      let markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBe(0)\n      await nvim.command(`b ${buf.id}`)\n      await helper.waitFor('eval', ['empty(get(b:,\"coc_diagnostic_info\",{}))'], 0)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delay refresh on InsertLeave","suites":["diagnostic manager","events"],"updatePoint":{"line":109,"column":43},"line":109,"code":"    it('should delay refresh on InsertLeave', async () => {\n      let doc = await workspace.document\n      await nvim.input('i')\n      let collection = manager.create('foo')\n      let diagnostics: Diagnostic[] = []\n      await doc.buffer.setLines(['foo bar foo bar', 'foo bar', 'foo', 'bar'], {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await doc.synchronize()\n      diagnostics.push(createDiagnostic('error', Range.create(0, 2, 0, 4), DiagnosticSeverity.Error))\n      collection.set(doc.uri, diagnostics)\n      await helper.wait(30)\n      let buf = doc.buffer\n      let val = await buf.getVar('coc_diagnostic_info') as any\n      expect(val == null).toBe(true)\n      let ns = await nvim.createNamespace('coc-diagnosticfoo')\n      let markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBe(0)\n      await nvim.input('<esc>')\n      await helper.wait(30)\n      markers = await buf.getExtMarks(ns, 0, -1)\n      expect(markers.length).toBe(1)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show diagnostic virtual text on CursorMoved","suites":["diagnostic manager","events"],"updatePoint":{"line":135,"column":58},"line":135,"code":"    it('should show diagnostic virtual text on CursorMoved', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('virtualText', true)\n      config.update('virtualTextCurrentLineOnly', true)\n      let doc = await createDocument()\n      await helper.wait(30)\n      let markers = await doc.buffer.getExtMarks(manager.config.virtualTextSrcId, 0, -1, { details: true })\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n      await nvim.call('cursor', [1, 3])\n      await helper.wait(30)\n      markers = await doc.buffer.getExtMarks(manager.config.virtualTextSrcId, 0, -1, { details: true })\n      expect(markers.length).toBe(0)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh on buffer create","suites":["diagnostic manager","refresh()"],"updatePoint":{"line":151,"column":39},"line":151,"code":"    it('should refresh on buffer create', async () => {\n      let uri = URI.file(path.join(path.dirname(__dirname), 'doc')).toString()\n      let fn = jest.fn()\n      let disposable = manager.onDidRefresh(() => {\n        fn()\n      })\n      let collection = manager.create('tmp')\n      let diagnostic = createDiagnostic('My Error')\n      collection.set(uri, [diagnostic])\n      let doc = await helper.createDocument('doc')\n      await helper.wait(30)\n      let val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(fn).toBeCalled()\n      expect(val).toBeDefined()\n      expect(val.error).toBe(1)\n      collection.dispose()\n      disposable.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle diagnostics for all buffer","suites":["diagnostic manager","toggleDiagnostic()"],"updatePoint":{"line":172,"column":48},"line":172,"code":"    it('should toggle diagnostics for all buffer', async () => {\n      let doc = await createDocument()\n      await helper.wait(50)\n      manager.toggleDiagnostic()\n      await helper.wait(50)\n      let val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBe(null)\n      manager.toggleDiagnostic()\n      await helper.wait(50)\n      val = await doc.buffer.getVar('coc_diagnostic_info') as any\n      expect(val).toBeDefined()\n      expect(val.error).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all diagnostics","suites":["diagnostic manager","getDiagnosticList()"],"updatePoint":{"line":188,"column":34},"line":188,"code":"    it('should get all diagnostics', async () => {\n      await createDocument()\n      let collection = manager.create('test')\n      let fsPath = await createTmpFile('foo')\n      let doc = await helper.createDocument(fsPath)\n      let diagnostics: Diagnostic[] = []\n      diagnostics.push(createDiagnostic('error', Range.create(0, 0, 0, 1), DiagnosticSeverity.Error))\n      diagnostics.push(createDiagnostic('error', Range.create(0, 2, 0, 3), DiagnosticSeverity.Warning))\n      collection.set(doc.uri, diagnostics)\n      let list = await manager.getDiagnosticList()\n      expect(list).toBeDefined()\n      expect(list.length).toBeGreaterThanOrEqual(5)\n      expect(list[0].severity).toBe('Error')\n      expect(list[1].severity).toBe('Error')\n      expect(list[2].severity).toBe('Error')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter diagnostics by configuration","suites":["diagnostic manager","getDiagnosticList()"],"updatePoint":{"line":205,"column":50},"line":205,"code":"    it('should filter diagnostics by configuration', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('level', 'warning')\n      config.update('showUnused', false)\n      config.update('showDeprecated', false)\n      let doc = await createDocument()\n      let diagnostics = manager.getDiagnostics(doc.uri)['test']\n      diagnostics[0].tags = [DiagnosticTag.Unnecessary]\n      diagnostics[2].tags = [DiagnosticTag.Deprecated]\n      let list = await manager.getDiagnosticList()\n      expect(list.length).toBe(3)\n      let res = manager.getDiagnostics(doc.uri)['test']\n      expect(res.length).toBe(1)\n      let ranges = manager.getSortedRanges(doc.uri)\n      expect(ranges.length).toBe(3)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw with empty diagnostics","suites":["diagnostic manager","preview()"],"updatePoint":{"line":224,"column":47},"line":224,"code":"    it('should not throw with empty diagnostics', async () => {\n      await manager.preview()\n      let tabpage = await nvim.tabpage\n      let wins = await tabpage.windows\n      expect(wins.length).toBe(1)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open preview window","suites":["diagnostic manager","preview()"],"updatePoint":{"line":231,"column":34},"line":231,"code":"    it('should open preview window', async () => {\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      await manager.preview()\n      let res = await nvim.call('coc#window#find', ['&previewwindow', 1])\n      expect(res).toBeDefined()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set configuration errors","suites":["diagnostic manager","setConfigurationErrors()"],"updatePoint":{"line":241,"column":39},"line":241,"code":"    it('should set configuration errors', async () => {\n      let doc = await workspace.document\n      let errors = [{\n        location: Location.create(doc.uri, Range.create(0, 0, 1, 0)),\n        message: 'foo',\n      }, {\n        location: Location.create(doc.uri, Range.create(1, 0, 2, 0)),\n        message: 'bar',\n      }]\n      manager.setConfigurationErrors(errors)\n      await helper.wait(50)\n      let res = manager.getDiagnostics(doc.uri)\n      expect(res.config.length).toBe(2)\n      manager.setConfigurationErrors()\n      await helper.wait(50)\n      res = manager.getDiagnostics(doc.uri)\n      expect(res.config).toBeUndefined()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create diagnostic collection","suites":["diagnostic manager","create()"],"updatePoint":{"line":262,"column":43},"line":262,"code":"    it('should create diagnostic collection', async () => {\n      let doc = await workspace.document\n      let collection = manager.create('test')\n      collection.set(doc.uri, [createDiagnostic('foo')])\n      await helper.wait(50)\n      let info = await doc.buffer.getVar('coc_diagnostic_info')\n      expect(info).toBeDefined()\n      await nvim.command('bd!')\n      await helper.wait(50)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sorted ranges of document","suites":["diagnostic manager","getSortedRanges()"],"updatePoint":{"line":275,"column":44},"line":275,"code":"    it('should get sorted ranges of document', async () => {\n      let doc = await workspace.document\n      await nvim.call('setline', [1, ['a', 'b', 'c']])\n      let collection = manager.create('test')\n      let diagnostics: Diagnostic[] = []\n      diagnostics.push(createDiagnostic('x', Range.create(0, 0, 0, 1)))\n      diagnostics.push(createDiagnostic('y', Range.create(0, 1, 0, 2)))\n      diagnostics.push(createDiagnostic('z', Range.create(1, 0, 1, 2)))\n      collection.set(doc.uri, diagnostics)\n      let ranges = manager.getSortedRanges(doc.uri)\n      expect(ranges[0]).toEqual(Range.create(0, 0, 0, 1))\n      expect(ranges[1]).toEqual(Range.create(0, 1, 0, 2))\n      expect(ranges[2]).toEqual(Range.create(1, 0, 1, 2))\n      ranges = manager.getSortedRanges(doc.uri, 'error')\n      expect(ranges.length).toBe(3)\n      expect(manager.getSortedRanges(doc.uri, 'warning').length).toBe(0)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostics in range","suites":["diagnostic manager","getDiagnosticsInRange"],"updatePoint":{"line":295,"column":39},"line":295,"code":"    it('should get diagnostics in range', async () => {\n      let doc = await workspace.document\n      let collection = manager.create('test')\n      let diagnostics: Diagnostic[] = []\n      await doc.buffer.setLines(['foo bar foo bar', 'foo bar'], {\n        start: 0,\n        end: -1,\n        strictIndexing: false\n      })\n      await doc.synchronize()\n      diagnostics.push(createDiagnostic('a', Range.create(0, 0, 0, 1)))\n      diagnostics.push(createDiagnostic('b', Range.create(0, 2, 0, 3)))\n      diagnostics.push(createDiagnostic('c', Range.create(1, 0, 1, 2)))\n      collection.set(doc.uri, diagnostics)\n      let res = manager.getDiagnosticsInRange(doc.textDocument, Range.create(0, 0, 0, 3))\n      expect(res.length).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostics under cursor","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":315,"column":43},"line":315,"code":"    it('should get diagnostics under cursor', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      await createDocument()\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(0)\n      await nvim.call('cursor', [1, 4])\n      diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(1)\n      config.update('checkCurrentLine', true)\n      await nvim.call('cursor', [1, 2])\n      diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty diagnostic at end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":329,"column":50},"line":329,"code":"    it('should get empty diagnostic at end of line', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n      await manager.refreshBuffer(99)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic next to end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":345,"column":49},"line":345,"code":"    it('should get diagnostic next to end of line', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 0, 4), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic with empty range at end of line","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":360,"column":61},"line":360,"code":"    it('should get diagnostic with empty range at end of line', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! $')\n      let diagnostic = Diagnostic.create(Range.create(0, 3, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diagnostic pass end of the buffer lines","suites":["diagnostic manager","getCurrentDiagnostics"],"updatePoint":{"line":375,"column":58},"line":375,"code":"    it('should get diagnostic pass end of the buffer lines', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      doc.forceSync()\n      await nvim.command('normal! ^')\n      let diagnostic = Diagnostic.create(Range.create(1, 0, 1, 0), 'error', DiagnosticSeverity.Error)\n      let collection = manager.create('empty')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.bufnr)\n      let diagnostics = await manager.getCurrentDiagnostics()\n      expect(diagnostics.length).toBeGreaterThanOrEqual(1)\n      expect(diagnostics[0].message).toBe('error')\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should does nothing when no diagnostic exists","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":393,"column":53},"line":393,"code":"    it('should does nothing when no diagnostic exists', async () => {\n      let doc = await workspace.document\n      await nvim.call('cursor', [1, 1])\n      await manager.jumpRelated()\n      let bufnr = await nvim.eval('bufnr(\"%\")')\n      expect(bufnr).toBe(doc.bufnr)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should does nothing when no related information exists","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":401,"column":62},"line":401,"code":"    it('should does nothing when no related information exists', async () => {\n      let doc = await createDocument()\n      await nvim.call('cursor', [1, 4])\n      await manager.jumpRelated()\n      let bufnr = await nvim.eval('bufnr(\"%\")')\n      expect(bufnr).toBe(doc.bufnr)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to related position","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":409,"column":39},"line":409,"code":"    it('should jump to related position', async () => {\n      let doc = await workspace.document\n      let range = Range.create(0, 0, 0, 10)\n      let location = Location.create(URI.file(__filename).toString(), range)\n      let diagnostic = Diagnostic.create(range, 'msg', DiagnosticSeverity.Error, 1000, 'test',\n        [{ location, message: 'test' }])\n      let collection = manager.create('positions')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.uri)\n      await nvim.call('cursor', [1, 1])\n      await manager.jumpRelated()\n      await helper.wait(100)\n      let bufname = await nvim.call('bufname', '%')\n      expect(bufname).toMatch('diagnosticManager')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open location list","suites":["diagnostic manager","jumpRelated"],"updatePoint":{"line":425,"column":33},"line":425,"code":"    it('should open location list', async () => {\n      let doc = await workspace.document\n      let range = Range.create(0, 0, 0, 10)\n      let diagnostic = Diagnostic.create(range, 'msg', DiagnosticSeverity.Error, 1000, 'test',\n        [{\n          location: Location.create(URI.file(__filename).toString(), Range.create(1, 0, 1, 10)),\n          message: 'foo'\n        }, {\n          location: Location.create(URI.file(__filename).toString(), Range.create(2, 0, 2, 10)),\n          message: 'bar'\n        }])\n      let collection = manager.create('positions')\n      collection.set(doc.uri, [diagnostic])\n      await manager.refreshBuffer(doc.uri)\n      await nvim.call('cursor', [1, 1])\n      await manager.jumpRelated()\n      await helper.waitFor('bufname', ['%'], 'list:///location')\n      await nvim.input('<esc>')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to previous","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":447,"column":31},"line":447,"code":"    it('should jump to previous', async () => {\n      let doc = await createDocument()\n      await nvim.command('normal! G$')\n      let ranges = manager.getSortedRanges(doc.uri)\n      ranges.reverse()\n      for (let i = 0; i < ranges.length; i++) {\n        await manager.jumpPrevious()\n        let pos = await window.getCursorPosition()\n        expect(pos).toEqual(ranges[i].start)\n      }\n      await manager.jumpPrevious()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to next","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":460,"column":27},"line":460,"code":"    it('should jump to next', async () => {\n      let doc = await createDocument()\n      await nvim.call('cursor', [0, 0])\n      let ranges = manager.getSortedRanges(doc.uri)\n      for (let i = 0; i < ranges.length; i++) {\n        await manager.jumpNext()\n        let pos = await window.getCursorPosition()\n        expect(pos).toEqual(ranges[i].start)\n      }\n      await manager.jumpNext()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw for buffer not attached","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":472,"column":48},"line":472,"code":"    it('should not throw for buffer not attached', async () => {\n      await nvim.command('edit foo | setl buftype=nofile')\n      let doc = await workspace.document\n      expect(doc.attached).toBe(false)\n      await manager.jumpNext()\n      await manager.jumpPrevious()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect wrapscan","suites":["diagnostic manager","jumpPrevious & jumpNext"],"updatePoint":{"line":480,"column":31},"line":480,"code":"    it('should respect wrapscan', async () => {\n      await createDocument()\n      await nvim.command('setl nowrapscan')\n      await nvim.command('normal! G$')\n      await manager.jumpNext()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 3, character: 2 })\n      await nvim.command('normal! gg0')\n      await manager.jumpPrevious()\n      pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 0 })\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use filetype map from config","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":495,"column":43},"line":495,"code":"    it('should use filetype map from config', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('filetypeMap', { default: 'bufferType' })\n      config.update('messageDelay', 10)\n      let doc = await createDocument('foo.js')\n      await nvim.setLine('foo')\n      await doc.synchronize()\n      let collection = manager.getCollectionByName('test')\n      let diagnostic = createDiagnostic('99', Range.create(0, 0, 0, 3), DiagnosticSeverity.Error)\n      diagnostic.codeDescription = {\n        href: 'http://www.example.com'\n      }\n      let diagnostics = [diagnostic]\n      collection.set(doc.uri, diagnostics)\n      await nvim.call('cursor', [1, 2])\n      await manager.echoMessage(false)\n      let win = await helper.getFloat()\n      let bufnr = await nvim.call('winbufnr', [win.id])\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.lines\n      expect(lines.join('\\n')).toMatch('www.example.com')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show floating window on cursor hold","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":518,"column":50},"line":518,"code":"    it('should show floating window on cursor hold', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('messageTarget', 'float')\n      config.update('messageDelay', 10)\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      await nvim.command('doautocmd CursorHold')\n      let winid = await helper.waitFloat()\n      let bufnr = await nvim.call('nvim_win_get_buf', winid) as number\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.lines\n      expect(lines.join('\\n')).toMatch('error')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter diagnostics by messageLevel","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":532,"column":49},"line":532,"code":"    it('should filter diagnostics by messageLevel', async () => {\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('messageLevel', 'error')\n      config.update('messageTarget', 'echo')\n      await createDocument()\n      await nvim.call('cursor', [1, 6])\n      await manager.echoMessage(false)\n      let line = await helper.getCmdline()\n      expect(line.indexOf('warning')).toBe(-1)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo messages on CursorHold","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":543,"column":42},"line":543,"code":"    it('should echo messages on CursorHold', async () => {\n      await createDocument()\n      await helper.wait(30)\n      let config = workspace.getConfiguration('diagnostic')\n      config.update('messageTarget', 'echo')\n      config.update('messageDelay', 1)\n      await nvim.call('cursor', [1, 3])\n      await helper.wait(50)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('error')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show diagnostics of current line","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":555,"column":47},"line":555,"code":"    it('should show diagnostics of current line', async () => {\n      helper.updateConfiguration('diagnostic.checkCurrentLine', true)\n      helper.updateConfiguration('diagnostic.messageDelay', 1)\n      await createDocument()\n      await nvim.call('cursor', [1, 3])\n      let winid = await helper.waitFloat()\n      let win = nvim.createWindow(winid)\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines.length).toBe(3)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter diagnostics by level","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":567,"column":42},"line":567,"code":"    it('should filter diagnostics by level', async () => {\n      helper.updateConfiguration('diagnostic.level', 'warning')\n      let doc = await createDocument()\n      let diagnosticsMap = manager.getDiagnostics(doc.uri)\n      for (let diagnostics of Object.values(diagnosticsMap)) {\n        for (let diagnostic of diagnostics) {\n          expect(diagnostic.severity != DiagnosticSeverity.Hint).toBe(true)\n          expect(diagnostic.severity != DiagnosticSeverity.Information).toBe(true)\n        }\n      }\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should send ale diagnostic items","suites":["diagnostic manager","diagnostic configuration"],"updatePoint":{"line":579,"column":40},"line":579,"code":"    it('should send ale diagnostic items', async () => {\n      helper.updateConfiguration('diagnostic.displayByAle', true)\n      let content = `\n    function! MockAleResults(bufnr, collection, items)\n      let g:collection = a:collection\n      let g:items = a:items\n    endfunction\n    `\n      let file = await createTmpFile(content)\n      await nvim.command(`source ${file}`)\n      await createDocument()\n      await helper.wait(50)\n      let items = await nvim.getVar('items') as any[]\n      expect(Array.isArray(items)).toBe(true)\n      expect(items.length).toBeGreaterThan(0)\n      await nvim.command('bd!')\n      await helper.wait(50)\n      items = await nvim.getVar('items') as any[]\n      expect(items).toEqual([])\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get severity level","suites":["diagnostic manager","severityLevel & getNameFromSeverity"],"updatePoint":{"line":602,"column":33},"line":602,"code":"    it('should get severity level', () => {\n      expect(severityLevel('hint')).toBe(DiagnosticSeverity.Hint)\n      expect(severityLevel('error')).toBe(DiagnosticSeverity.Error)\n      expect(severityLevel('warning')).toBe(DiagnosticSeverity.Warning)\n      expect(severityLevel('information')).toBe(DiagnosticSeverity.Information)\n      expect(severityLevel('')).toBe(DiagnosticSeverity.Hint)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get severity name","suites":["diagnostic manager","severityLevel & getNameFromSeverity"],"updatePoint":{"line":610,"column":32},"line":610,"code":"    it('should get severity name', () => {\n      expect(getNameFromSeverity(null as any)).toBe('CocError')\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when bufnr is invliad or disabled","suites":["diagnostic manager","toggleDiagnosticBuffer"],"updatePoint":{"line":616,"column":58},"line":616,"code":"    it('should not throw when bufnr is invliad or disabled', async () => {\n      let doc = await workspace.document\n      await manager.toggleDiagnosticBuffer(99)\n      helper.updateConfiguration('diagnostic.enable', false)\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle diagnostics for buffer","suites":["diagnostic manager","toggleDiagnosticBuffer"],"updatePoint":{"line":623,"column":44},"line":623,"code":"    it('should toggle diagnostics for buffer', async () => {\n      let doc = await createDocument()\n      // required to wait refresh finish\n      await helper.wait(50)\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n      let buf = nvim.createBuffer(doc.bufnr)\n      let res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res == null).toBe(true)\n      await manager.toggleDiagnosticBuffer(doc.bufnr)\n      await helper.wait(50)\n      res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res.error).toBe(2)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh by bufnr","suites":["diagnostic manager","refresh"],"updatePoint":{"line":644,"column":31},"line":644,"code":"    it('should refresh by bufnr', async () => {\n      let doc = await createDocument()\n      let buf = nvim.createBuffer(doc.bufnr)\n      let res = await buf.getVar('coc_diagnostic_info') as any\n      // should not refresh\n      expect(res == null).toBe(true)\n      manager.refresh(doc.bufnr)\n      await helper.wait(50)\n      res = await buf.getVar('coc_diagnostic_info') as any\n      expect(res?.error).toBe(2)\n      manager.refresh(99)\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh all buffers","suites":["diagnostic manager","refresh"],"updatePoint":{"line":657,"column":34},"line":657,"code":"    it('should refresh all buffers', async () => {\n      let uris = ['one', 'two'].map(s => URI.file(path.join(os.tmpdir(), s)).toString())\n      await workspace.loadFiles(uris)\n      let collection = manager.create('tmp')\n      collection.set([[uris[0], [createDiagnostic('Error one')]], [uris[1], [createDiagnostic('Error two')]]])\n      manager.refresh()\n      await helper.wait(50)\n      let bufnrs = [workspace.getDocument(uris[0]).bufnr, workspace.getDocument(uris[1]).bufnr]\n      for (let bufnr of bufnrs) {\n        let buf = nvim.createBuffer(bufnr)\n        let res = await buf.getVar('coc_diagnostic_info') as any\n        expect(res?.error).toBe(1)\n      }\n      collection.dispose()\n    })","file":"modules/diagnosticManager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog","suites":["Dialog module"],"updatePoint":{"line":21,"column":24},"line":21,"code":"  it('should show dialog', async () => {\n    let dialog = new Dialog(nvim, { content: '' })\n    await dialog.show({})\n    let winid = await dialog.winid\n    let win = nvim.createWindow(winid)\n    let width = await win.width\n    expect(width).toBe(4)\n    await nvim.call('coc#float#close', [winid])\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke callback with index -1","suites":["Dialog module"],"updatePoint":{"line":31,"column":42},"line":31,"code":"  it('should invoke callback with index -1', async () => {\n    let callback = jest.fn()\n    let dialog = new Dialog(nvim, { content: '', callback })\n    await dialog.show({})\n    let winid = await dialog.winid\n    await nvim.call('coc#float#close', [winid])\n    await helper.wait(50)\n    expect(callback).toHaveBeenCalledWith(-1)\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke callback on click","suites":["Dialog module"],"updatePoint":{"line":41,"column":37},"line":41,"code":"  it('should invoke callback on click', async () => {\n    let callback = jest.fn()\n    let buttons: DialogButton[] = [{\n      index: 0,\n      text: 'yes'\n    }, {\n      index: 1,\n      text: 'no'\n    }]\n    let dialog = new Dialog(nvim, { content: '', buttons, callback })\n    await dialog.show({})\n    let winid = await dialog.winid\n    let btnwin = await nvim.call('coc#float#get_related', [winid, 'buttons'])\n    await nvim.call('win_gotoid', [btnwin])\n    await nvim.call('cursor', [2, 1])\n    await nvim.call('coc#float#nvim_float_click', [])\n    await helper.wait(50)\n    expect(callback).toHaveBeenCalledWith(0)\n  })","file":"modules/dialog.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply edits","suites":["LinesTextDocument"],"updatePoint":{"line":28,"column":24},"line":28,"code":"  it('should apply edits', async () => {\n    let textDocument = new LinesTextDocument('', '', 1, [\n      'use std::io::Result;'\n    ], 1, true)\n    // 1234567890\n    let edits = [\n      { range: { start: { line: 0, character: 7 }, end: { line: 0, character: 11 } }, newText: \"\" },\n      { range: { start: { line: 0, character: 13 }, end: { line: 0, character: 19 } }, newText: \"io\" },\n      { range: { start: { line: 0, character: 19 }, end: { line: 0, character: 19 } }, newText: \"::\" },\n      {\n        range: { start: { line: 0, character: 19 }, end: { line: 0, character: 19 } }, newText: \"{Result, Error}\"\n      }\n    ]\n    edits = filterSortEdits(textDocument, edits)\n    let res = applyEdits(textDocument, edits)\n    expect(res).toEqual(['use std::io::{Result, Error};'])\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get length","suites":["LinesTextDocument"],"updatePoint":{"line":46,"column":23},"line":46,"code":"  it('should get length', async () => {\n    let doc = createTextDocument(['foo'])\n    expect(doc.length).toBe(4)\n    expect(doc.getText().length).toBe(4)\n    expect(doc.length).toBe(4)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getText by range","suites":["LinesTextDocument"],"updatePoint":{"line":53,"column":29},"line":53,"code":"  it('should getText by range', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    expect(doc.getText(Range.create(0, 0, 0, 1))).toBe('f')\n    expect(doc.getText(Range.create(0, 0, 1, 0))).toBe('foo\\n')\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work when eol enabled","suites":["LinesTextDocument"],"updatePoint":{"line":59,"column":34},"line":59,"code":"  it('should work when eol enabled', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    expect(doc.lineCount).toBe(3)\n    let content = doc.getText()\n    expect(content).toBe('foo\\nbar\\n')\n    content = doc.getText(Range.create(0, 0, 0, 3))\n    expect(content).toBe('foo')\n    let textLine = doc.lineAt(0)\n    expect(textLine.text).toBe('foo')\n    textLine = doc.lineAt(Position.create(0, 3))\n    expect(textLine.text).toBe('foo')\n    let pos = doc.positionAt(4)\n    expect(pos).toEqual({ line: 1, character: 0 })\n    content = doc.getText(Range.create(0, 0, 0, 3))\n    expect(content).toBe('foo')\n    let offset = doc.offsetAt(Position.create(0, 4))\n    expect(offset).toBe(4)\n    offset = doc.offsetAt(Position.create(2, 1))\n    expect(offset).toBe(8)\n    expect(doc.end).toEqual(Position.create(2, 0))\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid line","suites":["LinesTextDocument"],"updatePoint":{"line":81,"column":35},"line":81,"code":"  it('should throw for invalid line', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let fn = () => {\n      doc.lineAt(-1)\n    }\n    expect(fn).toThrow(Error)\n    fn = () => {\n      doc.lineAt(3)\n    }\n    expect(fn).toThrow(Error)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work when eol disabled","suites":["LinesTextDocument"],"updatePoint":{"line":93,"column":35},"line":93,"code":"  it('should work when eol disabled', async () => {\n    let doc = new LinesTextDocument('file://a', 'txt', 1, ['foo'], 1, false)\n    expect(doc.getText()).toBe('foo')\n    expect(doc.lineCount).toBe(1)\n    expect(doc.end).toEqual(Position.create(0, 3))\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should computeLinesOffsets","suites":["computeLinesOffsets()"],"updatePoint":{"line":102,"column":32},"line":102,"code":"  it('should computeLinesOffsets', async () => {\n    expect(computeLinesOffsets(['foo'], true)).toEqual([0, 4])\n    expect(computeLinesOffsets(['foo'], false)).toEqual([0])\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with line not last one","suites":["TextLine"],"updatePoint":{"line":109,"column":40},"line":109,"code":"  it('should work with line not last one', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let textLine = doc.lineAt(0)\n    expect(textLine.lineNumber).toBe(0)\n    expect(textLine.text).toBe('foo')\n    expect(textLine.range).toEqual(Range.create(0, 0, 0, 3))\n    expect(textLine.rangeIncludingLineBreak).toEqual(Range.create(0, 0, 1, 0))\n    expect(textLine.isEmptyOrWhitespace).toBe(false)\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with last line","suites":["TextLine"],"updatePoint":{"line":119,"column":32},"line":119,"code":"  it('should work with last line', async () => {\n    let doc = createTextDocument(['foo', 'bar'])\n    let textLine = doc.lineAt(2)\n    let r = textLine.rangeIncludingLineBreak\n    expect(textLine.rangeIncludingLineBreak).toEqual(Range.create(2, 0, 2, 0))\n  })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse iskeyword of character range","suites":["Document","properties"],"updatePoint":{"line":142,"column":49},"line":142,"code":"    it('should parse iskeyword of character range', async () => {\n      await nvim.setOption('iskeyword', 'a-z,A-Z,48-57,_')\n      let opt = await nvim.getOption('iskeyword')\n      expect(opt).toBe('a-z,A-Z,48-57,_')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get word range","suites":["Document","properties"],"updatePoint":{"line":148,"column":29},"line":148,"code":"    it('should get word range', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar')\n      await doc.synchronize()\n      let range = doc.getWordRangeAtPosition({ line: 0, character: 0 })\n      expect(range).toEqual(Range.create(0, 0, 0, 3))\n      range = doc.getWordRangeAtPosition({ line: 0, character: 3 })\n      expect(range).toBeNull()\n      range = doc.getWordRangeAtPosition({ line: 0, character: 4 })\n      expect(range).toEqual(Range.create(0, 4, 0, 7))\n      range = doc.getWordRangeAtPosition({ line: 0, character: 7 })\n      expect(range).toBeNull()\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check has changed","suites":["Document","properties"],"updatePoint":{"line":162,"column":32},"line":162,"code":"    it('should check has changed', async () => {\n      let doc = await workspace.document\n      expect(doc.hasChanged).toBe(false)\n      await nvim.setLine('foo bar')\n      await helper.waitValue(() => {\n        return doc.hasChanged\n      }, false)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get symbol ranges","suites":["Document","properties"],"updatePoint":{"line":171,"column":32},"line":171,"code":"    it('should get symbol ranges', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo bar foo')\n      let ranges = doc.getSymbolRanges('foo')\n      expect(ranges.length).toBe(2)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get localify bonus","suites":["Document","properties"],"updatePoint":{"line":178,"column":33},"line":178,"code":"    it('should get localify bonus', async () => {\n      let assertBonus = async (lines: string[], position: Position, words: string[], limit?: number) => {\n        let doc = await helper.createDocument()\n        await doc.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false })\n        await doc.patchChange()\n        let res = doc.getLocalifyBonus(position, position, limit)\n        for (let word of words) {\n          expect(res.has(word)).toBe(true)\n        }\n      }\n      await assertBonus(\n        ['context content clearTimeout', '', 'product confirm'],\n        Position.create(1, 0),\n        ['confirm', 'clearTimeout']\n      )\n      await assertBonus(\n        ['context content clearTimeout', '', 'product confirm', 'word', 'workspace', 'words'],\n        Position.create(2, 1),\n        ['confirm'],\n        50\n      )\n      await assertBonus(\n        ['context content clearTimeout', '', 'product confirm', 'word', 'workspace', 'words'],\n        Position.create(2, 1),\n        ['confirm'],\n        30\n      )\n      await assertBonus(\n        ['context content clearTimeout', '', 'product confirm'],\n        Position.create(0, 7),\n        ['confirm', 'clearTimeout']\n      )\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current line","suites":["Document","properties"],"updatePoint":{"line":212,"column":31},"line":212,"code":"    it('should get current line', async () => {\n      let doc = await workspace.document\n      await setLines(doc, ['first line', 'second line'])\n      let line = doc.getline(1, true)\n      expect(line).toBe('second line')\n      line = doc.getline(0, false)\n      expect(line).toBe('first line')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get variable form buffer","suites":["Document","properties"],"updatePoint":{"line":221,"column":39},"line":221,"code":"    it('should get variable form buffer', async () => {\n      await nvim.command('autocmd BufNewFile,BufRead * let b:coc_variable = 1')\n      let doc = await helper.createDocument()\n      let val = doc.getVar<number>('variable')\n      expect(val).toBe(1)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach change events","suites":["Document","properties"],"updatePoint":{"line":228,"column":35},"line":228,"code":"    it('should attach change events', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('abc')\n      await doc.synchronize()\n      let content = doc.getDocumentContent()\n      expect(content.indexOf('abc')).toBe(0)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not attach change events when b:coc_enabled is false","suites":["Document","properties"],"updatePoint":{"line":236,"column":67},"line":236,"code":"    it('should not attach change events when b:coc_enabled is false', async () => {\n      nvim.command('edit t|let b:coc_enabled = 0', true)\n      let doc = await workspace.document\n      let val = doc.getVar<number>('enabled', 0)\n      expect(val).toBe(0)\n      await nvim.setLine('abc')\n      await doc.synchronize()\n      let content = doc.getDocumentContent()\n      expect(content.indexOf('abc')).toBe(-1)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get lineCount, previewwindow, winid","suites":["Document","properties"],"updatePoint":{"line":247,"column":50},"line":247,"code":"    it('should get lineCount, previewwindow, winid', async () => {\n      let doc = await workspace.document\n      let { lineCount, winid, previewwindow } = doc\n      expect(lineCount).toBe(1)\n      expect(winid != -1).toBe(true)\n      expect(previewwindow).toBe(false)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set filetype","suites":["Document","properties"],"updatePoint":{"line":255,"column":27},"line":255,"code":"    it('should set filetype', async () => {\n      let doc = await workspace.document\n      doc.setFiletype('javascript.jsx')\n      expect(doc.filetype).toBe('javascriptreact')\n      doc.setFiletype('typescript.jsx')\n      expect(doc.filetype).toBe('typescriptreact')\n      doc.setFiletype('typescript.tsx')\n      expect(doc.filetype).toBe('typescriptreact')\n      doc.setFiletype('tex')\n      expect(doc.filetype).toBe('latex')\n      doc.setFiletype('foo')\n      expect(doc.filetype).toBe('foo')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should simple applyEdits","suites":["Document","applyEdits()"],"updatePoint":{"line":271,"column":32},"line":271,"code":"    it('should simple applyEdits', async () => {\n      let doc = await workspace.document\n      let edits: TextEdit[] = []\n      edits.push({\n        range: Range.create(0, 0, 0, 0),\n        newText: 'a\\n'\n      })\n      edits.push({\n        range: Range.create(0, 0, 0, 0),\n        newText: 'b\\n'\n      })\n      let edit = await doc.applyEdits(edits)\n      let content = doc.getDocumentContent()\n      expect(content).toBe('a\\nb\\n\\n')\n      await doc.applyEdits([edit])\n      expect(doc.getDocumentContent()).toEqual('\\n')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return revert edit","suites":["Document","applyEdits()"],"updatePoint":{"line":289,"column":33},"line":289,"code":"    it('should return revert edit', async () => {\n      let doc = await workspace.document\n      let edit = await doc.applyEdits([TextEdit.replace(Range.create(0, 0, 0, 0), 'foo')])\n      expect(doc.getDocumentContent()).toBe('foo\\n')\n      edit = await doc.applyEdits([edit])\n      expect(doc.getDocumentContent()).toBe('\\n')\n      edit = await doc.applyEdits([edit])\n      expect(doc.getDocumentContent()).toBe('foo\\n')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply merged edits","suites":["Document","applyEdits()"],"updatePoint":{"line":299,"column":33},"line":299,"code":"    it('should apply merged edits', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      await doc.patchChange()\n      let edits: TextEdit[] = []\n      edits.push({\n        range: Range.create(0, 0, 0, 3),\n        newText: ''\n      })\n      edits.push({\n        range: Range.create(0, 0, 0, 0),\n        newText: 'bar'\n      })\n      let edit = await doc.applyEdits(edits)\n      let line = await nvim.line\n      expect(line).toBe('bar')\n      await doc.applyEdits([edit])\n      expect(doc.getDocumentContent()).toBe('foo\\n')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply textedit exceed end","suites":["Document","applyEdits()"],"updatePoint":{"line":319,"column":40},"line":319,"code":"    it('should apply textedit exceed end', async () => {\n      let doc = await workspace.document\n      let edits: TextEdit[] = []\n      edits.push({\n        range: Range.create(0, 0, 999999, 99999),\n        newText: 'foo\\n'\n      })\n      await doc.applyEdits(edits)\n      let content = doc.getDocumentContent()\n      expect(content).toBe('foo\\n')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor","suites":["Document","applyEdits()"],"updatePoint":{"line":331,"column":26},"line":331,"code":"    it('should move cursor', async () => {\n      await nvim.input('ia')\n      await helper.wait(30)\n      let doc = await workspace.document\n      let edits: TextEdit[] = []\n      edits.push({\n        range: Range.create(0, 0, 0, 1),\n        newText: 'foo'\n      })\n      await doc.applyEdits(edits, false, true)\n      let cursor = await nvim.call('getcurpos') as number[]\n      expect(cursor[1]).toBe(1)\n      expect(cursor[2]).toBe(4)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with range not sorted","suites":["Document","applyEdits()"],"updatePoint":{"line":346,"column":47},"line":346,"code":"    it('should applyEdits with range not sorted', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setLines([\n        'aa',\n        'bb',\n        'cc',\n        'dd'\n      ], { start: 0, end: -1, strictIndexing: false })\n      await doc.patchChange()\n      let edits = [\n        { range: { start: { line: 3, character: 0 }, end: { line: 3, character: 1 } }, newText: \"\" },\n        { range: { start: { line: 0, character: 2 }, end: { line: 1, character: 0 } }, newText: \"\" },\n      ]\n      await doc.applyEdits(edits)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['aabb', 'cc', 'd'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with insert as same position","suites":["Document","applyEdits()"],"updatePoint":{"line":364,"column":54},"line":364,"code":"    it('should applyEdits with insert as same position', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setLines([\n        'foo'\n      ], { start: 0, end: -1, strictIndexing: false })\n      await doc.patchChange()\n      let edits = [\n        { range: { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } }, newText: 'aa' },\n        { range: { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } }, newText: 'bb' },\n      ]\n      await doc.applyEdits(edits)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['aabbfoo'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with bad range","suites":["Document","applyEdits()"],"updatePoint":{"line":379,"column":40},"line":379,"code":"    it('should applyEdits with bad range', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setLines([], { start: 0, end: -1, strictIndexing: false })\n      await doc.patchChange()\n      let edits = [{ range: { start: { line: -1, character: -1 }, end: { line: -1, character: -1 } }, newText: 'foo' },]\n      await doc.applyEdits(edits)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['foo'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with lines","suites":["Document","applyEdits()"],"updatePoint":{"line":389,"column":36},"line":389,"code":"    it('should applyEdits with lines', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setLines([\n        'aa',\n        'bb',\n        'cc',\n        'dd'\n      ], { start: 0, end: -1, strictIndexing: false })\n      await doc.patchChange()\n      let edits = [\n        { range: { start: { line: 0, character: 0 }, end: { line: 0, character: 1 } }, newText: \"\" },\n        { range: { start: { line: 0, character: 2 }, end: { line: 1, character: 0 } }, newText: \"\" },\n      ]\n      await doc.applyEdits(edits)\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['abb', 'cc', 'dd'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should applyEdits with changed lines","suites":["Document","applyEdits()"],"updatePoint":{"line":407,"column":44},"line":407,"code":"    it('should applyEdits with changed lines', async () => {\n      let doc = await workspace.document\n      let buf = doc.buffer\n      const assertChange = async (sl, sc, el, ec, text, lines) => {\n        let r = Range.create(sl, sc, el, ec)\n        let edits = [TextEdit.replace(r, text)]\n        await doc.applyEdits(edits)\n        let curr = await buf.lines\n        expect(curr).toEqual(lines)\n      }\n      await nvim.setLine('a')\n      await doc.patchChange()\n      await assertChange(0, 1, 0, 1, '\\nb', ['a', 'b'])\n      await assertChange(1, 0, 2, 0, 'c\\n', ['a', 'c'])\n      await assertChange(1, 0, 2, 0, '', ['a'])\n      await assertChange(1, 0, 1, 0, 'b\\nc\\n', ['a', 'b', 'c'])\n      await assertChange(2, 0, 3, 0, 'e\\n', ['a', 'b', 'e'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply single textedit","suites":["Document","applyEdits()"],"updatePoint":{"line":426,"column":36},"line":426,"code":"    it('should apply single textedit', async () => {\n      let doc = await workspace.document\n      let buf = doc.buffer\n      const assertChange = async (sl, sc, el, ec, text, lines) => {\n        let r = Range.create(sl, sc, el, ec)\n        let edits = [TextEdit.replace(r, text)]\n        await doc.applyEdits(edits)\n        let curr = await buf.lines\n        expect(curr).toEqual(lines)\n      }\n      await nvim.setLine('foo')\n      await doc.patchChange()\n      await assertChange(1, 0, 1, 0, 'bar', ['foo', 'bar'])\n      await assertChange(2, 0, 2, 0, 'do\\n', ['foo', 'bar', 'do'])\n      await assertChange(2, 1, 3, 0, '', ['foo', 'bar', 'd'])\n      await assertChange(2, 0, 3, 0, 'if', ['foo', 'bar', 'if'])\n      await assertChange(2, 0, 2, 2, 'x', ['foo', 'bar', 'x'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize on lines change","suites":["Document","synchronize"],"updatePoint":{"line":447,"column":42},"line":447,"code":"    it('should synchronize on lines change', async () => {\n      let document = await workspace.document\n      let doc = TextDocument.create('untitled:1', 'txt', 1, document.getDocumentContent())\n      let disposables = []\n      document.onDocumentChange(e => {\n        TextDocument.update(doc, e.contentChanges.slice(), 2)\n      }, null, disposables)\n      // document.on\n      await nvim.setLine('abc')\n      document.forceSync()\n      expect(doc.getText()).toBe('abc\\n')\n      disposeAll(disposables)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize changes after applyEdits","suites":["Document","synchronize"],"updatePoint":{"line":461,"column":51},"line":461,"code":"    it('should synchronize changes after applyEdits', async () => {\n      let document = await workspace.document\n      let doc = TextDocument.create('untitled:1', 'txt', 1, document.getDocumentContent())\n      let disposables = []\n      document.onDocumentChange(e => {\n        TextDocument.update(doc, e.contentChanges.slice(), e.textDocument.version)\n      }, null, disposables)\n      await nvim.setLine('abc')\n      await document.patchChange()\n      await document.applyEdits([TextEdit.insert({ line: 0, character: 0 }, 'd')])\n      expect(doc.getText()).toBe('dabc\\n')\n      disposeAll(disposables)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider empty lines","suites":["Document","synchronize"],"updatePoint":{"line":475,"column":35},"line":475,"code":"    it('should consider empty lines', async () => {\n      let document = await workspace.document\n      await nvim.call('setline', [1, ['foo', 'bar']])\n      await document.patchChange()\n      await nvim.command('normal! ggdG')\n      await nvim.call('append', [1, ['foo', 'bar']])\n      await document.patchChange()\n      let lines = document.textDocument.lines\n      expect(lines).toEqual(['', 'foo', 'bar'])\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after make changes","suites":["Document","recreate"],"updatePoint":{"line":518,"column":45},"line":518,"code":"    it('should synchronize after make changes', async () => {\n      await assertDocument(async () => {\n        await nvim.call('setline', [1, 'a'])\n        await nvim.call('setline', [2, 'b'])\n      })\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after edit","suites":["Document","recreate"],"updatePoint":{"line":525,"column":37},"line":525,"code":"    it('should synchronize after edit', async () => {\n      await assertDocument(async doc => {\n        let fsPath = URI.parse(doc.uri).fsPath\n        fs.writeFileSync(fsPath, '{\\n}\\n', 'utf8')\n        await nvim.command('edit')\n        await nvim.call('deletebufline', [doc.bufnr, 1])\n        doc = await workspace.document\n        let content = doc.getDocumentContent()\n        expect(content).toBe('}\\n')\n      })\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize after force edit","suites":["Document","recreate"],"updatePoint":{"line":537,"column":43},"line":537,"code":"    it('should synchronize after force edit', async () => {\n      await assertDocument(async doc => {\n        let fsPath = URI.parse(doc.uri).fsPath\n        fs.writeFileSync(fsPath, '{\\n}\\n', 'utf8')\n        await nvim.command('edit')\n        await nvim.call('deletebufline', [doc.bufnr, 1])\n        doc = await workspace.document\n        let content = doc.getDocumentContent()\n        expect(content).toBe('}\\n')\n      })\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #1","suites":["Document","getEndOffset"],"updatePoint":{"line":551,"column":30},"line":551,"code":"    it('should getEndOffset #1', async () => {\n      let doc = await workspace.document\n      await setLines(doc, ['', ''])\n      let end = doc.getEndOffset(1, 1, false)\n      expect(end).toBe(2)\n      end = doc.getEndOffset(2, 1, false)\n      expect(end).toBe(1)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #2","suites":["Document","getEndOffset"],"updatePoint":{"line":560,"column":30},"line":560,"code":"    it('should getEndOffset #2', async () => {\n      let doc = await workspace.document\n      await setLines(doc, ['a', ''])\n      let end = doc.getEndOffset(1, 1, false)\n      expect(end).toBe(2)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #3","suites":["Document","getEndOffset"],"updatePoint":{"line":567,"column":30},"line":567,"code":"    it('should getEndOffset #3', async () => {\n      let doc = await workspace.document\n      await setLines(doc, ['a'])\n      let end = doc.getEndOffset(1, 2, false)\n      expect(end).toBe(1)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getEndOffset #4","suites":["Document","getEndOffset"],"updatePoint":{"line":574,"column":30},"line":574,"code":"    it('should getEndOffset #4', async () => {\n      let doc = await workspace.document\n      await setLines(doc, ['', ''])\n      let end = doc.getEndOffset(1, 1, false)\n      expect(end).toBe(3)\n      end = doc.getEndOffset(1, 1, true)\n      expect(end).toBe(4)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize content added","suites":["Document","applyEdits"],"updatePoint":{"line":585,"column":40},"line":585,"code":"    it('should synchronize content added', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo f')\n      await doc.synchronize()\n      await nvim.command('normal! ^2l')\n      void nvim.input('ar')\n      await doc.applyEdits([{\n        range: Range.create(0, 0, 0, 5),\n        newText: 'foo foo'\n      }])\n      await helper.waitFor('getline', ['.'], 'foor foo')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize content delete","suites":["Document","applyEdits"],"updatePoint":{"line":598,"column":41},"line":598,"code":"    it('should synchronize content delete', async () => {\n      let doc = await workspace.document\n      await doc.buffer.setLines(['foo f'], { start: 0, end: -1, strictIndexing: false })\n      await doc.synchronize()\n      await nvim.command('normal! gg^2l')\n      await nvim.input('a')\n      await nvim.input('<backspace>')\n      await helper.waitFor('getline', ['.'], 'fo f')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlights to document","suites":["Document","highlights"],"updatePoint":{"line":610,"column":41},"line":610,"code":"    it('should add highlights to document', async () => {\n      let buf = await nvim.buffer\n      await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n      let ranges = [\n        Range.create(0, 0, 0, 2),\n        Range.create(1, 0, 1, 3)\n      ]\n      let ns = await nvim.createNamespace('coc-highlight')\n      nvim.pauseNotification()\n      buf.highlightRanges('highlight', 'Search', ranges)\n      await nvim.resumeNotification()\n      let markers = await helper.getMarkers(buf.id, ns)\n      expect(markers.length).toBe(2)\n      nvim.pauseNotification()\n      buf.clearNamespace('highlight')\n      await nvim.resumeNotification()\n      markers = await helper.getMarkers(buf.id, ns)\n      expect(markers.length).toBe(0)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add/clear highlights of current window","suites":["Document","highlights"],"updatePoint":{"line":630,"column":53},"line":630,"code":"    it('should add/clear highlights of current window', async () => {\n      let buf = await nvim.buffer\n      await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n      let win = await nvim.window\n      let ranges = [\n        Range.create(0, 0, 0, 2),\n        Range.create(1, 0, 1, 3)\n      ]\n      let res = await win.highlightRanges('Search', ranges)\n      expect(res.length).toBe(2)\n      let matches = await nvim.call('getmatches', [win.id])\n      expect(matches.length).toBe(2)\n      nvim.pauseNotification()\n      win.clearMatchGroup('Search')\n      await nvim.resumeNotification()\n      matches = await nvim.call('getmatches', [win.id])\n      expect(matches.length).toBe(0)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clear matches by ids","suites":["Document","highlights"],"updatePoint":{"line":649,"column":35},"line":649,"code":"    it('should clear matches by ids', async () => {\n      let buf = await nvim.buffer\n      await buf.setLines(['', 'world'], { start: 0, end: -1, strictIndexing: false })\n      let win = await nvim.window\n      let ranges = [\n        Range.create(0, 0, 0, 2),\n        Range.create(1, 0, 1, 3)\n      ]\n      let ids = await win.highlightRanges('Search', ranges)\n      nvim.pauseNotification()\n      win.clearMatches(ids)\n      await nvim.resumeNotification()\n      let matches = await nvim.call('getmatches', [win.id])\n      expect(matches.length).toBe(0)\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fetch lines on TextChanged","suites":["Document","onTextChange"],"updatePoint":{"line":676,"column":41},"line":676,"code":"    it('should fetch lines on TextChanged', async () => {\n      let doc = await createVimDocument()\n      expect(doc.attached).toBe(true)\n      let disposable = events.on('TextChanged', (bufnr: number) => {\n        if (bufnr == doc.bufnr) doc.onTextChange('TextChanged')\n      })\n      let p = new Promise<void>(resolve => {\n        doc.onDocumentChange(() => {\n          resolve()\n        })\n      })\n      await nvim.setLine('foo')\n      await p\n      disposable.dispose()\n      let line = doc.getline(0)\n      expect(line).toBe('foo')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update on insert change","suites":["Document","onTextChange"],"updatePoint":{"line":694,"column":38},"line":694,"code":"    it('should update on insert change', async () => {\n\n      let doc = await createVimDocument()\n      workspace.documentsManager.buffers.set(doc.bufnr, doc)\n      await nvim.setLine('foo foot')\n      await doc.synchronize()\n      let disposables: Disposable[] = []\n        ;['TextChangedP', 'TextChangedI', 'TextChanged'].forEach(event => {\n          events.on(event as any, (bufnr: number, info) => {\n            if (bufnr === doc.bufnr) doc.onTextChange(event, info)\n          }, null, disposables)\n        })\n      await nvim.input('of')\n      await nvim.eval(`feedkeys(\"\\\\<C-n>\", 'in')`)\n      await helper.waitFor('pumvisible', [], 1)\n      let line = doc.getline(1)\n      expect(line).toBe('f')\n    })","file":"modules/document.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire InsertEnter and InsertLeave when necessary","suites":["register handler"],"updatePoint":{"line":11,"column":60},"line":11,"code":"  it('should fire InsertEnter and InsertLeave when necessary', async () => {\n    let fn = jest.fn()\n    events.on('InsertEnter', fn, null, disposables)\n    events.on('InsertLeave', fn, null, disposables)\n    expect(events.insertMode).toBe(false)\n    await events.fire('CursorMovedI', [1, [1, 1]])\n    expect(events.insertMode).toBe(true)\n    await events.fire('CursorMoved', [1, [1, 1]])\n    expect(events.insertMode).toBe(false)\n    expect(fn).toBeCalledTimes(2)\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register single handler","suites":["register handler"],"updatePoint":{"line":23,"column":36},"line":23,"code":"  it('should register single handler', async () => {\n    let fn = jest.fn()\n    let obj = {}\n    let disposable = events.on('BufEnter', fn, obj)\n    disposables.push(disposable)\n    await events.fire('BufEnter', ['a', 'b'])\n    expect(fn).toBeCalledWith('a', 'b')\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register multiple events","suites":["register handler"],"updatePoint":{"line":32,"column":37},"line":32,"code":"  it('should register multiple events', async () => {\n    let fn = jest.fn()\n    let disposable = events.on(['TaskExit', 'TaskStderr'], fn)\n    disposables.push(disposable)\n    await events.fire('TaskExit', [])\n    await events.fire('TaskStderr', [])\n    expect(fn).toBeCalledTimes(2)\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve after timeout","suites":["register handler"],"updatePoint":{"line":41,"column":34},"line":41,"code":"  it('should resolve after timeout', async () => {\n    let fn = (): Promise<void> => new Promise(resolve => {\n      setTimeout(() => {\n        resolve()\n      }, 20)\n    })\n    let disposable = events.on('FocusGained', fn, {})\n    disposables.push(disposable)\n    let ts = Date.now()\n    await events.fire('FocusGained', [])\n    expect(Date.now() - ts >= 10).toBe(true)\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit TextInsert after TextChangedI","suites":["register handler"],"updatePoint":{"line":54,"column":47},"line":54,"code":"  it('should emit TextInsert after TextChangedI', async () => {\n    let arr: string[] = []\n    events.on('TextInsert', () => {\n      arr.push('insert')\n    }, null, disposables)\n    events.on('TextChangedI', () => {\n      arr.push('change')\n    }, null, disposables)\n    await events.fire('InsertCharPre', ['i', 1])\n    await events.fire('TextChangedI', [1, {\n      lnum: 1,\n      col: 2,\n      pre: 'i',\n      changedtick: 1,\n      line: 'i'\n    }])\n    expect(events.lastChangeTs).toBeDefined()\n    await events.race(['TextInsert'])\n    expect(arr).toEqual(['change', 'insert'])\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should race events","suites":["register handler"],"updatePoint":{"line":75,"column":24},"line":75,"code":"  it('should race events', async () => {\n    let p = events.race(['InsertCharPre', 'TextChangedI', 'MenuPopupChanged'])\n    await events.fire('InsertCharPre', ['i', 1])\n    await events.fire('TextChangedI', [1, {\n      lnum: 1,\n      col: 2,\n      pre: 'i',\n      changedtick: 1\n    }])\n    let res = await p\n    expect(res.name).toBe('InsertCharPre')\n    res = await events.race(['TextChanged'], 50)\n    expect(res).toBeUndefined()\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should race same events","suites":["register handler"],"updatePoint":{"line":90,"column":29},"line":90,"code":"  it('should race same events', async () => {\n    let arr: any[] = []\n    void events.race(['TextChangedI'], 200).then(res => {\n      arr.push(res)\n    })\n    void events.race(['TextChangedI'], 200).then(res => {\n      arr.push(res)\n    })\n    await events.fire('TextChangedI', [2, {}])\n    expect(arr.length).toBe(2)\n    expect(arr.map(o => o.name)).toEqual(['TextChangedI', 'TextChangedI'])\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel race by CancellationToken","suites":["register handler"],"updatePoint":{"line":103,"column":45},"line":103,"code":"  it('should cancel race by CancellationToken', async () => {\n    let tokenSource = new CancellationTokenSource()\n    setTimeout(() => {\n      tokenSource.cancel()\n    }, 20)\n    let res = await events.race(['TextChanged'], tokenSource.token)\n    expect(res).toBeUndefined()\n  })","file":"modules/events.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create root when it does not exist","suites":["extensions"],"updatePoint":{"line":24,"column":47},"line":24,"code":"  it('should create root when it does not exist', async () => {\n    let root = path.join(os.tmpdir(), 'foo-bar')\n    let res = extensions.checkRoot(root)\n    expect(res).toBe(true)\n    expect(fs.existsSync(path.join(root, 'package.json'))).toBe(true)\n    let method = typeof fs['rmSync'] === 'function' ? 'rmSync' : 'rmdirSync'\n    fs[method](root, { recursive: true })\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove unexpted file","suites":["extensions"],"updatePoint":{"line":33,"column":33},"line":33,"code":"  it('should remove unexpted file', async () => {\n    let root = path.join(os.tmpdir(), 'foo-bar')\n    fs.writeFileSync(root, '')\n    let res = extensions.checkRoot(root)\n    expect(res).toBe(true)\n    expect(fs.existsSync(path.join(root, 'package.json'))).toBe(true)\n    let method = typeof fs['rmSync'] === 'function' ? 'rmSync' : 'rmdirSync'\n    fs[method](root, { recursive: true })\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load global extensions","suites":["extensions"],"updatePoint":{"line":43,"column":35},"line":43,"code":"  it('should load global extensions', async () => {\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter global extensions","suites":["extensions"],"updatePoint":{"line":48,"column":37},"line":48,"code":"  it('should filter global extensions', async () => {\n    let res = extensions.filterGlobalExtensions(['test', 'foo'])\n    expect(res).toEqual(['foo'])\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load local extensions from &rtp","suites":["extensions"],"updatePoint":{"line":53,"column":44},"line":53,"code":"  it('should load local extensions from &rtp', async () => {\n    let folder = path.resolve(__dirname, '../extensions/vim/local')\n    await nvim.command(`set runtimepath^=${folder}`)\n    await helper.wait(200)\n    let stat = extensions.getExtensionState('local')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall npm extension","suites":["extensions"],"updatePoint":{"line":61,"column":44},"line":61,"code":"  it('should install/uninstall npm extension', async () => {\n    await extensions.installExtensions(['coc-omni'])\n    let folder = path.join(__dirname, '../extensions/coc-omni')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await extensions.uninstallExtension(['coc-omni'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall extension by url","suites":["extensions"],"updatePoint":{"line":71,"column":47},"line":71,"code":"  it('should install/uninstall extension by url', async () => {\n    await extensions.installExtensions(['https://github.com/hollowtree/vscode-vue-snippets'])\n    let folder = path.join(__dirname, '../extensions/vue-snippets')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await extensions.uninstallExtension(['vue-snippets'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install/uninstall extension by url with branch","suites":["extensions"],"updatePoint":{"line":81,"column":59},"line":81,"code":"  it('should install/uninstall extension by url with branch', async () => {\n    await extensions.installExtensions(['https://github.com/sdras/vue-vscode-snippets@main'])\n    let folder = path.join(__dirname, '../extensions/vue-vscode-snippets')\n    let exists = fs.existsSync(folder)\n    expect(exists).toBe(true)\n    await extensions.uninstallExtension(['vue-vscode-snippets'])\n    exists = fs.existsSync(folder)\n    expect(exists).toBe(false)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get all extensions","suites":["extensions"],"updatePoint":{"line":91,"column":31},"line":91,"code":"  it('should get all extensions', () => {\n    let list = extensions.all\n    expect(Array.isArray(list)).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extensions stat","suites":["extensions"],"updatePoint":{"line":96,"column":32},"line":96,"code":"  it('should get extensions stat', async () => {\n    let stats = await extensions.getExtensionStates()\n    expect(stats.length).toBeGreaterThan(0)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle extension","suites":["extensions"],"updatePoint":{"line":101,"column":29},"line":101,"code":"  it('should toggle extension', async () => {\n    await extensions.toggleExtension('test')\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('disabled')\n    await extensions.toggleExtension('test')\n    stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reload extension","suites":["extensions"],"updatePoint":{"line":110,"column":29},"line":110,"code":"  it('should reload extension', async () => {\n    await extensions.reloadExtension('test')\n    await helper.wait(100)\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should has extension","suites":["extensions"],"updatePoint":{"line":117,"column":26},"line":117,"code":"  it('should has extension', () => {\n    let res = extensions.has('test')\n    expect(res).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be activated","suites":["extensions"],"updatePoint":{"line":122,"column":25},"line":122,"code":"  it('should be activated', async () => {\n    let res = extensions.has('test')\n    expect(res).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate & deactivate extension","suites":["extensions"],"updatePoint":{"line":127,"column":44},"line":127,"code":"  it('should activate & deactivate extension', async () => {\n    await extensions.deactivate('test')\n    let stat = extensions.getExtensionState('test')\n    expect(stat).toBe('loaded')\n    await extensions.activate('test')\n    stat = extensions.getExtensionState('test')\n    expect(stat).toBe('activated')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call extension API","suites":["extensions"],"updatePoint":{"line":136,"column":31},"line":136,"code":"  it('should call extension API', async () => {\n    let res = await extensions.call('test', 'echo', ['5'])\n    expect(res).toBe('5')\n    let p: string = await extensions.call('test', 'asAbsolutePath', ['..'])\n    expect(p.endsWith('extensions')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extension API","suites":["extensions"],"updatePoint":{"line":143,"column":30},"line":143,"code":"  it('should get extension API', () => {\n    let res = extensions.getExtensionApi('test') as any\n    expect(typeof res.echo).toBe('function')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load single file extension","suites":["extensions"],"updatePoint":{"line":148,"column":39},"line":148,"code":"  it('should load single file extension', async () => {\n    let filepath = path.join(__dirname, '../extensions/root.js')\n    await extensions.loadExtensionFile(filepath)\n    expect(extensions.has('single-root')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on language","suites":["extensions active events"],"updatePoint":{"line":182,"column":33},"line":182,"code":"  it('should activate on language', async () => {\n    let ext = createExtension('onLanguage:javascript')\n    expect(ext.isActive).toBe(false)\n    await nvim.command('edit /tmp/a.js')\n    await nvim.command('setf javascript')\n    await helper.wait(100)\n    expect(ext.isActive).toBe(true)\n    ext = createExtension('onLanguage:javascript')\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on command","suites":["extensions active events"],"updatePoint":{"line":193,"column":32},"line":193,"code":"  it('should activate on command', async () => {\n    let ext = createExtension('onCommand:test.echo')\n    await events.fire('Command', ['test.echo'])\n    await helper.wait(30)\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on workspace contains","suites":["extensions active events"],"updatePoint":{"line":200,"column":43},"line":200,"code":"  it('should activate on workspace contains', async () => {\n    let ext = createExtension('workspaceContains:package.json')\n    let root = path.resolve(__dirname, '../../..')\n    await nvim.command(`edit ${path.join(root, 'file.js')}`)\n    await helper.wait(100)\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should activate on file system","suites":["extensions active events"],"updatePoint":{"line":208,"column":36},"line":208,"code":"  it('should activate on file system', async () => {\n    let ext = createExtension('onFileSystem:zip')\n    await nvim.command('edit zip:///a')\n    await helper.wait(30)\n    expect(ext.isActive).toBe(true)\n    ext = createExtension('onFileSystem:zip')\n    expect(ext.isActive).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get extensionPath","suites":["extension properties"],"updatePoint":{"line":219,"column":30},"line":219,"code":"  it('should get extensionPath', () => {\n    let ext = extensions.getExtension('test')\n    let p = ext.extension.extensionPath\n    expect(p.endsWith('test')).toBe(true)\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate","suites":["extension properties"],"updatePoint":{"line":225,"column":23},"line":225,"code":"  it('should deactivate', async () => {\n    let ext = extensions.getExtension('test')\n    await ext.deactivate()\n    expect(ext.extension.isActive).toBe(false)\n    await extensions.activate('test')\n  })","file":"modules/extensions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fetch json","suites":["fetch"],"updatePoint":{"line":23,"column":23},"line":23,"code":"  it('should fetch json', async () => {\n    let res = await fetch('https://nodejs.org/dist/index.json')\n    expect(Array.isArray(res)).toBe(true)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fetch buffer","suites":["fetch"],"updatePoint":{"line":28,"column":25},"line":28,"code":"  it('should fetch buffer', async () => {\n    let res = await fetch('https://www.npmjs.com/', { buffer: true })\n    expect(Buffer.isBuffer(res)).toBe(true)\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw on request error","suites":["fetch"],"updatePoint":{"line":33,"column":35},"line":33,"code":"  it('should throw on request error', async () => {\n    let err\n    try {\n      await fetch('http://not_exists_org')\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should report valid proxy","suites":["fetch"],"updatePoint":{"line":43,"column":31},"line":43,"code":"  it('should report valid proxy', async () => {\n    let agent = getAgent(parse('http://google.com'), { proxyUrl: 'domain.com:1234' })\n    expect(agent).toBe(null)\n\n    agent = getAgent(parse('http://google.com'), { proxyUrl: 'https://domain.com:1234' })\n    let proxy = (agent as any).proxy\n    expect(proxy.host).toBe('domain.com')\n    expect(proxy.port).toBe(1234)\n\n    agent = getAgent(parse('http://google.com'), { proxyUrl: 'http://user:pass@domain.com:1234' })\n    proxy = (agent as any).proxy\n    expect(proxy.host).toBe('domain.com')\n    expect(proxy.port).toBe(1234)\n    expect(proxy.auth).toBe('user:pass')\n  })","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should download binary file","suites":["download"],"updatePoint":{"line":61,"column":33},"line":61,"code":"  it('should download binary file', async () => {\n    let url = 'https://registry.npmjs.org/coc-pairs/-/coc-pairs-1.2.13.tgz'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    let res = await download(url, { dest: tmpFolder })\n    expect(fs.existsSync(res)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should download tgz","suites":["download"],"updatePoint":{"line":69,"column":25},"line":69,"code":"  it('should download tgz', async () => {\n    let url = 'https://registry.npmjs.org/coc-pairs/-/coc-pairs-1.2.13.tgz'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    await download(url, { dest: tmpFolder, extract: 'untar' })\n    let file = path.join(tmpFolder, 'package.json')\n    expect(fs.existsSync(file)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 10000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should extract zip file","suites":["download"],"updatePoint":{"line":78,"column":29},"line":78,"code":"  it('should extract zip file', async () => {\n    let url = 'https://codeload.github.com/chemzqm/vimrc/zip/master'\n    let tmpFolder = await fs.mkdtemp(path.join(os.tmpdir(), 'coc-test'))\n    await download(url, { dest: tmpFolder, extract: 'unzip' })\n    let folder = path.join(tmpFolder, 'vimrc-master')\n    expect(fs.existsSync(folder)).toBe(true)\n    await fs.remove(tmpFolder)\n  }, 30000)","file":"modules/fetch.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show window","suites":["FloatFactory","show()"],"updatePoint":{"line":27,"column":26},"line":27,"code":"    it('should show window', async () => {\n      expect(floatFactory.window).toBe(null)\n      expect(floatFactory.buffer).toBe(null)\n      expect(floatFactory.bufnr).toBe(0)\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.show(docs, { rounded: true })\n      expect(floatFactory.window).toBeDefined()\n      expect(floatFactory.buffer).toBeDefined()\n      let hasFloat = await nvim.call('coc#float#has_float')\n      expect(hasFloat).toBe(1)\n      await floatFactory.show([{ filetype: 'txt', content: '' }])\n      expect(floatFactory.window).toBe(null)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create window","suites":["FloatFactory","show()"],"updatePoint":{"line":44,"column":28},"line":44,"code":"    it('should create window', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.create(docs)\n      expect(floatFactory.window).toBeDefined()\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should catch error on create","suites":["FloatFactory","show()"],"updatePoint":{"line":53,"column":36},"line":53,"code":"    it('should catch error on create', async () => {\n      let fn = floatFactory.unbind\n      floatFactory.unbind = () => {\n        throw new Error('bad')\n      }\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(81)\n      }]\n      await floatFactory.show(docs)\n      floatFactory.unbind = fn\n      let msg = await helper.getCmdline()\n      expect(msg).toMatch('bad')\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show only one window","suites":["FloatFactory","show()"],"updatePoint":{"line":68,"column":35},"line":68,"code":"    it('should show only one window', async () => {\n      await helper.edit()\n      await nvim.setLine('foo')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await Promise.all([\n        floatFactory.show(docs),\n        floatFactory.show(docs)\n      ])\n      let count = 0\n      let wins = await nvim.windows\n      for (let win of wins) {\n        let isFloat = await win.getVar('float')\n        if (isFloat) count++\n      }\n      expect(count).toBe(1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close window when close called after create","suites":["FloatFactory","show()"],"updatePoint":{"line":88,"column":58},"line":88,"code":"    it('should close window when close called after create', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      let p = floatFactory.show(docs)\n      await helper.wait(10)\n      floatFactory.close()\n      await p\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(false)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not create on visual mode","suites":["FloatFactory","show()"],"updatePoint":{"line":101,"column":40},"line":101,"code":"    it('should not create on visual mode', async () => {\n      await helper.createDocument()\n      await nvim.call('cursor', [1, 1])\n      await nvim.setLine('foo')\n      await nvim.command('normal! v$')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      await floatFactory.show(docs)\n      expect(floatFactory.window).toBe(null)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should allow select mode","suites":["FloatFactory","show()"],"updatePoint":{"line":114,"column":32},"line":114,"code":"    it('should allow select mode', async () => {\n      await helper.createDocument()\n      await snippetManager.insertSnippet('${1:foo}')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      let { mode } = await nvim.mode\n      expect(mode).toBe('s')\n      await nvim.input('<esc>')\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check retrigger","suites":["FloatFactory","checkRetrigger"],"updatePoint":{"line":129,"column":30},"line":129,"code":"    it('should check retrigger', async () => {\n      expect(floatFactory.checkRetrigger(99)).toBe(false)\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'\n      }]\n      await floatFactory.show(docs)\n      expect(floatFactory.checkRetrigger(99)).toBe(false)\n      expect(floatFactory.checkRetrigger(bufnr)).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should config maxHeight and maxWidth","suites":["FloatFactory","options"],"updatePoint":{"line":143,"column":44},"line":143,"code":"    it('should config maxHeight and maxWidth', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'f'.repeat(80) + '\\nbar',\n      }]\n      await floatFactory.show(docs, {\n        maxWidth: 20,\n        maxHeight: 1\n      })\n      let win = floatFactory.window\n      expect(win).toBeDefined()\n      let width = await win.width\n      let height = await win.height\n      expect(width).toBe(19)\n      expect(height).toBe(1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set border, title, highlight, borderhighlight, cursorline","suites":["FloatFactory","options"],"updatePoint":{"line":160,"column":72},"line":160,"code":"    it('should set border, title, highlight, borderhighlight, cursorline', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo\\nbar'\n      }]\n      await floatFactory.show(docs, {\n        border: [1, 1, 1, 1],\n        title: 'title',\n        highlight: 'Pmenu',\n        borderhighlight: 'MoreMsg',\n        cursorline: true\n      })\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect prefer top","suites":["FloatFactory","options"],"updatePoint":{"line":176,"column":33},"line":176,"code":"    it('should respect prefer top', async () => {\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo\\nbar'\n      }]\n      await nvim.call('append', [1, ['', '', '']])\n      await nvim.command('exe 4')\n      await floatFactory.show(docs, { preferTop: true })\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let pos = await nvim.call('nvim_win_get_position', [win.id])\n      expect(pos).toEqual([1, 0])\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide on BufEnter","suites":["FloatFactory","events"],"updatePoint":{"line":192,"column":31},"line":192,"code":"    it('should hide on BufEnter', async () => {\n      await helper.edit()\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      await nvim.command(`edit foo`)\n      await helper.waitFor('coc#float#has_float', [], 0)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide on CursorMoved","suites":["FloatFactory","events"],"updatePoint":{"line":203,"column":34},"line":203,"code":"    it('should hide on CursorMoved', async () => {\n      await helper.createDocument()\n      await nvim.setLine('foo')\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      await helper.waitFloat()\n      await nvim.input('$')\n      await helper.waitFor('coc#float#has_float', [], 0)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not hide when cursor position not changed","suites":["FloatFactory","events"],"updatePoint":{"line":216,"column":56},"line":216,"code":"    it('should not hide when cursor position not changed', async () => {\n      await helper.edit()\n      await nvim.setLine('foo')\n      let cursor = await nvim.eval(\"[line('.'), col('.')]\")\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs)\n      await nvim.call('cursor', [1, 2])\n      await helper.wait(10)\n      await nvim.call('cursor', cursor)\n      await helper.wait(10)\n      await helper.waitFor('coc#float#has_float', [], 1)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should preserve float when autohide disable and not overlap with pum","suites":["FloatFactory","events"],"updatePoint":{"line":232,"column":76},"line":232,"code":"    it('should preserve float when autohide disable and not overlap with pum', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setLines(['foo', '', '', '', 'f'], { start: 0, end: -1, strictIndexing: false })\n      await doc.synchronize()\n      await nvim.call('cursor', [5, 1])\n      await nvim.input('A')\n      await helper.wait(50)\n      nvim.call('coc#start', [], true)\n      await helper.waitPopup()\n      let docs: Documentation[] = [{\n        filetype: 'markdown',\n        content: 'foo'\n      }]\n      await floatFactory.show(docs, {\n        preferTop: true,\n        autoHide: false\n      })\n      let activated = await floatFactory.activated()\n      expect(activated).toBe(true)\n    })","file":"modules/floatFactory.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fs statAsync","suites":["fs","stat()"],"updatePoint":{"line":10,"column":20},"line":10,"code":"    it('fs statAsync', async () => {\n      let res = await statAsync(__filename)\n      expect(res).toBeDefined\n      expect(res.isFile()).toBe(true)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fs statAsync #1","suites":["fs","stat()"],"updatePoint":{"line":16,"column":23},"line":16,"code":"    it('fs statAsync #1', async () => {\n      let res = await statAsync(path.join(__dirname, 'file_not_exist'))\n      expect(res).toBeNull\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get filetype","suites":["fs","getFileType()"],"updatePoint":{"line":23,"column":27},"line":23,"code":"    it('should get filetype', async () => {\n      let res = await getFileType(__dirname)\n      expect(res).toBe(FileType.Directory)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check file in folder","suites":["fs","checkFolder()"],"updatePoint":{"line":30,"column":35},"line":30,"code":"    it('should check file in folder', async () => {\n      let cwd = process.cwd()\n      let res = await checkFolder(cwd, 'package.json')\n      expect(res).toBe(true)\n      res = await checkFolder(cwd, '**/schema.json')\n      expect(res).toBe(true)\n      res = await checkFolder(cwd, 'not_exists_fs')\n      expect(res).toBe(false)\n      res = await checkFolder(os.homedir(), 'not_exists_fs', 10)\n      expect(res).toBe(false)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename file","suites":["fs","renameAsync()"],"updatePoint":{"line":44,"column":26},"line":44,"code":"    it('should rename file', async () => {\n      let filepath = path.join(os.tmpdir(), 'foo')\n      await writeFile(filepath, 'foo')\n      let dest = path.join(os.tmpdir(), 'bar')\n      await renameAsync(filepath, dest)\n      let exists = fs.existsSync(dest)\n      expect(exists).toBe(true)\n      fs.unlinkSync(dest)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file does not exist","suites":["fs","renameAsync()"],"updatePoint":{"line":54,"column":45},"line":54,"code":"    it('should throw when file does not exist', async () => {\n      let err\n      try {\n        await renameAsync('/foo/bar', '/a')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file does not exist","suites":["fs","getFileLineCount"],"updatePoint":{"line":66,"column":45},"line":66,"code":"    it('should throw when file does not exist', async () => {\n      let err\n      try {\n        await getFileLineCount('/foo/bar')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be casesensitive","suites":["fs","sameFile"],"updatePoint":{"line":78,"column":31},"line":78,"code":"    it('should be casesensitive', () => {\n      expect(sameFile('/a', '/A', false)).toBe(false)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read line","suites":["fs","readFileLine"],"updatePoint":{"line":84,"column":24},"line":84,"code":"    it('should read line', async () => {\n      let res = await readFileLine(__filename, 1)\n      expect(res).toBeDefined()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file does not exist","suites":["fs","readFileLine"],"updatePoint":{"line":89,"column":45},"line":89,"code":"    it('should throw when file does not exist', async () => {\n      const fn = async () => {\n        await readFileLine(__filename + 'fooobar', 1)\n      }\n      await expect(fn()).rejects.toThrow(Error)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when file does not exist","suites":["fs","readFileLines"],"updatePoint":{"line":98,"column":45},"line":98,"code":"    it('should throw when file does not exist', async () => {\n      const fn = async () => {\n        await readFileLines(__filename + 'fooobar', 0, 3)\n      }\n      await expect(fn()).rejects.toThrow(Error)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read lines","suites":["fs","readFileLines"],"updatePoint":{"line":105,"column":25},"line":105,"code":"    it('should read lines', async () => {\n      let res = await readFileLines(__filename, 0, 1)\n      expect(res.length).toBe(2)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be not ignored","suites":["fs","isGitIgnored()"],"updatePoint":{"line":112,"column":29},"line":112,"code":"    it('should be not ignored', async () => {\n      let res = await isGitIgnored(__filename)\n      expect(res).toBeFalsy\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be ignored","suites":["fs","isGitIgnored()"],"updatePoint":{"line":117,"column":25},"line":117,"code":"    it('should be ignored', async () => {\n      let res = await isGitIgnored('')\n      expect(res).toBe(false)\n      res = await isGitIgnored(path.join(os.tmpdir(), 'foo'))\n      expect(res).toBe(false)\n      res = await isGitIgnored(path.resolve(__dirname, '../lib/index.js.map'))\n      expect(res).toBe(false)\n      res = await isGitIgnored(__filename)\n      expect(res).toBe(false)\n      let filepath = path.join(os.tmpdir(), 'foo')\n      fs.writeFileSync(filepath, '', { encoding: 'utf8' })\n      res = await isGitIgnored(filepath)\n      expect(res).toBe(false)\n      fs.unlinkSync(filepath)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support wildcard","suites":["fs","inDirectory"],"updatePoint":{"line":135,"column":31},"line":135,"code":"    it('should support wildcard', async () => {\n      let res = inDirectory(__dirname, ['**/file_not_exist.json'])\n      expect(res).toBe(false)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"get parentDirs","suites":["fs","parentDirs"],"updatePoint":{"line":142,"column":22},"line":142,"code":"    it('get parentDirs', () => {\n      let dirs = parentDirs('/a/b/c')\n      expect(dirs).toEqual(['/', '/a', '/a/b'])\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"check parent folder","suites":["fs","isParentFolder"],"updatePoint":{"line":149,"column":27},"line":149,"code":"    it('check parent folder', () => {\n      expect(isParentFolder('/a', '/a/b')).toBe(true)\n      expect(isParentFolder('/a/b', '/a/b/')).toBe(false)\n      expect(isParentFolder('/a/b', '/a/b')).toBe(false)\n      expect(isParentFolder('/a/b', '/a/b', true)).toBe(true)\n      expect(isParentFolder('//', '/', true)).toBe(true)\n      expect(isParentFolder('/a/b/', '/a/b/c', true)).toBe(true)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix driver","suites":["fs","fixDriver"],"updatePoint":{"line":160,"column":25},"line":160,"code":"    it('should fix driver', async () => {\n      expect(fixDriver('c:/foo', 'win32')).toBe('C:/foo')\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"resolve root consider root path","suites":["fs","resolveRoot"],"updatePoint":{"line":166,"column":39},"line":166,"code":"    it('resolve root consider root path', () => {\n      let res = resolveRoot(__dirname, ['.git'])\n      expect(res).toMatch('coc.nvim')\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore glob pattern","suites":["fs","resolveRoot"],"updatePoint":{"line":171,"column":34},"line":171,"code":"    it('should ignore glob pattern', () => {\n      let res = resolveRoot(__dirname, [path.basename(__filename)], undefined, false, false, [\"**/__tests__/**\"])\n      expect(res).toBeFalsy()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore glob pattern bottom up","suites":["fs","resolveRoot"],"updatePoint":{"line":176,"column":44},"line":176,"code":"    it('should ignore glob pattern bottom up', () => {\n      let res = resolveRoot(__dirname, [path.basename(__filename)], undefined, true, false, [\"**/__tests__/**\"])\n      expect(res).toBeFalsy()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve from parent folders","suites":["fs","resolveRoot"],"updatePoint":{"line":181,"column":42},"line":181,"code":"    it('should resolve from parent folders', () => {\n      let root = path.resolve(__dirname, '../extensions/snippet-sample')\n      let res = resolveRoot(root, ['package.json'])\n      expect(res.endsWith('coc.nvim')).toBe(true)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve from parent folders with bottom-up method","suites":["fs","resolveRoot"],"updatePoint":{"line":187,"column":64},"line":187,"code":"    it('should resolve from parent folders with bottom-up method', () => {\n      let root = path.resolve(__dirname, '../extensions/snippet-sample')\n      let res = resolveRoot(root, ['package.json'], null, true)\n      expect(res.endsWith('extensions')).toBe(true)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve to cwd","suites":["fs","resolveRoot"],"updatePoint":{"line":193,"column":29},"line":193,"code":"    it('should resolve to cwd', () => {\n      let root = path.resolve(__dirname, '../extensions/test/')\n      let res = resolveRoot(root, ['package.json'], root, false, true)\n      expect(res).toBe(root)\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve to root","suites":["fs","resolveRoot"],"updatePoint":{"line":199,"column":30},"line":199,"code":"    it('should resolve to root', () => {\n      let root = path.resolve(__dirname, '../extensions/test/')\n      let res = resolveRoot(root, ['package.json'], root, false, false)\n      expect(res).toBe(path.resolve(__dirname, '../../../'))\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve to home","suites":["fs","resolveRoot"],"updatePoint":{"line":205,"column":34},"line":205,"code":"    it('should not resolve to home', () => {\n      let res = resolveRoot(__dirname, ['.config'], undefined, false, false, [os.homedir()])\n      expect(res != os.homedir()).toBeTruthy()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"findUp by filename","suites":["fs","findUp"],"updatePoint":{"line":212,"column":26},"line":212,"code":"    it('findUp by filename', () => {\n      let filepath = findUp('package.json', __dirname)\n      expect(filepath).toMatch('coc.nvim')\n      filepath = findUp('not_exists', __dirname)\n      expect(filepath).toBeNull()\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"findUp by filenames","suites":["fs","findUp"],"updatePoint":{"line":219,"column":27},"line":219,"code":"    it('findUp by filenames', async () => {\n      let filepath = findUp(['src'], __dirname)\n      expect(filepath).toMatch('coc.nvim')\n    })","file":"modules/fs.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get registry url","suites":["Installer"],"updatePoint":{"line":12,"column":29},"line":12,"code":"  it('should get registry url', async () => {\n    fs.writeFileSync(rcfile, '', 'utf8')\n    expect(registryUrl()).toBe('https://registry.npmjs.org/')\n    fs.writeFileSync(rcfile, 'coc.nvim:registry=https://example.org', 'utf8')\n    expect(registryUrl()).toBe('https://example.org/')\n    fs.writeFileSync(rcfile, 'registry=https://example.org/', 'utf8')\n    expect(registryUrl()).toBe('https://example.org/')\n    if (fs.existsSync(rcfile)) {\n      fs.unlinkSync(rcfile)\n    }\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get install arguments","suites":["Installer"],"updatePoint":{"line":24,"column":34},"line":24,"code":"  it('should get install arguments', async () => {\n    expect(getInstallArguments('pnpm', 'https://github.com/')).toEqual(['install'])\n    expect(getInstallArguments('npm', '')).toEqual(['install', '--ignore-scripts', '--no-lockfile', '--production', '--legacy-peer-deps', '--no-global'])\n    expect(getInstallArguments('yarn', '')).toEqual(['install', '--ignore-scripts', '--no-lockfile', '--production', '--ignore-engines'])\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get dependencies","suites":["Installer"],"updatePoint":{"line":30,"column":29},"line":30,"code":"  it('should get dependencies', async () => {\n    expect(getDependencies('{}')).toEqual({})\n    expect(getDependencies('')).toEqual({})\n    expect(getDependencies('{\"dependencies\":{\"foo\": \"0.0.1\"}}')).toEqual({ foo: '0.0.1' })\n    expect(getDependencies('{\"dependencies\":{\"coc.nvim\": \"0.0.80\"}}')).toEqual({})\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse name & version","suites":["Installer"],"updatePoint":{"line":37,"column":33},"line":37,"code":"  it('should parse name & version', async () => {\n    const getInfo = (def: string): { name?: string, version?: string } => {\n      let installer = new Installer(__dirname, 'npm', def)\n      return installer.info\n    }\n    expect(getInfo('https://github.com')).toEqual({ name: undefined, version: undefined })\n    expect(getInfo('@yaegassy/coc-intelephense')).toEqual({ name: '@yaegassy/coc-intelephense', version: undefined })\n    expect(getInfo('@yaegassy/coc-intelephense@1.0.0')).toEqual({ name: '@yaegassy/coc-intelephense', version: '1.0.0' })\n    expect(getInfo('foo@1.0.0')).toEqual({ name: 'foo', version: '1.0.0' })\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for url that not supported","suites":["Installer"],"updatePoint":{"line":48,"column":45},"line":48,"code":"  it('should throw for url that not supported', async () => {\n    let installer = new Installer(__dirname, 'npm', 'https://example.com')\n    let fn = async () => {\n      await installer.getInfoFromUri()\n    }\n    await expect(fn()).rejects.toThrow(/not supported/)\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get info from url","suites":["Installer"],"updatePoint":{"line":56,"column":30},"line":56,"code":"  it('should get info from url', async () => {\n    let installer = new Installer(__dirname, 'npm', 'https://github.com/sdras/vue-vscode-snippets@main')\n    let info = await installer.getInfoFromUri()\n    expect(info['dist.tarball']).toMatch(/main.tar.gz/)\n  }, 10000)","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should skip install & update for symbolic folder","suites":["Installer"],"updatePoint":{"line":62,"column":54},"line":62,"code":"  it('should skip install & update for symbolic folder', async () => {\n    let tmpDir = path.join(os.tmpdir(), 'foo')\n    if (fs.existsSync(tmpDir)) {\n      fs.unlinkSync(tmpDir)\n    }\n    fs.symlinkSync(__dirname, tmpDir, 'dir')\n    let installer = new Installer(os.tmpdir(), 'npm', 'foo')\n    let res = await installer.doInstall({ name: 'foo' })\n    expect(res).toBe(false)\n    let val = await installer.update()\n    expect(val).toBeUndefined()\n    fs.unlinkSync(tmpDir)\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should skip update when current version is latest","suites":["Installer"],"updatePoint":{"line":76,"column":55},"line":76,"code":"  it('should skip update when current version is latest', async () => {\n    let dir = path.join(os.tmpdir(), 'coc-pairs')\n    let installer = new Installer(os.tmpdir(), 'npm', 'coc-pairs')\n    let info = await installer.getInfo()\n    fs.mkdirSync(dir)\n    fs.writeFileSync(path.join(dir, 'package.json'), `{\"version\": \"${info.version}\"}`, 'utf8')\n    let res = await installer.update()\n    expect(res).toBeUndefined()\n    rmdir(dir)\n  }, 20000)","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should skip update when version not satisfies","suites":["Installer"],"updatePoint":{"line":87,"column":51},"line":87,"code":"  it('should skip update when version not satisfies', async () => {\n    let v = workspace.version\n    Object.assign(workspace, { version: '0.0.10' })\n    let installer = new Installer(os.tmpdir(), 'npm', 'coc-pairs')\n    let dir = path.join(os.tmpdir(), 'coc-pairs')\n    fs.mkdirSync(dir, { recursive: true })\n    let fn = async () => {\n      await installer.update()\n    }\n    await expect(fn()).rejects.toThrow(/please update/)\n    Object.assign(workspace, { version: v })\n    rmdir(dir)\n  })","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update extension","suites":["Installer"],"updatePoint":{"line":101,"column":29},"line":101,"code":"  it('should update extension', async () => {\n    let installer = new Installer(os.tmpdir(), 'npm', 'coc-pairs')\n    let dir = path.join(os.tmpdir(), 'coc-pairs')\n    fs.mkdirSync(dir, { recursive: true })\n    let res = await installer.update()\n    expect(res).toMatch(/coc-pairs/)\n    rmdir(dir)\n  }, 30000)","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should install extension with dependencies","suites":["Installer"],"updatePoint":{"line":110,"column":48},"line":110,"code":"  it('should install extension with dependencies', async () => {\n    let npm: string\n    try {\n      npm = which.sync('pnpm')\n    } catch (e) {\n      npm = which.sync('npm')\n    }\n    // coc-html use typescript as dependencies\n    let installer = new Installer(os.tmpdir(), npm, 'coc-html')\n    await installer.install()\n    let folder = path.join(os.tmpdir(), 'coc-html')\n    expect(fs.existsSync(path.join(folder, 'node_modules/typescript/package.json'))).toBe(true)\n    fs.unlinkSync(path.join(os.tmpdir(), 'package.json'))\n    rmdir(folder)\n  }, 30000)","file":"modules/installer.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update and get","suites":["Memos"],"updatePoint":{"line":19,"column":27},"line":19,"code":"  it('should update and get', async () => {\n    let memo = memos.createMemento('x')\n    await memo.update('foo.bar', 'memo')\n    let res = memo.get<string>('foo.bar')\n    expect(res).toBe('memo')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get value for key if it does not exist","suites":["Memos"],"updatePoint":{"line":26,"column":51},"line":26,"code":"  it('should get value for key if it does not exist', async () => {\n    let memo = memos.createMemento('y')\n    let res = memo.get<any>('xyz')\n    expect(res).toBeUndefined()\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use defaultValue when it does not exist","suites":["Memos"],"updatePoint":{"line":32,"column":52},"line":32,"code":"  it('should use defaultValue when it does not exist', async () => {\n    let memo = memos.createMemento('y')\n    let res = memo.get<any>('f.o.o', 'default')\n    expect(res).toBe('default')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update multiple values","suites":["Memos"],"updatePoint":{"line":38,"column":35},"line":38,"code":"  it('should update multiple values', async () => {\n    let memo = memos.createMemento('x')\n    await memo.update('foo', 'x')\n    await memo.update('bar', 'y')\n    expect(memo.get<string>('foo')).toBe('x')\n    expect(memo.get<string>('bar')).toBe('y')\n  })","file":"modules/memos.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["Menu"],"updatePoint":{"line":24,"column":28},"line":24,"code":"  it('should cancel by <esc>', async () => {\n    menu = new Menu(nvim, { items: [{ text: 'foo' }, { text: 'bar', disabled: true }] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('<esc>')\n    let res = await p\n    expect(res).toBe(-1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel before float window shown","suites":["Menu"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  it('should cancel before float window shown', async () => {\n    let tokenSource: CancellationTokenSource = new CancellationTokenSource()\n    menu = new Menu(nvim, { items: [{ text: 'foo' }] }, tokenSource.token)\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    let promise = menu.show()\n    tokenSource.cancel()\n    await promise\n    let res = await p\n    expect(res).toBe(-1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support menu shortcut","suites":["Menu"],"updatePoint":{"line":53,"column":34},"line":53,"code":"  it('should support menu shortcut', async () => {\n    menu = new Menu(nvim, { items: [{ text: 'foo' }, { text: 'bar' }, { text: 'baba' }], shortcuts: true, title: 'Actions' })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('b')\n    let res = await p\n    expect(res).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support content","suites":["Menu"],"updatePoint":{"line":67,"column":28},"line":67,"code":"  it('should support content', async () => {\n    menu = new Menu(nvim, { items: [{ text: 'foo' }, { text: 'bar' }], content: 'content' })\n    await menu.show()\n    let lines = await menu.buffer.lines\n    menu.dispose()\n    expect(lines[0]).toBe('content')\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by CR","suites":["Menu"],"updatePoint":{"line":75,"column":25},"line":75,"code":"  it('should select by CR', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('j')\n    await helper.wait(30)\n    await nvim.input('<cr>')\n    let res = await p\n    expect(res).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show menu in center","suites":["Menu"],"updatePoint":{"line":91,"column":32},"line":91,"code":"  it('should show menu in center', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'], position: 'center' })\n    await menu.show()\n    expect(menu.buffer).toBeDefined()\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore invalid index","suites":["Menu"],"updatePoint":{"line":97,"column":33},"line":97,"code":"  it('should ignore invalid index', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('0')\n    await helper.wait(30)\n    let exists = await nvim.call('coc#float#has_float', [])\n    expect(exists).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by index number","suites":["Menu"],"updatePoint":{"line":107,"column":35},"line":107,"code":"  it('should select by index number', async () => {\n    menu = new Menu(nvim, { items: ['foo', 'bar'] })\n    let p = new Promise(resolve => {\n      menu.onDidClose(v => {\n        resolve(v)\n      })\n    })\n    await menu.show()\n    await helper.wait(30)\n    await nvim.input('1')\n    let res = await p\n    expect(res).toBe(0)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should navigate by j, k, g & G","suites":["Menu"],"updatePoint":{"line":121,"column":36},"line":121,"code":"  it('should navigate by j, k, g & G', async () => {\n    menu = new Menu(nvim, { items: ['one', 'two', 'three'] })\n    await menu.show()\n    await helper.wait(50)\n    let id = await nvim.call('GetFloatWin')\n    expect(id).toBeGreaterThan(0)\n    let win = nvim.createWindow(id)\n    await nvim.input('j')\n    await helper.wait(50)\n    let cursor = await win.cursor\n    expect(cursor[0]).toBe(2)\n    await nvim.input('k')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(1)\n    await nvim.input('G')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(3)\n    await nvim.input('g')\n    await helper.wait(50)\n    cursor = await win.cursor\n    expect(cursor[0]).toBe(1)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select by numbers","suites":["Menu"],"updatePoint":{"line":146,"column":30},"line":146,"code":"  it('should select by numbers', async () => {\n    let selected: number\n    menu = new Menu(nvim, { items: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] })\n    await menu.show()\n    let promise = new Promise(resolve => {\n      menu.onDidClose(n => {\n        selected = n\n        resolve(undefined)\n      })\n    })\n    await helper.wait(50)\n    await nvim.input('1')\n    await helper.wait(50)\n    await nvim.input('0')\n    await promise\n    expect(selected).toBe(9)\n  })","file":"modules/menu.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should load items","suites":["Mru"],"updatePoint":{"line":9,"column":23},"line":9,"code":"  it('should load items', async () => {\n    let mru = new Mru('test', root)\n    await mru.clean()\n    let res = await mru.load()\n    expect(res.length).toBe(0)\n    res = mru.loadSync()\n    expect(res.length).toBe(0)\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add items","suites":["Mru"],"updatePoint":{"line":18,"column":22},"line":18,"code":"  it('should add items', async () => {\n    let mru = new Mru('test', root)\n    await mru.add('a')\n    await mru.add('b')\n    let res = await mru.load()\n    expect(res.length).toBe(2)\n    await mru.clean()\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add when file it does not exist","suites":["Mru"],"updatePoint":{"line":27,"column":44},"line":27,"code":"  it('should add when file it does not exist', async () => {\n    let mru = new Mru('test', root)\n    await mru.clean()\n    await mru.add('a')\n    let res = await mru.load()\n    expect(res).toEqual(['a'])\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove item","suites":["Mru"],"updatePoint":{"line":35,"column":24},"line":35,"code":"  it('should remove item', async () => {\n    let mru = new Mru('test', root)\n    await mru.add('a')\n    await mru.remove('a')\n    let res = await mru.load()\n    expect(res.length).toBe(0)\n    await mru.clean()\n  })","file":"modules/mru.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"bad channel name","suites":["OutputChannel"],"updatePoint":{"line":21,"column":24},"line":21,"code":"  test('bad channel name', () => {\n    let err\n    try {\n      new OutputChannel('@', nvim)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.show(true)","suites":["OutputChannel"],"updatePoint":{"line":31,"column":32},"line":31,"code":"  test('outputChannel.show(true)', async () => {\n    await nvim.setLine('foo')\n    let c = new OutputChannel('0', nvim)\n    let bufnr = (await nvim.buffer).id\n    c.show(true)\n    await helper.waitFor('bufnr', ['%'], bufnr)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.show(false)","suites":["OutputChannel"],"updatePoint":{"line":39,"column":33},"line":39,"code":"  test('outputChannel.show(false)', async () => {\n    let c = new OutputChannel('1', nvim)\n    let bufnr = (await nvim.buffer).id\n    c.show()\n    await wait(100)\n    let nr = (await nvim.buffer).id\n    expect(bufnr).toBeLessThan(nr)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.appendLine()","suites":["OutputChannel"],"updatePoint":{"line":48,"column":34},"line":48,"code":"  test('outputChannel.appendLine()', async () => {\n    let c = new OutputChannel('2', nvim)\n    c.show()\n    await wait(100)\n    let buf = await nvim.buffer\n    c.appendLine('foo')\n    await helper.waitFor('eval', [`join(getbufline(${buf.id},1,'$'),'\\n')`], /foo/)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.append()","suites":["OutputChannel"],"updatePoint":{"line":57,"column":30},"line":57,"code":"  test('outputChannel.append()', async () => {\n    let c = new OutputChannel('3', nvim)\n    c.show(false)\n    await wait(60)\n    c.append('foo')\n    c.append('bar')\n    await wait(50)\n    let buf = await nvim.buffer\n    await helper.waitFor('eval', [`join(getbufline(${buf.id},1,'$'),'\\n')`], /foo/)\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"outputChannel.clear()","suites":["OutputChannel"],"updatePoint":{"line":68,"column":29},"line":68,"code":"  test('outputChannel.clear()', async () => {\n    let c = new OutputChannel('4', nvim)\n    c.show(false)\n    await wait(30)\n    let buf = await nvim.buffer\n    c.appendLine('foo')\n    c.appendLine('bar')\n    await wait(30)\n    c.clear()\n    await wait(30)\n    let lines = await buf.lines\n    let content = lines.join('')\n    expect(content).toBe('')\n  })","file":"modules/outputChannel.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog with buttons","suites":["Picker create"],"updatePoint":{"line":28,"column":37},"line":28,"code":"  it('should show dialog with buttons', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let id = await nvim.call('coc#float#get_related', [winid, 'buttons'])\n    expect(id).toBeGreaterThan(0)\n    let res = await nvim.call('sign_getplaced', [picker.buffer.id, { group: 'PopUpCocDialog' }])\n    expect(res[0].signs).toBeDefined()\n    expect(res[0].signs[0].name).toBe('CocCurrentLine')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel dialog when cancellation token requested","suites":["Picker create"],"updatePoint":{"line":39,"column":60},"line":39,"code":"  it('should cancel dialog when cancellation token requested', async () => {\n    let tokenSource = new CancellationTokenSource()\n    picker = new Picker(nvim, { title: 'title', items }, tokenSource.token)\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    tokenSource.cancel()\n    await helper.wait(50)\n    let res = await nvim.call('coc#float#valid', [winid])\n    expect(res).toBe(0)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection mouse click bracket","suites":["Picker key mappings"],"updatePoint":{"line":52,"column":49},"line":52,"code":"  it('should toggle selection mouse click bracket', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show()\n    await nvim.setVar('mouse_position', [winid, 1, 1])\n    await nvim.input('<LeftRelease>')\n    await helper.wait(50)\n    let buf = picker.buffer\n    let lines = await buf.getLines({ start: 0, end: 1, strictIndexing: false })\n    expect(lines[0]).toMatch(/^\\[x\\]/)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change current line on mouse click label","suites":["Picker key mappings"],"updatePoint":{"line":63,"column":53},"line":63,"code":"  it('should change current line on mouse click label', async () => {\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show()\n    await nvim.setVar('mouse_position', [winid, 2, 4])\n    await nvim.input('<LeftRelease>')\n    await helper.wait(50)\n    let buf = picker.buffer\n    let res = await nvim.call('sign_getplaced', [buf.id, { group: 'PopUpCocDialog' }])\n    expect(res[0].signs).toBeDefined()\n    expect(res[0].signs[0].name).toBe('CocCurrentLine')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel by <esc>","suites":["Picker key mappings"],"updatePoint":{"line":75,"column":28},"line":75,"code":"  it('should cancel by <esc>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.eval(`feedkeys(\"\\\\<Esc>\", 'in')`)\n    await helper.wait(200)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should confirm by <CR>","suites":["Picker key mappings"],"updatePoint":{"line":87,"column":28},"line":87,"code":"  it('should confirm by <CR>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.input('<space>')\n    await helper.wait(100)\n    await nvim.input('<cr>')\n    await nvim.command('redraw')\n    await helper.wait(200)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should move cursor by j, k, g & G","suites":["Picker key mappings"],"updatePoint":{"line":102,"column":39},"line":102,"code":"  it('should move cursor by j, k, g & G', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    function getSigns(): Promise<any> {\n      return nvim.call('sign_getplaced', [picker.buffer.id, { group: 'PopUpCocDialog' }])\n    }\n    let winid = await picker.show({ pickerButtons: true })\n    await helper.waitFloat()\n    expect(winid).toBeDefined()\n    await nvim.input('j')\n    await helper.wait(100)\n    let res = await getSigns()\n    expect(res[0].signs[0].lnum).toBe(2)\n    await nvim.input('k')\n    await helper.wait(100)\n    res = await getSigns()\n    expect(res[0].signs[0].lnum).toBe(1)\n    await nvim.input('G')\n    await helper.wait(100)\n    res = await getSigns()\n    expect(res[0].signs[0].lnum).toBe(2)\n    await nvim.input('g')\n    await helper.wait(100)\n    res = await getSigns()\n    expect(res[0].signs[0].lnum).toBe(1)\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection by <space>","suites":["Picker key mappings"],"updatePoint":{"line":129,"column":40},"line":129,"code":"  it('should toggle selection by <space>', async () => {\n    await helper.createDocument()\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ pickerButtons: true })\n    await helper.waitFloat()\n    expect(winid).toBeDefined()\n    let fn = jest.fn()\n    picker.onDidClose(fn)\n    await nvim.input('<space>')\n    await helper.wait(300)\n    await nvim.command('redraw')\n    let lines = await nvim.call('getbufline', [picker.buffer.id, 1])\n    expect(lines[0]).toMatch('[x]')\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll forward & backward","suites":["Picker key mappings"],"updatePoint":{"line":144,"column":38},"line":144,"code":"  it('should scroll forward & backward', async () => {\n    await helper.createDocument()\n    let items = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'].map(s => {\n      return { label: s }\n    })\n    picker = new Picker(nvim, { title: 'title', items })\n    let winid = await picker.show({ maxHeight: 3 })\n    expect(winid).toBeDefined()\n    await nvim.input('<C-f>')\n    await helper.wait(100)\n    let info = await nvim.call('getwininfo', [winid])\n    expect(info[0]).toBeDefined()\n    await nvim.input('<C-b>')\n    await helper.wait(100)\n    info = await nvim.call('getwininfo', [winid])\n    expect(info[0]).toBeDefined()\n  })","file":"modules/picker.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should generate help tags","suites":["help tags"],"updatePoint":{"line":22,"column":31},"line":22,"code":"  it('should generate help tags', async () => {\n    let root = workspace.pluginRoot\n    let dir = await nvim.call('fnameescape', path.join(root, 'doc'))\n    let res = await nvim.call('execute', `helptags ${dir}`) as string\n    expect(res.length).toBe(0)\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return jumpable","suites":["help tags"],"updatePoint":{"line":29,"column":28},"line":29,"code":"  it('should return jumpable', async () => {\n    let jumpable = await helper.plugin.cocAction('snippetCheck', false, true)\n    expect(jumpable).toBe(false)\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show CocInfo","suites":["help tags"],"updatePoint":{"line":34,"column":25},"line":34,"code":"  it('should show CocInfo', async () => {\n    await helper.doAction('showInfo')\n    let line = await nvim.line\n    expect(line).toMatch('version')\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ensure current document created","suites":["help tags"],"updatePoint":{"line":40,"column":44},"line":40,"code":"  it('should ensure current document created', async () => {\n    await nvim.command('tabe tmp.js')\n    let res = await helper.plugin.cocAction('ensureDocument')\n    expect(res).toBe(true)\n    let bufnr = await nvim.call('bufnr', ['%'])\n    let doc = workspace.getDocument(bufnr)\n    expect(doc).toBeDefined()\n  })","file":"modules/plugin.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when dialog not supported ","suites":["window","showQuickPick"],"updatePoint":{"line":61,"column":47},"line":61,"code":"    it('should throw when dialog not supported ', async () => {\n      Object.assign(workspace.env, { dialog: false })\n      disposables.push({\n        dispose: () => {\n          Object.assign(workspace.env, { dialog: true })\n        }\n      })\n      let fn = async () => {\n        await window.showQuickPick(['foo', 'bar'])\n      }\n      await expect(fn()).rejects.toThrow(Error)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve undefined when token cancelled","suites":["window","showQuickPick"],"updatePoint":{"line":74,"column":53},"line":74,"code":"    it('should resolve undefined when token cancelled', async () => {\n      let tokenSource = new CancellationTokenSource()\n      let token = tokenSource.token\n      tokenSource.cancel()\n      let res = await window.showQuickPick(['foo', 'bar'], undefined, token)\n      expect(res).toBeUndefined()\n      let release = await window.mutex.acquire()\n      tokenSource = new CancellationTokenSource()\n      token = tokenSource.token\n      let p = window.showQuickPick(['foo', 'bar'], undefined, token)\n      tokenSource.cancel()\n      release()\n      res = await p\n      expect(res).toBeUndefined()\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show quickfix with items or texts","suites":["window","showQuickPick"],"updatePoint":{"line":90,"column":48},"line":90,"code":"    it('should show quickfix with items or texts', async () => {\n      await testQuickPick(['foo', 'bar'], false, false, 'bar')\n      await testQuickPick(['foo', 'bar'], true, false, ['bar'])\n      await testQuickPick(['foo', 'bar'], false, true, undefined)\n      let items: QuickPickItem[] = [{ label: 'foo', description: 'desc' }, { label: 'bar', picked: true }]\n      await testQuickPick(items, false, false, { label: 'bar', picked: true })\n      await testQuickPick(items, true, false, [{ label: 'bar', picked: true }])\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use title option","suites":["window","showQuickPick"],"updatePoint":{"line":99,"column":31},"line":99,"code":"    it('should use title option', async () => {\n      let p = window.showQuickPick(['foo', 'bar'], { title: 'title' })\n      await helper.waitFloat()\n      let line = await getTitleLine()\n      expect(line).toMatch('title')\n      await nvim.input('<esc>')\n      await p\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match on description","suites":["window","showQuickPick"],"updatePoint":{"line":108,"column":35},"line":108,"code":"    it('should match on description', async () => {\n      let items: QuickPickItem[] = [{ label: 'foo', description: 'desc' }, { label: 'bar', picked: true }]\n      let p = window.showQuickPick(items, { matchOnDescription: true })\n      await helper.waitFloat()\n      await nvim.input('d')\n      await helper.wait(30)\n      await nvim.input('<cr>')\n      let res = await p\n      expect(res).toBeDefined()\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when unable to open input window","suites":["window","createQuickPick"],"updatePoint":{"line":121,"column":53},"line":121,"code":"    it('should throw when unable to open input window', async () => {\n      let fn = nvim.call\n      nvim.call = (...args: any) => {\n        if (args[0] === 'coc#dialog#create_prompt_win') return undefined\n        return fn.apply(nvim, args)\n      }\n      disposables.push(Disposable.create(() => {\n        nvim.call = fn\n      }))\n      let fun = async () => {\n        await window.createQuickPick({\n          items: [{ label: 'foo' }, { label: 'bar' }],\n        })\n      }\n      await expect(fun()).rejects.toThrow(/Unable to open/)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when unable to open list window","suites":["window","createQuickPick"],"updatePoint":{"line":138,"column":52},"line":138,"code":"    it('should throw when unable to open list window', async () => {\n      let fn = nvim.call\n      nvim.call = (...args: any) => {\n        if (args[0] === 'coc#dialog#create_list') return undefined\n        return fn.apply(nvim, args)\n      }\n      disposables.push(Disposable.create(() => {\n        nvim.call = fn\n      }))\n      let fun = async () => {\n        await window.createQuickPick({\n          items: [{ label: 'foo' }, { label: 'bar' }],\n        })\n      }\n      await expect(fun()).rejects.toThrow(/Unable to open/)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect initial value","suites":["window","createQuickPick"],"updatePoint":{"line":155,"column":36},"line":155,"code":"    it('should respect initial value', async () => {\n      await window.createQuickPick({\n        items: [{ label: 'foo' }, { label: 'bar' }],\n        value: 'value'\n      })\n      let winids = await nvim.call('coc#float#get_float_win_list') as number[]\n      let winid = Math.min(...winids)\n      let buf = await (nvim.createWindow(winid)).buffer\n      let lines = await buf.lines\n      expect(lines[0]).toBe('value')\n      await nvim.input('<esc>')\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect maxHeight","suites":["window","createQuickPick"],"updatePoint":{"line":168,"column":32},"line":168,"code":"    it('should respect maxHeight', async () => {\n      await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n        value: 'value',\n        maxHeight: 2\n      })\n      let winids = await nvim.call('coc#float#get_float_win_list') as number[]\n      let winid = Math.max(...winids)\n      let win = nvim.createWindow(winid)\n      let h = await win.height\n      expect(h).toBe(2)\n      await nvim.input('<esc>')\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should scroll by <C-f> and <C-b>","suites":["window","createQuickPick"],"updatePoint":{"line":182,"column":40},"line":182,"code":"    it('should scroll by <C-f> and <C-b>', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n        value: 'value',\n        maxHeight: 2\n      })\n      disposables.push(quickpick)\n      let winids = await nvim.call('coc#float#get_float_win_list') as number[]\n      let winid = Math.max(...winids)\n      await nvim.input('<C-f>')\n      await helper.wait(30)\n      await nvim.input('<C-f>')\n      await helper.wait(30)\n      let info = await nvim.call('getwininfo', [winid])\n      expect(info[0].topline).toBe(2)\n      await nvim.input('<C-b>')\n      await helper.wait(30)\n      await nvim.input('<C-b>')\n      await helper.wait(30)\n      info = await nvim.call('getwininfo', [winid])\n      expect(info[0].topline).toBe(1)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change current line by <C-j> and <C-k>","suites":["window","createQuickPick"],"updatePoint":{"line":205,"column":53},"line":205,"code":"    it('should change current line by <C-j> and <C-k>', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n        value: 'value',\n        maxHeight: 2\n      })\n      disposables.push(quickpick)\n      await nvim.input('<C-j>')\n      await helper.wait(30)\n      await nvim.input('<C-j>')\n      await helper.wait(30)\n      expect(quickpick.currIndex).toBe(2)\n      await nvim.input('<C-k>')\n      await helper.wait(30)\n      await nvim.input('<C-k>')\n      await helper.wait(30)\n      expect(quickpick.currIndex).toBe(0)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selected item by <C-space>","suites":["window","createQuickPick"],"updatePoint":{"line":224,"column":48},"line":224,"code":"    it('should toggle selected item by <C-space>', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n        value: 'value',\n        maxHeight: 2\n      })\n      disposables.push(quickpick)\n      await nvim.input('<C-sapce>')\n      await helper.wait(30)\n      await nvim.input('<C-k>')\n      await helper.wait(30)\n      await nvim.input('<C-sapce>')\n      await helper.wait(30)\n      expect(quickpick.selectedItems.length).toBe(0)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not handle events from other buffer","suites":["window","createQuickPick"],"updatePoint":{"line":240,"column":50},"line":240,"code":"    it('should not handle events from other buffer', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n      })\n      disposables.push(quickpick)\n      await events.fire('BufWinLeave', [quickpick.buffer.id + 1])\n      await events.fire('PromptKeyPress', [quickpick.buffer.id + 1, 'C-f'])\n      expect(quickpick.currIndex).toBe(0)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect configurations","suites":["window","createQuickPick"],"updatePoint":{"line":250,"column":37},"line":250,"code":"    it('should respect configurations', async () => {\n      helper.updateConfiguration('dialog.maxWidth', 30)\n      helper.updateConfiguration('dialog.rounded', false)\n      helper.updateConfiguration('dialog.floatHighlight', 'Normal')\n      helper.updateConfiguration('dialog.floatBorderHighlight', 'Normal')\n      helper.updateConfiguration('dialog.maxHeight', 2)\n      await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }, { label: 'three' }],\n        value: 'value',\n        maxHeight: 2\n      })\n      let winids = await nvim.call('coc#float#get_float_win_list') as number[]\n      let winid = Math.max(...winids)\n      let win = nvim.createWindow(winid)\n      let h = await win.height\n      expect(h).toBe(2)\n      await nvim.input('<esc>')\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change title","suites":["window","createQuickPick"],"updatePoint":{"line":269,"column":27},"line":269,"code":"    it('should change title', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }],\n        title: 'from'\n      })\n      disposables.push(quickpick)\n      quickpick.title = 'to'\n      await helper.wait(30)\n      expect(quickpick.title).toBe('to')\n      let line = await getTitleLine()\n      expect(line).toMatch(/to/)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change loading","suites":["window","createQuickPick"],"updatePoint":{"line":282,"column":29},"line":282,"code":"    it('should change loading', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }]\n      })\n      disposables.push(quickpick)\n      quickpick.loading = true\n      expect(quickpick.loading).toBe(true)\n      quickpick.loading = false\n      expect(quickpick.loading).toBe(false)\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change items","suites":["window","createQuickPick"],"updatePoint":{"line":293,"column":27},"line":293,"code":"    it('should change items', async () => {\n      let quickpick = await window.createQuickPick({\n        items: [{ label: 'one' }, { label: 'two' }]\n      })\n      disposables.push(quickpick)\n      quickpick.onDidChangeValue(val => {\n        if (val == '>') {\n          quickpick.items = [{ label: 'three' }]\n        }\n      })\n      await nvim.input('>')\n      await helper.wait(30)\n      let lines = await quickpick.buffer.lines\n      expect(lines).toEqual(['three'])\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change activeItems","suites":["window","createQuickPick"],"updatePoint":{"line":309,"column":33},"line":309,"code":"    it('should change activeItems', async () => {\n      let quickpick = await window.createQuickPick<QuickPickItem>({\n        items: [{ label: 'one' }]\n      })\n      disposables.push(quickpick)\n      quickpick.onDidChangeValue(val => {\n        if (val == 'f') {\n          quickpick.activeItems = [{ label: 'foo', description: 'description' }, { label: 'foot' }]\n        }\n      })\n      await nvim.input('f')\n      await helper.wait(30)\n      let lines = await quickpick.buffer.lines\n      expect(lines).toEqual(['foo description', 'foot'])\n    })","file":"modules/quickpick.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #1","suites":["Regions"],"updatePoint":{"line":4,"column":19},"line":4,"code":"  it('should add #1', async () => {\n    let r = new Regions()\n    r.add(1, 2)\n    r.add(1, 2)\n    expect(r.current).toEqual([1, 2])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #2","suites":["Regions"],"updatePoint":{"line":11,"column":19},"line":11,"code":"  it('should add #2', async () => {\n    let r = new Regions()\n    r.add(3, 4)\n    r.add(1, 5)\n    expect(r.current).toEqual([1, 5])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #3","suites":["Regions"],"updatePoint":{"line":18,"column":19},"line":18,"code":"  it('should add #3', async () => {\n    let r = new Regions()\n    r.add(2, 3)\n    r.add(1, 2)\n    expect(r.current).toEqual([1, 3])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #4","suites":["Regions"],"updatePoint":{"line":25,"column":19},"line":25,"code":"  it('should add #4', async () => {\n    let r = new Regions()\n    r.add(2, 5)\n    r.add(3, 4)\n    expect(r.current).toEqual([2, 5])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #5","suites":["Regions"],"updatePoint":{"line":32,"column":19},"line":32,"code":"  it('should add #5', async () => {\n    let r = new Regions()\n    r.add(3, 4)\n    r.add(1, 5)\n    expect(r.current).toEqual([1, 5])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #6","suites":["Regions"],"updatePoint":{"line":39,"column":19},"line":39,"code":"  it('should add #6', async () => {\n    let r = new Regions()\n    r.add(1, 2)\n    r.add(3, 5)\n    expect(r.current).toEqual([1, 2, 3, 5])\n    r.add(1, 8)\n    expect(r.current).toEqual([1, 8])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add #7","suites":["Regions"],"updatePoint":{"line":48,"column":19},"line":48,"code":"  it('should add #7', async () => {\n    let r = new Regions()\n    r.add(1, 2)\n    r.add(1, 5)\n    expect(r.current).toEqual([1, 5])\n    r.add(9, 10)\n    r.add(5, 6)\n    expect(r.current).toEqual([1, 6, 9, 10])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check range","suites":["Regions"],"updatePoint":{"line":58,"column":24},"line":58,"code":"  it('should check range', async () => {\n    let r = new Regions()\n    r.add(1, 2)\n    r.add(1, 5)\n    expect(r.has(3, 5)).toBe(true)\n    expect(r.has(3, 6)).toBe(false)\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge spans","suites":["Regions"],"updatePoint":{"line":66,"column":24},"line":66,"code":"  it('should merge spans', async () => {\n    expect(Regions.mergeSpans([[0, 1], [1, 2]])).toEqual([[0, 2]])\n    expect(Regions.mergeSpans([[0, 1], [2, 3]])).toEqual([[0, 1], [2, 3]])\n    expect(Regions.mergeSpans([[2, 3], [0, 1]])).toEqual([[2, 3], [0, 1]])\n    expect(Regions.mergeSpans([[1, 4], [0, 5]])).toEqual([[0, 5]])\n    expect(Regions.mergeSpans([[1, 4], [2, 3]])).toEqual([[1, 4]])\n    expect(Regions.mergeSpans([[1, 2], [2, 3], [3, 4]])).toEqual([[1, 4]])\n  })","file":"modules/regions.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should build SemanticTokensBuilder simple","suites":["SemanticTokensBuilder"],"updatePoint":{"line":17,"column":47},"line":17,"code":"  it('should build SemanticTokensBuilder simple', () => {\n    const builder = new SemanticTokensBuilder()\n    builder.push(1, 0, 5, 1, 1)\n    builder.push(1, 10, 4, 2, 2)\n    builder.push(2, 2, 3, 2, 2)\n    deepStrictEqual(toArr(builder.build().data), [\n      1, 0, 5, 1, 1,\n      0, 10, 4, 2, 2,\n      1, 2, 3, 2, 2\n    ])\n  })","file":"modules/semanticTokensBuilder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should build SemanticTokensBuilder no modifier","suites":["SemanticTokensBuilder"],"updatePoint":{"line":29,"column":52},"line":29,"code":"  it('should build SemanticTokensBuilder no modifier', () => {\n    const builder = new SemanticTokensBuilder()\n    builder.push(1, 0, 5, 1)\n    builder.push(1, 10, 4, 2)\n    builder.push(2, 2, 3, 2)\n    deepStrictEqual(toArr(builder.build().data), [\n      1, 0, 5, 1, 0,\n      0, 10, 4, 2, 0,\n      1, 2, 3, 2, 0\n    ])\n  })","file":"modules/semanticTokensBuilder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should build SemanticTokensBuilder out of order 1","suites":["SemanticTokensBuilder"],"updatePoint":{"line":41,"column":55},"line":41,"code":"  it('should build SemanticTokensBuilder out of order 1', () => {\n    const builder = new SemanticTokensBuilder()\n    builder.push(2, 0, 5, 1, 1)\n    builder.push(2, 10, 1, 2, 2)\n    builder.push(2, 15, 2, 3, 3)\n    builder.push(1, 0, 4, 4, 4)\n    deepStrictEqual(toArr(builder.build().data), [\n      1, 0, 4, 4, 4,\n      1, 0, 5, 1, 1,\n      0, 10, 1, 2, 2,\n      0, 5, 2, 3, 3\n    ])\n  })","file":"modules/semanticTokensBuilder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"SemanticTokensBuilder out of order 2","suites":["SemanticTokensBuilder"],"updatePoint":{"line":55,"column":42},"line":55,"code":"  it('SemanticTokensBuilder out of order 2', () => {\n    const builder = new SemanticTokensBuilder()\n    builder.push(2, 10, 5, 1, 1)\n    builder.push(2, 2, 4, 2, 2)\n    deepStrictEqual(toArr(builder.build().data), [\n      2, 2, 4, 2, 2,\n      0, 8, 5, 1, 1\n    ])\n  })","file":"modules/semanticTokensBuilder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"SemanticTokensBuilder with legend","suites":["SemanticTokensBuilder"],"updatePoint":{"line":65,"column":41},"line":65,"code":"  test('SemanticTokensBuilder with legend', () => {\n    const legend: SemanticTokensLegend = {\n      tokenTypes: ['aType', 'bType', 'cType', 'dType'],\n      tokenModifiers: ['mod0', 'mod1', 'mod2', 'mod3', 'mod4', 'mod5']\n    }\n    const builder = new SemanticTokensBuilder(legend)\n    builder.push(Range.create(1, 0, 1, 5), 'bType')\n    builder.push(Range.create(2, 0, 2, 4), 'cType', ['mod0', 'mod5'])\n    builder.push(Range.create(3, 0, 3, 3), 'dType', ['mod2', 'mod4'])\n    deepStrictEqual(toArr(builder.build().data), [\n      1, 0, 5, 1, 0,\n      1, 0, 4, 2, 1 | (1 << 5),\n      1, 0, 3, 3, (1 << 2) | (1 << 4)\n    ])\n  })","file":"modules/semanticTokensBuilder.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do document enter","suites":["sources"],"updatePoint":{"line":27,"column":30},"line":27,"code":"  it('should do document enter', async () => {\n    let fn = jest.fn()\n    let source: ISource = {\n      name: 'enter',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] }),\n      onEnter: fn\n    }\n    disposables.push(sources.addSource(source))\n    let buffer = await nvim.buffer\n    await events.fire('BufEnter', [buffer.id])\n    expect(fn).toBeCalled()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sources by split filetypes","suites":["sources"],"updatePoint":{"line":44,"column":43},"line":44,"code":"  it('should get sources by split filetypes', async () => {\n    disposables.push(sources.addSource({\n      name: 'foo',\n      filetypes: ['foo'],\n      enable: true,\n      doComplete: () => Promise.resolve({ items: [] }),\n    }))\n    disposables.push(sources.addSource({\n      name: 'bar',\n      filetypes: ['bar'],\n      enable: true,\n      doComplete: () => Promise.resolve({ items: [] }),\n    }))\n    let arr = sources.getNormalSources('foo.bar', 'file:///a')\n    let names = arr.map(s => s.name)\n    expect(names.includes('foo')).toBe(true)\n    expect(names.includes('bar')).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return source states","suites":["sources"],"updatePoint":{"line":63,"column":33},"line":63,"code":"  it('should return source states', () => {\n    let stats = sources.sourceStats()\n    expect(stats.length > 1).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle source state","suites":["sources"],"updatePoint":{"line":68,"column":32},"line":68,"code":"  it('should toggle source state', () => {\n    sources.toggleSource('around')\n    let s = sources.getSource('around')\n    expect(s.enable).toBe(false)\n    sources.toggleSource('around')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should has source","suites":["sources#has"],"updatePoint":{"line":78,"column":23},"line":78,"code":"  it('should has source', () => {\n    expect(sources.has('around')).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not has source","suites":["sources#has"],"updatePoint":{"line":82,"column":27},"line":82,"code":"  it('should not has source', () => {\n    expect(sources.has('NotExists')).toBe(false)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should refresh if possible","suites":["sources#refresh"],"updatePoint":{"line":88,"column":32},"line":88,"code":"  it('should refresh if possible', async () => {\n    let fn = jest.fn()\n    let source: ISource = {\n      name: 'refresh',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] }),\n      refresh: fn\n    }\n    disposables.push(sources.addSource(source))\n    await sources.refresh('refresh')\n    expect(fn).toBeCalled()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work if refresh not defined","suites":["sources#refresh"],"updatePoint":{"line":104,"column":40},"line":104,"code":"  it('should work if refresh not defined', async () => {\n    let source: ISource = {\n      name: 'refresh',\n      enable: true,\n      priority: 0,\n      sourceType: SourceType.Service,\n      triggerCharacters: [],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    await sources.refresh('refresh')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create source","suites":["sources#createSource"],"updatePoint":{"line":119,"column":26},"line":119,"code":"  it('should create source', async () => {\n    disposables.push(sources.createSource({\n      name: 'custom',\n      doComplete: () => Promise.resolve({\n        items: [{\n          word: 'custom'\n        }]\n      })\n    }))\n    await helper.createDocument()\n    await nvim.input('i')\n    await helper.wait(30)\n    await nvim.input('c')\n    let visible = await helper.visible('custom', 'custom')\n    expect(visible).toBe(true)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create vim source","suites":["sources#createSource"],"updatePoint":{"line":136,"column":30},"line":136,"code":"  it('should create vim source', async () => {\n    let folder = path.resolve(__dirname, '..')\n    await nvim.command(`set runtimepath+=${folder}`)\n    disposables.push({\n      dispose: () => {\n        nvim.command(`set runtimepath-=${folder}`, true)\n        sources.removeSource('email')\n      }\n    })\n    await helper.waitValue(() => {\n      return sources.has('email')\n    }, true)\n    await helper.createDocument()\n    await nvim.input('i@')\n    await helper.visible('foo@gmail.com')\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by filetypes","suites":["sources#getTriggerSources()"],"updatePoint":{"line":155,"column":32},"line":155,"code":"  it('should filter by filetypes', async () => {\n    let source: ISource = {\n      name: 'test',\n      enable: true,\n      priority: 0,\n      filetypes: ['javascript'],\n      sourceType: SourceType.Service,\n      triggerCharacters: ['#'],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    let res = sources.getTriggerSources('#', 'javascript', 'file:///tmp.js')\n    expect(res.find(o => o.name == 'test')).toBeDefined()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter by documentSelector","suites":["sources#getTriggerSources()"],"updatePoint":{"line":170,"column":39},"line":170,"code":"  it('should filter by documentSelector', async () => {\n    let source: ISource = {\n      name: 'test',\n      enable: true,\n      priority: 0,\n      documentSelector: [{ language: 'javascript' }],\n      sourceType: SourceType.Service,\n      triggerCharacters: ['#'],\n      doComplete: () => Promise.resolve({ items: [] })\n    }\n    disposables.push(sources.addSource(source))\n    let res = sources.getTriggerSources('#', 'javascript', 'file:///tmp.js')\n    expect(res.find(o => o.name == 'test')).toBeDefined()\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter disabled sources","suites":["sources#getTriggerSources()"],"updatePoint":{"line":185,"column":36},"line":185,"code":"  it('should filter disabled sources', async () => {\n    await nvim.setLine('foo bar ')\n    let buf = await nvim.buffer\n    await buf.setVar('coc_disabled_sources', ['around', 'buffer', 'file'])\n    await nvim.input('Af')\n    await helper.wait(30)\n    await nvim.input('/')\n    await helper.wait(100)\n    let visible = await nvim.call('pumvisible')\n    expect(visible).toBe(0)\n  })","file":"modules/sources.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start task","suites":["task test"],"updatePoint":{"line":23,"column":23},"line":23,"code":"  it('should start task', async () => {\n    let task = workspace.createTask('sleep')\n    disposables.push(task)\n    let started = await task.start({ cmd: 'sleep', args: ['50'] })\n    expect(started).toBe(true)\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should stop task","suites":["task test"],"updatePoint":{"line":30,"column":22},"line":30,"code":"  it('should stop task', async () => {\n    let task = workspace.createTask('sleep')\n    disposables.push(task)\n    await task.start({ cmd: 'sleep', args: ['50'] })\n    await task.stop()\n    let running = await task.running\n    expect(running).toBe(false)\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit exit event","suites":["task test"],"updatePoint":{"line":39,"column":28},"line":39,"code":"  it('should emit exit event', async () => {\n    let fn = jest.fn()\n    let task = workspace.createTask('sleep')\n    disposables.push(task)\n    task.onExit(fn)\n    await task.start({ cmd: 'sleep', args: ['50'] })\n    await helper.wait(10)\n    await task.stop()\n    expect(fn).toBeCalled()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit stdout event","suites":["task test"],"updatePoint":{"line":50,"column":30},"line":50,"code":"  it('should emit stdout event', async () => {\n    let file = await createTmpFile('echo foo')\n    let task = workspace.createTask('echo')\n    disposables.push(task)\n    let p = new Promise<string[]>(resolve => {\n      let lines: string[] = []\n      task.onStdout(stdout => {\n        lines.push(...stdout)\n      })\n      task.onExit(() => {\n        resolve(lines)\n      })\n    })\n    await task.start({ cmd: '/bin/sh', args: [file] })\n    let lines = await p\n    expect(lines).toEqual(['foo'])\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change environment variables","suites":["task test"],"updatePoint":{"line":68,"column":41},"line":68,"code":"  it('should change environment variables', async () => {\n    let file = await createTmpFile('echo $NODE_ENV\\necho $COC_NVIM_TEST')\n    let task = workspace.createTask('ENV')\n    disposables.push(task)\n    let lines: string[] = []\n    task.onStdout(arr => {\n      lines.push(...arr)\n    })\n    await task.start({\n      cmd: '/bin/sh',\n      args: [file],\n      env: {\n        NODE_ENV: 'production',\n        COC_NVIM_TEST: 'yes'\n      }\n    })\n    await new Promise<void>(resolve => {\n      task.onExit(() => {\n        resolve()\n      })\n    })\n    expect(lines).toEqual(['production', 'yes'])\n    let res = await nvim.call('getenv', 'COC_NVIM_TEST')\n    expect(res).toBeNull()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should receive stdout lines as expected","suites":["task test"],"updatePoint":{"line":94,"column":45},"line":94,"code":"  it('should receive stdout lines as expected', async () => {\n    let file = await createTmpFile('echo 3\\necho \"\"\\necho 4')\n    let task = workspace.createTask('ENV')\n    let p = new Promise(resolve => {\n      let lines: string[] = []\n      task.onStdout(arr => {\n        lines.push(...arr)\n      })\n      task.onExit(() => {\n        resolve(lines)\n      })\n    })\n    await task.start({ cmd: '/bin/sh', args: [file] })\n    let lines = await p\n    expect(lines).toEqual(['3', '', '4'])\n    task.dispose()\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit stderr event","suites":["task test"],"updatePoint":{"line":112,"column":30},"line":112,"code":"  it('should emit stderr event', async () => {\n    let file = await createTmpFile('console.error(\"start\\\\n\\\\nend\");')\n    let task = workspace.createTask('error')\n    disposables.push(task)\n    let p = new Promise<string[]>(resolve => {\n      let lines: string[] = []\n      task.onStderr(arr => {\n        lines.push(...arr)\n      })\n      task.onExit(() => {\n        resolve(lines)\n      })\n    })\n    await task.start({ cmd: 'node', args: [file] })\n    let lines = await p\n    expect(lines).toEqual(['start', '', 'end'])\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not receive event from other task","suites":["task test"],"updatePoint":{"line":130,"column":46},"line":130,"code":"  it('should not receive event from other task', async () => {\n    let task1 = workspace.createTask('one')\n    disposables.push(task1)\n    let count = 0\n    let cb = () => {\n      count++\n    }\n    task1.onExit(cb)\n    task1.onStderr(cb)\n    task1.onStdout(cb)\n    let file = await createTmpFile('console.log(\"start\");console.error(\"end\");')\n    let task = workspace.createTask('error')\n    await task.start({ cmd: 'node', args: [file] })\n    let promise = new Promise<void>(resolve => {\n      task.onExit(() => {\n        resolve(undefined)\n      })\n    })\n    await promise\n    expect(count).toBe(0)\n  })","file":"modules/task.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get name","suites":["terminal properties"],"updatePoint":{"line":20,"column":21},"line":20,"code":"  it('should get name', () => {\n    let name = terminal.name\n    expect(name).toBe('sh')\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have correct cwd and env","suites":["terminal properties"],"updatePoint":{"line":25,"column":37},"line":25,"code":"  it('should have correct cwd and env', async () => {\n    let bufnr = terminal.bufnr\n    terminal.sendText('echo $PWD')\n    await helper.wait(300)\n    let lines = await nvim.call('getbufline', [bufnr, 1, '$']) as string[]\n    expect(lines[0].trim().length).toBeGreaterThan(0)\n    terminal.sendText('echo $COC_TERMINAL')\n    await helper.wait(300)\n    lines = await nvim.call('getbufline', [bufnr, 1, '$']) as string[]\n    expect(lines.includes(`option '-term'`)).toBe(true)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get pid","suites":["terminal properties"],"updatePoint":{"line":37,"column":20},"line":37,"code":"  it('should get pid', async () => {\n    let pid = await terminal.processId\n    expect(typeof pid).toBe('number')\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hide terminal window","suites":["terminal properties"],"updatePoint":{"line":42,"column":33},"line":42,"code":"  it('should hide terminal window', async () => {\n    await terminal.hide()\n    let winnr = await nvim.call('bufwinnr', terminal.bufnr)\n    expect(winnr).toBe(-1)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show terminal window","suites":["terminal properties"],"updatePoint":{"line":48,"column":33},"line":48,"code":"  it('should show terminal window', async () => {\n    await terminal.show()\n    let winnr = await nvim.call('bufwinnr', terminal.bufnr)\n    expect(winnr != -1).toBe(true)\n  })","file":"modules/terminal.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create logger","suites":["factory"],"updatePoint":{"line":49,"column":26},"line":49,"code":"  it('should create logger', async () => {\n    let file = path.join(__dirname, 'sandbox/log.js')\n    let fn = jest.fn()\n    const sandbox = factory.createSandbox(file, {\n      log: () => {\n        fn()\n      },\n      info: () => {\n        fn()\n      },\n      error: () => {\n        fn()\n      },\n      debug: () => {\n        fn()\n      },\n      warn: () => {\n        fn()\n      }\n    })\n    let res = vm.runInContext(`\nconsole.log('log')\nconsole.debug('debug')\nconsole.info('info')\nconsole.error('error')\nconsole.warn('warn')`, sandbox)\n    expect(fn).toBeCalledTimes(5)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw process.chdir","suites":["factory"],"updatePoint":{"line":78,"column":36},"line":78,"code":"  it('should not throw process.chdir', async () => {\n    let file = path.join(__dirname, 'sandbox/log.js')\n    const sandbox = factory.createSandbox(file, emptyLogger)\n    let res = vm.runInContext(`process.chdir()`, sandbox)\n    expect(res).toBeUndefined()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw with umask","suites":["factory"],"updatePoint":{"line":85,"column":29},"line":85,"code":"  it('should throw with umask', async () => {\n    let file = path.join(__dirname, 'sandbox/log.js')\n    const sandbox = factory.createSandbox(file, emptyLogger)\n    let res = vm.runInContext(`process.umask()`, sandbox)\n    expect(typeof res).toBe('number')\n    let err\n    try {\n      res = vm.runInContext(`process.umask(18)`, sandbox)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw with process.exit","suites":["factory"],"updatePoint":{"line":99,"column":36},"line":99,"code":"  it('should throw with process.exit', async () => {\n    let file = path.join(__dirname, 'sandbox/log.js')\n    const sandbox = factory.createSandbox(file, emptyLogger)\n    let err\n    try {\n      vm.runInContext(`process.exit()`, sandbox)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should hook require","suites":["factory"],"updatePoint":{"line":111,"column":25},"line":111,"code":"  it('should hook require', async () => {\n    let filename = path.join(__dirname, 'sandbox/log.js')\n    const sandbox = factory.createSandbox(filename, emptyLogger)\n    let fn = factory.compileInSandbox(sandbox)\n    let obj: any = {}\n    fn.apply(obj, [`const {wait} = require('coc.nvim')\\nmodule.exports = wait`, filename])\n    expect(typeof obj.exports).toBe('function')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get log file","suites":["logger"],"updatePoint":{"line":122,"column":25},"line":122,"code":"  it('should get log file', async () => {\n    let val = process.env.NVIM_COC_LOG_FILE\n    process.env.NVIM_COC_LOG_FILE = ''\n    let logger = createLogger('')\n    expect(logger.getLogFile()).toBeDefined()\n    process.env.XDG_RUNTIME_DIR = ''\n    expect(logger.getLogFile()).toBeDefined()\n    process.env.NVIM_COC_LOG_FILE = val\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getChangedPosition","suites":["textedit"],"updatePoint":{"line":145,"column":26},"line":145,"code":"  test('getChangedPosition', () => {\n    const assertPosition = (start, edit, arr) => {\n      let res = textedits.getChangedPosition(start, edit)\n      expect(res).toEqual(Position.create(arr[0], arr[1]))\n    }\n    let pos = Position.create(0, 0)\n    assertPosition(pos, TextEdit.insert(pos, 'abc'), [0, 3])\n    assertPosition(pos, TextEdit.insert(pos, 'a\\nb\\nc'), [2, 1])\n    let edit = TextEdit.replace(Range.create(pos, Position.create(0, 3)), 'abc')\n    assertPosition(pos, edit, [0, 0])\n    pos = Position.create(0, 1)\n    let r = Range.create(addPosition(pos, 0, -1), pos)\n    assertPosition(pos, TextEdit.replace(r, 'a\\nb\\n'), [2, -1])\n    pos = Position.create(1, 3)\n    edit = TextEdit.replace(Range.create(Position.create(0, 1), Position.create(1, 0)), 'abc')\n    assertPosition(pos, edit, [-1, 4])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getChangedLineCount","suites":["textedit"],"updatePoint":{"line":163,"column":27},"line":163,"code":"  test('getChangedLineCount', () => {\n    let pos = Position.create(5, 0)\n    let edits: TextEdit[] = [\n      TextEdit.replace(Range.create(0, 1, 1, 0), ''),\n      TextEdit.replace(Range.create(2, 1, 3, 0), ''),\n      TextEdit.replace(Range.create(10, 1, 12, 0), 'foo'),\n    ]\n    expect(textedits.getChangedLineCount(pos, edits)).toBe(-2)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getPosition()","suites":["textedit"],"updatePoint":{"line":173,"column":21},"line":173,"code":"  test('getPosition()', () => {\n    let pos = Position.create(1, 3)\n    const assertChange = (rl, rc, el, ec, text, val): void => {\n      let edit = TextEdit.replace(Range.create(rl, rc, el, ec), text)\n      let res = textedits.getPosition(pos, edit)\n      expect(res).toEqual(val)\n    }\n    assertChange(0, 1, 1, 0, 'abc', Position.create(0, 7))\n    assertChange(0, 1, 1, 1, 'abc', Position.create(0, 6))\n    assertChange(0, 1, 1, 0, 'abc\\n', Position.create(1, 3))\n    assertChange(1, 1, 1, 2, '', Position.create(1, 2))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getStartLine()","suites":["textedit"],"updatePoint":{"line":186,"column":22},"line":186,"code":"  test('getStartLine()', () => {\n    const assertLine = (rl, rc, el, ec, text, val: number): void => {\n      let edit = TextEdit.replace(Range.create(rl, rc, el, ec), text)\n      let res = textedits.getStartLine(edit)\n      expect(res).toBe(val)\n    }\n    assertLine(0, 0, 0, 0, 'abc\\n', -1)\n    assertLine(1, 0, 1, 0, 'd\\n', 0)\n    assertLine(0, 0, 0, 0, 'abc', 0)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"getPositionFromEdits()","suites":["textedit"],"updatePoint":{"line":197,"column":30},"line":197,"code":"  test('getPositionFromEdits()', async () => {\n    const assertEdits = (pos, edits, exp: [number, number]) => {\n      let res = textedits.getPositionFromEdits(pos, edits)\n      expect(res).toEqual(Position.create(exp[0], exp[1]))\n    }\n    let pos = Position.create(5, 1)\n    let edits: TextEdit[] = [\n      TextEdit.replace(Range.create(0, 3, 1, 0), ''),\n      TextEdit.replace(Range.create(2, 4, 3, 0), ''),\n      TextEdit.replace(Range.create(3, 4, 4, 0), ''),\n      TextEdit.replace(Range.create(4, 1, 5, 0), ''),\n      TextEdit.replace(Range.create(6, 1, 6, 1), 'foo'),\n    ]\n    assertEdits(pos, edits, [1, 10])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check empty workspaceEdit","suites":["textedit"],"updatePoint":{"line":213,"column":38},"line":213,"code":"  it('should check empty workspaceEdit', async () => {\n    let workspaceEdit: WorkspaceEdit = createEdit('untitled:/1')\n    expect(textedits.emptyWorkspaceEdit(workspaceEdit)).toBe(false)\n    expect(textedits.emptyWorkspaceEdit({ documentChanges: [] })).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check empty TextEdit","suites":["textedit"],"updatePoint":{"line":219,"column":33},"line":219,"code":"  it('should check empty TextEdit', async () => {\n    expect(textedits.emptyTextEdit(TextEdit.insert(Position.create(0, 0), ''))).toBe(true)\n    expect(textedits.emptyTextEdit(TextEdit.insert(Position.create(0, 0), 'a'))).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get well formed edit","suites":["textedit"],"updatePoint":{"line":224,"column":33},"line":224,"code":"  it('should get well formed edit', async () => {\n    let r = Range.create(1, 0, 0, 0)\n    let edit: TextEdit = { range: r, newText: 'foo' }\n    let res = textedits.getWellformedEdit(edit)\n    expect(res.range).toEqual(Range.create(0, 0, 1, 0))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check line count change","suites":["textedit"],"updatePoint":{"line":231,"column":36},"line":231,"code":"  it('should check line count change', async () => {\n    let r = Range.create(0, 0, 0, 5)\n    let edit: TextEdit = { range: r, newText: 'foo' }\n    expect(textedits.lineCountChange(edit)).toBe(0)\n    edit = { range: Range.create(0, 0, 1, 0), newText: 'foo' }\n    expect(textedits.lineCountChange(edit)).toBe(-1)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter and sort textedits","suites":["textedit"],"updatePoint":{"line":239,"column":38},"line":239,"code":"  it('should filter and sort textedits', async () => {\n    let doc = createTextDocument(['foo'])\n    expect(textedits.filterSortEdits(doc, [TextEdit.insert(Position.create(0, 0), 'a\\r\\nb')])).toEqual([\n      TextEdit.insert(Position.create(0, 0), 'a\\nb')\n    ])\n    expect(textedits.filterSortEdits(doc, [TextEdit.replace(Range.create(0, 0, 0, 3), 'foo')])).toEqual([])\n    expect(textedits.filterSortEdits(doc, [\n      TextEdit.insert(Position.create(0, 1), 'b'),\n      TextEdit.insert(Position.create(0, 0), 'a'),\n    ])).toEqual([\n      TextEdit.insert(Position.create(0, 0), 'a'),\n      TextEdit.insert(Position.create(0, 1), 'b'),\n    ])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge textedits #1","suites":["textedit"],"updatePoint":{"line":254,"column":31},"line":254,"code":"  it('should merge textedits #1', async () => {\n    let edits = [toEdit(0, 0, 0, 0, 'foo'), toEdit(0, 1, 0, 1, 'bar')]\n    let lines = ['ab']\n    let res = textedits.mergeTextEdits(edits, lines, ['fooabarb'])\n    expect(res).toEqual(toEdit(0, 0, 0, 1, 'fooabar'))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge textedits #2","suites":["textedit"],"updatePoint":{"line":261,"column":31},"line":261,"code":"  it('should merge textedits #2', async () => {\n    let edits = [toEdit(0, 0, 1, 0, 'foo\\n')]\n    let lines = ['bar']\n    let res = textedits.mergeTextEdits(edits, lines, ['foo'])\n    expect(res).toEqual(toEdit(0, 0, 1, 0, 'foo\\n'))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should merge textedits #3","suites":["textedit"],"updatePoint":{"line":268,"column":31},"line":268,"code":"  it('should merge textedits #3', async () => {\n    let edits = [toEdit(0, 0, 0, 1, 'd'), toEdit(1, 0, 1, 1, 'e'), toEdit(2, 0, 3, 0, 'f\\n')]\n    let lines = ['a', 'b', 'c']\n    let res = textedits.mergeTextEdits(edits, lines, ['d', 'e', 'f'])\n    expect(res).toEqual(toEdit(0, 0, 3, 0, 'd\\ne\\nf\\n'))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get case","suites":["strings"],"updatePoint":{"line":277,"column":21},"line":277,"code":"  it('should get case', async () => {\n    expect(strings.getCase('a'.charCodeAt(0))).toBe(1)\n    expect(strings.getCase('A'.charCodeAt(0))).toBe(2)\n    expect(strings.getCase('#'.charCodeAt(0))).toBe(0)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get next word code","suites":["strings"],"updatePoint":{"line":283,"column":31},"line":283,"code":"  it('should get next word code', async () => {\n    function assertNext(text: string, index: number, res: [number, string] | undefined): void {\n      let arr = res === undefined ? undefined : [res[0], res[1].charCodeAt(0)]\n      let result = strings.getNextWord(fuzzy.getCharCodes(text), index)\n      expect(result).toEqual(arr)\n    }\n    assertNext('abc', 0, [0, 'a'])\n    assertNext('abc', 1, undefined)\n    assertNext('abC', 1, [2, 'C'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get character indexes","suites":["strings"],"updatePoint":{"line":294,"column":34},"line":294,"code":"  it('should get character indexes', async () => {\n    expect(strings.getCharIndexes('abaca', 'a')).toEqual([0, 2, 4])\n    expect(strings.getCharIndexes('abd', 'f')).toEqual([])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert to lines","suites":["strings"],"updatePoint":{"line":299,"column":29},"line":299,"code":"  it('should convert to lines', async () => {\n    expect(strings.contentToLines('foo', false)).toEqual(['foo'])\n    expect(strings.contentToLines('foo\\n', true)).toEqual(['foo'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get parts","suites":["strings"],"updatePoint":{"line":304,"column":22},"line":304,"code":"  it('should get parts', async () => {\n    let res = strings.rangeParts('foo bar', Range.create(0, 0, 0, 4))\n    expect(res).toEqual(['', 'bar'])\n    res = strings.rangeParts('foo\\nbar', Range.create(0, 1, 1, 1))\n    expect(res).toEqual(['f', 'ar'])\n    res = strings.rangeParts('x\\nfoo\\nbar\\ny', Range.create(0, 1, 2, 3))\n    expect(res).toEqual(['x', '\\ny'])\n    res = strings.rangeParts('foo\\nbar', Range.create(1, 0, 1, 1))\n    expect(res).toEqual(['foo\\n', 'ar'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should equalsIgnoreCase","suites":["strings"],"updatePoint":{"line":315,"column":29},"line":315,"code":"  it('should equalsIgnoreCase', () => {\n    expect(strings.equalsIgnoreCase('', '')).toBe(true)\n    expect(!strings.equalsIgnoreCase('', '1')).toBe(true)\n    expect(!strings.equalsIgnoreCase('1', '')).toBe(true)\n    expect(strings.equalsIgnoreCase('a', 'a')).toBe(true)\n    expect(strings.equalsIgnoreCase('abc', 'Abc')).toBe(true)\n    expect(strings.equalsIgnoreCase('abc', 'ABC')).toBe(true)\n    expect(strings.equalsIgnoreCase('Hhenmeter', 'Hhenmeter')).toBe(true)\n    expect(strings.equalsIgnoreCase('L', 'l')).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check isWord","suites":["strings"],"updatePoint":{"line":326,"column":25},"line":326,"code":"  it('should check isWord', async () => {\n    expect(strings.isWord('_')).toBe(true)\n    expect(strings.isWord('0')).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find index","suites":["strings"],"updatePoint":{"line":331,"column":23},"line":331,"code":"  it('should find index', () => {\n    expect(strings.indexOf('a,b,c', ',', 2)).toBe(3)\n    expect(strings.indexOf('a,b,c', ',', 1)).toBe(1)\n    expect(strings.indexOf('a,b,c', 't', 1)).toBe(-1)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should upperFirst","suites":["strings"],"updatePoint":{"line":337,"column":23},"line":337,"code":"  it('should upperFirst', async () => {\n    expect(strings.upperFirst('')).toBe('')\n    expect(strings.upperFirst('abC')).toBe('AbC')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get symbol kind","suites":["getSymbolKind()"],"updatePoint":{"line":344,"column":28},"line":344,"code":"  it('should get symbol kind', async () => {\n    for (let i = 1; i <= 27; i++) {\n      expect(getSymbolKind(i as SymbolKind)).toBeDefined()\n    }\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check array","suites":["Is"],"updatePoint":{"line":352,"column":24},"line":352,"code":"  it('should check array', async () => {\n    expect(Is.array(false)).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check empty object","suites":["Is"],"updatePoint":{"line":356,"column":31},"line":356,"code":"  it('should check empty object', async () => {\n    expect(Is.emptyObject(false)).toBe(false)\n    expect(Is.emptyObject({})).toBe(true)\n    expect(Is.emptyObject({ x: 1 })).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check typed array","suites":["Is"],"updatePoint":{"line":362,"column":30},"line":362,"code":"  it('should check typed array', async () => {\n    let arr = new Array(10)\n    arr.fill(1)\n    expect(Is.typedArray<Uint32Array>(arr, v => {\n      return v >= 0\n    })).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set defaults","suites":["lodash"],"updatePoint":{"line":372,"column":25},"line":372,"code":"  it('should set defaults', async () => {\n    let res = lodash.defaults({ a: 1 }, { b: 2 }, { a: 3 }, null)\n    expect(res).toEqual({ a: 1, b: 2 })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check dark color","suites":["color"],"updatePoint":{"line":379,"column":29},"line":379,"code":"  it('should check dark color', async () => {\n    expect(color.isDark(Color.create(0.03, 0.01, 0.01, 0))).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse foreground color","suites":["parseAnsiHighlights"],"updatePoint":{"line":393,"column":35},"line":393,"code":"  it('should parse foreground color', async () => {\n    testColorHighlight('yellow', 'CocMarkdownCode')\n    testColorHighlight('blue', 'CocMarkdownLink')\n    testColorHighlight('magenta', 'CocMarkdownHeader')\n    testColorHighlight('green', 'CocListFgGreen')\n    testColorHighlight('green', 'CocListFgGreen', false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse background color","suites":["parseAnsiHighlights"],"updatePoint":{"line":401,"column":35},"line":401,"code":"  it('should parse background color', async () => {\n    let text = `${style.bgRed.open}text${style.bgRed.close}`\n    let res = parseAnsiHighlights(text, false)\n    expect(res.highlights.length).toBeGreaterThan(0)\n    expect(res.highlights[0].hlGroup).toBe('CocListBgRed')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse foreground and background","suites":["parseAnsiHighlights"],"updatePoint":{"line":408,"column":44},"line":408,"code":"  it('should parse foreground and background', async () => {\n    let text = `${style.bgRed.open}${style.blue.open}text${style.blue.close}${style.bgRed.close}`\n    let res = parseAnsiHighlights(text, true)\n    expect(res.highlights.length).toBeGreaterThan(0)\n    expect(res.highlights[0].hlGroup).toBe('CocListBlueRed')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should erase char","suites":["parseAnsiHighlights"],"updatePoint":{"line":415,"column":23},"line":415,"code":"  it('should erase char', async () => {\n    let text = `foo\\u0008bar`\n    let res = parseAnsiHighlights(text, true)\n    expect(res.line).toBe('fobar')\n    text = `${style.bgRed.open}foo${style.bgRed.close}\\u0008bar`\n    res = parseAnsiHighlights(text, true)\n    expect(res.line).toBe('fobar')\n    text = `${style.bgRed.open}f${style.bgRed.close}\\u0008bar`\n    res = parseAnsiHighlights(text, true)\n    expect(res.line).toBe('bar')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw for bad control character","suites":["parseAnsiHighlights"],"updatePoint":{"line":427,"column":48},"line":427,"code":"  it('should not throw for bad control character', async () => {\n    let text = '\\x1bafoo'\n    let res = parseAnsiHighlights(text)\n    expect(res.line).toBeDefined()\n    text = '\\x1b[33;44mabc\\x1b[33,44m'\n    res = parseAnsiHighlights(text)\n    expect(res.line).toBe('abc')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"distinct()","suites":["Arrays"],"updatePoint":{"line":439,"column":16},"line":439,"code":"  it('distinct()', () => {\n    function compare(a: string): string {\n      return a\n    }\n\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5'], compare), ['32', '4', '5'])\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5', '4'], compare), ['32', '4', '5'])\n    assert.deepStrictEqual(arrays.distinct(['32', 'constructor', '5', '1'], compare), ['32', 'constructor', '5', '1'])\n    assert.deepStrictEqual(arrays.distinct(['32', 'constructor', 'proto', 'proto', 'constructor'], compare), ['32', 'constructor', 'proto'])\n    assert.deepStrictEqual(arrays.distinct(['32', '4', '5', '32', '4', '5', '32', '4', '5', '5'], compare), ['32', '4', '5'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"tail()","suites":["Arrays"],"updatePoint":{"line":451,"column":12},"line":451,"code":"  it('tail()', () => {\n    assert.strictEqual(arrays.tail([1, 2, 3]), 3)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"intersect()","suites":["Arrays"],"updatePoint":{"line":455,"column":17},"line":455,"code":"  it('intersect()', () => {\n    assert.ok(!arrays.intersect([1, 2, 3], [4, 5]))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"group()","suites":["Arrays"],"updatePoint":{"line":459,"column":13},"line":459,"code":"  it('group()', () => {\n    let res = arrays.group([1, 2, 3, 4, 5], 3)\n    assert.deepStrictEqual(res, [[1, 2, 3], [4, 5]])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"groupBy()","suites":["Arrays"],"updatePoint":{"line":464,"column":15},"line":464,"code":"  it('groupBy()', () => {\n    let res = arrays.groupBy([0, 0, 3, 4], v => v != 0)\n    assert.deepStrictEqual(res, [[3, 4], [0, 0]])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"lastIndex()","suites":["Arrays"],"updatePoint":{"line":469,"column":17},"line":469,"code":"  it('lastIndex()', () => {\n    let res = arrays.lastIndex([1, 2, 3], x => x < 3)\n    assert.strictEqual(res, 1)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"flatMap()","suites":["Arrays"],"updatePoint":{"line":474,"column":15},"line":474,"code":"  it('flatMap()', () => {\n    let objs: { [key: string]: number[] }[] = [{ x: [1, 2] }, { y: [3, 4] }, { z: [5, 6] }]\n    function values(item: { [key: string]: number[] }): number[] {\n      return Object.keys(item).reduce((p, c) => p.concat(item[c]), [])\n    }\n    let res = arrays.flatMap(objs, values)\n    assert.deepStrictEqual(res, [1, 2, 3, 4, 5, 6])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"addSortedArray()","suites":["Arrays"],"updatePoint":{"line":483,"column":22},"line":483,"code":"  it('addSortedArray()', () => {\n    expect(arrays.addSortedArray('a', ['d', 'e'])).toEqual(['a', 'd', 'e'])\n    expect(arrays.addSortedArray('f', ['d', 'e'])).toEqual(['d', 'e', 'f'])\n    expect(arrays.addSortedArray('d', ['d', 'e'])).toEqual(['d', 'e'])\n    expect(arrays.addSortedArray('e', ['d', 'f'])).toEqual(['d', 'e', 'f'])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"samePosition","suites":["Position"],"updatePoint":{"line":496,"column":20},"line":496,"code":"  test('samePosition', () => {\n    let pos = Position.create(0, 0)\n    expect(positions.samePosition(pos, Position.create(0, 0))).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"rangeInRange","suites":["Position"],"updatePoint":{"line":501,"column":20},"line":501,"code":"  test('rangeInRange', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(positions.rangeInRange(r, r)).toBe(true)\n    expect(positions.rangeInRange(r, Range.create(addPosition(pos, 1, 0), pos))).toBe(false)\n    expect(positions.rangeInRange(Range.create(0, 1, 0, 1), Range.create(0, 0, 0, 1))).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"rangeOverlap","suites":["Position"],"updatePoint":{"line":509,"column":20},"line":509,"code":"  test('rangeOverlap', () => {\n    let r = Range.create(0, 0, 0, 0)\n    expect(positions.rangeOverlap(r, Range.create(0, 0, 0, 0))).toBe(false)\n    expect(positions.rangeOverlap(Range.create(0, 0, 0, 10), Range.create(0, 1, 0, 2))).toBe(true)\n    expect(positions.rangeOverlap(Range.create(0, 0, 0, 1), Range.create(0, 1, 0, 2))).toBe(false)\n    expect(positions.rangeOverlap(Range.create(0, 1, 0, 2), Range.create(0, 0, 0, 1))).toBe(false)\n    expect(positions.rangeOverlap(Range.create(0, 0, 0, 1), Range.create(0, 2, 0, 3))).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"rangeAdjacent","suites":["Position"],"updatePoint":{"line":518,"column":21},"line":518,"code":"  test('rangeAdjacent', () => {\n    let r = Range.create(1, 1, 1, 2)\n    expect(positions.rangeAdjacent(r, Range.create(0, 0, 0, 0))).toBe(false)\n    expect(positions.rangeAdjacent(r, Range.create(1, 1, 1, 3))).toBe(false)\n    expect(positions.rangeAdjacent(r, Range.create(0, 0, 1, 1))).toBe(true)\n    expect(positions.rangeAdjacent(r, Range.create(1, 2, 1, 4))).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"positionInRange","suites":["Position"],"updatePoint":{"line":526,"column":23},"line":526,"code":"  test('positionInRange', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(positions.positionInRange(pos, r)).toBe(0)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"comparePosition","suites":["Position"],"updatePoint":{"line":532,"column":23},"line":532,"code":"  test('comparePosition', () => {\n    let pos = Position.create(0, 0)\n    expect(positions.comparePosition(pos, pos)).toBe(0)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get start end position by content","suites":["Position"],"updatePoint":{"line":537,"column":48},"line":537,"code":"  test('should get start end position by content', () => {\n    expect(positions.getEnd(Position.create(0, 0), 'foo')).toEqual({ line: 0, character: 3 })\n    expect(positions.getEnd(Position.create(0, 1), 'foo\\nbar')).toEqual({ line: 1, character: 3 })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"isSingleLine","suites":["Position"],"updatePoint":{"line":542,"column":20},"line":542,"code":"  test('isSingleLine', () => {\n    let pos = Position.create(0, 0)\n    let r = Range.create(pos, pos)\n    expect(positions.isSingleLine(r)).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"toValidRange","suites":["Position"],"updatePoint":{"line":548,"column":20},"line":548,"code":"  test('toValidRange', () => {\n    expect(positions.toValidRange(Range.create(1, 0, 0, 1))).toEqual(Range.create(0, 1, 1, 0))\n    expect(positions.toValidRange({\n      start: { line: -1, character: -1 },\n      end: { line: -1, character: -1 },\n    })).toEqual(Range.create(0, 0, 0, 0))\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get match highlights","suites":["match highlights"],"updatePoint":{"line":559,"column":33},"line":559,"code":"  it('should get match highlights', async () => {\n    let res = getMatchHighlights('fob', 'foobar', 0, 'Search')\n    expect(res).toEqual([\n      { span: [0, 2], hlGroup: 'Search' },\n      { span: [3, 4], hlGroup: 'Search' }\n    ])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match empty text","suites":["match result"],"updatePoint":{"line":569,"column":29},"line":569,"code":"  it('should match empty text', async () => {\n    expect(getMatchResult('', 'foo')).toEqual({ score: 0 })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should match empty query","suites":["match result"],"updatePoint":{"line":573,"column":30},"line":573,"code":"  it('should match empty query', async () => {\n    expect(getMatchResult('foo', '')).toEqual({ score: 1 })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #1","suites":["match result"],"updatePoint":{"line":577,"column":32},"line":577,"code":"  it('should respect filename #1', () => {\n    let res = getMatchResult('/coc.nvim/coc.txt', 'coc', 'coc.txt')\n    expect(res).toEqual({ score: 4, matches: [10, 11, 12] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #2","suites":["match result"],"updatePoint":{"line":582,"column":32},"line":582,"code":"  it('should respect filename #2', () => {\n    let res = getMatchResult('/coc.nvim/Coc.txt', 'coc', 'Coc.txt')\n    expect(res).toEqual({ score: 3.5, matches: [10, 11, 12] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #3","suites":["match result"],"updatePoint":{"line":587,"column":32},"line":587,"code":"  it('should respect filename #3', () => {\n    let res = getMatchResult('/coc.nvim/cdoxc.txt', 'coc', 'cdoxc.txt')\n    expect(res).toEqual({ score: 3, matches: [10, 12, 14] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect filename #4","suites":["match result"],"updatePoint":{"line":592,"column":32},"line":592,"code":"  it('should respect filename #4', () => {\n    let res = getMatchResult('/coc.nvim/fileName.txt', 'namt', 'fileName.txt')\n    expect(res).toEqual({ score: 3.5, matches: [14, 15, 16, 19] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect path start","suites":["match result"],"updatePoint":{"line":597,"column":31},"line":597,"code":"  it('should respect path start', () => {\n    let res = getMatchResult('/foob/baxr/xyz', 'fbx')\n    expect(res).toEqual({ score: 3, matches: [1, 6, 11] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find fuzzy result","suites":["match result"],"updatePoint":{"line":602,"column":30},"line":602,"code":"  it('should find fuzzy result', () => {\n    let res = getMatchResult('foobarzyx', 'fbx')\n    expect(res).toEqual({ score: 2, matches: [0, 3, 8] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find fuzzy result #1","suites":["match result"],"updatePoint":{"line":607,"column":33},"line":607,"code":"  it('should find fuzzy result #1', () => {\n    let res = getMatchResult('LICENSES/preferred/MIT', 'lsit')\n    expect(res).toEqual({ score: 1.4, matches: [0, 5, 20, 21] })\n    expect(getMatchResult('foo', 'Fo')).toEqual({ score: 1.5, matches: [0, 1] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find fuzzy result #2","suites":["match result"],"updatePoint":{"line":613,"column":33},"line":613,"code":"  it('should find fuzzy result #2', async () => {\n    let res = getMatchResult('_api', 'AP')\n    expect(res).toEqual({ score: 0.8, matches: [1, 2] })\n    res = getMatchResult('_api', 'API')\n    expect(res).toEqual({ score: 1.3, matches: [1, 2, 3] })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw for invalid ms","suites":["utility"],"updatePoint":{"line":623,"column":37},"line":623,"code":"  it('should not throw for invalid ms', async () => {\n    await wait(-1)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get uri for unknown buftype","suites":["utility"],"updatePoint":{"line":627,"column":40},"line":627,"code":"  it('should get uri for unknown buftype', async () => {\n    let res = getUri('foo', 3, '', false)\n    expect(res).toBe('unknown:3')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch file","suites":["utility"],"updatePoint":{"line":632,"column":23},"line":632,"code":"  it('should watch file', async () => {\n    let filepath = await createTmpFile('my file')\n    let called = false\n    let disposable = watchFile(filepath, () => {\n      called = true\n    })\n    await wait(10)\n    fs.writeFileSync(filepath, 'new file', 'utf8')\n    await helper.waitValue(() => {\n      return called\n    }, true)\n    disposable.dispose()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check executable","suites":["utility"],"updatePoint":{"line":646,"column":29},"line":646,"code":"  it('should check executable', async () => {\n    let res = executable('command_not_exists')\n    expect(res).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check isRunning","suites":["utility"],"updatePoint":{"line":651,"column":28},"line":651,"code":"  it('should check isRunning', async () => {\n    expect(isRunning(process.pid)).toBe(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run command with timeout","suites":["utility"],"updatePoint":{"line":655,"column":37},"line":655,"code":"  it('should run command with timeout', async () => {\n    let err\n    try {\n      await runCommand('sleep 2', { cwd: __dirname }, 0.01)\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw on command error","suites":["utility"],"updatePoint":{"line":665,"column":35},"line":665,"code":"  it('should throw on command error', async () => {\n    let err\n    try {\n      await runCommand('command_not_exists', { cwd: __dirname })\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve concurrent with empty task","suites":["utility"],"updatePoint":{"line":675,"column":47},"line":675,"code":"  it('should resolve concurrent with empty task', async () => {\n    let fn = jest.fn()\n    await concurrent([], fn, 3)\n    expect(fn).toBeCalledTimes(0)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run concurrent","suites":["utility"],"updatePoint":{"line":681,"column":27},"line":681,"code":"  it('should run concurrent', async () => {\n    let res: number[] = []\n    let fn = (n: number): Promise<void> => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          res.push(n)\n          resolve()\n        }, n * 10)\n      })\n    }\n    let arr = [5, 4, 3, 6, 8]\n    let ts = Date.now()\n    await concurrent(arr, fn, 3)\n    let dt = Date.now() - ts\n    expect(dt).toBeGreaterThanOrEqual(100)\n    expect(res).toEqual([3, 4, 5, 6, 8])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getKeymapModifier","suites":["utility"],"updatePoint":{"line":699,"column":30},"line":699,"code":"  it('should getKeymapModifier', async () => {\n    expect(getKeymapModifier('i')).toBe('<C-o>')\n    expect(getKeymapModifier('s')).toBe('<Esc>')\n    expect(getKeymapModifier('x')).toBe('<C-U>')\n    expect(getKeymapModifier('t' as any)).toBe('')\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#score","suites":["score test"],"updatePoint":{"line":709,"column":15},"line":709,"code":"  it('fzy#score', async () => {\n    let a = fzy.score(\"amuser\", \"app/models/user.rb\")\n    let b = fzy.score(\"amuser\", \"app/models/customer.rb\")\n    expect(a).toBeGreaterThan(b)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#positions","suites":["score test"],"updatePoint":{"line":715,"column":19},"line":715,"code":"  it('fzy#positions', async () => {\n    let arr = fzy.positions(\"amuser\", \"app/models/user.rb\")\n    expect(arr).toEqual([0, 4, 11, 12, 13, 14])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"fzy#groupPositions","suites":["score test"],"updatePoint":{"line":720,"column":24},"line":720,"code":"  it('fzy#groupPositions', async () => {\n    let arr = fzy.groupPositions([1, 2, 3, 6, 7, 10])\n    expect(arr).toEqual([[1, 4], [6, 8], [10, 11]])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be fuzzy match","suites":["fuzzy match test"],"updatePoint":{"line":727,"column":27},"line":727,"code":"  it('should be fuzzy match', () => {\n    let needle = 'aBc'\n    let codes = fuzzy.getCharCodes(needle)\n    expect(fuzzy.fuzzyMatch(codes, 'abc')).toBeFalsy\n    expect(fuzzy.fuzzyMatch(codes, 'ab')).toBeFalsy\n    expect(fuzzy.fuzzyMatch(codes, 'addbdd')).toBeFalsy\n    expect(fuzzy.fuzzyMatch(codes, 'abbbBc')).toBeTruthy\n    expect(fuzzy.fuzzyMatch(codes, 'daBc')).toBeTruthy\n    expect(fuzzy.fuzzyMatch(codes, 'ABCz')).toBeTruthy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be fuzzy for character","suites":["fuzzy match test"],"updatePoint":{"line":738,"column":35},"line":738,"code":"  it('should be fuzzy for character', () => {\n    expect(fuzzy.fuzzyChar('a', 'a')).toBeTruthy\n    expect(fuzzy.fuzzyChar('a', 'A')).toBeTruthy\n    expect(fuzzy.fuzzyChar('z', 'z')).toBeTruthy\n    expect(fuzzy.fuzzyChar('z', 'Z')).toBeTruthy\n    expect(fuzzy.fuzzyChar('A', 'a')).toBeFalsy\n    expect(fuzzy.fuzzyChar('A', 'A')).toBeTruthy\n    expect(fuzzy.fuzzyChar('Z', 'z')).toBeFalsy\n    expect(fuzzy.fuzzyChar('Z', 'Z')).toBeTruthy\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mixin should recursive","suites":["object test"],"updatePoint":{"line":751,"column":28},"line":751,"code":"  it('mixin should recursive', () => {\n    let res = objects.mixin({ a: { b: 1 } }, { a: { c: 2 }, d: 3 })\n    expect(res.a.b).toBe(1)\n    expect(res.a.c).toBe(2)\n    expect(res.d).toBe(3)\n    res = objects.mixin({}, true)\n    expect(res).toEqual({})\n    res = objects.mixin({ x: 1 }, { x: 2 }, false)\n    expect(res).toEqual({ x: 1 })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deep clone","suites":["object test"],"updatePoint":{"line":762,"column":23},"line":762,"code":"  it('should deep clone', async () => {\n    let re = new RegExp('a', 'g')\n    expect(objects.deepClone(re)).toBe(re)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not deep freeze","suites":["object test"],"updatePoint":{"line":767,"column":28},"line":767,"code":"  it('should not deep freeze', async () => {\n    objects.deepFreeze(false)\n    objects.deepFreeze(true)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check equals","suites":["object test"],"updatePoint":{"line":772,"column":25},"line":772,"code":"  it('should check equals', async () => {\n    expect(objects.equals(false, 1)).toBe(false)\n    expect(objects.equals([1], {})).toBe(false)\n    expect(objects.equals([1, 2], [1, 3])).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check empty object","suites":["object test"],"updatePoint":{"line":778,"column":31},"line":778,"code":"  it('should check empty object', async () => {\n    expect(objects.isEmpty({})).toBe(true)\n    expect(objects.isEmpty([])).toBe(true)\n    expect(objects.isEmpty(null)).toBe(true)\n    expect(objects.isEmpty({ x: 1 })).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #1","suites":["ansiparse"],"updatePoint":{"line":787,"column":18},"line":787,"code":"  it('ansiparse #1', () => {\n    let str = '\\u001b[33mText\\u001b[mnormal'\n    let res = ansiparse(str)\n    expect(res).toEqual([{\n      foreground: 'yellow', text: 'Text'\n    }, {\n      text: 'normal'\n    }])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #2","suites":["ansiparse"],"updatePoint":{"line":797,"column":18},"line":797,"code":"  it('ansiparse #2', () => {\n    let str = '\\u001b[33m\\u001b[mText'\n    let res = ansiparse(str)\n    expect(res).toEqual([\n      { foreground: 'yellow', text: '' },\n      { text: 'Text' }])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"ansiparse #3","suites":["ansiparse"],"updatePoint":{"line":805,"column":18},"line":805,"code":"  it('ansiparse #3', () => {\n    let str = 'this.\\u001b[0m\\u001b[31m\\u001b[1mhistory\\u001b[0m.add()'\n    let res = ansiparse(str)\n    expect(res[1]).toEqual({\n      foreground: 'red',\n      bold: true, text: 'history'\n    })\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutex run in serial","suites":["Mutex"],"updatePoint":{"line":816,"column":25},"line":816,"code":"  it('mutex run in serial', async () => {\n    let lastTs: number\n    let fn = () => new Promise<void>(resolve => {\n      if (lastTs) {\n        let dt = Date.now() - lastTs\n        expect(dt).toBeGreaterThanOrEqual(2)\n      }\n      lastTs = Date.now()\n      setTimeout(() => {\n        resolve()\n      }, 3)\n    })\n    let mutex = new Mutex()\n    await Promise.all([\n      mutex.use(fn),\n      mutex.use(fn),\n      mutex.use(fn)\n    ])\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"mutex run after job finish","suites":["Mutex"],"updatePoint":{"line":836,"column":32},"line":836,"code":"  it('mutex run after job finish', async () => {\n    let count = 0\n    let fn = () => new Promise<void>(resolve => {\n      count = count + 1\n      setTimeout(() => {\n        resolve()\n      }, 10)\n    })\n    let mutex = new Mutex()\n    await mutex.use(fn)\n    await helper.wait(1)\n    await mutex.use(fn)\n    expect(count).toBe(2)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should release on reject","suites":["Mutex"],"updatePoint":{"line":851,"column":30},"line":851,"code":"  it('should release on reject', async () => {\n    let mutex = new Mutex()\n    let err\n    try {\n      await mutex.use(() => {\n        return Promise.reject(new Error('err'))\n      })\n    } catch (e) {\n      err = e\n    }\n    expect(err).toBeDefined()\n    expect(mutex.busy).toBe(false)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should terminate process","suites":["terminate"],"updatePoint":{"line":867,"column":30},"line":867,"code":"  it('should terminate process', async () => {\n    let cwd = process.cwd()\n    let child = spawn('sleep', ['10'], { cwd, detached: true })\n    let res = terminate(child, cwd)\n    await helper.wait(60)\n    expect(res).toBe(true)\n    expect(child.connected).toBe(false)\n    terminate(child, cwd)\n  })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get textedit without cursor","suites":["diff","diff lines"],"updatePoint":{"line":885,"column":42},"line":885,"code":"    it('should get textedit without cursor', () => {\n      let res = diff.getTextEdit(['a', 'b'], ['a', 'b'])\n      expect(res).toBeUndefined()\n      res = diff.getTextEdit(['a', 'b'], ['a', 'b'], Position.create(0, 0))\n      expect(res).toBeUndefined()\n      res = diff.getTextEdit(['a', 'b'], ['a', 'b', 'c'])\n      expect(res).toEqual(toEdit(2, 0, 2, 0, 'c\\n'))\n      res = diff.getTextEdit(['a', 'b', 'c'], ['a'])\n      expect(res).toEqual(toEdit(1, 0, 3, 0, ''))\n      res = diff.getTextEdit(['a', 'b'], ['a', 'd'])\n      expect(res).toEqual(toEdit(1, 0, 2, 0, 'd\\n'))\n      res = diff.getTextEdit(['a', 'b'], ['a', 'd', 'e'])\n      expect(res).toEqual(toEdit(1, 0, 2, 0, 'd\\ne\\n'))\n      res = diff.getTextEdit(['a', 'b', 'e'], ['a', 'd', 'e'])\n      expect(res).toEqual(toEdit(1, 0, 2, 0, 'd\\n'))\n      res = diff.getTextEdit(['a', 'b', 'e'], ['e'])\n      expect(res).toEqual(toEdit(0, 0, 2, 0, ''))\n      res = diff.getTextEdit(['a', 'b', 'e'], ['d', 'c', 'a', 'b', 'e'])\n      expect(res).toEqual(toEdit(0, 0, 0, 0, 'd\\nc\\n'))\n      res = diff.getTextEdit(['a', 'b'], ['a', 'b', ''])\n      expect(res).toEqual(toEdit(2, 0, 2, 0, '\\n'))\n      res = diff.getTextEdit(['a', 'b'], ['a', 'b', '', ''])\n      expect(res).toEqual(toEdit(2, 0, 2, 0, '\\n\\n'))\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get textedit for single line change","suites":["diff","diff lines"],"updatePoint":{"line":910,"column":50},"line":910,"code":"    it('should get textedit for single line change', async () => {\n      let res = diff.getTextEdit(['foo', 'c'], ['', 'c'], Position.create(0, 0), false)\n      expect(res).toEqual(toEdit(0, 0, 0, 3, ''))\n      res = diff.getTextEdit([''], ['foo'], Position.create(0, 0), false)\n      expect(res).toEqual(toEdit(0, 0, 0, 0, 'foo'))\n      res = diff.getTextEdit(['foo bar'], ['foo r'], Position.create(0, 4), false)\n      expect(res).toEqual(toEdit(0, 4, 0, 6, ''))\n      res = diff.getTextEdit(['f'], ['foo f'], Position.create(0, 0), false)\n      expect(res).toEqual(toEdit(0, 0, 0, 0, 'foo '))\n      res = diff.getTextEdit([' foo '], [' bar '], Position.create(0, 0), false)\n      expect(res).toEqual(toEdit(0, 1, 0, 4, 'bar'))\n      res = diff.getTextEdit(['foo'], ['bar'], Position.create(0, 0), true)\n      expect(res).toEqual(toEdit(0, 0, 0, 3, 'bar'))\n      res = diff.getTextEdit(['aa'], ['aaaa'], Position.create(0, 1), true)\n      expect(res).toEqual(toEdit(0, 0, 0, 0, 'aa'))\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff changed lines","suites":["diff","diff lines"],"updatePoint":{"line":927,"column":33},"line":927,"code":"    it('should diff changed lines', () => {\n      let res = diffLines('a\\n', 'b\\n')\n      expect(res).toEqual({ start: 0, end: 1, replacement: ['b'] })\n      res = diff.diffLines(['a', 'b'], ['c', 'd', 'a', 'b'], -1)\n      expect(res).toEqual({ start: 0, end: 0, replacement: ['c', 'd'] })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff added lines","suites":["diff","diff lines"],"updatePoint":{"line":934,"column":31},"line":934,"code":"    it('should diff added lines', () => {\n      let res = diffLines('a\\n', 'a\\nb\\n')\n      expect(res).toEqual({\n        start: 1,\n        end: 1,\n        replacement: ['b']\n      })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff remove lines","suites":["diff","diff lines"],"updatePoint":{"line":943,"column":32},"line":943,"code":"    it('should diff remove lines', () => {\n      let res = diffLines('a\\n\\n', 'a\\n')\n      expect(res).toEqual({\n        start: 1,\n        end: 2,\n        replacement: []\n      })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff remove multiple lines","suites":["diff","diff lines"],"updatePoint":{"line":952,"column":41},"line":952,"code":"    it('should diff remove multiple lines', () => {\n      let res = diffLines('a\\n\\n\\n', 'a\\n')\n      expect(res).toEqual({\n        start: 1,\n        end: 3,\n        replacement: []\n      })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should diff removed line","suites":["diff","diff lines"],"updatePoint":{"line":961,"column":32},"line":961,"code":"    it('should diff removed line', () => {\n      let res = diffLines('a\\n\\n\\nb', 'a\\n\\nb')\n      expect(res).toEqual({\n        start: 2,\n        end: 3,\n        replacement: []\n      })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reduce changed lines","suites":["diff","diff lines"],"updatePoint":{"line":970,"column":35},"line":970,"code":"    it('should reduce changed lines', async () => {\n      let res = diff.diffLines(['a', 'b', 'c'], ['a', 'b', 'c', 'd'], 0)\n      expect(res).toEqual({\n        start: 3,\n        end: 3,\n        replacement: ['d']\n      })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should patch line","suites":["diff","patch line"],"updatePoint":{"line":981,"column":25},"line":981,"code":"    it('should patch line', () => {\n      let res = diff.patchLine('foo', 'bar foo bar')\n      expect(res.length).toBe(7)\n      expect(res).toBe('    foo')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for comments ","suites":["diff","should get text edits"],"updatePoint":{"line":1003,"column":37},"line":1003,"code":"    it('should get diff for comments ', async () => {\n      let oldStr = '/*\\n *\\n * \\n'\n      let newStr = '/*\\n *\\n *\\n * \\n'\n      let doc = TextDocument.create('untitled://1', 'markdown', 0, oldStr)\n      let change = diff.getChange(doc.getText(), newStr, 1)\n      let start = doc.positionAt(change.start)\n      let end = doc.positionAt(change.end)\n      let edit: TextEdit = {\n        range: { start, end },\n        newText: change.newText\n      }\n      let res = TextDocument.applyEdits(doc, [edit])\n      expect(res).toBe(newStr)\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null for same content","suites":["diff","should get text edits"],"updatePoint":{"line":1018,"column":43},"line":1018,"code":"    it('should return null for same content', () => {\n      let change = diff.getChange('', '')\n      expect(change).toBeNull()\n      change = diff.getChange('abc', 'abc')\n      expect(change).toBeNull()\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added","suites":["diff","should get text edits"],"updatePoint":{"line":1025,"column":33},"line":1025,"code":"    it('should get diff for added', () => {\n      applyEdits('1\\n2', '1\\n2\\n3\\n4')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #0","suites":["diff","should get text edits"],"updatePoint":{"line":1029,"column":36},"line":1029,"code":"    it('should get diff for added #0', () => {\n      applyEdits('\\n\\n', '\\n\\n\\n')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #1","suites":["diff","should get text edits"],"updatePoint":{"line":1033,"column":36},"line":1033,"code":"    it('should get diff for added #1', () => {\n      applyEdits('1\\n2\\n3', '5\\n1\\n2\\n3')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #2","suites":["diff","should get text edits"],"updatePoint":{"line":1037,"column":36},"line":1037,"code":"    it('should get diff for added #2', () => {\n      applyEdits('1\\n2\\n3', '1\\n2\\n4\\n3')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #3","suites":["diff","should get text edits"],"updatePoint":{"line":1041,"column":36},"line":1041,"code":"    it('should get diff for added #3', () => {\n      applyEdits('1\\n2\\n3', '4\\n1\\n2\\n3\\n5')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for added #4","suites":["diff","should get text edits"],"updatePoint":{"line":1045,"column":36},"line":1045,"code":"    it('should get diff for added #4', () => {\n      applyEdits(' ', '   ')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for replace","suites":["diff","should get text edits"],"updatePoint":{"line":1049,"column":35},"line":1049,"code":"    it('should get diff for replace', () => {\n      applyEdits('1\\n2\\n3\\n4\\n5', '1\\n5\\n3\\n6\\n7')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for replace #1","suites":["diff","should get text edits"],"updatePoint":{"line":1053,"column":38},"line":1053,"code":"    it('should get diff for replace #1', () => {\n      applyEdits('1\\n2\\n3\\n4\\n5', '1\\n5\\n3\\n6\\n7')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #0","suites":["diff","should get text edits"],"updatePoint":{"line":1057,"column":37},"line":1057,"code":"    it('should get diff for remove #0', () => {\n      applyEdits('1\\n2\\n3\\n4', '1\\n4')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #1","suites":["diff","should get text edits"],"updatePoint":{"line":1061,"column":37},"line":1061,"code":"    it('should get diff for remove #1', () => {\n      applyEdits('1\\n2\\n3\\n4', '1')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get diff for remove #2","suites":["diff","should get text edits"],"updatePoint":{"line":1065,"column":37},"line":1065,"code":"    it('should get diff for remove #2', () => {\n      applyEdits('  ', ' ')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer cursor position for change","suites":["diff","should get text edits"],"updatePoint":{"line":1069,"column":48},"line":1069,"code":"    it('should prefer cursor position for change', async () => {\n      let res = diff.getChange(' int n', ' n', 0)\n      expect(res).toEqual({ start: 1, end: 5, newText: '' })\n      res = diff.getChange(' int n', ' n')\n      expect(res).toEqual({ start: 0, end: 4, newText: '' })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer next line for change","suites":["diff","should get text edits"],"updatePoint":{"line":1076,"column":42},"line":1076,"code":"    it('should prefer next line for change', async () => {\n      let res = diff.getChange('a\\nb', 'a\\nc\\nb')\n      expect(res).toEqual({ start: 2, end: 2, newText: 'c\\n' })\n      applyEdits('a\\nb', 'a\\nc\\nb')\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer previous line for change","suites":["diff","should get text edits"],"updatePoint":{"line":1082,"column":46},"line":1082,"code":"    it('should prefer previous line for change', async () => {\n      let res = diff.getChange('\\n\\na', '\\na')\n      expect(res).toEqual({ start: 0, end: 1, newText: '' })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider cursor","suites":["diff","should get text edits"],"updatePoint":{"line":1087,"column":30},"line":1087,"code":"    it('should consider cursor', () => {\n      let res = diff.getChange('\\n\\n\\n', '\\n\\n\\n\\n', 1)\n      expect(res).toEqual({ start: 2, end: 2, newText: '\\n' })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get minimal diff","suites":["diff","should get text edits"],"updatePoint":{"line":1092,"column":31},"line":1092,"code":"    it('should get minimal diff', () => {\n      let res = diff.getChange('foo\\nbar', 'fab\\nbar', 2)\n      expect(res).toEqual({ start: 1, end: 3, newText: 'ab' })\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should do async filter","suites":["diff","async"],"updatePoint":{"line":1111,"column":30},"line":1111,"code":"    it('should do async filter', async () => {\n      await filter([{ label: 'a' }, { label: 'b' }, { label: 'c' }], v => {\n        return { code: v.label.charCodeAt(0) }\n      }, (items, done) => {\n        expect(items.length).toBe(3)\n        expect(done).toBe(true)\n      })\n      let n = 0\n      let res: string[] = []\n      let finished: boolean\n      await filter<string>(['a', 'b', 'c'], () => {\n        blockMilliseconds(30)\n        return true\n      }, (items, done) => {\n        n++\n        res.push(...items)\n        finished = done\n      })\n      expect(n).toBe(3)\n      expect(res).toEqual(['a', 'b', 'c'])\n      expect(finished).toEqual(true)\n    })","file":"modules/util.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get offset","suites":["window","functions"],"updatePoint":{"line":49,"column":25},"line":49,"code":"    it('should get offset', async () => {\n      let buf = await nvim.buffer\n      await nvim.call('setline', [buf.id, ['bar', 'foo']])\n      await nvim.call('cursor', [2, 2])\n      let n = await window.getOffset()\n      expect(n).toBe(5)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should selected range","suites":["window","functions"],"updatePoint":{"line":57,"column":29},"line":57,"code":"    it('should selected range', async () => {\n      await nvim.setLine('foobar')\n      await nvim.command('normal! viw')\n      await nvim.eval(`feedkeys(\"\\\\<Esc>\", 'in')`)\n      let range = await window.getSelectedRange('v')\n      expect(range).toEqual({ start: { line: 0, character: 0 }, end: { line: 0, character: 6 } })\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run terminal command","suites":["window","functions"],"updatePoint":{"line":65,"column":35},"line":65,"code":"    it('should run terminal command', async () => {\n      let res = await window.runTerminalCommand('ls', __dirname)\n      expect(res.success).toBe(true)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open temimal buffer","suites":["window","functions"],"updatePoint":{"line":70,"column":34},"line":70,"code":"    it('should open temimal buffer', async () => {\n      let bufnr = await window.openTerminal('ls', { autoclose: false, keepfocus: false })\n      let curr = await nvim.eval('bufnr(\"%\")')\n      expect(curr).toBe(bufnr)\n      let buftype = await nvim.eval('&buftype')\n      expect(buftype).toBe('terminal')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create float factory","suites":["window","functions"],"updatePoint":{"line":78,"column":35},"line":78,"code":"    it('should create float factory', async () => {\n      helper.updateConfiguration('coc.preferences.excludeImageLinksInMarkdownDocument', false)\n      helper.updateConfiguration('floatFactory.floatConfig', {\n        winblend: 10,\n        rounded: true,\n        border: true,\n        close: true\n      })\n      let f = window.createFloatFactory({ modes: ['n', 'i'] })\n      await f.show([{ content: 'content', filetype: 'txt' }])\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let id = await nvim.call('coc#float#get_related', [win.id, 'border', 0]) as number\n      expect(id).toBeGreaterThan(0)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create outputChannel","suites":["window","functions"],"updatePoint":{"line":94,"column":35},"line":94,"code":"    it('should create outputChannel', () => {\n      let channel = window.createOutputChannel('channel')\n      expect(channel.name).toBe('channel')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create TreeView instance","suites":["window","functions"],"updatePoint":{"line":99,"column":39},"line":99,"code":"    it('should create TreeView instance', async () => {\n      let emitter = new Emitter<FileNode | undefined>()\n      let removed = false\n      let treeView = window.createTreeView('files', {\n        treeDataProvider: {\n          onDidChangeTreeData: emitter.event,\n          getChildren: root => {\n            if (root) return undefined\n            if (removed) return [{ filepath: '/foo/a', isFolder: true }]\n            return [{ filepath: '/foo/a', isFolder: true }, { filepath: '/foo/b.js' }]\n          },\n          getTreeItem: (node: FileNode) => {\n            let { filepath, isFolder } = node\n            return new TreeItem(URI.file(filepath), isFolder ? TreeItemCollapsibleState.Collapsed : TreeItemCollapsibleState.None)\n          },\n        }\n      })\n      disposables.push(emitter)\n      disposables.push(treeView)\n      await treeView.show()\n      let filetype = await nvim.eval('&filetype')\n      expect(filetype).toBe('coctree')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show outputChannel","suites":["window","functions"],"updatePoint":{"line":123,"column":33},"line":123,"code":"    it('should show outputChannel', async () => {\n      window.createOutputChannel('channel')\n      window.showOutputChannel('channel')\n      let buf = await nvim.buffer\n      let name = await buf.name\n      expect(name).toMatch('channel')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show none exists channel","suites":["window","functions"],"updatePoint":{"line":131,"column":43},"line":131,"code":"    it('should not show none exists channel', async () => {\n      let buf = await nvim.buffer\n      let bufnr = buf.id\n      window.showOutputChannel('NONE')\n      await helper.wait(20)\n      buf = await nvim.buffer\n      expect(buf.id).toBe(bufnr)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get cursor position","suites":["window","functions"],"updatePoint":{"line":140,"column":34},"line":140,"code":"    it('should get cursor position', async () => {\n      await nvim.setLine('       ')\n      await nvim.call('cursor', [1, 3])\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({\n        line: 0,\n        character: 2\n      })\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should moveTo position in insert mode","suites":["window","functions"],"updatePoint":{"line":150,"column":45},"line":150,"code":"    it('should moveTo position in insert mode', async () => {\n      await nvim.setLine('foo')\n      await nvim.input('i')\n      await window.moveTo({ line: 0, character: 3 })\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(4)\n      let virtualedit = await nvim.getOption('virtualedit')\n      expect(virtualedit).toBe('')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should choose quickpick","suites":["window","functions"],"updatePoint":{"line":160,"column":31},"line":160,"code":"    it('should choose quickpick', async () => {\n      let p = window.showQuickpick(['a', 'b'])\n      await helper.wait(50)\n      await nvim.input('1')\n      await nvim.input('<CR>')\n      let res = await p\n      expect(res).toBe(0)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel quickpick","suites":["window","functions"],"updatePoint":{"line":169,"column":31},"line":169,"code":"    it('should cancel quickpick', async () => {\n      let p = window.showQuickpick(['a', 'b'])\n      await helper.wait(50)\n      await nvim.input('<esc>')\n      let res = await p\n      expect(res).toBe(-1)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show prompt","suites":["window","functions"],"updatePoint":{"line":177,"column":26},"line":177,"code":"    it('should show prompt', async () => {\n      let p = window.showPrompt('prompt')\n      await helper.wait(50)\n      await nvim.input('y')\n      let res = await p\n      expect(res).toBe(true)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show dialog","suites":["window","functions"],"updatePoint":{"line":185,"column":26},"line":185,"code":"    it('should show dialog', async () => {\n      let dialog = await window.showDialog({ content: 'foo' })\n      let winid = await dialog.winid\n      expect(winid).toBeDefined()\n      expect(winid).toBeGreaterThan(1000)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show menu","suites":["window","functions"],"updatePoint":{"line":192,"column":24},"line":192,"code":"    it('should show menu', async () => {\n      let p = window.showMenuPicker(['a', 'b', 'c'], 'choose item')\n      await helper.wait(50)\n      let exists = await nvim.call('coc#float#has_float', [])\n      expect(exists).toBe(1)\n      await nvim.input('2')\n      let res = await p\n      expect(res).toBe(1)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return select items for picker","suites":["window","functions"],"updatePoint":{"line":202,"column":45},"line":202,"code":"    it('should return select items for picker', async () => {\n      let curr = await nvim.call('win_getid')\n      let p = window.showPickerDialog(['foo', 'bar'], 'select')\n      await helper.waitFloat()\n      await helper.wait(30)\n      await nvim.input(' ')\n      await nvim.input('<cr>')\n      let res = await p\n      let winid = await nvim.call('win_getid')\n      expect(winid).toBe(curr)\n      expect(res).toEqual(['foo'])\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when workspace folder does not exist","suites":["window","functions"],"updatePoint":{"line":215,"column":57},"line":215,"code":"    it('should throw when workspace folder does not exist', async () => {\n      helper.updateConfiguration('coc.preferences.rootPatterns', [])\n      await nvim.command('enew')\n      let err\n      try {\n        await window.openLocalConfig()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n      await nvim.command(`e ${path.join(os.tmpdir(), 'a')}`)\n      err\n      try {\n        await window.openLocalConfig()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n      await nvim.command(`e t.md`)\n      await nvim.command('setf markdown')\n      err\n      try {\n        await window.openLocalConfig()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should open local config","suites":["window","functions"],"updatePoint":{"line":244,"column":32},"line":244,"code":"    it('should open local config', async () => {\n      let dir = path.join(os.tmpdir(), '.vim')\n      if (fs.existsSync(dir)) {\n        fs.emptyDirSync(dir)\n        fs.rmdirSync(dir)\n      }\n      if (!fs.existsSync(path.join(os.tmpdir(), '.git'))) {\n        fs.mkdirSync(path.join(os.tmpdir(), '.git'))\n      }\n      await helper.edit(path.join(os.tmpdir(), 't'))\n      let root = workspace.root\n      expect(root).toBe(os.tmpdir())\n      let p = window.openLocalConfig()\n      await helper.wait(50)\n      await nvim.input('y')\n      await p\n      let bufname = await nvim.call('bufname', ['%'])\n      expect(bufname).toMatch('coc-settings.json')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should request input","suites":["window","window input"],"updatePoint":{"line":275,"column":28},"line":275,"code":"    it('should request input', async () => {\n      let winid = await nvim.call('win_getid')\n      let p = window.requestInput('Name')\n      await helper.wait(50)\n      await nvim.input('bar<enter>')\n      let res = await p\n      let curr = await nvim.call('win_getid')\n      expect(curr).toBe(winid)\n      expect(res).toBe('bar')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return empty string when input empty","suites":["window","window input"],"updatePoint":{"line":286,"column":51},"line":286,"code":"    it('should return empty string when input empty', async () => {\n      let p = window.requestInput('Name')\n      await helper.wait(30)\n      await nvim.input('<enter>')\n      let res = await p\n      expect(res).toBe('')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit change event","suites":["window","window input"],"updatePoint":{"line":294,"column":32},"line":294,"code":"    it('should emit change event', async () => {\n      let input = await window.createInputBox('', '', {})\n      disposables.push(input)\n      let curr: string\n      input.onDidChange(text => {\n        curr = text\n      })\n      await nvim.input('abc')\n      await helper.waitValue((() => {\n        return curr\n      }), 'abc')\n      input.title = 'foo'\n      expect(input.title).toBe('foo')\n      input.loading = true\n      expect(input.loading).toBe(true)\n      input.borderhighlight = 'WarningMsg'\n      expect(input.borderhighlight).toBe('WarningMsg')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not check bufnr for events","suites":["window","window input"],"updatePoint":{"line":313,"column":41},"line":313,"code":"    it('should not check bufnr for events', async () => {\n      let input = await window.createInputBox('', undefined, {})\n      disposables.push(input)\n      let bufnr = input.bufnr\n      let called = false\n      input.onDidChange(() => {\n        called = true\n      })\n      await events.fire('BufWinLeave', [bufnr + 1])\n      await events.fire('PromptInsert', ['', bufnr + 1])\n      await events.fire('TextChangedI', [bufnr + 1, {\n        lnum: 1,\n        col: 1,\n        line: '',\n        changedtick: 0,\n        pre: ''\n      }])\n      expect(called).toBe(false)\n      expect(input.bufnr).toBeDefined()\n      expect(input.dimension).toBeDefined()\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo lines","suites":["window","window showMessage"],"updatePoint":{"line":342,"column":25},"line":342,"code":"    it('should echo lines', async () => {\n      await window.echoLines(['a', 'b'])\n      let ch = await nvim.call('screenchar', [79, 1])\n      let s = String.fromCharCode(ch)\n      expect(s).toBe('a')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should echo multiple lines with truncate","suites":["window","window showMessage"],"updatePoint":{"line":349,"column":48},"line":349,"code":"    it('should echo multiple lines with truncate', async () => {\n      await window.echoLines(['a', 'b', 'd', 'e'], true)\n      let ch = await nvim.call('screenchar', [79, 1])\n      let s = String.fromCharCode(ch)\n      expect(s).toBe('a')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show messages","suites":["window","window showMessage"],"updatePoint":{"line":356,"column":28},"line":356,"code":"    it('should show messages', async () => {\n      window.showMessage('error', 'error')\n      window.showMessage('warning', 'warning')\n      window.showMessage('moremsg', 'more')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show information message","suites":["window","window showMessage"],"updatePoint":{"line":362,"column":39},"line":362,"code":"    it('should show information message', async () => {\n      let p = window.showInformationMessage('information message', 'first', 'second')\n      await ensureNotification(0)\n      let res = await p\n      expect(res).toBe('first')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning message","suites":["window","window showMessage"],"updatePoint":{"line":369,"column":35},"line":369,"code":"    it('should show warning message', async () => {\n      let p = window.showWarningMessage('warning message', 'first', 'second')\n      await ensureNotification(1)\n      let res = await p\n      expect(res).toBe('second')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error message","suites":["window","window showMessage"],"updatePoint":{"line":376,"column":33},"line":376,"code":"    it('should show error message', async () => {\n      let p = window.showErrorMessage('error message', 'first', 'second')\n      await ensureNotification(0)\n      let res = await p\n      expect(res).toBe('first')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer menu picker for notification message","suites":["window","window showMessage"],"updatePoint":{"line":383,"column":58},"line":383,"code":"    it('should prefer menu picker for notification message', async () => {\n      let p = window.showErrorMessage('error message', 'first', 'second')\n      await helper.waitFloat()\n      await nvim.input('1')\n      let res = await p\n      expect(res).toBe('first')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse sour name","suites":["window","window parseSource()"],"updatePoint":{"line":393,"column":30},"line":393,"code":"    it('should parse sour name', async () => {\n      expect(window.parseSource('\\n\\n')).toBeUndefined()\n      expect(window.parseSource(`\\n\\n${path.join(process.cwd(), 'a/b.js')}:1:1`)).toBe('coc.nvim')\n      expect(window.parseSource(`\\n\\n at Foo(${path.join(process.cwd(), 'a/b.js')}:1:1)`)).toBe('coc.nvim')\n      let info = extensions.getExtensionsInfo()\n      expect(window.parseSource(`\\n\\n${info[0].filepath}:1:1`)).toBe(info[0].name)\n      let filepath = path.join(info[0].directory, 'a/b/c.js')\n      expect(window.parseSource(`\\n\\n${filepath}:1:1`)).toBe(info[0].name)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show notification with options","suites":["window","window notifications"],"updatePoint":{"line":405,"column":45},"line":405,"code":"    it('should show notification with options', async () => {\n      await window.showNotification({\n        content: 'my notification',\n        title: 'title',\n      })\n      let ids = await nvim.call('coc#float#get_float_win_list')\n      expect(ids.length).toBe(1)\n      let win = nvim.createWindow(ids[0])\n      let kind = await win.getVar('kind')\n      expect(kind).toBe('notification')\n      let winid = await nvim.call('coc#float#get_related', [win.id, 'border'])\n      let bufnr = await nvim.call('winbufnr', [winid])\n      let buf = nvim.createBuffer(bufnr)\n      let lines = await buf.lines\n      expect(lines[0].includes('title')).toBe(true)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore events of other buffers","suites":["window","window notifications"],"updatePoint":{"line":422,"column":45},"line":422,"code":"    it('should ignore events of other buffers', async () => {\n      let bufnr = workspace.bufnr\n      let notification = new Notification(nvim, {})\n      await events.fire('BufWinLeave', [bufnr + 1])\n      await events.fire('FloatBtnClick', [bufnr + 1, 1])\n      notification.dispose()\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw on showNotification when no dialog support","suites":["window","window notifications"],"updatePoint":{"line":430,"column":63},"line":430,"code":"    it('should throw on showNotification when no dialog support', async () => {\n      Object.assign(workspace.env, { dialog: false })\n      disposables.push(Disposable.create(() => {\n        Object.assign(workspace.env, { dialog: true })\n      }))\n      let fn = async () => {\n        await window.showNotification({\n          content: 'my notification',\n          title: 'title',\n        })\n      }\n      await expect(fn()).rejects.toThrow(Error)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show notification without border","suites":["window","window notifications"],"updatePoint":{"line":444,"column":47},"line":444,"code":"    it('should show notification without border', async () => {\n      helper.updateConfiguration('notification.border', false)\n      await window.showNotification({\n        content: 'my notification',\n        title: 'title',\n      })\n      let win = await helper.getFloat()\n      let height = await nvim.call('coc#float#get_height', [win.id])\n      expect(height).toBe(2)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show progress notification","suites":["window","window notifications"],"updatePoint":{"line":455,"column":41},"line":455,"code":"    it('should show progress notification', async () => {\n      let called = 0\n      let res = await window.withProgress({ title: 'Downloading', cancellable: true }, (progress, token) => {\n        let n = 0\n        return new Promise(resolve => {\n          let interval = setInterval(() => {\n            progress.report({ message: 'progress', increment: 1 })\n            n = n + 10\n            called = called + 1\n            if (n == 100) {\n              clearInterval(interval)\n              resolve('done')\n            }\n          }, 10)\n          token.onCancellationRequested(() => {\n            clearInterval(interval)\n            resolve(undefined)\n          })\n        })\n      })\n      expect(called).toBeGreaterThan(8)\n      expect(res).toBe('done')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel progress notification on window close","suites":["window","window notifications"],"updatePoint":{"line":479,"column":59},"line":479,"code":"    it('should cancel progress notification on window close', async () => {\n      let called = 0\n      let p = window.withProgress({ title: 'Downloading', cancellable: true }, (progress, token) => {\n        let n = 0\n        return new Promise(resolve => {\n          let interval = setInterval(() => {\n            progress.report({ message: 'progress', increment: 1 })\n            n = n + 10\n            called = called + 1\n            if (n == 100) {\n              clearInterval(interval)\n              resolve('done')\n            }\n          }, 10)\n          token.onCancellationRequested(() => {\n            clearInterval(interval)\n            resolve(undefined)\n          })\n        })\n      })\n      await helper.wait(30)\n      await nvim.call('coc#float#close_all', [])\n      let res = await p\n      expect(called).toBeLessThan(10)\n      expect(res).toBe(undefined)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel progress when resolved","suites":["window","window notifications"],"updatePoint":{"line":506,"column":44},"line":506,"code":"    it('should cancel progress when resolved', async () => {\n      let called = 0\n      let p = window.withProgress({ title: 'Process' }, () => {\n        called = called + 1\n        return Promise.resolve()\n      })\n      await p\n      let win = await helper.getFloat()\n      if (win) {\n        let res = await nvim.call('coc#window#get_var', [win.id, 'closing'])\n        expect(res).toBe(1)\n      }\n      expect(called).toBe(1)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should be disabled by configuration","suites":["window","window notifications"],"updatePoint":{"line":521,"column":43},"line":521,"code":"    it('should be disabled by configuration', async () => {\n      helper.updateConfiguration('notification.disabledProgressSources', ['test'])\n      let p = window.withProgress({ title: 'Downloading', source: 'test' }, (progress, token) => {\n        let n = 0\n        return new Promise(resolve => {\n          let interval = setInterval(() => {\n            progress.report({ message: 'progress', increment: 1 })\n            n = n + 1\n            if (n == 10) {\n              clearInterval(interval)\n              resolve('done')\n            }\n          }, 10)\n        })\n      })\n      await helper.wait(30)\n      let win = await helper.getFloat()\n      expect(win).toBeUndefined()\n      let res = await p\n      expect(res).toBe('done')\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error message when rejected","suites":["window","window notifications"],"updatePoint":{"line":543,"column":47},"line":543,"code":"    it('should show error message when rejected', async () => {\n      let p = window.withProgress({ title: 'Process' }, () => {\n        return Promise.reject(new Error('Unable to fetch'))\n      })\n      let res = await p\n      expect(res).toBe(undefined)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch(/Unable to fetch/)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add new highlights","suites":["window","diffHighlights"],"updatePoint":{"line":574,"column":33},"line":574,"code":"    it('should add new highlights', async () => {\n      let buf = await createFile()\n      let items: HighlightItem[] = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 0,\n        colEnd: 3\n      }]\n      let res = await window.diffHighlights(buf.id, ns, items)\n      expect(res).toBeDefined()\n      expect(res.add.length).toBe(1)\n      await window.applyDiffHighlights(buf.id, ns, priority, res)\n      let markers = await buf.getExtMarks(ns_id, 0, -1, { details: true })\n      expect(markers.length).toBe(1)\n      expect(markers[0][3].end_col).toBe(3)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return empty diff","suites":["window","diffHighlights"],"updatePoint":{"line":591,"column":32},"line":591,"code":"    it('should return empty diff', async () => {\n      let buf = await createFile()\n      let items: HighlightItem[] = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 0,\n        colEnd: 3\n      }]\n      await setHighlights(items)\n      let res = await window.diffHighlights(buf.id, ns, items)\n      expect(res).toBeDefined()\n      expect(res.remove).toEqual([])\n      expect(res.add).toEqual([])\n      expect(res.removeMarkers).toEqual([])\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove and add highlights","suites":["window","diffHighlights"],"updatePoint":{"line":607,"column":40},"line":607,"code":"    it('should remove and add highlights', async () => {\n      let buf = await createFile()\n      let items: HighlightItem[] = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 0,\n        colEnd: 3\n      }]\n      await setHighlights(items)\n      items = [{\n        hlGroup: 'Search',\n        lnum: 1,\n        colStart: 0,\n        colEnd: 3\n      }]\n      let res = await window.diffHighlights(buf.id, ns, items)\n      expect(res).toBeDefined()\n      expect(res.add.length).toBe(1)\n      expect(res.removeMarkers.length).toBe(1)\n      await window.applyDiffHighlights(buf.id, ns, priority, res)\n      let markers = await buf.getExtMarks(ns_id, 0, -1, { details: true })\n      expect(markers.length).toBe(1)\n      expect(markers[0][1]).toBe(1)\n      expect(markers[0][3].end_col).toBe(3)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update highlights of single line","suites":["window","diffHighlights"],"updatePoint":{"line":633,"column":47},"line":633,"code":"    it('should update highlights of single line', async () => {\n      let buf = await createFile()\n      let items: HighlightItem[] = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 0,\n        colEnd: 1\n      }, {\n        hlGroup: 'Search',\n        lnum: 1,\n        colStart: 2,\n        colEnd: 3\n      }]\n      await setHighlights(items)\n      items = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 2,\n        colEnd: 3\n      }]\n      let res = await window.diffHighlights(buf.id, ns, items)\n      expect(res).toBeDefined()\n      expect(res.add.length).toBe(1)\n      expect(res.removeMarkers.length).toBe(2)\n      await window.applyDiffHighlights(buf.id, ns, priority, res)\n      let markers = await buf.getExtMarks(ns_id, 0, -1, { details: true })\n      expect(markers.length).toBe(1)\n      expect(markers[0][1]).toBe(0)\n      expect(markers[0][3].end_col).toBe(3)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not use extmarks on neovim < 0.5.1","suites":["window","diffHighlights"],"updatePoint":{"line":664,"column":49},"line":664,"code":"    it('should not use extmarks on neovim < 0.5.1', async () => {\n      let fn = workspace.has\n      workspace.has = feature => {\n        if (feature == 'nvim-0.5.1') return false\n        return fn.apply(workspace, [feature])\n      }\n      disposables.push({\n        dispose: () => {\n          workspace.has = fn\n        }\n      })\n      let buf = await createFile()\n      let items: HighlightItem[] = [{\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 0,\n        colEnd: 1\n      }, {\n        hlGroup: 'Search',\n        lnum: 0,\n        colStart: 2,\n        colEnd: 3\n      }]\n      await setHighlights(items)\n      let res = await window.diffHighlights(buf.id, ns, [])\n      expect(res).toEqual({\n        remove: [0], add: [], removeMarkers: []\n      })\n      await window.applyDiffHighlights(buf.id, ns, priority, res, true)\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should error message for document not attached","suites":["window","checkBuffer"],"updatePoint":{"line":705,"column":61},"line":705,"code":"    it('should should error message for document not attached', async () => {\n      await nvim.command('edit t|let b:coc_enabled = 0')\n      await window.bufferCheck()\n      await checkFloat('not attached')\n      await nvim.call('coc#float#close_all', [])\n      await nvim.command('edit +setl\\\\ buftype=nofile b')\n      await window.bufferCheck()\n      await checkFloat('not attached')\n      await nvim.call('coc#float#close_all', [])\n      await nvim.setVar('coc_max_filesize', 10240)\n      let filepath = path.join(process.cwd(), 'data/schema.json')\n      await helper.edit(filepath)\n      await window.bufferCheck()\n      await checkFloat('not attached')\n      await nvim.call('coc#float#close_all', [])\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show state of current buffer","suites":["window","checkBuffer"],"updatePoint":{"line":722,"column":43},"line":722,"code":"    it('should show state of current buffer', async () => {\n      disposables.push(languages.registerDocumentFormatProvider(['*'], {\n        provideDocumentFormattingEdits: () => {\n          return []\n        }\n      }))\n      await commands.executeCommand('document.checkBuffer')\n      await checkFloat('Provider state')\n      await nvim.call('coc#float#close_all', [])\n    })","file":"modules/window.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should have initialized","suites":["workspace properties"],"updatePoint":{"line":37,"column":29},"line":37,"code":"  it('should have initialized', () => {\n    let { nvim, rootPath, uri, insertMode, workspaceFolder, cwd, documents, textDocuments } = workspace\n    expect(insertMode).toBe(false)\n    expect(nvim).toBeTruthy()\n    expect(documents.length).toBe(1)\n    expect(textDocuments.length).toBe(1)\n    expect(rootPath).toBe(process.cwd())\n    expect(cwd).toBe(process.cwd())\n    let floatSupported = workspace.floatSupported\n    expect(floatSupported).toBe(true)\n    let { pluginRoot } = workspace\n    expect(typeof pluginRoot).toBe('string')\n    let { isVim, isNvim } = workspace\n    expect(isVim).toBe(false)\n    expect(isNvim).toBe(true)\n    expect(uri).toBeDefined()\n    expect(workspaceFolder).toBeUndefined()\n    let watchmanPath = workspace.getWatchmanPath()\n    expect(watchmanPath == null || typeof watchmanPath === 'string').toBe(true)\n    let folder = workspace.getWorkspaceFolder(uri)\n    expect(folder).toBeUndefined()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get filetyps","suites":["workspace properties"],"updatePoint":{"line":60,"column":25},"line":60,"code":"  it('should get filetyps', async () => {\n    await helper.edit('f.js')\n    let filetypes = workspace.filetypes\n    expect(filetypes.has('javascript')).toBe(true)\n    let languageIds = workspace.languageIds\n    expect(languageIds.has('javascript')).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get channelNames","suites":["workspace properties"],"updatePoint":{"line":68,"column":29},"line":68,"code":"  it('should get channelNames', async () => {\n    let names = workspace.channelNames\n    expect(Array.isArray(names)).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with deprecated method","suites":["workspace properties"],"updatePoint":{"line":73,"column":40},"line":73,"code":"  it('should work with deprecated method', async () => {\n    await nvim.setLine('foo')\n    await workspace['moveTo'](Position.create(0, 1))\n    let col = await nvim.call('col', ['.'])\n    expect(col).toBe(2)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should call vim method","suites":["workspace methods"],"updatePoint":{"line":82,"column":28},"line":82,"code":"  it('should call vim method', async () => {\n    let res = await workspace.callAsync('bufnr', ['%'])\n    expect(typeof res).toBe('number')\n    let obj: any = workspace.env\n    obj.isVim = true\n    disposables.push({\n      dispose: () => {\n        obj.isVim = false\n      }\n    })\n    res = await workspace.callAsync('bufnr', ['%'])\n    expect(typeof res).toBe('number')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get the document","suites":["workspace methods"],"updatePoint":{"line":96,"column":29},"line":96,"code":"  it('should get the document', async () => {\n    let doc = await workspace.document\n    let buf = await nvim.buffer\n    expect(doc.buffer.equals(buf)).toBeTruthy()\n    doc = workspace.getDocument(doc.uri)\n    expect(doc.buffer.equals(buf)).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get attached document","suites":["workspace methods"],"updatePoint":{"line":104,"column":34},"line":104,"code":"  it('should get attached document', async () => {\n    let fn = () => {\n      workspace.getAttachedDocument('file://not_exists')\n    }\n    expect(fn).toThrow(Error)\n    await nvim.command(`edit +setl\\\\ buftype=nofile [tree]`)\n    let doc = await workspace.document\n    expect(doc.attached).toBe(false)\n    fn = () => {\n      workspace.getAttachedDocument(doc.bufnr)\n    }\n    expect(fn).toThrow(Error)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options of without bufnr","suites":["workspace methods"],"updatePoint":{"line":118,"column":48},"line":118,"code":"  it('should get format options of without bufnr', async () => {\n    let opts = await workspace.getFormatOptions()\n    expect(opts.insertSpaces).toBe(true)\n    expect(opts.tabSize).toBe(2)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options of current buffer","suites":["workspace methods"],"updatePoint":{"line":124,"column":49},"line":124,"code":"  it('should get format options of current buffer', async () => {\n    let buf = await nvim.buffer\n    await buf.setVar('coc_trim_trailing_whitespace', 1)\n    await buf.setVar('coc_trim_final_newlines', 1)\n    await buf.setOption('shiftwidth', 8)\n    await buf.setOption('expandtab', false)\n    let doc = workspace.getDocument(buf.id)\n    let opts = await workspace.getFormatOptions(doc.uri)\n    expect(opts).toEqual({\n      tabSize: 8,\n      insertSpaces: false,\n      insertFinalNewline: true,\n      trimTrailingWhitespace: true,\n      trimFinalNewlines: true\n    })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get format options when uri does not exist","suites":["workspace methods"],"updatePoint":{"line":141,"column":55},"line":141,"code":"  it('should get format options when uri does not exist', async () => {\n    let uri = URI.file('/tmp/foo').toString()\n    let opts = await workspace.getFormatOptions(uri)\n    expect(opts.insertSpaces).toBe(true)\n    expect(opts.tabSize).toBe(2)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get config files","suites":["workspace methods"],"updatePoint":{"line":148,"column":29},"line":148,"code":"  it('should get config files', async () => {\n    let file = workspace.getConfigFile(ConfigurationTarget.Global)\n    expect(file).toBeFalsy()\n    file = workspace.getConfigFile(ConfigurationTarget.User)\n    expect(file).toBeTruthy()\n    file = workspace.getConfigFile(ConfigurationTarget.Workspace)\n    expect(file).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create file watcher","suites":["workspace methods"],"updatePoint":{"line":157,"column":32},"line":157,"code":"  it('should create file watcher', async () => {\n    let watcher = workspace.createFileSystemWatcher('**/*.ts')\n    expect(watcher).toBeDefined()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get quickfix item from Location","suites":["workspace methods"],"updatePoint":{"line":162,"column":44},"line":162,"code":"  it('should get quickfix item from Location', async () => {\n    let filepath = await createTmpFile('quickfix')\n    let uri = URI.file(filepath).toString()\n    let p = Position.create(0, 0)\n    let loc = Location.create(uri, Range.create(p, p))\n    let item = await workspace.getQuickfixItem(loc)\n    expect(item.filename).toBe(filepath)\n    expect(item.text).toBe('quickfix')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get quickfix list from Locations","suites":["workspace methods"],"updatePoint":{"line":172,"column":45},"line":172,"code":"  it('should get quickfix list from Locations', async () => {\n    let filepathA = await createTmpFile('fileA:1\\nfileA:2\\nfileA:3')\n    let uriA = URI.file(filepathA).toString()\n    let filepathB = await createTmpFile('fileB:1\\nfileB:2\\nfileB:3')\n    let uriB = URI.file(filepathB).toString()\n    let p1 = Position.create(0, 0)\n    let p2 = Position.create(1, 0)\n    let locations: Location[] = []\n    locations.push(Location.create(uriA, Range.create(p1, p1)))\n    locations.push(Location.create(uriA, Range.create(p2, p2)))\n    locations.push(Location.create(uriB, Range.create(p1, p1)))\n    locations.push(Location.create(uriB, Range.create(p2, p2)))\n    let items = await workspace.getQuickfixList(locations)\n    expect(items[0].filename).toBe(filepathA)\n    expect(items[0].text).toBe('fileA:1')\n    expect(items[1].filename).toBe(filepathA)\n    expect(items[1].text).toBe('fileA:2')\n    expect(items[2].filename).toBe(filepathB)\n    expect(items[2].text).toBe('fileB:1')\n    expect(items[3].filename).toBe(filepathB)\n    expect(items[3].text).toBe('fileB:2')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get line of document","suites":["workspace methods"],"updatePoint":{"line":195,"column":33},"line":195,"code":"  it('should get line of document', async () => {\n    let doc = await workspace.document\n    await nvim.setLine('abc')\n    let line = await workspace.getLine(doc.uri, 0)\n    expect(line).toBe('abc')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get line of file","suites":["workspace methods"],"updatePoint":{"line":202,"column":29},"line":202,"code":"  it('should get line of file', async () => {\n    let filepath = await createTmpFile('quickfix')\n    let uri = URI.file(filepath).toString()\n    let line = await workspace.getLine(uri, 0)\n    expect(line).toBe('quickfix')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read content from buffer","suites":["workspace methods"],"updatePoint":{"line":209,"column":37},"line":209,"code":"  it('should read content from buffer', async () => {\n    let doc = await workspace.document\n    await doc.applyEdits([{ range: Range.create(0, 0, 0, 0), newText: 'foo' }])\n    let line = await workspace.readFile(doc.uri)\n    expect(line).toBe('foo\\n')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should read content from file","suites":["workspace methods"],"updatePoint":{"line":216,"column":35},"line":216,"code":"  it('should read content from file', async () => {\n    let filepath = await createTmpFile('content')\n    let content = await workspace.readFile(URI.file(filepath).toString())\n    expect(content).toBe(content)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand filepath","suites":["workspace methods"],"updatePoint":{"line":222,"column":28},"line":222,"code":"  it('should expand filepath', async () => {\n    let home = os.homedir()\n    let res = workspace.expand('~/$NODE_ENV/')\n    expect(res.startsWith(home)).toBeTruthy()\n    expect(res).toContain(process.env.NODE_ENV)\n\n    res = workspace.expand('$HOME/$NODE_ENV/')\n    expect(res.startsWith(home)).toBeTruthy()\n    expect(res).toContain(process.env.NODE_ENV)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand variables","suites":["workspace methods"],"updatePoint":{"line":233,"column":29},"line":233,"code":"  it('should expand variables', async () => {\n    expect(workspace.expand('${workspace}/foo')).toBe(`${workspace.root}/foo`)\n    expect(workspace.expand('${env:NODE_ENV}')).toBe(process.env.NODE_ENV)\n    expect(workspace.expand('${cwd}')).toBe(workspace.cwd)\n    let folder = path.dirname(workspace.root)\n    expect(workspace.expand('${workspaceFolderBasename}')).toBe(folder)\n    await helper.edit('bar.ts')\n    expect(workspace.expand('${file}')).toContain('bar')\n    expect(workspace.expand('${fileDirname}')).toBe(path.dirname(__dirname))\n    expect(workspace.expand('${fileExtname}')).toBe('.ts')\n    expect(workspace.expand('${fileBasename}')).toBe('bar.ts')\n    expect(workspace.expand('${fileBasenameNoExtension}')).toBe('bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should run command","suites":["workspace methods"],"updatePoint":{"line":247,"column":24},"line":247,"code":"  it('should run command', async () => {\n    let res = await workspace.runCommand('ls', __dirname, 1)\n    expect(res).toMatch('workspace')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve module path if exists","suites":["workspace methods"],"updatePoint":{"line":252,"column":42},"line":252,"code":"  it('should resolve module path if exists', async () => {\n    let res = await workspace.resolveModule('typescript')\n    res = await workspace.resolveModule('typescript')\n    expect(res).toBeTruthy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not resolve module if it does not exist","suites":["workspace methods"],"updatePoint":{"line":258,"column":52},"line":258,"code":"  it('should not resolve module if it does not exist', async () => {\n    let res = await workspace.resolveModule('foo')\n    res = await workspace.resolveModule('foo')\n    expect(res).toBeFalsy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return match score for document","suites":["workspace methods"],"updatePoint":{"line":264,"column":44},"line":264,"code":"  it('should return match score for document', async () => {\n    let doc = await helper.createDocument('tmp.xml')\n    expect(workspace.match(['xml'], doc.textDocument)).toBe(10)\n    expect(workspace.match(['wxml'], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ language: 'xml' }], doc.textDocument)).toBe(10)\n    expect(workspace.match([{ language: 'wxml' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ pattern: '**/*.xml' }], doc.textDocument)).toBe(5)\n    expect(workspace.match([{ pattern: '**/*.html' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ scheme: 'file' }], doc.textDocument)).toBe(5)\n    expect(workspace.match([{ scheme: 'term' }], doc.textDocument)).toBe(0)\n    expect(workspace.match([{ language: 'xml' }, { scheme: 'file' }], doc.textDocument)).toBe(10)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename buffer","suites":["workspace methods"],"updatePoint":{"line":277,"column":26},"line":277,"code":"  it('should rename buffer', async () => {\n    let doc = await helper.createDocument('a')\n    let fsPath = URI.parse(doc.uri).fsPath.replace(/a$/, 'b')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(fsPath)) fs.unlinkSync(fsPath)\n    }))\n    let p = workspace.renameCurrent()\n    await helper.wait(50)\n    await nvim.input('<backspace>b<cr>')\n    await p\n    let name = await nvim.eval('bufname(\"%\")') as string\n    expect(name.endsWith('b')).toBe(true)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should rename file","suites":["workspace methods"],"updatePoint":{"line":291,"column":24},"line":291,"code":"  it('should rename file', async () => {\n    let fsPath = path.join(tmpFolder, 'x')\n    let newPath = path.join(tmpFolder, 'b')\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(fsPath)) fs.unlinkSync(fsPath)\n      if (fs.existsSync(newPath)) fs.unlinkSync(newPath)\n    }))\n    fs.writeFileSync(fsPath, 'foo', 'utf8')\n    await helper.createDocument(fsPath)\n    let p = workspace.renameCurrent()\n    await helper.waitFor('mode', [], 'c')\n    await nvim.input('<backspace>b<cr>')\n    await p\n    let name = await nvim.eval('bufname(\"%\")') as string\n    expect(name.endsWith('b')).toBe(true)\n    expect(fs.existsSync(newPath)).toBe(true)\n    let content = fs.readFileSync(newPath, 'utf8')\n    expect(content).toMatch(/foo/)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should handle will save event","suites":["workspace methods"],"updatePoint":{"line":311,"column":35},"line":311,"code":"  it('should handle will save event', async () => {\n    async function doRename() {\n      let fsPath = await createTmpFile('foo', disposables)\n      let newPath = path.join(path.dirname(fsPath), 'new_file')\n      disposables.push(Disposable.create(() => {\n        if (fs.existsSync(newPath)) fs.unlinkSync(newPath)\n      }))\n      await workspace.renameFile(fsPath, newPath, { overwrite: true })\n      if (fs.existsSync(newPath)) fs.unlinkSync(newPath)\n    }\n    let called = false\n    let disposable = workspace.onWillRenameFiles(e => {\n      let p = new Promise<void>(resolve => {\n        setTimeout(() => {\n          called = true\n          resolve()\n        }, 10)\n      })\n      e.waitUntil(p)\n    })\n    await doRename()\n    disposable.dispose()\n    expect(called).toBe(true)\n    called = false\n    disposable = workspace.onWillRenameFiles(e => {\n      called = true\n      e.waitUntil(Promise.resolve({ changes: {} }))\n    })\n    await doRename()\n    expect(called).toBe(true)\n    disposable.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create database","suites":["workspace utility"],"updatePoint":{"line":347,"column":28},"line":347,"code":"  it('should create database', async () => {\n    let db = workspace.createDatabase('test')\n    let res = db.exists('xyz')\n    expect(res).toBe(false)\n    db.destroy()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get current state","suites":["workspace utility"],"updatePoint":{"line":354,"column":30},"line":354,"code":"  it('should get current state', async () => {\n    let buf = await helper.edit()\n    await buf.setLines(['foo', 'bar'], { start: 0, end: -1, strictIndexing: false })\n    await nvim.call('cursor', [2, 2])\n    let doc = workspace.getDocument(buf.id)\n    let state = await workspace.getCurrentState()\n    expect(doc.uri).toBe(state.document.uri)\n    expect(state.position).toEqual({ line: 1, character: 1 })\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should findUp to tsconfig.json from current file","suites":["workspace utility"],"updatePoint":{"line":364,"column":54},"line":364,"code":"  it('should findUp to tsconfig.json from current file', async () => {\n    await helper.edit(path.join(__dirname, 'edit'))\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toMatch('tsconfig.json')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should findUp from current file ","suites":["workspace utility"],"updatePoint":{"line":370,"column":38},"line":370,"code":"  it('should findUp from current file ', async () => {\n    await helper.edit('foo')\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toMatch('tsconfig.json')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not findUp from file in other directory","suites":["workspace utility"],"updatePoint":{"line":376,"column":52},"line":376,"code":"  it('should not findUp from file in other directory', async () => {\n    await nvim.command(`edit ${path.join(os.tmpdir(), 'foo')}`)\n    let filepath = await workspace.findUp('tsconfig.json')\n    expect(filepath).toBeNull()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register autocmd","suites":["workspace utility"],"updatePoint":{"line":382,"column":29},"line":382,"code":"  it('should register autocmd', async () => {\n    let event: any\n    let eventCount = 0\n    let disposables = []\n    disposables.push(workspace.registerAutocmd({\n      event: 'TextYankPost',\n      arglist: ['v:event'],\n      callback: ev => {\n        eventCount += 1\n        event = ev\n      }\n    }))\n    disposables.push(workspace.registerAutocmd({\n      event: ['InsertEnter', 'CursorMoved'],\n      callback: () => {\n        eventCount += 1\n      }\n    }))\n    await nvim.setLine('foo')\n    await helper.wait(30)\n    await nvim.command('normal! yy')\n    await helper.wait(30)\n    await nvim.command('normal! Abar')\n    await helper.wait(30)\n    expect(event.regtype).toBe('V')\n    expect(event.operator).toBe('y')\n    expect(event.regcontents).toEqual(['foo'])\n    expect(eventCount).toBeGreaterThan(2)\n    disposables.forEach(d => d.dispose())\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist keymap","suites":["workspace utility"],"updatePoint":{"line":413,"column":26},"line":413,"code":"  it('should regist keymap', async () => {\n    let fn = jest.fn()\n    await nvim.command('nmap go <Plug>(coc-echo)')\n    let disposable = workspace.registerKeymap(['n', 'v'], 'echo', fn, { sync: true })\n    await helper.wait(30)\n    let { mode } = await nvim.mode\n    expect(mode).toBe('n')\n    await nvim.call('feedkeys', ['go', 'i'])\n    await helper.wait(50)\n    expect(fn).toBeCalledTimes(1)\n    disposable.dispose()\n    await nvim.call('feedkeys', ['go', 'i'])\n    await helper.wait(50)\n    expect(fn).toBeCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist expr keymap","suites":["workspace utility"],"updatePoint":{"line":429,"column":31},"line":429,"code":"  it('should regist expr keymap', async () => {\n    let called = false\n    let fn = () => {\n      called = true\n      return '\"\"'\n    }\n    await nvim.input('i')\n    let { mode } = await nvim.mode\n    expect(mode).toBe('i')\n    let disposable = workspace.registerExprKeymap('i', '\"', fn)\n    await helper.wait(30)\n    await nvim.call('feedkeys', ['\"', 't'])\n    await helper.wait(30)\n    expect(called).toBe(true)\n    let line = await nvim.line\n    expect(line).toBe('\"\"')\n    disposable.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist buffer expr keymap","suites":["workspace utility"],"updatePoint":{"line":448,"column":38},"line":448,"code":"  it('should regist buffer expr keymap', async () => {\n    let fn = () => '\"\"'\n    await nvim.input('i')\n    let disposable = workspace.registerExprKeymap('i', '\"', fn, true)\n    await helper.wait(30)\n    await nvim.call('feedkeys', ['\"', 't'])\n    await helper.wait(30)\n    let line = await nvim.line\n    expect(line).toBe('\"\"')\n    disposable.dispose()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch options","suites":["workspace utility"],"updatePoint":{"line":460,"column":26},"line":460,"code":"  it('should watch options', async () => {\n    let fn = jest.fn()\n    workspace.watchOption('showmode', fn, disposables)\n    workspace.watchOption('showmode', fn)\n    await helper.wait(30)\n    await nvim.command('set showmode')\n    await helper.wait(30)\n    expect(fn).toBeCalled()\n    await nvim.command('noa set noshowmode')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should watch global","suites":["workspace utility"],"updatePoint":{"line":471,"column":25},"line":471,"code":"  it('should watch global', async () => {\n    let fn = jest.fn()\n    workspace.watchGlobal('x', fn, disposables)\n    workspace.watchGlobal('x', fn)\n    workspace.watchGlobal('x')\n    await nvim.command('let g:x = 1')\n    await helper.wait(30)\n    expect(fn).toBeCalled()\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check nvim version","suites":["workspace utility"],"updatePoint":{"line":481,"column":31},"line":481,"code":"  it('should check nvim version', async () => {\n    expect(workspace.has('patch-7.4.248')).toBe(false)\n    expect(workspace.has('nvim-0.5.0')).toBe(true)\n    expect(workspace.has('nvim-0.9.0')).toBe(false)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should listen to fileType change","suites":["workspace events"],"updatePoint":{"line":490,"column":38},"line":490,"code":"  it('should listen to fileType change', async () => {\n    let buf = await helper.edit()\n    await nvim.command('setf xml')\n    await helper.wait(50)\n    let doc = workspace.getDocument(buf.id)\n    expect(doc.filetype).toBe('xml')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidOpenTextDocument","suites":["workspace events"],"updatePoint":{"line":498,"column":39},"line":498,"code":"  it('should fire onDidOpenTextDocument', async () => {\n    let fn = jest.fn()\n    workspace.onDidOpenTextDocument(fn, null, disposables)\n    await helper.edit()\n    await helper.wait(30)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidChangeTextDocument","suites":["workspace events"],"updatePoint":{"line":506,"column":41},"line":506,"code":"  it('should fire onDidChangeTextDocument', async () => {\n    let fn = jest.fn()\n    await helper.edit()\n    workspace.onDidChangeTextDocument(fn, null, disposables)\n    await nvim.setLine('foo')\n    let doc = await workspace.document\n    doc.forceSync()\n    await helper.wait(20)\n    expect(fn).toHaveBeenCalledTimes(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onDidChangeConfiguration","suites":["workspace events"],"updatePoint":{"line":517,"column":42},"line":517,"code":"  it('should fire onDidChangeConfiguration', async () => {\n    let fn = jest.fn()\n    let disposable = workspace.onDidChangeConfiguration(e => {\n      disposable.dispose()\n      expect(e.affectsConfiguration('tsserver')).toBe(true)\n      expect(e.affectsConfiguration('tslint')).toBe(false)\n      fn()\n    })\n    let config = workspace.getConfiguration('tsserver')\n    config.update('enable', false)\n    expect(fn).toHaveBeenCalledTimes(1)\n    config.update('enable', undefined)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get empty configuration for none exists section","suites":["workspace events"],"updatePoint":{"line":531,"column":60},"line":531,"code":"  it('should get empty configuration for none exists section', () => {\n    let config = workspace.getConfiguration('notexists')\n    let keys = Object.keys(config)\n    expect(keys.length).toBe(0)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire onWillSaveUntil","suites":["workspace events"],"updatePoint":{"line":537,"column":33},"line":537,"code":"  it('should fire onWillSaveUntil', async () => {\n    let doc = await workspace.document\n    let filepath = URI.parse(doc.uri).fsPath\n    let fn = jest.fn()\n    let disposable = workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        fn()\n        let edit: TextEdit = {\n          newText: 'foo',\n          range: Range.create(0, 0, 0, 0)\n        }\n        resolve([edit])\n      })\n      event.waitUntil(promise)\n    })\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await events.fire('BufWritePre', [doc.bufnr, doc.bufname])\n    await helper.wait(30)\n    let content = doc.getDocumentContent()\n    expect(content.startsWith('foobar')).toBe(true)\n    disposable.dispose()\n    expect(fn).toBeCalledTimes(1)\n    if (fs.existsSync(filepath)) {\n      fs.unlinkSync(filepath)\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not work for async waitUntil","suites":["workspace events"],"updatePoint":{"line":565,"column":41},"line":565,"code":"  it('should not work for async waitUntil', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    let disposable = workspace.onWillSaveTextDocument(event => {\n      setTimeout(() => {\n        let edit: TextEdit = {\n          newText: 'foo',\n          range: Range.create(0, 0, 0, 0)\n        }\n        event.waitUntil(Promise.resolve([edit]))\n      }, 30)\n    })\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await nvim.command('wa')\n    let content = doc.getDocumentContent()\n    expect(content).toMatch('bar')\n    disposable.dispose()\n    if (fs.existsSync(filepath)) {\n      fs.unlinkSync(filepath)\n    }\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should only use first returned textEdits","suites":["workspace events"],"updatePoint":{"line":588,"column":46},"line":588,"code":"  it('should only use first returned textEdits', async () => {\n    let doc = await helper.createDocument()\n    let filepath = URI.parse(doc.uri).fsPath\n    disposables.push(Disposable.create(() => {\n      if (fs.existsSync(filepath)) {\n        fs.unlinkSync(filepath)\n      }\n    }))\n    workspace.onWillSaveTextDocument(event => {\n      event.waitUntil(Promise.resolve(undefined))\n    }, null, disposables)\n    workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        setTimeout(() => {\n          let edit: TextEdit = {\n            newText: 'foo',\n            range: Range.create(0, 0, 0, 0)\n          }\n          resolve([edit])\n        }, 10)\n      })\n      event.waitUntil(promise)\n    }, null, disposables)\n    workspace.onWillSaveTextDocument(event => {\n      let promise = new Promise<TextEdit[]>(resolve => {\n        setTimeout(() => {\n          let edit: TextEdit = {\n            newText: 'bar',\n            range: Range.create(0, 0, 0, 0)\n          }\n          resolve([edit])\n        }, 30)\n      })\n      event.waitUntil(promise)\n    }, null, disposables)\n    await nvim.setLine('bar')\n    await helper.wait(30)\n    await nvim.command('wa')\n    let content = doc.getDocumentContent()\n    expect(content).toMatch('foo')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should attach & detach","suites":["workspace events"],"updatePoint":{"line":630,"column":28},"line":630,"code":"  it('should attach & detach', async () => {\n    let buf = await helper.edit()\n    await nvim.command('CocDisable')\n    let doc = workspace.getDocument(buf.id)\n    expect(doc).toBeUndefined()\n    await nvim.command('CocEnable')\n    doc = workspace.getDocument(buf.id)\n    expect(doc.bufnr).toBe(buf.id)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist document content provider","suites":["workspace textDocument content provider"],"updatePoint":{"line":643,"column":45},"line":643,"code":"  it('should regist document content provider', async () => {\n    let provider: TextDocumentContentProvider = {\n      provideTextDocumentContent: (_uri, _token): string => 'sample text'\n    }\n    workspace.registerTextDocumentContentProvider('test', provider)\n    await nvim.command('edit test://1')\n    let buf = await nvim.buffer\n    let lines = await buf.lines\n    expect(lines).toEqual(['sample text'])\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should react on change event of document content provider","suites":["workspace textDocument content provider"],"updatePoint":{"line":654,"column":63},"line":654,"code":"  it('should react on change event of document content provider', async () => {\n    let text = 'foo'\n    let emitter = new Emitter<URI>()\n    let event = emitter.event\n    let provider: TextDocumentContentProvider = {\n      onDidChange: event,\n      provideTextDocumentContent: (_uri, _token): string => text\n    }\n    workspace.registerTextDocumentContentProvider('jdk', provider)\n    workspace.autocmds.setupDynamicAutocmd(true)\n    await nvim.command('edit jdk://1')\n    await workspace.document\n    text = 'bar'\n    emitter.fire(URI.parse('jdk://1'))\n    await helper.waitFor('getline', ['.'], 'bar')\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should regist","suites":["workspace registerBufferSync"],"updatePoint":{"line":673,"column":19},"line":673,"code":"  it('should regist', async () => {\n    await helper.createDocument()\n    let created = 0\n    let deleted = 0\n    let changed = 0\n    let disposable = workspace.registerBufferSync(() => {\n      created = created + 1\n      return {\n        dispose: () => {\n          deleted += 1\n        },\n        onChange: () => {\n          changed += 1\n        }\n      }\n    })\n    disposables.push(disposable)\n    let doc = await helper.createDocument()\n    expect(created).toBe(2)\n    await doc.applyEdits([TextEdit.insert(Position.create(0, 0), 'foo')])\n    expect(changed).toBe(1)\n    await nvim.command('bd!')\n    expect(deleted).toBe(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke onTextChange","suites":["workspace registerBufferSync"],"updatePoint":{"line":698,"column":32},"line":698,"code":"  it('should invoke onTextChange', async () => {\n    let called = 0\n    disposables.push(workspace.registerBufferSync(() => {\n      return {\n        dispose: () => {\n        },\n        onTextChange: () => {\n          called = called + 1\n        }\n      }\n    }))\n    let doc = await helper.createDocument()\n    await nvim.setLine('foo')\n    await doc.synchronize()\n    expect(called).toBe(1)\n  })","file":"modules/workspace.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert ultisnips snippet","suites":["snippet provider","insertSnippet command"],"updatePoint":{"line":34,"column":39},"line":34,"code":"    it('should insert ultisnips snippet', async () => {\n      await nvim.setLine('foo')\n      let edit = TextEdit.replace(Range.create(0, 0, 0, 3), '${1:`echo \"bar\"`}')\n      await commandManager.executeCommand('editor.action.insertSnippet', edit, {})\n      let line = await nvim.line\n      expect(line).toBe('bar')\n      edit = TextEdit.replace(Range.create(0, 0, 0, 3), '${1:`echo \"foo\"`}')\n      await commandManager.executeCommand('editor.action.insertSnippet', edit, { regex: '' })\n      line = await nvim.line\n      expect(line).toBe('foo')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when buffer not attached","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":48,"column":45},"line":48,"code":"    it('should throw when buffer not attached', async () => {\n      await nvim.command(`vnew +setl\\\\ buftype=nofile`)\n      let err\n      try {\n        await snippetManager.insertSnippet('foo')\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw with invalid range","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":59,"column":39},"line":59,"code":"    it('should throw with invalid range', async () => {\n      await nvim.command(`vnew +setl\\\\ buftype=nofile`)\n      let err\n      try {\n        await snippetManager.insertSnippet('foo', false, Range.create(3, 0, 3, 0))\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not active when insert plain snippet","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":70,"column":51},"line":70,"code":"    it('should not active when insert plain snippet', async () => {\n      await snippetManager.insertSnippet('foo')\n      let line = await nvim.line\n      expect(line).toBe('foo')\n      expect(snippetManager.session).toBe(undefined)\n      expect(snippetManager.getSession(doc.bufnr)).toBeUndefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start new session if session exists","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":78,"column":50},"line":78,"code":"    it('should start new session if session exists', async () => {\n      await nvim.setLine('bar')\n      await snippetManager.insertSnippet('${1:foo} ')\n      await nvim.input('<esc>')\n      await nvim.command('stopinsert')\n      await nvim.input('A')\n      let active = await snippetManager.insertSnippet('${2:bar}')\n      expect(active).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('foo barbar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start nest session","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":90,"column":33},"line":90,"code":"    it('should start nest session', async () => {\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      await nvim.input('<backspace>')\n      let active = await snippetManager.insertSnippet('${1:x} $1')\n      expect(active).toBe(true)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert snippetString","suites":["snippet provider","insertSnippet()"],"updatePoint":{"line":97,"column":35},"line":97,"code":"    it('should insert snippetString', async () => {\n      let snippetString = new SnippetString()\n        .appendTabstop(1)\n        .appendText(' ')\n        .appendPlaceholder('bar', 2)\n      await snippetManager.insertSnippet(snippetString)\n      await nvim.input('$foo;')\n      snippetString = new SnippetString()\n        .appendVariable('foo', 'x')\n      await snippetManager.insertSnippet(snippetString, false, Range.create(0, 5, 0, 6))\n      let line = await nvim.line\n      expect(line).toBe('$foo;xbar')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next placeholder","suites":["snippet provider","nextPlaceholder()"],"updatePoint":{"line":113,"column":36},"line":113,"code":"    it('should goto next placeholder', async () => {\n      await snippetManager.insertSnippet('${1:a} ${2:b}')\n      await snippetManager.nextPlaceholder()\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(3)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove keymap on nextPlaceholder when session not exits","suites":["snippet provider","nextPlaceholder()"],"updatePoint":{"line":120,"column":70},"line":120,"code":"    it('should remove keymap on nextPlaceholder when session not exits', async () => {\n      await nvim.call('coc#snippet#enable')\n      await snippetManager.nextPlaceholder()\n      let val = await doc.buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect preferCompleteThanJumpPlaceholder","suites":["snippet provider","nextPlaceholder()"],"updatePoint":{"line":127,"column":56},"line":127,"code":"    it('should respect preferCompleteThanJumpPlaceholder', async () => {\n      let config = workspace.getConfiguration('suggest')\n      config.update('preferCompleteThanJumpPlaceholder', true)\n      await nvim.setLine('foo')\n      await nvim.input('o')\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      await nvim.input('f')\n      await nvim.eval(`feedkeys(\"\\\\<C-n>\", 'in')`)\n      await helper.waitFor('pumvisible', [], 1)\n      await nvim.input('<C-j>')\n      await helper.waitFor('getline', ['.'], 'foo bar')\n      config.update('preferCompleteThanJumpPlaceholder', false)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto previous placeholder","suites":["snippet provider","previousPlaceholder()"],"updatePoint":{"line":143,"column":40},"line":143,"code":"    it('should goto previous placeholder', async () => {\n      await snippetManager.insertSnippet('${1:a} ${2:b}')\n      await snippetManager.nextPlaceholder()\n      await snippetManager.previousPlaceholder()\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(1)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove keymap on previousPlaceholder when session not exits","suites":["snippet provider","previousPlaceholder()"],"updatePoint":{"line":151,"column":74},"line":151,"code":"    it('should remove keymap on previousPlaceholder when session not exits', async () => {\n      await nvim.call('coc#snippet#enable')\n      await snippetManager.previousPlaceholder()\n      let val = await doc.buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check position on InsertEnter","suites":["snippet provider","Events"],"updatePoint":{"line":160,"column":44},"line":160,"code":"    it('should check position on InsertEnter', async () => {\n      await nvim.input('ibar<left><left><left>')\n      await snippetManager.insertSnippet('${1:foo} $1 ')\n      await nvim.input('<esc>A')\n      await helper.wait(50)\n      expect(snippetManager.session).toBeUndefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change status item on editor change","suites":["snippet provider","Events"],"updatePoint":{"line":168,"column":50},"line":168,"code":"    it('should change status item on editor change', async () => {\n      await nvim.command('tabe')\n      await workspace.document\n      await nvim.input('i')\n      await snippetManager.insertSnippet('${1:foo} $1 ')\n      let val = await nvim.getVar('coc_status')\n      expect(val).toBeDefined()\n      await nvim.setTabpage(nvim.createTabpage(1))\n      val = await nvim.getVar('coc_status') as string\n      expect(val.includes('SNIP')).toBeFalsy()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel snippet session","suites":["snippet provider","cancel()"],"updatePoint":{"line":182,"column":37},"line":182,"code":"    it('should cancel snippet session', async () => {\n      let buffer = doc.buffer\n      await nvim.call('coc#snippet#enable')\n      snippetManager.cancel()\n      let val = await buffer.getVar('coc_snippet_active')\n      expect(val).toBe(0)\n      let active = await snippetManager.insertSnippet('${1:foo}')\n      expect(active).toBe(true)\n      snippetManager.cancel()\n      expect(snippetManager.session).toBeUndefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check jumpable","suites":["snippet provider","jumpable()"],"updatePoint":{"line":196,"column":29},"line":196,"code":"    it('should check jumpable', async () => {\n      await nvim.input('i')\n      await snippetManager.insertSnippet('${1:foo} ${2:bar}')\n      let jumpable = snippetManager.jumpable()\n      expect(jumpable).toBe(true)\n      await snippetManager.nextPlaceholder()\n      jumpable = snippetManager.jumpable()\n      expect(jumpable).toBe(true)\n      await snippetManager.nextPlaceholder()\n      jumpable = snippetManager.jumpable()\n      expect(jumpable).toBe(false)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize when position changed and pum visible","suites":["snippet provider","synchronize text"],"updatePoint":{"line":211,"column":64},"line":211,"code":"    it('should synchronize when position changed and pum visible', async () => {\n      let doc = await workspace.document\n      await nvim.setLine('foo')\n      await nvim.input('o')\n      let res = await snippetManager.insertSnippet(\"`!p snip.rv = ' '*(4- len(t[1]))`${1}\", true, undefined, InsertTextMode.asIs, {})\n      expect(res).toBe(true)\n      let line = await nvim.line\n      expect(line).toBe('    ')\n      await nvim.input('f')\n      await nvim.eval(`feedkeys(\"\\\\<C-n>\",'in')`)\n      await helper.waitFor('pumvisible', [], 1)\n      await nvim.input('<C-e>')\n      let s = snippetManager.getSession(doc.bufnr)\n      expect(s).toBeDefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update placeholder on placeholder update","suites":["snippet provider","synchronize text"],"updatePoint":{"line":227,"column":55},"line":227,"code":"    it('should update placeholder on placeholder update', async () => {\n      await nvim.input('i')\n      await snippetManager.insertSnippet('$1\\n${1/,/|/g}', true, undefined, InsertTextMode.adjustIndentation, {})\n      await nvim.input('a,b')\n      await helper.wait(50)\n      let s = snippetManager.getSession(doc.bufnr)\n      await s.forceSynchronize()\n      let lines = await nvim.call('getline', [1, '$'])\n      expect(lines).toEqual(['a,b', 'a|b'])\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust cursor position on update","suites":["snippet provider","synchronize text"],"updatePoint":{"line":238,"column":47},"line":238,"code":"    it('should adjust cursor position on update', async () => {\n      await nvim.call('cursor', [1, 1])\n      await nvim.input('i')\n      await snippetManager.insertSnippet('${1/..*/ -> /}$1')\n      let line = await nvim.line\n      expect(line).toBe('')\n      await nvim.input('x')\n      let s = snippetManager.getSession(doc.bufnr)\n      expect(s).toBeDefined()\n      await s.forceSynchronize()\n      line = await nvim.line\n      expect(line).toBe(' -> x')\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(6)\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize text on change final placeholder","suites":["snippet provider","synchronize text"],"updatePoint":{"line":254,"column":59},"line":254,"code":"    it('should synchronize text on change final placeholder', async () => {\n      let doc = await workspace.document\n      await nvim.input('i')\n      let res = await snippetManager.insertSnippet('$0empty$0')\n      expect(res).toBe(true)\n      await nvim.call('nvim_buf_set_text', [doc.bufnr, 0, 0, 0, 0, ['abc']])\n      await doc.synchronize()\n      let s = snippetManager.getSession(doc.bufnr)\n      await s.forceSynchronize()\n      let line = await nvim.line\n      expect(line).toBe('abcemptyabc')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve snippet text","suites":["snippet provider","resolveSnippet()"],"updatePoint":{"line":269,"column":35},"line":269,"code":"    it('should resolve snippet text', async () => {\n      let snippet = await snippetManager.resolveSnippet('${1:foo}')\n      expect(snippet.toString()).toBe('foo')\n      snippet = await snippetManager.resolveSnippet('${1:foo} ${2:`!p snip.rv = \"foo\"`}', {})\n      expect(snippet.toString()).toBe('foo foo')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should avoid python resolve when necessary","suites":["snippet provider","resolveSnippet()"],"updatePoint":{"line":276,"column":50},"line":276,"code":"    it('should avoid python resolve when necessary', async () => {\n      await nvim.command('startinsert')\n      let res = await snippetManager.insertSnippet('${1:foo} `!p snip.rv = t[1]`', true, Range.create(0, 0, 0, 0), InsertTextMode.asIs, {})\n      expect(res).toBe(true)\n      let snippet = await snippetManager.resolveSnippet('${1:x} `!p snip.rv= t[1]`', {})\n      expect(snippet.toString()).toBe('x ')\n      res = await nvim.call('pyxeval', 't[1]')\n      expect(res).toBe('foo')\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose","suites":["snippet provider","dispose()"],"updatePoint":{"line":288,"column":22},"line":288,"code":"    it('should dispose', async () => {\n      let active = await snippetManager.insertSnippet('${1:foo}')\n      expect(active).toBe(true)\n      snippetManager.dispose()\n      expect(snippetManager.session).toBeUndefined()\n    })","file":"snippets/manager.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"transformEscapes","suites":["SnippetParser"],"updatePoint":{"line":8,"column":24},"line":8,"code":"  test('transformEscapes', () => {\n    assert.equal(transformEscapes('b\\\\uabc\\\\LDef'), 'bAbcdef')\n    assert.equal(transformEscapes('b\\\\Uabc\\\\Edef'), 'bABCdef')\n    assert.equal(transformEscapes('b\\\\LABC\\\\Edef'), 'babcdef')\n    assert.equal(transformEscapes(' \\\\n \\\\t'), ' \\n \\t')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Scanner","suites":["SnippetParser"],"updatePoint":{"line":15,"column":15},"line":15,"code":"  test('Scanner', () => {\n\n    const scanner = new Scanner()\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('{{abc}}')\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc() ')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.OpenParen)\n    assert.equal(scanner.next().type, TokenType.CloseParen)\n    assert.equal(scanner.next().type, TokenType.Format)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('abc 123')\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Format)\n    assert.equal(scanner.next().type, TokenType.Int)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo_bar')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('$foo-bar')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Dash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('${foo}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('${1223:foo}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.Int)\n    assert.equal(scanner.next().type, TokenType.Colon)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n\n    scanner.text('\\\\${}')\n    assert.equal(scanner.next().type, TokenType.Backslash)\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n\n    scanner.text('${foo/regex/format/option}')\n    assert.equal(scanner.next().type, TokenType.Dollar)\n    assert.equal(scanner.next().type, TokenType.CurlyOpen)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.Forwardslash)\n    assert.equal(scanner.next().type, TokenType.VariableName)\n    assert.equal(scanner.next().type, TokenType.CurlyClose)\n    assert.equal(scanner.next().type, TokenType.EOF)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, escaped","suites":["SnippetParser"],"updatePoint":{"line":133,"column":23},"line":133,"code":"  test('Parser, escaped', function() {\n    assertEscaped('foo$0', 'foo\\\\$0')\n    assertEscaped('foo\\\\$0', 'foo\\\\\\\\\\\\$0')\n    assertEscaped('f$1oo$0', 'f\\\\$1oo\\\\$0')\n    assertEscaped('${1:foo}$0', '\\\\${1:foo\\\\}\\\\$0')\n    assertEscaped('$', '\\\\$')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, escaped ultisnips","suites":["SnippetParser"],"updatePoint":{"line":141,"column":33},"line":141,"code":"  test('Parser, escaped ultisnips', () => {\n    const actual = new SnippetParser(true).text('t\\\\`a\\\\`\\n\\\\$ \\\\{\\\\}')\n    expect(actual).toBe('t`a`\\n$ {}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform with empty placeholder","suites":["SnippetParser"],"updatePoint":{"line":146,"column":48},"line":146,"code":"  test('Parser, transform with empty placeholder', () => {\n    const actual = new SnippetParser(true).text('${1} ${1/^(.*)/$1aa/}')\n    expect(actual).toBe(' aa')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, isPlainText()","suites":["SnippetParser"],"updatePoint":{"line":151,"column":29},"line":151,"code":"  test('Parser, isPlainText()', function() {\n    const s = (input: string, res: boolean) => {\n      assert.equal(SnippetParser.isPlainText(input), res)\n    }\n    s('abc', true)\n    s('abc$0', true)\n    s('ab$0chh', false)\n    s('ab$1chh', false)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, first placeholder / variable","suites":["SnippetParser"],"updatePoint":{"line":161,"column":44},"line":161,"code":"  test('Parser, first placeholder / variable', function() {\n    const first = (input: string): Marker => {\n      const p = new SnippetParser(true)\n      let s = p.parse(input, true)\n      return s.first\n    }\n    const assertPlaceholder = (m: any, index: number) => {\n      assert.equal(m instanceof Placeholder, true)\n      assert.equal(m.index, index)\n    }\n    assertPlaceholder(first('foo'), 0)\n    assertPlaceholder(first('${1:foo}'), 1)\n    assertPlaceholder(first('${2:foo}'), 2)\n    let f = first('$foo $bar') as Variable\n    assert.equal(f instanceof Variable, true)\n    assert.equal(f.name, 'foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, text","suites":["SnippetParser"],"updatePoint":{"line":179,"column":20},"line":179,"code":"  test('Parser, text', () => {\n    assertText('$', '$')\n    assertText('\\\\\\\\$', '\\\\$')\n    assertText('{', '{')\n    assertText('\\\\}', '}')\n    assertText('\\\\abc', '\\\\abc')\n    assertText('foo${f:\\\\}}bar', 'foo}bar')\n    assertText('\\\\{', '\\\\{')\n    assertText('I need \\\\\\\\\\\\$', 'I need \\\\$')\n    assertText('\\\\', '\\\\')\n    assertText('\\\\{{', '\\\\{{')\n    assertText('{{', '{{')\n    assertText('{{dd', '{{dd')\n    assertText('}}', '}}')\n    assertText('ff}}', 'ff}}')\n\n    assertText('farboo', 'farboo')\n    assertText('far{{}}boo', 'far{{}}boo')\n    assertText('far{{123}}boo', 'far{{123}}boo')\n    assertText('far\\\\{{123}}boo', 'far\\\\{{123}}boo')\n    assertText('far{{id:bern}}boo', 'far{{id:bern}}boo')\n    assertText('far{{id:bern {{basel}}}}boo', 'far{{id:bern {{basel}}}}boo')\n    assertText('far{{id:bern {{id:basel}}}}boo', 'far{{id:bern {{id:basel}}}}boo')\n    assertText('far{{id:bern {{id2:basel}}}}boo', 'far{{id:bern {{id2:basel}}}}boo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, TM text","suites":["SnippetParser"],"updatePoint":{"line":206,"column":23},"line":206,"code":"  test('Parser, TM text', () => {\n    assertTextAndMarker('foo${1:bar}}', 'foobar}', Text, Placeholder, Text)\n    assertTextAndMarker('foo${1:bar}${2:foo}}', 'foobarfoo}', Text, Placeholder, Placeholder, Text)\n\n    assertTextAndMarker('foo${1:bar\\\\}${2:foo}}', 'foobar}foo', Text, Placeholder)\n\n    let [, placeholder] = new SnippetParser().parse('foo${1:bar\\\\}${2:foo}}').children\n    let { children } = (<Placeholder>placeholder)\n\n    assert.equal((<Placeholder>placeholder).index, '1')\n    assert.ok(children[0] instanceof Text)\n    assert.equal(children[0].toString(), 'bar}')\n    assert.ok(children[1] instanceof Placeholder)\n    assert.equal(children[1].toString(), 'foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder","suites":["SnippetParser"],"updatePoint":{"line":222,"column":27},"line":222,"code":"  test('Parser, placeholder', () => {\n    assertTextAndMarker('farboo', 'farboo', Text)\n    assertTextAndMarker('far{{}}boo', 'far{{}}boo', Text)\n    assertTextAndMarker('far{{123}}boo', 'far{{123}}boo', Text)\n    assertTextAndMarker('far\\\\{{123}}boo', 'far\\\\{{123}}boo', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, literal code","suites":["SnippetParser"],"updatePoint":{"line":229,"column":28},"line":229,"code":"  test('Parser, literal code', () => {\n    assertTextAndMarker('far`123`boo', 'far`123`boo', Text)\n    assertTextAndMarker('far\\\\`123\\\\`boo', 'far\\\\`123\\\\`boo', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variables/tabstop","suites":["SnippetParser"],"updatePoint":{"line":234,"column":33},"line":234,"code":"  test('Parser, variables/tabstop', () => {\n    assertTextAndMarker('$far-boo', '-boo', Variable, Text)\n    assertTextAndMarker('\\\\$far-boo', '$far-boo', Text)\n    assertTextAndMarker('far$farboo', 'far', Text, Variable)\n    assertTextAndMarker('far${farboo}', 'far', Text, Variable)\n    assertTextAndMarker('$123', '', Placeholder)\n    assertTextAndMarker('$farboo', '', Variable)\n    assertTextAndMarker('$far12boo', '', Variable)\n    assertTextAndMarker('000_${far}_000', '000__000', Text, Variable, Text)\n    assertTextAndMarker('FFF_${TM_SELECTED_TEXT}_FFF$0', 'FFF__FFF', Text, Variable, Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variables/placeholder with defaults","suites":["SnippetParser"],"updatePoint":{"line":246,"column":51},"line":246,"code":"  test('Parser, variables/placeholder with defaults', () => {\n    assertTextAndMarker('${name:value}', 'value', Variable)\n    assertTextAndMarker('${1:value}', 'value', Placeholder)\n    assertTextAndMarker('${1:bar${2:foo}bar}', 'barfoobar', Placeholder)\n\n    assertTextAndMarker('${name:value', '${name:value', Text)\n    assertTextAndMarker('${1:bar${2:foobar}', '${1:barfoobar', Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, variable transforms","suites":["SnippetParser"],"updatePoint":{"line":255,"column":35},"line":255,"code":"  test('Parser, variable transforms', function() {\n    assertTextAndMarker('${foo///}', '', Variable)\n    assertTextAndMarker('${foo/regex/format/gmi}', '', Variable)\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/}', '', Variable)\n\n    // invalid regex\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/GMI}', '${foo/([A-Z][a-z])/format/GMI}', Text)\n    assertTextAndMarker('${foo/([A-Z][a-z])/format/funky}', '${foo/([A-Z][a-z])/format/funky}', Text)\n    assertTextAndMarker('${foo/([A-Z][a-z]/format/}', '${foo/([A-Z][a-z]/format/}', Text)\n\n    // tricky regex\n    assertTextAndMarker('${foo/m\\\\/atch/$1/i}', '', Variable)\n    assertMarker('${foo/regex\\/format/options}', Text)\n\n    // incomplete\n    assertTextAndMarker('${foo///', '${foo///', Text)\n    assertTextAndMarker('${foo/regex/format/options', '${foo/regex/format/options', Text)\n\n    // format string\n    assertMarker('${foo/.*/${0:fooo}/i}', Variable)\n    assertMarker('${foo/.*/${1}/i}', Variable)\n    assertMarker('${foo/.*/$1/i}', Variable)\n    assertMarker('${foo/.*/This-$1-encloses/i}', Variable)\n    assertMarker('${foo/.*/complex${1:else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:-else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:+if}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:?if:else}/i}', Variable)\n    assertMarker('${foo/.*/complex${1:/upcase}/i}', Variable)\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parse, parse code block","suites":["SnippetParser"],"updatePoint":{"line":286,"column":31},"line":286,"code":"  test('Parse, parse code block', () => {\n    assertText('aa \\\\`echo\\\\`', 'aa `echo`', true)\n    assertText('aa `xyz`', 'aa ', true)\n    assertText('aa `!v xyz`', 'aa ', true)\n    assertText('aa `!p xyz`', 'aa ', true)\n    assertText('aa `!p foo\\nbar`', 'aa ', true)\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    assertMarker(c('`foo`'), CodeBlock)\n    assertMarker(c('`!v bar`'), CodeBlock)\n    assertMarker(c('`!p python`'), CodeBlock)\n    const assertPlaceholder = (text: string, kind: EvalKind, code: string) => {\n      let p = c(text).children[0]\n      assert.ok(p instanceof Placeholder)\n      let m = p.children[0] as CodeBlock\n      assert.ok(m instanceof CodeBlock)\n      assert.equal(m.kind, kind)\n      assert.equal(m.code, code)\n    }\n    assertPlaceholder('${1:` foo `}', 'shell', 'foo')\n    assertPlaceholder('${1:`!v bar`}', 'vim', 'bar')\n    assertPlaceholder('${1:`!p python`}', 'python', 'python')\n    assertPlaceholder('${1:`!p x\\\\`y`}', 'python', 'x\\\\`y')\n    assertPlaceholder('${1:`!p x\\ny`}', 'python', 'x\\ny')\n    assertPlaceholder('${1:`!p \\nx\\ny`}', 'python', 'x\\ny')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, CodeBlock toTextmateString","suites":["SnippetParser"],"updatePoint":{"line":314,"column":42},"line":314,"code":"  test('Parser, CodeBlock toTextmateString', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    expect(c('`foo`').toTextmateString()).toBe('`foo`')\n    expect(c('`!p snip.rv`').toTextmateString()).toBe('`!p snip.rv`')\n    expect(c('`!v \"var\"`').toTextmateString()).toBe('`!v \"var\"`')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with CodeBlock primary","suites":["SnippetParser"],"updatePoint":{"line":323,"column":50},"line":323,"code":"  test('Parser, placeholder with CodeBlock primary', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${1/^_(.*)/$1/} $1 aa ${1:`!p snip.rv = \"_foo\"`}')\n    let arr = s.placeholders\n    arr = arr.filter(o => o.index == 1)\n    assert.equal(arr.length, 3)\n    let filtered = arr.filter(o => o.primary === true)\n    assert.equal(filtered.length, 1)\n    assert.equal(filtered[0], arr[2])\n    let childs = arr.map(o => o.children[0])\n    assert.ok(childs[0] instanceof Text)\n    assert.ok(childs[1] instanceof Text)\n    assert.ok(childs[2] instanceof CodeBlock)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with CodeBlock not primary","suites":["SnippetParser"],"updatePoint":{"line":340,"column":54},"line":340,"code":"  test('Parser, placeholder with CodeBlock not primary', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${1/^_(.*)/$1/} ${1:_foo} ${2:bar} $1 $3 ${1:`!p snip.rv = \"three\"`}')\n    let arr = s.placeholders\n    arr = arr.filter(o => o.index == 1)\n    assert.equal(arr.length, 4)\n    assert.ok(arr[0].transform)\n    assert.equal(arr[1].primary, true)\n    assert.equal(arr[2].toString(), '_foo')\n    assert.equal(arr[3].toString(), '_foo')\n    assert.deepEqual(s.values, { '0': '', '1': '_foo', '2': 'bar', '3': '' })\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, python CodeBlock with related","suites":["SnippetParser"],"updatePoint":{"line":355,"column":45},"line":355,"code":"  test('Parser, python CodeBlock with related', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${1:_foo} ${2:bar} $1 $3 ${3:`!p snip.rv = str(t[1]) + str(t[2])`}')\n    let b = s.pyBlocks[0]\n    expect(b).toBeDefined()\n    expect(b.related).toEqual([1, 2])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, python CodeBlock by sequence","suites":["SnippetParser"],"updatePoint":{"line":365,"column":44},"line":365,"code":"  test('Parser, python CodeBlock by sequence', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${2:\\{${3:`!p foo`}\\}} ${1:`!p bar`}')\n    let arr = s.pyBlocks\n    expect(arr[0].code).toBe('foo')\n    expect(arr[1].code).toBe('bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, hasPython()","suites":["SnippetParser"],"updatePoint":{"line":375,"column":27},"line":375,"code":"  test('Parser, hasPython()', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    assert.equal(c('${1:`!p foo`}').hasPython, true)\n    assert.equal(c('`!p foo`').hasPython, true)\n    assert.equal(c('$1').hasPython, false)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, hasCodeBlock()","suites":["SnippetParser"],"updatePoint":{"line":384,"column":30},"line":384,"code":"  test('Parser, hasCodeBlock()', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    assert.equal(c('${1:`!p foo`}').hasCodeBlock, true)\n    assert.equal(c('`!p foo`').hasCodeBlock, true)\n    assert.equal(c('$1').hasCodeBlock, false)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, resolved variable","suites":["SnippetParser"],"updatePoint":{"line":393,"column":33},"line":393,"code":"  test('Parser, resolved variable', () => {\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${1:${VISUAL}} $1')\n    assert.ok(s.children[0] instanceof Placeholder)\n    assert.ok(s.children[0].children[0] instanceof Variable)\n    let v = s.children[0].children[0] as Variable\n    assert.equal(v.name, 'VISUAL')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser variable with code","suites":["SnippetParser"],"updatePoint":{"line":404,"column":33},"line":404,"code":"  test('Parser variable with code', () => {\n    // not allowed on ultisnips.\n    const c = text => {\n      return (new SnippetParser(true)).parse(text)\n    }\n    let s = c('${foo:`!p snip.rv = \"bar\"`}')\n    assert.ok(s.children[0] instanceof Variable)\n    assert.ok(s.children[0].children[0] instanceof CodeBlock)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform condition if text","suites":["SnippetParser"],"updatePoint":{"line":414,"column":43},"line":414,"code":"  test('Parser, transform condition if text', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('begin|${1:t}${1/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}')\n    expect(snip.toString()).toBe('begin|tabular')\n    let m = snip.placeholders.find(o => o.index == 1 && o.primary)\n    snip.resetMarker(m, 'a')\n    expect(snip.toString()).toBe('begin|array')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform condition not match","suites":["SnippetParser"],"updatePoint":{"line":423,"column":45},"line":423,"code":"  test('Parser, transform condition not match', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:xyz} ${1/^(f)(b?)/(?2:_:two)/}')\n    expect(snip.toString()).toBe('xyz xyz')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform backslash in condition","suites":["SnippetParser"],"updatePoint":{"line":429,"column":48},"line":429,"code":"  test('Parser, transform backslash in condition', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:foo} ${1/^(f)/(?1:x\\\\)\\\\:a:two)/}')\n    expect(snip.toString()).toBe('foo x):aoo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform backslash in format string","suites":["SnippetParser"],"updatePoint":{"line":435,"column":52},"line":435,"code":"  test('Parser, transform backslash in format string', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:\\\\n} ${1/^(\\\\\\\\n)/$1aa/}')\n    expect(snip.toString()).toBe('\\\\n \\\\naa')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, ultisnips transform replacement","suites":["SnippetParser"],"updatePoint":{"line":441,"column":47},"line":441,"code":"  test('Parser, ultisnips transform replacement', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:foo} ${1/^\\\\w/$0_/}')\n    expect(snip.toString()).toBe('foo f_oo')\n    snip = p.parse('${1:foo} ${1/^\\\\w//}')\n    expect(snip.toString()).toBe('foo oo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, convert ultisnips regex","suites":["SnippetParser"],"updatePoint":{"line":449,"column":39},"line":449,"code":"  test('Parser, convert ultisnips regex', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:foo} ${1/^\\\\A/_/}')\n    expect(snip.toString()).toBe('foo _foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform condition else text","suites":["SnippetParser"],"updatePoint":{"line":455,"column":45},"line":455,"code":"  test('Parser, transform condition else text', () => {\n    const p = new SnippetParser(true)\n    let snip = p.parse('${1:foo} ${1/^(f)(b?)/(?2:_:two)/}')\n    expect(snip.toString()).toBe('foo twooo')\n    let m = snip.placeholders.find(o => o.index == 1 && o.primary)\n    snip.resetMarker(m, 'fb')\n    expect(snip.toString()).toBe('fb _')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform escape sequence","suites":["SnippetParser"],"updatePoint":{"line":464,"column":41},"line":464,"code":"  test('Parser, transform escape sequence', () => {\n    const p = new SnippetParser(true)\n    const snip = p.parse('${1:a text}\\n${1/\\\\w+\\\\s*/\\\\u$0/}')\n    expect(snip.toString()).toBe('a text\\nA text')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform backslash","suites":["SnippetParser"],"updatePoint":{"line":470,"column":35},"line":470,"code":"  test('Parser, transform backslash', () => {\n    const p = new SnippetParser(true)\n    const snip = p.parse('${1:a}\\n${1/\\\\w+/\\\\(\\\\)\\\\:\\\\x\\\\\\\\y/}')\n    expect(snip.toString()).toBe('a\\n():\\\\x\\\\\\\\y')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform with ascii option","suites":["SnippetParser"],"updatePoint":{"line":476,"column":43},"line":476,"code":"  test('Parser, transform with ascii option', () => {\n    let p = new SnippetParser()\n    let snip = p.parse('${1:pche}\\n${1/.*/$0/a}')\n    expect(snip.toString()).toBe('pche\\npeche')\n    p = new SnippetParser()\n    snip = p.parse('${1/.*/$0/a}\\n${1:pche}')\n    expect(snip.toString()).toBe('peche\\npche')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with transform","suites":["SnippetParser"],"updatePoint":{"line":485,"column":42},"line":485,"code":"  test('Parser, placeholder with transform', () => {\n    const p = new SnippetParser()\n    const snippet = p.parse('${1:type}${1/(.+)/ /}')\n    let s = snippet.toString()\n    assert.equal(s.length, 5)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder transforms","suites":["SnippetParser"],"updatePoint":{"line":492,"column":38},"line":492,"code":"  test('Parser, placeholder transforms', function() {\n    assertTextAndMarker('${1///}', '', Placeholder)\n    assertTextAndMarker('${1/regex/format/gmi}', '', Placeholder)\n    assertTextAndMarker('${1/([A-Z][a-z])/format/}', '', Placeholder)\n    assertTextAndMarker('${1///}', '', Placeholder)\n\n    // tricky regex\n    assertTextAndMarker('${1/m\\\\/atch/$1/i}', '', Placeholder)\n    assertMarker('${1/regex\\/format/options}', Text)\n\n    // incomplete\n    assertTextAndMarker('${1///', '${1///', Text)\n    assertTextAndMarker('${1/regex/format/options', '${1/regex/format/options', Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"No way to escape forward slash in snippet regex #36715","suites":["SnippetParser"],"updatePoint":{"line":507,"column":62},"line":507,"code":"  test('No way to escape forward slash in snippet regex #36715', function() {\n    assertMarker('${TM_DIRECTORY/src\\\\//$1/}', Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"No way to escape forward slash in snippet format section #37562","suites":["SnippetParser"],"updatePoint":{"line":511,"column":71},"line":511,"code":"  test('No way to escape forward slash in snippet format section #37562', function() {\n    assertMarker('${TM_SELECTED_TEXT/a/\\\\/$1/g}', Variable)\n    assertMarker('${TM_SELECTED_TEXT/a/in\\\\/$1ner/g}', Variable)\n    assertMarker('${TM_SELECTED_TEXT/a/end\\\\//g}', Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, placeholder with choice","suites":["SnippetParser"],"updatePoint":{"line":517,"column":39},"line":517,"code":"  test('Parser, placeholder with choice', () => {\n\n    assertTextAndMarker('${1|one,two,three|}', 'one', Placeholder)\n    assertTextAndMarker('${1|one|}', 'one', Placeholder)\n    assertTextAndMarker('${1|one1,two2|}', 'one1', Placeholder)\n    assertTextAndMarker('${1|one1\\\\,two2|}', 'one1,two2', Placeholder)\n    assertTextAndMarker('${1|one1\\\\|two2|}', 'one1|two2', Placeholder)\n    assertTextAndMarker('${1|one1\\\\atwo2|}', 'one1\\\\atwo2', Placeholder)\n    assertTextAndMarker('${1|one,two,three,|}', '${1|one,two,three,|}', Text)\n    assertTextAndMarker('${1|one,', '${1|one,', Text)\n\n    const p = new SnippetParser()\n    const snippet = p.parse('${1|one,two,three|}')\n    assertMarker(snippet, Placeholder)\n    const expected = [Placeholder, Text, Text, Text]\n    snippet.walk(marker => {\n      assert.equal(marker, expected.shift())\n      return true\n    })\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet choices: unable to escape comma and pipe, #31521","suites":["SnippetParser"],"updatePoint":{"line":538,"column":64},"line":538,"code":"  test('Snippet choices: unable to escape comma and pipe, #31521', function() {\n    assertTextAndMarker('console.log(${1|not\\\\, not, five, 5, 1   23|});', 'console.log(not, not);', Text, Placeholder, Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Marker, toTextmateString()","suites":["SnippetParser"],"updatePoint":{"line":542,"column":34},"line":542,"code":"  test('Marker, toTextmateString()', function() {\n\n    function assertTextsnippetString(input: string, expected: string): void {\n      const snippet = new SnippetParser().parse(input)\n      const actual = snippet.toTextmateString()\n      assert.equal(actual, expected)\n    }\n\n    assertTextsnippetString('$1', '$1')\n    assertTextsnippetString('\\\\$1', '\\\\$1')\n    assertTextsnippetString('console.log(${1|not\\\\, not, five, 5, 1   23|});', 'console.log(${1|not\\\\, not, five, 5, 1   23|});')\n    assertTextsnippetString('console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});', 'console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});')\n    assertTextsnippetString('this is text', 'this is text')\n    assertTextsnippetString('this ${1:is ${2:nested with $var}}', 'this ${1:is ${2:nested with ${var}}}')\n    assertTextsnippetString('this ${1:is ${2:nested with $var}}}', 'this ${1:is ${2:nested with ${var}}}\\\\}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Marker, toTextmateString() <-> identity","suites":["SnippetParser"],"updatePoint":{"line":559,"column":47},"line":559,"code":"  test('Marker, toTextmateString() <-> identity', function() {\n\n    function assertIdent(input: string): void {\n      // full loop: (1) parse input, (2) generate textmate string, (3) parse, (4) ensure both trees are equal\n      const snippet = new SnippetParser().parse(input)\n      const input2 = snippet.toTextmateString()\n      const snippet2 = new SnippetParser().parse(input2)\n\n      function checkCheckChildren(marker1: Marker, marker2: Marker) {\n        assert.ok(marker1 instanceof Object.getPrototypeOf(marker2).constructor)\n        assert.ok(marker2 instanceof Object.getPrototypeOf(marker1).constructor)\n\n        assert.equal(marker1.children.length, marker2.children.length)\n        assert.equal(marker1.toString(), marker2.toString())\n\n        for (let i = 0; i < marker1.children.length; i++) {\n          checkCheckChildren(marker1.children[i], marker2.children[i])\n        }\n      }\n\n      checkCheckChildren(snippet, snippet2)\n    }\n\n    assertIdent('$1')\n    assertIdent('\\\\$1')\n    assertIdent('console.log(${1|not\\\\, not, five, 5, 1   23|});')\n    assertIdent('console.log(${1|not\\\\, not, \\\\| five, 5, 1   23|});')\n    assertIdent('this is text')\n    assertIdent('this ${1:is ${2:nested with $var}}')\n    assertIdent('this ${1:is ${2:nested with $var}}}')\n    assertIdent('this ${1:is ${2:nested with $var}} and repeating $1')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, choice marker","suites":["SnippetParser"],"updatePoint":{"line":592,"column":29},"line":592,"code":"  test('Parser, choice marker', () => {\n    const { placeholders } = new SnippetParser().parse('${1|one,two,three|}')\n\n    assert.equal(placeholders.length, 1)\n    assert.ok(placeholders[0].choice instanceof Choice)\n    assert.ok(placeholders[0].children[0] instanceof Choice)\n    assert.equal((<Choice>placeholders[0].children[0]).options.length, 3)\n\n    assertText('${1|one,two,three|}', 'one')\n    assertText('\\\\${1|one,two,three|}', '${1|one,two,three|}')\n    assertText('${1\\\\|one,two,three|}', '${1\\\\|one,two,three|}')\n    assertText('${1||}', '${1||}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Backslash character escape in choice tabstop doesn't work #58494","suites":["SnippetParser"],"updatePoint":{"line":606,"column":73},"line":606,"code":"  test('Backslash character escape in choice tabstop doesn\\'t work #58494', function() {\n\n    const { placeholders } = new SnippetParser().parse('${1|\\\\,,},$,\\\\|,\\\\\\\\|}')\n    assert.equal(placeholders.length, 1)\n    assert.ok(placeholders[0].choice instanceof Choice)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, only textmate","suites":["SnippetParser"],"updatePoint":{"line":613,"column":29},"line":613,"code":"  test('Parser, only textmate', () => {\n    const p = new SnippetParser()\n    assertMarker(p.parse('far{{}}boo'), Text)\n    assertMarker(p.parse('far{{123}}boo'), Text)\n    assertMarker(p.parse('far\\\\{{123}}boo'), Text)\n\n    assertMarker(p.parse('far$0boo'), Text, Placeholder, Text)\n    assertMarker(p.parse('far${123}boo'), Text, Placeholder, Text)\n    assertMarker(p.parse('far\\\\${123}boo'), Text)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, real world","suites":["SnippetParser"],"updatePoint":{"line":624,"column":26},"line":624,"code":"  test('Parser, real world', () => {\n    let marker = new SnippetParser().parse('console.warn(${1: $TM_SELECTED_TEXT })').children\n\n    assert.equal(marker[0].toString(), 'console.warn(')\n    assert.ok(marker[1] instanceof Placeholder)\n    assert.equal(marker[2].toString(), ')')\n\n    const placeholder = <Placeholder>marker[1]\n    assert.equal(placeholder, false)\n    assert.equal(placeholder.index, '1')\n    assert.equal(placeholder.children.length, 3)\n    assert.ok(placeholder.children[0] instanceof Text)\n    assert.ok(placeholder.children[1] instanceof Variable)\n    assert.ok(placeholder.children[2] instanceof Text)\n    assert.equal(placeholder.children[0].toString(), ' ')\n    assert.equal(placeholder.children[1].toString(), '')\n    assert.equal(placeholder.children[2].toString(), ' ')\n\n    const nestedVariable = <Variable>placeholder.children[1]\n    assert.equal(nestedVariable.name, 'TM_SELECTED_TEXT')\n    assert.equal(nestedVariable.children.length, 0)\n\n    marker = new SnippetParser().parse('$TM_SELECTED_TEXT').children\n    assert.equal(marker.length, 1)\n    assert.ok(marker[0] instanceof Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, transform example","suites":["SnippetParser"],"updatePoint":{"line":651,"column":33},"line":651,"code":"  test('Parser, transform example', () => {\n    let { children } = new SnippetParser().parse('${1:name} : ${2:type}${3/\\\\s:=(.*)/${1:+ :=}${1}/};\\n$0')\n\n    //${1:name}\n    assert.ok(children[0] instanceof Placeholder)\n    assert.equal(children[0].children.length, 1)\n    assert.equal(children[0].children[0].toString(), 'name')\n    assert.equal((<Placeholder>children[0]).transform, undefined)\n\n    // :\n    assert.ok(children[1] instanceof Text)\n    assert.equal(children[1].toString(), ' : ')\n\n    //${2:type}\n    assert.ok(children[2] instanceof Placeholder)\n    assert.equal(children[2].children.length, 1)\n    assert.equal(children[2].children[0].toString(), 'type')\n\n    //${3/\\\\s:=(.*)/${1:+ :=}${1}/}\n    assert.ok(children[3] instanceof Placeholder)\n    assert.equal(children[3].children.length, 1)\n    assert.notEqual((<Placeholder>children[3]).transform, undefined)\n    let transform = (<Placeholder>children[3]).transform\n    assert.equal(transform.regexp, '/\\\\s:=(.*)/')\n    assert.equal(transform.children.length, 2)\n    assert.ok(transform.children[0] instanceof FormatString)\n    assert.equal((<FormatString>transform.children[0]).index, 1)\n    assert.equal((<FormatString>transform.children[0]).ifValue, ' :=')\n    assert.ok(transform.children[1] instanceof FormatString)\n    assert.equal((<FormatString>transform.children[1]).index, 1)\n    assert.ok(children[4] instanceof Text)\n    assert.equal(children[4].toString(), ';\\n')\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, default placeholder values","suites":["SnippetParser"],"updatePoint":{"line":686,"column":42},"line":686,"code":"  test('Parser, default placeholder values', () => {\n\n    assertMarker('errorContext: `${1:err}`, error: $1', Text, Placeholder, Text, Placeholder)\n\n    const [, p1, , p2] = new SnippetParser().parse('errorContext: `${1:err}`, error:$1').children\n\n    assert.equal((<Placeholder>p1).index, '1')\n    assert.equal((<Placeholder>p1).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p1).children[0]), 'err')\n\n    assert.equal((<Placeholder>p2).index, '1')\n    assert.equal((<Placeholder>p2).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p2).children[0]), 'err')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Parser, default placeholder values and one transform","suites":["SnippetParser"],"updatePoint":{"line":701,"column":60},"line":701,"code":"  test('Parser, default placeholder values and one transform', () => {\n\n    assertMarker('errorContext: `${1:err}`, error: ${1/err/ok/}', Text, Placeholder, Text, Placeholder)\n\n    const [, p3, , p4] = new SnippetParser().parse('errorContext: `${1:err}`, error:${1/err/ok/}').children\n\n    assert.equal((<Placeholder>p3).index, '1')\n    assert.equal((<Placeholder>p3).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p3).children[0]), 'err')\n    assert.equal((<Placeholder>p3).transform, undefined)\n\n    assert.equal((<Placeholder>p4).index, '1')\n    assert.equal((<Placeholder>p4).children.length, '1')\n    assert.equal((<Text>(<Placeholder>p4).children[0]), 'ok')\n    assert.notEqual((<Placeholder>p4).transform, undefined)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Repeated snippet placeholder should always inherit, #31040","suites":["SnippetParser"],"updatePoint":{"line":718,"column":66},"line":718,"code":"  test('Repeated snippet placeholder should always inherit, #31040', function() {\n    assertText('${1:foo}-abc-$1', 'foo-abc-foo')\n    assertText('${1:foo}-abc-${1}', 'foo-abc-foo')\n    assertText('${1:foo}-abc-${1:bar}', 'foo-abc-foo')\n    assertText('${1}-abc-${1:foo}', 'foo-abc-foo')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"backspace esapce in TM only, #16212","suites":["SnippetParser"],"updatePoint":{"line":725,"column":43},"line":725,"code":"  test('backspace esapce in TM only, #16212', () => {\n    const actual = new SnippetParser().text('Foo \\\\\\\\${abc}bar')\n    assert.equal(actual, 'Foo \\\\bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"colon as variable/placeholder value, #16717","suites":["SnippetParser"],"updatePoint":{"line":730,"column":51},"line":730,"code":"  test('colon as variable/placeholder value, #16717', () => {\n    let actual = new SnippetParser().text('${TM_SELECTED_TEXT:foo:bar}')\n    assert.equal(actual, 'foo:bar')\n\n    actual = new SnippetParser().text('${1:foo:bar}')\n    assert.equal(actual, 'foo:bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"incomplete placeholder","suites":["SnippetParser"],"updatePoint":{"line":738,"column":30},"line":738,"code":"  test('incomplete placeholder', () => {\n    assertTextAndMarker('${1:}', '', Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"marker#len","suites":["SnippetParser"],"updatePoint":{"line":742,"column":18},"line":742,"code":"  test('marker#len', () => {\n\n    function assertLen(template: string, ...lengths: number[]): void {\n      const snippet = new SnippetParser().parse(template, true)\n      snippet.walk(m => {\n        const expected = lengths.shift()\n        assert.equal(m.len(), expected)\n        return true\n      })\n      assert.equal(lengths.length, 0)\n    }\n\n    assertLen('text$0', 4, 0)\n    assertLen('$1text$0', 0, 4, 0)\n    assertLen('te$1xt$0', 2, 0, 2, 0)\n    assertLen('errorContext: `${1:err}`, error: $0', 15, 0, 3, 10, 0)\n    assertLen('errorContext: `${1:err}`, error: $1$0', 15, 0, 3, 10, 0, 3, 0)\n    assertLen('$TM_SELECTED_TEXT$0', 0, 0)\n    assertLen('${TM_SELECTED_TEXT:def}$0', 0, 3, 0)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"parser, parent node","suites":["SnippetParser"],"updatePoint":{"line":763,"column":27},"line":763,"code":"  test('parser, parent node', function() {\n    let snippet = new SnippetParser().parse('This ${1:is ${2:nested}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    let [first, second] = snippet.placeholders\n    assert.equal(first.index, '1')\n    assert.equal(second.index, '2')\n    assert.ok(second.parent === first)\n    assert.ok(first.parent === snippet)\n\n    snippet = new SnippetParser().parse('${VAR:default${1:value}}$0', true)\n    assert.equal(snippet.placeholders.length, 2)\n      ;[first] = snippet.placeholders\n    assert.equal(first.index, '1')\n\n    assert.ok(snippet.children[0] instanceof Variable)\n    assert.ok(first.parent === snippet.children[0])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#enclosingPlaceholders","suites":["SnippetParser"],"updatePoint":{"line":782,"column":45},"line":782,"code":"  test('TextmateSnippet#enclosingPlaceholders', () => {\n    let snippet = new SnippetParser().parse('This ${1:is ${2:nested}}$0', true)\n    let [first, second] = snippet.placeholders\n\n    assert.deepEqual(snippet.enclosingPlaceholders(first), [])\n    assert.deepEqual(snippet.enclosingPlaceholders(second), [first])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#getTextBefore","suites":["SnippetParser"],"updatePoint":{"line":790,"column":37},"line":790,"code":"  test('TextmateSnippet#getTextBefore', () => {\n    let snippet = new SnippetParser().parse('This ${1:is ${2:nested}}$0', true)\n    expect(snippet.getTextBefore(snippet, undefined)).toBe('')\n    let [first, second] = snippet.placeholders\n    expect(snippet.getTextBefore(second, first)).toBe('is ')\n    snippet = new SnippetParser().parse('This ${1:foo ${2:is ${3:nested}}} $0', true)\n    let arr = snippet.placeholders\n    expect(snippet.getTextBefore(arr[2], arr[0])).toBe('foo is ')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#offset","suites":["SnippetParser"],"updatePoint":{"line":800,"column":30},"line":800,"code":"  test('TextmateSnippet#offset', () => {\n    let snippet = new SnippetParser().parse('te$1xt', true)\n    assert.equal(snippet.offset(snippet.children[0]), 0)\n    assert.equal(snippet.offset(snippet.children[1]), 2)\n    assert.equal(snippet.offset(snippet.children[2]), 2)\n\n    snippet = new SnippetParser().parse('${TM_SELECTED_TEXT:def}', true)\n    assert.equal(snippet.offset(snippet.children[0]), 0)\n    assert.equal(snippet.offset((<Variable>snippet.children[0]).children[0]), 0)\n\n    // forgein marker\n    assert.equal(snippet.offset(new Text('foo')), -1)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#deleteText","suites":["SnippetParser"],"updatePoint":{"line":814,"column":34},"line":814,"code":"  test('TextmateSnippet#deleteText', () => {\n    let snippet = new SnippetParser().parse('foo ${1:bar}', true)\n    let res = snippet.deleteText(2, 2)\n    expect(res).toBe(true)\n    expect(snippet.toString()).toBe('fobar')\n    res = snippet.deleteText(2, 5)\n    expect(res).toBe(false)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#placeholder","suites":["SnippetParser"],"updatePoint":{"line":823,"column":35},"line":823,"code":"  test('TextmateSnippet#placeholder', () => {\n    let snippet = new SnippetParser().parse('te$1xt$0', true)\n    let placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 2)\n\n    snippet = new SnippetParser().parse('te$1xt$1$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n\n\n    snippet = new SnippetParser().parse('te$1xt$2$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n\n    snippet = new SnippetParser().parse('${1:bar${2:foo}bar}$0', true)\n    placeholders = snippet.placeholders\n    assert.equal(placeholders.length, 3)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#replace 1/2","suites":["SnippetParser"],"updatePoint":{"line":842,"column":35},"line":842,"code":"  test('TextmateSnippet#replace 1/2', function() {\n    let snippet = new SnippetParser().parse('aaa${1:bbb${2:ccc}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    const [, second] = snippet.placeholders\n    assert.equal(second.index, '2')\n\n    const enclosing = snippet.enclosingPlaceholders(second)\n    assert.equal(enclosing.length, 1)\n    assert.equal(enclosing[0].index, '1')\n    let marker = snippet.placeholders.find(o => o.index == 2)\n    let nested = new SnippetParser().parse('ddd$1eee$0', true)\n    snippet.replace(marker, nested.children)\n\n    assert.equal(snippet.toString(), 'aaabbbdddeee')\n    assert.equal(snippet.placeholders.length, 5)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#replace 2/2","suites":["SnippetParser"],"updatePoint":{"line":860,"column":35},"line":860,"code":"  test('TextmateSnippet#replace 2/2', function() {\n    let snippet = new SnippetParser().parse('aaa${1:bbb${2:ccc}}$0', true)\n\n    assert.equal(snippet.placeholders.length, 3)\n    const [, second] = snippet.placeholders\n    assert.equal(second.index, '2')\n\n    let nested = new SnippetParser().parse('dddeee$0', true)\n    snippet.replace(second, nested.children)\n\n    assert.equal(snippet.toString(), 'aaabbbdddeee')\n    assert.equal(snippet.placeholders.length, 4)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"TextmateSnippet#insertSnippet","suites":["SnippetParser"],"updatePoint":{"line":874,"column":37},"line":874,"code":"  test('TextmateSnippet#insertSnippet', function() {\n    let snippet = new SnippetParser().parse('${1:aaa} bbb ${2:ccc}}$0', true)\n    let marker = snippet.placeholders.find(o => o.index == 1)\n    snippet.insertSnippet('${1:dd} ${2:ff}', marker, ['', 'aaa'])\n    let arr = snippet.placeholders.map(p => p.index)\n    expect(arr).toEqual([1, 2, 3, 4, 5, 0])\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Maximum call stack size exceeded, #28983","suites":["SnippetParser"],"updatePoint":{"line":882,"column":48},"line":882,"code":"  test('Maximum call stack size exceeded, #28983', function() {\n    new SnippetParser().parse('${1:${foo:${1}}}')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet can freeze the editor, #30407","suites":["SnippetParser"],"updatePoint":{"line":886,"column":45},"line":886,"code":"  test('Snippet can freeze the editor, #30407', function() {\n\n    const seen = new Set<Marker>()\n\n    seen.clear()\n    new SnippetParser().parse('class ${1:${TM_FILENAME/(?:\\\\A|_)([A-Za-z0-9]+)(?:\\\\.rb)?/(?2::\\\\u$1)/g}} < ${2:Application}Controller\\n  $3\\nend').walk(marker => {\n      assert.ok(!seen.has(marker))\n      seen.add(marker)\n      return true\n    })\n\n    seen.clear()\n    new SnippetParser().parse('${1:${FOO:abc$1def}}').walk(marker => {\n      assert.ok(!seen.has(marker))\n      seen.add(marker)\n      return true\n    })\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippets: make parser ignore `${0|choice|}`, #31599","suites":["SnippetParser"],"updatePoint":{"line":905,"column":59},"line":905,"code":"  test('Snippets: make parser ignore `${0|choice|}`, #31599', function() {\n    assertTextAndMarker('${0|foo,bar|}', '${0|foo,bar|}', Text)\n    assertTextAndMarker('${1|foo,bar|}', 'foo', Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Transform -> FormatString#resolve","suites":["SnippetParser"],"updatePoint":{"line":911,"column":41},"line":911,"code":"  test('Transform -> FormatString#resolve', function() {\n\n    // shorthand functions\n    assert.equal(new FormatString(1, 'upcase').resolve('foo'), 'FOO')\n    assert.equal(new FormatString(1, 'downcase').resolve('FOO'), 'foo')\n    assert.equal(new FormatString(1, 'capitalize').resolve('bar'), 'Bar')\n    assert.equal(new FormatString(1, 'capitalize').resolve('bar no repeat'), 'Bar no repeat')\n    assert.equal(new FormatString(1, 'pascalcase').resolve('bar-foo'), 'BarFoo')\n    assert.equal(new FormatString(1, 'notKnown').resolve('input'), 'input')\n\n    // if\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve(undefined), '')\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve(''), '')\n    assert.equal(new FormatString(1, undefined, 'foo', undefined).resolve('bar'), 'foo')\n\n    // else\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve(undefined), 'foo')\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve(''), 'foo')\n    assert.equal(new FormatString(1, undefined, undefined, 'foo').resolve('bar'), 'bar')\n\n    // if-else\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve(undefined), 'foo')\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve(''), 'foo')\n    assert.equal(new FormatString(1, undefined, 'bar', 'foo').resolve('baz'), 'bar')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet variable transformation doesn't work if regex is complicated and snippet body contains '$$' #55627","suites":["SnippetParser"],"updatePoint":{"line":937,"column":117},"line":937,"code":"  test('Snippet variable transformation doesn\\'t work if regex is complicated and snippet body contains \\'$$\\' #55627', function() {\n    const snippet = new SnippetParser().parse('const fileName = \"${TM_FILENAME/(.*)\\\\..+$/$1/}\"')\n    assert.equal(snippet.toTextmateString(), 'const fileName = \"${TM_FILENAME/(.*)\\\\..+$/${1}/}\"')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"[BUG] HTML attribute suggestions: Snippet session does not have end-position set, #33147","suites":["SnippetParser"],"updatePoint":{"line":942,"column":96},"line":942,"code":"  test('[BUG] HTML attribute suggestions: Snippet session does not have end-position set, #33147', function() {\n\n    const { placeholders } = new SnippetParser().parse('src=\"$1\"', true)\n    const [first, second] = placeholders\n\n    assert.equal(placeholders.length, 2)\n    assert.equal(first.index, 1)\n    assert.equal(second.index, 0)\n\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet optional transforms are not applied correctly when reusing the same variable, #37702","suites":["SnippetParser"],"updatePoint":{"line":953,"column":100},"line":953,"code":"  test('Snippet optional transforms are not applied correctly when reusing the same variable, #37702', function() {\n\n    const transform = new Transform()\n    transform.appendChild(new FormatString(1, 'upcase'))\n    transform.appendChild(new FormatString(2, 'upcase'))\n    transform.regexp = /^(.)|-(.)/g\n\n    assert.equal(transform.resolve('my-file-name'), 'MyFileName')\n\n    const clone = transform.clone()\n    assert.equal(clone.resolve('my-file-name'), 'MyFileName')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"problem with snippets regex #40570","suites":["SnippetParser"],"updatePoint":{"line":966,"column":42},"line":966,"code":"  test('problem with snippets regex #40570', function() {\n\n    const snippet = new SnippetParser().parse('${TM_DIRECTORY/.*src[\\\\/](.*)/$1/}')\n    assertMarker(snippet, Variable)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Variable transformation doesn't work if undefined variables are used in the same snippet #51769","suites":["SnippetParser"],"updatePoint":{"line":972,"column":104},"line":972,"code":"  test('Variable transformation doesn\\'t work if undefined variables are used in the same snippet #51769', function() {\n    let transform = new Transform()\n    transform.appendChild(new Text('bar'))\n    transform.regexp = new RegExp('foo', 'gi')\n    assert.equal(transform.toTextmateString(), '/foo/bar/ig')\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Snippet parser freeze #53144","suites":["SnippetParser"],"updatePoint":{"line":979,"column":36},"line":979,"code":"  test('Snippet parser freeze #53144', function() {\n    let snippet = new SnippetParser().parse('${1/(void$)|(.+)/${1:?-\\treturn nil;}/}')\n    assertMarker(snippet, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"snippets variable not resolved in JSON proposal #52931","suites":["SnippetParser"],"updatePoint":{"line":984,"column":62},"line":984,"code":"  test('snippets variable not resolved in JSON proposal #52931', function() {\n    assertTextAndMarker('FOO${1:/bin/bash}', 'FOO/bin/bash', Text, Placeholder)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"Mirroring sequence of nested placeholders not selected properly on backjumping #58736","suites":["SnippetParser"],"updatePoint":{"line":988,"column":93},"line":988,"code":"  test('Mirroring sequence of nested placeholders not selected properly on backjumping #58736', function() {\n    let snippet = new SnippetParser().parse('${3:nest1 ${1:nest2 ${2:nest3}}} $3')\n    assert.equal(snippet.children.length, 3)\n    assert.ok(snippet.children[0] instanceof Placeholder)\n    assert.ok(snippet.children[1] instanceof Text)\n    assert.ok(snippet.children[2] instanceof Placeholder)\n\n    function assertParent(marker: Marker) {\n      marker.children.forEach(assertParent)\n      if (!(marker instanceof Placeholder)) {\n        return\n      }\n      let found = false\n      let m: Marker = marker\n      while (m && !found) {\n        if (m.parent === snippet) {\n          found = true\n        }\n        m = m.parent\n      }\n      assert.ok(found)\n    }\n    let [, , clone] = snippet.children\n    assertParent(clone)\n  })","file":"snippets/parser.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert escaped text","suites":["SnippetSession","start()"],"updatePoint":{"line":50,"column":34},"line":50,"code":"    it('should insert escaped text', async () => {\n      let res = await start('\\\\`a\\\\` \\\\$ \\\\{\\\\}', Range.create(0, 0, 0, 0), false, defaultContext)\n      expect(res).toBe(true)\n      let line = await nvim.line\n      expect(line).toBe('`a` $ {}')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not start with plain snippet when jump to final placeholder","suites":["SnippetSession","start()"],"updatePoint":{"line":57,"column":74},"line":57,"code":"    it('should not start with plain snippet when jump to final placeholder', async () => {\n      let res = await start('bar$0', defaultRange)\n      expect(res).toBe(false)\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 3 })\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with range replaced","suites":["SnippetSession","start()"],"updatePoint":{"line":64,"column":40},"line":64,"code":"    it('should start with range replaced', async () => {\n      await nvim.setLine('foo')\n      let res = await start('bar$0', Range.create(0, 0, 0, 3), true)\n      expect(res).toBe(false)\n      let line = await nvim.line\n      expect(line).toBe('bar')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fix indent of next line when necessary","suites":["SnippetSession","start()"],"updatePoint":{"line":72,"column":53},"line":72,"code":"    it('should fix indent of next line when necessary', async () => {\n      let buf = await nvim.buffer\n      await nvim.setLine('  ab')\n      await nvim.input('i')\n      let session = await createSession()\n      let res = await session.start('${1:x}\\n', Range.create(0, 3, 0, 3))\n      expect(res).toBe(true)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  ax', '  b'])\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert indent for snippet endsWith line break","suites":["SnippetSession","start()"],"updatePoint":{"line":83,"column":60},"line":83,"code":"    it('should insert indent for snippet endsWith line break', async () => {\n      let buf = await nvim.buffer\n      await nvim.setLine('  bar')\n      await nvim.command('startinsert')\n      await nvim.call('cursor', [1, 3])\n      let session = await createSession()\n      let res = await session.start('${1:foo}\\n', Range.create(0, 2, 0, 2))\n      expect(res).toBe(true)\n      let lines = await buf.lines\n      expect(lines).toEqual(['  foo', '  bar'])\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start without select placeholder","suites":["SnippetSession","start()"],"updatePoint":{"line":95,"column":47},"line":95,"code":"    it('should start without select placeholder', async () => {\n      let session = await createSession()\n      let res = await session.start(' ${1:aa} ', defaultRange, false)\n      expect(res).toBe(true)\n      let { mode } = await nvim.mode\n      expect(mode).toBe('n')\n      await session.selectCurrentPlaceholder()\n      await helper.waitFor('mode', [], 's')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with variable selected","suites":["SnippetSession","start()"],"updatePoint":{"line":105,"column":43},"line":105,"code":"    it('should start with variable selected', async () => {\n      let session = await createSession()\n      let res = await session.start('${foo:bar}', defaultRange, false)\n      expect(res).toBe(true)\n      let line = await nvim.getLine()\n      expect(line).toBe('bar')\n      await session.selectCurrentPlaceholder()\n      await helper.waitFor('mode', [], 's')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select none transform placeholder","suites":["SnippetSession","start()"],"updatePoint":{"line":115,"column":48},"line":115,"code":"    it('should select none transform placeholder', async () => {\n      await start('${1/..*/ -> /}xy$1', defaultRange)\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(3)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should indent multiple lines variable text","suites":["SnippetSession","start()"],"updatePoint":{"line":121,"column":50},"line":121,"code":"    it('should indent multiple lines variable text', async () => {\n      let buf = await nvim.buffer\n      let text = 'abc\\n  def'\n      await nvim.setVar('coc_selected_text', text)\n      await start('fun\\n  ${0:${TM_SELECTED_TEXT:return}}\\nend')\n      let lines = await buf.lines\n      expect(lines.length).toBe(4)\n      expect(lines).toEqual([\n        'fun', '  abc', '    def', 'end'\n      ])\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve VISUAL","suites":["SnippetSession","start()"],"updatePoint":{"line":133,"column":29},"line":133,"code":"    it('should resolve VISUAL', async () => {\n      let text = 'abc'\n      await nvim.setVar('coc_selected_text', text)\n      await start('$VISUAL')\n      let line = await nvim.line\n      expect(line).toBe('abc')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve default value of VISUAL","suites":["SnippetSession","start()"],"updatePoint":{"line":141,"column":46},"line":141,"code":"    it('should resolve default value of VISUAL', async () => {\n      await nvim.setVar('coc_selected_text', '')\n      await start('${VISUAL:foo}')\n      let line = await nvim.line\n      expect(line).toBe('foo')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start with nest snippet","suites":["SnippetSession","nested snippet"],"updatePoint":{"line":150,"column":38},"line":150,"code":"    it('should start with nest snippet', async () => {\n      let session = await createSession()\n      let res = await session.start('${1:a} ${2:b}', defaultRange, false)\n      let line = await nvim.getLine()\n      expect(line).toBe('a b')\n      expect(res).toBe(true)\n      let { placeholder } = session\n      expect(placeholder.index).toBe(1)\n      let r = await getCursorRange()\n      res = await session.start('${1:foo} ${2:bar}', r)\n      expect(res).toBe(true)\n      placeholder = session.placeholder\n      expect(placeholder.index).toBe(2)\n      line = await nvim.getLine()\n      expect(line).toBe('foo bara b')\n      expect(session.snippet.text).toBe('foo bara b')\n      await session.nextPlaceholder()\n      placeholder = session.placeholder\n      expect(placeholder.index).toBe(3)\n      expect(session.placeholder.value).toBe('bar')\n      let col = await nvim.call('col', ['.'])\n      expect(col).toBe(7)\n      await session.nextPlaceholder()\n      await session.nextPlaceholder()\n      expect(session.placeholder.index).toBe(5)\n      expect(session.placeholder.value).toBe('b')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start nest snippet without select","suites":["SnippetSession","nested snippet"],"updatePoint":{"line":178,"column":48},"line":178,"code":"    it('should start nest snippet without select', async () => {\n      await nvim.command('startinsert')\n      let session = await createSession()\n      let res = await session.start('${1:a} ${2:b}', defaultRange)\n      let line = await nvim.call('getline', ['.'])\n      let r = await getCursorRange()\n      res = await session.start('${1:foo} ${2:bar}', r, false)\n      expect(res).toBe(true)\n      line = await nvim.line\n      expect(line).toBe('afoo bar b')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should synchronize content change","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":192,"column":41},"line":192,"code":"    it('should synchronize content change', async () => {\n      let pyfile = path.join(__dirname, '../ultisnips.py')\n      await nvim.command(`execute 'pyxfile '.fnameescape('${pyfile}')`)\n      let session = await createSession(true)\n      await session.start('${1:foo}${2:`!p snip.rv = \"\"`} `!p snip.rv = t[1] + t[2]`', defaultRange, true, {\n        line: '',\n        range: defaultRange\n      })\n      await nvim.input('bar')\n      await session.forceSynchronize()\n      await helper.waitFor('getline', ['.'], 'bar bar')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when change after snippet","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":205,"column":47},"line":205,"code":"    it('should cancel when change after snippet', async () => {\n      let session = await createSession()\n      await nvim.setLine(' x')\n      await nvim.input('i')\n      await session.start('${1:foo }bar', defaultRange)\n      await nvim.setLine('foo bar y')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when change before and in snippet","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":215,"column":55},"line":215,"code":"    it('should cancel when change before and in snippet', async () => {\n      let session = await createSession()\n      await nvim.setLine(' x')\n      await nvim.input('i')\n      await session.start('${1:foo }bar', defaultRange)\n      await nvim.setLine('afoobar')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset position when change before snippet","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":225,"column":56},"line":225,"code":"    it('should reset position when change before snippet', async () => {\n      let session = await createSession()\n      await nvim.setLine('x')\n      await nvim.input('a')\n      let r = await getCursorRange()\n      await session.start('${1:foo} bar', r)\n      await nvim.setLine('yfoo bar')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(true)\n      let start = session.snippet.start\n      expect(start).toEqual(Position.create(0, 1))\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when before and body changed","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":238,"column":50},"line":238,"code":"    it('should cancel when before and body changed', async () => {\n      let session = await createSession()\n      await nvim.setLine('x')\n      await nvim.input('a')\n      await session.start('${1:foo }bar', defaultRange)\n      await nvim.setLine('yfoo  bar')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when unable to find placeholder","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":248,"column":53},"line":248,"code":"    it('should cancel when unable to find placeholder', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('${1:foo} bar', defaultRange)\n      await nvim.setLine('foodbar')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel when unable to find removed Text","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":257,"column":54},"line":257,"code":"    it('should cancel when unable to find removed Text', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('${1:foo} bar', defaultRange)\n      await nvim.setLine('fobar')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should adjust with removed text","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":266,"column":39},"line":266,"code":"    it('should adjust with removed text', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('${1:foo} bar$0', defaultRange)\n      await nvim.input('<esc>')\n      await nvim.call('cursor', [1, 5])\n      await nvim.input('i')\n      await nvim.input('<backspace>')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(true)\n      await session.nextPlaceholder()\n      let col = await nvim.call('col', ['.'])\n      expect(col).toBe(7)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should prefer range contains current cursor","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":281,"column":51},"line":281,"code":"    it('should prefer range contains current cursor', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('$1 $2', defaultRange)\n      await nvim.input('<esc>A')\n      await nvim.input(' ')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(true)\n      let p = session.placeholder\n      expect(p.index).toBe(2)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update cursor column after synchronize","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":293,"column":53},"line":293,"code":"    it('should update cursor column after synchronize', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('${1} ${1:foo}', defaultRange)\n      await nvim.input('b')\n      await session.forceSynchronize()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual(Position.create(0, 3))\n      await nvim.input('a')\n      await session.forceSynchronize()\n      pos = await window.getCursorPosition()\n      expect(pos).toEqual(Position.create(0, 5))\n      await nvim.input('<backspace>')\n      await session.forceSynchronize()\n      pos = await window.getCursorPosition()\n      expect(pos).toEqual(Position.create(0, 3))\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update cursor line after synchronize","suites":["SnippetSession","synchronize()"],"updatePoint":{"line":311,"column":51},"line":311,"code":"    it('should update cursor line after synchronize', async () => {\n      let buf = await nvim.buffer\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('${1} ${1:foo}', defaultRange)\n      await nvim.input('b')\n      await session.forceSynchronize()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual(Position.create(0, 3))\n      await nvim.input('<cr>')\n      await session.forceSynchronize()\n      expect(session.isActive).toBe(true)\n      pos = await window.getCursorPosition()\n      let lines = await buf.lines\n      expect(lines).toEqual(['b', ' b', ''])\n      expect(pos).toEqual(Position.create(2, 0))\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should deactivate on cursor outside","suites":["SnippetSession","deactivate()"],"updatePoint":{"line":332,"column":43},"line":332,"code":"    it('should deactivate on cursor outside', async () => {\n      let buf = await nvim.buffer\n      let session = await createSession()\n      let res = await session.start('a${1:a}b', defaultRange)\n      expect(res).toBe(true)\n      await buf.append(['foo', 'bar'])\n      await nvim.call('cursor', [2, 1])\n      await session.checkPosition()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when jump on deactivate session","suites":["SnippetSession","deactivate()"],"updatePoint":{"line":343,"column":56},"line":343,"code":"    it('should not throw when jump on deactivate session', async () => {\n      let session = await createSession()\n      session.deactivate()\n      await session.start('${1:foo} $0', defaultRange)\n      await session.selectPlaceholder(undefined, true)\n      await session.forceSynchronize()\n      await session.previousPlaceholder()\n      await session.nextPlaceholder()\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel keymap on jump final placeholder","suites":["SnippetSession","deactivate()"],"updatePoint":{"line":353,"column":54},"line":353,"code":"    it('should cancel keymap on jump final placeholder', async () => {\n      let session = await createSession()\n      await nvim.input('i')\n      await session.start('$0x${1:a}b$0', defaultRange)\n      let line = await nvim.line\n      expect(line).toBe('xab')\n      let map = await nvim.call('maparg', ['<C-j>', 'i']) as string\n      expect(map).toMatch('coc#snippet#jump')\n      await session.nextPlaceholder()\n      map = await nvim.call('maparg', ['<C-j>', 'i']) as string\n      expect(map).toBe('')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when session not activated","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":368,"column":51},"line":368,"code":"    it('should not throw when session not activated', async () => {\n      let session = await createSession()\n      await session.start('${foo} ${bar}', defaultRange, false)\n      session.deactivate()\n      await session.nextPlaceholder()\n      await session.previousPlaceholder()\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to variable placeholder","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":376,"column":43},"line":376,"code":"    it('should jump to variable placeholder', async () => {\n      let session = await createSession()\n      await session.start('${foo} ${bar}', defaultRange, false)\n      await session.selectCurrentPlaceholder()\n      await session.nextPlaceholder()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 6 })\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to variable placeholder after number placeholder","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":385,"column":68},"line":385,"code":"    it('should jump to variable placeholder after number placeholder', async () => {\n      let session = await createSession()\n      await session.start('${foo} ${1:bar}', defaultRange, false)\n      await session.selectCurrentPlaceholder()\n      await session.nextPlaceholder()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 2 })\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to first placeholder","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":394,"column":40},"line":394,"code":"    it('should jump to first placeholder', async () => {\n      let session = await createSession()\n      await session.start('${foo} ${foo} ${2:bar}', defaultRange, false)\n      await session.selectCurrentPlaceholder()\n      let pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 10 })\n      await session.nextPlaceholder()\n      pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 2 })\n      await session.nextPlaceholder()\n      pos = await window.getCursorPosition()\n      expect(pos).toEqual({ line: 0, character: 11 })\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto next placeholder","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":408,"column":36},"line":408,"code":"    it('should goto next placeholder', async () => {\n      let session = await createSession()\n      let res = await session.start('${1:a} ${2:b} c', defaultRange)\n      expect(res).toBe(true)\n      await session.nextPlaceholder()\n      let { placeholder } = session\n      expect(placeholder.index).toBe(2)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump to none transform placeholder","suites":["SnippetSession","nextPlaceholder()"],"updatePoint":{"line":417,"column":49},"line":417,"code":"    it('should jump to none transform placeholder', async () => {\n      let session = await createSession()\n      let res = await session.start('${1} ${2/^_(.*)/$2/}bar$2', defaultRange)\n      expect(res).toBe(true)\n      let line = await nvim.line\n      expect(line).toBe(' bar')\n      await session.nextPlaceholder()\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(5)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should goto previous placeholder","suites":["SnippetSession","previousPlaceholder()"],"updatePoint":{"line":431,"column":40},"line":431,"code":"    it('should goto previous placeholder', async () => {\n      let session = await createSession()\n      let res = await session.start('${1:foo} ${2:bar}', defaultRange)\n      expect(res).toBe(true)\n      await session.nextPlaceholder()\n      expect(session.placeholder.index).toBe(2)\n      await session.previousPlaceholder()\n      expect(session.placeholder.index).toBe(1)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add highlights","suites":["SnippetSession","highlights()"],"updatePoint":{"line":443,"column":29},"line":443,"code":"    it('should add highlights', async () => {\n      let ns = await nvim.call('coc#highlight#create_namespace', ['snippets'])\n      let session = await createSession(true)\n      await session.start('${2:bar ${1:foo}} $2', defaultRange)\n      let buf = nvim.createBuffer(workspace.bufnr)\n      let markers = await buf.getExtMarks(ns, 0, -1, { details: true })\n      expect(markers.length).toBe(2)\n      expect(markers[0][3].hl_group).toBe('CocSnippetVisual')\n      expect(markers[1][3].hl_group).toBe('CocSnippetVisual')\n      session.deactivate()\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel snippet if position out of range","suites":["SnippetSession","checkPosition()"],"updatePoint":{"line":458,"column":54},"line":458,"code":"    it('should cancel snippet if position out of range', async () => {\n      let session = await createSession()\n      await nvim.setLine('bar')\n      await session.start('${1:foo}', defaultRange)\n      await nvim.call('cursor', [1, 5])\n      await session.checkPosition()\n      expect(session.isActive).toBe(false)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not cancel snippet if position in range","suites":["SnippetSession","checkPosition()"],"updatePoint":{"line":467,"column":54},"line":467,"code":"    it('should not cancel snippet if position in range', async () => {\n      let session = await createSession()\n      await session.start('${1:foo}', defaultRange)\n      await nvim.call('cursor', [1, 3])\n      await session.checkPosition()\n      expect(session.isActive).toBe(true)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should find current placeholder if possible","suites":["SnippetSession","findPlaceholder()"],"updatePoint":{"line":478,"column":51},"line":478,"code":"    it('should find current placeholder if possible', async () => {\n      let session = await createSession()\n      await session.start('${1:abc}${2:def}', defaultRange)\n      let placeholder = session.findPlaceholder(Range.create(0, 3, 0, 3))\n      expect(placeholder.index).toBe(1)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should return null if placeholder not found","suites":["SnippetSession","findPlaceholder()"],"updatePoint":{"line":485,"column":51},"line":485,"code":"    it('should return null if placeholder not found', async () => {\n      let session = await createSession()\n      await session.start('${1:abc}xyz${2:def}', defaultRange)\n      let placeholder = session.findPlaceholder(Range.create(0, 4, 0, 4))\n      expect(placeholder).toBeNull()\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select range placeholder","suites":["SnippetSession","selectPlaceholder()"],"updatePoint":{"line":495,"column":39},"line":495,"code":"    it('should select range placeholder', async () => {\n      let session = await createSession()\n      await session.start('${1:abc}', defaultRange)\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('s')\n      await nvim.input('<backspace>')\n      let line = await nvim.line\n      expect(line).toBe('')\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select empty placeholder","suites":["SnippetSession","selectPlaceholder()"],"updatePoint":{"line":505,"column":39},"line":505,"code":"    it('should select empty placeholder', async () => {\n      let session = await createSession()\n      await session.start('a ${1} ${2}', defaultRange)\n      let mode = await nvim.mode\n      expect(mode.mode).toBe('i')\n      let col = await nvim.call('col', '.')\n      expect(col).toBe(3)\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select choice placeholder","suites":["SnippetSession","selectPlaceholder()"],"updatePoint":{"line":514,"column":40},"line":514,"code":"    it('should select choice placeholder', async () => {\n      await nvim.input('i')\n      let session = await createSession()\n      await session.start('${1|one,two,three|}', defaultRange)\n      let line = await nvim.line\n      expect(line).toBe('one')\n      await helper.waitFor('pumvisible', [], 1)\n      let val = await nvim.eval('g:coc#_context') as any\n      expect(val.start).toBe(0)\n      expect(val.candidates).toEqual(['one', 'two', 'three'])\n    })","file":"snippets/session.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve uppercase variables","suites":["CocSnippet","resolveVariables()"],"updatePoint":{"line":58,"column":42},"line":58,"code":"    it('should resolve uppercase variables', async () => {\n      let doc = await helper.createDocument()\n      let fsPath = URI.parse(doc.uri).fsPath\n      await assertResult('$TM_FILENAME', path.basename(fsPath))\n      await assertResult('$TM_FILENAME_BASE', path.basename(fsPath, path.extname(fsPath)))\n      await assertResult('$TM_DIRECTORY', path.dirname(fsPath))\n      await assertResult('$TM_FILEPATH', fsPath)\n      await nvim.call('setreg', ['\"\"', 'foo'])\n      await assertResult('$YANK', 'foo')\n      await assertResult('$TM_LINE_INDEX', '0')\n      await assertResult('$TM_LINE_NUMBER', '1')\n      await nvim.setLine('foo')\n      await assertResult('$TM_CURRENT_LINE', 'foo')\n      await nvim.call('setreg', ['*', 'foo'])\n      await assertResult('$CLIPBOARD', 'foo')\n      let d = new Date()\n      await assertResult('$CURRENT_YEAR', d.getFullYear().toString())\n      await assertResult('$NOT_EXISTS', 'NOT_EXISTS')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve new VSCode variables","suites":["CocSnippet","resolveVariables()"],"updatePoint":{"line":78,"column":43},"line":78,"code":"    it('should resolve new VSCode variables', async () => {\n      let doc = await helper.createDocument()\n      await doc.buffer.setOption('comments', 's1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-')\n      await doc.buffer.setOption('commentstring', '')\n      let fsPath = URI.parse(doc.uri).fsPath\n      let c = await createSnippet('$RANDOM')\n      expect(c.text.length).toBe(6)\n      c = await createSnippet('$RANDOM_HEX')\n      expect(c.text.length).toBe(6)\n      c = await createSnippet('$UUID')\n      expect(c.text).toMatch('-')\n      c = await createSnippet('$RELATIVE_FILEPATH')\n      expect(c.text).toMatch(path.basename(fsPath))\n      c = await createSnippet('$WORKSPACE_NAME')\n      expect(c.text.length).toBeGreaterThan(0)\n      c = await createSnippet('$WORKSPACE_FOLDER')\n      expect(c.text.length).toBeGreaterThan(0)\n      await assertResult('$LINE_COMMENT', '//')\n      await assertResult('$BLOCK_COMMENT_START', '/*')\n      await assertResult('$BLOCK_COMMENT_END', '*/')\n      await doc.buffer.setOption('comments', '')\n      await doc.buffer.setOption('commentstring', '// %s')\n      await assertResult('$LINE_COMMENT', '//')\n      await assertResult('$BLOCK_COMMENT_START', '')\n      await assertResult('$BLOCK_COMMENT_END', '')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve variables in placeholders","suites":["CocSnippet","resolveVariables()"],"updatePoint":{"line":105,"column":48},"line":105,"code":"    it('should resolve variables in placeholders', async () => {\n      await nvim.setLine('foo')\n      await assertResult('$1 ${1:$TM_CURRENT_LINE}', 'foo foo')\n      await assertResult('$1 ${1:$TM_CURRENT_LINE bar}', 'foo bar foo bar')\n      await assertResult('$2 ${2:|${1:$TM_CURRENT_LINE}|}', '|foo| |foo|')\n      await assertResult('$1 $2 ${2:${1:|$TM_CURRENT_LINE|}}', '|foo| |foo| |foo|')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve variables  with default value","suites":["CocSnippet","resolveVariables()"],"updatePoint":{"line":113,"column":52},"line":113,"code":"    it('should resolve variables  with default value', async () => {\n      await assertResult('$1 ${1:${VISUAL:foo}}', 'foo foo')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve for lower case variables","suites":["CocSnippet","resolveVariables()"],"updatePoint":{"line":117,"column":47},"line":117,"code":"    it('should resolve for lower case variables', async () => {\n      await assertResult('${foo:abcdef} ${bar}', 'abcdef bar')\n      await assertResult('${1:${foo:abcdef}} ${1/^\\\\w\\\\w(.*)/$1/}', 'abcdef cdef')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init shell code block","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":124,"column":36},"line":124,"code":"    it('should init shell code block', async () => {\n      await assertResult('`echo \"hello\"` world', 'hello world')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init vim block","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":128,"column":29},"line":128,"code":"    it('should init vim block', async () => {\n      await assertResult('`!v eval(\"1 + 1\")` = 2', '2 = 2')\n      await nvim.setLine('  ')\n      await assertResult('${1:`!v indent(\".\")`} \"$1\"', '2 \"2\"')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init code block in placeholders","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":134,"column":46},"line":134,"code":"    it('should init code block in placeholders', async () => {\n      await assertResult('f ${1:`echo \"b\"`}', 'f b')\n      await assertResult('f ${1:`!v \"b\"`}', 'f b')\n      await assertResult('f ${1:`!p snip.rv = \"b\"`}', 'f b')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup python globals","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":140,"column":35},"line":140,"code":"    it('should setup python globals', async () => {\n      await helper.edit('t.js')\n      await createSnippet('`!p snip.rv = fn`', {})\n      await assertPyxValue('fn', 't.js')\n      await assertPyxValue('path', /t\\.js$/)\n      await assertPyxValue('t', [''])\n      await assertPyxValue('context', true)\n      await createSnippet('`!p snip.rv = fn`', {\n        regex: '[ab]',\n        context: 'False'\n      }, Range.create(0, 2, 0, 3), 'a b')\n      await assertPyxValue('context', false)\n      await assertPyxValue('match.group(0)', 'b')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should setup python match","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":155,"column":33},"line":155,"code":"    it('should setup python match', async () => {\n      let c = await createSnippet('\\\\\\\\frac{`!p snip.rv = match.group(1)`}{$1}$0', {\n        regex: '((\\\\d+)|(\\\\d*)(\\\\\\\\)?([A-Za-z]+)((\\\\^|_)(\\\\{\\\\d+\\\\}|\\\\d))*)/',\n        context: 'True'\n      }, Range.create(0, 0, 0, 3), '20/')\n      await assertPyxValue('context', true)\n      await assertPyxValue('match.group(1)', '20')\n      expect(c.text).toBe('\\\\frac{20}{}')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with methods of snip","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":165,"column":40},"line":165,"code":"    it('should work with methods of snip', async () => {\n      await nvim.command('setl shiftwidth=4 ft=txt tabstop=4 expandtab')\n      await createSnippet('`!p snip.rv = \"a\"`', {}, Range.create(0, 4, 0, 8), '    abcd')\n      await executePythonCode(nvim, [\n        'snip.shift(1)',\n        // ultisnip indent only when there's '\\n' in snip.rv\n        'snip += \"\"',\n        'newLine = snip.mkline(\"foo\")'\n      ])\n      await assertPyxValue('newLine', '        foo')\n      await executePythonCode(nvim, [\n        'snip.unshift(1)',\n        'newLine = snip.mkline(\"b\")'\n      ])\n      await assertPyxValue('newLine', '    b')\n      await executePythonCode(nvim, [\n        'snip.shift(1)',\n        'snip.reset_indent()',\n        'newLine = snip.mkline(\"f\")'\n      ])\n      await assertPyxValue('newLine', '    f')\n      await executePythonCode(nvim, [\n        'fff = snip.opt(\"&fff\", \"foo\")',\n        'ft = snip.opt(\"&ft\", \"ft\")',\n      ])\n      await assertPyxValue('fff', 'foo')\n      await assertPyxValue('ft', 'txt')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init python code block","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":194,"column":37},"line":194,"code":"    it('should init python code block', async () => {\n      await assertResult('`!p snip.rv = \"a\"` = a', 'a = a')\n      await assertResult('`!p snip.rv = t[1]` = ${1:a}', 'a = a')\n      await assertResult('`!p snip.rv = t[1]` = ${1:`!v eval(\"\\'a\\'\")`}', 'a = a')\n      await assertResult('`!p snip.rv = t[1] + t[2]` = ${1:a} ${2:b}', 'ab = a b')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init python placeholder","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":201,"column":38},"line":201,"code":"    it('should init python placeholder', async () => {\n      await assertResult('foo ${1/^\\\\|(.*)\\\\|$/$1/} ${1:|`!p snip.rv = \"a\"`|}', 'foo a |a|')\n      await assertResult('foo $1 ${1:`!p snip.rv = \"a\"`}', 'foo a a')\n      await assertResult('${1/^_(.*)/$1/} $1 aa ${1:`!p snip.rv = \"_foo\"`}', 'foo _foo aa _foo')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should init nested python placeholder","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":207,"column":45},"line":207,"code":"    it('should init nested python placeholder', async () => {\n      await assertResult('${1:foo`!p snip.rv = t[2]`} ${2:bar} $1', 'foobar bar foobar')\n      await assertResult('${3:f${2:oo${1:b`!p snip.rv = \"ar\"`}}} `!p snip.rv = t[3]`', 'foobar foobar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should recursive init python placeholder","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":212,"column":48},"line":212,"code":"    it('should recursive init python placeholder', async () => {\n      await assertResult('${1:`!p snip.rv = t[2]`} ${2:`!p snip.rv = t[3]`} ${3:`!p snip.rv = t[4][0]`} ${4:bar}', 'b b b bar')\n      await assertResult('${1:foo} ${2:`!p snip.rv = t[1][0]`} ${3:`!p snip.rv = \"\"`} ${4:`!p snip.rv = t[2]`}', 'foo f  f')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update python block from placeholder","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":217,"column":51},"line":217,"code":"    it('should update python block from placeholder', async () => {\n      await assertResult('`!p snip.rv = t[1][0] if len(t[1]) > 0 else \"\"` ${1:`!p snip.rv = t[2]`} ${2:foo}', 'f foo foo')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update nested placeholder values","suites":["CocSnippet","code block initialize"],"updatePoint":{"line":221,"column":47},"line":221,"code":"    it('should update nested placeholder values', async () => {\n      let c = await createSnippet('${2:foo ${1:`!p snip.rv = \"bar\"`}} ${2/^\\\\w//} `!p snip.rv = t[2]`', {})\n      expect(c.text).toBe('foo bar oo bar foo bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get text before marker","suites":["CocSnippet","getContentBefore()"],"updatePoint":{"line":229,"column":37},"line":229,"code":"    it('should get text before marker', async () => {\n      let c = await createSnippet('${1:foo} ${2:bar}', {})\n      let markers = c.placeholders\n      let p = markers[0].parent\n      expect(p instanceof TextmateSnippet).toBe(true)\n      expect(getContentBefore(p)).toBe('')\n      expect(getContentBefore(markers[0])).toBe('')\n      expect(getContentBefore(markers[1])).toBe('foo ')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get text before nested marker","suites":["CocSnippet","getContentBefore()"],"updatePoint":{"line":239,"column":44},"line":239,"code":"    it('should get text before nested marker', async () => {\n      let c = await createSnippet('${1:foo} ${2:is nested with $4} $3 bar', {})\n      let markers = c.placeholders as Placeholder[]\n      let p = markers.find(o => o.index == 4)\n      expect(getContentBefore(p)).toBe('foo is nested with ')\n      p = markers.find(o => o.index == 0)\n      expect(getContentBefore(p)).toBe('foo is nested with   bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider normal line break","suites":["CocSnippet","getContentBefore()"],"updatePoint":{"line":248,"column":41},"line":248,"code":"    it('should consider normal line break', async () => {\n      let c = await createSnippet('${1:foo}\\n${2:is nested with $4}', {})\n      let markers = c.placeholders as Placeholder[]\n      let p = markers.find(o => o.index == 4)\n      expect(getContentBefore(p)).toBe('is nested with ')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should consider line break after update","suites":["CocSnippet","getContentBefore()"],"updatePoint":{"line":255,"column":47},"line":255,"code":"    it('should consider line break after update', async () => {\n      let c = await createSnippet('${1:foo} ${2}', {})\n      let p = c.getPlaceholder(1)\n      await c.tmSnippet.update(nvim, p.marker, 'abc\\ndef')\n      let markers = c.placeholders as Placeholder[]\n      let placeholder = markers.find(o => o.index == 2)\n      expect(getContentBefore(placeholder)).toBe('def ')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get sorted placeholders","suites":["CocSnippet","getSortedPlaceholders()"],"updatePoint":{"line":266,"column":38},"line":266,"code":"    it('should get sorted placeholders', async () => {\n      const assert = (snip: CocSnippet, index: number | undefined, indexes: number[]) => {\n        let curr = index == null ? undefined : snip.getPlaceholder(index)\n        let res = snip.getSortedPlaceholders(curr)\n        expect(res.map(o => o.index)).toEqual(indexes)\n      }\n      let c = await createSnippet('${1:foo} ${2/^\\\\w//} ${2:bar} ', {})\n      assert(c, undefined, [1, 2, 0])\n      assert(c, 1, [1, 2, 0])\n      assert(c, 2, [2, 1, 0])\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getNewText for placeholder","suites":["CocSnippet","getNewText()"],"updatePoint":{"line":280,"column":41},"line":280,"code":"    it('should getNewText for placeholder', async () => {\n      let c = await createSnippet('before ${1:foo} after$2', {})\n      let p = c.getPlaceholder(1)\n      expect(c.getNewText(p, `fff`)).toBe(undefined)\n      expect(c.getNewText(p, `before foo `)).toBe(undefined)\n      expect(c.getNewText(p, `before foo afteralll`)).toBe(undefined)\n      expect(c.getNewText(p, `before bar after`)).toBe('bar')\n      p = c.getPlaceholder(2)\n      expect(c.getNewText(p, `before foo afterbar`)).toBe('bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should work with snip.c","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":302,"column":31},"line":302,"code":"    it('should work with snip.c', async () => {\n      let code = [\n        '#ifndef ${1:`!p',\n        'if not snip.c:',\n        '  import random, string',\n        \"  name = re.sub(r'[^A-Za-z0-9]+','_', snip.fn).upper()\",\n        \"  rand = ''.join(random.sample(string.ascii_letters+string.digits, 8))\",\n        \"  snip.rv = ('%s_%s' % (name,rand)).upper()\",\n        \"else:\",\n        \"  snip.rv = snip.c + t[2]`}\",\n        '#define $1',\n        '$2'\n      ].join('\\n')\n      let c = await createSnippet(code, {})\n      let first = c.text.split('\\n')[0]\n      let p = c.getPlaceholder(2)\n      expect(p).toBeDefined()\n      await c.tmSnippet.update(nvim, p.marker, 'foo')\n      let t = c.tmSnippet.toString()\n      expect(t.startsWith(first)).toBe(true)\n      expect(t.split('\\n').map(s => s.endsWith('foo'))).toEqual([true, true, true])\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should calculate delta","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":325,"column":30},"line":325,"code":"    it('should calculate delta', async () => {\n      // TODO\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update variable placeholders","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":329,"column":43},"line":329,"code":"    it('should update variable placeholders', async () => {\n      await assertUpdate('${foo} ${foo}', 'bar', 'bar bar')\n      await assertUpdate('${foo} ${foo:x}', 'bar', 'bar bar')\n      await assertUpdate('${1:${foo:x}} $1', 'bar', 'bar bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update placeholder with code blocks","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":335,"column":50},"line":335,"code":"    it('should update placeholder with code blocks', async () => {\n      await assertUpdate('${1:`echo \"foo\"`} $1', 'bar', 'bar bar')\n      await assertUpdate('${2:${1:`echo \"foo\"`}} $2', 'bar', 'bar bar')\n      await assertUpdate('${1:`!v \"foo\"`} $1', 'bar', 'bar bar')\n      await assertUpdate('${1:`!p snip.rv = \"foo\"`} $1', 'bar', 'bar bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update related python blocks","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":342,"column":43},"line":342,"code":"    it('should update related python blocks', async () => {\n      // multiple\n      await assertUpdate('`!p snip.rv = t[1]` ${1:`!p snip.rv = \"foo\"`} `!p snip.rv = t[1]`', 'bar', 'bar bar bar')\n      // parent\n      await assertUpdate('`!p snip.rv = t[2]` ${2:foo ${1:`!p snip.rv = \"foo\"`}}', 'bar', 'foo bar foo bar')\n      // related placeholders\n      await assertUpdate('${2:foo `!p snip.rv = t[1]`} ${1:`!p snip.rv = \"foo\"`}', 'bar', 'foo bar bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update python code blocks with normal placeholder values","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":351,"column":71},"line":351,"code":"    it('should update python code blocks with normal placeholder values', async () => {\n      await assertUpdate('`!p snip.rv = t[1]` $1 `!p snip.rv = t[1]`', 'bar', 'bar bar bar')\n      await assertUpdate('`!p snip.rv = t[2]` ${2:foo $1}', 'bar', 'foo bar foo bar')\n      await assertUpdate('${2:foo `!p snip.rv = t[1]`} $1', 'bar', 'foo bar bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset values for removed placeholders","suites":["CocSnippet","updatePlaceholder()"],"updatePoint":{"line":357,"column":52},"line":357,"code":"    it('should reset values for removed placeholders', async () => {\n      // Keep remained placeholder this is same behavior of VSCode.\n      let s = await assertUpdate('${2:bar${1:foo}} $2 $1', 'bar', 'bar bar foo', 2)\n      let prev = s.getPrevPlaceholder(2)\n      expect(prev).toBeDefined()\n      expect(prev.value).toBe('foo')\n      // python placeholder, reset to empty value\n      await assertUpdate('${2:bar${1:foo}} $2 `!p snip.rv = t[1]`', 'bar', 'bar bar ', 2)\n      // not reset since $1 still exists\n      await assertUpdate('${2:bar${1:foo}} $2 $1 `!p snip.rv = t[1]`', 'bar', 'bar bar foo foo', 2)\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get ranges of placeholder","suites":["CocSnippet","getRanges()"],"updatePoint":{"line":371,"column":40},"line":371,"code":"    it('should get ranges of placeholder', async () => {\n      let c = await createSnippet('${2:${1:x} $1}\\n$2', {})\n      let p = c.getPlaceholder(1)\n      let arr = c.getRanges(p)\n      expect(arr.length).toBe(4)\n      expect(arr[0]).toEqual(Range.create(0, 0, 0, 1))\n      expect(arr[1]).toEqual(Range.create(0, 2, 0, 3))\n      expect(arr[2]).toEqual(Range.create(1, 0, 1, 1))\n      expect(arr[3]).toEqual(Range.create(1, 2, 1, 3))\n      expect(c.text).toBe('x x\\nx x')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should update indexes of python blocks","suites":["CocSnippet","insertSnippet()"],"updatePoint":{"line":385,"column":46},"line":385,"code":"    it('should update indexes of python blocks', async () => {\n      let c = await createSnippet('${1:a} ${2:b} ${3:`!p snip.rv=t[2]`}', {})\n      let p = c.getPlaceholder(1)\n      await c.insertSnippet(p, '${1:foo} ${2:bar}', ['', ''])\n      expect(c.text).toBe('foo bar b b')\n      p = c.getPlaceholder(5)\n      expect(p.after).toBe(' b')\n      let source = new CancellationTokenSource()\n      let res = await c.updatePlaceholder(p, Position.create(0, 9), 'xyz', source.token)\n      expect(res.text).toBe('foo bar xyz xyz')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert nested placeholder","suites":["CocSnippet","insertSnippet()"],"updatePoint":{"line":397,"column":40},"line":397,"code":"    it('should insert nested placeholder', async () => {\n      let c = await createSnippet('${1:foo}\\n$1', {})\n      let p = c.getPlaceholder(1)\n      let marker = await c.insertSnippet(p, '${1:x} $1', ['', '']) as Placeholder\n      p = c.getPlaceholder(marker.index)\n      let source = new CancellationTokenSource()\n      let res = await c.updatePlaceholder(p, Position.create(0, 3), 'bar', source.token)\n      expect(res.text).toBe('bar bar\\nbar bar')\n      expect(res.delta).toEqual(Position.create(0, 0))\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert nested python snippet","suites":["CocSnippet","insertSnippet()"],"updatePoint":{"line":408,"column":43},"line":408,"code":"    it('should insert nested python snippet', async () => {\n      let c = await createSnippet('${1:foo}\\n`!p snip.rv = t[1]`', {})\n      let p = c.getPlaceholder(1)\n      let line = await nvim.line\n      let marker = await c.insertSnippet(p, '${1:x} `!p snip.rv = t[1]`', ['', ''], { line, range: Range.create(0, 0, 0, 3) }) as Placeholder\n      p = c.getPlaceholder(marker.index)\n      expect(c.text).toBe('x x\\nx x')\n      let source = new CancellationTokenSource()\n      let res = await c.updatePlaceholder(p, Position.create(0, 1), 'bar', source.token)\n      expect(res.text).toBe('bar bar\\nbar bar')\n      await executePythonCode(nvim, [`snip = ContextSnippet()`])\n      let val = await nvim.call('pyxeval', 'snip.last_placeholder.current_text')\n      expect(val).toBe('foo')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should insert python snippet to normal snippet","suites":["CocSnippet","insertSnippet()"],"updatePoint":{"line":423,"column":54},"line":423,"code":"    it('should insert python snippet to normal snippet', async () => {\n      let c = await createSnippet('${1:foo}\\n$1', {})\n      let p = c.getPlaceholder(1)\n      expect(c.hasPython).toBe(false)\n      let marker = await c.insertSnippet(p, '${1:x} `!p snip.rv = t[1]`', ['', ''], { line: '', range: Range.create(0, 0, 0, 3) }) as Placeholder\n      p = c.getPlaceholder(marker.index)\n      expect(c.text).toBe('x x\\nx x')\n      let source = new CancellationTokenSource()\n      let res = await c.updatePlaceholder(p, Position.create(0, 1), 'bar', source.token)\n      expect(res.text).toBe('bar bar\\nbar bar')\n      expect(c.hasPython).toBe(true)\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not change match for original placeholders","suites":["CocSnippet","insertSnippet()"],"updatePoint":{"line":436,"column":57},"line":436,"code":"    it('should not change match for original placeholders', async () => {\n      let c = await createSnippet('`!p snip.rv = match.group(1)` $1', {\n        regex: '^(\\\\w+)'\n      }, Range.create(0, 0, 0, 3), 'foo')\n      let p = c.getPlaceholder(1)\n      expect(c.hasPython).toBe(true)\n      expect(c.text).toBe('foo ')\n      await c.insertSnippet(p, '`!p snip.rv = match.group(1)`', ['', ''], {\n        regex: '^(\\\\w+)',\n        line: 'bar',\n        range: Range.create(0, 0, 0, 3)\n      })\n      expect(c.text).toBe('foo bar')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check shouldFormat","suites":["CocSnippet","utils"],"updatePoint":{"line":463,"column":33},"line":463,"code":"    it('should check shouldFormat', () => {\n      expect(shouldFormat(' f')).toBe(true)\n      expect(shouldFormat('a\\nb')).toBe(true)\n      expect(shouldFormat('foo')).toBe(false)\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should normalizeSnippetString","suites":["CocSnippet","utils"],"updatePoint":{"line":469,"column":37},"line":469,"code":"    it('should normalizeSnippetString', () => {\n      expect(normalizeSnippetString('a\\n\\n\\tb', '  ', {\n        insertSpaces: true,\n        tabSize: 2\n      })).toBe('a\\n\\n    b')\n      expect(normalizeSnippetString('a\\n\\n  b', '\\t', {\n        insertSpaces: false,\n        tabSize: 2\n      })).toBe('a\\n\\n\\t\\tb')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw for invalid regex","suites":["CocSnippet","utils"],"updatePoint":{"line":480,"column":38},"line":480,"code":"    it('should throw for invalid regex', async () => {\n      assertThrow(() => {\n        convertRegex('\\\\z')\n      })\n      assertThrow(() => {\n        convertRegex('(?s)')\n      })\n      assertThrow(() => {\n        convertRegex('(?x)')\n      })\n      assertThrow(() => {\n        convertRegex('a\\nb')\n      })\n      assertThrow(() => {\n        convertRegex('(<)?(\\\\w+@\\\\w+(?:\\\\.\\\\w+)+)(?(1)>|$)')\n      })\n      assertThrow(() => {\n        convertRegex('(<)?(\\\\w+@\\\\w+(?:\\\\.\\\\w+)+)(?(1)>|)')\n      })\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should convert regex","suites":["CocSnippet","utils"],"updatePoint":{"line":501,"column":28},"line":501,"code":"    it('should convert regex', async () => {\n      // \\\\A\n      expect(convertRegex('\\\\A')).toBe('^')\n      expect(convertRegex('f(?#abc)b')).toBe('fb')\n      expect(convertRegex('f(?P<abc>def)b')).toBe('f(?<abc>def)b')\n      expect(convertRegex('f(?P=abc)b')).toBe('f\\\\k<abc>b')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should catch error with executePythonCode","suites":["CocSnippet","utils"],"updatePoint":{"line":509,"column":49},"line":509,"code":"    it('should catch error with executePythonCode', async () => {\n      let fn = async () => {\n        await executePythonCode(nvim, ['INVALID_CODE'])\n      }\n      await expect(fn()).rejects.toThrow(Error)\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should set error with addPythonTryCatch","suites":["CocSnippet","utils"],"updatePoint":{"line":516,"column":47},"line":516,"code":"    it('should set error with addPythonTryCatch', async () => {\n      let code = addPythonTryCatch('INVALID_CODE', true)\n      await nvim.command(`pyx ${code}`)\n      let msg = await nvim.getVar('errmsg')\n      expect(msg).toBeDefined()\n      expect(msg).toMatch('INVALID_CODE')\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should parse comments","suites":["CocSnippet","utils"],"updatePoint":{"line":524,"column":29},"line":524,"code":"    it('should parse comments', async () => {\n      expect(parseCommentstring('a%sb')).toBeUndefined()\n      expect(parseCommentstring('// %s')).toBe('//')\n      expect(parseComments('')).toEqual({\n        start: undefined,\n        end: undefined,\n        single: undefined\n      })\n      expect(parseComments('s:/*')).toEqual({\n        start: '/*',\n        end: undefined,\n        single: undefined\n      })\n      expect(parseComments('e:*/')).toEqual({\n        end: '*/',\n        start: undefined,\n        single: undefined\n      })\n      expect(parseComments(':#,:b')).toEqual({\n        end: undefined,\n        start: undefined,\n        single: '#'\n      })\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reduce TextEdit","suites":["CocSnippet","utils"],"updatePoint":{"line":549,"column":30},"line":549,"code":"    it('should reduce TextEdit', () => {\n      let e: TextEdit\n      e = TextEdit.replace(Range.create(0, 0, 0, 3), 'foo')\n      expect(reduceTextEdit(e, '')).toEqual(e)\n      e = TextEdit.replace(Range.create(0, 0, 0, 3), 'foo\\nbar')\n      expect(reduceTextEdit(e, 'bar')).toEqual(\n        TextEdit.replace(Range.create(0, 0, 0, 0), 'foo\\n')\n      )\n      e = TextEdit.replace(Range.create(0, 0, 0, 3), 'foo\\nbar')\n      expect(reduceTextEdit(e, 'foo')).toEqual(\n        TextEdit.replace(Range.create(0, 3, 0, 3), '\\nbar')\n      )\n      e = TextEdit.replace(Range.create(0, 0, 0, 3), 'def')\n      expect(reduceTextEdit(e, 'daf')).toEqual(\n        TextEdit.replace(Range.create(0, 1, 0, 2), 'e')\n      )\n      e = TextEdit.replace(Range.create(2, 0, 3, 0), 'ascii ascii bar\\n')\n      expect(reduceTextEdit(e, 'xyz ascii bar\\n')).toEqual(\n        TextEdit.replace(Range.create(2, 0, 2, 3), 'ascii')\n      )\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get new end position","suites":["CocSnippet","utils"],"updatePoint":{"line":571,"column":35},"line":571,"code":"    it('should get new end position', () => {\n      let assert = (pos: Position, oldText: string, newText: string, res: Position) => {\n        expect(getEndPosition(pos, createTextDocument(oldText), createTextDocument(newText))).toEqual(res)\n      }\n      assert(Position.create(0, 0), 'foo', 'bar', undefined)\n      assert(Position.create(0, 0), 'foo\\nbar', 'bar', undefined)\n      assert(Position.create(0, 0), 'foo\\nbar', 'x\\nfoo\\nba', undefined)\n      assert(Position.create(0, 0), 'foo\\nbar', 'x\\nfoo\\nbar', Position.create(1, 0))\n      assert(Position.create(0, 0), 'foo', 'foo', Position.create(0, 0))\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should check content before position","suites":["CocSnippet","utils"],"updatePoint":{"line":582,"column":44},"line":582,"code":"    it('should check content before position', () => {\n      let assert = (pos: Position, oldText: string, newText: string, res: boolean) => {\n        expect(checkContentBefore(pos, createTextDocument(oldText), createTextDocument(newText))).toBe(res)\n      }\n      assert(Position.create(1, 0), 'foo\\nbar', 'foo', true)\n      assert(Position.create(1, 1), 'foo\\nbar', 'foo', false)\n      assert(Position.create(2, 0), 'foo\\nbar\\n', 'foo', false)\n      assert(Position.create(1, 1), 'foo\\nbar', 'foo\\nbd', true)\n      assert(Position.create(1, 1), 'foo\\nbar', 'foo\\nab', false)\n      assert(Position.create(1, 1), 'foo\\nbar', 'aoo\\nbb', false)\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should getParts by range","suites":["CocSnippet","utils"],"updatePoint":{"line":594,"column":32},"line":594,"code":"    it('should getParts by range', async () => {\n      expect(getParts('abcdef', Range.create(1, 5, 1, 11), Range.create(1, 6, 1, 10))).toEqual(['a', 'f'])\n      expect(getParts('abc\\nfoo\\ndef', Range.create(0, 5, 2, 3), Range.create(1, 1, 1, 2))).toEqual(['abc\\nf', 'o\\ndef'])\n      expect(getParts('abc\\ndef', Range.create(0, 1, 2, 3), Range.create(0, 1, 2, 3))).toEqual(['', ''])\n    })","file":"snippets/snippet.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append plain snippets","suites":["SnippetString","Append"],"updatePoint":{"line":5,"column":36},"line":5,"code":"    it('should append plain snippets', () => {\n      let snippetString = new SnippetString('foo')\n      expect(snippetString.value).toBe('foo')\n\n      snippetString = new SnippetString().appendText('foo')\n      expect(snippetString.value).toBe('foo')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append tabstop","suites":["SnippetString","Append"],"updatePoint":{"line":13,"column":29},"line":13,"code":"    it('should append tabstop', () => {\n      let snippetString = new SnippetString()\n        .appendTabstop()\n        .appendText(' ')\n        .appendTabstop()\n        .appendText(' ')\n        .appendTabstop(4)\n        .appendText(' ')\n        .appendTabstop(3)\n\n      expect(snippetString.value).toBe('$1 $2 $4 $3')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append placeholder","suites":["SnippetString","Append"],"updatePoint":{"line":26,"column":33},"line":26,"code":"    it('should append placeholder', () => {\n      let snippetString = new SnippetString()\n        .appendPlaceholder('abcdef')\n        .appendText(' ')\n        .appendPlaceholder('foo')\n        .appendText(' ')\n        .appendPlaceholder('bar', 4)\n        .appendText(' ')\n        .appendPlaceholder('a', 3)\n        .appendText(' ')\n        .appendPlaceholder(s => {\n          s.appendText('plain')\n        }, 5)\n\n      expect(snippetString.value).toBe('${1:abcdef} ${2:foo} ${4:bar} ${3:a} ${5:plain}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append choice","suites":["SnippetString","Append"],"updatePoint":{"line":43,"column":28},"line":43,"code":"    it('should append choice', () => {\n      let snippetString = new SnippetString()\n        .appendChoice(['foo', 'bar'])\n        .appendText(' ')\n        .appendChoice(['foo3', 'bar3'], 3)\n        .appendText(' ')\n        .appendChoice(['foo2', 'bar2'], 2)\n\n      expect(snippetString.value).toBe('${1|foo,bar|} ${3|foo3,bar3|} ${2|foo2,bar2|}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should append variables","suites":["SnippetString","Append"],"updatePoint":{"line":54,"column":31},"line":54,"code":"    it('should append variables', () => {\n      let snippetString = new SnippetString()\n        .appendVariable('foo', 'abcdef')\n        .appendText(' ')\n        .appendVariable('bar')\n\n      expect(snippetString.value).toBe('${foo:abcdef} ${bar}')\n\n      snippetString = new SnippetString()\n        .appendVariable('foo', s => s.appendText('abcdef'))\n        .appendText(' ')\n        .appendVariable('bar')\n\n      expect(snippetString.value).toBe('${foo:abcdef} ${bar}')\n    })","file":"snippets/string.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get children from root","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":77,"column":37},"line":77,"code":"    it('should get children from root', async () => {\n      let nodes = createNodes(defaultDef)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      expect(res.length).toBe(3)\n      expect(res.map(o => o.label)).toEqual(['a', 'b', 'g'])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get children from child node","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":90,"column":43},"line":90,"code":"    it('should get children from child node', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let nodes = await provider.getChildren(res[0])\n      expect(nodes.length).toBe(2)\n      expect(nodes.map(o => o.label)).toEqual(['c', 'd'])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw when provideData throws","suites":["BasicDataProvider","getChildren()"],"updatePoint":{"line":103,"column":44},"line":103,"code":"    it('should throw when provideData throws', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          throw new Error('my error')\n        }\n      })\n      disposables.push(provider)\n      let err\n      try {\n        await provider.getChildren()\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get tree item from node","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":121,"column":38},"line":121,"code":"    it('should get tree item from node', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.Collapsed)\n      item = provider.getTreeItem(res[2])\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.None)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should respect expandLevel option","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":136,"column":41},"line":136,"code":"    it('should respect expandLevel option', async () => {\n      let provider = new BasicDataProvider({\n        expandLevel: 1,\n        provideData: () => {\n          return createNodes(defaultDef)\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.collapsibleState).toBe(TreeItemCollapsibleState.Expanded)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should include highlights","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":150,"column":33},"line":150,"code":"    it('should include highlights', async () => {\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [createNode('a', [], undefined, 'tip')]\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.tooltip).toBe('tip')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use icon from node","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":163,"column":33},"line":163,"code":"    it('should use icon from node', async () => {\n      let node = createNode('a', [], undefined, 'tip')\n      node.icon = {\n        text: 'i',\n        hlGroup: 'Function'\n      }\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.icon).toBeDefined()\n      expect(item.icon).toEqual({\n        text: 'i',\n        hlGroup: 'Function'\n      })\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve icon","suites":["BasicDataProvider","getTreeItem()"],"updatePoint":{"line":185,"column":27},"line":185,"code":"    it('should resolve icon', async () => {\n      let provider = new BasicDataProvider<CustomNode>({\n        provideData: () => {\n          let node = createNode('a', [], undefined, 'tip')\n          node.kind = 'function'\n          return [node]\n        },\n        resolveIcon: item => {\n          if (item.kind === 'function') {\n            return {\n              text: 'f',\n              hlGroup: 'Function'\n            }\n          }\n        }\n      })\n      disposables.push(provider)\n      let res = await provider.getChildren()\n      let item = provider.getTreeItem(res[0])\n      expect(item).toBeDefined()\n      expect(item.icon).toEqual({\n        text: 'f',\n        hlGroup: 'Function'\n      })\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get undefined when data does not exist","suites":["BasicDataProvider","getParent()"],"updatePoint":{"line":213,"column":53},"line":213,"code":"    it('should get undefined when data does not exist', async () => {\n      let node = createNode('a')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        }\n      })\n      disposables.push(provider)\n      let res = provider.getParent(node)\n      expect(res).toBeUndefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should get parent node","suites":["BasicDataProvider","getParent()"],"updatePoint":{"line":225,"column":30},"line":225,"code":"    it('should get parent node', async () => {\n      let node = createNode('g')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [\n            createNode('a', [createNode('c', [node]), createNode('d')]),\n            createNode('b', [createNode('e'), createNode('f')]),\n            createNode('g')\n          ]\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let res = provider.getParent(node)\n      expect(res).toBeDefined()\n      expect(res.label).toBe('c')\n      // console.log(provider.labels.join('\\n'))\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should resolve tooltip and command","suites":["BasicDataProvider","resolveTreeItem()"],"updatePoint":{"line":246,"column":42},"line":246,"code":"    it('should resolve tooltip and command', async () => {\n      let node = createNode('a')\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        },\n        resolveItem: item => {\n          item.tooltip = 'tip'\n          item.command = {\n            command: 'test command',\n            title: 'test'\n          }\n          return item\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let source = new CancellationTokenSource()\n      let item = provider.getTreeItem(node)\n      let resolved = await provider.resolveTreeItem(item, node, source.token)\n      expect(resolved.tooltip).toBe('tip')\n      expect(resolved.command.command).toBe('test command')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should register command invoke click","suites":["BasicDataProvider","resolveTreeItem()"],"updatePoint":{"line":270,"column":44},"line":270,"code":"    it('should register command invoke click', async () => {\n      let node = createNode('a')\n      let called: TreeNode\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return [node]\n        },\n        handleClick: item => {\n          called = item\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let source = new CancellationTokenSource()\n      let item = provider.getTreeItem(node)\n      let resolved = await provider.resolveTreeItem(item, node, source.token)\n      expect(resolved.command).toBeDefined()\n      expect(resolved.command.command).toMatch('invoke')\n      await commandsManager.execute(resolved.command)\n      expect(called).toBeDefined()\n      expect(called).toBe(node)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add children with event","suites":["BasicDataProvider","update()"],"updatePoint":{"line":295,"column":38},"line":295,"code":"    it('should add children with event', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b']]],\n        ['b', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let b = nodes[0].children[0]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = false\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBe(b)\n        called = true\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['b', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', 'b', ' f'\n      ])\n      expect(called).toBe(true)\n      expect(b.children).toBeDefined()\n      expect(b.children.length).toBe(2)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should remove children with event","suites":["BasicDataProvider","update()"],"updatePoint":{"line":328,"column":41},"line":328,"code":"    it('should remove children with event', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let b = nodes[0].children[0]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = false\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBe(b)\n        called = true\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b']]],\n        ['e', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', 'e', ' f'\n      ])\n      expect(called).toBe(true)\n      expect(b.children).toBeUndefined()\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not fire event for children when parent have changed","suites":["BasicDataProvider","update()"],"updatePoint":{"line":360,"column":67},"line":360,"code":"    it('should not fire event for children when parent have changed', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = 0\n      provider.onDidChangeTreeData(node => {\n        expect(node).toBeUndefined()\n        called += 1\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d'], ['g']]]]],\n        ['e', [['f']]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      expect(called).toBe(1)\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', '  g', 'e', ' f'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should fire events for independent node change","suites":["BasicDataProvider","update()"],"updatePoint":{"line":389,"column":54},"line":389,"code":"    it('should fire events for independent node change', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b', [['c']]]]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let called = []\n      provider.onDidChangeTreeData(node => {\n        called.push(node)\n      })\n      let newDefs: NodeDef[] = [\n        ['a', [['b', [['c'], ['d']]]]],\n        ['e', [['f', [['g']]]]]\n      ]\n      let curr = provider.update(createNodes(newDefs))\n      expect(called.length).toBe(2)\n      expect(called[0].label).toBe('b')\n      expect(called[1].label).toBe('f')\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' b', '  c', '  d', 'e', ' f', '  g'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should apply new properties","suites":["BasicDataProvider","update()"],"updatePoint":{"line":420,"column":35},"line":420,"code":"    it('should apply new properties', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b']]],\n        ['e', [['f']]]\n      ]\n      let nodes = createNodes(defs)\n      let provider = new BasicDataProvider<CustomNode>({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = createNodes([\n        ['a', [['b', [['c']]]]],\n        ['e', [['f', [['g']]]]]\n      ])\n      let b = newNodes[0].children[0]\n      Object.assign(b, { x: 1, y: 2 })\n      let curr = provider.update(newNodes)\n      let node = curr[0].children[0]\n      expect(node).toBeDefined()\n      expect(node.x).toBe(1)\n      expect(node.y).toBe(2)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep references and have new data sequence","suites":["BasicDataProvider","update()"],"updatePoint":{"line":446,"column":57},"line":446,"code":"    it('should keep references and have new data sequence', async () => {\n      let defs: NodeDef[] = [\n        ['a', [['b'], ['c']]],\n        ['e', [['f']]],\n        ['g']\n      ]\n      let nodes = createNodes(defs)\n      let keeps = [\n        findNode('a', nodes),\n        findNode('b', nodes),\n        findNode('c', nodes),\n        findNode('e', nodes),\n        findNode('f', nodes),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = createNodes([\n        ['a', [['c', [['d'], ['h']]], ['b']]],\n        ['e', [['f', [['j']]], ['i']]]\n      ])\n      let curr = provider.update(newNodes)\n      expect(curr).toBe(nodes)\n      expect(keeps[0]).toBe(findNode('a', curr))\n      expect(keeps[1]).toBe(findNode('b', curr))\n      expect(keeps[2]).toBe(findNode('c', curr))\n      expect(keeps[3]).toBe(findNode('e', curr))\n      expect(keeps[4]).toBe(findNode('f', curr))\n      let labels = createLabels(curr)\n      expect(labels).toEqual([\n        'a', ' c', '  d', '  h', ' b', 'e', ' f', '  j', ' i'\n      ])\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should use key for nodes","suites":["BasicDataProvider","update()"],"updatePoint":{"line":484,"column":32},"line":484,"code":"    it('should use key for nodes', async () => {\n      let nodes = [\n        createNode('a', [], 'x'),\n        createNode('a', [], 'y'),\n        createNode('a', [], 'z'),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = [\n        createNode('a', [], 'x'),\n        createNode('a', [], 'z'),\n      ]\n      let curr = provider.update(newNodes)\n      expect(curr.length).toBe(2)\n      expect(curr[0].key).toBe('x')\n      expect(curr[1].key).toBe('z')\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset data","suites":["BasicDataProvider","update()"],"updatePoint":{"line":507,"column":25},"line":507,"code":"    it('should reset data', async () => {\n      let nodes = [\n        createNode('a', [], 'x'),\n      ]\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return nodes\n        }\n      })\n      disposables.push(provider)\n      await provider.getChildren()\n      let newNodes = [\n        createNode('a', [], 'x'),\n      ]\n      let curr = provider.update(newNodes, true)\n      expect(curr === nodes).toBe(false)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke onDispose from opts","suites":["BasicDataProvider","dispose"],"updatePoint":{"line":527,"column":41},"line":527,"code":"    it('should invoke onDispose from opts', async () => {\n      let called = false\n      let provider = new BasicDataProvider({\n        provideData: () => {\n          return []\n        },\n        onDispose: () => {\n          called = true\n        }\n      })\n      provider.dispose()\n      expect(called).toBe(true)\n    })","file":"tree/basicProvider.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should create TreeItem from resourceUri","suites":["TreeView","TreeItem()"],"updatePoint":{"line":95,"column":47},"line":95,"code":"    it('should create TreeItem from resourceUri', async () => {\n      let item = new TreeItem(URI.file('/foo/bar.ts'))\n      expect(item.resourceUri).toBeDefined()\n      expect(item.label).toBe('bar.ts')\n      expect(item.label).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show with title","suites":["TreeView","show()"],"updatePoint":{"line":104,"column":30},"line":104,"code":"    it('should show with title', async () => {\n      createTreeView(defaultDef)\n      expect(treeView).toBeDefined()\n      await treeView.show()\n      let visible = treeView.visible\n      expect(visible).toBe(true)\n      await helper.wait(50)\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not show when visible","suites":["TreeView","show()"],"updatePoint":{"line":114,"column":36},"line":114,"code":"    it('should not show when visible', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      let windowId = treeView.windowId\n      await treeView.show()\n      expect(treeView.windowId).toBe(windowId)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reuse window","suites":["TreeView","show()"],"updatePoint":{"line":122,"column":27},"line":122,"code":"    it('should reuse window', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      let windowId = treeView.windowId\n      await helper.wait(50)\n      provider.dispose()\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      expect(treeView.windowId).toBe(windowId)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render item icon","suites":["TreeView","show()"],"updatePoint":{"line":134,"column":31},"line":134,"code":"    it('should render item icon', async () => {\n      createTreeView(defaultDef)\n      nodes[0].icon = { text: 'i', hlGroup: 'Title' }\n      nodes[1].icon = { text: 'i', hlGroup: 'Title' }\n      nodes[2].icon = { text: 'i', hlGroup: 'Title' }\n      await treeView.show()\n      await helper.wait(50)\n      await checkLines(['test', '+ i a', '+ i b', '  i g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change open close icon","suites":["TreeView","configuration"],"updatePoint":{"line":154,"column":37},"line":154,"code":"    it('should change open close icon', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let { configurations } = workspace\n      configurations.updateUserConfig({\n        'tree.openedIcon': '',\n        'tree.closedIcon': '',\n      })\n      await helper.wait(50)\n      await checkLines(['test', ' a', ' b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit visibility change event","suites":["TreeView","attach events"],"updatePoint":{"line":184,"column":43},"line":184,"code":"    it('should emit visibility change event', async () => {\n      createTreeView(defaultDef)\n      let p = waitVisibilityEvent(true)\n      await treeView.show()\n      await p\n      nvim.command('close', true)\n      await waitVisibilityEvent(false)\n      p = waitVisibilityEvent(true)\n      await treeView.show()\n      await p\n      nvim.command('enew', true)\n      await waitVisibilityEvent(false)\n      p = waitVisibilityEvent(true)\n      await treeView.show()\n      await p\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should dispose on tab close","suites":["TreeView","attach events"],"updatePoint":{"line":201,"column":35},"line":201,"code":"    it('should dispose on tab close', async () => {\n      await nvim.command('tabe')\n      createTreeView(defaultDef)\n      await treeView.show()\n      await nvim.command('close')\n      await nvim.command('normal! 1gt')\n      await nvim.command('tabonly')\n      await helper.waitValue(() => {\n        return treeView.valid\n      }, false)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change title","suites":["TreeView","public properties"],"updatePoint":{"line":215,"column":27},"line":215,"code":"    it('should change title', async () => {\n      createTreeView(defaultDef)\n      treeView.title = 'foo'\n      await treeView.show()\n      await events.race(['TextChanged'])\n      await checkLines(['foo', '+ a', '+ b', '  g'])\n      treeView.title = 'bar'\n      await events.race(['TextChanged'])\n      await checkLines(['bar', '+ a', '+ b', '  g'])\n      treeView.title = undefined\n      await events.race(['TextChanged'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change description","suites":["TreeView","public properties"],"updatePoint":{"line":228,"column":33},"line":228,"code":"    it('should change description', async () => {\n      createTreeView(defaultDef)\n      treeView.description = 'desc'\n      await treeView.show()\n      await events.race(['TextChanged'])\n      await checkLines(['test desc', '+ a', '+ b', '  g'])\n      treeView.description = 'foo bar'\n      await events.race(['TextChanged'])\n      await checkLines(['test foo bar', '+ a', '+ b', '  g'])\n      treeView.description = ''\n      await events.race(['TextChanged'])\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change message","suites":["TreeView","public properties"],"updatePoint":{"line":242,"column":29},"line":242,"code":"    it('should change message', async () => {\n      createTreeView(defaultDef)\n      treeView.message = 'hello'\n      await treeView.show()\n      await events.race(['TextChanged'])\n      await checkLines(['hello', '', 'test', '+ a', '+ b', '  g'])\n      treeView.message = 'foo'\n      await events.race(['TextChanged'])\n      await checkLines(['foo', '', 'test', '+ a', '+ b', '  g'])\n      treeView.message = undefined\n      await events.race(['TextChanged'])\n      await checkLines(['test', '+ a', '+ b', '  g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable winfixwidth","suites":["TreeView","options"],"updatePoint":{"line":258,"column":34},"line":258,"code":"    it('should disable winfixwidth', async () => {\n      createTreeView(defaultDef, { winfixwidth: false })\n      await treeView.show()\n      let res = await nvim.eval('&winfixwidth')\n      expect(res).toBe(0)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should disable leaf indent","suites":["TreeView","options"],"updatePoint":{"line":265,"column":34},"line":265,"code":"    it('should disable leaf indent', async () => {\n      createTreeView(defaultDef, { disableLeafIndent: true })\n      await treeView.show()\n      await events.race(['TextChanged'])\n      await checkLines(['test', '+ a', '+ b', 'g'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should adjust window width","suites":["TreeView","options"],"updatePoint":{"line":272,"column":41},"line":272,"code":"    it('should should adjust window width', async () => {\n      let def: NodeDef[] = [\n        ['a', [['c'], ['d']]],\n        ['very long line']\n      ]\n      createTreeView(def, { autoWidth: true })\n      await treeView.show('belowright 10vs')\n      await events.race(['TextChanged'])\n      let width = await nvim.call('winwidth', [0])\n      expect(width).toBeGreaterThan(10)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should support many selection","suites":["TreeView","options"],"updatePoint":{"line":284,"column":37},"line":284,"code":"    it('should support many selection', async () => {\n      createTreeView(defaultDef, { canSelectMany: true })\n      await treeView.show()\n      await events.race(['TextChanged'])\n      let selection: TreeNode[]\n      treeView.onDidChangeSelection(e => {\n        selection = e.selection\n      })\n      await nvim.command('exe 1')\n      await nvim.input('<space>')\n      await helper.wait(10)\n      await nvim.command('exe 2')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(2)\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      let signs = res[0].signs\n      expect(treeView.selection.length).toBe(1)\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 2,\n        id: 3001,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should jump back by <C-o>","suites":["TreeView","key-mappings"],"updatePoint":{"line":322,"column":33},"line":322,"code":"    it('should jump back by <C-o>', async () => {\n      let winid = await nvim.call('win_getid')\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.input('<C-o>')\n      await helper.wait(50)\n      let win = await nvim.window\n      expect(win.id).toBe(winid)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle selection by <space>","suites":["TreeView","key-mappings"],"updatePoint":{"line":333,"column":42},"line":333,"code":"    it('should toggle selection by <space>', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let selection: TreeNode[]\n      treeView.onDidChangeSelection(e => {\n        selection = e.selection\n      })\n      await nvim.command('exe 1')\n      await nvim.input('<space>')\n      await helper.wait(10)\n      await nvim.command('exe 2')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      expect(selection.length).toBe(1)\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      let signs = res[0].signs\n      expect(treeView.selection.length).toBe(1)\n      expect(signs.length).toBe(1)\n      expect(signs[0]).toEqual({\n        lnum: 3,\n        id: 3002,\n        name: 'CocTreeSelected',\n        priority: 10,\n        group: 'CocTree'\n      })\n      await nvim.input('<space>')\n      await helper.wait(50)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      signs = res[0].signs\n      expect(signs.length).toBe(0)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should reset signs after expand & collapse","suites":["TreeView","key-mappings"],"updatePoint":{"line":370,"column":50},"line":370,"code":"    it('should reset signs after expand & collapse', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.command('exe 3')\n      await nvim.input('<space>')\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      let res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(1)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(0)\n      await nvim.input('t')\n      await helper.wait(100)\n      res = await nvim.call('sign_getplaced', [buf.id, { group: 'CocTree' }])\n      expect(res[0].signs.length).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should close tree view by <esc>","suites":["TreeView","key-mappings"],"updatePoint":{"line":402,"column":39},"line":402,"code":"    it('should close tree view by <esc>', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      expect(treeView.visible).toBe(true)\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      expect(treeView.visible).toBe(false)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command by <cr>","suites":["TreeView","key-mappings"],"updatePoint":{"line":412,"column":37},"line":412,"code":"    it('should invoke command by <cr>', async () => {\n      let node: TreeNode\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node).toBeUndefined()\n      await nvim.command('exe 2')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node.label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when resolve command cancelled","suites":["TreeView","key-mappings"],"updatePoint":{"line":430,"column":55},"line":430,"code":"    it('should not throw when resolve command cancelled', async () => {\n      let node: TreeNode\n      let cancelled = false\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        },\n        resolveItem: (item, _node, token) => {\n          return new Promise(resolve => {\n            let timer = setTimeout(() => {\n              item.command = {\n                title: 'not exists',\n                command: 'test'\n              }\n              resolve(item)\n            }, 5000)\n            token.onCancellationRequested(() => {\n              cancelled = true\n              clearTimeout(timer)\n              resolve(item)\n            })\n          })\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await nvim.command('exe 1')\n      await helper.wait(50)\n      expect(cancelled).toBe(true)\n      expect(node).toBeUndefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle expand by t","suites":["TreeView","key-mappings"],"updatePoint":{"line":465,"column":33},"line":465,"code":"    it('should toggle expand by t', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 1')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test', '- a', '  + c', '    d', '- b', '    e', '    f', '  g'\n      ])\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test', '+ a', '- b', '    e', '    f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should should collapse parent node by t","suites":["TreeView","key-mappings"],"updatePoint":{"line":491,"column":47},"line":491,"code":"    it('should should collapse parent node by t', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should collapse all nodes by M","suites":["TreeView","key-mappings"],"updatePoint":{"line":517,"column":38},"line":517,"code":"    it('should collapse all nodes by M', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 6')\n      await nvim.input('t')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '- b',\n        '    e',\n        '    f',\n        '  g',\n      ])\n      await nvim.input('M')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should toggle expand on open/close icon click ","suites":["TreeView","key-mappings"],"updatePoint":{"line":555,"column":54},"line":555,"code":"    it('should toggle expand on open/close icon click ', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [1, 1])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 1])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '    c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command on node click","suites":["TreeView","key-mappings"],"updatePoint":{"line":585,"column":43},"line":585,"code":"    it('should invoke command on node click', async () => {\n      let node: TreeNode\n      createTreeView(defaultDef, {}, {\n        handleClick: n => {\n          node = n\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<LeftRelease>')\n      await helper.wait(50)\n      expect(node).toBeDefined()\n      expect(node.label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when resolveActions does not exist","suites":["TreeView","invokeActions"],"updatePoint":{"line":603,"column":62},"line":603,"code":"    it('should show warning when resolveActions does not exist', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch('No actions')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show warning when resolveActions is empty","suites":["TreeView","invokeActions"],"updatePoint":{"line":614,"column":56},"line":614,"code":"    it('should show warning when resolveActions is empty', async () => {\n      createTreeView(defaultDef, {}, {\n        resolveActions: () => {\n          return []\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.wait(50)\n      let cmdline = await helper.getCmdline()\n      expect(cmdline).toMatch('No actions')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke selected action","suites":["TreeView","invokeActions"],"updatePoint":{"line":629,"column":37},"line":629,"code":"    it('should invoke selected action', async () => {\n      let args: any[]\n      let called = false\n      createTreeView(defaultDef, {}, {\n        resolveActions: (item, element) => {\n          args = [item, element]\n          return [{\n            title: 'one',\n            handler: () => {\n              called = true\n            }\n          }]\n        }\n      })\n      await treeView.show()\n      await events.race(['TextChanged'], 200)\n      await nvim.call('cursor', [2, 3])\n      await nvim.input('<tab>')\n      await helper.waitFloat()\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(called).toBe(true)\n      expect(args[0].label).toBe('a')\n      expect(args[1].label).toBe('a')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should emit visibility change on buffer unload","suites":["TreeView","events"],"updatePoint":{"line":657,"column":54},"line":657,"code":"    it('should emit visibility change on buffer unload', async () => {\n      createTreeView(defaultDef)\n      let visible\n      treeView.onDidChangeVisibility(e => {\n        visible = e.visible\n      })\n      await treeView.show()\n      await helper.wait(50)\n      let buf = await nvim.buffer\n      nvim.command(`bd! ${buf.id}`, true)\n      await helper.wait(50)\n      expect(visible).toBe(false)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show tooltip on CursorHold","suites":["TreeView","events"],"updatePoint":{"line":671,"column":41},"line":671,"code":"    it('should show tooltip on CursorHold', async () => {\n      createTreeView(defaultDef, {}, {\n        resolveItem: (item, node) => {\n          if (node.label == 'a') {\n            item.tooltip = 'first'\n          }\n          if (node.label == 'b') {\n            item.tooltip = { kind: 'markdown', value: '#title' }\n          }\n          return item\n        }\n      })\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      let bufnr = await nvim.eval(`bufnr('%')`) as number\n      await events.fire('CursorHold', [bufnr])\n      let win = await helper.getFloat()\n      expect(win).toBeDefined()\n      let buf = await win.buffer\n      let lines = await buf.lines\n      expect(lines).toEqual(['first'])\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await events.fire('CursorHold', [bufnr])\n      lines = await buf.lines\n      expect(lines).toEqual(['#title'])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should ignore hidden node change","suites":["TreeView","data change"],"updatePoint":{"line":702,"column":40},"line":702,"code":"    it('should ignore hidden node change', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let tick = await nvim.eval('b:changedtick')\n      updateData([\n        ['a', [['c', [['h']]], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g']\n      ])\n      await helper.wait(50)\n      let curr = await nvim.eval('b:changedtick')\n      expect(curr).toBe(tick)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render all nodes on root change","suites":["TreeView","data change"],"updatePoint":{"line":717,"column":46},"line":717,"code":"    it('should render all nodes on root change', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      updateData([\n        ['g'],\n        ['h'],\n        ['b', [['e'], ['f']]],\n        ['a', [['c'], ['d']]]\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  g',\n        '  h',\n        '+ b',\n        '+ a',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep node open state","suites":["TreeView","data change"],"updatePoint":{"line":739,"column":35},"line":739,"code":"    it('should keep node open state', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 3')\n      await nvim.input('t')\n      await helper.wait(50)\n      await nvim.command('exe 6')\n      await nvim.input('t')\n      await helper.wait(50)\n      updateData([\n        ['h'],\n        ['g', [['i']]],\n        ['b', [['f']]],\n        ['a', [['c'], ['j']]]\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  h',\n        '+ g',\n        '- b',\n        '    f',\n        '- a',\n        '    c',\n        '    j',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render changed nodes","suites":["TreeView","data change"],"updatePoint":{"line":775,"column":35},"line":775,"code":"    it('should render changed nodes', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      updateData([\n        ['a', [['h', [['i']]], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g'],\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '- a',\n        '  + h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should error message on error","suites":["TreeView","data change"],"updatePoint":{"line":800,"column":37},"line":800,"code":"    it('should error message on error', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await nvim.command('exe 2')\n      await nvim.input('t')\n      await helper.wait(50)\n      let msg = 'Unable to fetch children'\n      provider.getChildren = () => {\n        throw new Error(msg)\n      }\n      updateData([['a']])\n      await helper.wait(50)\n      let line = await nvim.call('getline', [1])\n      expect(line).toMatch(msg)\n      let res = await treeView.checkLines()\n      expect(res).toBe(true)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should show error message on refresh error","suites":["TreeView","data change"],"updatePoint":{"line":819,"column":50},"line":819,"code":"    it('should show error message on refresh error', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      makeUpdateUIThrowError()\n      updateData([\n        ['a', [['h'], ['d']]],\n        ['b', [['e'], ['f']]],\n        ['g'],\n      ])\n      await helper.wait(50)\n      let line = await helper.getCmdline()\n      expect(line).toMatch('Error on tree refresh')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should render deprecated node with deprecated highlight","suites":["TreeView","data change"],"updatePoint":{"line":834,"column":63},"line":834,"code":"    it('should render deprecated node with deprecated highlight', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let defs: NodeDef[] = [\n        ['a'],\n        ['b']\n      ]\n      let nodes = createNodes(defs)\n      nodes[0].deprecated = true\n      provider.update(nodes)\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '  a',\n        '  b',\n      ])\n      let ns = await nvim.call('coc#highlight#create_namespace', ['tree'])\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], { details: true }]) as any[]\n      expect(markers.length > 0).toBe(true)\n      expect(markers[0][3]['hl_group']).toBe('CocDeprecatedHighlight')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw when node not rendered","suites":["TreeView","focusItem()"],"updatePoint":{"line":860,"column":47},"line":860,"code":"    it('should not throw when node not rendered', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      let c = nodes[0].children[0]\n      treeView.focusItem(c)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should focus rendered node","suites":["TreeView","focusItem()"],"updatePoint":{"line":868,"column":34},"line":868,"code":"    it('should focus rendered node', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      treeView.focusItem(nodes[1])\n      await helper.wait(50)\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toBe('+ b')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should throw error when getParent does not exist","suites":["TreeView","reveal()"],"updatePoint":{"line":880,"column":56},"line":880,"code":"    it('should throw error when getParent does not exist', async () => {\n      createTreeView(defaultDef)\n      provider.getParent = undefined\n      await treeView.show()\n      await helper.wait(50)\n      let err\n      try {\n        await treeView.reveal(nodes[0].children[0])\n      } catch (e) {\n        err = e\n      }\n      expect(err).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should select item","suites":["TreeView","reveal()"],"updatePoint":{"line":894,"column":26},"line":894,"code":"    it('should select item', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      let h = createNode('h')\n      c.children = [h]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(h)\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n      let selection = treeView.selection\n      expect(selection.length).toBe(1)\n      expect(selection[0].label).toBe('h')\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('h')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not select item","suites":["TreeView","reveal()"],"updatePoint":{"line":918,"column":30},"line":918,"code":"    it('should not select item', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[1], { select: false })\n      let lnum = await nvim.call('line', ['.'])\n      expect(lnum).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should focus item","suites":["TreeView","reveal()"],"updatePoint":{"line":927,"column":25},"line":927,"code":"    it('should focus item', async () => {\n      createTreeView(defaultDef)\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[1], { focus: true })\n      let line = await nvim.call('getline', ['.'])\n      expect(line).toMatch('b')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand item whih single level","suites":["TreeView","reveal()"],"updatePoint":{"line":936,"column":44},"line":936,"code":"    it('should expand item whih single level', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[0], { expand: true })\n      await checkLines([\n        'test',\n        '- a',\n        '  + c',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should expand item whih 2 level","suites":["TreeView","reveal()"],"updatePoint":{"line":953,"column":39},"line":953,"code":"    it('should expand item whih 2 level', async () => {\n      createTreeView(defaultDef)\n      let c = nodes[0].children[0]\n      c.children = [createNode('h')]\n      await treeView.show()\n      await helper.wait(50)\n      await treeView.reveal(nodes[0], { expand: 2 })\n      await checkLines([\n        'test',\n        '- a',\n        '  - c',\n        '      h',\n        '    d',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should start filter by input","suites":["TreeView","filter"],"updatePoint":{"line":981,"column":36},"line":981,"code":"    it('should start filter by input', async () => {\n      await createFilterTreeView()\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n      await nvim.input('a')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  a',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw error on filter","suites":["TreeView","filter"],"updatePoint":{"line":995,"column":40},"line":995,"code":"    it('should not throw error on filter', async () => {\n      await createFilterTreeView()\n        ; (treeView as any).getRenderedLine = () => {\n          throw new Error('Error on updateUI')\n        }\n      await nvim.input('a')\n      await helper.wait(50)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should add & remove Cursor highlight on window change","suites":["TreeView","filter"],"updatePoint":{"line":1004,"column":61},"line":1004,"code":"    it('should add & remove Cursor highlight on window change', async () => {\n      let winid = await nvim.call('win_getid')\n      let ns = await nvim.call('coc#highlight#create_namespace', ['tree'])\n      await createFilterTreeView()\n      let bufnr = await nvim.call('bufnr', ['%'])\n      let markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers[0]).toBeDefined()\n      await nvim.call('win_gotoid', [winid])\n      await helper.wait(50)\n      markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers.length).toBe(0)\n      await nvim.command('wincmd p')\n      await helper.wait(50)\n      markers = await nvim.call('nvim_buf_get_extmarks', [bufnr, ns, [1, 0], [1, -1], {}]) as [number, number, number][]\n      expect(markers.length).toBe(1)\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should filter new nodes on data change","suites":["TreeView","filter"],"updatePoint":{"line":1021,"column":46},"line":1021,"code":"    it('should filter new nodes on data change', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      updateData([\n        ['ab'],\n        ['e'],\n        ['fa']\n      ])\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        'a ',\n        '  ab',\n        '  fa',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should change selected item by <up> and <down>","suites":["TreeView","filter"],"updatePoint":{"line":1039,"column":54},"line":1039,"code":"    it('should change selected item by <up> and <down>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      updateData([\n        ['ab'],\n        ['fa']\n      ])\n      await helper.wait(50)\n      await nvim.input('<down>')\n      await helper.wait(50)\n      let curr = treeView.selection[0]\n      expect(curr.label).toBe('fa')\n      await nvim.input('<down>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('ab')\n      await nvim.input('<up>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('fa')\n      await nvim.input('<up>')\n      await helper.wait(50)\n      curr = treeView.selection[0]\n      expect(curr.label).toBe('ab')\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should not throw with empty nodes","suites":["TreeView","filter"],"updatePoint":{"line":1066,"column":41},"line":1066,"code":"    it('should not throw with empty nodes', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<up>')\n      await helper.wait(50)\n      await nvim.input('<down>')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await checkLines(['test', 'ab '])\n      let curr = treeView.selection[0]\n      expect(curr).toBeUndefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should invoke command by <cr>","suites":["TreeView","filter"],"updatePoint":{"line":1081,"column":37},"line":1081,"code":"    it('should invoke command by <cr>', async () => {\n      let node\n      await createFilterTreeView({\n        handleClick: n => {\n          node = n\n        }\n      })\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      expect(node).toBeDefined()\n      let curr = treeView.selection[0]\n      expect(curr).toBeDefined()\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should keep state when press <cr> with empty selection ","suites":["TreeView","filter"],"updatePoint":{"line":1095,"column":63},"line":1095,"code":"    it('should keep state when press <cr> with empty selection ', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<cr>')\n      await helper.wait(50)\n      await checkLines(['test', 'ab '])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should delete last filter character by <bs>","suites":["TreeView","filter"],"updatePoint":{"line":1104,"column":51},"line":1104,"code":"    it('should delete last filter character by <bs>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(50)\n      await nvim.input('<bs>')\n      await helper.wait(50)\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should clean filter character by <C-u>","suites":["TreeView","filter"],"updatePoint":{"line":1115,"column":46},"line":1115,"code":"    it('should clean filter character by <C-u>', async () => {\n      await createFilterTreeView()\n      await nvim.input('ab')\n      await helper.wait(50)\n      await nvim.input('<C-u>')\n      await helper.wait(50)\n      await checkLines([\n        'test', ' ', '  a', '  c', '  d', '  b', '  e', '  f', '  g'\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should cancel filter by <esc> and <C-o>","suites":["TreeView","filter"],"updatePoint":{"line":1126,"column":47},"line":1126,"code":"    it('should cancel filter by <esc> and <C-o>', async () => {\n      await createFilterTreeView()\n      await nvim.input('<esc>')\n      await helper.wait(50)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n      await nvim.input('f')\n      await helper.wait(20)\n      await nvim.input('<C-o>')\n      await helper.wait(20)\n      await checkLines([\n        'test',\n        '+ a',\n        '+ b',\n        '  g',\n      ])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"},{"name":"should navigate input history by <C-n> and <C-p>","suites":["TreeView","filter"],"updatePoint":{"line":1148,"column":56},"line":1148,"code":"    it('should navigate input history by <C-n> and <C-p>', async () => {\n      await createFilterTreeView()\n      await nvim.input('a')\n      await helper.wait(20)\n      await nvim.input('<esc>')\n      await helper.wait(20)\n      await nvim.input('f')\n      await helper.wait(20)\n      await nvim.input('b')\n      await helper.wait(20)\n      await nvim.input('<C-o>')\n      await helper.wait(20)\n      await nvim.input('f')\n      await helper.wait(20)\n      await nvim.input('<C-n>')\n      await helper.wait(20)\n      await checkLines(['test', 'a ', '  a',])\n      await nvim.input('<C-n>')\n      await helper.wait(20)\n      await checkLines(['test', 'b ', '  b',])\n      await nvim.input('<C-p>')\n      await helper.wait(20)\n      await checkLines(['test', 'a ', '  a',])\n      await nvim.input('<C-p>')\n      await helper.wait(20)\n      await checkLines(['test', 'b ', '  b',])\n    })","file":"tree/treeView.test.ts","skipped":false,"dir":"src/__tests__"}]}