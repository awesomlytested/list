{"repo":"BabylonJS/Babylon.js","url":"https://github.com/BabylonJS/Babylon.js","branch":"master","configs":[{"package":"babylonjs","lang":"js","dir":"tests","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"babylonjs-viewer","lang":"js","dir":"Viewer/tests","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should call callback when configuration is loaded","suites":["Configuration loader"],"updatePoint":{"line":8,"column":55,"index":448},"line":8,"code":"  it(\"should call callback when configuration is loaded\", done => {\n    let configurationLoader = new ConfigurationLoader();\n    configurationLoader.loadConfiguration({}, newConfig => {\n      done();\n    });\n  });","file":"unit/src/configuration/loader.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should resolve the promise when configuration is loaded","suites":["Configuration loader"],"updatePoint":{"line":14,"column":61,"index":668},"line":14,"code":"  it(\"should resolve the promise when configuration is loaded\", done => {\n    let configurationLoader = new ConfigurationLoader();\n    configurationLoader.loadConfiguration({}).then(() => {\n      done();\n    });\n  });","file":"unit/src/configuration/loader.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should not change configuration is not needed initConfig","suites":["Configuration loader"],"updatePoint":{"line":20,"column":62,"index":887},"line":20,"code":"  it(\"should not change configuration is not needed initConfig\", done => {\n    let configurationLoader = new ConfigurationLoader();\n    let config = {\n      version: \"\" + Math.random(),\n      extends: \"none\"\n    };\n    configurationLoader.loadConfiguration(config, newConfig => {\n      assert.deepEqual(config, newConfig);\n      done();\n    });\n  });","file":"unit/src/configuration/loader.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should load default configuration is no configuration extension provided","suites":["Configuration loader"],"updatePoint":{"line":31,"column":78,"index":1254},"line":31,"code":"  it(\"should load default configuration is no configuration extension provided\", done => {\n    let configurationLoader = new ConfigurationLoader();\n    let config = {\n      version: \"\" + Math.random()\n    };\n    configurationLoader.loadConfiguration(config, newConfig => {\n      assert.equal(config.version, newConfig.version);\n      assert.notDeepEqual(config, newConfig);\n      assert.isDefined(newConfig.engine);\n      assert.isDefined(newConfig.scene);\n      assert.isDefined(newConfig.templates);\n      done();\n    });\n  });","file":"unit/src/configuration/loader.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should have html, json and dom mappers","suites":["Configuration mappers"],"updatePoint":{"line":7,"column":44,"index":342},"line":7,"code":"  it(\"should have html, json and dom mappers\", done => {\n    assert.isDefined(mapperManager);\n    assert.isDefined(mapperManager.getMapper(\"html\"));\n    assert.isDefined(mapperManager.getMapper(\"json\"));\n    assert.isDefined(mapperManager.getMapper(\"dom\"));\n    done();\n  });","file":"unit/src/configuration/mappers.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should map html elements correctly","suites":["Configuration mappers"],"updatePoint":{"line":14,"column":40,"index":614},"line":14,"code":"  it(\"should map html elements correctly\", done => {\n    let htmlMappers = mapperManager.getMapper(\"html\");\n    let randomNumber = Math.random();\n    let randomString = \"test-\" + Math.random();\n    let htmlString = `<test-element model.rotation-offset-angle=\"${randomNumber}\" model.cast-shadow=\"true\" model.id=\"${randomString}\"></test-element>`;\n    var d = document.createElement('div');\n    d.innerHTML = htmlString;\n    let htmlElement = d.firstChild;\n    let config = htmlMappers.map(htmlElement);\n\n    if (config.model && typeof config.model === 'object') {\n      assert.equal(config.model.rotationOffsetAngle, randomNumber);\n      assert.isTrue(config.model.castShadow);\n      assert.equal(config.model.id, randomString);\n      done();\n    } else {\n      assert.fail();\n    }\n  });","file":"unit/src/configuration/mappers.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should map dom elements correctly","suites":["Configuration mappers"],"updatePoint":{"line":33,"column":39,"index":1401},"line":33,"code":"  it(\"should map dom elements correctly\", done => {\n    let domMappers = mapperManager.getMapper(\"dom\");\n    let randomNumber = Math.random();\n    let randomString = \"test-\" + Math.random();\n    let htmlString = `<test-element>\n    <model rotation-offset-angle=\"${randomNumber}\" cast-shadow=\"true\" id=\"${randomString}\">\n    </model>\n</test-element>`;\n    var d = document.createElement('div');\n    d.innerHTML = htmlString;\n    let htmlElement = d.firstChild;\n    let config = domMappers.map(htmlElement);\n\n    if (config.model && typeof config.model === 'object') {\n      assert.equal(config.model.rotationOffsetAngle, randomNumber);\n      assert.isTrue(config.model.castShadow);\n      assert.equal(config.model.id, randomString);\n      done();\n    } else {\n      assert.fail();\n    }\n  });","file":"unit/src/configuration/mappers.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should register a new mapper and allow to use it","suites":["Configuration mappers"],"updatePoint":{"line":55,"column":54,"index":2208},"line":55,"code":"  it(\"should register a new mapper and allow to use it\", done => {\n    let randomVersion = \"version\" + Math.random();\n    let randomName = \"test\" + Math.random();\n    randomName = randomName.replace(\".\", \"\");\n    let newMapper = {\n      map: rawSource => {\n        return {\n          version: randomVersion\n        };\n      }\n    };\n    console.log(\"Next error log is expected\");\n    assert.isUndefined(mapperManager.getMapper(randomName));\n    mapperManager.registerMapper(randomName, newMapper);\n    let mapperTest = mapperManager.getMapper(randomName);\n    assert.isDefined(mapperTest);\n    assert.equal(mapperTest, newMapper);\n    let config = mapperTest.map(\"\");\n    assert.equal(config.version, randomVersion);\n    done();\n  });","file":"unit/src/configuration/mappers.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should be used as a template for the following tests","suites":[],"updatePoint":{"line":6,"column":58,"index":313},"line":6,"code":"  it(\"should be used as a template for the following tests\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    viewer.onInitDoneObservable.add(() => {\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should update the image processing configuration values","suites":[],"updatePoint":{"line":15,"column":61,"index":571},"line":15,"code":"  it(\"should update the image processing configuration values\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    viewer.onInitDoneObservable.add(() => {\n      // check babylon defaults\n      assert.isFalse(viewer.sceneManager.scene.imageProcessingConfiguration.applyByPostProcess);\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.exposure, 1);\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.contrast, 1);\n      assert.isFalse(viewer.sceneManager.scene.imageProcessingConfiguration.colorGradingEnabled);\n\n      if (viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves) {\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalDensity, 0);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalHue, 30);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalSaturation, 0);\n      } else {\n        assert.fail(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves, {}, \"color curves was not initialized\");\n      } // update with fixed values\n\n\n      viewer.updateConfiguration({\n        scene: {\n          imageProcessingConfiguration: {\n            applyByPostProcess: true,\n            exposure: 0,\n            contrast: 0,\n            colorGradingEnabled: true,\n            colorCurves: {\n              globalDensity: 1,\n              globalHue: 0.2,\n              globalSaturation: 0.5\n            }\n          }\n        }\n      });\n      assert.isTrue(viewer.sceneManager.scene.imageProcessingConfiguration.applyByPostProcess, \"apply by post process should be true\");\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.exposure, 0);\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.contrast, 0);\n      assert.isTrue(viewer.sceneManager.scene.imageProcessingConfiguration.colorGradingEnabled);\n\n      if (viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves) {\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalDensity, 1);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalHue, 0.2);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.globalSaturation, 0.5);\n      } else {\n        assert.fail(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves, {}, \"color curves was not initialized\");\n      }\n\n      let randoms = [0, 1, 2, 3, 4].map(n => Math.random());\n      viewer.updateConfiguration({\n        scene: {\n          imageProcessingConfiguration: {\n            exposure: randoms[0],\n            contrast: randoms[1],\n            colorCurves: {\n              highlightsDensity: randoms[2],\n              highlightsHue: randoms[3],\n              highlightsSaturation: randoms[4]\n            }\n          }\n        }\n      });\n      assert.isTrue(viewer.sceneManager.scene.imageProcessingConfiguration.applyByPostProcess, \"apply by post process should be true\");\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.exposure, randoms[0]);\n      assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.contrast, randoms[1]);\n      assert.isTrue(viewer.sceneManager.scene.imageProcessingConfiguration.colorGradingEnabled);\n\n      if (viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves) {\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.highlightsDensity, randoms[2]);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.highlightsHue, randoms[3]);\n        assert.equal(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves.highlightsSaturation, randoms[4]);\n      } else {\n        assert.fail(viewer.sceneManager.scene.imageProcessingConfiguration.colorCurves, {}, \"color curves was not initialized\");\n      }\n\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should update main color and reflection color","suites":[],"updatePoint":{"line":94,"column":51,"index":4614},"line":94,"code":"  it(\"should update main color and reflection color\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    viewer.onInitDoneObservable.add(() => {\n      assert.equal(viewer.sceneManager.mainColor.r, 1);\n      assert.equal(viewer.sceneManager.mainColor.g, 1);\n      assert.equal(viewer.sceneManager.mainColor.b, 1);\n      assert.equal(viewer.sceneManager.reflectionColor.r, 1);\n      assert.equal(viewer.sceneManager.reflectionColor.g, 1);\n      assert.equal(viewer.sceneManager.reflectionColor.b, 1);\n      viewer.updateConfiguration({\n        environmentMap: {\n          tintLevel: 1,\n          texture: \"\",\n          rotationY: 0,\n          mainColor: {\n            r: 0.5,\n            g: 0.5,\n            b: 0.5\n          }\n        }\n      });\n      assert.equal(viewer.sceneManager.mainColor.r, 0.5);\n      assert.equal(viewer.sceneManager.mainColor.g, 0.5);\n      assert.equal(viewer.sceneManager.mainColor.b, 0.5); // to black\n\n      viewer.updateConfiguration({\n        scene: {\n          mainColor: {\n            r: 0,\n            g: 0,\n            b: 0\n          }\n        }\n      });\n      assert.equal(viewer.sceneManager.mainColor.r, 0);\n      assert.equal(viewer.sceneManager.mainColor.g, 0);\n      assert.equal(viewer.sceneManager.mainColor.b, 0);\n      assert.equal(viewer.sceneManager.reflectionColor.r, 0);\n      assert.equal(viewer.sceneManager.reflectionColor.g, 0);\n      assert.equal(viewer.sceneManager.reflectionColor.b, 0);\n      let randomColor = Math.random(); //only update red\n\n      viewer.updateConfiguration({\n        scene: {\n          mainColor: {\n            r: randomColor\n          }\n        }\n      });\n      assert.equal(viewer.sceneManager.mainColor.r, randomColor);\n      assert.equal(viewer.sceneManager.mainColor.g, 0);\n      assert.equal(viewer.sceneManager.mainColor.b, 0);\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should update the flags correctly","suites":[],"updatePoint":{"line":152,"column":39,"index":6521},"line":152,"code":"  it(\"should update the flags correctly\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    viewer.onInitDoneObservable.add(() => {\n      viewer.updateConfiguration({\n        scene: {\n          flags: {\n            audioEnabled: false\n          }\n        }\n      });\n      assert.isFalse(viewer.sceneManager.scene.audioEnabled);\n      viewer.updateConfiguration({\n        scene: {\n          flags: {\n            audioEnabled: true,\n            lightsEnabled: false\n          }\n        }\n      });\n      assert.isTrue(viewer.sceneManager.scene.audioEnabled);\n      assert.isFalse(viewer.sceneManager.scene.lightsEnabled);\n      viewer.updateConfiguration({\n        scene: {\n          flags: {\n            lightsEnabled: true,\n            shadowsEnabled: false\n          }\n        }\n      });\n      assert.isTrue(viewer.sceneManager.scene.audioEnabled);\n      assert.isTrue(viewer.sceneManager.scene.lightsEnabled);\n      assert.isFalse(viewer.sceneManager.scene.shadowsEnabled);\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should be enabled and disabled with booleans","suites":[],"updatePoint":{"line":192,"column":50,"index":7662},"line":192,"code":"  it(\"should be enabled and disabled with booleans\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    let started = false;\n    let optimizerFunction = SceneOptimizer; //mock!\n\n    SceneOptimizer.prototype.start = function () {\n      started = true;\n    };\n\n    SceneOptimizer.prototype.stop = function () {\n      started = false;\n    };\n\n    SceneOptimizer.prototype.dispose = function () {};\n\n    viewer.onInitDoneObservable.add(() => {\n      assert.isUndefined(viewer.sceneManager.sceneOptimizer);\n      viewer.updateConfiguration({\n        optimizer: true\n      });\n      assert.isDefined(viewer.sceneManager.sceneOptimizer);\n      assert.isTrue(started);\n      viewer.updateConfiguration({\n        optimizer: false\n      });\n      assert.isUndefined(viewer.sceneManager.sceneOptimizer);\n      assert.isFalse(started); //SceneOptimizer = optimizerFunction;\n\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should enable and disable camera behaviors","suites":[],"updatePoint":{"line":228,"column":48,"index":8665},"line":228,"code":"  it(\"should enable and disable camera behaviors\", done => {\n    let viewer = Helper.getNewViewerInstance(undefined, {\n      extends: \"none\"\n    });\n    viewer.onInitDoneObservable.add(() => {\n      assert.isFalse(viewer.sceneManager.camera.useAutoRotationBehavior);\n      viewer.updateConfiguration({\n        camera: {\n          behaviors: {\n            autoRotate: {\n              type: 0\n            }\n          }\n        }\n      });\n      assert.isTrue(viewer.sceneManager.camera.useAutoRotationBehavior);\n      viewer.updateConfiguration({\n        camera: {\n          behaviors: {\n            autoRotate: false\n          }\n        }\n      });\n      assert.isFalse(viewer.sceneManager.camera.useAutoRotationBehavior);\n      viewer.dispose();\n      done();\n    });\n  });","file":"unit/src/configuration/updateConfiguration.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should convert camelCase to kebab-case and back","suites":["viewer helper"],"updatePoint":{"line":7,"column":53,"index":390},"line":7,"code":"  it(\"should convert camelCase to kebab-case and back\", done => {\n    let camelString = \"oneTestTwoTestThreeTest\";\n    let kebab = camelToKebab(camelString);\n    assert.equal(kebab, \"one-test-two-test-three-test\");\n    assert.equal(kebabToCamel(kebab), camelString);\n    done();\n  });","file":"unit/src/helper.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should find absolute and relative http urls","suites":["viewer helper"],"updatePoint":{"line":14,"column":49,"index":671},"line":14,"code":"  it(\"should find absolute and relative http urls\", done => {\n    let url = \"http://test.url/?param=123\";\n    let https = \"https://https.url.to.check/\";\n    let relativeUrl = \"/url/to/find\";\n    let notUrl = \"not a url!\";\n    let ftp = \"ftp://test.ftp.server\";\n    assert.isTrue(isUrl(url));\n    assert.isTrue(isUrl(https));\n    assert.isTrue(isUrl(relativeUrl));\n    assert.isFalse(isUrl(notUrl));\n    assert.isFalse(isUrl(ftp));\n    done();\n  });","file":"unit/src/helper.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should extend objects correctly","suites":["viewer helper"],"updatePoint":{"line":27,"column":37,"index":1108},"line":27,"code":"  it(\"should extend objects correctly\", done => {\n    let finalKey = Math.random();\n    let toAugoment = {\n      definedKey: Math.random(),\n      color: {\n        r: 0,\n        g: 0\n      },\n      test: function () {}\n    };\n    let augmentation = {\n      definedKey: finalKey,\n      color: {\n        r: finalKey,\n        g: finalKey,\n        b: finalKey\n      },\n      undefinedKey: \"shouldNotBeAugmented\",\n      test: \"should be ignored\"\n    };\n    assert.notEqual(toAugoment.definedKey, augmentation.definedKey);\n    extendClassWithConfig(toAugoment, augmentation); //defined keys should be replaced\n\n    assert.equal(toAugoment.definedKey, finalKey); //undefined keys should not be set\n\n    assert.isUndefined(toAugoment.undefinedKey); // functions should be ignored\n\n    assert.isFunction(toAugoment.test); //should iterate to deep objects\n\n    assert.equal(toAugoment.color.r, finalKey);\n    assert.equal(toAugoment.color.g, finalKey); //b should not be set!\n\n    assert.isUndefined(toAugoment.color.b);\n    done();\n  });","file":"unit/src/helper.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should be defined when the library is loaded","suites":["Viewer Manager"],"updatePoint":{"line":6,"column":50,"index":334},"line":6,"code":"  it(\"should be defined when the library is loaded\", done => {\n    assert.isDefined(viewerManager, \"viewerManager is not defined\");\n    done();\n  });","file":"unit/src/viewer/viewerManager.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should add and remove a viewer when viewer constructed and disposed","suites":["Viewer Manager"],"updatePoint":{"line":10,"column":73,"index":507},"line":10,"code":"  it(\"should add and remove a viewer when viewer constructed and disposed\", done => {\n    let element = document.createElement(\"div\");\n    let randomString = \"\" + Math.random();\n    element.id = randomString;\n    assert.isUndefined(viewerManager.getViewerByHTMLElement(element));\n    assert.isUndefined(viewerManager.getViewerById(randomString));\n    let viewer = Helper.getNewViewerInstance(element);\n    assert.isDefined(viewerManager.getViewerByHTMLElement(element));\n    assert.isDefined(viewerManager.getViewerById(randomString));\n    viewer.dispose();\n    assert.isUndefined(viewerManager.getViewerByHTMLElement(element));\n    assert.isUndefined(viewerManager.getViewerById(randomString));\n    done();\n  });","file":"unit/src/viewer/viewerManager.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should trigger the promsie when viewer was added","suites":["Viewer Manager"],"updatePoint":{"line":24,"column":54,"index":1202},"line":24,"code":"  it(\"should trigger the promsie when viewer was added\", done => {\n    let element = document.createElement(\"div\");\n    let randomString = \"\" + Math.random();\n    element.id = randomString;\n    let viewer = Helper.getNewViewerInstance(element);\n    viewerManager.getViewerPromiseById(randomString).then(() => {\n      viewer.dispose();\n      done();\n    }, error => {\n      assert.fail();\n    });\n  });","file":"unit/src/viewer/viewerManager.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should trigger observers when viewer constructed and disposed","suites":["Viewer Manager"],"updatePoint":{"line":36,"column":67,"index":1617},"line":36,"code":"  it(\"should trigger observers when viewer constructed and disposed\", done => {\n    let element = document.createElement(\"div\");\n    let randomString = \"\" + Math.random();\n    element.id = randomString;\n    let addedFlag = false;\n    viewerManager.onViewerAddedObservable.add(addedViewer => {\n      assert.equal(addedViewer.baseId, randomString);\n      addedFlag = true;\n    });\n    viewerManager.onViewerRemovedObservable.add(viewerId => {\n      assert.equal(randomString, viewerId);\n\n      if (addedFlag) {\n        viewerManager.dispose();\n        done();\n      } else {\n        assert.fail();\n      }\n    });\n    let viewer = Helper.getNewViewerInstance(element);\n    viewer.dispose();\n  });","file":"unit/src/viewer/viewerManager.ts","skipped":false,"dir":"Viewer/tests"},{"name":"should dispose viewer(s) when disposed","suites":["Viewer Manager"],"updatePoint":{"line":58,"column":44,"index":2289},"line":58,"code":"  it(\"should dispose viewer(s) when disposed\", done => {\n    let element = document.createElement(\"div\");\n    let randomString = \"\" + Math.random();\n    element.id = randomString;\n    let viewer = Helper.getNewViewerInstance(element);\n    let dispose = viewer.dispose;\n\n    viewer.dispose = () => {\n      dispose.call(viewer);\n      done();\n    };\n\n    viewerManager.dispose();\n  });","file":"unit/src/viewer/viewerManager.ts","skipped":false,"dir":"Viewer/tests"}]}