{"repo":"n8n-io/n8n","url":"https://github.com/n8n-io/n8n","branch":"master","configs":[{"package":"n8n","lang":"ts","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-core","lang":"ts","dir":"packages/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-editor-ui","lang":"js","dir":"packages/editor-ui/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-nodes-base","lang":"ts","dir":"packages/nodes-base/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-workflow","lang":"ts","dir":"packages/workflow/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"POST /login should log user in","suites":[],"updatePoint":{"line":50,"column":36},"line":50,"code":"test('POST /login should log user in', async () => {\n\tconst ownerPassword = randomValidPassword();\n\tconst owner = await testDb.createUser({\n\t\tpassword: ownerPassword,\n\t\tglobalRole: globalOwnerRole,\n\t});\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post('/login').send({\n\t\temail: owner.email,\n\t\tpassword: ownerPassword,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(owner.email);\n\texpect(firstName).toBe(owner.firstName);\n\texpect(lastName).toBe(owner.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return 401 Unauthorized if no cookie","suites":[],"updatePoint":{"line":95,"column":60},"line":95,"code":"test('GET /login should return 401 Unauthorized if no cookie', async () => {\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.get('/login');\n\n\texpect(response.statusCode).toBe(401);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return cookie if UM is disabled and no cookie is already set","suites":[],"updatePoint":{"line":106,"column":84},"line":106,"code":"test('GET /login should return cookie if UM is disabled and no cookie is already set', async () => {\n\tconst authlessAgent = utils.createAgent(app);\n\tawait testDb.createUserShell(globalOwnerRole);\n\n\tconfig.set('userManagement.isInstanceOwnerSetUp', false);\n\n\tawait Db.collections.Settings.update(\n\t\t{ key: 'userManagement.isInstanceOwnerSetUp' },\n\t\t{ value: JSON.stringify(false) },\n\t);\n\n\tconst response = await authlessAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return 401 Unauthorized if invalid cookie","suites":[],"updatePoint":{"line":125,"column":65},"line":125,"code":"test('GET /login should return 401 Unauthorized if invalid cookie', async () => {\n\tconst invalidAuthAgent = utils.createAgent(app);\n\tinvalidAuthAgent.jar.setCookie(`${AUTH_COOKIE_NAME}=invalid`);\n\n\tconst response = await invalidAuthAgent.get('/login');\n\n\texpect(response.statusCode).toBe(401);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in owner shell","suites":[],"updatePoint":{"line":137,"column":52},"line":137,"code":"test('GET /login should return logged-in owner shell', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBeNull();\n\texpect(lastName).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in member shell","suites":[],"updatePoint":{"line":173,"column":53},"line":173,"code":"test('GET /login should return logged-in member shell', async () => {\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconst response = await authAgent(memberShell).get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBeNull();\n\texpect(lastName).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('member');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in owner","suites":[],"updatePoint":{"line":209,"column":46},"line":209,"code":"test('GET /login should return logged-in owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst response = await authAgent(owner).get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(owner.email);\n\texpect(firstName).toBe(owner.firstName);\n\texpect(lastName).toBe(owner.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in member","suites":[],"updatePoint":{"line":245,"column":47},"line":245,"code":"test('GET /login should return logged-in member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authAgent(member).get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(member.email);\n\texpect(firstName).toBe(member.firstName);\n\texpect(lastName).toBe(member.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('member');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /logout should log user out","suites":[],"updatePoint":{"line":281,"column":38},"line":281,"code":"test('POST /logout should log user out', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst response = await authAgent(owner).post('/logout');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual(LOGGED_OUT_RESPONSE_BODY);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":" should return 401 Unauthorized if no cookie","suites":[],"updatePoint":{"line":44,"column":59},"line":44,"code":"\ttest(`${route} should return 401 Unauthorized if no cookie`, async () => {\n\t\tconst response = await request(app)[method](endpoint).use(utils.prefix(REST_PATH_SEGMENT));\n\n\t\texpect(response.statusCode).toBe(401);\n\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":" should return 403 Forbidden for member","suites":[],"updatePoint":{"line":54,"column":54},"line":54,"code":"\ttest(`${route} should return 403 Forbidden for member`, async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst response = await authAgent(member)[method](endpoint);\n\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"user-management:reset should reset DB to default user state","suites":[],"updatePoint":{"line":29,"column":65},"line":29,"code":"test('user-management:reset should reset DB to default user state', async () => {\n\tawait testDb.createUser({ globalRole: globalOwnerRole });\n\n\tawait Reset.run();\n\n\tconst user = await Db.collections.User.findOne({ globalRole: globalOwnerRole });\n\n\tif (!user) {\n\t\tfail('No owner found after DB reset to default user state');\n\t}\n\n\texpect(user.email).toBeNull();\n\texpect(user.firstName).toBeNull();\n\texpect(user.lastName).toBeNull();\n\texpect(user.password).toBeNull();\n\texpect(user.resetPasswordToken).toBeNull();\n\texpect(user.resetPasswordTokenExpiration).toBeNull();\n\texpect(user.personalizationAnswers).toBeNull();\n});","file":"integration/commands/reset.cmd.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"router should switch based on flag","suites":[],"updatePoint":{"line":62,"column":40},"line":62,"code":"test('router should switch based on flag', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t// free router\n\tsharingSpy.mockReturnValueOnce(false);\n\n\tconst freeShareResponse = authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\tconst freeGetResponse = authAgent(owner).get(`/credentials/${savedCredential.id}`).send();\n\n\tconst [{ statusCode: freeShareStatus }, { statusCode: freeGetStatus }] = await Promise.all([\n\t\tfreeShareResponse,\n\t\tfreeGetResponse,\n\t]);\n\n\texpect(freeShareStatus).toBe(404);\n\texpect(freeGetStatus).toBe(200);\n\n\t// EE router\n\n\tconst eeShareResponse = authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\tconst eeGetResponse = authAgent(owner).get(`/credentials/${savedCredential.id}`).send();\n\n\tconst [{ statusCode: eeShareStatus }, { statusCode: eeGetStatus }] = await Promise.all([\n\t\teeShareResponse,\n\t\teeGetResponse,\n\t]);\n\n\texpect(eeShareStatus).toBe(200);\n\texpect(eeGetStatus).toBe(200);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should return all creds for owner","suites":[],"updatePoint":{"line":105,"column":56},"line":105,"code":"test('GET /credentials should return all creds for owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\tawait saveCredential(randomCredentialPayload(), { user: member1 });\n\n\tconst sharedWith = [member1, member2, member3];\n\tawait testDb.shareCredentialWithUsers(savedCredential, sharedWith);\n\n\tconst response = await authAgent(owner).get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data).toHaveLength(2); // owner retrieved owner cred and member cred\n\n\tconst [ownerCredential, memberCredential] = response.body.data as CredentialWithSharings[];\n\n\tvalidateMainCredentialData(ownerCredential);\n\texpect(ownerCredential.data).toBeUndefined();\n\n\tvalidateMainCredentialData(memberCredential);\n\texpect(memberCredential.data).toBeUndefined();\n\n\texpect(ownerCredential.ownedBy).toMatchObject({\n\t\tid: owner.id,\n\t\temail: owner.email,\n\t\tfirstName: owner.firstName,\n\t\tlastName: owner.lastName,\n\t});\n\n\texpect(Array.isArray(ownerCredential.sharedWith)).toBe(true);\n\texpect(ownerCredential.sharedWith).toHaveLength(3);\n\n\t// Fix order issue (MySQL might return items in any order)\n\tconst ownerCredentialsSharedWithOrdered = [...ownerCredential.sharedWith!].sort(\n\t\t(a: IUser, b: IUser) => (a.email < b.email ? -1 : 1),\n\t);\n\tconst orderedSharedWith = [...sharedWith].sort((a, b) => (a.email < b.email ? -1 : 1));\n\n\townerCredentialsSharedWithOrdered.forEach((sharee: IUser, idx: number) => {\n\t\texpect(sharee).toMatchObject({\n\t\t\tid: orderedSharedWith[idx].id,\n\t\t\temail: orderedSharedWith[idx].email,\n\t\t\tfirstName: orderedSharedWith[idx].firstName,\n\t\t\tlastName: orderedSharedWith[idx].lastName,\n\t\t});\n\t});\n\n\texpect(memberCredential.ownedBy).toMatchObject({\n\t\tid: member1.id,\n\t\temail: member1.email,\n\t\tfirstName: member1.firstName,\n\t\tlastName: member1.lastName,\n\t});\n\n\texpect(Array.isArray(memberCredential.sharedWith)).toBe(true);\n\texpect(memberCredential.sharedWith).toHaveLength(0);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should return only relevant creds for member","suites":[],"updatePoint":{"line":166,"column":67},"line":166,"code":"test('GET /credentials should return only relevant creds for member', async () => {\n\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tawait saveCredential(randomCredentialPayload(), { user: member2 });\n\tconst savedMemberCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\n\tawait testDb.shareCredentialWithUsers(savedMemberCredential, [member2]);\n\n\tconst response = await authAgent(member1).get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data).toHaveLength(1); // member retrieved only member cred\n\n\tconst [member1Credential] = response.body.data;\n\n\tvalidateMainCredentialData(member1Credential);\n\texpect(member1Credential.data).toBeUndefined();\n\n\texpect(member1Credential.ownedBy).toMatchObject({\n\t\tid: member1.id,\n\t\temail: member1.email,\n\t\tfirstName: member1.firstName,\n\t\tlastName: member1.lastName,\n\t});\n\n\texpect(Array.isArray(member1Credential.sharedWith)).toBe(true);\n\texpect(member1Credential.sharedWith).toHaveLength(1);\n\n\tconst [sharee] = member1Credential.sharedWith;\n\n\texpect(sharee).toMatchObject({\n\t\tid: member2.id,\n\t\temail: member2.email,\n\t\tfirstName: member2.firstName,\n\t\tlastName: member2.lastName,\n\t});\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for owner","suites":[],"updatePoint":{"line":210,"column":63},"line":210,"code":"test('GET /credentials/:id should retrieve owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst firstResponse = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\tconst { data: firstCredential } = firstResponse.body;\n\tvalidateMainCredentialData(firstCredential);\n\texpect(firstCredential.data).toBeUndefined();\n\texpect(firstCredential.ownedBy).toMatchObject({\n\t\tid: ownerShell.id,\n\t\temail: ownerShell.email,\n\t\tfirstName: ownerShell.firstName,\n\t\tlastName: ownerShell.lastName,\n\t});\n\texpect(firstCredential.sharedWith).toHaveLength(0);\n\n\tconst secondResponse = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(secondResponse.statusCode).toBe(200);\n\n\tconst { data: secondCredential } = secondResponse.body;\n\tvalidateMainCredentialData(secondCredential);\n\texpect(secondCredential.data).toBeDefined();\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve non-owned cred for owner","suites":[],"updatePoint":{"line":241,"column":67},"line":241,"code":"test('GET /credentials/:id should retrieve non-owned cred for owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(owner);\n\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\tawait testDb.shareCredentialWithUsers(savedCredential, [member2]);\n\n\tconst response1 = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(response1.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(response1.body.data);\n\texpect(response1.body.data.data).toBeUndefined();\n\texpect(response1.body.data.ownedBy).toMatchObject({\n\t\tid: member1.id,\n\t\temail: member1.email,\n\t\tfirstName: member1.firstName,\n\t\tlastName: member1.lastName,\n\t});\n\texpect(response1.body.data.sharedWith).toHaveLength(1);\n\texpect(response1.body.data.sharedWith[0]).toMatchObject({\n\t\tid: member2.id,\n\t\temail: member2.email,\n\t\tfirstName: member2.firstName,\n\t\tlastName: member2.lastName,\n\t});\n\n\tconst response2 = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(response2.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(response2.body.data);\n\texpect(response2.body.data.data).toBeUndefined();\n\texpect(response2.body.data.sharedWith).toHaveLength(1);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for member","suites":[],"updatePoint":{"line":282,"column":64},"line":282,"code":"test('GET /credentials/:id should retrieve owned cred for member', async () => {\n\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\tconst authMemberAgent = authAgent(member1);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\tawait testDb.shareCredentialWithUsers(savedCredential, [member2, member3]);\n\n\tconst firstResponse = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\tconst { data: firstCredential } = firstResponse.body;\n\tvalidateMainCredentialData(firstCredential);\n\texpect(firstCredential.data).toBeUndefined();\n\texpect(firstCredential.ownedBy).toMatchObject({\n\t\tid: member1.id,\n\t\temail: member1.email,\n\t\tfirstName: member1.firstName,\n\t\tlastName: member1.lastName,\n\t});\n\texpect(firstCredential.sharedWith).toHaveLength(2);\n\tfirstCredential.sharedWith.forEach((sharee: IUser, idx: number) => {\n\t\texpect([member2.id, member3.id]).toContain(sharee.id);\n\t});\n\n\tconst secondResponse = await authMemberAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(secondResponse.statusCode).toBe(200);\n\n\tconst { data: secondCredential } = secondResponse.body;\n\tvalidateMainCredentialData(secondCredential);\n\texpect(secondCredential.data).toBeDefined();\n\texpect(firstCredential.sharedWith).toHaveLength(2);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should not retrieve non-owned cred for member","suites":[],"updatePoint":{"line":320,"column":72},"line":320,"code":"test('GET /credentials/:id should not retrieve non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst response = await authAgent(member).get(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(403);\n\texpect(response.body.data).toBeUndefined(); // owner's cred not returned\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should fail with missing encryption key","suites":[],"updatePoint":{"line":331,"column":66},"line":331,"code":"test('GET /credentials/:id should fail with missing encryption key', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tconst response = await authAgent(ownerShell)\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should return 404 if cred not found","suites":[],"updatePoint":{"line":347,"column":62},"line":347,"code":"test('GET /credentials/:id should return 404 if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).get('/credentials/789');\n\texpect(response.statusCode).toBe(404);\n\n\tconst responseAbc = await authAgent(ownerShell).get('/credentials/abc');\n\texpect(responseAbc.statusCode).toBe(400);\n\n\t// because EE router has precedence, check if forwards this route\n\tconst responseNew = await authAgent(ownerShell).get('/credentials/new');\n\texpect(responseNew.statusCode).toBe(200);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should share the credential with the provided userIds and unshare it for missing ones","suites":[],"updatePoint":{"line":365,"column":118},"line":365,"code":"test('PUT /credentials/:id/share should share the credential with the provided userIds and unshare it for missing ones', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst [member1, member2, member3, member4, member5] = await testDb.createManyUsers(5, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\tconst shareWithIds = [member1.id, member2.id, member3.id];\n\n\tawait testDb.shareCredentialWithUsers(savedCredential, [member4, member5]);\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds });\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data).toBeUndefined();\n\n\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\trelations: ['role'],\n\t\twhere: { credentials: savedCredential },\n\t});\n\n\t// check that sharings have been removed/added correctly\n\texpect(sharedCredentials.length).toBe(shareWithIds.length + 1); // +1 for the owner\n\n\tsharedCredentials.forEach((sharedCredential) => {\n\t\tif (sharedCredential.userId === owner.id) {\n\t\t\texpect(sharedCredential.role.name).toBe('owner');\n\t\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t\t\treturn;\n\t\t}\n\t\texpect(shareWithIds).toContain(sharedCredential.userId);\n\t\texpect(sharedCredential.role.name).toBe('user');\n\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t});\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should share the credential with the provided userIds","suites":[],"updatePoint":{"line":407,"column":86},"line":407,"code":"test('PUT /credentials/:id/share should share the credential with the provided userIds', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst [member1, member2, member3] = await testDb.createManyUsers(3, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\tconst memberIds = [member1.id, member2.id, member3.id];\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: memberIds });\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data).toBeUndefined();\n\n\t// check that sharings got correctly set in DB\n\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\trelations: ['role'],\n\t\twhere: { credentials: savedCredential, user: { id: In([...memberIds]) } },\n\t});\n\n\texpect(sharedCredentials.length).toBe(memberIds.length);\n\n\tsharedCredentials.forEach((sharedCredential) => {\n\t\texpect(sharedCredential.role.name).toBe('user');\n\t\texpect(sharedCredential.role.scope).toBe('credential');\n\t});\n\n\t// check that owner still exists\n\tconst ownerSharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['role'],\n\t\twhere: { credentials: savedCredential, user: owner },\n\t});\n\n\texpect(ownerSharedCredential.role.name).toBe('owner');\n\texpect(ownerSharedCredential.role.scope).toBe('credential');\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should respond 403 for non-existing credentials","suites":[],"updatePoint":{"line":445,"column":80},"line":445,"code":"test('PUT /credentials/:id/share should respond 403 for non-existing credentials', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/1234567/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\texpect(response.statusCode).toBe(403);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should respond 403 for non-owned credentials","suites":[],"updatePoint":{"line":456,"column":77},"line":456,"code":"test('PUT /credentials/:id/share should respond 403 for non-owned credentials', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\texpect(response.statusCode).toBe(403);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should ignore pending sharee","suites":[],"updatePoint":{"line":468,"column":61},"line":468,"code":"test('PUT /credentials/:id/share should ignore pending sharee', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: [memberShell.id] });\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\twhere: { credentials: savedCredential },\n\t});\n\n\texpect(sharedCredentials).toHaveLength(1);\n\texpect(sharedCredentials[0].userId).toBe(owner.id);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should ignore non-existing sharee","suites":[],"updatePoint":{"line":487,"column":66},"line":487,"code":"test('PUT /credentials/:id/share should ignore non-existing sharee', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: ['bce38a11-5e45-4d1c-a9ee-36e4a20ab0fc'] });\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\twhere: { credentials: savedCredential },\n\t});\n\n\texpect(sharedCredentials).toHaveLength(1);\n\texpect(sharedCredentials[0].userId).toBe(owner.id);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should respond 400 if invalid payload is provided","suites":[],"updatePoint":{"line":505,"column":82},"line":505,"code":"test('PUT /credentials/:id/share should respond 400 if invalid payload is provided', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst responses = await Promise.all([\n\t\tauthAgent(owner).put(`/credentials/${savedCredential.id}/share`).send(),\n\t\tauthAgent(owner)\n\t\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t\t.send({ shareWithIds: [1] }),\n\t]);\n\n\tresponses.forEach((response) => expect(response.statusCode).toBe(400));\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /credentials/:id/share should unshare the credential","suites":[],"updatePoint":{"line":523,"column":62},"line":523,"code":"test('PUT /credentials/:id/share should unshare the credential', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tawait testDb.shareCredentialWithUsers(savedCredential, [member1, member2]);\n\n\tconst response = await authAgent(owner)\n\t\t.put(`/credentials/${savedCredential.id}/share`)\n\t\t.send({ shareWithIds: [] });\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst sharedCredentials = await Db.collections.SharedCredentials.find({\n\t\twhere: { credentials: savedCredential },\n\t});\n\n\texpect(sharedCredentials).toHaveLength(1);\n\texpect(sharedCredentials[0].userId).toBe(owner.id);\n});","file":"integration/credentials.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should return all creds for owner","suites":[],"updatePoint":{"line":64,"column":56},"line":64,"code":"test('GET /credentials should return all creds for owner', async () => {\n\tconst [owner, member] = await Promise.all([\n\t\ttestDb.createUser({ globalRole: globalOwnerRole }),\n\t\ttestDb.createUser({ globalRole: globalMemberRole }),\n\t]);\n\n\tconst [{ id: savedOwnerCredentialId }, { id: savedMemberCredentialId }] = await Promise.all([\n\t\tsaveCredential(randomCredentialPayload(), { user: owner }),\n\t\tsaveCredential(randomCredentialPayload(), { user: member }),\n\t]);\n\n\tconst response = await authAgent(owner).get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(2); // owner retrieved owner cred and member cred\n\n\tconst savedCredentialsIds = [savedOwnerCredentialId, savedMemberCredentialId];\n\tresponse.body.data.forEach((credential: CredentialsEntity) => {\n\t\tvalidateMainCredentialData(credential);\n\t\texpect(credential.data).toBeUndefined();\n\t\texpect(savedCredentialsIds.includes(Number(credential.id))).toBe(true);\n\t});\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should return only own creds for member","suites":[],"updatePoint":{"line":88,"column":62},"line":88,"code":"test('GET /credentials should return only own creds for member', async () => {\n\tconst [member1, member2] = await testDb.createManyUsers(2, {\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconst [savedCredential1] = await Promise.all([\n\t\tsaveCredential(randomCredentialPayload(), { user: member1 }),\n\t\tsaveCredential(randomCredentialPayload(), { user: member2 }),\n\t]);\n\n\tconst response = await authAgent(member1).get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1); // member retrieved only own cred\n\n\tconst [member1Credential] = response.body.data;\n\n\tvalidateMainCredentialData(member1Credential);\n\texpect(member1Credential.data).toBeUndefined();\n\texpect(member1Credential.id).toBe(savedCredential1.id.toString());\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should create cred","suites":[],"updatePoint":{"line":110,"column":42},"line":110,"code":"test('POST /credentials should create cred', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst payload = randomCredentialPayload();\n\n\tconst response = await authAgent(ownerShell).post('/credentials').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(payload.name);\n\texpect(type).toBe(payload.type);\n\tif (!payload.nodesAccess) {\n\t\tfail('Payload did not contain a nodesAccess array');\n\t}\n\texpect(nodesAccess[0].nodeType).toBe(payload.nodesAccess[0].nodeType);\n\texpect(encryptedData).not.toBe(payload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(payload.name);\n\texpect(credential.type).toBe(payload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(payload.nodesAccess![0].nodeType);\n\texpect(credential.data).not.toBe(payload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['user', 'credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.user.id).toBe(ownerShell.id);\n\texpect(sharedCredential.credentials.name).toBe(payload.name);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with invalid inputs","suites":[],"updatePoint":{"line":145,"column":55},"line":145,"code":"test('POST /credentials should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\n\tawait Promise.all(\n\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/credentials').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with missing encryption key","suites":[],"updatePoint":{"line":157,"column":63},"line":157,"code":"test('POST /credentials should fail with missing encryption key', async () => {\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).post('/credentials').send(randomCredentialPayload());\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should ignore ID in payload","suites":[],"updatePoint":{"line":170,"column":51},"line":170,"code":"test('POST /credentials should ignore ID in payload', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\n\tconst firstResponse = await authOwnerAgent\n\t\t.post('/credentials')\n\t\t.send({ id: '8', ...randomCredentialPayload() });\n\n\texpect(firstResponse.body.data.id).not.toBe('8');\n\n\tconst secondResponse = await authOwnerAgent\n\t\t.post('/credentials')\n\t\t.send({ id: 8, ...randomCredentialPayload() });\n\n\texpect(secondResponse.body.data.id).not.toBe(8);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for owner","suites":[],"updatePoint":{"line":187,"column":64},"line":187,"code":"test('DELETE /credentials/:id should delete owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst response = await authAgent(ownerShell).delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete non-owned cred for owner","suites":[],"updatePoint":{"line":205,"column":68},"line":205,"code":"test('DELETE /credentials/:id should delete non-owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\tconst response = await authAgent(ownerShell).delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for member","suites":[],"updatePoint":{"line":224,"column":65},"line":224,"code":"test('DELETE /credentials/:id should delete owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\tconst response = await authAgent(member).delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should not delete non-owned cred for member","suites":[],"updatePoint":{"line":242,"column":73},"line":242,"code":"test('DELETE /credentials/:id should not delete non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst response = await authAgent(member).delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(404);\n\n\tconst shellCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(shellCredential).toBeDefined(); // not deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeDefined(); // not deleted\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should fail if cred not found","suites":[],"updatePoint":{"line":260,"column":59},"line":260,"code":"test('DELETE /credentials/:id should fail if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).delete('/credentials/123');\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update owned cred for owner","suites":[],"updatePoint":{"line":268,"column":63},"line":268,"code":"test('PATCH /credentials/:id should update owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\tconst patchPayload = randomCredentialPayload();\n\n\tconst response = await authAgent(ownerShell)\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\tif (!patchPayload.nodesAccess) {\n\t\tfail('Payload did not contain a nodesAccess array');\n\t}\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess![0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update non-owned cred for owner","suites":[],"updatePoint":{"line":305,"column":67},"line":305,"code":"test('PATCH /credentials/:id should update non-owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\tconst patchPayload = randomCredentialPayload();\n\n\tconst response = await authAgent(ownerShell)\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\n\tif (!patchPayload.nodesAccess) {\n\t\tfail('Payload did not contain a nodesAccess array');\n\t}\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess![0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update owned cred for member","suites":[],"updatePoint":{"line":344,"column":64},"line":344,"code":"test('PATCH /credentials/:id should update owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\tconst patchPayload = randomCredentialPayload();\n\n\tconst response = await authAgent(member)\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\n\tif (!patchPayload.nodesAccess) {\n\t\tfail('Payload did not contain a nodesAccess array');\n\t}\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess![0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should not update non-owned cred for member","suites":[],"updatePoint":{"line":382,"column":72},"line":382,"code":"test('PATCH /credentials/:id should not update non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\tconst patchPayload = randomCredentialPayload();\n\n\tconst response = await authAgent(member)\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(404);\n\n\tconst shellCredential = await Db.collections.Credentials.findOneOrFail(savedCredential.id);\n\n\texpect(shellCredential.name).not.toBe(patchPayload.name); // not updated\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail with invalid inputs","suites":[],"updatePoint":{"line":399,"column":60},"line":399,"code":"test('PATCH /credentials/:id should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tawait Promise.all(\n\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent\n\t\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t\t.send(invalidPayload);\n\n\t\t\tif (response.statusCode === 500) {\n\t\t\t\tconsole.log(response.statusCode, response.body);\n\t\t\t}\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail if cred not found","suites":[],"updatePoint":{"line":418,"column":58},"line":418,"code":"test('PATCH /credentials/:id should fail if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell)\n\t\t.patch('/credentials/123')\n\t\t.send(randomCredentialPayload());\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail with missing encryption key","suites":[],"updatePoint":{"line":428,"column":68},"line":428,"code":"test('PATCH /credentials/:id should fail with missing encryption key', async () => {\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).post('/credentials').send(randomCredentialPayload());\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/new should return default name for new credential or its increment","suites":[],"updatePoint":{"line":441,"column":89},"line":441,"code":"test('GET /credentials/new should return default name for new credential or its increment', async () => {\n\tconst ownerShell = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(ownerShell);\n\tconst name = config.getEnv('credentials.defaultName');\n\tlet tempName = name;\n\n\tfor (let i = 0; i < 4; i++) {\n\t\tconst response = await authOwnerAgent.get(`/credentials/new?name=${name}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\tif (i === 0) {\n\t\t\texpect(response.body.data.name).toBe(name);\n\t\t} else {\n\t\t\ttempName = name + ' ' + (i + 1);\n\t\t\texpect(response.body.data.name).toBe(tempName);\n\t\t}\n\t\tawait saveCredential({ ...randomCredentialPayload(), name: tempName }, { user: ownerShell });\n\t}\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/new should return name from query for new credential or its increment","suites":[],"updatePoint":{"line":461,"column":92},"line":461,"code":"test('GET /credentials/new should return name from query for new credential or its increment', async () => {\n\tconst ownerShell = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(ownerShell);\n\tconst name = 'special credential name';\n\tlet tempName = name;\n\n\tfor (let i = 0; i < 4; i++) {\n\t\tconst response = await authOwnerAgent.get(`/credentials/new?name=${name}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\tif (i === 0) {\n\t\t\texpect(response.body.data.name).toBe(name);\n\t\t} else {\n\t\t\ttempName = name + ' ' + (i + 1);\n\t\t\texpect(response.body.data.name).toBe(tempName);\n\t\t}\n\t\tawait saveCredential({ ...randomCredentialPayload(), name: tempName }, { user: ownerShell });\n\t}\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for owner","suites":[],"updatePoint":{"line":481,"column":63},"line":481,"code":"test('GET /credentials/:id should retrieve owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst firstResponse = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(firstResponse.body.data);\n\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\tconst secondResponse = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\tvalidateMainCredentialData(secondResponse.body.data);\n\texpect(secondResponse.body.data.data).toBeDefined();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for member","suites":[],"updatePoint":{"line":501,"column":64},"line":501,"code":"test('GET /credentials/:id should retrieve owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = authAgent(member);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\tconst firstResponse = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(firstResponse.body.data);\n\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\tconst secondResponse = await authMemberAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(secondResponse.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(secondResponse.body.data);\n\texpect(secondResponse.body.data.data).toBeDefined();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve non-owned cred for owner","suites":[],"updatePoint":{"line":523,"column":67},"line":523,"code":"test('GET /credentials/:id should retrieve non-owned cred for owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(owner);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\tconst response1 = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(response1.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(response1.body.data);\n\texpect(response1.body.data.data).toBeUndefined();\n\n\tconst response2 = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(response2.statusCode).toBe(200);\n\n\tvalidateMainCredentialData(response2.body.data);\n\texpect(response2.body.data.data).toBeDefined();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should not retrieve non-owned cred for member","suites":[],"updatePoint":{"line":547,"column":72},"line":547,"code":"test('GET /credentials/:id should not retrieve non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst response = await authAgent(member).get(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(404);\n\texpect(response.body.data).toBeUndefined(); // owner's cred not returned\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should fail with missing encryption key","suites":[],"updatePoint":{"line":558,"column":66},"line":558,"code":"test('GET /credentials/:id should fail with missing encryption key', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: ownerShell });\n\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tconst response = await authAgent(ownerShell)\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should return 404 if cred not found","suites":[],"updatePoint":{"line":574,"column":62},"line":574,"code":"test('GET /credentials/:id should return 404 if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).get('/credentials/789');\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should return 400 if id is not a number","suites":[],"updatePoint":{"line":581,"column":66},"line":581,"code":"test('GET /credentials/:id should return 400 if id is not a number', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst responseAbc = await authAgent(ownerShell).get('/credentials/abc');\n\texpect(responseAbc.statusCode).toBe(400);\n});","file":"integration/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized owner shell","suites":["Owner shell"],"updatePoint":{"line":51,"column":50},"line":51,"code":"\ttest('GET /me should return sanitized owner shell', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\t\tconst response = await authAgent(ownerShell).get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t\tapiKey,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBeNull();\n\t\texpect(firstName).toBeNull();\n\t\texpect(lastName).toBeNull();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(true);\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":84,"column":49},"line":84,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = authAgent(ownerShell);\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedOwnerShell.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwnerShell.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwnerShell.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Owner shell"],"updatePoint":{"line":126,"column":48},"line":126,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = authAgent(ownerShell);\n\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail();\n\t\t\texpect(storedOwnerShell.email).toBeNull();\n\t\t\texpect(storedOwnerShell.firstName).toBeNull();\n\t\t\texpect(storedOwnerShell.lastName).toBeNull();\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail for shell","suites":["Owner shell"],"updatePoint":{"line":141,"column":47},"line":141,"code":"\ttest('PATCH /me/password should fail for shell', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = authAgent(ownerShell);\n\n\t\tconst validPasswordPayload = {\n\t\t\tcurrentPassword: randomValidPassword(),\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst validPayloads = [validPasswordPayload, ...INVALID_PASSWORD_PAYLOADS];\n\n\t\tawait Promise.all(\n\t\t\tvalidPayloads.map(async (payload) => {\n\t\t\t\tconst response = await authOwnerShellAgent.patch('/me/password').send(payload);\n\t\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\n\t\t\t\tif (payload.newPassword) {\n\t\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t\t}\n\n\t\t\t\tif (payload.currentPassword) {\n\t\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail();\n\t\texpect(storedOwnerShell.password).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":173,"column":55},"line":173,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = authAgent(ownerShell);\n\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authOwnerShellAgent.post('/me/survey').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: IsNull() },\n\t\t\t});\n\n\t\t\texpect(storedShellOwner.personalizationAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/api-key should create an api key","suites":["Owner shell"],"updatePoint":{"line":193,"column":48},"line":193,"code":"\ttest('POST /me/api-key should create an api key', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\t\tconst response = await authAgent(ownerShell).post('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toBeDefined();\n\t\texpect(response.body.data.apiKey).not.toBeNull();\n\n\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\twhere: { email: IsNull() },\n\t\t});\n\n\t\texpect(storedShellOwner.apiKey).toEqual(response.body.data.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me/api-key should fetch the api key","suites":["Owner shell"],"updatePoint":{"line":209,"column":47},"line":209,"code":"\ttest('GET /me/api-key should fetch the api key', async () => {\n\t\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\townerShell = await testDb.addApiKey(ownerShell);\n\n\t\tconst response = await authAgent(ownerShell).get('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toEqual(ownerShell.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /me/api-key should fetch the api key","suites":["Owner shell"],"updatePoint":{"line":219,"column":50},"line":219,"code":"\ttest('DELETE /me/api-key should fetch the api key', async () => {\n\t\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\townerShell = await testDb.addApiKey(ownerShell);\n\n\t\tconst response = await authAgent(ownerShell).delete('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\twhere: { email: IsNull() },\n\t\t});\n\n\t\texpect(storedShellOwner.apiKey).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized member","suites":["Member"],"updatePoint":{"line":249,"column":45},"line":249,"code":"\ttest('GET /me should return sanitized member', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst response = await authAgent(member).get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t\tapiKey,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(member.email);\n\t\texpect(firstName).toBe(member.firstName);\n\t\texpect(lastName).toBe(member.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole.name).toBe('member');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":282,"column":49},"line":282,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = authAgent(member);\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('member');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedMember.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedMember.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedMember.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":324,"column":48},"line":324,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = authAgent(member);\n\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\t\t\texpect(storedMember.email).toBe(member.email);\n\t\t\texpect(storedMember.firstName).toBe(member.firstName);\n\t\t\texpect(storedMember.lastName).toBe(member.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":339,"column":58},"line":339,"code":"\ttest('PATCH /me/password should succeed with valid inputs', async () => {\n\t\tconst memberPassword = randomValidPassword();\n\t\tconst member = await testDb.createUser({\n\t\t\tpassword: memberPassword,\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tconst validPayload = {\n\t\t\tcurrentPassword: memberPassword,\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await authAgent(member).patch('/me/password').send(validPayload);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\t\texpect(storedMember.password).not.toBe(member.password);\n\t\texpect(storedMember.password).not.toBe(validPayload.newPassword);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":360,"column":57},"line":360,"code":"\ttest('PATCH /me/password should fail with invalid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = authAgent(member);\n\n\t\tfor (const payload of INVALID_PASSWORD_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me/password').send(payload);\n\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\n\t\t\tif (payload.newPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t}\n\t\t\tif (payload.currentPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t}\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":379,"column":55},"line":379,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = authAgent(member);\n\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authMemberAgent.post('/me/survey').send(validPayload);\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst { personalizationAnswers: storedAnswers } = await Db.collections.User.findOneOrFail();\n\n\t\t\texpect(storedAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/api-key should create an api key","suites":["Member"],"updatePoint":{"line":396,"column":48},"line":396,"code":"\ttest('POST /me/api-key should create an api key', async () => {\n\t\tconst member = await testDb.createUser({\n\t\t\tglobalRole: globalMemberRole,\n\t\t\tapiKey: randomApiKey(),\n\t\t});\n\n\t\tconst response = await authAgent(member).post('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toBeDefined();\n\t\texpect(response.body.data.apiKey).not.toBeNull();\n\n\t\tconst storedMember = await Db.collections.User.findOneOrFail(member.id);\n\n\t\texpect(storedMember.apiKey).toEqual(response.body.data.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me/api-key should fetch the api key","suites":["Member"],"updatePoint":{"line":413,"column":47},"line":413,"code":"\ttest('GET /me/api-key should fetch the api key', async () => {\n\t\tconst member = await testDb.createUser({\n\t\t\tglobalRole: globalMemberRole,\n\t\t\tapiKey: randomApiKey(),\n\t\t});\n\n\t\tconst response = await authAgent(member).get('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.apiKey).toEqual(member.apiKey);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /me/api-key should fetch the api key","suites":["Member"],"updatePoint":{"line":425,"column":50},"line":425,"code":"\ttest('DELETE /me/api-key should fetch the api key', async () => {\n\t\tconst member = await testDb.createUser({\n\t\t\tglobalRole: globalMemberRole,\n\t\t\tapiKey: randomApiKey(),\n\t\t});\n\n\t\tconst response = await authAgent(member).delete('/me/api-key');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst storedMember = await Db.collections.User.findOneOrFail(member.id);\n\n\t\texpect(storedMember.apiKey).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized owner","suites":["Owner"],"updatePoint":{"line":450,"column":44},"line":450,"code":"\ttest('GET /me should return sanitized owner', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst response = await authAgent(owner).get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t\tapiKey,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(owner.email);\n\t\texpect(firstName).toBe(owner.firstName);\n\t\texpect(lastName).toBe(owner.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t\texpect(apiKey).toBeUndefined();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner"],"updatePoint":{"line":483,"column":49},"line":483,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = authAgent(owner);\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\t\t\texpect(apiKey).toBeUndefined();\n\n\t\t\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedOwner.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwner.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwner.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should respond 200 if no nodes are installed","suites":[],"updatePoint":{"line":83,"column":61},"line":83,"code":"test('GET /nodes should respond 200 if no nodes are installed', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { data },\n\t} = await authAgent(ownerShell).get('/nodes');\n\n\texpect(statusCode).toBe(200);\n\texpect(data).toHaveLength(0);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should return list of one installed package and node","suites":[],"updatePoint":{"line":95,"column":69},"line":95,"code":"test('GET /nodes should return list of one installed package and node', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { data },\n\t} = await authAgent(ownerShell).get('/nodes');\n\n\texpect(statusCode).toBe(200);\n\texpect(data).toHaveLength(1);\n\texpect(data[0].installedNodes).toHaveLength(1);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should return list of multiple installed packages and nodes","suites":[],"updatePoint":{"line":111,"column":76},"line":111,"code":"test('GET /nodes should return list of multiple installed packages and nodes', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst first = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(first.packageName));\n\n\tconst second = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(second.packageName));\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(second.packageName));\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { data },\n\t} = await authAgent(ownerShell).get('/nodes');\n\n\texpect(statusCode).toBe(200);\n\texpect(data).toHaveLength(2);\n\n\tconst allNodes = data.reduce(\n\t\t(acc: InstalledNodes[], cur: InstalledPackages) => acc.concat(cur.installedNodes),\n\t\t[],\n\t);\n\n\texpect(allNodes).toHaveLength(3);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should not check for updates if no packages installed","suites":[],"updatePoint":{"line":137,"column":70},"line":137,"code":"test('GET /nodes should not check for updates if no packages installed', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tawait authAgent(ownerShell).get('/nodes');\n\n\texpect(mocked(executeCommand)).toHaveBeenCalledTimes(0);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should check for updates if packages installed","suites":[],"updatePoint":{"line":145,"column":63},"line":145,"code":"test('GET /nodes should check for updates if packages installed', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\tawait authAgent(ownerShell).get('/nodes');\n\n\texpect(mocked(executeCommand)).toHaveBeenCalledWith('npm outdated --json', {\n\t\tdoNotHandleError: true,\n\t});\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /nodes should report package updates if available","suites":[],"updatePoint":{"line":158,"column":59},"line":158,"code":"test('GET /nodes should report package updates if available', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst { packageName } = await testDb.saveInstalledPackage(utils.installedPackagePayload());\n\tawait testDb.saveInstalledNode(utils.installedNodePayload(packageName));\n\n\tmocked(executeCommand).mockImplementationOnce(() => {\n\t\tthrow {\n\t\t\tcode: 1,\n\t\t\tstdout: JSON.stringify({\n\t\t\t\t[packageName]: {\n\t\t\t\t\tcurrent: COMMUNITY_PACKAGE_VERSION.CURRENT,\n\t\t\t\t\twanted: COMMUNITY_PACKAGE_VERSION.CURRENT,\n\t\t\t\t\tlatest: COMMUNITY_PACKAGE_VERSION.UPDATED,\n\t\t\t\t\tlocation: path.join('node_modules', packageName),\n\t\t\t\t},\n\t\t\t}),\n\t\t};\n\t});\n\n\tmocked(isNpmError).mockReturnValueOnce(true);\n\n\tconst {\n\t\tbody: { data },\n\t} = await authAgent(ownerShell).get('/nodes');\n\n\texpect(data[0].installedVersion).toBe(COMMUNITY_PACKAGE_VERSION.CURRENT);\n\texpect(data[0].updateAvailable).toBe(COMMUNITY_PACKAGE_VERSION.UPDATED);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /nodes should reject if package name is missing","suites":[],"updatePoint":{"line":192,"column":58},"line":192,"code":"test('POST /nodes should reject if package name is missing', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst { statusCode } = await authAgent(ownerShell).post('/nodes');\n\n\texpect(statusCode).toBe(400);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /nodes should reject if package is duplicate","suites":[],"updatePoint":{"line":200,"column":55},"line":200,"code":"test('POST /nodes should reject if package is duplicate', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tmocked(findInstalledPackage).mockResolvedValueOnce(new InstalledPackages());\n\tmocked(isPackageInstalled).mockResolvedValueOnce(true);\n\tmocked(hasPackageLoaded).mockReturnValueOnce(true);\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { message },\n\t} = await authAgent(ownerShell).post('/nodes').send({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(400);\n\texpect(message).toContain('already installed');\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /nodes should allow installing packages that could not be loaded","suites":[],"updatePoint":{"line":218,"column":75},"line":218,"code":"test('POST /nodes should allow installing packages that could not be loaded', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tmocked(findInstalledPackage).mockResolvedValueOnce(new InstalledPackages());\n\tmocked(hasPackageLoaded).mockReturnValueOnce(false);\n\tmocked(checkNpmPackageStatus).mockResolvedValueOnce({ status: 'OK' });\n\n\tjest.spyOn(LoadNodesAndCredentials(), 'loadNpmModule').mockImplementationOnce(mockedEmptyPackage);\n\n\tconst { statusCode } = await authAgent(ownerShell).post('/nodes').send({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(200);\n\texpect(mocked(removePackageFromMissingList)).toHaveBeenCalled();\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /nodes should not install a banned package","suites":[],"updatePoint":{"line":235,"column":53},"line":235,"code":"test('POST /nodes should not install a banned package', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tmocked(checkNpmPackageStatus).mockResolvedValueOnce({ status: 'Banned' });\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { message },\n\t} = await authAgent(ownerShell).post('/nodes').send({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(400);\n\texpect(message).toContain('banned');\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /nodes should not delete if package name is empty","suites":[],"updatePoint":{"line":254,"column":62},"line":254,"code":"test('DELETE /nodes should not delete if package name is empty', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).delete('/nodes');\n\n\texpect(response.statusCode).toBe(400);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /nodes should reject if package is not installed","suites":[],"updatePoint":{"line":262,"column":61},"line":262,"code":"test('DELETE /nodes should reject if package is not installed', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { message },\n\t} = await authAgent(ownerShell).delete('/nodes').query({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(400);\n\texpect(message).toContain('not installed');\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /nodes should uninstall package","suites":[],"updatePoint":{"line":276,"column":44},"line":276,"code":"test('DELETE /nodes should uninstall package', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst removeSpy = jest\n\t\t.spyOn(LoadNodesAndCredentials(), 'removeNpmModule')\n\t\t.mockImplementationOnce(jest.fn());\n\n\tmocked(findInstalledPackage).mockImplementationOnce(mockedEmptyPackage);\n\n\tconst { statusCode } = await authAgent(ownerShell).delete('/nodes').query({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(200);\n\texpect(removeSpy).toHaveBeenCalledTimes(1);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /nodes should reject if package name is empty","suites":[],"updatePoint":{"line":297,"column":57},"line":297,"code":"test('PATCH /nodes should reject if package name is empty', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).patch('/nodes');\n\n\texpect(response.statusCode).toBe(400);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /nodes reject if package is not installed","suites":[],"updatePoint":{"line":305,"column":53},"line":305,"code":"test('PATCH /nodes reject if package is not installed', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst {\n\t\tstatusCode,\n\t\tbody: { message },\n\t} = await authAgent(ownerShell).patch('/nodes').send({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(statusCode).toBe(400);\n\texpect(message).toContain('not installed');\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /nodes should update a package","suites":[],"updatePoint":{"line":319,"column":42},"line":319,"code":"test('PATCH /nodes should update a package', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst updateSpy = jest\n\t\t.spyOn(LoadNodesAndCredentials(), 'updateNpmModule')\n\t\t.mockImplementationOnce(mockedEmptyPackage);\n\n\tmocked(findInstalledPackage).mockImplementationOnce(mockedEmptyPackage);\n\n\tawait authAgent(ownerShell).patch('/nodes').send({\n\t\tname: utils.installedPackagePayload().packageName,\n\t});\n\n\texpect(updateSpy).toHaveBeenCalledTimes(1);\n});","file":"integration/nodes.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should create owner and enable isInstanceOwnerSetUp","suites":[],"updatePoint":{"line":49,"column":69},"line":49,"code":"test('POST /owner should create owner and enable isInstanceOwnerSetUp', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst newOwnerData = {\n\t\temail: randomEmail(),\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst response = await authAgent(ownerShell).post('/owner').send(newOwnerData);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tpassword,\n\t\tresetPasswordToken,\n\t\tisPending,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(newOwnerData.email);\n\texpect(firstName).toBe(newOwnerData.firstName);\n\texpect(lastName).toBe(newOwnerData.lastName);\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(isPending).toBe(false);\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\texpect(apiKey).toBeUndefined();\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\texpect(storedOwner.password).not.toBe(newOwnerData.password);\n\texpect(storedOwner.email).toBe(newOwnerData.email);\n\texpect(storedOwner.firstName).toBe(newOwnerData.firstName);\n\texpect(storedOwner.lastName).toBe(newOwnerData.lastName);\n\n\tconst isInstanceOwnerSetUpConfig = config.getEnv('userManagement.isInstanceOwnerSetUp');\n\texpect(isInstanceOwnerSetUpConfig).toBe(true);\n\n\tconst isInstanceOwnerSetUpSetting = await utils.isInstanceOwnerSetUp();\n\texpect(isInstanceOwnerSetUpSetting).toBe(true);\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should create owner with lowercased email","suites":[],"updatePoint":{"line":101,"column":59},"line":101,"code":"test('POST /owner should create owner with lowercased email', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst newOwnerData = {\n\t\temail: randomEmail().toUpperCase(),\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst response = await authAgent(ownerShell).post('/owner').send(newOwnerData);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, email } = response.body.data;\n\n\texpect(id).toBe(ownerShell.id);\n\texpect(email).toBe(newOwnerData.email.toLowerCase());\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\texpect(storedOwner.email).toBe(newOwnerData.email.toLowerCase());\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should fail with invalid inputs","suites":[],"updatePoint":{"line":124,"column":49},"line":124,"code":"test('POST /owner should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = authAgent(ownerShell);\n\n\tawait Promise.all(\n\t\tINVALID_POST_OWNER_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/owner').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner/skip-setup should persist skipping setup to the DB","suites":[],"updatePoint":{"line":136,"column":68},"line":136,"code":"test('POST /owner/skip-setup should persist skipping setup to the DB', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst response = await authAgent(ownerShell).post('/owner/skip-setup').send();\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst skipConfig = config.getEnv('userManagement.skipInstanceOwnerSetup');\n\texpect(skipConfig).toBe(true);\n\n\tconst { value } = await Db.collections.Settings.findOneOrFail({\n\t\tkey: 'userManagement.skipInstanceOwnerSetup',\n\t});\n\texpect(value).toBe('true');\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should send password reset email","suites":[],"updatePoint":{"line":50,"column":60},"line":50,"code":"test('POST /forgot-password should send password reset email', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\tconst member = await testDb.createUser({\n\t\temail: 'test@test.com',\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tawait Promise.all(\n\t\t[{ email: owner.email }, { email: member.email.toUpperCase() }].map(async (payload) => {\n\t\t\tconst response = await authlessAgent.post('/forgot-password').send(payload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual({});\n\n\t\t\tconst user = await Db.collections.User.findOneOrFail({ email: payload.email });\n\t\t\texpect(user.resetPasswordToken).toBeDefined();\n\t\t\texpect(user.resetPasswordTokenExpiration).toBeGreaterThan(Math.ceil(Date.now() / 1000));\n\t\t}),\n\t);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail if emailing is not set up","suites":[],"updatePoint":{"line":75,"column":65},"line":75,"code":"test('POST /forgot-password should fail if emailing is not set up', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post('/forgot-password').send({ email: owner.email });\n\n\texpect(response.statusCode).toBe(500);\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail({ email: owner.email });\n\texpect(storedOwner.resetPasswordToken).toBeNull();\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail with invalid inputs","suites":[],"updatePoint":{"line":88,"column":59},"line":88,"code":"test('POST /forgot-password should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst invalidPayloads = [\n\t\trandomEmail(),\n\t\t[randomEmail()],\n\t\t{},\n\t\t[{ name: randomName() }],\n\t\t[{ email: randomName() }],\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post('/forgot-password').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedOwner = await Db.collections.User.findOneOrFail({ email: owner.email });\n\t\t\texpect(storedOwner.resetPasswordToken).toBeNull();\n\t\t}),\n\t);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail if user is not found","suites":[],"updatePoint":{"line":114,"column":60},"line":114,"code":"test('POST /forgot-password should fail if user is not found', async () => {\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent.post('/forgot-password').send({ email: randomEmail() });\n\n\texpect(response.statusCode).toBe(200); // expect 200 to remain vague\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should succeed with valid inputs","suites":[],"updatePoint":{"line":124,"column":66},"line":124,"code":"test('GET /resolve-password-token should succeed with valid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\texpect(response.statusCode).toBe(200);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail with invalid inputs","suites":[],"updatePoint":{"line":144,"column":65},"line":144,"code":"test('GET /resolve-password-token should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst first = await authlessAgent.get('/resolve-password-token').query({ token: uuid() });\n\n\tconst second = await authlessAgent.get('/resolve-password-token').query({ userId: owner.id });\n\n\tfor (const response of [first, second]) {\n\t\texpect(response.statusCode).toBe(400);\n\t}\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail if user is not found","suites":[],"updatePoint":{"line":160,"column":66},"line":160,"code":"test('GET /resolve-password-token should fail if user is not found', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: uuid() });\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail if token is expired","suites":[],"updatePoint":{"line":174,"column":65},"line":174,"code":"test('GET /resolve-password-token should fail if token is expired', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) - 1;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should succeed with valid inputs","suites":[],"updatePoint":{"line":196,"column":60},"line":196,"code":"test('POST /change-password should succeed with valid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst passwordToStore = randomValidPassword();\n\n\tconst response = await authlessAgent.post('/change-password').send({\n\t\ttoken: resetPasswordToken,\n\t\tuserId: owner.id,\n\t\tpassword: passwordToStore,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n\n\tconst { password: storedPassword } = await Db.collections.User.findOneOrFail(owner.id);\n\n\tconst comparisonResult = await compare(passwordToStore, storedPassword);\n\texpect(comparisonResult).toBe(true);\n\texpect(storedPassword).not.toBe(passwordToStore);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should fail with invalid inputs","suites":[],"updatePoint":{"line":229,"column":59},"line":229,"code":"test('POST /change-password should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst invalidPayloads = [\n\t\t{ token: uuid() },\n\t\t{ id: owner.id },\n\t\t{ password: randomValidPassword() },\n\t\t{ token: uuid(), id: owner.id },\n\t\t{ token: uuid(), password: randomValidPassword() },\n\t\t{ id: owner.id, password: randomValidPassword() },\n\t\t{\n\t\t\tid: owner.id,\n\t\t\tpassword: randomInvalidPassword(),\n\t\t\ttoken: resetPasswordToken,\n\t\t},\n\t\t{\n\t\t\tid: owner.id,\n\t\t\tpassword: randomValidPassword(),\n\t\t\ttoken: uuid(),\n\t\t},\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post('/change-password').query(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst { password: storedPassword } = await Db.collections.User.findOneOrFail();\n\t\t\texpect(owner.password).toBe(storedPassword);\n\t\t}),\n\t);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should fail when token has expired","suites":[],"updatePoint":{"line":272,"column":62},"line":272,"code":"test('POST /change-password should fail when token has expired', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) - 1;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst passwordToStore = randomValidPassword();\n\n\tconst response = await authlessAgent.post('/change-password').send({\n\t\ttoken: resetPasswordToken,\n\t\tuserId: owner.id,\n\t\tpassword: passwordToStore,\n\t});\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should create credentials","suites":[],"updatePoint":{"line":52,"column":49},"line":52,"code":"test('POST /credentials should create credentials', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\tconst payload = {\n\t\tname: 'test credential',\n\t\ttype: 'githubApi',\n\t\tdata: {\n\t\t\taccessToken: 'abcdefghijklmnopqrstuvwxyz',\n\t\t\tuser: 'test',\n\t\t\tserver: 'testServer',\n\t\t},\n\t};\n\n\tconst response = await authOwnerAgent.post('/credentials').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type } = response.body;\n\n\texpect(name).toBe(payload.name);\n\texpect(type).toBe(payload.type);\n\n\tconst credential = await Db.collections.Credentials!.findOneOrFail(id);\n\n\texpect(credential.name).toBe(payload.name);\n\texpect(credential.type).toBe(payload.type);\n\texpect(credential.data).not.toBe(payload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials!.findOneOrFail({\n\t\trelations: ['user', 'credentials', 'role'],\n\t\twhere: { credentials: credential, user: ownerShell },\n\t});\n\n\texpect(sharedCredential.role).toEqual(credentialOwnerRole);\n\texpect(sharedCredential.credentials.name).toBe(payload.name);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with invalid inputs","suites":[],"updatePoint":{"line":96,"column":55},"line":96,"code":"test('POST /credentials should fail with invalid inputs', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tawait Promise.all(\n\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/credentials').send(invalidPayload);\n\t\t\texpect(response.statusCode === 400 || response.statusCode === 415).toBe(true);\n\t\t}),\n\t);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with missing encryption key","suites":[],"updatePoint":{"line":115,"column":63},"line":115,"code":"test('POST /credentials should fail with missing encryption key', async () => {\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst response = await authOwnerAgent.post('/credentials').send(credentialPayload());\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for owner","suites":[],"updatePoint":{"line":136,"column":64},"line":136,"code":"test('DELETE /credentials/:id should delete owned cred for owner', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst savedCredential = await saveCredential(dbCredential(), { user: ownerShell });\n\n\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { name, type } = response.body;\n\n\texpect(name).toBe(savedCredential.name);\n\texpect(type).toBe(savedCredential.type);\n\n\tconst deletedCredential = await Db.collections.Credentials!.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials!.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete non-owned cred for owner","suites":[],"updatePoint":{"line":167,"column":68},"line":167,"code":"test('DELETE /credentials/:id should delete non-owned cred for owner', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst savedCredential = await saveCredential(dbCredential(), { user: member });\n\n\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst deletedCredential = await Db.collections.Credentials!.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials!.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for member","suites":[],"updatePoint":{"line":195,"column":65},"line":195,"code":"test('DELETE /credentials/:id should delete owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authMemberAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: member,\n\t});\n\n\tconst savedCredential = await saveCredential(dbCredential(), { user: member });\n\n\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { name, type } = response.body;\n\n\texpect(name).toBe(savedCredential.name);\n\texpect(type).toBe(savedCredential.type);\n\n\tconst deletedCredential = await Db.collections.Credentials!.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials!.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for member but leave others untouched","suites":[],"updatePoint":{"line":225,"column":92},"line":225,"code":"test('DELETE /credentials/:id should delete owned cred for member but leave others untouched', async () => {\n\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst savedCredential = await saveCredential(dbCredential(), { user: member1 });\n\tconst notToBeChangedCredential = await saveCredential(dbCredential(), { user: member1 });\n\tconst notToBeChangedCredential2 = await saveCredential(dbCredential(), { user: member2 });\n\n\tconst authMemberAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: member1,\n\t});\n\n\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { name, type } = response.body;\n\n\texpect(name).toBe(savedCredential.name);\n\texpect(type).toBe(savedCredential.type);\n\n\tconst deletedCredential = await Db.collections.Credentials!.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials!.findOne({\n\t\twhere: {\n\t\t\tcredentials: savedCredential,\n\t\t},\n\t});\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n\n\tawait Promise.all(\n\t\t[notToBeChangedCredential, notToBeChangedCredential2].map(async (credential) => {\n\t\t\tconst untouchedCredential = await Db.collections.Credentials!.findOne(credential.id);\n\n\t\t\texpect(untouchedCredential).toEqual(credential); // not deleted\n\n\t\t\tconst untouchedSharedCredential = await Db.collections.SharedCredentials!.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tcredentials: credential,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\texpect(untouchedSharedCredential).toBeDefined(); // not deleted\n\t\t}),\n\t);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should not delete non-owned cred for member","suites":[],"updatePoint":{"line":278,"column":73},"line":278,"code":"test('DELETE /credentials/:id should not delete non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authMemberAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: member,\n\t});\n\tconst savedCredential = await saveCredential(dbCredential(), { user: ownerShell });\n\n\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(404);\n\n\tconst shellCredential = await Db.collections.Credentials!.findOne(savedCredential.id);\n\n\texpect(shellCredential).toBeDefined(); // not deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials!.findOne();\n\n\texpect(deletedSharedCredential).toBeDefined(); // not deleted\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should fail if cred not found","suites":[],"updatePoint":{"line":303,"column":59},"line":303,"code":"test('DELETE /credentials/:id should fail if cred not found', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst response = await authOwnerAgent.delete('/credentials/123');\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/schema/:credentialType should fail due to not found type","suites":[],"updatePoint":{"line":319,"column":79},"line":319,"code":"test('GET /credentials/schema/:credentialType should fail due to not found type', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst response = await authOwnerAgent.get('/credentials/schema/testing');\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/schema/:credentialType should retrieve credential type","suites":[],"updatePoint":{"line":335,"column":77},"line":335,"code":"test('GET /credentials/schema/:credentialType should retrieve credential type', async () => {\n\tlet ownerShell = await testDb.createUserShell(globalOwnerRole);\n\townerShell = await testDb.addApiKey(ownerShell);\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tversion: 1,\n\t\tauth: true,\n\t\tuser: ownerShell,\n\t});\n\n\tconst response = await authOwnerAgent.get('/credentials/schema/githubApi');\n\n\tconst { additionalProperties, type, properties, required } = response.body;\n\n\texpect(additionalProperties).toBe(false);\n\texpect(type).toBe('object');\n\texpect(properties.server).toBeDefined();\n\texpect(properties.server.type).toBe('string');\n\texpect(properties.user.type).toBeDefined();\n\texpect(properties.user.type).toBe('string');\n\texpect(properties.accessToken.type).toBeDefined();\n\texpect(properties.accessToken.type).toBe('string');\n\texpect(required).toEqual(expect.arrayContaining(['server', 'user', 'accessToken']));\n\texpect(response.statusCode).toBe(200);\n});","file":"integration/publicApi/credentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions/:id should fail due to missing API Key","suites":[],"updatePoint":{"line":60,"column":60},"line":60,"code":"test('GET /executions/:id should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/executions/1');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions/:id should fail due to invalid API Key","suites":[],"updatePoint":{"line":75,"column":60},"line":75,"code":"test('GET /executions/:id should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/executions/1');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions/:id should get an execution","suites":[],"updatePoint":{"line":91,"column":49},"line":91,"code":"test('GET /executions/:id should get an execution', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\tconst response = await authOwnerAgent.get(`/executions/${execution.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\tfinished,\n\t\tmode,\n\t\tretryOf,\n\t\tretrySuccessId,\n\t\tstartedAt,\n\t\tstoppedAt,\n\t\tworkflowId,\n\t\twaitTill,\n\t} = response.body;\n\n\texpect(id).toBeDefined();\n\texpect(finished).toBe(true);\n\texpect(mode).toEqual(execution.mode);\n\texpect(retrySuccessId).toBeNull();\n\texpect(retryOf).toBeNull();\n\texpect(startedAt).not.toBeNull();\n\texpect(stoppedAt).not.toBeNull();\n\texpect(workflowId).toBe(execution.workflowId);\n\texpect(waitTill).toBeNull();\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /executions/:id should fail due to missing API Key","suites":[],"updatePoint":{"line":132,"column":63},"line":132,"code":"test('DELETE /executions/:id should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.delete('/executions/1');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /executions/:id should fail due to invalid API Key","suites":[],"updatePoint":{"line":147,"column":63},"line":147,"code":"test('DELETE /executions/:id should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.delete('/executions/1');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /executions/:id should delete an execution","suites":[],"updatePoint":{"line":163,"column":55},"line":163,"code":"test('DELETE /executions/:id should delete an execution', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tconst execution = await testDb.createSuccessfulExecution(workflow);\n\n\tconst response = await authOwnerAgent.delete(`/executions/${execution.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\tfinished,\n\t\tmode,\n\t\tretryOf,\n\t\tretrySuccessId,\n\t\tstartedAt,\n\t\tstoppedAt,\n\t\tworkflowId,\n\t\twaitTill,\n\t} = response.body;\n\n\texpect(id).toBeDefined();\n\texpect(finished).toBe(true);\n\texpect(mode).toEqual(execution.mode);\n\texpect(retrySuccessId).toBeNull();\n\texpect(retryOf).toBeNull();\n\texpect(startedAt).not.toBeNull();\n\texpect(stoppedAt).not.toBeNull();\n\texpect(workflowId).toBe(execution.workflowId);\n\texpect(waitTill).toBeNull();\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should fail due to missing API Key","suites":[],"updatePoint":{"line":204,"column":56},"line":204,"code":"test('GET /executions should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/executions');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should fail due to invalid API Key","suites":[],"updatePoint":{"line":219,"column":56},"line":219,"code":"test('GET /executions should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/executions');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should retrieve all successful executions","suites":[],"updatePoint":{"line":235,"column":63},"line":235,"code":"test('GET /executions should retrieve all successful executions', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tconst successfullExecution = await testDb.createSuccessfulExecution(workflow);\n\n\tawait testDb.createErrorExecution(workflow);\n\n\tconst response = await authOwnerAgent.get(`/executions`).query({\n\t\tstatus: 'success',\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1);\n\texpect(response.body.nextCursor).toBe(null);\n\n\tconst {\n\t\tid,\n\t\tfinished,\n\t\tmode,\n\t\tretryOf,\n\t\tretrySuccessId,\n\t\tstartedAt,\n\t\tstoppedAt,\n\t\tworkflowId,\n\t\twaitTill,\n\t} = response.body.data[0];\n\n\texpect(id).toBeDefined();\n\texpect(finished).toBe(true);\n\texpect(mode).toEqual(successfullExecution.mode);\n\texpect(retrySuccessId).toBeNull();\n\texpect(retryOf).toBeNull();\n\texpect(startedAt).not.toBeNull();\n\texpect(stoppedAt).not.toBeNull();\n\texpect(workflowId).toBe(successfullExecution.workflowId);\n\texpect(waitTill).toBeNull();\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should paginate two executions","suites":[],"line":283,"code":"test.skip('GET /executions should paginate two executions', async () => {","file":"integration/publicApi/executions.test.ts","skipped":true,"dir":"packages/cli/test"},{"name":"GET /executions should retrieve all error executions","suites":[],"updatePoint":{"line":348,"column":58},"line":348,"code":"test('GET /executions should retrieve all error executions', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tawait testDb.createSuccessfulExecution(workflow);\n\n\tconst errorExecution = await testDb.createErrorExecution(workflow);\n\n\tconst response = await authOwnerAgent.get(`/executions`).query({\n\t\tstatus: 'error',\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1);\n\texpect(response.body.nextCursor).toBe(null);\n\n\tconst {\n\t\tid,\n\t\tfinished,\n\t\tmode,\n\t\tretryOf,\n\t\tretrySuccessId,\n\t\tstartedAt,\n\t\tstoppedAt,\n\t\tworkflowId,\n\t\twaitTill,\n\t} = response.body.data[0];\n\n\texpect(id).toBeDefined();\n\texpect(finished).toBe(false);\n\texpect(mode).toEqual(errorExecution.mode);\n\texpect(retrySuccessId).toBeNull();\n\texpect(retryOf).toBeNull();\n\texpect(startedAt).not.toBeNull();\n\texpect(stoppedAt).not.toBeNull();\n\texpect(workflowId).toBe(errorExecution.workflowId);\n\texpect(waitTill).toBeNull();\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should return all waiting executions","suites":[],"updatePoint":{"line":395,"column":58},"line":395,"code":"test('GET /executions should return all waiting executions', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tawait testDb.createSuccessfulExecution(workflow);\n\n\tawait testDb.createErrorExecution(workflow);\n\n\tconst waitingExecution = await testDb.createWaitingExecution(workflow);\n\n\tconst response = await authOwnerAgent.get(`/executions`).query({\n\t\tstatus: 'waiting',\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1);\n\texpect(response.body.nextCursor).toBe(null);\n\n\tconst {\n\t\tid,\n\t\tfinished,\n\t\tmode,\n\t\tretryOf,\n\t\tretrySuccessId,\n\t\tstartedAt,\n\t\tstoppedAt,\n\t\tworkflowId,\n\t\twaitTill,\n\t} = response.body.data[0];\n\n\texpect(id).toBeDefined();\n\texpect(finished).toBe(false);\n\texpect(mode).toEqual(waitingExecution.mode);\n\texpect(retrySuccessId).toBeNull();\n\texpect(retryOf).toBeNull();\n\texpect(startedAt).not.toBeNull();\n\texpect(stoppedAt).not.toBeNull();\n\texpect(workflowId).toBe(waitingExecution.workflowId);\n\texpect(new Date(waitTill).getTime()).toBeGreaterThan(Date.now() - 1000);\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /executions should retrieve all executions of specific workflow","suites":[],"updatePoint":{"line":444,"column":73},"line":444,"code":"test('GET /executions should retrieve all executions of specific workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst [workflow, workflow2] = await testDb.createManyWorkflows(2, {}, owner);\n\n\tconst savedExecutions = await testDb.createManyExecutions(\n\t\t2,\n\t\tworkflow,\n\t\t// @ts-ignore\n\t\ttestDb.createSuccessfulExecution,\n\t);\n\t// @ts-ignore\n\tawait testDb.createManyExecutions(2, workflow2, testDb.createSuccessfulExecution);\n\n\tconst response = await authOwnerAgent.get(`/executions`).query({\n\t\tworkflowId: workflow.id.toString(),\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(2);\n\texpect(response.body.nextCursor).toBe(null);\n\n\tfor (const execution of response.body.data) {\n\t\tconst {\n\t\t\tid,\n\t\t\tfinished,\n\t\t\tmode,\n\t\t\tretryOf,\n\t\t\tretrySuccessId,\n\t\t\tstartedAt,\n\t\t\tstoppedAt,\n\t\t\tworkflowId,\n\t\t\twaitTill,\n\t\t} = execution;\n\n\t\texpect(savedExecutions.some((exec) => exec.id === id)).toBe(true);\n\t\texpect(finished).toBe(true);\n\t\texpect(mode).toBeDefined();\n\t\texpect(retrySuccessId).toBeNull();\n\t\texpect(retryOf).toBeNull();\n\t\texpect(startedAt).not.toBeNull();\n\t\texpect(stoppedAt).not.toBeNull();\n\t\texpect(workflowId).toBe(workflow.id.toString());\n\t\texpect(waitTill).toBeNull();\n\t}\n});","file":"integration/publicApi/executions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should fail due to missing API Key","suites":[],"updatePoint":{"line":59,"column":55},"line":59,"code":"test('GET /workflows should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/workflows');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should fail due to invalid API Key","suites":[],"updatePoint":{"line":74,"column":55},"line":74,"code":"test('GET /workflows should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get('/workflows');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should return all owned workflows","suites":[],"updatePoint":{"line":91,"column":54},"line":91,"code":"test('GET /workflows should return all owned workflows', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tawait Promise.all([\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, member),\n\t]);\n\n\tconst response = await authAgent.get('/workflows');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(3);\n\texpect(response.body.nextCursor).toBeNull();\n\n\tfor (const workflow of response.body.data) {\n\t\tconst {\n\t\t\tid,\n\t\t\tconnections,\n\t\t\tactive,\n\t\t\tstaticData,\n\t\t\tnodes,\n\t\t\tsettings,\n\t\t\tname,\n\t\t\tcreatedAt,\n\t\t\tupdatedAt,\n\t\t\ttags,\n\t\t} = workflow;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(name).toBeDefined();\n\t\texpect(connections).toBeDefined();\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toBeDefined();\n\t\texpect(nodes).toBeDefined();\n\t\texpect(tags).toBeDefined();\n\t\texpect(settings).toBeDefined();\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\t}\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should return all owned workflows with pagination","suites":[],"updatePoint":{"line":140,"column":70},"line":140,"code":"test('GET /workflows should return all owned workflows with pagination', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tawait Promise.all([\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, member),\n\t]);\n\n\tconst response = await authAgent.get('/workflows?limit=1');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1);\n\texpect(response.body.nextCursor).not.toBeNull();\n\n\tconst response2 = await authAgent.get(`/workflows?limit=1&cursor=${response.body.nextCursor}`);\n\n\texpect(response2.statusCode).toBe(200);\n\texpect(response2.body.data.length).toBe(1);\n\texpect(response2.body.nextCursor).not.toBeNull();\n\texpect(response2.body.nextCursor).not.toBe(response.body.nextCursor);\n\n\tconst responses = [...response.body.data, ...response2.body.data];\n\n\tfor (const workflow of responses) {\n\t\tconst {\n\t\t\tid,\n\t\t\tconnections,\n\t\t\tactive,\n\t\t\tstaticData,\n\t\t\tnodes,\n\t\t\tsettings,\n\t\t\tname,\n\t\t\tcreatedAt,\n\t\t\tupdatedAt,\n\t\t\ttags,\n\t\t} = workflow;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(name).toBeDefined();\n\t\texpect(connections).toBeDefined();\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toBeDefined();\n\t\texpect(nodes).toBeDefined();\n\t\texpect(tags).toBeDefined();\n\t\texpect(settings).toBeDefined();\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\t}\n\n\t// check that we really received a different result\n\texpect(response.body.data[0].id).toBeLessThan(response2.body.data[0].id);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should return all owned workflows filtered by tag","suites":[],"updatePoint":{"line":201,"column":70},"line":201,"code":"test('GET /workflows should return all owned workflows filtered by tag', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst tag = await testDb.createTag({});\n\n\tconst [workflow] = await Promise.all([\n\t\ttestDb.createWorkflow({ tags: [tag] }, member),\n\t\ttestDb.createWorkflow({}, member),\n\t]);\n\n\tconst response = await authAgent.get(`/workflows?tags=${tag.name}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(1);\n\n\tconst {\n\t\tid,\n\t\tconnections,\n\t\tactive,\n\t\tstaticData,\n\t\tnodes,\n\t\tsettings,\n\t\tname,\n\t\tcreatedAt,\n\t\tupdatedAt,\n\t\ttags: wfTags,\n\t} = response.body.data[0];\n\n\texpect(id).toBe(workflow.id);\n\texpect(name).toBeDefined();\n\texpect(connections).toBeDefined();\n\texpect(active).toBe(false);\n\texpect(staticData).toBeDefined();\n\texpect(nodes).toBeDefined();\n\texpect(settings).toBeDefined();\n\texpect(createdAt).toBeDefined();\n\texpect(updatedAt).toBeDefined();\n\n\texpect(wfTags.length).toBe(1);\n\texpect(wfTags[0].id).toBe(tag.id);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should return all owned workflows filtered by tags","suites":[],"updatePoint":{"line":250,"column":71},"line":250,"code":"test('GET /workflows should return all owned workflows filtered by tags', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst tags = await Promise.all([await testDb.createTag({}), await testDb.createTag({})]);\n\tconst tagNames = tags.map((tag) => tag.name).join(',');\n\n\tconst [workflow1, workflow2] = await Promise.all([\n\t\ttestDb.createWorkflow({ tags }, member),\n\t\ttestDb.createWorkflow({ tags }, member),\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({ tags: [tags[0]] }, member),\n\t\ttestDb.createWorkflow({ tags: [tags[1]] }, member),\n\t]);\n\n\tconst response = await authAgent.get(`/workflows?tags=${tagNames}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(2);\n\n\tfor (const workflow of response.body.data) {\n\t\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\t\tworkflow;\n\n\t\texpect(id).toBeDefined();\n\t\texpect([workflow1.id, workflow2.id].includes(id)).toBe(true);\n\n\t\texpect(name).toBeDefined();\n\t\texpect(connections).toBeDefined();\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toBeDefined();\n\t\texpect(nodes).toBeDefined();\n\t\texpect(settings).toBeDefined();\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\n\t\texpect(workflow.tags.length).toBe(2);\n\t\tworkflow.tags.forEach((tag: TagEntity) => {\n\t\t\texpect(tags.some((savedTag) => savedTag.id === tag.id)).toBe(true);\n\t\t});\n\t}\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows should return all workflows for owner","suites":[],"updatePoint":{"line":299,"column":58},"line":299,"code":"test('GET /workflows should return all workflows for owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tawait Promise.all([\n\t\ttestDb.createWorkflow({}, owner),\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, owner),\n\t\ttestDb.createWorkflow({}, member),\n\t\ttestDb.createWorkflow({}, owner),\n\t]);\n\n\tconst response = await authOwnerAgent.get('/workflows');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(5);\n\texpect(response.body.nextCursor).toBeNull();\n\n\tfor (const workflow of response.body.data) {\n\t\tconst {\n\t\t\tid,\n\t\t\tconnections,\n\t\t\tactive,\n\t\t\tstaticData,\n\t\t\tnodes,\n\t\t\tsettings,\n\t\t\tname,\n\t\t\tcreatedAt,\n\t\t\tupdatedAt,\n\t\t\ttags,\n\t\t} = workflow;\n\n\t\texpect(id).toBeDefined();\n\t\texpect(name).toBeDefined();\n\t\texpect(connections).toBeDefined();\n\t\texpect(active).toBe(false);\n\t\texpect(staticData).toBeDefined();\n\t\texpect(nodes).toBeDefined();\n\t\texpect(tags).toBeDefined();\n\t\texpect(settings).toBeDefined();\n\t\texpect(createdAt).toBeDefined();\n\t\texpect(updatedAt).toBeDefined();\n\t}\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should fail due to missing API Key","suites":[],"updatePoint":{"line":351,"column":59},"line":351,"code":"test('GET /workflows/:id should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\towner.apiKey = null;\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should fail due to invalid API Key","suites":[],"updatePoint":{"line":368,"column":59},"line":368,"code":"test('GET /workflows/:id should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should fail due to non-existing workflow","suites":[],"updatePoint":{"line":385,"column":65},"line":385,"code":"test('GET /workflows/:id should fail due to non-existing workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.get(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should retrieve workflow","suites":[],"updatePoint":{"line":400,"column":49},"line":400,"code":"test('GET /workflows/:id should retrieve workflow', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\t// create and assign workflow to owner\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst response = await authAgent.get(`/workflows/${workflow.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt, tags } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(tags).toEqual([]);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should retrieve non-owned workflow for owner","suites":[],"updatePoint":{"line":432,"column":69},"line":432,"code":"test('GET /workflows/:id should retrieve non-owned workflow for owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\t// create and assign workflow to owner\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst response = await authOwnerAgent.get(`/workflows/${workflow.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /workflows/:id should fail due to missing API Key","suites":[],"updatePoint":{"line":464,"column":62},"line":464,"code":"test('DELETE /workflows/:id should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.delete(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /workflows/:id should fail due to invalid API Key","suites":[],"updatePoint":{"line":479,"column":62},"line":479,"code":"test('DELETE /workflows/:id should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.delete(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /workflows/:id should fail due to non-existing workflow","suites":[],"updatePoint":{"line":496,"column":68},"line":496,"code":"test('DELETE /workflows/:id should fail due to non-existing workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.delete(`/workflows/2`);\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /workflows/:id should delete the workflow","suites":[],"updatePoint":{"line":511,"column":54},"line":511,"code":"test('DELETE /workflows/:id should delete the workflow', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\t// create and assign workflow to owner\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst response = await authAgent.delete(`/workflows/${workflow.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t// make sure the workflow actually deleted from the db\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\tworkflow,\n\t});\n\n\texpect(sharedWorkflow).toBeUndefined();\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /workflows/:id should delete non-owned workflow when owner","suites":[],"updatePoint":{"line":549,"column":71},"line":549,"code":"test('DELETE /workflows/:id should delete non-owned workflow when owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\t// create and assign workflow to owner\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst response = await authAgent.delete(`/workflows/${workflow.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t// make sure the workflow actually deleted from the db\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\tworkflow,\n\t});\n\n\texpect(sharedWorkflow).toBeUndefined();\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should fail due to missing API Key","suites":[],"updatePoint":{"line":588,"column":69},"line":588,"code":"test('POST /workflows/:id/activate should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/activate`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should fail due to invalid API Key","suites":[],"updatePoint":{"line":603,"column":69},"line":603,"code":"test('POST /workflows/:id/activate should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/activate`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should fail due to non-existing workflow","suites":[],"updatePoint":{"line":620,"column":75},"line":620,"code":"test('POST /workflows/:id/activate should fail due to non-existing workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/activate`);\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should fail due to trying to activate a workflow without a trigger","suites":[],"updatePoint":{"line":635,"column":101},"line":635,"code":"test('POST /workflows/:id/activate should fail due to trying to activate a workflow without a trigger', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflow({}, owner);\n\n\tconst response = await authOwnerAgent.post(`/workflows/${workflow.id}/activate`);\n\n\texpect(response.statusCode).toBe(400);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should set workflow as active","suites":[],"updatePoint":{"line":652,"column":64},"line":652,"code":"test('POST /workflows/:id/activate should set workflow as active', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\tconst response = await authAgent.post(`/workflows/${workflow.id}/activate`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(true);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t// check whether the workflow is on the database\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow,\n\t\t},\n\t\trelations: ['workflow'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.active).toBe(true);\n\n\t// check whether the workflow is on the active workflow runner\n\texpect(await workflowRunner.isActive(workflow.id.toString())).toBe(true);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/activate should set non-owned workflow as active when owner","suites":[],"updatePoint":{"line":696,"column":85},"line":696,"code":"test('POST /workflows/:id/activate should set non-owned workflow as active when owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\tconst response = await authAgent.post(`/workflows/${workflow.id}/activate`);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(true);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toEqual(workflow.createdAt.toISOString());\n\texpect(updatedAt).toEqual(workflow.updatedAt.toISOString());\n\n\t// check whether the workflow is on the database\n\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: owner,\n\t\t\tworkflow,\n\t\t},\n\t});\n\n\texpect(sharedOwnerWorkflow).toBeUndefined();\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow,\n\t\t},\n\t\trelations: ['workflow'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.active).toBe(true);\n\n\t// check whether the workflow is on the active workflow runner\n\texpect(await workflowRunner.isActive(workflow.id.toString())).toBe(true);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/deactivate should fail due to missing API Key","suites":[],"updatePoint":{"line":750,"column":71},"line":750,"code":"test('POST /workflows/:id/deactivate should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/deactivate`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/deactivate should fail due to invalid API Key","suites":[],"updatePoint":{"line":765,"column":71},"line":765,"code":"test('POST /workflows/:id/deactivate should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/deactivate`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/deactivate should fail due to non-existing workflow","suites":[],"updatePoint":{"line":782,"column":77},"line":782,"code":"test('POST /workflows/:id/deactivate should fail due to non-existing workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post(`/workflows/2/deactivate`);\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/deactivate should deactivate workflow","suites":[],"updatePoint":{"line":797,"column":63},"line":797,"code":"test('POST /workflows/:id/deactivate should deactivate workflow', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\tawait authAgent.post(`/workflows/${workflow.id}/activate`);\n\n\tconst workflowDeactivationResponse = await authAgent.post(`/workflows/${workflow.id}/deactivate`);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tworkflowDeactivationResponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toBeDefined();\n\texpect(updatedAt).toBeDefined();\n\n\t// get the workflow after it was deactivated\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow,\n\t\t},\n\t\trelations: ['workflow'],\n\t});\n\n\t// check whether the workflow is deactivated in the database\n\texpect(sharedWorkflow?.workflow.active).toBe(false);\n\n\texpect(await workflowRunner.isActive(workflow.id.toString())).toBe(false);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows/:id/deactivate should deactivate non-owned workflow when owner","suites":[],"updatePoint":{"line":841,"column":84},"line":841,"code":"test('POST /workflows/:id/deactivate should deactivate non-owned workflow when owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst workflow = await testDb.createWorkflowWithTrigger({}, member);\n\n\tawait authAgent.post(`/workflows/${workflow.id}/activate`);\n\n\tconst workflowDeactivationResponse = await authAgent.post(`/workflows/${workflow.id}/deactivate`);\n\n\tconst { id, connections, active, staticData, nodes, settings, name, createdAt, updatedAt } =\n\t\tworkflowDeactivationResponse.body;\n\n\texpect(id).toEqual(workflow.id);\n\texpect(name).toEqual(workflow.name);\n\texpect(connections).toEqual(workflow.connections);\n\texpect(active).toBe(false);\n\texpect(staticData).toEqual(workflow.staticData);\n\texpect(nodes).toEqual(workflow.nodes);\n\texpect(settings).toEqual(workflow.settings);\n\texpect(createdAt).toBeDefined();\n\texpect(updatedAt).toBeDefined();\n\n\t// check whether the workflow is deactivated in the database\n\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: owner,\n\t\t\tworkflow,\n\t\t},\n\t});\n\n\texpect(sharedOwnerWorkflow).toBeUndefined();\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow,\n\t\t},\n\t\trelations: ['workflow'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.active).toBe(false);\n\n\texpect(await workflowRunner.isActive(workflow.id.toString())).toBe(false);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should fail due to missing API Key","suites":[],"updatePoint":{"line":894,"column":56},"line":894,"code":"test('POST /workflows should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post('/workflows');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should fail due to invalid API Key","suites":[],"updatePoint":{"line":909,"column":56},"line":909,"code":"test('POST /workflows should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post('/workflows');\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should fail due to invalid body","suites":[],"updatePoint":{"line":926,"column":53},"line":926,"code":"test('POST /workflows should fail due to invalid body', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.post('/workflows').send({});\n\n\texpect(response.statusCode).toBe(400);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should create workflow","suites":[],"updatePoint":{"line":941,"column":44},"line":941,"code":"test('POST /workflows should create workflow', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole, apiKey: randomApiKey() });\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst payload = {\n\t\tname: 'testing',\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Start',\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [240, 300],\n\t\t\t},\n\t\t],\n\t\tconnections: {},\n\t\tstaticData: null,\n\t\tsettings: {\n\t\t\tsaveExecutionProgress: true,\n\t\t\tsaveManualExecutions: true,\n\t\t\tsaveDataErrorExecution: 'all',\n\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\texecutionTimeout: 3600,\n\t\t\ttimezone: 'America/New_York',\n\t\t},\n\t};\n\n\tconst response = await authAgent.post('/workflows').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(id).toBeDefined();\n\texpect(name).toBe(payload.name);\n\texpect(connections).toEqual(payload.connections);\n\texpect(settings).toEqual(payload.settings);\n\texpect(staticData).toEqual(payload.staticData);\n\texpect(nodes).toEqual(payload.nodes);\n\texpect(active).toBe(false);\n\texpect(createdAt).toBeDefined();\n\texpect(updatedAt).toEqual(createdAt);\n\n\t// check if created workflow in DB\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow: response.body,\n\t\t},\n\t\trelations: ['workflow', 'role'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.name).toBe(name);\n\texpect(sharedWorkflow?.workflow.createdAt.toISOString()).toBe(createdAt);\n\texpect(sharedWorkflow?.role).toEqual(workflowOwnerRole);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should fail due to missing API Key","suites":[],"updatePoint":{"line":1006,"column":59},"line":1006,"code":"test('PUT /workflows/:id should fail due to missing API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.put(`/workflows/1`);\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should fail due to invalid API Key","suites":[],"updatePoint":{"line":1021,"column":59},"line":1021,"code":"test('PUT /workflows/:id should fail due to invalid API Key', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\towner.apiKey = 'abcXYZ';\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.put(`/workflows/1`).send({});\n\n\texpect(response.statusCode).toBe(401);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should fail due to non-existing workflow","suites":[],"updatePoint":{"line":1038,"column":65},"line":1038,"code":"test('PUT /workflows/:id should fail due to non-existing workflow', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.put(`/workflows/1`).send({\n\t\tname: 'testing',\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Start',\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [240, 300],\n\t\t\t},\n\t\t],\n\t\tconnections: {},\n\t\tstaticData: null,\n\t\tsettings: {\n\t\t\tsaveExecutionProgress: true,\n\t\t\tsaveManualExecutions: true,\n\t\t\tsaveDataErrorExecution: 'all',\n\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\texecutionTimeout: 3600,\n\t\t\ttimezone: 'America/New_York',\n\t\t},\n\t});\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should fail due to invalid body","suites":[],"updatePoint":{"line":1075,"column":56},"line":1075,"code":"test('PUT /workflows/:id should fail due to invalid body', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst authOwnerAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst response = await authOwnerAgent.put(`/workflows/1`).send({\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Start',\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [240, 300],\n\t\t\t},\n\t\t],\n\t\tconnections: {},\n\t\tstaticData: null,\n\t\tsettings: {\n\t\t\tsaveExecutionProgress: true,\n\t\t\tsaveManualExecutions: true,\n\t\t\tsaveDataErrorExecution: 'all',\n\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\texecutionTimeout: 3600,\n\t\t\ttimezone: 'America/New_York',\n\t\t},\n\t});\n\n\texpect(response.statusCode).toBe(400);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should update workflow","suites":[],"updatePoint":{"line":1111,"column":47},"line":1111,"code":"test('PUT /workflows/:id should update workflow', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: member,\n\t\tversion: 1,\n\t});\n\n\tconst payload = {\n\t\tname: 'name updated',\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Start',\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [240, 300],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Cron',\n\t\t\t\ttype: 'n8n-nodes-base.cron',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [400, 300],\n\t\t\t},\n\t\t],\n\t\tconnections: {},\n\t\tstaticData: '{\"id\":1}',\n\t\tsettings: {\n\t\t\tsaveExecutionProgress: false,\n\t\t\tsaveManualExecutions: false,\n\t\t\tsaveDataErrorExecution: 'all',\n\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\texecutionTimeout: 3600,\n\t\t\ttimezone: 'America/New_York',\n\t\t},\n\t};\n\n\tconst response = await authAgent.put(`/workflows/${workflow.id}`).send(payload);\n\n\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(response.statusCode).toBe(200);\n\n\texpect(id).toBe(workflow.id);\n\texpect(name).toBe(payload.name);\n\texpect(connections).toEqual(payload.connections);\n\texpect(settings).toEqual(payload.settings);\n\texpect(staticData).toMatchObject(JSON.parse(payload.staticData));\n\texpect(nodes).toEqual(payload.nodes);\n\texpect(active).toBe(false);\n\texpect(createdAt).toBe(workflow.createdAt.toISOString());\n\texpect(updatedAt).not.toBe(workflow.updatedAt.toISOString());\n\n\t// check updated workflow in DB\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow: response.body,\n\t\t},\n\t\trelations: ['workflow'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.name).toBe(payload.name);\n\texpect(sharedWorkflow?.workflow.updatedAt.getTime()).toBeGreaterThan(\n\t\tworkflow.updatedAt.getTime(),\n\t);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id should update non-owned workflow if owner","suites":[],"updatePoint":{"line":1187,"column":66},"line":1187,"code":"test('PUT /workflows/:id should update non-owned workflow if owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole, apiKey: randomApiKey() });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst workflow = await testDb.createWorkflow({}, member);\n\n\tconst authAgent = utils.createAgent(app, {\n\t\tapiPath: 'public',\n\t\tauth: true,\n\t\tuser: owner,\n\t\tversion: 1,\n\t});\n\n\tconst payload = {\n\t\tname: 'name owner updated',\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: 'uuid-1',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Start',\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [240, 300],\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'uuid-2',\n\t\t\t\tparameters: {},\n\t\t\t\tname: 'Cron',\n\t\t\t\ttype: 'n8n-nodes-base.cron',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tposition: [400, 300],\n\t\t\t},\n\t\t],\n\t\tconnections: {},\n\t\tstaticData: '{\"id\":1}',\n\t\tsettings: {\n\t\t\tsaveExecutionProgress: false,\n\t\t\tsaveManualExecutions: false,\n\t\t\tsaveDataErrorExecution: 'all',\n\t\t\tsaveDataSuccessExecution: 'all',\n\t\t\texecutionTimeout: 3600,\n\t\t\ttimezone: 'America/New_York',\n\t\t},\n\t};\n\n\tconst response = await authAgent.put(`/workflows/${workflow.id}`).send(payload);\n\n\tconst { id, name, nodes, connections, staticData, active, settings, createdAt, updatedAt } =\n\t\tresponse.body;\n\n\texpect(response.statusCode).toBe(200);\n\n\texpect(id).toBe(workflow.id);\n\texpect(name).toBe(payload.name);\n\texpect(connections).toEqual(payload.connections);\n\texpect(settings).toEqual(payload.settings);\n\texpect(staticData).toMatchObject(JSON.parse(payload.staticData));\n\texpect(nodes).toEqual(payload.nodes);\n\texpect(active).toBe(false);\n\texpect(createdAt).toBe(workflow.createdAt.toISOString());\n\texpect(updatedAt).not.toBe(workflow.updatedAt.toISOString());\n\n\t// check updated workflow in DB\n\tconst sharedOwnerWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: owner,\n\t\t\tworkflow: response.body,\n\t\t},\n\t});\n\n\texpect(sharedOwnerWorkflow).toBeUndefined();\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\twhere: {\n\t\t\tuser: member,\n\t\t\tworkflow: response.body,\n\t\t},\n\t\trelations: ['workflow', 'role'],\n\t});\n\n\texpect(sharedWorkflow?.workflow.name).toBe(payload.name);\n\texpect(sharedWorkflow?.workflow.updatedAt.getTime()).toBeGreaterThan(\n\t\tworkflow.updatedAt.getTime(),\n\t);\n\texpect(sharedWorkflow?.role).toEqual(workflowOwnerRole);\n});","file":"integration/publicApi/workflows.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /users should return all users","suites":[],"updatePoint":{"line":76,"column":40},"line":76,"code":"test('GET /users should return all users', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tawait testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authAgent(owner).get('/users');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(2);\n\n\tawait Promise.all(\n\t\tresponse.body.data.map(async (user: User) => {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t\tapiKey,\n\t\t\t} = user;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBeDefined();\n\t\t\texpect(firstName).toBeDefined();\n\t\t\texpect(lastName).toBeDefined();\n\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole).toBeDefined();\n\t\t\texpect(apiKey).not.toBeDefined();\n\t\t}),\n\t);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should delete the user","suites":[],"updatePoint":{"line":115,"column":46},"line":115,"code":"test('DELETE /users/:id should delete the user', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst userToDelete = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst newWorkflow = new WorkflowEntity();\n\n\tObject.assign(newWorkflow, {\n\t\tname: randomName(),\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodes: [],\n\t});\n\n\tconst savedWorkflow = await Db.collections.Workflow.save(newWorkflow);\n\n\tawait Db.collections.SharedWorkflow.save({\n\t\trole: workflowOwnerRole,\n\t\tuser: userToDelete,\n\t\tworkflow: savedWorkflow,\n\t});\n\n\tconst newCredential = new CredentialsEntity();\n\n\tObject.assign(newCredential, {\n\t\tname: randomName(),\n\t\tdata: '',\n\t\ttype: '',\n\t\tnodesAccess: [],\n\t});\n\n\tconst savedCredential = await Db.collections.Credentials.save(newCredential);\n\n\tawait Db.collections.SharedCredentials.save({\n\t\trole: credentialOwnerRole,\n\t\tuser: userToDelete,\n\t\tcredentials: savedCredential,\n\t});\n\n\tconst response = await authAgent(owner).delete(`/users/${userToDelete.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\tconst user = await Db.collections.User.findOne(userToDelete.id);\n\texpect(user).toBeUndefined(); // deleted\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\trelations: ['user'],\n\t\twhere: { user: userToDelete },\n\t});\n\texpect(sharedWorkflow).toBeUndefined(); // deleted\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOne({\n\t\trelations: ['user'],\n\t\twhere: { user: userToDelete },\n\t});\n\texpect(sharedCredential).toBeUndefined(); // deleted\n\n\tconst workflow = await Db.collections.Workflow.findOne(savedWorkflow.id);\n\texpect(workflow).toBeUndefined(); // deleted\n\n\t// TODO: Include active workflow and check whether webhook has been removed\n\n\tconst credential = await Db.collections.Credentials.findOne(savedCredential.id);\n\texpect(credential).toBeUndefined(); // deleted\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should fail to delete self","suites":[],"updatePoint":{"line":183,"column":50},"line":183,"code":"test('DELETE /users/:id should fail to delete self', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst response = await authAgent(owner).delete(`/users/${owner.id}`);\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst user = await Db.collections.User.findOne(owner.id);\n\texpect(user).toBeDefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should fail if user to delete is transferee","suites":[],"updatePoint":{"line":194,"column":67},"line":194,"code":"test('DELETE /users/:id should fail if user to delete is transferee', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst { id: idToDelete } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authAgent(owner).delete(`/users/${idToDelete}`).query({\n\t\ttransferId: idToDelete,\n\t});\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst user = await Db.collections.User.findOne(idToDelete);\n\texpect(user).toBeDefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id with transferId should perform transfer","suites":[],"updatePoint":{"line":209,"column":63},"line":209,"code":"test('DELETE /users/:id with transferId should perform transfer', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst userToDelete = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst savedWorkflow = await testDb.createWorkflow(undefined, userToDelete);\n\n\tconst savedCredential = await testDb.saveCredential(undefined, {\n\t\tuser: userToDelete,\n\t\trole: credentialOwnerRole,\n\t});\n\n\tconst response = await authAgent(owner).delete(`/users/${userToDelete.id}`).query({\n\t\ttransferId: owner.id,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOneOrFail({\n\t\trelations: ['workflow'],\n\t\twhere: { user: owner },\n\t});\n\n\texpect(sharedWorkflow.workflow).toBeDefined();\n\texpect(sharedWorkflow.workflow.id).toBe(savedWorkflow.id);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { user: owner },\n\t});\n\n\texpect(sharedCredential.credentials).toBeDefined();\n\texpect(sharedCredential.credentials.id).toBe(savedCredential.id);\n\n\tconst deletedUser = await Db.collections.User.findOne(userToDelete);\n\n\texpect(deletedUser).toBeUndefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-signup-token should validate invite token","suites":[],"updatePoint":{"line":248,"column":60},"line":248,"code":"test('GET /resolve-signup-token should validate invite token', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconst response = await authAgent(owner)\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId: memberShell.id });\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({\n\t\tdata: {\n\t\t\tinviter: {\n\t\t\t\tfirstName: owner.firstName,\n\t\t\t\tlastName: owner.lastName,\n\t\t\t},\n\t\t},\n\t});\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-signup-token should fail with invalid inputs","suites":[],"updatePoint":{"line":269,"column":63},"line":269,"code":"test('GET /resolve-signup-token should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(owner);\n\n\tconst { id: inviteeId } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst first = await authOwnerAgent.get('/resolve-signup-token').query({ inviterId: owner.id });\n\n\tconst second = await authOwnerAgent.get('/resolve-signup-token').query({ inviteeId });\n\n\tconst third = await authOwnerAgent.get('/resolve-signup-token').query({\n\t\tinviterId: '5531199e-b7ae-425b-a326-a95ef8cca59d',\n\t\tinviteeId: 'cb133beb-7729-4c34-8cd1-a06be8834d9d',\n\t});\n\n\t// user is already set up, so call should error\n\tconst fourth = await authOwnerAgent\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId });\n\n\t// cause inconsistent DB state\n\tawait Db.collections.User.update(owner.id, { email: '' });\n\tconst fifth = await authOwnerAgent\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId });\n\n\tfor (const response of [first, second, third, fourth, fifth]) {\n\t\texpect(response.statusCode).toBe(400);\n\t}\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fill out a user shell","suites":[],"updatePoint":{"line":302,"column":50},"line":302,"code":"test('POST /users/:id should fill out a user shell', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconst memberData = {\n\t\tinviterId: owner.id,\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post(`/users/${memberShell.id}`).send(memberData);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpersonalizationAnswers,\n\t\tpassword,\n\t\tresetPasswordToken,\n\t\tglobalRole,\n\t\tisPending,\n\t\tapiKey,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBe(memberData.firstName);\n\texpect(lastName).toBe(memberData.lastName);\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(isPending).toBe(false);\n\texpect(globalRole).toBeDefined();\n\texpect(apiKey).not.toBeDefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n\n\tconst member = await Db.collections.User.findOneOrFail(memberShell.id);\n\texpect(member.firstName).toBe(memberData.firstName);\n\texpect(member.lastName).toBe(memberData.lastName);\n\texpect(member.password).not.toBe(memberData.password);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fail with invalid inputs","suites":[],"updatePoint":{"line":351,"column":53},"line":351,"code":"test('POST /users/:id should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst memberShellEmail = randomEmail();\n\n\tconst memberShell = await Db.collections.User.save({\n\t\temail: memberShellEmail,\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconst invalidPayloads = [\n\t\t{\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomInvalidPassword(),\n\t\t},\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post(`/users/${memberShell.id}`).send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedUser = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: memberShellEmail },\n\t\t\t});\n\n\t\t\texpect(storedUser.firstName).toBeNull();\n\t\t\texpect(storedUser.lastName).toBeNull();\n\t\t\texpect(storedUser.password).toBeNull();\n\t\t}),\n\t);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fail with already accepted invite","suites":[],"updatePoint":{"line":408,"column":62},"line":408,"code":"test('POST /users/:id should fail with already accepted invite', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst newMemberData = {\n\t\tinviterId: owner.id,\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post(`/users/${member.id}`).send(newMemberData);\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst storedMember = await Db.collections.User.findOneOrFail({\n\t\twhere: { email: member.email },\n\t});\n\texpect(storedMember.firstName).not.toBe(newMemberData.firstName);\n\texpect(storedMember.lastName).not.toBe(newMemberData.lastName);\n\n\tconst comparisonResult = await compareHash(member.password, storedMember.password);\n\texpect(comparisonResult).toBe(false);\n\texpect(storedMember.password).not.toBe(newMemberData.password);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail if emailing is not set up","suites":[],"updatePoint":{"line":436,"column":55},"line":436,"code":"test('POST /users should fail if emailing is not set up', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst response = await authAgent(owner)\n\t\t.post('/users')\n\t\t.send([{ email: randomEmail() }]);\n\n\texpect(response.statusCode).toBe(500);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail if user management is disabled","suites":[],"updatePoint":{"line":446,"column":60},"line":446,"code":"test('POST /users should fail if user management is disabled', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconfig.set('userManagement.disabled', true);\n\n\tconst response = await authAgent(owner)\n\t\t.post('/users')\n\t\t.send([{ email: randomEmail() }]);\n\n\texpect(response.statusCode).toBe(500);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should email invites and create user shells but ignore existing","suites":[],"updatePoint":{"line":458,"column":81},"line":458,"code":"test('POST /users should email invites and create user shells but ignore existing', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst testEmails = [randomEmail(), randomEmail().toUpperCase(), memberShell.email, member.email];\n\n\tconst payload = testEmails.map((e) => ({ email: e }));\n\n\tconst response = await authAgent(owner).post('/users').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tfor (const {\n\t\tuser: { id, email: receivedEmail },\n\t\terror,\n\t} of response.body.data) {\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(id).not.toBe(member.id);\n\n\t\tconst lowerCasedEmail = receivedEmail.toLowerCase();\n\t\texpect(receivedEmail).toBe(lowerCasedEmail);\n\t\texpect(payload.some(({ email }) => email.toLowerCase() === lowerCasedEmail)).toBe(true);\n\n\t\tif (error) {\n\t\t\texpect(error).toBe('Email could not be sent');\n\t\t}\n\n\t\tconst storedUser = await Db.collections.User.findOneOrFail(id);\n\t\tconst { firstName, lastName, personalizationAnswers, password, resetPasswordToken } =\n\t\t\tstoredUser;\n\n\t\texpect(firstName).toBeNull();\n\t\texpect(lastName).toBeNull();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeNull();\n\t\texpect(resetPasswordToken).toBeNull();\n\t}\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail with invalid inputs","suites":[],"updatePoint":{"line":500,"column":49},"line":500,"code":"test('POST /users should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = authAgent(owner);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst invalidPayloads = [\n\t\trandomEmail(),\n\t\t[randomEmail()],\n\t\t{},\n\t\t[{ name: randomName() }],\n\t\t[{ email: randomName() }],\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/users').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst users = await Db.collections.User.find();\n\t\t\texpect(users.length).toBe(1); // DB unaffected\n\t\t}),\n\t);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should ignore an empty payload","suites":[],"updatePoint":{"line":525,"column":48},"line":525,"code":"test('POST /users should ignore an empty payload', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authAgent(owner).post('/users').send([]);\n\n\tconst { data } = response.body;\n\n\texpect(response.statusCode).toBe(200);\n\texpect(Array.isArray(data)).toBe(true);\n\texpect(data.length).toBe(0);\n\n\tconst users = await Db.collections.User.find();\n\texpect(users.length).toBe(1);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id/reinvite should send reinvite, but fail if user already accepted invite","suites":[],"updatePoint":{"line":542,"column":93},"line":542,"code":"test('POST /users/:id/reinvite should send reinvite, but fail if user already accepted invite', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\t// those configs are needed to make sure the reinvite email is sent,because of this check isEmailSetUp()\n\tconfig.set('userManagement.emails.smtp.host', 'host');\n\tconfig.set('userManagement.emails.smtp.auth.user', 'user');\n\tconfig.set('userManagement.emails.smtp.auth.pass', 'pass');\n\n\tconst email = randomEmail();\n\tconst payload = [{ email }];\n\tconst response = await authOwnerAgent.post('/users').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { data } = response.body;\n\tconst invitedUserId = data[0].user.id;\n\tconst reinviteResponse = await authOwnerAgent.post(`/users/${invitedUserId}/reinvite`);\n\n\texpect(reinviteResponse.statusCode).toBe(200);\n\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst reinviteMemberResponse = await authOwnerAgent.post(`/users/${member.id}/reinvite`);\n\n\texpect(reinviteMemberResponse.statusCode).toBe(400);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"UserManagementMailer expect NodeMailer.verifyConnection have been called","suites":[],"updatePoint":{"line":571,"column":78},"line":571,"code":"test('UserManagementMailer expect NodeMailer.verifyConnection have been called', async () => {\n\tjest.spyOn(NodeMailer.prototype, 'verifyConnection').mockImplementation(async () => {});\n\n\t// NodeMailer.verifyConnection called 1 time\n\tconst userManagementMailer = UserManagementMailer.getInstance();\n\t// NodeMailer.verifyConnection called 2 time\n\t(await userManagementMailer).verifyConnection();\n\n\texpect(NodeMailer.prototype.verifyConnection).toHaveBeenCalledTimes(2);\n\n\t// @ts-ignore\n\tNodeMailer.prototype.verifyConnection.mockRestore();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Router should switch dynamically","suites":[],"updatePoint":{"line":67,"column":38},"line":67,"code":"test('Router should switch dynamically', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst createWorkflowResponse = await authAgent(owner).post('/workflows').send(makeWorkflow());\n\tconst { id } = createWorkflowResponse.body.data;\n\n\t// free router\n\n\tisSharingEnabled.mockReturnValueOnce(false);\n\n\tconst freeShareResponse = await authAgent(owner)\n\t\t.put(`/workflows/${id}/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\texpect(freeShareResponse.status).toBe(404);\n\n\t// EE router\n\n\tconst paidShareResponse = await authAgent(owner)\n\t\t.put(`/workflows/${id}/share`)\n\t\t.send({ shareWithIds: [member.id] });\n\n\texpect(paidShareResponse.status).toBe(200);\n});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should save sharing with new users","suites":["PUT /workflows/:id"],"updatePoint":{"line":94,"column":66},"line":94,"code":"\ttest('PUT /workflows/:id/share should save sharing with new users', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authAgent(owner)\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should succeed when sharing with invalid user-id","suites":["PUT /workflows/:id"],"updatePoint":{"line":109,"column":80},"line":109,"code":"\ttest('PUT /workflows/:id/share should succeed when sharing with invalid user-id', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authAgent(owner)\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [uuid()] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should allow sharing with multiple users","suites":["PUT /workflows/:id"],"updatePoint":{"line":123,"column":72},"line":123,"code":"\ttest('PUT /workflows/:id/share should allow sharing with multiple users', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst anotherMember = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authAgent(owner)\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id, anotherMember.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(3);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PUT /workflows/:id/share should override sharing","suites":["PUT /workflows/:id"],"updatePoint":{"line":139,"column":55},"line":139,"code":"\ttest('PUT /workflows/:id/share should override sharing', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst anotherMember = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst authOwnerAgent = authAgent(owner);\n\n\t\tconst response = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id, anotherMember.id] });\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst sharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(sharedWorkflows).toHaveLength(3);\n\n\t\tconst secondResponse = await authOwnerAgent\n\t\t\t.put(`/workflows/${workflow.id}/share`)\n\t\t\t.send({ shareWithIds: [member.id] });\n\t\texpect(secondResponse.statusCode).toBe(200);\n\n\t\tconst secondSharedWorkflows = await testDb.getWorkflowSharing(workflow);\n\t\texpect(secondSharedWorkflows).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should return workflows with ownership, sharing and credential usage details","suites":["GET /workflows"],"updatePoint":{"line":167,"column":83},"line":167,"code":"\ttest('should return workflows with ownership, sharing and credential usage details', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflow = await createWorkflow(\n\t\t\t{\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: uuid(),\n\t\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\t\tparameters: {},\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\t\tcredentials: {\n\t\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\towner,\n\t\t);\n\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member]);\n\n\t\tconst response = await authAgent(owner).get('/workflows');\n\n\t\tconst [fetchedWorkflow] = response.body.data;\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(fetchedWorkflow.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(fetchedWorkflow.sharedWith).toHaveLength(1);\n\n\t\tconst [sharee] = fetchedWorkflow.sharedWith;\n\n\t\texpect(sharee).toMatchObject({\n\t\t\tid: member.id,\n\t\t\temail: member.email,\n\t\t\tfirstName: member.firstName,\n\t\t\tlastName: member.lastName,\n\t\t});\n\n\t\texpect(fetchedWorkflow.usedCredentials).toHaveLength(1);\n\n\t\tconst [usedCredential] = fetchedWorkflow.usedCredentials;\n\n\t\texpect(usedCredential).toMatchObject({\n\t\t\tid: savedCredential.id.toString(),\n\t\t\tname: savedCredential.name,\n\t\t\ttype: savedCredential.type,\n\t\t\tcurrentUserHasAccess: true,\n\t\t});\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should fail with invalid id due to route rule","suites":["GET /workflows/:id"],"updatePoint":{"line":234,"column":56},"line":234,"code":"\ttest('GET should fail with invalid id due to route rule', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst response = await authAgent(owner).get('/workflows/potatoes');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return 404 for non existing workflow","suites":["GET /workflows/:id"],"updatePoint":{"line":242,"column":54},"line":242,"code":"\ttest('GET should return 404 for non existing workflow', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst response = await authAgent(owner).get('/workflows/9001');\n\n\t\texpect(response.statusCode).toBe(404);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return a workflow with owner","suites":["GET /workflows/:id"],"updatePoint":{"line":250,"column":46},"line":250,"code":"\ttest('GET should return a workflow with owner', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\n\t\tconst response = await authAgent(owner).get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return shared workflow with user data","suites":["GET /workflows/:id"],"updatePoint":{"line":267,"column":55},"line":267,"code":"\ttest('GET should return shared workflow with user data', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member]);\n\n\t\tconst response = await authAgent(owner).get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(1);\n\t\texpect(response.body.data.sharedWith[0]).toMatchObject({\n\t\t\tid: member.id,\n\t\t\temail: member.email,\n\t\t\tfirstName: member.firstName,\n\t\t\tlastName: member.lastName,\n\t\t});\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return all sharees","suites":["GET /workflows/:id"],"updatePoint":{"line":292,"column":36},"line":292,"code":"\ttest('GET should return all sharees', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst workflow = await createWorkflow({}, owner);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member1, member2]);\n\n\t\tconst response = await authAgent(owner).get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.ownedBy).toMatchObject({\n\t\t\tid: owner.id,\n\t\t\temail: owner.email,\n\t\t\tfirstName: owner.firstName,\n\t\t\tlastName: owner.lastName,\n\t\t});\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(2);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials owned by user","suites":["GET /workflows/:id"],"updatePoint":{"line":312,"column":64},"line":312,"code":"\ttest('GET should return workflow with credentials owned by user', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, owner);\n\n\t\tconst response = await authAgent(owner).get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials saying owner has access even when not shared","suites":["GET /workflows/:id"],"updatePoint":{"line":336,"column":95},"line":336,"code":"\ttest('GET should return workflow with credentials saying owner has access even when not shared', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, owner);\n\n\t\tconst response = await authAgent(owner).get(`/workflows/${workflow.id}`);\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true, // owner has access to any cred\n\t\t\t},\n\t\t]);\n\n\t\texpect(response.body.data.sharedWith).toHaveLength(0);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials for all users with or without access","suites":["GET /workflows/:id"],"updatePoint":{"line":361,"column":87},"line":361,"code":"\ttest('GET should return workflow with credentials for all users with or without access', async () => {\n\t\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, member1);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member2]);\n\n\t\tconst responseMember1 = await authAgent(member1).get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember1.statusCode).toBe(200);\n\t\texpect(responseMember1.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true, // one user has access\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember1.body.data.sharedWith).toHaveLength(1);\n\n\t\tconst responseMember2 = await authAgent(member2).get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember2.statusCode).toBe(200);\n\t\texpect(responseMember2.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: false, // the other one doesn't\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember2.body.data.sharedWith).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET should return workflow with credentials for all users with access","suites":["GET /workflows/:id"],"updatePoint":{"line":396,"column":76},"line":396,"code":"\ttest('GET should return workflow with credentials for all users with access', async () => {\n\t\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\t\t// Both users have access to the credential (none is owner)\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member2]);\n\n\t\tconst workflowPayload = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\t\tconst workflow = await createWorkflow(workflowPayload, member1);\n\t\tawait testDb.shareWorkflowWithUsers(workflow, [member2]);\n\n\t\tconst responseMember1 = await authAgent(member1).get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember1.statusCode).toBe(200);\n\t\texpect(responseMember1.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember1.body.data.sharedWith).toHaveLength(1);\n\n\t\tconst responseMember2 = await authAgent(member2).get(`/workflows/${workflow.id}`);\n\t\texpect(responseMember2.statusCode).toBe(200);\n\t\texpect(responseMember2.body.data.usedCredentials).toMatchObject([\n\t\t\t{\n\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\tname: savedCredential.name,\n\t\t\t\tcurrentUserHasAccess: true,\n\t\t\t},\n\t\t]);\n\t\texpect(responseMember2.body.data.sharedWith).toHaveLength(1);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should create a workflow that uses no credential","suites":["POST /workflows"],"updatePoint":{"line":435,"column":53},"line":435,"code":"\tit('Should create a workflow that uses no credential', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst workflow = makeWorkflow({ withPinData: false });\n\n\t\tconst response = await authAgent(owner).post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should save a new workflow with credentials","suites":["POST /workflows"],"updatePoint":{"line":445,"column":48},"line":445,"code":"\tit('Should save a new workflow with credentials', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authAgent(owner).post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not allow saving a workflow using credential you have no access","suites":["POST /workflows"],"updatePoint":{"line":459,"column":75},"line":459,"code":"\tit('Should not allow saving a workflow using credential you have no access', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\t// Credential belongs to owner, member cannot use it.\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authAgent(member).post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(400);\n\t\texpect(response.body.message).toBe(\n\t\t\t'The workflow you are trying to save contains credentials that are not shared with you',\n\t\t);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow owner to save a workflow using credential owned by others","suites":["POST /workflows"],"updatePoint":{"line":478,"column":75},"line":478,"code":"\tit('Should allow owner to save a workflow using credential owned by others', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\t// Credential belongs to owner, member cannot use it.\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authAgent(owner).post('/workflows').send(workflow);\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow saving a workflow using a credential owned by others and shared with you","suites":["POST /workflows"],"updatePoint":{"line":494,"column":90},"line":494,"code":"\tit('Should allow saving a workflow using a credential owned by others and shared with you', async () => {\n\t\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\t\tawait testDb.shareCredentialWithUsers(savedCredential, [member2]);\n\n\t\tconst workflow = makeWorkflow({\n\t\t\twithPinData: false,\n\t\t\twithCredential: { id: savedCredential.id.toString(), name: savedCredential.name },\n\t\t});\n\n\t\tconst response = await authAgent(member2).post('/workflows').send(workflow);\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should succeed when saving unchanged workflow nodes","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":512,"column":56},"line":512,"code":"\tit('Should succeed when saving unchanged workflow nodes', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authAgent(owner).post('/workflows').send(workflow);\n\t\tconst { id, hash } = createResponse.body.data;\n\n\t\tconst response = await authAgent(owner).patch(`/workflows/${id}`).send({\n\t\t\tname: 'new name',\n\t\t\thash,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should allow owner to add node containing credential not shared with the owner","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":549,"column":83},"line":549,"code":"\tit('Should allow owner to add node containing credential not shared with the owner', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member });\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authAgent(owner).post('/workflows').send(workflow);\n\t\tconst { id, hash } = createResponse.body.data;\n\n\t\tconst response = await authAgent(owner)\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({\n\t\t\t\thash,\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\t\tname: 'Start',\n\t\t\t\t\t\tparameters: {},\n\t\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tcredentials: {\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should prevent member from adding node containing credential inaccessible to member","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":604,"column":88},"line":604,"code":"\tit('Should prevent member from adding node containing credential inaccessible to member', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: owner });\n\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst createResponse = await authAgent(owner).post('/workflows').send(workflow);\n\t\tconst { id, hash } = createResponse.body.data;\n\n\t\tconst response = await authAgent(member)\n\t\t\t.patch(`/workflows/${id}`)\n\t\t\t.send({\n\t\t\t\thash,\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\t\tname: 'Start',\n\t\t\t\t\t\tparameters: {},\n\t\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tcredentials: {},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tid: 'uuid-12345',\n\t\t\t\t\t\tname: 'Start',\n\t\t\t\t\t\tparameters: {},\n\t\t\t\t\t\tposition: [-20, 260],\n\t\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\t\tcredentials: {\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\n\t\texpect(response.statusCode).toBe(400);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should succeed but prevent modifying nodes that are read-only for the requester","suites":["PATCH /workflows/:id - validate credential permissions to user"],"updatePoint":{"line":669,"column":84},"line":669,"code":"\tit('Should succeed but prevent modifying nodes that are read-only for the requester', async () => {\n\t\tconst member1 = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst member2 = await testDb.createUser({ globalRole: globalMemberRole });\n\n\t\tconst savedCredential = await saveCredential(randomCredentialPayload(), { user: member1 });\n\n\t\tconst originalNodes: INode[] = [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tname: 'Start',\n\t\t\t\tparameters: {},\n\t\t\t\tposition: [-20, 260],\n\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tcredentials: {\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tid: savedCredential.id.toString(),\n\t\t\t\t\t\tname: savedCredential.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t];\n\n\t\tconst changedNodes: INode[] = [\n\t\t\t{\n\t\t\t\tid: 'uuid-1234',\n\t\t\t\tname: 'End',\n\t\t\t\tparameters: {},\n\t\t\t\tposition: [-20, 260],\n\t\t\t\ttype: 'n8n-nodes-base.no-op',\n\t\t\t\ttypeVersion: 1,\n\t\t\t\tcredentials: {\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tid: '200',\n\t\t\t\t\t\tname: 'fake credential',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t];\n\n\t\tconst workflow = {\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodes: originalNodes,\n\t\t};\n\n\t\tconst createResponse = await authAgent(member1).post('/workflows').send(workflow);\n\t\tconst { id, hash } = createResponse.body.data;\n\n\t\tawait authAgent(member1)\n\t\t\t.put(`/workflows/${id}/share`)\n\t\t\t.send({ shareWithIds: [member2.id] });\n\n\t\tconst response = await authAgent(member2).patch(`/workflows/${id}`).send({\n\t\t\thash,\n\t\t\tnodes: changedNodes,\n\t\t});\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body.data.nodes).toMatchObject(originalNodes);\n\t});","file":"integration/workflows.controller.ee.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should store pin data for node in workflow","suites":[],"updatePoint":{"line":42,"column":64},"line":42,"code":"test('POST /workflows should store pin data for node in workflow', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst workflow = makeWorkflow({ withPinData: true });\n\n\tconst response = await authOwnerAgent.post('/workflows').send(workflow);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { pinData } = response.body.data as { pinData: IPinData };\n\n\texpect(pinData).toMatchObject(MOCK_PINDATA);\n});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /workflows should set pin data to null if no pin data","suites":[],"updatePoint":{"line":57,"column":64},"line":57,"code":"test('POST /workflows should set pin data to null if no pin data', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst workflow = makeWorkflow({ withPinData: false });\n\n\tconst response = await authOwnerAgent.post('/workflows').send(workflow);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { pinData } = response.body.data as { pinData: IPinData };\n\n\texpect(pinData).toBeNull();\n});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /workflows/:id should return pin data","suites":[],"updatePoint":{"line":72,"column":47},"line":72,"code":"test('GET /workflows/:id should return pin data', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst workflow = makeWorkflow({ withPinData: true });\n\n\tconst workflowCreationResponse = await authOwnerAgent.post('/workflows').send(workflow);\n\n\tconst { id } = workflowCreationResponse.body.data as { id: string };\n\n\tconst workflowRetrievalResponse = await authOwnerAgent.get(`/workflows/${id}`);\n\n\texpect(workflowRetrievalResponse.statusCode).toBe(200);\n\n\tconst { pinData } = workflowRetrievalResponse.body.data as { pinData: IPinData };\n\n\texpect(pinData).toMatchObject(MOCK_PINDATA);\n});","file":"integration/workflows.controller.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should initialize activeExecutions with empty list","suites":["ActiveExecutions"],"updatePoint":{"line":39,"column":57},"line":39,"code":"\ttest('Should initialize activeExecutions with empty list', () => {\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should add execution to active execution list","suites":["ActiveExecutions"],"updatePoint":{"line":43,"column":52},"line":43,"code":"\ttest('Should add execution to active execution list', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\n\t\texpect(executionId).toBe(FAKE_EXECUTION_ID);\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(1);\n\t\texpect(mocked(Db.collections.Execution.save)).toHaveBeenCalledTimes(1);\n\t\texpect(mocked(Db.collections.Execution.update)).toHaveBeenCalledTimes(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should update execution if add is called with execution ID","suites":["ActiveExecutions"],"updatePoint":{"line":53,"column":65},"line":53,"code":"\ttest('Should update execution if add is called with execution ID', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(\n\t\t\tnewExecution,\n\t\t\tundefined,\n\t\t\tFAKE_SECOND_EXECUTION_ID,\n\t\t);\n\n\t\texpect(executionId).toBe(FAKE_SECOND_EXECUTION_ID);\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(1);\n\t\texpect(mocked(Db.collections.Execution.save)).toHaveBeenCalledTimes(0);\n\t\texpect(mocked(Db.collections.Execution.update)).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail attaching execution to invalid executionId","suites":["ActiveExecutions"],"updatePoint":{"line":67,"column":61},"line":67,"code":"\ttest('Should fail attaching execution to invalid executionId', async () => {\n\t\tconst deferredPromise = mockCancelablePromise();\n\n\t\texpect(() => {\n\t\t\tactiveExecutions.attachWorkflowExecution(FAKE_EXECUTION_ID, deferredPromise);\n\t\t}).toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should successfully attach execution to valid executionId","suites":["ActiveExecutions"],"updatePoint":{"line":75,"column":64},"line":75,"code":"\ttest('Should successfully attach execution to valid executionId', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tawait activeExecutions.add(newExecution, undefined, FAKE_EXECUTION_ID);\n\t\tconst deferredPromise = mockCancelablePromise();\n\n\t\texpect(() =>\n\t\t\tactiveExecutions.attachWorkflowExecution(FAKE_EXECUTION_ID, deferredPromise),\n\t\t).not.toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should attach and resolve response promise to existing execution","suites":["ActiveExecutions"],"updatePoint":{"line":85,"column":71},"line":85,"code":"\ttest('Should attach and resolve response promise to existing execution', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tawait activeExecutions.add(newExecution, undefined, FAKE_EXECUTION_ID);\n\t\tconst deferredPromise = await mockDeferredPromise();\n\t\tactiveExecutions.attachResponsePromise(FAKE_EXECUTION_ID, deferredPromise);\n\t\tconst fakeResponse = { data: { resultData: { runData: {} } } };\n\t\tactiveExecutions.resolveResponsePromise(FAKE_EXECUTION_ID, fakeResponse);\n\n\t\texpect(deferredPromise.promise()).resolves.toEqual(fakeResponse);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should remove an existing execution","suites":["ActiveExecutions"],"updatePoint":{"line":96,"column":42},"line":96,"code":"\ttest('Should remove an existing execution', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tactiveExecutions.remove(executionId);\n\n\t\texpect(activeExecutions.getActiveExecutions().length).toBe(0);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should resolve post execute promise on removal","suites":["ActiveExecutions"],"updatePoint":{"line":104,"column":53},"line":104,"code":"\ttest('Should resolve post execute promise on removal', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tconst postExecutePromise = activeExecutions.getPostExecutePromise(executionId);\n\t\t// Force the above to be executed since we cannot await it\n\t\tawait new Promise((res) => {\n\t\t\tsetTimeout(res, 100);\n\t\t});\n\t\tconst fakeOutput = mockFullRunData();\n\t\tactiveExecutions.remove(executionId, fakeOutput);\n\n\t\texpect(postExecutePromise).resolves.toEqual(fakeOutput);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error when trying to create a promise with invalid execution","suites":["ActiveExecutions"],"updatePoint":{"line":118,"column":80},"line":118,"code":"\ttest('Should throw error when trying to create a promise with invalid execution', async () => {\n\t\texpect(activeExecutions.getPostExecutePromise(FAKE_EXECUTION_ID)).rejects.toThrow();\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call function to cancel execution when asked to stop","suites":["ActiveExecutions"],"updatePoint":{"line":122,"column":66},"line":122,"code":"\ttest('Should call function to cancel execution when asked to stop', async () => {\n\t\tconst newExecution = mockExecutionData();\n\t\tconst executionId = await activeExecutions.add(newExecution);\n\t\tconst cancelExecution = jest.fn();\n\t\tconst cancellablePromise = mockCancelablePromise();\n\t\tcancellablePromise.cancel = cancelExecution;\n\t\tactiveExecutions.attachWorkflowExecution(executionId, cancellablePromise);\n\t\tactiveExecutions.stopExecution(executionId);\n\n\t\texpect(cancelExecution).toHaveBeenCalledTimes(1);\n\t});","file":"unit/ActiveExecutions.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail with empty package name","suites":["parsePackageName"],"updatePoint":{"line":34,"column":42},"line":34,"code":"\ttest('Should fail with empty package name', () => {\n\t\texpect(() => parseNpmPackageName('')).toThrowError();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should fail with invalid package prefix name","suites":["parsePackageName"],"updatePoint":{"line":38,"column":51},"line":38,"code":"\ttest('Should fail with invalid package prefix name', () => {\n\t\texpect(() => parseNpmPackageName('INVALID_PREFIX@123')).toThrowError();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name","suites":["parsePackageName"],"updatePoint":{"line":42,"column":38},"line":42,"code":"\ttest('Should parse valid package name', () => {\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst parsed = parseNpmPackageName(validPackageName);\n\n\t\texpect(parsed.rawString).toBe(validPackageName);\n\t\texpect(parsed.packageName).toBe(validPackageName);\n\t\texpect(parsed.scope).toBeUndefined();\n\t\texpect(parsed.version).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name and version","suites":["parsePackageName"],"updatePoint":{"line":52,"column":50},"line":52,"code":"\ttest('Should parse valid package name and version', () => {\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst validPackageVersion = '0.1.1';\n\t\tconst fullPackageName = `${validPackageName}@${validPackageVersion}`;\n\t\tconst parsed = parseNpmPackageName(fullPackageName);\n\n\t\texpect(parsed.rawString).toBe(fullPackageName);\n\t\texpect(parsed.packageName).toBe(validPackageName);\n\t\texpect(parsed.scope).toBeUndefined();\n\t\texpect(parsed.version).toBe(validPackageVersion);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse valid package name, scope and version","suites":["parsePackageName"],"updatePoint":{"line":64,"column":57},"line":64,"code":"\ttest('Should parse valid package name, scope and version', () => {\n\t\tconst validPackageScope = '@n8n';\n\t\tconst validPackageName = NODE_PACKAGE_PREFIX + 'cool-package-name';\n\t\tconst validPackageVersion = '0.1.1';\n\t\tconst fullPackageName = `${validPackageScope}/${validPackageName}@${validPackageVersion}`;\n\t\tconst parsed = parseNpmPackageName(fullPackageName);\n\n\t\texpect(parsed.rawString).toBe(fullPackageName);\n\t\texpect(parsed.packageName).toBe(`${validPackageScope}/${validPackageName}`);\n\t\texpect(parsed.scope).toBe(validPackageScope);\n\t\texpect(parsed.version).toBe(validPackageVersion);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call command with valid options","suites":["executeCommand"],"updatePoint":{"line":88,"column":45},"line":88,"code":"\ttest('Should call command with valid options', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\texpect(args[1].cwd).toBeDefined();\n\t\t\texpect(args[1].env).toBeDefined();\n\t\t\t// PATH or NODE_PATH may be undefined depending on environment so we don't check for these keys.\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toBeCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should make sure folder exists","suites":["executeCommand"],"updatePoint":{"line":104,"column":37},"line":104,"code":"\ttest('Should make sure folder exists', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toBeCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should try to create folder if it does not exist","suites":["executeCommand"],"updatePoint":{"line":117,"column":55},"line":117,"code":"\ttest('Should try to create folder if it does not exist', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(null, { stdout: 'Done' });\n\t\t});\n\n\t\t// @ts-ignore\n\t\tfsAccess.mockImplementation(() => {\n\t\t\tthrow new Error('Folder does not exist.');\n\t\t});\n\n\t\tawait executeCommand('ls');\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toHaveBeenCalled();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw especial error when package is not found","suites":["executeCommand"],"updatePoint":{"line":135,"column":60},"line":135,"code":"\ttest('Should throw especial error when package is not found', async () => {\n\t\t// @ts-ignore\n\t\texec.mockImplementation((...args) => {\n\t\t\tconst callbackFunction = args[args.length - 1];\n\t\t\tcallbackFunction(\n\t\t\t\tnew Error(\n\t\t\t\t\t'Something went wrong - ' +\n\t\t\t\t\t\tNPM_COMMAND_TOKENS.NPM_PACKAGE_NOT_FOUND_ERROR +\n\t\t\t\t\t\t'. Aborting.',\n\t\t\t\t),\n\t\t\t);\n\t\t});\n\n\t\tawait expect(async () => await executeCommand('ls')).rejects.toThrow(\n\t\t\tRESPONSE_ERROR_MESSAGES.PACKAGE_NOT_FOUND,\n\t\t);\n\n\t\texpect(fsAccess).toHaveBeenCalled();\n\t\texpect(exec).toHaveBeenCalled();\n\t\texpect(fsMkdir).toHaveBeenCalledTimes(0);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return same list if availableUpdates is undefined","suites":["crossInformationPackage"],"updatePoint":{"line":159,"column":63},"line":159,"code":"\ttest('Should return same list if availableUpdates is undefined', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages);\n\t\texpect(crossedData).toEqual(fakePackages);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should correctly match update versions for packages","suites":["crossInformationPackage"],"updatePoint":{"line":165,"column":58},"line":165,"code":"\ttest('Should correctly match update versions for packages', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\n\t\tconst updates: CommunityPackages.AvailableUpdates = {\n\t\t\t[fakePackages[0].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.2.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t\t[fakePackages[1].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.3.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t};\n\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages, updates);\n\n\t\t// @ts-ignore\n\t\texpect(crossedData[0].updateAvailable).toBe('0.2.0');\n\t\t// @ts-ignore\n\t\texpect(crossedData[1].updateAvailable).toBe('0.3.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should correctly match update versions for single package","suites":["crossInformationPackage"],"updatePoint":{"line":191,"column":64},"line":191,"code":"\ttest('Should correctly match update versions for single package', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\n\t\tconst updates: CommunityPackages.AvailableUpdates = {\n\t\t\t[fakePackages[1].packageName]: {\n\t\t\t\tcurrent: fakePackages[0].installedVersion,\n\t\t\t\twanted: fakePackages[0].installedVersion,\n\t\t\t\tlatest: '0.3.0',\n\t\t\t\tlocation: fakePackages[0].packageName,\n\t\t\t},\n\t\t};\n\n\t\tconst crossedData = matchPackagesWithUpdates(fakePackages, updates);\n\n\t\t// @ts-ignore\n\t\texpect(crossedData[0].updateAvailable).toBeUndefined();\n\t\t// @ts-ignore\n\t\texpect(crossedData[1].updateAvailable).toBe('0.3.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not match failed packages that do not exist","suites":["matchMissingPackages"],"updatePoint":{"line":213,"column":57},"line":213,"code":"\ttest('Should not match failed packages that do not exist', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${NODE_PACKAGE_PREFIX}another-very-long-name-that-never-is-seen`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages).toEqual(fakePackages);\n\t\texpect(matchedPackages[0].failedLoading).toBeUndefined();\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should match failed packages that should be present","suites":["matchMissingPackages"],"updatePoint":{"line":223,"column":58},"line":223,"code":"\ttest('Should match failed packages that should be present', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${fakePackages[0].packageName}@${fakePackages[0].installedVersion}`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages[0].failedLoading).toBe(true);\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should match failed packages even if version is wrong","suites":["matchMissingPackages"],"updatePoint":{"line":232,"column":60},"line":232,"code":"\ttest('Should match failed packages even if version is wrong', () => {\n\t\tconst fakePackages = generateListOfFakeInstalledPackages();\n\t\tconst notFoundPackageList = `${NODE_PACKAGE_PREFIX}very-long-name-that-should-never-be-generated@1.0.0 ${fakePackages[0].packageName}@123.456.789`;\n\t\tconst matchedPackages = matchMissingPackages(fakePackages, notFoundPackageList);\n\n\t\texpect(matchedPackages[0].failedLoading).toBe(true);\n\t\texpect(matchedPackages[1].failedLoading).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should call axios.post","suites":["checkNpmPackageStatus"],"updatePoint":{"line":243,"column":29},"line":243,"code":"\ttest('Should call axios.post', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\tawait checkNpmPackageStatus(packageName);\n\t\texpect(axios.post).toHaveBeenCalled();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not fail if request fails","suites":["checkNpmPackageStatus"],"updatePoint":{"line":249,"column":39},"line":249,"code":"\ttest('Should not fail if request fails', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\taxios.post = jest.fn(() => {\n\t\t\tthrow new Error('Something went wrong');\n\t\t});\n\t\tconst result = await checkNpmPackageStatus(packageName);\n\t\texpect(result.status).toBe(NPM_PACKAGE_STATUS_GOOD);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should warn if package is banned","suites":["checkNpmPackageStatus"],"updatePoint":{"line":258,"column":39},"line":258,"code":"\ttest('Should warn if package is banned', async () => {\n\t\tconst packageName = NODE_PACKAGE_PREFIX + randomName();\n\t\t// @ts-ignore\n\t\taxios.post = jest.fn(() => {\n\t\t\treturn { data: { status: 'Banned', reason: 'Not good' } };\n\t\t});\n\t\tconst result = await checkNpmPackageStatus(packageName);\n\t\texpect(result.status).toBe('Banned');\n\t\texpect(result.reason).toBe('Not good');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return true when failed package list does not exist","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":271,"column":65},"line":271,"code":"\ttest('Should return true when failed package list does not exist', () => {\n\t\tconfig.set('nodes.packagesMissing', undefined);\n\t\tconst result = hasPackageLoaded('package');\n\t\texpect(result).toBe(true);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return true when package is not in the list of missing packages","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":277,"column":77},"line":277,"code":"\ttest('Should return true when package is not in the list of missing packages', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packgeB@0.1.0');\n\t\tconst result = hasPackageLoaded('packageC');\n\t\texpect(result).toBe(true);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return false when package is in the list of missing packages","suites":["hasPackageLoadedSuccessfully"],"updatePoint":{"line":283,"column":74},"line":283,"code":"\ttest('Should return false when package is in the list of missing packages', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packgeB@0.1.0');\n\t\tconst result = hasPackageLoaded('packageA');\n\t\texpect(result).toBe(false);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should do nothing if key does not exist","suites":["removePackageFromMissingList"],"updatePoint":{"line":291,"column":46},"line":291,"code":"\ttest('Should do nothing if key does not exist', () => {\n\t\tconfig.set('nodes.packagesMissing', undefined);\n\n\t\tremovePackageFromMissingList('packageA');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBeUndefined();\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should remove only correct package from list","suites":["removePackageFromMissingList"],"updatePoint":{"line":300,"column":51},"line":300,"code":"\ttest('Should remove only correct package from list', () => {\n\t\tconfig.set('nodes.packagesMissing', 'packageA@0.1.0 packageB@0.2.0 packageBB@0.2.0');\n\n\t\tremovePackageFromMissingList('packageB');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBe('packageA@0.1.0 packageBB@0.2.0');\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not remove if package is not in the list","suites":["removePackageFromMissingList"],"updatePoint":{"line":309,"column":54},"line":309,"code":"\ttest('Should not remove if package is not in the list', () => {\n\t\tconst failedToLoadList = 'packageA@0.1.0 packageB@0.2.0 packageBB@0.2.0';\n\t\tconfig.set('nodes.packagesMissing', failedToLoadList);\n\n\t\tremovePackageFromMissingList('packageC');\n\n\t\tconst packageList = config.get('nodes.packagesMissing');\n\t\texpect(packageList).toBe(failedToLoadList);\n\t});","file":"unit/CommunityNodeHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error when calling invalid credential name","suites":["ActiveExecutions"],"updatePoint":{"line":11,"column":62},"line":11,"code":"\ttest('Should throw error when calling invalid credential name', () => {\n\t\texpect(() => credentialTypes.getByName('fakeThirdCredential')).toThrowError();\n\t});","file":"unit/CredentialTypes.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return correct credential type for valid name","suites":["ActiveExecutions"],"updatePoint":{"line":15,"column":59},"line":15,"code":"\ttest('Should return correct credential type for valid name', () => {\n\t\tconst mockedCredentialTypes = mockNodesAndCredentials().loaded.credentials;\n\t\texpect(credentialTypes.getByName('fakeFirstCredential')).toStrictEqual(\n\t\t\tmockedCredentialTypes.fakeFirstCredential.type,\n\t\t);\n\t});","file":"unit/CredentialTypes.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse form-urlencoded content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":4,"column":58},"line":4,"code":"\ttest('Should parse form-urlencoded content type correctly', () => {\n\t\tconst curl =\n\t\t\t'curl -X POST https://reqbin.com/echo/post/form -H \"Content-Type: application/x-www-form-urlencoded\" -d \"param1=value1&param2=value2\"';\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/form');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('param1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('param2');\n\t\texpect(parameters.bodyParameters?.parameters[1].value).toBe('value2');\n\t\texpect(parameters.contentType).toBe('form-urlencoded');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse JSON content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":19,"column":47},"line":19,"code":"\ttest('Should parse JSON content type correctly', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo/post/json -H 'Content-Type: application/json' -d '{\"login\":\"my_login\",\"password\":\"my_password\"}'`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('login');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('my_login');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('password');\n\t\texpect(parameters.bodyParameters?.parameters[1].value).toBe('my_password');\n\t\texpect(parameters.contentType).toBe('json');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse multipart-form-data content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":33,"column":62},"line":33,"code":"\ttest('Should parse multipart-form-data content type correctly', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo/post/json -v -F key1=value1 -F upload=@localfilename`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].parameterType).toBe('formData');\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('key1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].parameterType).toBe('formBinaryData');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('upload');\n\t\texpect(parameters.contentType).toBe('multipart-form-data');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse binary request correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":48,"column":44},"line":48,"code":"\ttest('Should parse binary request correctly', () => {\n\t\tconst curl = `curl --location --request POST 'https://www.website.com' --header 'Content-Type: image/png' --data-binary '@/Users/image.png`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://www.website.com');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.contentType).toBe('binaryData');\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse unknown content type correctly","suites":["CurlConverterHelper"],"updatePoint":{"line":59,"column":50},"line":59,"code":"\ttest('Should parse unknown content type correctly', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo/post/xml\n\t\t-H \"Content-Type: application/xml\"\n\t\t-H \"Accept: application/xml\"\n\t\t-d \"<Request><Login>my_login</Login><Password>my_password</Password></Request>\"`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/xml');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.contentType).toBe('raw');\n\t\texpect(parameters.rawContentType).toBe('application/xml');\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('Accept');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe('application/xml');\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse header properties and keep the original case","suites":["CurlConverterHelper"],"updatePoint":{"line":76,"column":64},"line":76,"code":"\ttest('Should parse header properties and keep the original case', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo/post/json -v -F key1=value1 -F upload=@localfilename -H \"ACCEPT: text/javascript\" -H \"content-type: multipart/form-data\"`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo/post/json');\n\t\texpect(parameters.sendBody).toBe(true);\n\t\texpect(parameters.bodyParameters?.parameters[0].parameterType).toBe('formData');\n\t\texpect(parameters.bodyParameters?.parameters[0].name).toBe('key1');\n\t\texpect(parameters.bodyParameters?.parameters[0].value).toBe('value1');\n\t\texpect(parameters.bodyParameters?.parameters[1].parameterType).toBe('formBinaryData');\n\t\texpect(parameters.bodyParameters?.parameters[1].name).toBe('upload');\n\t\texpect(parameters.contentType).toBe('multipart-form-data');\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('ACCEPT');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe('text/javascript');\n\t\texpect(parameters.sendQuery).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse querystring properties","suites":["CurlConverterHelper"],"updatePoint":{"line":93,"column":42},"line":93,"code":"\ttest('Should parse querystring properties', () => {\n\t\tconst curl = `curl -G -d 'q=kitties' -d 'count=20' https://google.com/search`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://google.com/search');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendHeaders).toBe(false);\n\t\texpect(parameters.sendQuery).toBe(true);\n\t\texpect(parameters.queryParameters?.parameters[0].name).toBe('q');\n\t\texpect(parameters.queryParameters?.parameters[0].value).toBe('kitties');\n\t\texpect(parameters.queryParameters?.parameters[1].name).toBe('count');\n\t\texpect(parameters.queryParameters?.parameters[1].value).toBe('20');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse basic authentication property and keep the original case","suites":["CurlConverterHelper"],"updatePoint":{"line":107,"column":76},"line":107,"code":"\ttest('Should parse basic authentication property and keep the original case', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\"`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location flag with --location","suites":["CurlConverterHelper"],"updatePoint":{"line":121,"column":49},"line":121,"code":"\ttest('Should parse location flag with --location', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" --location`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location flag with --L","suites":["CurlConverterHelper"],"updatePoint":{"line":136,"column":42},"line":136,"code":"\ttest('Should parse location flag with --L', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" -L`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse location and max redirects flags with --location and --max-redirs 10","suites":["CurlConverterHelper"],"updatePoint":{"line":151,"column":88},"line":151,"code":"\ttest('Should parse location and max redirects flags with --location and --max-redirs 10', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" --location --max-redirs 10`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.redirect.redirect.followRedirects).toBe(true);\n\t\texpect(parameters.options.redirect.redirect.maxRedirects).toBe('10');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse proxy flag -x","suites":["CurlConverterHelper"],"updatePoint":{"line":167,"column":33},"line":167,"code":"\ttest('Should parse proxy flag -x', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" -x https://google.com`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.proxy).toBe('https://google.com');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse proxy flag --proxy","suites":["CurlConverterHelper"],"updatePoint":{"line":182,"column":38},"line":182,"code":"\ttest('Should parse proxy flag --proxy', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" -x https://google.com`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.proxy).toBe('https://google.com');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include headers on output flag --include","suites":["CurlConverterHelper"],"updatePoint":{"line":197,"column":60},"line":197,"code":"\ttest('Should parse include headers on output flag --include', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" --include -x https://google.com`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.response.response.fullResponse).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include headers on output flag -i","suites":["CurlConverterHelper"],"updatePoint":{"line":212,"column":53},"line":212,"code":"\ttest('Should parse include headers on output flag -i', () => {\n\t\tconst curl = `curl https://reqbin.com/echo -u \"login:password\" -x https://google.com -i`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.contentType).toBeUndefined();\n\t\texpect(parameters.sendQuery).toBe(false);\n\t\texpect(parameters.sendHeaders).toBe(true);\n\t\texpect(parameters.headerParameters?.parameters[0].name).toBe('authorization');\n\t\texpect(parameters.headerParameters?.parameters[0].value).toBe(\n\t\t\t`Basic ${Buffer.from('login:password').toString('base64')}`,\n\t\t);\n\t\texpect(parameters.options.response.response.fullResponse).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include request flag -X","suites":["CurlConverterHelper"],"updatePoint":{"line":227,"column":43},"line":227,"code":"\ttest('Should parse include request flag -X', () => {\n\t\tconst curl = `curl -X POST https://reqbin.com/echo -u \"login:password\" -x https://google.com`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include request flag --request","suites":["CurlConverterHelper"],"updatePoint":{"line":235,"column":50},"line":235,"code":"\ttest('Should parse include request flag --request', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" -x https://google.com`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse include timeout flag --connect-timeout","suites":["CurlConverterHelper"],"updatePoint":{"line":243,"column":58},"line":243,"code":"\ttest('Should parse include timeout flag --connect-timeout', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" --connect-timeout 20`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.timeout).toBe(20000);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse download file flag -O","suites":["CurlConverterHelper"],"updatePoint":{"line":252,"column":41},"line":252,"code":"\ttest('Should parse download file flag -O', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" -O`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.response.response.responseFormat).toBe('file');\n\t\texpect(parameters.options.response.response.outputPropertyName).toBe('data');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse download file flag -o","suites":["CurlConverterHelper"],"updatePoint":{"line":262,"column":41},"line":262,"code":"\ttest('Should parse download file flag -o', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" -o`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.response.response.responseFormat).toBe('file');\n\t\texpect(parameters.options.response.response.outputPropertyName).toBe('data');\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse ignore SSL flag -k","suites":["CurlConverterHelper"],"updatePoint":{"line":272,"column":38},"line":272,"code":"\ttest('Should parse ignore SSL flag -k', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" -k`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.allowUnauthorizedCerts).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should parse ignore SSL flag --insecure","suites":["CurlConverterHelper"],"updatePoint":{"line":281,"column":46},"line":281,"code":"\ttest('Should parse ignore SSL flag --insecure', () => {\n\t\tconst curl = `curl --request POST https://reqbin.com/echo -u \"login:password\" --insecure`;\n\t\tconst parameters = toHttpNodeParameters(curl);\n\t\texpect(parameters.url).toBe('https://reqbin.com/echo');\n\t\texpect(parameters.method).toBe('POST');\n\t\texpect(parameters.sendBody).toBe(false);\n\t\texpect(parameters.options.allowUnauthorizedCerts).toBe(true);\n\t});","file":"unit/CurlConverterHelper.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"initializes license manager","suites":["License"],"updatePoint":{"line":28,"column":34},"line":28,"code":"\ttest('initializes license manager', async () => {\n\t\texpect(LicenseManager).toHaveBeenCalledWith({\n\t\t\tautoRenewEnabled: true,\n\t\t\tautoRenewOffset: MOCK_RENEW_OFFSET,\n\t\t\tdeviceFingerprint: expect.any(Function),\n\t\t\tproductIdentifier: `n8n-${MOCK_N8N_VERSION}`,\n\t\t\tlogger: expect.anything(),\n\t\t\tloadCertStr: expect.any(Function),\n\t\t\tsaveCertStr: expect.any(Function),\n\t\t\tserver: MOCK_SERVER_URL,\n\t\t\ttenantId: 1,\n\t\t});\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"activates license if current license is not valid","suites":["License"],"updatePoint":{"line":42,"column":56},"line":42,"code":"\ttest('activates license if current license is not valid', async () => {\n\t\tLicenseManager.prototype.isValid.mockReturnValue(false);\n\n\t\tawait license.activate(MOCK_ACTIVATION_KEY);\n\n\t\texpect(LicenseManager.prototype.isValid).toHaveBeenCalled();\n\t\texpect(LicenseManager.prototype.activate).toHaveBeenCalledWith(MOCK_ACTIVATION_KEY);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"does not activate license if current license is valid","suites":["License"],"updatePoint":{"line":51,"column":60},"line":51,"code":"\ttest('does not activate license if current license is valid', async () => {\n\t\tLicenseManager.prototype.isValid.mockReturnValue(true);\n\n\t\tawait license.activate(MOCK_ACTIVATION_KEY);\n\n\t\texpect(LicenseManager.prototype.isValid).toHaveBeenCalled();\n\t\texpect(LicenseManager.prototype.activate).not.toHaveBeenCalledWith();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"renews license","suites":["License"],"updatePoint":{"line":60,"column":21},"line":60,"code":"\ttest('renews license', async () => {\n\t\tawait license.renew();\n\n\t\texpect(LicenseManager.prototype.renew).toHaveBeenCalled();\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check if feature is enabled","suites":["License"],"updatePoint":{"line":66,"column":34},"line":66,"code":"\ttest('check if feature is enabled', async () => {\n\t\tawait license.isFeatureEnabled(MOCK_FEATURE_FLAG);\n\n\t\texpect(LicenseManager.prototype.hasFeatureEnabled).toHaveBeenCalledWith(MOCK_FEATURE_FLAG);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"check if sharing feature is enabled","suites":["License"],"updatePoint":{"line":72,"column":42},"line":72,"code":"\ttest('check if sharing feature is enabled', async () => {\n\t\tawait license.isFeatureEnabled(MOCK_FEATURE_FLAG);\n\n\t\texpect(LicenseManager.prototype.hasFeatureEnabled).toHaveBeenCalledWith(MOCK_FEATURE_FLAG);\n\t});","file":"unit/License.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if workflow has no creds","suites":["PermissionChecker.check()"],"updatePoint":{"line":50,"column":44},"line":50,"code":"\ttest('should allow if workflow has no creds', async () => {\n\t\tconst userId = uuid();\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Start',\n\t\t\t\t\ttype: 'n8n-nodes-base.start',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tparameters: {},\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(() => PermissionChecker.check(workflow, userId)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if requesting user is instance owner","suites":["PermissionChecker.check()"],"updatePoint":{"line":74,"column":56},"line":74,"code":"\ttest('should allow if requesting user is instance owner', async () => {\n\t\tconst owner = await testDb.createOwner();\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: randomPositiveDigit().toString(),\n\t\t\t\t\t\t\tname: 'Action Network Account',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(async () => await PermissionChecker.check(workflow, owner.id)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should allow if workflow creds are valid subset","suites":["PermissionChecker.check()"],"updatePoint":{"line":104,"column":54},"line":104,"code":"\ttest('should allow if workflow creds are valid subset', async () => {\n\t\tconst [owner, member] = await Promise.all([testDb.createOwner(), testDb.createUser()]);\n\n\t\tconst ownerCred = await saveCredential(randomCred(), { user: owner });\n\t\tconst memberCred = await saveCredential(randomCred(), { user: member });\n\n\t\tconst workflow = new Workflow({\n\t\t\tid: randomPositiveDigit().toString(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: ownerCred.id.toString(),\n\t\t\t\t\t\t\tname: ownerCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network 2',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: memberCred.id.toString(),\n\t\t\t\t\t\t\tname: memberCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\texpect(async () => await PermissionChecker.check(workflow, owner.id)).not.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should deny if workflow creds are not valid subset","suites":["PermissionChecker.check()"],"updatePoint":{"line":151,"column":57},"line":151,"code":"\ttest('should deny if workflow creds are not valid subset', async () => {\n\t\tconst member = await testDb.createUser();\n\n\t\tconst memberCred = await saveCredential(randomCred(), { user: member });\n\n\t\tconst workflowDetails = {\n\t\t\tid: randomPositiveDigit(),\n\t\t\tname: 'test',\n\t\t\tactive: false,\n\t\t\tconnections: {},\n\t\t\tnodeTypes: mockNodeTypes,\n\t\t\tnodes: [\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: memberCred.id.toString(),\n\t\t\t\t\t\t\tname: memberCred.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: uuid(),\n\t\t\t\t\tname: 'Action Network 2',\n\t\t\t\t\ttype: 'n8n-nodes-base.actionNetwork',\n\t\t\t\t\tparameters: {},\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [0, 0] as [number, number],\n\t\t\t\t\tcredentials: {\n\t\t\t\t\t\tactionNetworkApi: {\n\t\t\t\t\t\t\tid: 'non-existing-credential-id',\n\t\t\t\t\t\t\tname: 'Non-existing credential name',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst workflowEntity = await Db.collections.Workflow.save(workflowDetails);\n\n\t\tawait Db.collections.SharedWorkflow.save({\n\t\t\tworkflow: workflowEntity,\n\t\t\tuser: member,\n\t\t\trole: workflowOwnerRole,\n\t\t});\n\n\t\tconst workflow = new Workflow({ ...workflowDetails, id: workflowDetails.id.toString() });\n\n\t\texpect(PermissionChecker.check(workflow, member.id)).rejects.toThrow();\n\t});","file":"unit/PermissionChecker.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should call track method","suites":["Telemetry","trackN8nStop"],"updatePoint":{"line":48,"column":32},"line":48,"code":"\t\ttest('should call track method', () => {\n\t\t\ttelemetry.trackN8nStop();\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should count executions correctly","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":59,"column":41},"line":59,"code":"\t\ttest('should count executions correctly', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: true,\n\t\t\t\tsuccess: true,\n\t\t\t\terror_node_type: 'custom-nodes-base.node-type',\n\t\t\t};\n\n\t\t\tpayload.is_manual = true;\n\t\t\tpayload.success = true;\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = true;\n\t\t\tconst execTime2 = fakeJestSystemTime('2022-01-01 13:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = true;\n\t\t\tpayload.success = false;\n\t\t\tconst execTime3 = fakeJestSystemTime('2022-01-01 14:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = false;\n\t\t\tconst execTime4 = fakeJestSystemTime('2022-01-01 15:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\tconst execBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime3);\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime4);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should fire \"Workflow execution errored\" event for failed executions","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":109,"column":76},"line":109,"code":"\t\ttest('should fire \"Workflow execution errored\" event for failed executions', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: true,\n\t\t\t\tsuccess: false,\n\t\t\t\terror_node_type: 'custom-nodes-base.node-type',\n\t\t\t};\n\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tlet execBuffer = telemetry.getCountsBuffer();\n\n\t\t\t// should not fire event for custom nodes\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime1);\n\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.node-type';\n\t\t\tfakeJestSystemTime('2022-01-01 13:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tfakeJestSystemTime('2022-01-01 12:30:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\t// should fire event for custom nodes\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(2);\n\t\t\texpect(spyTrack).toHaveBeenCalledWith('Workflow execution errored', payload);\n\t\t\texpect(execBuffer['1'].manual_error?.count).toBe(4);\n\t\t\texpect(execBuffer['1'].manual_error?.first).toEqual(execTime1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should track production executions count correctly","suites":["Telemetry","trackWorkflowExecution"],"updatePoint":{"line":144,"column":58},"line":144,"code":"\t\ttest('should track production executions count correctly', async () => {\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: false,\n\t\t\t\tsuccess: true,\n\t\t\t\terror_node_type: 'node_type',\n\t\t\t};\n\n\t\t\t// successful execution\n\t\t\tconst execTime1 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\tlet execBuffer = telemetry.getCountsBuffer();\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(1);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// successful execution n8n node\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '2';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(1);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(1);\n\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// additional successful execution\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '2';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tpayload.workflow_id = '1';\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// failed execution\n\t\t\tconst execTime2 = fakeJestSystemTime('2022-01-01 12:00:00');\n\t\t\tpayload.error_node_type = 'custom-package.custom-node';\n\t\t\tpayload.success = false;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(1);\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\n\t\t\t// failed execution n8n node\n\t\t\tpayload.success = false;\n\t\t\tpayload.error_node_type = 'n8n-nodes-base.merge';\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(1);\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(execBuffer['1'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_error).toBeUndefined();\n\t\t\texpect(execBuffer['2'].manual_success).toBeUndefined();\n\t\t\texpect(execBuffer['2'].prod_error).toBeUndefined();\n\t\t\texpect(execBuffer['1'].prod_success?.count).toBe(2);\n\t\t\texpect(execBuffer['1'].prod_error?.count).toBe(2);\n\t\t\texpect(execBuffer['2'].prod_success?.count).toBe(2);\n\n\t\t\texpect(execBuffer['1'].prod_error?.first).toEqual(execTime2);\n\t\t\texpect(execBuffer['1'].prod_success?.first).toEqual(execTime1);\n\t\t\texpect(execBuffer['2'].prod_success?.first).toEqual(execTime1);\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should trigger pulse in intervals","suites":["Telemetry","pulse"],"updatePoint":{"line":276,"column":41},"line":276,"code":"\t\ttest('should trigger pulse in intervals', () => {\n\t\t\texpect(pulseSpy).toBeCalledTimes(0);\n\n\t\t\tjest.advanceTimersToNextTimer();\n\n\t\t\texpect(pulseSpy).toBeCalledTimes(1);\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(1);\n\t\t\texpect(spyTrack).toHaveBeenCalledWith('pulse');\n\n\t\t\tjest.advanceTimersToNextTimer();\n\n\t\t\texpect(pulseSpy).toBeCalledTimes(2);\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(2);\n\t\t\texpect(spyTrack).toHaveBeenCalledWith('pulse');\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should track workflow counts correctly","suites":["Telemetry","pulse"],"updatePoint":{"line":292,"column":46},"line":292,"code":"\t\ttest('should track workflow counts correctly', async () => {\n\t\t\texpect(pulseSpy).toBeCalledTimes(0);\n\n\t\t\tlet execBuffer = telemetry.getCountsBuffer();\n\n\t\t\t// expect clear counters on start\n\t\t\texpect(Object.keys(execBuffer).length).toBe(0);\n\n\t\t\tconst payload = {\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tis_manual: true,\n\t\t\t\tsuccess: true,\n\t\t\t\terror_node_type: 'custom-nodes-base.node-type',\n\t\t\t};\n\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = true;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = true;\n\t\t\tpayload.success = false;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.is_manual = false;\n\t\t\tpayload.success = false;\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\tpayload.workflow_id = '2';\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\t\t\tawait telemetry.trackWorkflowExecution(payload);\n\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(0);\n\t\t\texpect(pulseSpy).toBeCalledTimes(0);\n\n\t\t\tjest.advanceTimersToNextTimer();\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\n\t\t\texpect(pulseSpy).toBeCalledTimes(1);\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(3);\n\t\t\texpect(spyTrack).toHaveBeenNthCalledWith(1, 'Workflow execution count', {\n\t\t\t\tevent_version: '2',\n\t\t\t\tworkflow_id: '1',\n\t\t\t\tmanual_error: {\n\t\t\t\t\tcount: 2,\n\t\t\t\t\tfirst: testDateTime,\n\t\t\t\t},\n\t\t\t\tmanual_success: {\n\t\t\t\t\tcount: 2,\n\t\t\t\t\tfirst: testDateTime,\n\t\t\t\t},\n\t\t\t\tprod_error: {\n\t\t\t\t\tcount: 2,\n\t\t\t\t\tfirst: testDateTime,\n\t\t\t\t},\n\t\t\t\tprod_success: {\n\t\t\t\t\tcount: 2,\n\t\t\t\t\tfirst: testDateTime,\n\t\t\t\t},\n\t\t\t});\n\t\t\texpect(spyTrack).toHaveBeenNthCalledWith(2, 'Workflow execution count', {\n\t\t\t\tevent_version: '2',\n\t\t\t\tworkflow_id: '2',\n\t\t\t\tprod_error: {\n\t\t\t\t\tcount: 2,\n\t\t\t\t\tfirst: testDateTime,\n\t\t\t\t},\n\t\t\t});\n\t\t\texpect(spyTrack).toHaveBeenNthCalledWith(3, 'pulse');\n\t\t\texpect(Object.keys(execBuffer).length).toBe(0);\n\n\t\t\tjest.advanceTimersToNextTimer();\n\n\t\t\texecBuffer = telemetry.getCountsBuffer();\n\t\t\texpect(Object.keys(execBuffer).length).toBe(0);\n\n\t\t\texpect(pulseSpy).toBeCalledTimes(2);\n\t\t\texpect(spyTrack).toHaveBeenCalledTimes(4);\n\t\t\texpect(spyTrack).toHaveBeenNthCalledWith(4, 'pulse');\n\t\t});","file":"unit/Telemetry.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an error if any node has no credential ID","suites":["WorkflowCredentials"],"updatePoint":{"line":51,"column":62},"line":51,"code":"\ttest('Should return an error if any node has no credential ID', () => {\n\t\tconst credentials = noIdNode.credentials!!.test;\n\t\tconst expectedError = new Error(\n\t\t\t`Credentials with name \"${credentials.name}\" for type \"test\" miss an ID.`,\n\t\t);\n\t\texpect(WorkflowCredentials([noIdNode])).rejects.toEqual(expectedError);\n\t\texpect(mocked(Db.collections.Credentials.findOne)).toHaveBeenCalledTimes(0);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an error if credentials cannot be found in the DB","suites":["WorkflowCredentials"],"updatePoint":{"line":60,"column":70},"line":60,"code":"\ttest('Should return an error if credentials cannot be found in the DB', () => {\n\t\tconst credentials = notFoundNode.credentials!!.test;\n\t\tconst expectedError = new Error(\n\t\t\t`Could not find credentials for type \"test\" with ID \"${credentials.id}\".`,\n\t\t);\n\t\texpect(WorkflowCredentials([notFoundNode])).rejects.toEqual(expectedError);\n\t\texpect(mocked(Db.collections.Credentials.findOne)).toHaveBeenCalledTimes(1);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should ignore duplicates","suites":["WorkflowCredentials"],"updatePoint":{"line":69,"column":31},"line":69,"code":"\ttest('Should ignore duplicates', async () => {\n\t\tconst response = await WorkflowCredentials([validNode, validNode, validNode]);\n\t\texpect(Object.keys(response)).toEqual(['test']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should ignore Nodes with no credentials set","suites":["WorkflowCredentials"],"updatePoint":{"line":74,"column":50},"line":74,"code":"\ttest('Should ignore Nodes with no credentials set', async () => {\n\t\tconst response = await WorkflowCredentials([validNode, noCredentialsNode]);\n\t\texpect(Object.keys(response)).toEqual(['test']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should work for Nodes with multiple credentials","suites":["WorkflowCredentials"],"updatePoint":{"line":79,"column":54},"line":79,"code":"\ttest('Should work for Nodes with multiple credentials', async () => {\n\t\tconst response = await WorkflowCredentials([multiCredNode]);\n\t\texpect(Object.keys(response)).toEqual(['mcTest', 'mcTest2']);\n\t});","file":"unit/WorkflowCredentials.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a workflow without nodes","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":21,"column":64},"line":21,"code":"\t\ttest('Should return an empty list for a workflow without nodes', () => {\n\t\t\tconst workflow = getWorkflow();\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a workflow with nodes without credentials","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":27,"column":81},"line":27,"code":"\t\ttest('Should return an empty list for a workflow with nodes without credentials', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithoutCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an element for a node with a credential without access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":33,"column":76},"line":33,"code":"\t\ttest('Should return an element for a node with a credential without access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an empty list for a node with a credential with access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":39,"column":76},"line":39,"code":"\t\ttest('Should return an empty list for a node with a credential with access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(0);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return an element for a node with two credentials and mixed access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":47,"column":81},"line":47,"code":"\t\ttest('Should return an element for a node with two credentials and mixed access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one node for a workflow with two nodes and two credentials","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":55,"column":80},"line":55,"code":"\t\ttest('Should return one node for a workflow with two nodes and two credentials', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t\tTHIRD_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one element for a workflows with two nodes and one credential","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":64,"column":83},"line":64,"code":"\t\ttest('Should return one element for a workflows with two nodes and one credential', () => {\n\t\t\tconst workflow = getWorkflow({\n\t\t\t\taddNodeWithoutCreds: true,\n\t\t\t\taddNodeWithOneCred: true,\n\t\t\t\taddNodeWithTwoCreds: true,\n\t\t\t});\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return one element for a workflows with two nodes and partial credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":76,"column":94},"line":76,"code":"\t\ttest('Should return one element for a workflows with two nodes and partial credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tFIRST_CREDENTIAL_ID,\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(1);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return two elements for a workflows with two nodes and partial credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":85,"column":95},"line":85,"code":"\t\ttest('Should return two elements for a workflows with two nodes and partial credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, [\n\t\t\t\tSECOND_CREDENTIAL_ID,\n\t\t\t]);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(2);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should return two elements for a workflows with two nodes and no credential access","suites":["WorkflowHelpers","getNodesWithInaccessibleCreds"],"updatePoint":{"line":93,"column":90},"line":93,"code":"\t\ttest('Should return two elements for a workflows with two nodes and no credential access', () => {\n\t\t\tconst workflow = getWorkflow({ addNodeWithOneCred: true, addNodeWithTwoCreds: true });\n\t\t\tconst nodesWithInaccessibleCreds = getNodesWithInaccessibleCreds(workflow, []);\n\t\t\texpect(nodesWithInaccessibleCreds).toHaveLength(2);\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error saving a workflow using credential without access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":101,"column":74},"line":101,"code":"\t\tit('Should throw error saving a workflow using credential without access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst previousWorkflowVersion = getWorkflow();\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, []);\n\t\t\t}).toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not throw error when saving a workflow using credential with access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":109,"column":80},"line":109,"code":"\t\tit('Should not throw error when saving a workflow using credential with access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\tconst previousWorkflowVersion = getWorkflow();\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, [\n\t\t\t\t\tgenerateCredentialEntity(FIRST_CREDENTIAL_ID),\n\t\t\t\t]);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should not throw error when saving a workflow removing node without credential access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":119,"column":91},"line":119,"code":"\t\tit('Should not throw error when saving a workflow removing node without credential access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow();\n\t\t\tconst previousWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, [\n\t\t\t\t\tgenerateCredentialEntity(FIRST_CREDENTIAL_ID),\n\t\t\t\t]);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should save fine when not making changes to workflow without access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":129,"column":73},"line":129,"code":"\t\tit('Should save fine when not making changes to workflow without access', () => {\n\t\t\tconst workflowWithOneCredential = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(workflowWithOneCredential, workflowWithOneCredential, []);\n\t\t\t}).not.toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"Should throw error saving a workflow adding node without credential access","suites":["WorkflowHelpers","validateWorkflowCredentialUsage"],"updatePoint":{"line":136,"column":80},"line":136,"code":"\t\tit('Should throw error saving a workflow adding node without credential access', () => {\n\t\t\tconst newWorkflowVersion = getWorkflow({\n\t\t\t\taddNodeWithOneCred: true,\n\t\t\t\taddNodeWithTwoCreds: true,\n\t\t\t});\n\t\t\tconst previousWorkflowVersion = getWorkflow({ addNodeWithOneCred: true });\n\t\t\texpect(() => {\n\t\t\t\tvalidateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, []);\n\t\t\t}).toThrow();\n\t\t});","file":"unit/WorkflowHelpers.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":5,"column":72},"line":5,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', []);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\t// const nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data with initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":18,"column":69},"line":18,"code":"\t\ttest('should be able to set and read key data with initial data set', () => {\n\t\t\tconst key = 'key2';\n\t\t\tconst password = 'password';\n\n\t\t\t// Saved under \"key1\"\n\t\t\tconst initialData = 4321;\n\t\t\tconst initialDataEncoded = 'U2FsdGVkX1+0baznXt+Ag/ub8A2kHLyoLxn/rR9h4XQ=';\n\n\t\t\tconst credentials = new Credentials(\n\t\t\t\t{ id: null, name: 'testName' },\n\t\t\t\t'testType',\n\t\t\t\t[],\n\t\t\t\tinitialDataEncoded,\n\t\t\t);\n\n\t\t\tconst newData = 1234;\n\n\t\t\t// Set and read new data\n\t\t\tcredentials.setDataKey(key, newData, password);\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\n\t\t\t// Read the data which got provided encrypted on init\n\t\t\texpect(credentials.getDataKey('key1', password)).toEqual(initialData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","with nodeType set"],"updatePoint":{"line":45,"column":72},"line":45,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst nodeAccess = [\n\t\t\t\t{\n\t\t\t\t\tnodeType: 'base.noOp',\n\t\t\t\t\tuser: 'userName',\n\t\t\t\t\tdate: new Date(),\n\t\t\t\t},\n\t\t\t];\n\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', nodeAccess);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\tconst nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\t// Should be able to read with nodeType which has access\n\t\t\texpect(credentials.getDataKey(key, password, nodeType)).toEqual(newData);\n\n\t\t\t// Should not be able to read with nodeType which does NOT have access\n\t\t\t// expect(credentials.getDataKey(key, password, 'base.otherNode')).toThrowError(Error);\n\t\t\ttry {\n\t\t\t\tcredentials.getDataKey(key, password, 'base.otherNode');\n\t\t\t\texpect(true).toBe(false);\n\t\t\t} catch (e) {\n\t\t\t\texpect(e.message).toBe(\n\t\t\t\t\t'The node of type \"base.otherNode\" does not have access to credentials \"testName\" of type \"testType\".',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get the data which will be saved in database\n\t\t\tconst dbData = credentials.getDataToSave();\n\t\t\texpect(dbData.name).toEqual('testName');\n\t\t\texpect(dbData.type).toEqual('testType');\n\t\t\texpect(dbData.nodesAccess).toEqual(nodeAccess);\n\t\t\t// Compare only the first 6 characters as the rest seems to change with each execution\n\t\t\texpect(dbData.data!.slice(0, 6)).toEqual(\n\t\t\t\t'U2FsdGVkX1+wpQWkj+YTzaPSNTFATjnlmFKIsUTZdhk='.slice(0, 6),\n\t\t\t);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'default' mode","suites":["NodeExecuteFunctions","test binary data helper methods"],"updatePoint":{"line":18,"column":90},"line":18,"code":"\t\ttest(`test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'default' mode`, async () => {\n\t\t\t// Setup a 'default' binary data manager instance\n\t\t\tawait BinaryDataManager.init({\n\t\t\t\tmode: 'default',\n\t\t\t\tavailableModes: 'default',\n\t\t\t\tlocalStoragePath: temporaryDir,\n\t\t\t\tbinaryDataTTL: 1,\n\t\t\t\tpersistedBinaryDataTTL: 1,\n\t\t\t});\n\n\t\t\t// Set our binary data buffer\n\t\t\tlet inputData: Buffer = Buffer.from('This is some binary data', 'utf8');\n\t\t\tlet setBinaryDataBufferResponse: IBinaryData = await NodeExecuteFunctions.setBinaryDataBuffer(\n\t\t\t\t{\n\t\t\t\t\tmimeType: 'txt',\n\t\t\t\t\tdata: 'This should be overwritten by the actual payload in the response',\n\t\t\t\t},\n\t\t\t\tinputData,\n\t\t\t\t'executionId',\n\t\t\t);\n\n\t\t\t// Expect our return object to contain the base64 encoding of the input data, as it should be stored in memory.\n\t\t\texpect(setBinaryDataBufferResponse.data).toEqual(inputData.toString('base64'));\n\n\t\t\t// Now, re-fetch our data.\n\t\t\t// An ITaskDataConnections object is used to share data between nodes. The top level property, 'main', represents the successful output object from a previous node.\n\t\t\tlet taskDataConnectionsInput: ITaskDataConnections = {\n\t\t\t\tmain: [],\n\t\t\t};\n\n\t\t\t// We add an input set, with one item at index 0, to this input. It contains an empty json payload and our binary data.\n\t\t\ttaskDataConnectionsInput.main.push([\n\t\t\t\t{\n\t\t\t\t\tjson: {},\n\t\t\t\t\tbinary: {\n\t\t\t\t\t\tdata: setBinaryDataBufferResponse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\t// Now, lets fetch our data! The item will be item index 0.\n\t\t\tlet getBinaryDataBufferResponse: Buffer = await NodeExecuteFunctions.getBinaryDataBuffer(\n\t\t\t\ttaskDataConnectionsInput,\n\t\t\t\t0,\n\t\t\t\t'data',\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\texpect(getBinaryDataBufferResponse).toEqual(inputData);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'filesystem' mode","suites":["NodeExecuteFunctions","test binary data helper methods"],"updatePoint":{"line":69,"column":93},"line":69,"code":"\t\ttest(`test getBinaryDataBuffer(...) & setBinaryDataBuffer(...) methods in 'filesystem' mode`, async () => {\n\t\t\t// Setup a 'filesystem' binary data manager instance\n\t\t\tawait BinaryDataManager.init({\n\t\t\t\tmode: 'filesystem',\n\t\t\t\tavailableModes: 'filesystem',\n\t\t\t\tlocalStoragePath: temporaryDir,\n\t\t\t\tbinaryDataTTL: 1,\n\t\t\t\tpersistedBinaryDataTTL: 1,\n\t\t\t});\n\n\t\t\t// Set our binary data buffer\n\t\t\tlet inputData: Buffer = Buffer.from('This is some binary data', 'utf8');\n\t\t\tlet setBinaryDataBufferResponse: IBinaryData = await NodeExecuteFunctions.setBinaryDataBuffer(\n\t\t\t\t{\n\t\t\t\t\tmimeType: 'txt',\n\t\t\t\t\tdata: 'This should be overwritten with the name of the configured data manager',\n\t\t\t\t},\n\t\t\t\tinputData,\n\t\t\t\t'executionId',\n\t\t\t);\n\n\t\t\t// Expect our return object to contain the name of the configured data manager.\n\t\t\texpect(setBinaryDataBufferResponse.data).toEqual('filesystem');\n\n\t\t\t// Ensure that the input data was successfully persisted to disk.\n\t\t\texpect(\n\t\t\t\treadFileSync(\n\t\t\t\t\t`${temporaryDir}/${setBinaryDataBufferResponse.id?.replace('filesystem:', '')}`,\n\t\t\t\t),\n\t\t\t).toEqual(inputData);\n\n\t\t\t// Now, re-fetch our data.\n\t\t\t// An ITaskDataConnections object is used to share data between nodes. The top level property, 'main', represents the successful output object from a previous node.\n\t\t\tlet taskDataConnectionsInput: ITaskDataConnections = {\n\t\t\t\tmain: [],\n\t\t\t};\n\n\t\t\t// We add an input set, with one item at index 0, to this input. It contains an empty json payload and our binary data.\n\t\t\ttaskDataConnectionsInput.main.push([\n\t\t\t\t{\n\t\t\t\t\tjson: {},\n\t\t\t\t\tbinary: {\n\t\t\t\t\t\tdata: setBinaryDataBufferResponse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\t// Now, lets fetch our data! The item will be item index 0.\n\t\t\tlet getBinaryDataBufferResponse: Buffer = await NodeExecuteFunctions.getBinaryDataBuffer(\n\t\t\t\ttaskDataConnectionsInput,\n\t\t\t\t0,\n\t\t\t\t'data',\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\texpect(getBinaryDataBufferResponse).toEqual(inputData);\n\t\t});","file":"NodeExecuteFunctions.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"runs query to update db","suites":["pgUpdate"],"updatePoint":{"line":5,"column":28},"line":5,"code":"\tit('runs query to update db', async () => {\n\t\tconst updateItem = { id: 1234, name: 'test' };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values(1234,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db if updateKey is not in columns","suites":["pgUpdate"],"updatePoint":{"line":33,"column":59},"line":33,"code":"\tit('runs query to update db if updateKey is not in columns', async () => {\n\t\tconst updateItem = { id: 1234, name: 'test' };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tconst results = await PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values(1234,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast as updateKey","suites":["pgUpdate"],"updatePoint":{"line":61,"column":51},"line":61,"code":"\tit('runs query to update db with cast as updateKey', async () => {\n\t\tconst updateItem = { id: '1234', name: 'test' };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id:uuid',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values('1234'::uuid,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast in target columns","suites":["pgUpdate"],"updatePoint":{"line":89,"column":56},"line":89,"code":"\tit('runs query to update db with cast in target columns', async () => {\n\t\tconst updateItem = { id: '1234', name: 'test' };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id:uuid,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values('1234'::uuid,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert","suites":["pgInsert"],"updatePoint":{"line":119,"column":25},"line":119,"code":"\tit('runs query to insert', async () => {\n\t\tconst insertItem = { id: 1234, name: 'test', age: 34 };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id,name,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`insert into \\\"myschema\\\".\\\"mytable\\\"(\\\"id\\\",\\\"name\\\",\\\"age\\\") values(1234,'test',34) RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert with type casting","suites":["pgInsert"],"updatePoint":{"line":146,"column":43},"line":146,"code":"\tit('runs query to insert with type casting', async () => {\n\t\tconst insertItem = { id: 1234, name: 'test', age: 34 };\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id:int,name:text,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = { any };\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(\n\t\t\t`insert into \\\"myschema\\\".\\\"mytable\\\"(\\\"id\\\",\\\"name\\\",\\\"age\\\") values(1234::int,'test'::text,34) RETURNING *`,\n\t\t);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"it should adjust multiple metadata values","suites":["adjustMetadata"],"updatePoint":{"line":4,"column":46},"line":4,"code":"\tit('it should adjust multiple metadata values', async () => {\n\t\tconst additionalFieldsValues = {\n\t\t\tmetadata: {\n\t\t\t\tmetadataProperties: [\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: 'keyA',\n\t\t\t\t\t\tvalue: 'valueA',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: 'keyB',\n\t\t\t\t\t\tvalue: 'valueB',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t};\n\n\t\tconst adjustedMetadata = helpers.adjustMetadata(additionalFieldsValues);\n\n\t\tconst expectedAdjustedMetadata = {\n\t\t\tmetadata: {\n\t\t\t\tkeyA: 'valueA',\n\t\t\t\tkeyB: 'valueB',\n\t\t\t},\n\t\t};\n\t\texpect(adjustedMetadata).toStrictEqual(expectedAdjustedMetadata);\n\t});","file":"nodes/Stripe/helpers.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should generate a valid cron for `everyMinute` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":5,"column":63},"line":5,"code":"\t\ttest('should generate a valid cron for `everyMinute` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyMinute',\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] \\* \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyHour` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":12,"column":61},"line":12,"code":"\t\ttest('should generate a valid cron for `everyHour` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyHour',\n\t\t\t\tminute: 11,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 11 \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyX[minutes]` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":20,"column":67},"line":20,"code":"\t\ttest('should generate a valid cron for `everyX[minutes]` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyX',\n\t\t\t\tunit: 'minutes',\n\t\t\t\tvalue: 42,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] \\*\\/42 \\* \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyX[hours]` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":29,"column":65},"line":29,"code":"\t\ttest('should generate a valid cron for `everyX[hours]` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyX',\n\t\t\t\tunit: 'hours',\n\t\t\t\tvalue: 3,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 0 \\*\\/3 \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyDay` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":38,"column":60},"line":38,"code":"\t\ttest('should generate a valid cron for `everyDay` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyDay',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 \\* \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyWeek` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":47,"column":61},"line":47,"code":"\t\ttest('should generate a valid cron for `everyWeek` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyWeek',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t\tweekday: 4,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 \\* \\* 4$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should generate a valid cron for `everyMonth` triggers","suites":["Cron","toCronExpression"],"updatePoint":{"line":57,"column":62},"line":57,"code":"\t\ttest('should generate a valid cron for `everyMonth` triggers', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'everyMonth',\n\t\t\t\thour: 13,\n\t\t\t\tminute: 17,\n\t\t\t\tdayOfMonth: 12,\n\t\t\t});\n\t\t\texpect(expression).toMatch(/^[1-6]?[0-9] 17 13 12 \\* \\*$/);\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should trim custom cron expressions","suites":["Cron","toCronExpression"],"updatePoint":{"line":67,"column":43},"line":67,"code":"\t\ttest('should trim custom cron expressions', () => {\n\t\t\tconst expression = toCronExpression({\n\t\t\t\tmode: 'custom',\n\t\t\t\tcronExpression: ' 0 9-17 * * * ',\n\t\t\t});\n\t\t\texpect(expression).toEqual('0 9-17 * * *');\n\t\t});","file":"Cron.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not be able to use global built-ins from denylist","suites":["Expression","getParameterValue()"],"updatePoint":{"line":33,"column":62},"line":33,"code":"\t\tit('should not be able to use global built-ins from denylist', () => {\n\t\t\texpect(evaluate('={{document}}')).toEqual({});\n\t\t\texpect(evaluate('={{window}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Window}}')).toEqual({});\n\t\t\texpect(evaluate('={{globalThis}}')).toEqual({});\n\t\t\texpect(evaluate('={{self}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{alert}}')).toEqual({});\n\t\t\texpect(evaluate('={{prompt}}')).toEqual({});\n\t\t\texpect(evaluate('={{confirm}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{eval}}')).toEqual({});\n\t\t\texpect(evaluate('={{uneval}}')).toEqual({});\n\t\t\texpect(evaluate('={{setTimeout}}')).toEqual({});\n\t\t\texpect(evaluate('={{setInterval}}')).toEqual({});\n\t\t\texpect(evaluate('={{Function}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{fetch}}')).toEqual({});\n\t\t\texpect(evaluate('={{XMLHttpRequest}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Promise}}')).toEqual({});\n\t\t\texpect(evaluate('={{Generator}}')).toEqual({});\n\t\t\texpect(evaluate('={{GeneratorFunction}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncFunction}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncGenerator}}')).toEqual({});\n\t\t\texpect(evaluate('={{AsyncGeneratorFunction}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{WebAssembly}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{Reflect}}')).toEqual({});\n\t\t\texpect(evaluate('={{Proxy}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{constructor}}')).toEqual({});\n\n\t\t\texpect(evaluate('={{escape}}')).toEqual({});\n\t\t\texpect(evaluate('={{unescape}}')).toEqual({});\n\t\t});","file":"Expression.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should be able to use global built-ins from allowlist","suites":["Expression","getParameterValue()"],"updatePoint":{"line":72,"column":59},"line":72,"code":"\t\tit('should be able to use global built-ins from allowlist', () => {\n\t\t\texpect(evaluate('={{new Date()}}')).toBeInstanceOf(Date);\n\t\t\texpect(evaluate('={{DateTime.now().toLocaleString()}}')).toEqual(\n\t\t\t\tDateTime.now().toLocaleString(),\n\t\t\t);\n\t\t\texpect(evaluate('={{Interval.after(new Date(), 100)}}')).toEqual(\n\t\t\t\tInterval.after(new Date(), 100),\n\t\t\t);\n\t\t\texpect(evaluate('={{Duration.fromMillis(100)}}')).toEqual(Duration.fromMillis(100));\n\n\t\t\texpect(evaluate('={{new Object()}}')).toEqual(new Object());\n\n\t\t\texpect(evaluate('={{new Array()}}')).toEqual(new Array());\n\t\t\texpect(evaluate('={{new Int8Array()}}')).toEqual(new Int8Array());\n\t\t\texpect(evaluate('={{new Uint8Array()}}')).toEqual(new Uint8Array());\n\t\t\texpect(evaluate('={{new Uint8ClampedArray()}}')).toEqual(new Uint8ClampedArray());\n\t\t\texpect(evaluate('={{new Int16Array()}}')).toEqual(new Int16Array());\n\t\t\texpect(evaluate('={{new Uint16Array()}}')).toEqual(new Uint16Array());\n\t\t\texpect(evaluate('={{new Int32Array()}}')).toEqual(new Int32Array());\n\t\t\texpect(evaluate('={{new Uint32Array()}}')).toEqual(new Uint32Array());\n\t\t\texpect(evaluate('={{new Float32Array()}}')).toEqual(new Float32Array());\n\t\t\texpect(evaluate('={{new Float64Array()}}')).toEqual(new Float64Array());\n\t\t\texpect(evaluate('={{new BigInt64Array()}}')).toEqual(new BigInt64Array());\n\t\t\texpect(evaluate('={{new BigUint64Array()}}')).toEqual(new BigUint64Array());\n\n\t\t\texpect(evaluate('={{new Map()}}')).toEqual(new Map());\n\t\t\texpect(evaluate('={{new WeakMap()}}')).toEqual(new WeakMap());\n\t\t\texpect(evaluate('={{new Set()}}')).toEqual(new Set());\n\t\t\texpect(evaluate('={{new WeakSet()}}')).toEqual(new WeakSet());\n\n\t\t\texpect(evaluate('={{new Error()}}')).toEqual(new Error());\n\t\t\texpect(evaluate('={{new TypeError()}}')).toEqual(new TypeError());\n\t\t\texpect(evaluate('={{new SyntaxError()}}')).toEqual(new SyntaxError());\n\t\t\texpect(evaluate('={{new EvalError()}}')).toEqual(new EvalError());\n\t\t\texpect(evaluate('={{new RangeError()}}')).toEqual(new RangeError());\n\t\t\texpect(evaluate('={{new ReferenceError()}}')).toEqual(new ReferenceError());\n\t\t\texpect(evaluate('={{new URIError()}}')).toEqual(new URIError());\n\n\t\t\texpect(evaluate('={{Intl}}')).toEqual(Intl);\n\n\t\t\texpect(evaluate('={{new String()}}')).toEqual(new String());\n\t\t\texpect(evaluate(\"={{new RegExp('')}}\")).toEqual(new RegExp(''));\n\n\t\t\texpect(evaluate('={{Math}}')).toEqual(Math);\n\t\t\texpect(evaluate('={{new Number()}}')).toEqual(new Number());\n\t\t\texpect(evaluate(\"={{BigInt('1')}}\")).toEqual(BigInt('1'));\n\t\t\texpect(evaluate('={{Infinity}}')).toEqual(Infinity);\n\t\t\texpect(evaluate('={{NaN}}')).toEqual(NaN);\n\t\t\texpect(evaluate('={{isFinite(1)}}')).toEqual(isFinite(1));\n\t\t\texpect(evaluate('={{isNaN(1)}}')).toEqual(isNaN(1));\n\t\t\texpect(evaluate(\"={{parseFloat('1')}}\")).toEqual(parseFloat('1'));\n\t\t\texpect(evaluate(\"={{parseInt('1', 10)}}\")).toEqual(parseInt('1', 10));\n\n\t\t\texpect(evaluate('={{JSON.stringify({})}}')).toEqual(JSON.stringify({}));\n\t\t\texpect(evaluate('={{new ArrayBuffer(10)}}')).toEqual(new ArrayBuffer(10));\n\t\t\texpect(evaluate('={{new SharedArrayBuffer(10)}}')).toEqual(new SharedArrayBuffer(10));\n\t\t\texpect(evaluate('={{Atomics}}')).toEqual(Atomics);\n\t\t\texpect(evaluate('={{new DataView(new ArrayBuffer(1))}}')).toEqual(\n\t\t\t\tnew DataView(new ArrayBuffer(1)),\n\t\t\t);\n\n\t\t\texpect(evaluate(\"={{encodeURI('https://google.com')}}\")).toEqual(\n\t\t\t\tencodeURI('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{encodeURIComponent('https://google.com')}}\")).toEqual(\n\t\t\t\tencodeURIComponent('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{decodeURI('https://google.com')}}\")).toEqual(\n\t\t\t\tdecodeURI('https://google.com'),\n\t\t\t);\n\t\t\texpect(evaluate(\"={{decodeURIComponent('https://google.com')}}\")).toEqual(\n\t\t\t\tdecodeURIComponent('https://google.com'),\n\t\t\t);\n\n\t\t\texpect(evaluate('={{Boolean(1)}}')).toEqual(Boolean(1));\n\t\t\texpect(evaluate('={{Symbol(1).toString()}}')).toEqual(Symbol(1).toString());\n\t\t});","file":"Expression.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got added (init empty)","suites":["ObservableObject"],"updatePoint":{"line":5,"column":72},"line":5,"code":"\ttest('should recognize that item on parent level got added (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\n\t\t// Make sure that \"__dataChanged\" does not returned as a key\n\t\texpect(Object.keys(testObject)).toEqual(['a']);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":15,"column":142},"line":15,"code":"\ttest('should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":23,"column":142},"line":23,"code":"\ttest('should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = { b: 2 };\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({ b: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":31,"column":141},"line":31,"code":"\ttest('should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [];\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":39,"column":139},"line":39,"code":"\ttest('should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [1, 2];\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":47,"column":76},"line":47,"code":"\ttest('should recognize that item on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual(1);\n\t\ttestObject.a = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":56,"column":77},"line":56,"code":"\ttest('should recognize that array on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: [1, 2] });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t\t(testObject.a as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":65,"column":81},"line":65,"code":"\ttest('should recognize that item on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\t(testObject.a! as IDataObject).b = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":74,"column":146},"line":74,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":85,"column":147},"line":85,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: false,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":96,"column":82},"line":96,"code":"\ttest('should recognize that array on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: [1, 2] } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2]);\n\t\t((testObject.a! as IDataObject).b as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":105,"column":82},"line":105,"code":"\ttest('should recognize that item on second child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(1);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":115,"column":80},"line":115,"code":"\ttest('should recognize that item on parent level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":125,"column":136},"line":125,"code":"\ttest('should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":137,"column":86},"line":137,"code":"\ttest('should recognize that item on second child level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\tdelete (testObject.a! as IDataObject).b;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(undefined);\n\t\texpect(testObject).toEqual({ a: {} });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed with null (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":147,"column":92},"line":147,"code":"\ttest('should recognize that item on second child level changed with null (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: null } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: null });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(null);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":5,"column":20},"line":5,"code":"\ttest('in valid URLs', () => {\n\t\tfor (const url of validUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":12,"column":24},"line":12,"code":"\ttest('in malformed URLs', () => {\n\t\tfor (const url of malformedUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":22,"column":21},"line":22,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":29,"column":25},"line":29,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":38,"column":21},"line":38,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of uuidUrls(validUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":45,"column":25},"line":45,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of uuidUrls(malformedUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":54,"column":21},"line":54,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":61,"column":25},"line":61,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"parses JSON","suites":["jsonParse"],"updatePoint":{"line":4,"column":16},"line":4,"code":"\tit('parses JSON', () => {\n\t\texpect(jsonParse('[1, 2, 3]')).toEqual([1, 2, 3]);\n\t\texpect(jsonParse('{ \"a\": 1 }')).toEqual({ a: 1 });\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"optionally throws `errorMessage","suites":["jsonParse"],"updatePoint":{"line":9,"column":36},"line":9,"code":"\tit('optionally throws `errorMessage', () => {\n\t\texpect(() => {\n\t\t\tjsonParse('', { errorMessage: 'Invalid JSON' });\n\t\t}).toThrow('Invalid JSON');\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"optionally returns a `fallbackValue`","suites":["jsonParse"],"updatePoint":{"line":15,"column":41},"line":15,"code":"\tit('optionally returns a `fallbackValue`', () => {\n\t\texpect(jsonParse('', { fallbackValue: { foo: 'bar' } })).toEqual({ foo: 'bar' });\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should deep copy an object","suites":["deepCopy"],"updatePoint":{"line":21,"column":31},"line":21,"code":"\tit('should deep copy an object', () => {\n\t\tconst serializable = {\n\t\t\tx: 1,\n\t\t\ty: 2,\n\t\t\ttoJSON: () => 'x:1,y:2',\n\t\t};\n\t\tconst object = {\n\t\t\tdeep: {\n\t\t\t\tprops: {\n\t\t\t\t\tlist: [{ a: 1 }, { b: 2 }, { c: 3 }],\n\t\t\t\t},\n\t\t\t\tarr: [1, 2, 3],\n\t\t\t},\n\t\t\tserializable,\n\t\t\tarr: [\n\t\t\t\t{\n\t\t\t\t\tprop: {\n\t\t\t\t\t\tlist: ['a', 'b', 'c'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tfunc: () => {},\n\t\t\tdate: new Date(1667389172201),\n\t\t\tundef: undefined,\n\t\t\tnil: null,\n\t\t\tbool: true,\n\t\t\tnum: 1,\n\t\t};\n\t\tconst copy = deepCopy(object);\n\t\texpect(copy).not.toBe(object);\n\t\texpect(copy.arr).toEqual(object.arr);\n\t\texpect(copy.arr).not.toBe(object.arr);\n\t\texpect(copy.date).toBe('2022-11-02T11:39:32.201Z');\n\t\texpect(copy.serializable).toBe(serializable.toJSON());\n\t\texpect(copy.deep.props).toEqual(object.deep.props);\n\t\texpect(copy.deep.props).not.toBe(object.deep.props);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should avoid max call stack in case of circular deps","suites":["deepCopy"],"updatePoint":{"line":59,"column":57},"line":59,"code":"\tit('should avoid max call stack in case of circular deps', () => {\n\t\tconst object: Record<string, any> = {\n\t\t\tdeep: {\n\t\t\t\tprops: {\n\t\t\t\t\tlist: [{ a: 1 }, { b: 2 }, { c: 3 }],\n\t\t\t\t},\n\t\t\t\tarr: [1, 2, 3],\n\t\t\t},\n\t\t\tarr: [\n\t\t\t\t{\n\t\t\t\t\tprop: {\n\t\t\t\t\t\tlist: ['a', 'b', 'c'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tfunc: () => {},\n\t\t\tdate: new Date(1667389172201),\n\t\t\tundef: undefined,\n\t\t\tnil: null,\n\t\t\tbool: true,\n\t\t\tnum: 1,\n\t\t};\n\n\t\tobject.circular = object;\n\t\tobject.deep.props.circular = object;\n\t\tobject.deep.arr.push(object);\n\n\t\tconst copy = deepCopy(object);\n\t\texpect(copy).not.toBe(object);\n\t\texpect(copy.arr).toEqual(object.arr);\n\t\texpect(copy.arr).not.toBe(object.arr);\n\t\texpect(copy.date).toBe('2022-11-02T11:39:32.201Z');\n\t\texpect(copy.deep.props.circular).toBe(copy);\n\t\texpect(copy.deep.props.circular).not.toBe(object);\n\t\texpect(copy.deep.arr.slice(-1)[0]).toBe(copy);\n\t\texpect(copy.deep.arr.slice(-1)[0]).not.toBe(object);\n\t});","file":"utils.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should also resolve all child parameters when the parent get requested","suites":["Workflow","getParameterValue"],"updatePoint":{"line":1327,"column":78},"line":1327,"code":"\t\ttest('should also resolve all child parameters when the parent get requested', () => {\n\t\t\tconst nodeTypes = Helpers.NodeTypes();\n\n\t\t\tconst nodes: INode[] = [\n\t\t\t\t{\n\t\t\t\t\tname: 'Node1',\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tstring: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\t\t\t\tvalue: '={{$parameter.values.string[0].value}}A',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'test.setMulti',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tid: 'uuid-1234',\n\t\t\t\t\tposition: [100, 100],\n\t\t\t\t},\n\t\t\t];\n\t\t\tconst connections: IConnections = {};\n\n\t\t\tconst workflow = new Workflow({ nodes, connections, active: false, nodeTypes });\n\t\t\tconst activeNodeName = 'Node1';\n\n\t\t\tconst runExecutionData: IRunExecutionData = {\n\t\t\t\tresultData: {\n\t\t\t\t\trunData: {\n\t\t\t\t\t\tNode1: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstartTime: 1,\n\t\t\t\t\t\t\t\texecutionTime: 1,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmain: [\n\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tjson: {},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tsource: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst itemIndex = 0;\n\t\t\tconst runIndex = 0;\n\t\t\tconst connectionInputData: INodeExecutionData[] =\n\t\t\t\trunExecutionData.resultData.runData!['Node1']![0]!.data!.main[0]!;\n\t\t\tconst parameterName = 'values';\n\n\t\t\tconst parameterValue = nodes.find((node) => node.name === activeNodeName)!.parameters[\n\t\t\t\tparameterName\n\t\t\t];\n\t\t\tconst result = workflow.expression.getParameterValue(\n\t\t\t\tparameterValue,\n\t\t\t\trunExecutionData,\n\t\t\t\trunIndex,\n\t\t\t\titemIndex,\n\t\t\t\tactiveNodeName,\n\t\t\t\tconnectionInputData,\n\t\t\t\t'manual',\n\t\t\t\ttimezone,\n\t\t\t\t{},\n\t\t\t);\n\n\t\t\texpect(result).toEqual({\n\t\t\t\tstring: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\tvalue: 'value1A',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent nodes of nodes","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1682,"column":43},"line":1682,"code":"\t\ttest('Should return parent nodes of nodes', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent up to depth","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1705,"column":40},"line":1705,"code":"\t\ttest('Should return parent up to depth', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 0)).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return all parents with depth of -1","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1716,"column":50},"line":1716,"code":"\t\ttest('Should return all parents with depth of -1', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', -1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parents of nodes with all connected output indicies","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1731,"column":73},"line":1731,"code":"\t\ttest('Should return parents of nodes with all connected output indicies', () => {\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Switch')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [1, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set2')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [1, 2, 0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should handle loops within workflows","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1767,"column":44},"line":1767,"code":"\t\ttest('Should handle loops within workflows', () => {\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 3,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Switch')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":256,"column":32},"line":256,"code":"\t\ttest('test $(\"NodeName\").all()', () => {\n\t\t\texpect(proxy.$('Rename').all()[1].json.data).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":259,"column":39},"line":259,"code":"\t\ttest('test $(\"NodeName\").all() length', () => {\n\t\t\texpect(proxy.$('Rename').all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":262,"column":31},"line":262,"code":"\t\ttest('test $(\"NodeName\").item', () => {\n\t\t\texpect(proxy.$('Rename').item).toEqual({ json: { data: 105 }, pairedItem: { item: 0 } });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeNameEarlier\").item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":265,"column":38},"line":265,"code":"\t\ttest('test $(\"NodeNameEarlier\").item', () => {\n\t\t\texpect(proxy.$('Function').item).toEqual({\n\t\t\t\tjson: { initialName: 105 },\n\t\t\t\tpairedItem: { item: 0 },\n\t\t\t});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").itemMatching(2)","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":271,"column":42},"line":271,"code":"\t\ttest('test $(\"NodeName\").itemMatching(2)', () => {\n\t\t\texpect(proxy.$('Rename').itemMatching(2).json.data).toEqual(121);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":274,"column":34},"line":274,"code":"\t\ttest('test $(\"NodeName\").first()', () => {\n\t\t\texpect(proxy.$('Rename').first().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":277,"column":33},"line":277,"code":"\t\ttest('test $(\"NodeName\").last()', () => {\n\t\t\texpect(proxy.$('Rename').last().json.data).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").params","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":281,"column":33},"line":281,"code":"\t\ttest('test $(\"NodeName\").params', () => {\n\t\t\texpect(proxy.$('Rename').params).toEqual({ value1: 'data', value2: 'initialName' });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":285,"column":25},"line":285,"code":"\t\ttest('test $input.all()', () => {\n\t\t\texpect(proxy.$input.all()[1].json.data).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":288,"column":32},"line":288,"code":"\t\ttest('test $input.all() length', () => {\n\t\t\texpect(proxy.$input.all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":291,"column":27},"line":291,"code":"\t\ttest('test $input.first()', () => {\n\t\t\texpect(proxy.$input.first().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":294,"column":26},"line":294,"code":"\t\ttest('test $input.last()', () => {\n\t\t\texpect(proxy.$input.last().json.data).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.item","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":297,"column":24},"line":297,"code":"\t\ttest('test $input.item', () => {\n\t\t\texpect(proxy.$input.item.json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $thisItem","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":300,"column":22},"line":300,"code":"\t\ttest('test $thisItem', () => {\n\t\t\texpect(proxy.$thisItem.json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $binary","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":304,"column":20},"line":304,"code":"\t\ttest('test $binary', () => {\n\t\t\texpect(proxy.$binary).toEqual({});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $json","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":308,"column":18},"line":308,"code":"\t\ttest('test $json', () => {\n\t\t\texpect(proxy.$json).toEqual({ data: 105 });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $itemIndex","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":312,"column":23},"line":312,"code":"\t\ttest('test $itemIndex', () => {\n\t\t\texpect(proxy.$itemIndex).toEqual(0);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $prevNode","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":316,"column":22},"line":316,"code":"\t\ttest('test $prevNode', () => {\n\t\t\texpect(proxy.$prevNode).toEqual({ name: 'Rename', outputIndex: 0, runIndex: 0 });\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $runIndex","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":320,"column":22},"line":320,"code":"\t\ttest('test $runIndex', () => {\n\t\t\texpect(proxy.$runIndex).toEqual(0);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $workflow","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":324,"column":22},"line":324,"code":"\t\ttest('test $workflow', () => {\n\t\t\texpect(proxy.$workflow).toEqual({\n\t\t\t\tactive: false,\n\t\t\t\tid: '123',\n\t\t\t\tname: 'test workflow',\n\t\t\t});\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"}]}