{
    "repo": "facebook/jest",
    "url": "https://github.com/facebook/jest",
    "branch": "main",
    "configs": [
        {
            "package": "example-async",
            "lang": "js",
            "dir": "examples/async/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-automatic-mocks",
            "lang": "js",
            "dir": "examples/automatic-mocks/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-enzyme",
            "lang": "js",
            "dir": "examples/enzyme/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-jquery",
            "lang": "js",
            "dir": "examples/jquery/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-manual-mocks",
            "lang": "js",
            "dir": "examples/manual-mocks/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-manual-mock",
            "lang": "js",
            "dir": "examples/module-mock/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-mongodb",
            "lang": "js",
            "dir": "examples/mongodb/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-react-native",
            "lang": "js",
            "dir": "examples/react-native/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-react-testing-library",
            "lang": "js",
            "dir": "examples/react-testing-library/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-react",
            "lang": "js",
            "dir": "examples/react/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-snapshot",
            "lang": "js",
            "dir": "examples/snapshot/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-timer",
            "lang": "js",
            "dir": "examples/timer/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "example-typescript",
            "lang": "ts",
            "dir": "examples/typescript/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "babel-jest",
            "lang": "ts",
            "dir": "packages/babel-jest/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "babel-plugin-jest-hoist",
            "lang": "ts",
            "dir": "packages/babel-plugin-jest-hoist/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "diff-sequences",
            "lang": "ts",
            "dir": "packages/diff-sequences/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "expect",
            "lang": "ts",
            "dir": "packages/expect/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-circus",
            "lang": "ts",
            "dir": "packages/jest-circus/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-cli",
            "lang": "js",
            "dir": "packages/jest-cli/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-config",
            "lang": "ts",
            "dir": "packages/jest-config/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/console",
            "lang": "ts",
            "dir": "packages/jest-console/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/core",
            "lang": "ts",
            "dir": "packages/jest-core/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/create-cache-key-function",
            "lang": "ts",
            "dir": "packages/jest-create-cache-key-function/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-diff",
            "lang": "ts",
            "dir": "packages/jest-diff/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-docblock",
            "lang": "ts",
            "dir": "packages/jest-docblock/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-each",
            "lang": "ts",
            "dir": "packages/jest-each/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-environment-jsdom",
            "lang": "ts",
            "dir": "packages/jest-environment-jsdom/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-environment-node",
            "lang": "ts",
            "dir": "packages/jest-environment-node/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/fake-timers",
            "lang": "ts",
            "dir": "packages/jest-fake-timers/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-get-type",
            "lang": "ts",
            "dir": "packages/jest-get-type/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/globals",
            "lang": "ts",
            "dir": "packages/jest-globals/src/__tests__",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "jest-haste-map",
            "lang": "ts",
            "dir": "packages/jest-haste-map/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-jasmine2",
            "lang": "ts",
            "dir": "packages/jest-jasmine2/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-leak-detector",
            "lang": "ts",
            "dir": "packages/jest-leak-detector/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-matcher-utils",
            "lang": "ts",
            "dir": "packages/jest-matcher-utils/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-message-util",
            "lang": "ts",
            "dir": "packages/jest-message-util/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-mock",
            "lang": "ts",
            "dir": "packages/jest-mock/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-regex-util",
            "lang": "ts",
            "dir": "packages/jest-regex-util/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-repl",
            "lang": "js",
            "dir": "packages/jest-repl/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/reporters",
            "lang": "ts",
            "dir": "packages/jest-reporters/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-resolve-dependencies",
            "lang": "ts",
            "dir": "packages/jest-resolve-dependencies/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-resolve",
            "lang": "ts",
            "dir": "packages/jest-resolve/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-runner",
            "lang": "ts",
            "dir": "packages/jest-runner/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-runtime",
            "lang": "ts",
            "dir": "packages/jest-runtime/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-serializer",
            "lang": "ts",
            "dir": "packages/jest-serializer/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-snapshot",
            "lang": "ts",
            "dir": "packages/jest-snapshot/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/source-map",
            "lang": "ts",
            "dir": "packages/jest-source-map/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/test-result",
            "lang": "ts",
            "dir": "packages/jest-test-result/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/test-sequencer",
            "lang": "js",
            "dir": "packages/jest-test-sequencer/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@jest/transform",
            "lang": "ts",
            "dir": "packages/jest-transform/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-util",
            "lang": "ts",
            "dir": "packages/jest-util/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-validate",
            "lang": "ts",
            "dir": "packages/jest-validate/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "jest-worker",
            "lang": "ts",
            "dir": "packages/jest-worker/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "pretty-format",
            "lang": "ts",
            "dir": "packages/pretty-format/src/__tests__",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "works with resolves",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 23,
                "index": 206
            },
            "line": 9,
            "code": "it('works with resolves', () => {\n  expect.assertions(1);\n  return expect(user.getUserName(5)).resolves.toBe('Paul');\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "works with promises",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 23,
                "index": 378
            },
            "line": 15,
            "code": "it('works with promises', () => {\n  expect.assertions(1);\n  return user.getUserName(4).then(data => expect(data).toBe('Mark'));\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "works with async/await",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 26,
                "index": 542
            },
            "line": 21,
            "code": "it('works with async/await', async () => {\n  expect.assertions(1);\n  const data = await user.getUserName(4);\n  expect(data).toBe('Mark');\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "works with async/await and resolves",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 39,
                "index": 748
            },
            "line": 28,
            "code": "it('works with async/await and resolves', async () => {\n  expect.assertions(1);\n  await expect(user.getUserName(5)).resolves.toBe('Paul');\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "tests error with rejects",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 28,
                "index": 927
            },
            "line": 34,
            "code": "it('tests error with rejects', () => {\n  expect.assertions(1);\n  return expect(user.getUserName(3)).rejects.toEqual({\n    error: 'User with 3 not found.'\n  });\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "tests error with promises",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 31,
                "index": 1144
            },
            "line": 42,
            "code": "test('tests error with promises', async () => {\n  expect.assertions(1);\n  return user.getUserName(2).catch(e => expect(e).toEqual({\n    error: 'User with 2 not found.'\n  }));\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "tests error with async/await",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 32,
                "index": 1350
            },
            "line": 50,
            "code": "it('tests error with async/await', async () => {\n  expect.assertions(1);\n  try {\n    await user.getUserName(1);\n  } catch (e) {\n    expect(e).toEqual({\n      error: 'User with 1 not found.'\n    });\n  }\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "tests error with async/await and rejects",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 44,
                "index": 1610
            },
            "line": 62,
            "code": "it('tests error with async/await and rejects', async () => {\n  expect.assertions(1);\n  await expect(user.getUserName(3)).rejects.toEqual({\n    error: 'User with 3 not found.'\n  });\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/async/__tests__"
        },
        {
            "name": "if utils are mocked",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 25,
                "index": 114
            },
            "line": 4,
            "code": "test('if utils are mocked', () => {\n  expect(utils.authorize.mock).toBeTruthy();\n  expect(utils.isAuthorized.mock).toBeTruthy();\n});",
            "file": "automock.test.js",
            "skipped": false,
            "dir": "examples/automatic-mocks/__tests__"
        },
        {
            "name": "mocked implementation",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 27,
                "index": 249
            },
            "line": 8,
            "code": "test('mocked implementation', () => {\n  utils.authorize.mockReturnValue('mocked_token');\n  utils.isAuthorized.mockReturnValue(true);\n  expect(utils.authorize()).toBe('mocked_token');\n  expect(utils.isAuthorized('not_wizard')).toBeTruthy();\n});",
            "file": "automock.test.js",
            "skipped": false,
            "dir": "examples/automatic-mocks/__tests__"
        },
        {
            "name": "implementation created by automock",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 40,
                "index": 129
            },
            "line": 4,
            "code": "test('implementation created by automock', () => {\n  expect(utils.authorize('wizard')).toBeUndefined();\n  expect(utils.isAuthorized()).toBeUndefined();\n});",
            "file": "createMockFromModule.test.js",
            "skipped": false,
            "dir": "examples/automatic-mocks/__tests__"
        },
        {
            "name": "implementation created by jest.createMockFromModule",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 57,
                "index": 302
            },
            "line": 8,
            "code": "test('implementation created by jest.createMockFromModule', () => {\n  const utils = jest.createMockFromModule('../utils').default;\n  utils.isAuthorized = jest.fn(secret => secret === 'not wizard');\n  expect(utils.authorize.mock).toBeTruthy();\n  expect(utils.isAuthorized('not wizard')).toBe(true);\n});",
            "file": "createMockFromModule.test.js",
            "skipped": false,
            "dir": "examples/automatic-mocks/__tests__"
        },
        {
            "name": "original implementation",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 29,
                "index": 142
            },
            "line": 5,
            "code": "test('original implementation', () => {\n  expect(utils.authorize()).toBe('token');\n});",
            "file": "disableAutomocking.test.js",
            "skipped": false,
            "dir": "examples/automatic-mocks/__tests__"
        },
        {
            "name": "CheckboxWithLabel changes the text after click",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 50,
                "index": 300
            },
            "line": 9,
            "code": "it('CheckboxWithLabel changes the text after click', () => {\n  // Render a checkbox with label in the document\n  const checkbox = shallow( /*#__PURE__*/React.createElement(CheckboxWithLabel, {\n    labelOn: \"On\",\n    labelOff: \"Off\"\n  }));\n  expect(checkbox.text()).toBe('Off');\n  checkbox.find('input').simulate('change');\n  expect(checkbox.text()).toBe('On');\n});",
            "file": "CheckboxWithLabel-test.js",
            "skipped": false,
            "dir": "examples/enzyme/__tests__"
        },
        {
            "name": "displays a user after a click",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 33,
                "index": 167
            },
            "line": 8,
            "code": "it('displays a user after a click', () => {\n  // Set up our document body\n  document.body.innerHTML = '<div>' + '  <span id=\"username\" />' + '  <button id=\"button\" />' + '</div>';\n\n  // This module has a side-effect\n  require('../displayUser');\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Tell the fetchCurrentUser mock function to automatically invoke\n  // its callback with some data\n  fetchCurrentUser.mockImplementation(cb => {\n    cb({\n      fullName: 'Johnny Cash',\n      loggedIn: true\n    });\n  });\n\n  // Use jquery to emulate a click on our button\n  $('#button').click();\n\n  // Assert that the fetchCurrentUser function was called, and that the\n  // #username span's inner text was updated as we'd expect it to.\n  expect(fetchCurrentUser).toHaveBeenCalled();\n  expect($('#username').text()).toBe('Johnny Cash - Logged In');\n});",
            "file": "display_user.test.js",
            "skipped": false,
            "dir": "examples/jquery/__tests__"
        },
        {
            "name": "calls into $.ajax with the correct params",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 45,
                "index": 164
            },
            "line": 5,
            "code": "it('calls into $.ajax with the correct params', () => {\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Call into the function we want to test\n  const dummyCallback = () => {};\n  fetchCurrentUser(dummyCallback);\n\n  // Now make sure that $.ajax was properly called during the previous\n  // 2 lines\n  expect($.ajax).toHaveBeenCalledWith({\n    success: expect.any(Function),\n    type: 'GET',\n    url: 'http://example.com/currentUser'\n  });\n});",
            "file": "fetch_current_user.test.js",
            "skipped": false,
            "dir": "examples/jquery/__tests__"
        },
        {
            "name": "calls the callback when $.ajax requests are finished",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 56,
                "index": 664
            },
            "line": 21,
            "code": "it('calls the callback when $.ajax requests are finished', () => {\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Create a mock function for our callback\n  const callback = jest.fn();\n  fetchCurrentUser(callback);\n\n  // Now we emulate the process by which `$.ajax` would execute its own\n  // callback\n  $.ajax.mock.calls[0 /*first call*/][0 /*first argument*/].success({\n    firstName: 'Bobby',\n    lastName: 'Marley'\n  });\n\n  // And finally we assert that this emulated call by `$.ajax` incurred a\n  // call back into the mock function we provided as a callback\n  expect(callback.mock.calls[0 /*first call*/][0 /*first arg*/]).toEqual({\n    fullName: 'Bobby Marley',\n    loggedIn: true\n  });\n});",
            "file": "fetch_current_user.test.js",
            "skipped": false,
            "dir": "examples/jquery/__tests__"
        },
        {
            "name": "includes all files in the directory in the summary",
            "suites": [
                "listFilesInDirectorySync"
            ],
            "updatePoint": {
                "line": 15,
                "column": 56,
                "index": 460
            },
            "line": 15,
            "code": "  it('includes all files in the directory in the summary', () => {\n    const FileSummarizer = require('../FileSummarizer');\n    const fileSummary = FileSummarizer.summarizeFilesInDirectorySync('/path/to');\n    expect(fileSummary).toHaveLength(2);\n  });",
            "file": "file_summarizer.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "if lodash head is mocked",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 30,
                "index": 118
            },
            "line": 4,
            "code": "test('if lodash head is mocked', () => {\n  expect(lodash.head([2, 3])).toBe(5);\n});",
            "file": "lodashMocking.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "if original user model",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 28,
                "index": 122
            },
            "line": 4,
            "code": "test('if original user model', () => {\n  expect(user.getAuthenticated()).toEqual({\n    age: 26,\n    name: 'Real name'\n  });\n});",
            "file": "user.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "if user model is mocked",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 29,
                "index": 152
            },
            "line": 5,
            "code": "test('if user model is mocked', () => {\n  expect(user.getAuthenticated()).toEqual({\n    age: 622,\n    name: 'Mock name'\n  });\n});",
            "file": "userMocked.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "isLocalhost should detect localhost environment",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 51,
                "index": 140
            },
            "line": 5,
            "code": "it('isLocalhost should detect localhost environment', () => {\n  jest.replaceProperty(process, 'env', {\n    HOSTNAME: 'localhost'\n  });\n  expect(isLocalhost()).toBe(true);\n});",
            "file": "utils.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "isLocalhost should detect non-localhost environment",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 55,
                "index": 319
            },
            "line": 11,
            "code": "it('isLocalhost should detect non-localhost environment', () => {\n  jest.replaceProperty(process, 'env', {\n    HOSTNAME: 'example.com'\n  });\n  expect(isLocalhost()).toBe(false);\n});",
            "file": "utils.test.js",
            "skipped": false,
            "dir": "examples/manual-mocks/__tests__"
        },
        {
            "name": "uses mocked module",
            "suites": [
                "define mock per test"
            ],
            "updatePoint": {
                "line": 14,
                "column": 24,
                "index": 377
            },
            "line": 14,
            "code": "  it('uses mocked module', () => {\n    jest.doMock('../fruit', () => ({\n      apple: 'mocked apple',\n      default: jest.fn(() => 'mocked fruit'),\n      strawberry: jest.fn(() => 'mocked strawberry')\n    }));\n    const {\n      apple,\n      strawberry,\n      default: defaultExport\n    } = require('../fruit');\n    const defaultExportResult = defaultExport();\n    expect(defaultExportResult).toBe('mocked fruit');\n    expect(defaultExport).toHaveBeenCalled();\n    expect(apple).toBe('mocked apple');\n    expect(strawberry()).toBe('mocked strawberry');\n  });",
            "file": "mock_per_test.js",
            "skipped": false,
            "dir": "examples/module-mock/__tests__"
        },
        {
            "name": "uses actual module",
            "suites": [
                "define mock per test"
            ],
            "updatePoint": {
                "line": 31,
                "column": 24,
                "index": 934
            },
            "line": 31,
            "code": "  it('uses actual module', () => {\n    jest.dontMock('../fruit');\n    const {\n      apple,\n      strawberry,\n      default: defaultExport\n    } = require('../fruit');\n    const defaultExportResult = defaultExport();\n    expect(defaultExportResult).toBe('banana');\n    expect(apple).toBe('apple');\n    expect(strawberry()).toBe('strawberry');\n  });",
            "file": "mock_per_test.js",
            "skipped": false,
            "dir": "examples/module-mock/__tests__"
        },
        {
            "name": "renders correctly",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 21,
                "index": 338
            },
            "line": 12,
            "code": "it('renders correctly', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(Intro, null)).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "intro.test.js",
            "skipped": false,
            "dir": "examples/react-native/__tests__"
        },
        {
            "name": "renders the ActivityIndicator component",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 43,
                "index": 590
            },
            "line": 18,
            "code": "it('renders the ActivityIndicator component', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(ActivityIndicator, {\n    animating: true,\n    size: \"small\"\n  })).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "intro.test.js",
            "skipped": false,
            "dir": "examples/react-native/__tests__"
        },
        {
            "name": "renders the TextInput component",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 35,
                "index": 815
            },
            "line": 25,
            "code": "it('renders the TextInput component', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(TextInput, {\n    autoCorrect: false,\n    value: \"apple banana kiwi\"\n  })).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "intro.test.js",
            "skipped": false,
            "dir": "examples/react-native/__tests__"
        },
        {
            "name": "renders the FlatList component",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 34,
                "index": 1047
            },
            "line": 32,
            "code": "it('renders the FlatList component', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(FlatList, {\n    data: ['apple', 'banana', 'kiwi'],\n    keyExtractor: item => item,\n    renderItem: ({\n      item\n    }) => /*#__PURE__*/React.createElement(Text, null, item)\n  })).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "intro.test.js",
            "skipped": false,
            "dir": "examples/react-native/__tests__"
        },
        {
            "name": "CheckboxWithLabel changes the text after click",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 50,
                "index": 223
            },
            "line": 5,
            "code": "it('CheckboxWithLabel changes the text after click', () => {\n  const {\n    queryByLabelText,\n    getByLabelText\n  } = render( /*#__PURE__*/React.createElement(CheckboxWithLabel, {\n    labelOn: \"On\",\n    labelOff: \"Off\"\n  }));\n  expect(queryByLabelText(/off/i)).toBeTruthy();\n  fireEvent.click(getByLabelText(/off/i));\n  expect(queryByLabelText(/on/i)).toBeTruthy();\n});",
            "file": "CheckboxWithLabel-test.js",
            "skipped": false,
            "dir": "examples/react-testing-library/__tests__"
        },
        {
            "name": "CheckboxWithLabel changes the text after click",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 50,
                "index": 249
            },
            "line": 6,
            "code": "it('CheckboxWithLabel changes the text after click', () => {\n  const checkboxLabelRef = /*#__PURE__*/createRef();\n  const checkboxInputRef = /*#__PURE__*/createRef();\n  // Render a checkbox with label in the document\n  TestUtils.renderIntoDocument( /*#__PURE__*/React.createElement(CheckboxWithLabel, {\n    labelRef: checkboxLabelRef,\n    inputRef: checkboxInputRef,\n    labelOn: \"On\",\n    labelOff: \"Off\"\n  }));\n  const labelNode = checkboxLabelRef.current;\n  const inputNode = checkboxInputRef.current;\n\n  // Verify that it's Off by default\n  expect(labelNode.textContent).toBe('Off');\n\n  // Simulate a click and verify that it is now On\n  TestUtils.Simulate.change(inputNode);\n  expect(labelNode.textContent).toBe('On');\n});",
            "file": "CheckboxWithLabel-test.js",
            "skipped": false,
            "dir": "examples/react/__tests__"
        },
        {
            "name": "renders correctly",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 21,
                "index": 232
            },
            "line": 9,
            "code": "it('renders correctly', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(Clock, null)).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "clock.test.js",
            "skipped": false,
            "dir": "examples/snapshot/__tests__"
        },
        {
            "name": "renders correctly",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 21,
                "index": 167
            },
            "line": 7,
            "code": "it('renders correctly', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(Link, {\n    page: \"http://www.facebook.com\"\n  }, \"Facebook\")).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "link.test.js",
            "skipped": false,
            "dir": "examples/snapshot/__tests__"
        },
        {
            "name": "renders as an anchor when no page is set",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 44,
                "index": 397
            },
            "line": 13,
            "code": "it('renders as an anchor when no page is set', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(Link, null, \"Facebook\")).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "link.test.js",
            "skipped": false,
            "dir": "examples/snapshot/__tests__"
        },
        {
            "name": "properly escapes quotes",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 27,
                "index": 573
            },
            "line": 17,
            "code": "it('properly escapes quotes', () => {\n  const tree = renderer.create( /*#__PURE__*/React.createElement(Link, null, \"\\\"Facebook\\\" \\\\'is \\\\ 'awesome'\")).toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "link.test.js",
            "skipped": false,
            "dir": "examples/snapshot/__tests__"
        },
        {
            "name": "changes the class when hovered",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 34,
                "index": 779
            },
            "line": 21,
            "code": "it('changes the class when hovered', () => {\n  const component = renderer.create( /*#__PURE__*/React.createElement(Link, {\n    page: \"http://www.facebook.com\"\n  }, \"Facebook\"));\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n\n  // manually trigger the callback\n  renderer.act(() => {\n    tree.props.onMouseEnter();\n  });\n  // re-rendering\n  tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n\n  // manually trigger the callback\n  renderer.act(() => {\n    tree.props.onMouseLeave();\n  });\n  // re-rendering\n  tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});",
            "file": "link.test.js",
            "skipped": false,
            "dir": "examples/snapshot/__tests__"
        },
        {
            "name": "schedules a 10-second timer after 1 second",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 46,
                "index": 142
            },
            "line": 6,
            "code": "it('schedules a 10-second timer after 1 second', () => {\n  jest.spyOn(globalThis, 'setTimeout');\n  const infiniteTimerGame = require('../infiniteTimerGame');\n  const callback = jest.fn();\n  infiniteTimerGame(callback);\n\n  // At this point in time, there should have been a single call to\n  // setTimeout to schedule the end of the game in 1 second.\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n  expect(setTimeout).toHaveBeenNthCalledWith(1, expect.any(Function), 1000);\n\n  // Fast forward and exhaust only currently pending timers\n  // (but not any new timers that get created during that process)\n  jest.runOnlyPendingTimers();\n\n  // At this point, our 1-second timer should have fired its callback\n  expect(callback).toHaveBeenCalled();\n\n  // And it should have created a new timer to start the game over in\n  // 10 seconds\n  expect(setTimeout).toHaveBeenCalledTimes(2);\n  expect(setTimeout).toHaveBeenNthCalledWith(2, expect.any(Function), 10000);\n});",
            "file": "infinite_timer_game.test.js",
            "skipped": false,
            "dir": "examples/timer/__tests__"
        },
        {
            "name": "waits 1 second before ending the game",
            "suites": [
                "timerGame"
            ],
            "updatePoint": {
                "line": 10,
                "column": 43,
                "index": 238
            },
            "line": 10,
            "code": "  it('waits 1 second before ending the game', () => {\n    const timerGame = require('../timerGame');\n    timerGame();\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), 1000);\n  });",
            "file": "timer_game.test.js",
            "skipped": false,
            "dir": "examples/timer/__tests__"
        },
        {
            "name": "calls the callback after 1 second via runAllTimers",
            "suites": [
                "timerGame"
            ],
            "updatePoint": {
                "line": 16,
                "column": 56,
                "index": 497
            },
            "line": 16,
            "code": "  it('calls the callback after 1 second via runAllTimers', () => {\n    const timerGame = require('../timerGame');\n    const callback = jest.fn();\n    timerGame(callback);\n\n    // At this point in time, the callback should not have been called yet\n    expect(callback).not.toHaveBeenCalled();\n\n    // Fast-forward until all timers have been executed\n    jest.runAllTimers();\n\n    // Now our callback should have been called!\n    expect(callback).toHaveBeenCalled();\n    expect(callback).toHaveBeenCalledTimes(1);\n  });",
            "file": "timer_game.test.js",
            "skipped": false,
            "dir": "examples/timer/__tests__"
        },
        {
            "name": "calls the callback after 1 second via advanceTimersByTime",
            "suites": [
                "timerGame"
            ],
            "updatePoint": {
                "line": 31,
                "column": 63,
                "index": 1022
            },
            "line": 31,
            "code": "  it('calls the callback after 1 second via advanceTimersByTime', () => {\n    const timerGame = require('../timerGame');\n    const callback = jest.fn();\n    timerGame(callback);\n\n    // At this point in time, the callback should not have been called yet\n    expect(callback).not.toHaveBeenCalled();\n\n    // Fast-forward until all timers have been executed\n    jest.advanceTimersByTime(1000);\n\n    // Now our callback should have been called!\n    expect(callback).toHaveBeenCalled();\n    expect(callback).toHaveBeenCalledTimes(1);\n  });",
            "file": "timer_game.test.js",
            "skipped": false,
            "dir": "examples/timer/__tests__"
        },
        {
            "name": "returns result from subtract",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 20,
                "column": 34
            },
            "line": 20,
            "code": "  it('returns result from subtract', () => {\n    mockSub.mockReturnValueOnce(0);\n\n    const calc = makeCalc(memory);\n    const result = calc('Sub', [2, 2]);\n\n    expect(result).toBe(0);\n    expect(mockSub).toHaveBeenCalledWith(2, 2);\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "returns result from sum",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 30,
                "column": 29
            },
            "line": 30,
            "code": "  it('returns result from sum', () => {\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const result = calc('Sum', [1, 1]);\n\n    expect(result).toBe(2);\n    expect(mockSum).toHaveBeenCalledWith(1, 1);\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "adds last result to memory",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 40,
                "column": 32
            },
            "line": 40,
            "code": "  it('adds last result to memory', () => {\n    MockMemory.prototype.add.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemoryAdd', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(MockMemory.prototype.add).toHaveBeenCalledWith(2);\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "subtracts last result to memory",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 53,
                "column": 37
            },
            "line": 53,
            "code": "  it('subtracts last result to memory', () => {\n    MockMemory.prototype.subtract.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemorySub', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(MockMemory.prototype.subtract).toHaveBeenCalledWith(2);\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "clears the memory",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 66,
                "column": 23
            },
            "line": 66,
            "code": "  it('clears the memory', () => {\n    MockMemory.prototype.add.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2).mockReturnValueOnce(4);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemoryAdd', []);\n    const sumResult2 = calc('Sum', [2, 2]);\n    const clearResult = calc('MemoryClear', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(sumResult2).toBe(4);\n    expect(clearResult).toBe(4);\n    expect(MockMemory.prototype.reset).toHaveBeenCalledTimes(1);\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "throws an error when invalid Op is passed",
            "suites": [
                "calc - mocks"
            ],
            "updatePoint": {
                "line": 83,
                "column": 47
            },
            "line": 83,
            "code": "  it('throws an error when invalid Op is passed', () => {\n    const calc = makeCalc(memory);\n\n    // @ts-expect-error\n    expect(() => calc('Multiply', [2, 3])).toThrow(new Error('Invalid op'));\n  });",
            "file": "calc.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "subtracts 5 - 1 to equal 4 in TypeScript",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 44
            },
            "line": 6,
            "code": "it('subtracts 5 - 1 to equal 4 in TypeScript', () => {\n  expect(sub(5, 1)).toBe(4);\n});",
            "file": "sub-test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "adds 1 + 2 to equal 3 in TScript",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 36
            },
            "line": 5,
            "code": "it('adds 1 + 2 to equal 3 in TScript', () => {\n  // Generally, `import` should be used for TypeScript\n  // as using `require` will not return any type information.\n  const sum = require('../sum.ts').default;\n  expect(sum(1, 2)).toBe(3);\n});",
            "file": "sum-test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "adds 1 + 2 to equal 3 in JavaScript",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 39
            },
            "line": 12,
            "code": "it('adds 1 + 2 to equal 3 in JavaScript', () => {\n  const sum = require('../sum.js');\n  expect(sum(1, 2)).toBe(3);\n});",
            "file": "sum-test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "adds 1 + 2 to equal 3 in Typescript",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 39
            },
            "line": 5,
            "code": "it('adds 1 + 2 to equal 3 in Typescript', () => {\n  const sum = require('../sum.ts').default;\n  expect(sum(1, 2)).toBe(3);\n});",
            "file": "sum.test.js",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "adds 1 + 2 to equal 3 in JavaScript",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 39
            },
            "line": 10,
            "code": "it('adds 1 + 2 to equal 3 in JavaScript', () => {\n  const sum = require('../sum.js');\n  expect(sum(1, 2)).toBe(3);\n});",
            "file": "sum.test.js",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "isLocalhost should detect localhost environment",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 51
            },
            "line": 16,
            "code": "it('isLocalhost should detect localhost environment', () => {\n  replacedEnv.replaceValue({HOSTNAME: 'localhost'});\n\n  expect(isLocalhost()).toBe(true);\n});",
            "file": "utils.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "isLocalhost should detect non-localhost environment",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 55
            },
            "line": 22,
            "code": "it('isLocalhost should detect non-localhost environment', () => {\n  expect(isLocalhost()).toBe(false);\n});",
            "file": "utils.test.ts",
            "skipped": false,
            "dir": "examples/typescript/__tests__"
        },
        {
            "name": "returns cache key hash",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 47,
                "column": 30
            },
            "line": 47,
            "code": "  test('returns cache key hash', () => {\n    expect(oldCacheKey).toHaveLength(32);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `THIS_FILE` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 51,
                "column": 40
            },
            "line": 51,
            "code": "  test('if `THIS_FILE` value is changing', async () => {\n    jest.doMock('graceful-fs', () => ({\n      readFileSync: () => 'new this file',\n    }));\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `babelOptions.options` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 68,
                "column": 51
            },
            "line": 68,
            "code": "  test('if `babelOptions.options` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          options: 'new-options',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `sourceText` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 92,
                "column": 41
            },
            "line": 92,
            "code": "  test('if `sourceText` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      'new source text',\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `sourcePath` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 102,
                "column": 41
            },
            "line": 102,
            "code": "  test('if `sourcePath` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      sourceText,\n      'new-source-path.js',\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `configString` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 112,
                "column": 43
            },
            "line": 112,
            "code": "  test('if `configString` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      configString: 'new-config-string',\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `babelOptions.config` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 121,
                "column": 50
            },
            "line": 121,
            "code": "  test('if `babelOptions.config` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          config: 'new-config',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `babelOptions.babelrc` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 145,
                "column": 51
            },
            "line": 145,
            "code": "  test('if `babelOptions.babelrc` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          babelrc: 'new-babelrc',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `instrument` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 169,
                "column": 41
            },
            "line": 169,
            "code": "  test('if `instrument` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      instrument: false,\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `process.env.NODE_ENV` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 178,
                "column": 51
            },
            "line": 178,
            "code": "  test('if `process.env.NODE_ENV` value is changing', () => {\n    process.env.NODE_ENV = 'NEW_NODE_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if `process.env.BABEL_ENV` value is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 186,
                "column": 52
            },
            "line": 186,
            "code": "  test('if `process.env.BABEL_ENV` value is changing', () => {\n    process.env.BABEL_ENV = 'NEW_BABEL_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "if node version is changing",
            "suites": [
                "getCacheKey"
            ],
            "updatePoint": {
                "line": 194,
                "column": 35
            },
            "line": 194,
            "code": "  test('if node version is changing', () => {\n    // @ts-expect-error: Testing purpose\n    delete process.version;\n    process.version = 'new-node-version';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });",
            "file": "getCacheKey.test.ts",
            "skipped": false,
            "dir": "packages/babel-jest/src/__tests__"
        },
        {
            "name": "is not a number",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 16,
                "column": 25
            },
            "line": 16,
            "code": "    test('is not a number', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff('0', 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "Infinity is not a safe integer",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 22,
                "column": 40
            },
            "line": 22,
            "code": "    test('Infinity is not a safe integer', () => {\n      expect(() => {\n        diff(Infinity, 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "Not a Number is not a safe integer",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 27,
                "column": 44
            },
            "line": 27,
            "code": "    test('Not a Number is not a safe integer', () => {\n      expect(() => {\n        diff(NaN, 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "MAX_SAFE_INTEGER + 1 is not a safe integer",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 33,
                "column": 52
            },
            "line": 33,
            "code": "    test('MAX_SAFE_INTEGER + 1 is not a safe integer', () => {\n      expect(() => {\n        diff(0, Number.MAX_SAFE_INTEGER + 1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "MIN_SAFE_INTEGER - 1 is not a safe integer",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 38,
                "column": 52
            },
            "line": 38,
            "code": "    test('MIN_SAFE_INTEGER - 1 is not a safe integer', () => {\n      expect(() => {\n        diff(0, Number.MIN_SAFE_INTEGER - 1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "is a negative integer",
            "suites": [
                "invalid arg",
                "length"
            ],
            "updatePoint": {
                "line": 43,
                "column": 31
            },
            "line": 43,
            "code": "    test('is a negative integer', () => {\n      expect(() => {\n        diff(0, -1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "null is not a function",
            "suites": [
                "invalid arg",
                "callback"
            ],
            "updatePoint": {
                "line": 51,
                "column": 32
            },
            "line": 51,
            "code": "    test('null is not a function', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff(0, 0, null, foundSubsequence);\n      }).toThrow(/isCommon/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "undefined is not a function",
            "suites": [
                "invalid arg",
                "callback"
            ],
            "updatePoint": {
                "line": 57,
                "column": 37
            },
            "line": 57,
            "code": "    test('undefined is not a function', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff(0, 0, isCommon, undefined);\n      }).toThrow(/foundSubsequence/);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "are not common according to Object.is method",
            "suites": [
                "input callback encapsulates comparison",
                "zero and negative zero"
            ],
            "updatePoint": {
                "line": 102,
                "column": 54
            },
            "line": 102,
            "code": "    test('are not common according to Object.is method', () => {\n      expect(countCommonObjectIs(a, b)).toBe(0);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "are common according to === operator",
            "suites": [
                "input callback encapsulates comparison",
                "zero and negative zero"
            ],
            "updatePoint": {
                "line": 105,
                "column": 46
            },
            "line": 105,
            "code": "    test('are common according to === operator', () => {\n      expect(countCommonStrictEquality(a, b)).toBe(1);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "is common according to Object.is method",
            "suites": [
                "input callback encapsulates comparison",
                "Not a Number"
            ],
            "updatePoint": {
                "line": 114,
                "column": 49
            },
            "line": 114,
            "code": "    test('is common according to Object.is method', () => {\n      expect(countCommonObjectIs(a, a)).toBe(1);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "is not common according to === operator",
            "suites": [
                "input callback encapsulates comparison",
                "Not a Number"
            ],
            "updatePoint": {
                "line": 117,
                "column": 49
            },
            "line": 117,
            "code": "    test('is not common according to === operator', () => {\n      expect(countCommonStrictEquality(a, a)).toBe(0);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "arrays of strings",
            "suites": [
                "input callback encapsulates sequences"
            ],
            "updatePoint": {
                "line": 265,
                "column": 25
            },
            "line": 265,
            "code": "  test('arrays of strings', () => {\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "string and array of strings",
            "suites": [
                "input callback encapsulates sequences"
            ],
            "updatePoint": {
                "line": 268,
                "column": 35
            },
            "line": 268,
            "code": "  test('string and array of strings', () => {\n    expectCommonItems(a.join(''), b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "strings",
            "suites": [
                "input callback encapsulates sequences"
            ],
            "updatePoint": {
                "line": 271,
                "column": 15
            },
            "line": 271,
            "code": "  test('strings', () => {\n    expectCommonItems(a.join(''), b.join(''), expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "of a",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 295,
                "column": 14
            },
            "line": 295,
            "code": "    test('of a', () => {\n      expect(countItemsNegativeZero(-0, 1)).toBe(0);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "of b",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 298,
                "column": 14
            },
            "line": 298,
            "code": "    test('of b', () => {\n      expect(countItemsNegativeZero(1, -0)).toBe(0);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "of a and b",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 301,
                "column": 20
            },
            "line": 301,
            "code": "    test('of a and b', () => {\n      expect(countItemsNegativeZero(-0, -0)).toBe(0);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "a empty and b empty",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 306,
                "column": 27
            },
            "line": 306,
            "code": "  test('a empty and b empty', () => {\n    const a: Array<unknown> = [];\n    const b: Array<unknown> = [];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "a empty and b non-empty",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 312,
                "column": 31
            },
            "line": 312,
            "code": "  test('a empty and b non-empty', () => {\n    const a: Array<unknown> = [];\n    const b = [false];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "a non-empty and b empty",
            "suites": [
                "no common items",
                "negative zero is equivalent to zero for length"
            ],
            "updatePoint": {
                "line": 318,
                "column": 31
            },
            "line": 318,
            "code": "  test('a non-empty and b empty', () => {\n    const a = [false, true];\n    const b: Array<unknown> = [];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "baDeltaLength 0 even",
            "suites": [
                "no common items",
                "a non-empty and b non-empty"
            ],
            "updatePoint": {
                "line": 327,
                "column": 30
            },
            "line": 327,
            "code": "    test('baDeltaLength 0 even', () => {\n      // findSubsequences not transposed because graph is square\n      // reverse path overlaps on first iteration with d === 1\n      // last segment cannot have a prev segment\n      const a = [false];\n      const b = [true];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "baDeltaLength 1 odd",
            "suites": [
                "no common items",
                "a non-empty and b non-empty"
            ],
            "updatePoint": {
                "line": 336,
                "column": 29
            },
            "line": 336,
            "code": "    test('baDeltaLength 1 odd', () => {\n      // findSubsequences transposed because graph has landscape orientation\n      // forward path overlaps on first iteration with d === 2\n      // last segment has a prev segment because unroll a half iteration\n      const a = [0, 1];\n      const b = ['0'];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "baDeltaLength 2 even",
            "suites": [
                "no common items",
                "a non-empty and b non-empty"
            ],
            "updatePoint": {
                "line": 345,
                "column": 30
            },
            "line": 345,
            "code": "    test('baDeltaLength 2 even', () => {\n      // findSubsequences transposed because graph has landscape orientation\n      // reverse path overlaps with d === 3\n      // last segment has a prev segment\n      const a = [0, 1, 2, 3];\n      const b = ['0', '1'];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "baDeltaLength 7 odd",
            "suites": [
                "no common items",
                "a non-empty and b non-empty"
            ],
            "updatePoint": {
                "line": 354,
                "column": 29
            },
            "line": 354,
            "code": "    test('baDeltaLength 7 odd', () => {\n      // findSubsequences not transposed because graph has portrait orientation\n      // forward path overlaps with d === 7\n      // last segment has a prev segment\n      const a = ['0', '1', '2'];\n      const b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "length 1",
            "suites": [
                "only common items"
            ],
            "updatePoint": {
                "line": 370,
                "column": 16
            },
            "line": 370,
            "code": "  test('length 1', () => {\n    const a = [false];\n    expectCommonItems(a, a, a);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "length 2",
            "suites": [
                "only common items"
            ],
            "updatePoint": {
                "line": 374,
                "column": 16
            },
            "line": 374,
            "code": "  test('length 2', () => {\n    const a = [false, true];\n    expectCommonItems(a, a, a);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "preceding changes",
            "suites": [
                "all common items outside"
            ],
            "updatePoint": {
                "line": 386,
                "column": 25
            },
            "line": 386,
            "code": "  test('preceding changes', () => {\n    // default export trims common item from the start\n    const a = [common1];\n    const b = [common1, 'insert1', 'insert2'];\n    const expected = [common1];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "following change",
            "suites": [
                "all common items outside"
            ],
            "updatePoint": {
                "line": 393,
                "column": 24
            },
            "line": 393,
            "code": "  test('following change', () => {\n    // default export trims common items from the end\n    const a = ['delete1', common1, common2];\n    const b = [common1, common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "preceding and following changes in one sequence",
            "suites": [
                "all common items outside"
            ],
            "updatePoint": {
                "line": 400,
                "column": 55
            },
            "line": 400,
            "code": "  test('preceding and following changes in one sequence', () => {\n    // default export trims common items from the start and end\n    const a = [common1, common2, 'delete1', 'delete2', common3];\n    const b = [common1, common2, common3];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "preceding changes adjacent to common in both sequences",
            "suites": [
                "some common items inside and outside"
            ],
            "updatePoint": {
                "line": 414,
                "column": 62
            },
            "line": 414,
            "code": "  test('preceding changes adjacent to common in both sequences', () => {\n    // default export trims common item from the start\n    // baDeltaLength 0 even\n    // common item follows last (only) reverse segment when d === 1\n    const a = [common1, common2, 'delete1_lastR'];\n    const b = [common1, 'insert1', common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "following changes adjacent to common in both sequences",
            "suites": [
                "some common items inside and outside"
            ],
            "updatePoint": {
                "line": 423,
                "column": 62
            },
            "line": 423,
            "code": "  test('following changes adjacent to common in both sequences', () => {\n    // default export trims common item from the end\n    // baDeltaLength 1 odd\n    // common item follows prev (but not last) forward segment when d === 2\n    const a = [common1, 'delete1', common2];\n    const b = ['insert1_prevF', common1, 'insert2_lastF', common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "move from start to end relative to change",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 441,
                "column": 49
            },
            "line": 441,
            "code": "  test('move from start to end relative to change', () => {\n    // baDeltaLength 0 even\n    // common items follow last (only) reverse segment when d === 1\n    const a = [common1, common2, 'delete1'];\n    const b = ['insert1', common1, common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "move from start to end relative to common",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 449,
                "column": 49
            },
            "line": 449,
            "code": "  test('move from start to end relative to common', () => {\n    // baDeltaLength 0 even\n    // common items follow last (only) reverse segment when d === 1\n    const a = [common1, common2, common3];\n    const b = [common3, common1, common2];\n    // common3 is delete from a and insert from b\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "move from start to end relative to change and common",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 458,
                "column": 60
            },
            "line": 458,
            "code": "  test('move from start to end relative to change and common', () => {\n    // baDeltaLength 0 even\n    // common items follow last reverse segment when d === 3\n    const a = [common1, common2, 'delete1_lastR', common3, 'delete2'];\n    const b = ['insert1', common3, 'insert2', common1, common2];\n    // common3 is delete from a and insert from b\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "reverse relative to change",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 467,
                "column": 34
            },
            "line": 467,
            "code": "  test('reverse relative to change', () => {\n    // baDeltaLength 0 even\n    // common item follows last reverse segment when d === 4\n    const a = [common1, 'delete1', common2, 'delete2', common3];\n    const b = [common3, 'insert1_lastR', common2, 'insert2', common1];\n\n    // Because a and b have more than one longest common subsequence,\n    // expected value might change if implementation changes.\n    // common1 and common2 are delete from a and insert from b\n    const expected = [common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "preceding middle",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 480,
                "column": 24
            },
            "line": 480,
            "code": "  test('preceding middle', () => {\n    // baDeltaLength 1 odd\n    // common items follow prev and last forward segments when d === 3\n    const a = ['delete1', common1, common2, common3, 'delete2'];\n    const b = [\n      'insert1_prevF',\n      common1,\n      'insert2_lastF',\n      common2,\n      common3,\n      'insert3',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "following middle",
            "suites": [
                "all common items inside non-recursive"
            ],
            "updatePoint": {
                "line": 495,
                "column": 24
            },
            "line": 495,
            "code": "  test('following middle', () => {\n    // baDeltaLength 2 even\n    // common items follow prev and last reverse segments when d === 4\n    const a = ['delete1', 'delete2', common1, common2, common3, 'delete3'];\n    const b = [\n      'insert1',\n      'insert2',\n      common1,\n      common2,\n      'insert3_lastR',\n      common3,\n      'insert4_prevR',\n      'insert5',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "prev reverse at depth 1 and preceding at depth 2",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 524,
                "column": 56
            },
            "line": 524,
            "code": "  test('prev reverse at depth 1 and preceding at depth 2', () => {\n    // depth 1 common item follows prev reverse segment when d === 3\n    // depth 2 preceding common items follow prev and last forward segments when d === 2\n    const a = [\n      'delete1_depth2_preceding_prevF',\n      common1,\n      common2,\n      common3,\n      'delete2_depth1_prevR',\n      'delete3',\n    ];\n    const b = [\n      common1,\n      'insert1_depth2_preceding_lastF',\n      common2,\n      'insert2',\n      'insert3_depth1_lastR',\n      common3,\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "last forward at depth 1 and following at depth 2",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 546,
                "column": 56
            },
            "line": 546,
            "code": "  test('last forward at depth 1 and following at depth 2', () => {\n    // depth 1 common item follows last forward segment when d === 5\n    // depth 2 following common items follow prev and last reverse segments when d === 2\n    const a = [\n      'delete1',\n      'delete2',\n      common1,\n      'delete3',\n      common2,\n      'delete4_depth2_following_lastR',\n      common3,\n    ];\n    const b = [\n      'insert1',\n      'insert2',\n      'insert3_depth1_lastF',\n      common1,\n      'insert4',\n      common2,\n      common3,\n      'insert5_depth2_following_prevR',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "preceding at depth 2 and both at depth 3 of following",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 571,
                "column": 61
            },
            "line": 571,
            "code": "  test('preceding at depth 2 and both at depth 3 of following', () => {\n    // depth 1 transposed from landscape to portrait so swap args\n    // depth 1 common items do not follow prev nor last forward segment when d === 8\n    // depth 2 preceding common item follows prev forward segment when d === 4\n    // depth 2 following transposed again so unswap swapped args\n    // depth 2 following common items do not follow prev nor last foward segment when d === 4\n    // depth 3 preceding common item follows last forward segment when d === 2\n    // depth 3 following rransposed again so swap args again\n    // depth 3 following common item follows last forward segment when d === 2\n    const a = [\n      'delete1_depth2_preceding_prevF',\n      common1,\n      'delete2_depth2_preceding_middle',\n      'delete3',\n      'delete4',\n      'delete5_depth1_middle',\n      common2,\n      'delete6',\n      'delete7',\n      'delete8_depth3_following_lastF',\n      common3,\n    ];\n    const b = [\n      'insert1',\n      'insert2',\n      common1,\n      'insert3',\n      'insert4',\n      'insert5_depth3_preceding_lastF',\n      common2,\n      'insert6_depth2_following_middle',\n      common3,\n      'insert7',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "interleaved single change",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 609,
                "column": 33
            },
            "line": 609,
            "code": "  test('interleaved single change', () => {\n    // depth 1 common items follow prev and last forward segment when d === 4\n    // depth 2 preceding common items follow prev and last forward segment when d === 2\n    // depth 2 following common items follow prev and last forward segment when d === 2\n    const a = [common1, common2, common3, common4, common5, common6];\n    const b = [\n      'insert1_depth_2_preceding_prevF',\n      common1,\n      'insert2_depth2_preceding_lastF',\n      common2,\n      'insert3_depth1_prevF',\n      common3,\n      'insert4_depth1_lastF',\n      common4,\n      'insert5_depth2_following_prevF',\n      common5,\n      'insert6_depth2_following_lastF',\n      common6,\n      'insert7',\n    ];\n    const expected = [common1, common2, common3, common4, common5, common6];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "interleaved double changes",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 632,
                "column": 34
            },
            "line": 632,
            "code": "  test('interleaved double changes', () => {\n    // depth 1 common item follows prev reverse segment when d === 7\n    // depth 2 preceding transposed from landscape to portrait so swap args\n    // depth 2 preceding common item follows last forward segment when d === 4\n    // depth 3 preceding transposed again so unswap swapped args\n    // depth 3 preceding preceding common item follows last forward segment when d === 2\n    // depth 2 following common item follows prev reverse segment when d === 3\n    // depth 3 following preceding transposed\n    // depth 3 following preceding common item follows last forward segment when d === 2\n    const a = [\n      'delete1',\n      common1,\n      'delete2_depth2_preceding_lastF',\n      common2,\n      'delete3_depth3_preceding_following_lastF',\n      common3,\n      'delete4',\n      common4,\n      'delete5_depth3_following_preceding_lastF',\n      common5,\n      'delete6',\n      common6,\n      'delete7',\n    ];\n    const b = [\n      'insert1_depth3_preceding_preceding_lastF',\n      common1,\n      'insert2',\n      common2,\n      'insert3',\n      common3,\n      'insert4_depth1_middle',\n      common4,\n      'insert5_depth1_prevR',\n      common5,\n      'insert6',\n      common6,\n      'insert7_depth2_following_prevR',\n    ];\n    const expected = [common1, common2, common3, common4, common5, common6];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "optimization decreases iMaxF",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 675,
                "column": 36
            },
            "line": 675,
            "code": "  test('optimization decreases iMaxF', () => {\n    // iMaxF 3 initially because aLength\n    // iMaxF 1 at d === 4\n    // depth 1 common items do not follow prev nor last forward segment when d === 5\n    // depth 2 preceding common item follows last forward segment when d === 3\n    // depth 3 preceding preceding common item follows last (only) reverse segment when d === 1\n    const a = [common1, 'delete1_depth3_lastR', common2];\n    const b = [\n      'insert1',\n      common1,\n      'insert2_depth2_lastF',\n      common2,\n      'insert3',\n      'insert4',\n      'insert5',\n      'insert6',\n      'insert7',\n      'insert8',\n      'insert9',\n    ];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "optimization decreases iMaxR",
            "suites": [
                "all common items inside recursive"
            ],
            "updatePoint": {
                "line": 698,
                "column": 36
            },
            "line": 698,
            "code": "  test('optimization decreases iMaxR', () => {\n    // iMaxF 3 initially because aLength\n    // iMaxR 0 at d === 2\n    // depth 1 common items do not follow prev nor last forward segment when d === 5\n    // depth 2 following common items follow prev reverse segment when d === 2\n    const a = [common1, common2];\n    const b = [\n      'insert1',\n      'insert2',\n      'insert3',\n      'insert4',\n      'insert5_depth1_middle',\n      'insert6',\n      'insert7',\n      'insert8_depth2_middle',\n      common1,\n      common2,\n      'insert9_depth2_prevR',\n    ];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "progress",
            "suites": [
                "common substrings"
            ],
            "updatePoint": {
                "line": 767,
                "column": 16
            },
            "line": 767,
            "code": "  test('progress', () => {\n    // Confirm expected progress. If change is correct, then update test.\n    // A property value changes from an object to an array of objects.\n    // prettier-ignore\n    const a = [\n      '\"sorting\": Object {',\n      '\"ascending\": true,',\n    ].join('\\n');\n    // prettier-ignore\n    const b = [\n      '\"sorting\": Array [',\n      'Object {',\n      '\"descending\": false,',\n    ].join('\\n');\n    const expected = ['\"sorting\": ', 'Object {\\n\"', 'scending\": ', 'e,'];\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toEqual(expected);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "regression",
            "suites": [
                "common substrings"
            ],
            "updatePoint": {
                "line": 787,
                "column": 18
            },
            "line": 787,
            "code": "  test('regression', () => {\n    // Prevent unexpected regression. If change is incorrect, then fix code.\n    // Internationalization fails for a text node.\n    // English translation and French quotation by Antoine de Saint Exupéry:\n    const a =\n      'It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to remove.';\n    const b =\n      \"Il semble que la perfection soit atteinte non quand il n'y a plus rien à ajouter, mais quand il n'y a plus rien à retrancher.\";\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toMatchSnapshot();\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "wrapping",
            "suites": [
                "common substrings"
            ],
            "updatePoint": {
                "line": 800,
                "column": 16
            },
            "line": 800,
            "code": "  test('wrapping', () => {\n    const a = [\n      'When engineers are provided with ready-to-use tools, they end up writing more',\n      'tests, which in turn results in more stable code bases.',\n    ].join('\\n');\n    const b = [\n      'When engineers have ready-to-use tools, they write more tests, which results in',\n      'more stable and healthy code bases.',\n    ].join('\\n');\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toMatchSnapshot();\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/diff-sequences/src/__tests__"
        },
        {
            "name": "does not throw",
            "suites": [
                ".assertions()"
            ],
            "updatePoint": {
                "line": 15,
                "column": 20
            },
            "line": 15,
            "code": "  it('does not throw', () => {\n    jestExpect.assertions(2);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "redeclares different assertion count",
            "suites": [
                ".assertions()"
            ],
            "updatePoint": {
                "line": 21,
                "column": 42
            },
            "line": 21,
            "code": "  it('redeclares different assertion count', () => {\n    jestExpect.assertions(3);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n    jestExpect.assertions(2);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "expects no assertions",
            "suites": [
                ".assertions()"
            ],
            "updatePoint": {
                "line": 27,
                "column": 27
            },
            "line": 27,
            "code": "  it('expects no assertions', () => {\n    jestExpect.assertions(0);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not throw if there is an assertion",
            "suites": [
                ".hasAssertions()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 45
            },
            "line": 33,
            "code": "  it('does not throw if there is an assertion', () => {\n    jestExpect.hasAssertions();\n    jestExpect('a').toBe('a');\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws if expected is not undefined",
            "suites": [
                ".hasAssertions()"
            ],
            "updatePoint": {
                "line": 38,
                "column": 41
            },
            "line": 38,
            "code": "  it('throws if expected is not undefined', () => {\n    expect(() => {\n      // @ts-expect-error\n      jestExpect.hasAssertions(2);\n    }).toThrowErrorMatchingSnapshot();\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "hasAssertions not leaking to global state",
            "suites": [
                ".hasAssertions()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 47
            },
            "line": 45,
            "code": "  it('hasAssertions not leaking to global state', () => {});",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "verify the default value of numPassingAsserts",
            "suites": [
                "numPassingAsserts"
            ],
            "updatePoint": {
                "line": 49,
                "column": 51
            },
            "line": 49,
            "code": "  it('verify the default value of numPassingAsserts', () => {\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "verify the resetting of numPassingAsserts after a test",
            "suites": [
                "numPassingAsserts"
            ],
            "updatePoint": {
                "line": 54,
                "column": 60
            },
            "line": 54,
            "code": "  it('verify the resetting of numPassingAsserts after a test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    // reset state\n    jestExpect.extractExpectedAssertionsErrors();\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "verify the correctness of numPassingAsserts count for passing test",
            "suites": [
                "numPassingAsserts"
            ],
            "updatePoint": {
                "line": 63,
                "column": 72
            },
            "line": 63,
            "code": "  it('verify the correctness of numPassingAsserts count for passing test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(2);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "verify the correctness of numPassingAsserts count for failing test",
            "suites": [
                "numPassingAsserts"
            ],
            "updatePoint": {
                "line": 70,
                "column": 72
            },
            "line": 70,
            "code": "  it('verify the correctness of numPassingAsserts count for failing test', () => {\n    expect('a').toBe('a');\n    try {\n      expect('a').toBe('b');\n    } catch (error) {}\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(1);\n  });",
            "file": "assertionCounts.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Any.asymmetricMatch()",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 27
            },
            "line": 25,
            "code": "test('Any.asymmetricMatch()', () => {\n  class Thing {}\n\n  [\n    any(String).asymmetricMatch('jest'),\n    any(Number).asymmetricMatch(1),\n    any(Function).asymmetricMatch(() => {}),\n    any(Boolean).asymmetricMatch(true),\n    any(BigInt).asymmetricMatch(1n),\n    any(Symbol).asymmetricMatch(Symbol()),\n    any(Object).asymmetricMatch({}),\n    any(Object).asymmetricMatch(null),\n    any(Array).asymmetricMatch([]),\n    any(Thing).asymmetricMatch(new Thing()),\n  ].forEach(test => {\n    jestExpect(test).toBe(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Any.asymmetricMatch() on primitive wrapper classes",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 56
            },
            "line": 44,
            "code": "test('Any.asymmetricMatch() on primitive wrapper classes', () => {\n  [\n    // eslint-disable-next-line no-new-wrappers\n    any(String).asymmetricMatch(new String('jest')),\n    // eslint-disable-next-line no-new-wrappers\n    any(Number).asymmetricMatch(new Number(1)),\n    // eslint-disable-next-line no-new-func\n    any(Function).asymmetricMatch(new Function('() => {}')),\n    // eslint-disable-next-line no-new-wrappers\n    any(Boolean).asymmetricMatch(new Boolean(true)),\n    any(BigInt).asymmetricMatch(Object(1n)),\n    any(Symbol).asymmetricMatch(Object(Symbol())),\n  ].forEach(test => {\n    jestExpect(test).toBe(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Any.toAsymmetricMatcher()",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 31
            },
            "line": 61,
            "code": "test('Any.toAsymmetricMatcher()', () => {\n  jestExpect(any(Number).toAsymmetricMatcher()).toBe('Any<Number>');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Any.toAsymmetricMatcher() with function name",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 50
            },
            "line": 65,
            "code": "test('Any.toAsymmetricMatcher() with function name', () => {\n  [\n    ['someFunc', function someFunc() {}],\n    ['$someFunc', function $someFunc() {}],\n    [\n      '$someFunc2',\n      (function () {\n        function $someFunc2() {}\n        Object.defineProperty($someFunc2, 'name', {value: ''});\n        return $someFunc2;\n      })(),\n    ],\n    [\n      '$someAsyncFunc',\n      (function () {\n        async function $someAsyncFunc() {}\n        Object.defineProperty($someAsyncFunc, 'name', {value: ''});\n        return $someAsyncFunc;\n      })(),\n    ],\n    [\n      '$someGeneratorFunc',\n      (function () {\n        function* $someGeneratorFunc() {}\n        Object.defineProperty($someGeneratorFunc, 'name', {value: ''});\n        return $someGeneratorFunc;\n      })(),\n    ],\n    [\n      '$someFuncWithFakeToString',\n      (function () {\n        function $someFuncWithFakeToString() {}\n        $someFuncWithFakeToString.toString = () => 'Fake to string';\n        return $someFuncWithFakeToString;\n      })(),\n    ],\n  ].forEach(([name, fn]) => {\n    jestExpect(any(fn).toAsymmetricMatcher()).toBe(`Any<${name}>`);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Any throws when called with empty constructor",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 51
            },
            "line": 106,
            "code": "test('Any throws when called with empty constructor', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => any()).toThrow(\n    'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',\n  );\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Anything matches any type",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 31
            },
            "line": 113,
            "code": "test('Anything matches any type', () => {\n  [\n    anything().asymmetricMatch('jest'),\n    anything().asymmetricMatch(1),\n    anything().asymmetricMatch(() => {}),\n    anything().asymmetricMatch(true),\n    anything().asymmetricMatch({}),\n    anything().asymmetricMatch([]),\n  ].forEach(test => {\n    jestExpect(test).toBe(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Anything does not match null and undefined",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 48
            },
            "line": 126,
            "code": "test('Anything does not match null and undefined', () => {\n  [\n    anything().asymmetricMatch(null),\n    anything().asymmetricMatch(undefined),\n  ].forEach(test => {\n    jestExpect(test).toBe(false);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "Anything.toAsymmetricMatcher()",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 36
            },
            "line": 135,
            "code": "test('Anything.toAsymmetricMatcher()', () => {\n  jestExpect(anything().toAsymmetricMatcher()).toBe('Anything');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayContaining matches",
            "suites": [],
            "updatePoint": {
                "line": 139,
                "column": 29
            },
            "line": 139,
            "code": "test('ArrayContaining matches', () => {\n  [\n    arrayContaining([]).asymmetricMatch('jest'),\n    arrayContaining(['foo']).asymmetricMatch(['foo']),\n    arrayContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayContaining([]).asymmetricMatch({}),\n  ].forEach(test => {\n    jestExpect(test).toEqual(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayContaining does not match",
            "suites": [],
            "updatePoint": {
                "line": 150,
                "column": 36
            },
            "line": 150,
            "code": "test('ArrayContaining does not match', () => {\n  jestExpect(arrayContaining(['foo']).asymmetricMatch(['bar'])).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayContaining throws for non-arrays",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 43
            },
            "line": 154,
            "code": "test('ArrayContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayContaining, not 'string'.\");\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayNotContaining matches",
            "suites": [],
            "updatePoint": {
                "line": 161,
                "column": 32
            },
            "line": 161,
            "code": "test('ArrayNotContaining matches', () => {\n  jestExpect(arrayNotContaining(['foo']).asymmetricMatch(['bar'])).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayNotContaining does not match",
            "suites": [],
            "updatePoint": {
                "line": 165,
                "column": 39
            },
            "line": 165,
            "code": "test('ArrayNotContaining does not match', () => {\n  [\n    arrayNotContaining([]).asymmetricMatch('jest'),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo']),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayNotContaining([]).asymmetricMatch({}),\n  ].forEach(test => {\n    jestExpect(test).toEqual(false);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ArrayNotContaining throws for non-arrays",
            "suites": [],
            "updatePoint": {
                "line": 176,
                "column": 46
            },
            "line": 176,
            "code": "test('ArrayNotContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayNotContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayNotContaining, not 'string'.\");\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining matches",
            "suites": [],
            "updatePoint": {
                "line": 183,
                "column": 30
            },
            "line": 183,
            "code": "test('ObjectContaining matches', () => {\n  [\n    objectContaining({}).asymmetricMatch('jest'),\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foo', jest: 'jest'}),\n    objectContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectContaining({first: objectContaining({second: {}})}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectContaining({foo: Buffer.from('foo')}).asymmetricMatch({\n      foo: Buffer.from('foo'),\n      jest: 'jest',\n    }),\n  ].forEach(test => {\n    jestExpect(test).toEqual(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining does not match",
            "suites": [],
            "updatePoint": {
                "line": 200,
                "column": 37
            },
            "line": 200,
            "code": "test('ObjectContaining does not match', () => {\n  [\n    objectContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectContaining({foo: undefined}).asymmetricMatch({}),\n    objectContaining({\n      answer: 42,\n      foo: {bar: 'baz', foobar: 'qux'},\n    }).asymmetricMatch({foo: {bar: 'baz'}}),\n  ].forEach(test => {\n    jestExpect(test).toEqual(false);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining matches defined properties",
            "suites": [],
            "updatePoint": {
                "line": 214,
                "column": 49
            },
            "line": 214,
            "code": "test('ObjectContaining matches defined properties', () => {\n  const definedPropertyObject = {};\n  Object.defineProperty(definedPropertyObject, 'foo', {get: () => 'bar'});\n  jestExpect(\n    objectContaining({foo: 'bar'}).asymmetricMatch(definedPropertyObject),\n  ).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining matches prototype properties",
            "suites": [],
            "updatePoint": {
                "line": 222,
                "column": 51
            },
            "line": 222,
            "code": "test('ObjectContaining matches prototype properties', () => {\n  const prototypeObject = {foo: 'bar'};\n  let obj;\n\n  if (Object.create) {\n    obj = Object.create(prototypeObject);\n  } else {\n    function Foo() {}\n    Foo.prototype = prototypeObject;\n    Foo.prototype.constructor = Foo;\n    obj = new (Foo as any)();\n  }\n  jestExpect(objectContaining({foo: 'bar'}).asymmetricMatch(obj)).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining throws for non-objects",
            "suites": [],
            "updatePoint": {
                "line": 237,
                "column": 45
            },
            "line": 237,
            "code": "test('ObjectContaining throws for non-objects', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => objectContaining(1337).asymmetricMatch()).toThrow(\n    \"You must provide an object to ObjectContaining, not 'number'.\",\n  );\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectContaining does not mutate the sample",
            "suites": [],
            "updatePoint": {
                "line": 244,
                "column": 49
            },
            "line": 244,
            "code": "test('ObjectContaining does not mutate the sample', () => {\n  const sample = {foo: {bar: {}}};\n  const sample_json = JSON.stringify(sample);\n  expect({foo: {bar: {}}}).toEqual(expect.objectContaining(sample));\n\n  expect(JSON.stringify(sample)).toEqual(sample_json);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectNotContaining matches",
            "suites": [],
            "updatePoint": {
                "line": 252,
                "column": 33
            },
            "line": 252,
            "code": "test('ObjectNotContaining matches', () => {\n  [\n    objectContaining({}).asymmetricMatch(null),\n    objectContaining({}).asymmetricMatch(undefined),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectNotContaining({foo: undefined}).asymmetricMatch({}),\n    objectNotContaining({\n      first: objectNotContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({first: {second: {}, third: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}, third: {}},\n    }),\n    objectNotContaining({foo: 'foo', jest: 'jest'}).asymmetricMatch({\n      foo: 'foo',\n    }),\n  ].forEach(test => {\n    jestExpect(test).toEqual(true);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectNotContaining does not match",
            "suites": [],
            "updatePoint": {
                "line": 276,
                "column": 40
            },
            "line": 276,
            "code": "test('ObjectNotContaining does not match', () => {\n  [\n    objectNotContaining({}).asymmetricMatch('jest'),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({\n      foo: 'foo',\n      jest: 'jest',\n    }),\n    objectNotContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({\n      first: objectContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({}).asymmetricMatch(null),\n    objectNotContaining({}).asymmetricMatch(undefined),\n    objectNotContaining({}).asymmetricMatch({}),\n  ].forEach(test => {\n    jestExpect(test).toEqual(false);\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectNotContaining inverts ObjectContaining",
            "suites": [],
            "updatePoint": {
                "line": 298,
                "column": 50
            },
            "line": 298,
            "code": "test('ObjectNotContaining inverts ObjectContaining', () => {\n  (\n    [\n      [{}, null],\n      [{foo: 'foo'}, {foo: 'foo', jest: 'jest'}],\n      [{foo: 'foo', jest: 'jest'}, {foo: 'foo'}],\n      [{foo: undefined}, {foo: undefined}],\n      [{foo: undefined}, {}],\n      [{first: {second: {}}}, {first: {second: {}}}],\n      [{first: objectContaining({second: {}})}, {first: {second: {}}}],\n      [{first: objectNotContaining({second: {}})}, {first: {second: {}}}],\n      [{}, {foo: undefined}],\n    ] as const\n  ).forEach(([sample, received]) => {\n    jestExpect(objectNotContaining(sample).asymmetricMatch(received)).toEqual(\n      !objectContaining(sample).asymmetricMatch(received),\n    );\n  });\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "ObjectNotContaining throws for non-objects",
            "suites": [],
            "updatePoint": {
                "line": 318,
                "column": 48
            },
            "line": 318,
            "code": "test('ObjectNotContaining throws for non-objects', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    objectNotContaining(1337).asymmetricMatch();\n  }).toThrow(\n    \"You must provide an object to ObjectNotContaining, not 'number'.\",\n  );\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringContaining matches string against string",
            "suites": [],
            "updatePoint": {
                "line": 327,
                "column": 52
            },
            "line": 327,
            "code": "test('StringContaining matches string against string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch('queen*')).toBe(true);\n  jestExpect(stringContaining('en').asymmetricMatch('queue')).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringContaining throws if expected value is not string",
            "suites": [],
            "updatePoint": {
                "line": 332,
                "column": 61
            },
            "line": 332,
            "code": "test('StringContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringContaining returns false if received value is not string",
            "suites": [],
            "updatePoint": {
                "line": 339,
                "column": 68
            },
            "line": 339,
            "code": "test('StringContaining returns false if received value is not string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch(1)).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotContaining matches string against string",
            "suites": [],
            "updatePoint": {
                "line": 343,
                "column": 55
            },
            "line": 343,
            "code": "test('StringNotContaining matches string against string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch('queen*')).toBe(false);\n  jestExpect(stringNotContaining('en').asymmetricMatch('queue')).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotContaining throws if expected value is not string",
            "suites": [],
            "updatePoint": {
                "line": 348,
                "column": 64
            },
            "line": 348,
            "code": "test('StringNotContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotContaining returns true if received value is not string",
            "suites": [],
            "updatePoint": {
                "line": 355,
                "column": 70
            },
            "line": 355,
            "code": "test('StringNotContaining returns true if received value is not string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch(1)).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringMatching matches string against regexp",
            "suites": [],
            "updatePoint": {
                "line": 359,
                "column": 50
            },
            "line": 359,
            "code": "test('StringMatching matches string against regexp', () => {\n  jestExpect(stringMatching(/en/).asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching(/en/).asymmetricMatch('queue')).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringMatching matches string against string",
            "suites": [],
            "updatePoint": {
                "line": 364,
                "column": 50
            },
            "line": 364,
            "code": "test('StringMatching matches string against string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching('en').asymmetricMatch('queue')).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringMatching throws if expected value is neither string nor regexp",
            "suites": [],
            "updatePoint": {
                "line": 369,
                "column": 74
            },
            "line": 369,
            "code": "test('StringMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringMatching returns false if received value is not string",
            "suites": [],
            "updatePoint": {
                "line": 376,
                "column": 66
            },
            "line": 376,
            "code": "test('StringMatching returns false if received value is not string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch(1)).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringMatching returns false even if coerced non-string received value matches pattern",
            "suites": [],
            "updatePoint": {
                "line": 380,
                "column": 92
            },
            "line": 380,
            "code": "test('StringMatching returns false even if coerced non-string received value matches pattern', () => {\n  jestExpect(stringMatching('null').asymmetricMatch(null)).toBe(false);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotMatching matches string against regexp",
            "suites": [],
            "updatePoint": {
                "line": 384,
                "column": 53
            },
            "line": 384,
            "code": "test('StringNotMatching matches string against regexp', () => {\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queue')).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotMatching matches string against string",
            "suites": [],
            "updatePoint": {
                "line": 389,
                "column": 53
            },
            "line": 389,
            "code": "test('StringNotMatching matches string against string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching('en').asymmetricMatch('queue')).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotMatching throws if expected value is neither string nor regexp",
            "suites": [],
            "updatePoint": {
                "line": 394,
                "column": 77
            },
            "line": 394,
            "code": "test('StringNotMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "StringNotMatching returns true if received value is not string",
            "suites": [],
            "updatePoint": {
                "line": 401,
                "column": 68
            },
            "line": 401,
            "code": "test('StringNotMatching returns true if received value is not string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch(1)).toBe(true);\n});",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " closeTo  return true",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 416,
                "column": 53
            },
            "line": 416,
            "code": "    test(`${expected} closeTo ${received} return true`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(true);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " notCloseTo  return false",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 419,
                "column": 57
            },
            "line": 419,
            "code": "    test(`${expected} notCloseTo ${received} return false`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(false);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " closeTo  return false",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 432,
                "column": 54
            },
            "line": 432,
            "code": "    test(`${expected} closeTo ${received} return false`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(false);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " notCloseTo  return true",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 435,
                "column": 56
            },
            "line": 435,
            "code": "    test(`${expected} notCloseTo ${received} return true`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(true);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " closeTo  with precision  return true",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 446,
                "column": 81
            },
            "line": 446,
            "code": "    test(`${expected} closeTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        true,\n      );\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " notCloseTo  with precision  return false",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 451,
                "column": 85
            },
            "line": 451,
            "code": "    test(`${expected} notCloseTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(false);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " closeTo  with precision  return false",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 462,
                "column": 82
            },
            "line": 462,
            "code": "    test(`${expected} closeTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        false,\n      );\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": " notCloseTo  with precision  return true",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 467,
                "column": 84
            },
            "line": 467,
            "code": "    test(`${expected} notCloseTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(true);\n    });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "closeTo throw if expected is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 474,
                "column": 47
            },
            "line": 474,
            "code": "  test('closeTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo('a');\n    }).toThrow('Expected is not a Number');\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "notCloseTo throw if expected is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 481,
                "column": 50
            },
            "line": 481,
            "code": "  test('notCloseTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo('a');\n    }).toThrow('Expected is not a Number');\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "closeTo throw if precision is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 488,
                "column": 48
            },
            "line": 488,
            "code": "  test('closeTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "notCloseTo throw if precision is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 495,
                "column": 51
            },
            "line": 495,
            "code": "  test('notCloseTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "closeTo return false if received is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 502,
                "column": 54
            },
            "line": 502,
            "code": "  test('closeTo return false if received is not number', () => {\n    jestExpect(closeTo(1).asymmetricMatch('a')).toBe(false);\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "notCloseTo return false if received is not number",
            "suites": [
                "closeTo"
            ],
            "updatePoint": {
                "line": 506,
                "column": 57
            },
            "line": 506,
            "code": "  test('notCloseTo return false if received is not number', () => {\n    jestExpect(notCloseTo(1).asymmetricMatch('a')).toBe(false);\n  });",
            "file": "asymmetricMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "basic matchers customTesters do not apply to still do not pass different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 106,
                "column": 93
            },
            "line": 106,
            "code": "  it('basic matchers customTesters do not apply to still do not pass different Volume objects', () => {\n    expect(volume1).not.toBe(volume2);\n    expect([volume1]).not.toContain(volume2);\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "basic matchers pass different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 111,
                "column": 50
            },
            "line": 111,
            "code": "  it('basic matchers pass different Volume objects', () => {\n    expect(volume1).toEqual(volume1);\n    expect(volume1).toEqual(volume2);\n    expect([volume1, volume2]).toEqual([volume2, volume1]);\n    expect(new Map([['key', volume1]])).toEqual(new Map([['key', volume2]]));\n    expect(new Set([volume1])).toEqual(new Set([volume2]));\n    expect(toIterator([volume1, volume2])).toEqual(\n      toIterator([volume2, volume1]),\n    );\n    expect([volume1]).toContainEqual(volume2);\n    expect({a: volume1}).toHaveProperty('a', volume2);\n    expect({a: volume1, b: undefined}).toStrictEqual({\n      a: volume2,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: volume1}}).toMatchObject({\n      a: 1,\n      b: {c: volume2},\n    });\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "asymmetric matchers pass different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 132,
                "column": 55
            },
            "line": 132,
            "code": "  it('asymmetric matchers pass different Volume objects', () => {\n    expect([volume1]).toEqual(expect.arrayContaining([volume2]));\n    expect({a: 1, b: {c: volume1}}).toEqual(\n      expect.objectContaining({b: {c: volume2}}),\n    );\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "spy matchers pass different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 139,
                "column": 48
            },
            "line": 139,
            "code": "  it('spy matchers pass different Volume objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => volumeReturn1,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveLastReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveNthReturnedWith(1, volumeReturn2);\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "custom matchers pass different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 154,
                "column": 51
            },
            "line": 154,
            "code": "  it('custom matchers pass different Volume objects', () => {\n    expect(volume1).toEqualVolume(volume2);\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toBe recommends toStrictEqual even with different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 158,
                "column": 70
            },
            "line": 158,
            "code": "  it('toBe recommends toStrictEqual even with different Volume objects', () => {\n    expect(() => expect(volume1).toBe(volume2)).toThrow('toStrictEqual');\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toBe recommends toEqual even with different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 162,
                "column": 64
            },
            "line": 162,
            "code": "  it('toBe recommends toEqual even with different Volume objects', () => {\n    expect(() => expect({a: undefined, b: volume1}).toBe({b: volume2})).toThrow(\n      'toEqual',\n    );\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toContains recommends toContainEquals even with different Volume objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 168,
                "column": 78
            },
            "line": 168,
            "code": "  it('toContains recommends toContainEquals even with different Volume objects', () => {\n    expect(() => expect([volume1]).toContain(volume2)).toThrow(\n      'toContainEqual',\n    );\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toMatchObject error shows Volume objects as equal",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 174,
                "column": 55
            },
            "line": 174,
            "code": "  it('toMatchObject error shows Volume objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: volume1}).toMatchObject({a: 2, b: volume2}),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "iterableEquality still properly detects cycles",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 180,
                "column": 52
            },
            "line": 180,
            "code": "  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(volume1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(volume2);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });",
            "file": "customEqualityTesters.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "exposes an equality function to custom testers",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 144,
                "column": 52
            },
            "line": 144,
            "code": "  it('exposes an equality function to custom testers', () => {\n    const runTestSymbol = Symbol('run this test');\n\n    // jestExpect and expect share the same global state\n    expect.assertions(3);\n    jestExpect.addEqualityTesters([\n      function dummyTester(a) {\n        // Equality testers are globally added. Only run this assertion for this test\n        if (a === runTestSymbol) {\n          expect(this.equals).toBe(equals);\n          return true;\n        }\n\n        return undefined;\n      },\n    ]);\n\n    expect(() =>\n      jestExpect(runTestSymbol).toEqual(runTestSymbol),\n    ).not.toThrow();\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "basic matchers customTesters do not apply to still do not pass different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 166,
                "column": 91
            },
            "line": 166,
            "code": "  it('basic matchers customTesters do not apply to still do not pass different Book objects', () => {\n    expect(book1).not.toBe(book1b);\n    expect([book1]).not.toContain(book1b);\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "basic matchers pass different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 171,
                "column": 48
            },
            "line": 171,
            "code": "  it('basic matchers pass different Book objects', () => {\n    expect(book1).toEqual(book1);\n    expect(book1).toEqual(book1b);\n    expect([book1, book1b]).toEqual([book1b, book1]);\n    expect(new Map([['key', book1]])).toEqual(new Map([['key', book1b]]));\n    expect(new Set([book1])).toEqual(new Set([book1b]));\n    expect(toIterator([book1, book1b])).toEqual(toIterator([book1b, book1]));\n    expect([book1]).toContainEqual(book1b);\n    expect({a: book1}).toHaveProperty('a', book1b);\n    expect({a: book1, b: undefined}).toStrictEqual({\n      a: book1b,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: book1}}).toMatchObject({\n      a: 1,\n      b: {c: book1b},\n    });\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "asymmetric matchers pass different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 190,
                "column": 53
            },
            "line": 190,
            "code": "  it('asymmetric matchers pass different Book objects', () => {\n    expect([book1]).toEqual(expect.arrayContaining([book1b]));\n    expect({a: 1, b: {c: book1}}).toEqual(\n      expect.objectContaining({b: {c: book1b}}),\n    );\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "spy matchers pass different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 197,
                "column": 46
            },
            "line": 197,
            "code": "  it('spy matchers pass different Book objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => bookReturn1a,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveLastReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveNthReturnedWith(1, bookReturn1b);\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "custom matchers pass different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 212,
                "column": 49
            },
            "line": 212,
            "code": "  it('custom matchers pass different Book objects', () => {\n    expect(book1).toEqualBook(book1b);\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toBe recommends toStrictEqual even with different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 216,
                "column": 68
            },
            "line": 216,
            "code": "  it('toBe recommends toStrictEqual even with different Book objects', () => {\n    expect(() => expect(book1).toBe(book1b)).toThrow('toStrictEqual');\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toBe recommends toEqual even with different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 220,
                "column": 62
            },
            "line": 220,
            "code": "  it('toBe recommends toEqual even with different Book objects', () => {\n    expect(() => expect({a: undefined, b: book1}).toBe({b: book1b})).toThrow(\n      'toEqual',\n    );\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toContains recommends toContainEquals even with different Book objects",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 226,
                "column": 76
            },
            "line": 226,
            "code": "  it('toContains recommends toContainEquals even with different Book objects', () => {\n    expect(() => expect([book1]).toContain(book1b)).toThrow('toContainEqual');\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toMatchObject error shows Book objects as equal",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 230,
                "column": 53
            },
            "line": 230,
            "code": "  it('toMatchObject error shows Book objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: book1}).toMatchObject({a: 2, b: book1b}),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "iterableEquality still properly detects cycles",
            "suites": [
                "with custom equality testers"
            ],
            "updatePoint": {
                "line": 236,
                "column": 52
            },
            "line": 236,
            "code": "  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(book1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(book1b);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });",
            "file": "customEqualityTestersRecursive.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "is available globally when matcher is unary",
            "suites": [],
            "updatePoint": {
                "line": 72,
                "column": 47
            },
            "line": 72,
            "code": "it('is available globally when matcher is unary', () => {\n  jestExpect(15).toBeDivisibleBy(5);\n  jestExpect(15).toBeDivisibleBy(3);\n  jestExpect(15).not.toBeDivisibleBy(6);\n\n  expect(() =>\n    jestExpect(15).toBeDivisibleBy(2),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "is available globally when matcher is variadic",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 50
            },
            "line": 82,
            "code": "it('is available globally when matcher is variadic', () => {\n  jestExpect(15).toBeWithinRange(10, 20);\n  jestExpect(15).not.toBeWithinRange(6, 10);\n\n  expect(() =>\n    jestExpect(15).toBeWithinRange(1, 3),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "exposes matcherUtils in context",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 35
            },
            "line": 91,
            "code": "it('exposes matcherUtils in context', () => {\n  jestExpect.extend({\n    shouldNotError(_actual: unknown) {\n      const pass: boolean = this.equals(\n        this.utils,\n        Object.assign(matcherUtils, {\n          iterableEquality,\n          subsetEquality,\n        }),\n      );\n      const message = pass\n        ? () => 'expected this.utils to be defined in an extend call'\n        : () => 'expected this.utils not to be defined in an extend call';\n\n      return {message, pass};\n    },\n  });\n\n  jestExpect('test').shouldNotError();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "is ok if there is no message specified",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 42
            },
            "line": 112,
            "code": "it('is ok if there is no message specified', () => {\n  jestExpect.extend({\n    toFailWithoutMessage(_expected: unknown) {\n      return {message: () => '', pass: false};\n    },\n  });\n\n  expect(() =>\n    jestExpect(true).toFailWithoutMessage(),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "exposes an equality function to custom matchers",
            "suites": [],
            "updatePoint": {
                "line": 124,
                "column": 51
            },
            "line": 124,
            "code": "it('exposes an equality function to custom matchers', () => {\n  // jestExpect and expect share the same global state\n  expect.assertions(3);\n  jestExpect.extend({\n    toBeOne(_expected: unknown) {\n      expect(this.equals).toBe(equals);\n      return {message: () => '', pass: !!this.equals(1, 1)};\n    },\n  });\n\n  expect(() => jestExpect('test').toBeOne()).not.toThrow();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "defines asymmetric unary matchers",
            "suites": [],
            "updatePoint": {
                "line": 137,
                "column": 37
            },
            "line": 137,
            "code": "it('defines asymmetric unary matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "defines asymmetric unary matchers that can be prefixed by not",
            "suites": [],
            "updatePoint": {
                "line": 146,
                "column": 65
            },
            "line": 146,
            "code": "it('defines asymmetric unary matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "defines asymmetric variadic matchers",
            "suites": [],
            "updatePoint": {
                "line": 155,
                "column": 40
            },
            "line": 155,
            "code": "it('defines asymmetric variadic matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeWithinRange(1, 3)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeWithinRange(4, 11)}),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "defines asymmetric variadic matchers that can be prefixed by not",
            "suites": [],
            "updatePoint": {
                "line": 164,
                "column": 68
            },
            "line": 164,
            "code": "it('defines asymmetric variadic matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({\n      value: jestExpect.not.toBeWithinRange(1, 3),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({\n      value: jestExpect.not.toBeWithinRange(5, 7),\n    }),\n  ).not.toThrow();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "prints the Symbol into the error message",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 44
            },
            "line": 177,
            "code": "it('prints the Symbol into the error message', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n\n  expect(() =>\n    jestExpect({a: foo}).toEqual({\n      a: jestExpect.toBeSymbol(bar),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "allows overriding existing extension",
            "suites": [],
            "updatePoint": {
                "line": 188,
                "column": 40
            },
            "line": 188,
            "code": "it('allows overriding existing extension', () => {\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'bar'};\n    },\n  });\n\n  jestExpect('foo').not.toAllowOverridingExistingMatcher();\n\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'foo'};\n    },\n  });\n\n  jestExpect('foo').toAllowOverridingExistingMatcher();\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws descriptive errors for invalid matchers",
            "suites": [],
            "updatePoint": {
                "line": 206,
                "column": 50
            },
            "line": 206,
            "code": "it('throws descriptive errors for invalid matchers', () => {\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: undefined,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"undefined\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 42,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"number\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 'foobar',\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"string\"',\n  );\n});",
            "file": "extend.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should throw if passed two arguments",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 40
            },
            "line": 32,
            "code": "it('should throw if passed two arguments', () => {\n  expect(() => jestExpect('foo', 'bar')).toThrow(\n    new Error('Expect takes at most one argument.'),\n  );\n});",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should reject",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 39,
                "column": 19
            },
            "line": 39,
            "code": "  it('should reject', async () => {\n    await jestExpect(Promise.reject(4)).rejects.toBe(4);\n    await jestExpect(Promise.reject(4)).rejects.not.toBe(5);\n    await jestExpect(Promise.reject(4.2)).rejects.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.reject(3)).rejects.not.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.reject({a: 1, b: 2})).rejects.toMatchObject({\n      a: 1,\n    });\n    await jestExpect(Promise.reject({a: 1, b: 2})).rejects.not.toMatchObject({\n      c: 1,\n    });\n    await jestExpect(\n      Promise.reject(new Error('rejectMessage')),\n    ).rejects.toMatchObject({message: 'rejectMessage'});\n    await jestExpect(Promise.reject(new Error())).rejects.toThrow();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should reject with toThrow",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 56,
                "column": 32
            },
            "line": 56,
            "code": "  it('should reject with toThrow', async () => {\n    async function fn() {\n      throw new Error('some error');\n    }\n    await jestExpect(fn()).rejects.toThrow('some error');\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should reject async function to toThrow",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 63,
                "column": 45
            },
            "line": 63,
            "code": "  it('should reject async function to toThrow', async () => {\n    await jestExpect(async () => {\n      throw new Error('Test');\n    }).rejects.toThrow('Test');\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value  synchronously",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 70,
                "column": 65
            },
            "line": 70,
            "code": "    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).rejects.toBe(111);\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value ",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 80,
                "column": 51
            },
            "line": 80,
            "code": "    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).rejects.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value  synchronously",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 93,
                "column": 65
            },
            "line": 93,
            "code": "    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).rejects.not.toBe(111);\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value ",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 103,
                "column": 51
            },
            "line": 103,
            "code": "    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).rejects.not.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for promise that resolves",
            "suites": [
                ".rejects"
            ],
            "updatePoint": {
                "line": 115,
                "column": 37
            },
            "line": 115,
            "code": "  it('fails for promise that resolves', async () => {\n    let error;\n    try {\n      await jestExpect(Promise.resolve(4)).rejects.toBe(4);\n    } catch (e) {\n      error = e;\n    }\n    expect(error).toBeDefined();\n    expect(error.message).toMatchSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should resolve",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 128,
                "column": 20
            },
            "line": 128,
            "code": "  it('should resolve', async () => {\n    await jestExpect(Promise.resolve(4)).resolves.toBe(4);\n    await jestExpect(Promise.resolve(4)).resolves.not.toBe(5);\n    await jestExpect(Promise.resolve(4.2)).resolves.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.resolve(3)).resolves.not.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.resolve({a: 1, b: 2})).resolves.toMatchObject({\n      a: 1,\n    });\n    await jestExpect(Promise.resolve({a: 1, b: 2})).resolves.not.toMatchObject({\n      c: 1,\n    });\n    await jestExpect(\n      Promise.resolve(() => {\n        throw new Error();\n      }),\n    ).resolves.toThrow();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value  synchronously",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 147,
                "column": 65
            },
            "line": 147,
            "code": "    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).resolves.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value ",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 158,
                "column": 51
            },
            "line": 158,
            "code": "    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).resolves.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value  synchronously",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 171,
                "column": 65
            },
            "line": 171,
            "code": "    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).resolves.not.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails non-promise value ",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 182,
                "column": 51
            },
            "line": 182,
            "code": "    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).resolves.not.toBeDefined();\n      } catch (e) {\n        error = e;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for promise that rejects",
            "suites": [
                ".resolves"
            ],
            "updatePoint": {
                "line": 194,
                "column": 36
            },
            "line": 194,
            "code": "  it('fails for promise that rejects', async () => {\n    let error;\n    try {\n      await jestExpect(Promise.reject(4)).resolves.toBe(4);\n    } catch (e) {\n      error = e;\n    }\n    expect(error).toBeDefined();\n    expect(error.message).toMatchSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not throw",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 207,
                "column": 20
            },
            "line": 207,
            "code": "  it('does not throw', () => {\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n    jestExpect(1).not.toBe(2);\n    jestExpect(1).toBe(1);\n    jestExpect(null).not.toBe(undefined);\n    jestExpect(null).toBe(null);\n    jestExpect(undefined).toBe(undefined);\n    jestExpect(NaN).toBe(NaN);\n    jestExpect(BigInt(1)).not.toBe(BigInt(2));\n    jestExpect(BigInt(1)).not.toBe(1);\n    jestExpect(BigInt(1)).toBe(BigInt(1));\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for:  and ",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 247,
                "column": 54
            },
            "line": 247,
            "code": "    it(`fails for: ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() => jestExpect(a).toBe(b)).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for:  and ",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 256,
                "column": 54
            },
            "line": 256,
            "code": "    it(`fails for: ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() => jestExpect(a).toBe(b)).toThrow('toBe');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for '' with '.not'",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 262,
                "column": 47
            },
            "line": 262,
            "code": "    it(`fails for '${stringify(v)}' with '.not'`, () => {\n      expect(() => jestExpect(v).not.toBe(v)).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for '' with '.not'",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 268,
                "column": 47
            },
            "line": 268,
            "code": "    it(`fails for '${stringify(v)}' with '.not'`, () => {\n      expect(() => jestExpect(v).not.toBe(v)).toThrow('toBe');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not crash on circular references",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 273,
                "column": 43
            },
            "line": 273,
            "code": "  it('does not crash on circular references', () => {\n    const obj = {};\n    obj.circular = obj;\n\n    expect(() => jestExpect(obj).toBe({})).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "assertion error matcherResult property contains matcher name, expected and actual values",
            "suites": [
                ".toBe()"
            ],
            "updatePoint": {
                "line": 280,
                "column": 96
            },
            "line": 280,
            "code": "  test('assertion error matcherResult property contains matcher name, expected and actual values', () => {\n    const actual = {a: 1};\n    const expected = {a: 2};\n    try {\n      jestExpect(actual).toBe(expected);\n    } catch (error) {\n      expect(error.matcherResult).toEqual(\n        expect.objectContaining({\n          actual,\n          expected,\n          name: 'toBe',\n        }),\n      );\n    }\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not ignore keys with undefined values",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 324,
                "column": 48
            },
            "line": 324,
            "code": "  it('does not ignore keys with undefined values', () => {\n    expect({\n      a: undefined,\n      b: 2,\n    }).not.toStrictEqual({b: 2});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not ignore keys with undefined values inside an array",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 331,
                "column": 64
            },
            "line": 331,
            "code": "  it('does not ignore keys with undefined values inside an array', () => {\n    expect([{a: undefined}]).not.toStrictEqual([{}]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not ignore keys with undefined values deep inside an object",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 335,
                "column": 70
            },
            "line": 335,
            "code": "  it('does not ignore keys with undefined values deep inside an object', () => {\n    expect([{a: [{a: undefined}]}]).not.toStrictEqual([{a: [{}]}]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not consider holes as undefined in sparse arrays",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 339,
                "column": 59
            },
            "line": 339,
            "code": "  it('does not consider holes as undefined in sparse arrays', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    expect([, , , 1, , ,]).not.toStrictEqual([, , , 1, undefined, ,]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes when comparing same type",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 344,
                "column": 37
            },
            "line": 344,
            "code": "  it('passes when comparing same type', () => {\n    expect({\n      test: new TestClassA(1, 2),\n    }).toStrictEqual({test: new TestClassA(1, 2)});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "matches the expected snapshot when it fails",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 350,
                "column": 49
            },
            "line": 350,
            "code": "  it('matches the expected snapshot when it fails', () => {\n    expect(() =>\n      jestExpect({\n        test: 2,\n      }).toStrictEqual({test: new TestClassA(1, 2)}),\n    ).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect({\n        test: new TestClassA(1, 2),\n      }).not.toStrictEqual({test: new TestClassA(1, 2)}),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "displays substring diff",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 364,
                "column": 29
            },
            "line": 364,
            "code": "  it('displays substring diff', () => {\n    const expected =\n      'Another caveat is that Jest will not typecheck your tests.';\n    const received =\n      'Because TypeScript support in Babel is just transpilation, Jest will not type-check your tests as they run.';\n    expect(() =>\n      jestExpect(received).toStrictEqual(expected),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "displays substring diff for multiple lines",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 374,
                "column": 48
            },
            "line": 374,
            "code": "  it('displays substring diff for multiple lines', () => {\n    const expected = [\n      '    69 | ',\n      \"    70 | test('assert.doesNotThrow', () => {\",\n      '  > 71 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    72 |     throw Error('err!');\",\n      '    73 |   });',\n      '    74 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:71:10)',\n    ].join('\\n');\n    const received = [\n      '    68 | ',\n      \"    69 | test('assert.doesNotThrow', () => {\",\n      '  > 70 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    71 |     throw Error('err!');\",\n      '    72 |   });',\n      '    73 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)',\n    ].join('\\n');\n    expect(() =>\n      jestExpect(received).toStrictEqual(expected),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not pass for different types",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 400,
                "column": 39
            },
            "line": 400,
            "code": "  it('does not pass for different types', () => {\n    expect({\n      test: new TestClassA(1, 2),\n    }).not.toStrictEqual({test: new TestClassB(1, 2)});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not simply compare constructor names",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 406,
                "column": 47
            },
            "line": 406,
            "code": "  it('does not simply compare constructor names', () => {\n    const c = new TestClassC(1, 2);\n    const d = new TestClassD(1, 2);\n    expect(c.constructor.name).toEqual(d.constructor.name);\n    expect({test: c}).not.toStrictEqual({test: d});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes for matching sparse arrays",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 414,
                "column": 39
            },
            "line": 414,
            "code": "  it('passes for matching sparse arrays', () => {\n    expect([, 1]).toStrictEqual([, 1]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not pass when sparseness of arrays do not match",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 418,
                "column": 58
            },
            "line": 418,
            "code": "  it('does not pass when sparseness of arrays do not match', () => {\n    expect([, 1]).not.toStrictEqual([undefined, 1]);\n    expect([undefined, 1]).not.toStrictEqual([, 1]);\n    expect([, , , 1]).not.toStrictEqual([, 1]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not pass when equally sparse arrays have different values",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 424,
                "column": 68
            },
            "line": 424,
            "code": "  it('does not pass when equally sparse arrays have different values', () => {\n    expect([, 1]).not.toStrictEqual([, 2]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not pass when ArrayBuffers are not equal",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 428,
                "column": 51
            },
            "line": 428,
            "code": "  it('does not pass when ArrayBuffers are not equal', () => {\n    expect(Uint8Array.from([1, 2]).buffer).not.toStrictEqual(\n      Uint8Array.from([0, 0]).buffer,\n    );\n    expect(Uint8Array.from([2, 1]).buffer).not.toStrictEqual(\n      Uint8Array.from([2, 2]).buffer,\n    );\n    expect(Uint8Array.from([]).buffer).not.toStrictEqual(\n      Uint8Array.from([1]).buffer,\n    );\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes for matching buffers",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 440,
                "column": 33
            },
            "line": 440,
            "code": "  it('passes for matching buffers', () => {\n    expect(Uint8Array.from([1]).buffer).toStrictEqual(\n      Uint8Array.from([1]).buffer,\n    );\n    expect(Uint8Array.from([]).buffer).toStrictEqual(\n      Uint8Array.from([]).buffer,\n    );\n    expect(Uint8Array.from([9, 3]).buffer).toStrictEqual(\n      Uint8Array.from([9, 3]).buffer,\n    );\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for missing keys even if backed by an asymmetric matcher accepting them",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 452,
                "column": 83
            },
            "line": 452,
            "code": "  it('fails for missing keys even if backed by an asymmetric matcher accepting them', () => {\n    // issue 12463\n    expect({a: 1}).not.toStrictEqual({a: 1, b: jestExpect.optionalFn()});\n    expect({a: 1, b: jestExpect.optionalFn()}).not.toStrictEqual({a: 1});\n    expect([1]).not.toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).not.toStrictEqual([1]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes if keys are present and asymmetric matcher accept them",
            "suites": [
                ".toStrictEqual()"
            ],
            "updatePoint": {
                "line": 460,
                "column": 67
            },
            "line": 460,
            "code": "  it('passes if keys are present and asymmetric matcher accept them', () => {\n    // issue 12463\n    // with a proper function\n    expect({a: 1, b: () => {}}).toStrictEqual({\n      a: 1,\n      b: jestExpect.optionalFn(),\n    });\n    expect({a: 1, b: jestExpect.optionalFn()}).toStrictEqual({\n      a: 1,\n      b: () => {},\n    });\n    expect([1, () => {}]).toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).toStrictEqual([1, () => {}]);\n    // with undefined\n    expect({a: 1, b: undefined}).toStrictEqual({\n      a: 1,\n      b: jestExpect.optionalFn(),\n    });\n    expect({a: 1, b: jestExpect.optionalFn()}).toStrictEqual({\n      a: 1,\n      b: undefined,\n    });\n    expect([1, undefined]).toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).toStrictEqual([1, undefined]);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toEqual()",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 689,
                "column": 7
            },
            "line": 687,
            "code": "    test(`{pass: false} expect(${stringify(a)}).toEqual(${stringify(\n      b,\n    )})`, () => {\n      expect(() => jestExpect(a).toEqual(b)).toThrowErrorMatchingSnapshot();\n      jestExpect(a).not.toEqual(b);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toEqual()",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 701,
                "column": 7
            },
            "line": 699,
            "code": "    test(`{pass: false} expect(${stringify(a)}).toEqual(${stringify(\n      b,\n    )})`, () => {\n      expect(() => jestExpect(a).toEqual(b)).toThrow('toEqual');\n      jestExpect(a).not.toEqual(b);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().not.toEqual()",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 934,
                "column": 7
            },
            "line": 932,
            "code": "    test(`{pass: true} expect(${stringify(a)}).not.toEqual(${stringify(\n      b,\n    )})`, () => {\n      jestExpect(a).toEqual(b);\n      expect(() => jestExpect(a).not.toEqual(b)).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().not.toEqual()",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 954,
                "column": 7
            },
            "line": 952,
            "code": "    test(`{pass: true} expect(${stringify(a)}).not.toEqual(${stringify(\n      b,\n    )})`, () => {\n      jestExpect(a).toEqual(b);\n      expect(() => jestExpect(a).not.toEqual(b)).toThrow('toEqual');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "assertion error matcherResult property contains matcher name, expected and actual values",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 960,
                "column": 96
            },
            "line": 960,
            "code": "  test('assertion error matcherResult property contains matcher name, expected and actual values', () => {\n    const actual = {a: 1};\n    const expected = {a: 2};\n    try {\n      jestExpect(actual).toEqual(expected);\n    } catch (error) {\n      expect(error.matcherResult).toEqual(\n        expect.objectContaining({\n          actual,\n          expected,\n          name: 'toEqual',\n        }),\n      );\n    }\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "symbol based keys in arrays are processed correctly",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 976,
                "column": 59
            },
            "line": 976,
            "code": "  test('symbol based keys in arrays are processed correctly', () => {\n    const mySymbol = Symbol('test');\n    const actual1 = [];\n    actual1[mySymbol] = 3;\n    const actual2 = [];\n    actual2[mySymbol] = 4;\n    const expected = [];\n    expected[mySymbol] = 3;\n\n    expect(actual1).toEqual(expected);\n    expect(actual2).not.toEqual(expected);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "non-enumerable members should be skipped during equal",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 989,
                "column": 61
            },
            "line": 989,
            "code": "  test('non-enumerable members should be skipped during equal', () => {\n    const actual = {\n      x: 3,\n    };\n    Object.defineProperty(actual, 'test', {\n      enumerable: false,\n      value: 5,\n    });\n    expect(actual).toEqual({x: 3});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "non-enumerable symbolic members should be skipped during equal",
            "suites": [
                ".toEqual()"
            ],
            "updatePoint": {
                "line": 1000,
                "column": 70
            },
            "line": 1000,
            "code": "  test('non-enumerable symbolic members should be skipped during equal', () => {\n    const actual = {\n      x: 3,\n    };\n    const mySymbol = Symbol('test');\n    Object.defineProperty(actual, mySymbol, {\n      enumerable: false,\n      value: 5,\n    });\n    expect(actual).toEqual({x: 3});\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "properties with the same circularity are equal",
            "suites": [
                ".toEqual()",
                "cyclic object equality"
            ],
            "updatePoint": {
                "line": 1013,
                "column": 56
            },
            "line": 1013,
            "code": "    test('properties with the same circularity are equal', () => {\n      const a = {};\n      a.x = a;\n      const b = {};\n      b.x = b;\n      expect(a).toEqual(b);\n      expect(b).toEqual(a);\n\n      const c = {};\n      c.x = a;\n      const d = {};\n      d.x = b;\n      expect(c).toEqual(d);\n      expect(d).toEqual(c);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "properties with different circularity are not equal",
            "suites": [
                ".toEqual()",
                "cyclic object equality"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 61
            },
            "line": 1029,
            "code": "    test('properties with different circularity are not equal', () => {\n      const a = {};\n      a.x = {y: a};\n      const b = {};\n      const bx = {};\n      b.x = bx;\n      bx.y = bx;\n      expect(a).not.toEqual(b);\n      expect(b).not.toEqual(a);\n\n      const c = {};\n      c.x = a;\n      const d = {};\n      d.x = b;\n      expect(c).not.toEqual(d);\n      expect(d).not.toEqual(c);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "are not equal if circularity is not on the same property",
            "suites": [
                ".toEqual()",
                "cyclic object equality"
            ],
            "updatePoint": {
                "line": 1047,
                "column": 66
            },
            "line": 1047,
            "code": "    test('are not equal if circularity is not on the same property', () => {\n      const a = {};\n      const b = {};\n      a.a = a;\n      b.a = {};\n      b.a.a = a;\n      expect(a).not.toEqual(b);\n      expect(b).not.toEqual(a);\n\n      const c = {};\n      c.x = {x: c};\n      const d = {};\n      d.x = d;\n      expect(c).not.toEqual(d);\n      expect(d).not.toEqual(c);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passing  and ",
            "suites": [
                ".toBeInstanceOf()"
            ],
            "updatePoint": {
                "line": 1105,
                "column": 53
            },
            "line": 1105,
            "code": "    test(`passing ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() =>\n        jestExpect(a).not.toBeInstanceOf(b),\n      ).toThrowErrorMatchingSnapshot();\n\n      jestExpect(a).toBeInstanceOf(b);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "failing  and ",
            "suites": [
                ".toBeInstanceOf()"
            ],
            "updatePoint": {
                "line": 1125,
                "column": 53
            },
            "line": 1125,
            "code": "    test(`failing ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() =>\n        jestExpect(a).toBeInstanceOf(b),\n      ).toThrowErrorMatchingSnapshot();\n\n      jestExpect(a).not.toBeInstanceOf(b);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws if constructor is not a function",
            "suites": [
                ".toBeInstanceOf()"
            ],
            "updatePoint": {
                "line": 1134,
                "column": 45
            },
            "line": 1134,
            "code": "  it('throws if constructor is not a function', () => {\n    expect(() =>\n      jestExpect({}).toBeInstanceOf(4),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not accept arguments",
            "suites": [
                ".toBeTruthy(), .toBeFalsy()"
            ],
            "updatePoint": {
                "line": 1142,
                "column": 31
            },
            "line": 1142,
            "code": "  it('does not accept arguments', () => {\n    expect(() => jestExpect(0).toBeTruthy(null)).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect(0).not.toBeFalsy(null),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is truthy",
            "suites": [
                ".toBeTruthy(), .toBeFalsy()"
            ],
            "updatePoint": {
                "line": 1151,
                "column": 37
            },
            "line": 1151,
            "code": "    test(`'${stringify(v)}' is truthy`, () => {\n      jestExpect(v).toBeTruthy();\n      jestExpect(v).not.toBeFalsy();\n\n      expect(() =>\n        jestExpect(v).not.toBeTruthy(),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() => jestExpect(v).toBeFalsy()).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is truthy",
            "suites": [
                ".toBeTruthy(), .toBeFalsy()"
            ],
            "updatePoint": {
                "line": 1164,
                "column": 37
            },
            "line": 1164,
            "code": "    test(`'${stringify(v)}' is truthy`, () => {\n      jestExpect(v).toBeTruthy();\n      jestExpect(v).not.toBeFalsy();\n\n      expect(() => jestExpect(v).not.toBeTruthy()).toThrow('toBeTruthy');\n\n      expect(() => jestExpect(v).toBeFalsy()).toThrow('toBeFalsy');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is falsy",
            "suites": [
                ".toBeTruthy(), .toBeFalsy()"
            ],
            "updatePoint": {
                "line": 1175,
                "column": 36
            },
            "line": 1175,
            "code": "    test(`'${stringify(v)}' is falsy`, () => {\n      jestExpect(v).toBeFalsy();\n      jestExpect(v).not.toBeTruthy();\n\n      expect(() => jestExpect(v).toBeTruthy()).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(v).not.toBeFalsy(),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is falsy",
            "suites": [
                ".toBeTruthy(), .toBeFalsy()"
            ],
            "updatePoint": {
                "line": 1188,
                "column": 36
            },
            "line": 1188,
            "code": "    test(`'${stringify(v)}' is falsy`, () => {\n      jestExpect(v).toBeFalsy();\n      jestExpect(v).not.toBeTruthy();\n\n      expect(() => jestExpect(v).toBeTruthy()).toThrow('toBeTruthy');\n\n      expect(() => jestExpect(v).not.toBeFalsy()).toThrow('toBeFalsy');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect(NaN).toBeNaN()",
            "suites": [
                ".toBeNaN()"
            ],
            "updatePoint": {
                "line": 1200,
                "column": 40
            },
            "line": 1200,
            "code": "  it('{pass: true} expect(NaN).toBeNaN()', () => {\n    [NaN, Math.sqrt(-1), Infinity - Infinity, 0 / 0].forEach(v => {\n      jestExpect(v).toBeNaN();\n\n      expect(() => jestExpect(v).not.toBeNaN()).toThrowErrorMatchingSnapshot();\n    });\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws",
            "suites": [
                ".toBeNaN()"
            ],
            "updatePoint": {
                "line": 1208,
                "column": 12
            },
            "line": 1208,
            "code": "  it('throws', () => {\n    [1, '', null, undefined, {}, [], 0.2, 0, Infinity, -Infinity].forEach(v => {\n      expect(() => jestExpect(v).toBeNaN()).toThrowErrorMatchingSnapshot();\n\n      jestExpect(v).not.toBeNaN();\n    });\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for ''",
            "suites": [
                ".toBeNull()"
            ],
            "updatePoint": {
                "line": 1219,
                "column": 37
            },
            "line": 1219,
            "code": "    test(`fails for '${stringify(v)}'`, () => {\n      jestExpect(v).not.toBeNull();\n\n      expect(() => jestExpect(v).toBeNull()).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails for null with .not",
            "suites": [
                ".toBeNull()"
            ],
            "updatePoint": {
                "line": 1226,
                "column": 30
            },
            "line": 1226,
            "code": "  it('fails for null with .not', () => {\n    expect(() =>\n      jestExpect(null).not.toBeNull(),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "pass for null",
            "suites": [
                ".toBeNull()"
            ],
            "updatePoint": {
                "line": 1232,
                "column": 19
            },
            "line": 1232,
            "code": "  it('pass for null', () => {\n    jestExpect(null).toBeNull();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is defined",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1239,
                "column": 38
            },
            "line": 1239,
            "code": "    test(`'${stringify(v)}' is defined`, () => {\n      jestExpect(v).toBeDefined();\n      jestExpect(v).not.toBeUndefined();\n\n      expect(() =>\n        jestExpect(v).not.toBeDefined(),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(v).toBeUndefined(),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' is defined",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1254,
                "column": 38
            },
            "line": 1254,
            "code": "    test(`'${stringify(v)}' is defined`, () => {\n      jestExpect(v).toBeDefined();\n      jestExpect(v).not.toBeUndefined();\n\n      expect(() => jestExpect(v).not.toBeDefined()).toThrow('toBeDefined');\n\n      expect(() => jestExpect(v).toBeUndefined()).toThrow('toBeUndefined');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "undefined is undefined",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1264,
                "column": 30
            },
            "line": 1264,
            "code": "  test('undefined is undefined', () => {\n    jestExpect(undefined).toBeUndefined();\n    jestExpect(undefined).not.toBeDefined();\n\n    expect(() =>\n      jestExpect(undefined).toBeDefined(),\n    ).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect(undefined).not.toBeUndefined(),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeLessThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1291,
                "column": 60
            },
            "line": 1291,
            "code": "      it(`{pass: true} expect(${small}).toBeLessThan(${big})`, () => {\n        jestExpect(small).toBeLessThan(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeLessThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1295,
                "column": 61
            },
            "line": 1295,
            "code": "      it(`{pass: false} expect(${big}).toBeLessThan(${small})`, () => {\n        jestExpect(big).not.toBeLessThan(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeGreaterThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1299,
                "column": 63
            },
            "line": 1299,
            "code": "      it(`{pass: true} expect(${big}).toBeGreaterThan(${small})`, () => {\n        jestExpect(big).toBeGreaterThan(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeGreaterThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1303,
                "column": 64
            },
            "line": 1303,
            "code": "      it(`{pass: false} expect(${small}).toBeGreaterThan(${big})`, () => {\n        jestExpect(small).not.toBeGreaterThan(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeLessThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1307,
                "column": 67
            },
            "line": 1307,
            "code": "      it(`{pass: true} expect(${small}).toBeLessThanOrEqual(${big})`, () => {\n        jestExpect(small).toBeLessThanOrEqual(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeLessThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1311,
                "column": 68
            },
            "line": 1311,
            "code": "      it(`{pass: false} expect(${big}).toBeLessThanOrEqual(${small})`, () => {\n        jestExpect(big).not.toBeLessThanOrEqual(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeGreaterThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1315,
                "column": 70
            },
            "line": 1315,
            "code": "      it(`{pass: true} expect(${big}).toBeGreaterThanOrEqual(${small})`, () => {\n        jestExpect(big).toBeGreaterThanOrEqual(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeGreaterThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1319,
                "column": 71
            },
            "line": 1319,
            "code": "      it(`{pass: false} expect(${small}).toBeGreaterThanOrEqual(${big})`, () => {\n        jestExpect(small).not.toBeGreaterThanOrEqual(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws: [, ]",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1323,
                "column": 36
            },
            "line": 1323,
            "code": "      it(`throws: [${small}, ${big}]`, () => {\n        expect(() =>\n          jestExpect(small).toBeGreaterThan(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).not.toBeLessThan(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).not.toBeGreaterThan(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).toBeLessThan(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).toBeGreaterThanOrEqual(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).not.toBeLessThanOrEqual(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).not.toBeGreaterThanOrEqual(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).toBeLessThanOrEqual(small),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "can compare BigInt to Numbers",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1358,
                "column": 39
            },
            "line": 1358,
            "code": "    test('can compare BigInt to Numbers', () => {\n      const a = BigInt(2);\n      jestExpect(a).toBeGreaterThan(1);\n      jestExpect(a).toBeGreaterThanOrEqual(2);\n      jestExpect(2).toBeLessThanOrEqual(a);\n      jestExpect(a).toBeLessThan(3);\n      jestExpect(a).toBeLessThanOrEqual(2);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeLessThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1373,
                "column": 9
            },
            "line": 1371,
            "code": "      it(`{pass: true} expect(${stringify(small)}).toBeLessThan(${stringify(\n        big,\n      )})`, () => {\n        jestExpect(small).toBeLessThan(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeLessThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1379,
                "column": 9
            },
            "line": 1377,
            "code": "      it(`{pass: false} expect(${stringify(big)}).toBeLessThan(${stringify(\n        small,\n      )})`, () => {\n        jestExpect(big).not.toBeLessThan(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeGreaterThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1385,
                "column": 9
            },
            "line": 1383,
            "code": "      it(`{pass: true} expect(${stringify(big)}).toBeGreaterThan(${stringify(\n        small,\n      )})`, () => {\n        jestExpect(big).toBeGreaterThan(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeGreaterThan()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1391,
                "column": 9
            },
            "line": 1389,
            "code": "      it(`{pass: false} expect(${stringify(small)}).toBeGreaterThan(${stringify(\n        big,\n      )})`, () => {\n        jestExpect(small).not.toBeGreaterThan(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeLessThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1397,
                "column": 48
            },
            "line": 1395,
            "code": "      it(`{pass: true} expect(${stringify(\n        small,\n      )}).toBeLessThanOrEqual(${stringify(big)})`, () => {\n        jestExpect(small).toBeLessThanOrEqual(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeLessThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 50
            },
            "line": 1401,
            "code": "      it(`{pass: false} expect(${stringify(\n        big,\n      )}).toBeLessThanOrEqual(${stringify(small)})`, () => {\n        jestExpect(big).not.toBeLessThanOrEqual(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeGreaterThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1409,
                "column": 53
            },
            "line": 1407,
            "code": "      it(`{pass: true} expect(${stringify(\n        big,\n      )}).toBeGreaterThanOrEqual(${stringify(small)})`, () => {\n        jestExpect(big).toBeGreaterThanOrEqual(small);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeGreaterThanOrEqual()",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1415,
                "column": 51
            },
            "line": 1413,
            "code": "      it(`{pass: false} expect(${stringify(\n        small,\n      )}).toBeGreaterThanOrEqual(${stringify(big)})`, () => {\n        jestExpect(small).not.toBeGreaterThanOrEqual(big);\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws: [, ]",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1419,
                "column": 58
            },
            "line": 1419,
            "code": "      it(`throws: [${stringify(small)}, ${stringify(big)}]`, () => {\n        expect(() => jestExpect(small).toBeGreaterThan(big)).toThrow(\n          'toBeGreaterThan',\n        );\n\n        expect(() => jestExpect(small).not.toBeLessThan(big)).toThrow(\n          'toBeLessThan',\n        );\n\n        expect(() => jestExpect(big).not.toBeGreaterThan(small)).toThrow(\n          'toBeGreaterThan',\n        );\n\n        expect(() => jestExpect(big).toBeLessThan(small)).toThrow(\n          'toBeLessThan',\n        );\n\n        expect(() => jestExpect(small).toBeGreaterThanOrEqual(big)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(small).not.toBeLessThanOrEqual(big)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n\n        expect(() => jestExpect(big).not.toBeGreaterThanOrEqual(small)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(big).toBeLessThanOrEqual(small)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "equal numbers: [, ]",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1461,
                "column": 41
            },
            "line": 1461,
            "code": "      test(`equal numbers: [${n1}, ${n2}]`, () => {\n        jestExpect(n1).toBeGreaterThanOrEqual(n2);\n        jestExpect(n1).toBeLessThanOrEqual(n2);\n\n        expect(() =>\n          jestExpect(n1).not.toBeGreaterThanOrEqual(n2),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(n1).not.toBeLessThanOrEqual(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "equal numbers: [, ]",
            "suites": [
                ".toBeDefined(), .toBeUndefined()"
            ],
            "updatePoint": {
                "line": 1479,
                "column": 41
            },
            "line": 1479,
            "code": "      test(`equal numbers: [${n1}, ${n2}]`, () => {\n        jestExpect(n1).toBeGreaterThanOrEqual(n2);\n        jestExpect(n1).toBeLessThanOrEqual(n2);\n\n        expect(() => jestExpect(n1).not.toBeGreaterThanOrEqual(n2)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(n1).not.toBeLessThanOrEqual(n2)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "iterable",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1500,
                "column": 16
            },
            "line": 1500,
            "code": "  test('iterable', () => {\n    // different node versions print iterable differently, so we can't\n    // use snapshots here.\n    const iterable = {\n      *[Symbol.iterator]() {\n        yield 1;\n        yield 2;\n        yield 3;\n      },\n    };\n\n    jestExpect(iterable).toContain(2);\n    jestExpect(iterable).toContainEqual(2);\n    expect(() => jestExpect(iterable).not.toContain(1)).toThrow('toContain');\n    expect(() => jestExpect(iterable).not.toContainEqual(1)).toThrow(\n      'toContainEqual',\n    );\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' contains ''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1530,
                "column": 55
            },
            "line": 1530,
            "code": "    it(`'${stringify(list)}' contains '${stringify(v)}'`, () => {\n      jestExpect(list).toContain(v);\n\n      expect(() =>\n        jestExpect(list).not.toContain(v),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' contains ''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1543,
                "column": 55
            },
            "line": 1543,
            "code": "    it(`'${stringify(list)}' contains '${stringify(v)}'`, () => {\n      jestExpect(list).toContain(v);\n\n      expect(() => jestExpect(list).not.toContain(v)).toThrow('toContain');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' does not contain ''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1556,
                "column": 63
            },
            "line": 1556,
            "code": "    it(`'${stringify(list)}' does not contain '${stringify(v)}'`, () => {\n      jestExpect(list).not.toContain(v);\n\n      expect(() =>\n        jestExpect(list).toContain(v),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' does not contain ''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1566,
                "column": 63
            },
            "line": 1566,
            "code": "    it(`'${stringify(list)}' does not contain '${stringify(v)}'`, () => {\n      jestExpect(list).not.toContain(v);\n\n      expect(() => jestExpect(list).toContain(v)).toThrow('toContain');\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "error cases",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1573,
                "column": 19
            },
            "line": 1573,
            "code": "  test('error cases', () => {\n    expect(() => jestExpect(null).toContain(1)).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect('-0').toContain(-0)).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('null').toContain(null),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('undefined').toContain(undefined),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('false').toContain(false),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect('1').toContain(BigInt(1))).toThrow('toContain');\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' contains a value equal to ''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1600,
                "column": 7
            },
            "line": 1598,
            "code": "    it(`'${stringify(list)}' contains a value equal to '${stringify(\n      v,\n    )}'`, () => {\n      jestExpect(list).toContainEqual(v);\n      expect(() =>\n        jestExpect(list).not.toContainEqual(v),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "'' does not contain a value equal to''",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1611,
                "column": 7
            },
            "line": 1609,
            "code": "    it(`'${stringify(list)}' does not contain a value equal to'${stringify(\n      v,\n    )}'`, () => {\n      jestExpect(list).not.toContainEqual(v);\n\n      expect(() =>\n        jestExpect(list).toContainEqual(v),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "error cases for toContainEqual",
            "suites": [
                ".toContain(), .toContainEqual()"
            ],
            "updatePoint": {
                "line": 1620,
                "column": 38
            },
            "line": 1620,
            "code": "  test('error cases for toContainEqual', () => {\n    expect(() =>\n      jestExpect(null).toContainEqual(1),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeCloseTo()",
            "suites": [
                ".toBeCloseTo"
            ],
            "updatePoint": {
                "line": 1638,
                "column": 53
            },
            "line": 1638,
            "code": "    it(`{pass: true} expect(${n1}).toBeCloseTo(${n2})`, () => {\n      jestExpect(n1).toBeCloseTo(n2);\n\n      expect(() =>\n        jestExpect(n1).not.toBeCloseTo(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeCloseTo()",
            "suites": [
                ".toBeCloseTo"
            ],
            "updatePoint": {
                "line": 1655,
                "column": 54
            },
            "line": 1655,
            "code": "    it(`{pass: false} expect(${n1}).toBeCloseTo(${n2})`, () => {\n      jestExpect(n1).not.toBeCloseTo(n2);\n\n      expect(() =>\n        jestExpect(n1).toBeCloseTo(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toBeCloseTo(, )",
            "suites": [
                ".toBeCloseTo"
            ],
            "updatePoint": {
                "line": 1668,
                "column": 60
            },
            "line": 1668,
            "code": "    it(`{pass: false} expect(${n1}).toBeCloseTo(${n2}, ${p})`, () => {\n      jestExpect(n1).not.toBeCloseTo(n2, p);\n\n      expect(() =>\n        jestExpect(n1).toBeCloseTo(n2, p),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toBeCloseTo(, )",
            "suites": [
                ".toBeCloseTo"
            ],
            "updatePoint": {
                "line": 1683,
                "column": 59
            },
            "line": 1683,
            "code": "    it(`{pass: true} expect(${n1}).toBeCloseTo(${n2}, ${p})`, () => {\n      jestExpect(n1).toBeCloseTo(n2, p);\n\n      expect(() =>\n        jestExpect(n1).not.toBeCloseTo(n2, p),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise empty isNot false received",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1693,
                "column": 44
            },
            "line": 1693,
            "code": "    test('promise empty isNot false received', () => {\n      const precision = 3;\n      const expected = 0;\n      const received = '';\n      expect(() => {\n        jestExpect(received).toBeCloseTo(expected, precision);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise empty isNot true expected",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1702,
                "column": 43
            },
            "line": 1702,
            "code": "    test('promise empty isNot true expected', () => {\n      const received = 0.1;\n      // expected is undefined\n      expect(() => {\n        jestExpect(received).not.toBeCloseTo();\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise rejects isNot false expected",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1710,
                "column": 46
            },
            "line": 1710,
            "code": "    test('promise rejects isNot false expected', () => {\n      const expected = '0';\n      const received = Promise.reject(0.01);\n      return expect(\n        jestExpect(received).rejects.toBeCloseTo(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise rejects isNot true received",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1718,
                "column": 45
            },
            "line": 1718,
            "code": "    test('promise rejects isNot true received', () => {\n      const expected = 0;\n      const received = Promise.reject(Symbol('0.1'));\n      return expect(\n        jestExpect(received).rejects.not.toBeCloseTo(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise resolves isNot false received",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1726,
                "column": 47
            },
            "line": 1726,
            "code": "    test('promise resolves isNot false received', () => {\n      const precision = 3;\n      const expected = 0;\n      const received = Promise.resolve(false);\n      return expect(\n        jestExpect(received).resolves.toBeCloseTo(expected, precision),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "promise resolves isNot true expected",
            "suites": [
                ".toBeCloseTo",
                "throws: Matcher error"
            ],
            "updatePoint": {
                "line": 1735,
                "column": 46
            },
            "line": 1735,
            "code": "    test('promise resolves isNot true expected', () => {\n      const precision = 3;\n      const expected = null;\n      const received = Promise.resolve(0.1);\n      return expect(\n        jestExpect(received).resolves.not.toBeCloseTo(expected, precision),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toMatch()",
            "suites": [
                ".toMatch()"
            ],
            "updatePoint": {
                "line": 1751,
                "column": 49
            },
            "line": 1751,
            "code": "    it(`{pass: true} expect(${n1}).toMatch(${n2})`, () => {\n      jestExpect(n1).toMatch(n2);\n\n      expect(() =>\n        jestExpect(n1).not.toMatch(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws: [, ]",
            "suites": [
                ".toMatch()"
            ],
            "updatePoint": {
                "line": 1764,
                "column": 30
            },
            "line": 1764,
            "code": "    it(`throws: [${n1}, ${n2}]`, () => {\n      expect(() => jestExpect(n1).toMatch(n2)).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "escapes strings properly",
            "suites": [
                ".toMatch()"
            ],
            "updatePoint": {
                "line": 1804,
                "column": 30
            },
            "line": 1804,
            "code": "  it('escapes strings properly', () => {\n    jestExpect('this?: throws').toMatch('this?: throws');\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not maintain RegExp state between calls",
            "suites": [
                ".toMatch()"
            ],
            "updatePoint": {
                "line": 1808,
                "column": 50
            },
            "line": 1808,
            "code": "  it('does not maintain RegExp state between calls', () => {\n    const regex = /[f]\\d+/gi;\n    jestExpect('f123').toMatch(regex);\n    jestExpect('F456').toMatch(regex);\n    jestExpect(regex.lastIndex).toBe(0);\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toHaveLength()",
            "suites": [
                ".toHaveLength"
            ],
            "updatePoint": {
                "line": 1827,
                "column": 31
            },
            "line": 1825,
            "code": "    test(`{pass: true} expect(${stringify(\n      received,\n    )}).toHaveLength(${length})`, () => {\n      jestExpect(received).toHaveLength(length);\n      expect(() =>\n        jestExpect(received).not.toHaveLength(length),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toHaveLength()",
            "suites": [
                ".toHaveLength"
            ],
            "updatePoint": {
                "line": 1844,
                "column": 31
            },
            "line": 1842,
            "code": "    test(`{pass: false} expect(${stringify(\n      received,\n    )}).toHaveLength(${length})`, () => {\n      jestExpect(received).not.toHaveLength(length);\n      expect(() =>\n        jestExpect(received).toHaveLength(length),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "error cases",
            "suites": [
                ".toHaveLength"
            ],
            "updatePoint": {
                "line": 1852,
                "column": 19
            },
            "line": 1852,
            "code": "  test('error cases', () => {\n    expect(() =>\n      jestExpect({a: 9}).toHaveLength(1),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect(0).toHaveLength(1)).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect(undefined).not.toHaveLength(1),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "not number",
            "suites": [
                ".toHaveLength",
                "matcher error expected length"
            ],
            "updatePoint": {
                "line": 1863,
                "column": 20
            },
            "line": 1863,
            "code": "    test('not number', () => {\n      const expected = '3';\n      const received = 'abc';\n      expect(() => {\n        jestExpect(received).not.toHaveLength(expected);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "number Infinity",
            "suites": [
                ".toHaveLength",
                "matcher error expected length"
            ],
            "updatePoint": {
                "line": 1871,
                "column": 25
            },
            "line": 1871,
            "code": "    test('number Infinity', () => {\n      const expected = Infinity;\n      const received = Promise.reject('abc');\n      return expect(\n        jestExpect(received).rejects.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "number NaN",
            "suites": [
                ".toHaveLength",
                "matcher error expected length"
            ],
            "updatePoint": {
                "line": 1879,
                "column": 20
            },
            "line": 1879,
            "code": "    test('number NaN', () => {\n      const expected = NaN;\n      const received = Promise.reject('abc');\n      return expect(\n        jestExpect(received).rejects.not.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "number float",
            "suites": [
                ".toHaveLength",
                "matcher error expected length"
            ],
            "updatePoint": {
                "line": 1887,
                "column": 22
            },
            "line": 1887,
            "code": "    test('number float', () => {\n      const expected = 0.5;\n      const received = Promise.resolve('abc');\n      return expect(\n        jestExpect(received).resolves.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "number negative integer",
            "suites": [
                ".toHaveLength",
                "matcher error expected length"
            ],
            "updatePoint": {
                "line": 1895,
                "column": 33
            },
            "line": 1895,
            "code": "    test('number negative integer', () => {\n      const expected = -3;\n      const received = Promise.resolve('abc');\n      return expect(\n        jestExpect(received).resolves.not.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toHaveProperty('', )",
            "suites": [
                ".toHaveProperty()"
            ],
            "updatePoint": {
                "line": 1980,
                "column": 57
            },
            "line": 1978,
            "code": "    test(`{pass: true} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}', ${stringify(value)})`, () => {\n      jestExpect(obj).toHaveProperty(keyPath, value);\n      expect(() =>\n        jestExpect(obj).not.toHaveProperty(keyPath, value),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toHaveProperty('', )",
            "suites": [
                ".toHaveProperty()"
            ],
            "updatePoint": {
                "line": 2009,
                "column": 57
            },
            "line": 2007,
            "code": "    test(`{pass: false} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}', ${stringify(value)})`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath, value),\n      ).toThrowErrorMatchingSnapshot();\n      jestExpect(obj).not.toHaveProperty(keyPath, value);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toHaveProperty('')",
            "suites": [
                ".toHaveProperty()"
            ],
            "updatePoint": {
                "line": 2027,
                "column": 36
            },
            "line": 2025,
            "code": "    test(`{pass: true} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      jestExpect(obj).toHaveProperty(keyPath);\n      expect(() =>\n        jestExpect(obj).not.toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toHaveProperty('')",
            "suites": [
                ".toHaveProperty()"
            ],
            "updatePoint": {
                "line": 2050,
                "column": 36
            },
            "line": 2048,
            "code": "    test(`{pass: false} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n      jestExpect(obj).not.toHaveProperty(keyPath);\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{error} expect().toHaveProperty('')",
            "suites": [
                ".toHaveProperty()"
            ],
            "updatePoint": {
                "line": 2068,
                "column": 36
            },
            "line": 2066,
            "code": "    test(`{error} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: true} expect().toMatchObject()",
            "suites": [
                "toMatchObject()"
            ],
            "updatePoint": {
                "line": 2106,
                "column": 9
            },
            "line": 2104,
            "code": "      it(`{pass: true} expect(${stringify(n1)}).toMatchObject(${stringify(\n        n2,\n      )})`, () => {\n        jestExpect(n1).toMatchObject(n2);\n        expect(() =>\n          jestExpect(n1).not.toMatchObject(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "{pass: false} expect().toMatchObject()",
            "suites": [
                "toMatchObject()"
            ],
            "updatePoint": {
                "line": 2119,
                "column": 9
            },
            "line": 2117,
            "code": "      it(`{pass: false} expect(${stringify(n1)}).toMatchObject(${stringify(\n        n2,\n      )})`, () => {\n        jestExpect(n1).not.toMatchObject(n2);\n        expect(() =>\n          jestExpect(n1).toMatchObject(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throws expect().toMatchObject()",
            "suites": [
                "toMatchObject()",
                "circular references",
                "transitive circular references"
            ],
            "updatePoint": {
                "line": 2296,
                "column": 7
            },
            "line": 2294,
            "code": "    it(`throws expect(${stringify(n1)}).toMatchObject(${stringify(\n      n2,\n    )})`, () => {\n      expect(() =>\n        jestExpect(n1).toMatchObject(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "does not match properties up in the prototype chain",
            "suites": [
                "toMatchObject()",
                "circular references",
                "transitive circular references"
            ],
            "updatePoint": {
                "line": 2303,
                "column": 57
            },
            "line": 2303,
            "code": "  it('does not match properties up in the prototype chain', () => {\n    const a = {};\n    a.ref = a;\n\n    const b = Object.create(a);\n    b.other = 'child';\n\n    const matcher = {other: 'child'};\n    matcher.ref = matcher;\n\n    jestExpect(b).not.toMatchObject(matcher);\n    expect(() =>\n      jestExpect(b).toMatchObject(matcher),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "toMatchObject ignores symbol key properties",
            "suites": [
                "toMatchObject()",
                "circular references",
                "transitive circular references"
            ],
            "updatePoint": {
                "line": 2319,
                "column": 49
            },
            "line": 2319,
            "code": "  it('toMatchObject ignores symbol key properties', () => {\n    // issue 13638\n    const sym = Symbol('foo');\n    const sym2 = Symbol('foo2');\n    jestExpect({}).not.toMatchObject({[sym]: true});\n    jestExpect({[sym]: true}).not.toMatchObject({[sym2]: true});\n    jestExpect({[sym]: true}).not.toMatchObject({[sym]: false});\n    jestExpect({example: 10, [sym]: true}).not.toMatchObject({\n      example: 12,\n      [sym]: true,\n    });\n    jestExpect({[sym]: true}).toMatchObject({[sym]: true});\n    jestExpect({example: 10, [sym]: true}).toMatchObject({\n      example: 10,\n      [sym]: true,\n    });\n  });",
            "file": "matchers.test.js",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 43,
            "code": "describe.each(['toBeCalled', 'toHaveBeenCalled'] as const)('%s', called => {\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() => jestExpect(fn)[called]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when called', () => {\n    const fn = jest.fn();\n    fn('arg0', 'arg1', 'arg2');\n    jestExpect(createSpy(fn))[called]();\n    jestExpect(fn)[called]();\n    expect(() => jestExpect(fn).not[called]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when called', () => {\n    const fn = jest.fn();\n    const spy = createSpy(fn);\n\n    jestExpect(spy).not[called]();\n    jestExpect(fn).not[called]();\n    expect(() => jestExpect(spy)[called]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[called](555)).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not[called](555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    fn();\n    jestExpect(fn)[called]();\n    expect(() => jestExpect(fn).not[called]()).toThrowErrorMatchingSnapshot();\n  });\n});",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works only on spies or jest.fn",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 38
            },
            "line": 44,
            "code": "  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() => jestExpect(fn)[called]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes when called",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 26
            },
            "line": 50,
            "code": "  test('passes when called', () => {\n    const fn = jest.fn();\n    fn('arg0', 'arg1', 'arg2');\n    jestExpect(createSpy(fn))[called]();\n    jestExpect(fn)[called]();\n    expect(() => jestExpect(fn).not[called]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes when called",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 31
            },
            "line": 58,
            "code": "  test('.not passes when called', () => {\n    const fn = jest.fn();\n    const spy = createSpy(fn);\n\n    jestExpect(spy).not[called]();\n    jestExpect(fn).not[called]();\n    expect(() => jestExpect(spy)[called]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails with any argument passed",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 38
            },
            "line": 67,
            "code": "  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[called](555)).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not fails with any argument passed",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 43
            },
            "line": 75,
            "code": "  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not[called](555),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 58
            },
            "line": 84,
            "code": "  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    fn();\n    jestExpect(fn)[called]();\n    expect(() => jestExpect(fn).not[called]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 93,
            "code": "describe.each(['toBeCalledTimes', 'toHaveBeenCalledTimes'] as const)(\n  '%s',\n  calledTimes => {\n    test('.not works only on spies or jest.fn', () => {\n      const fn = function fn() {};\n\n      expect(() =>\n        jestExpect(fn).not[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('only accepts a number argument', () => {\n      const fn = jest.fn();\n      fn();\n      jestExpect(fn)[calledTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn)[calledTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    test('.not only accepts a number argument', () => {\n      const fn = jest.fn();\n      jestExpect(fn).not[calledTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[calledTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    test('passes if function called equal to expected times', () => {\n      const fn = jest.fn();\n      fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](2);\n      jestExpect(fn)[calledTimes](2);\n\n      expect(() =>\n        jestExpect(spy).not[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('.not passes if function called more than expected times', () => {\n      const fn = jest.fn();\n      fn();\n      fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](3);\n      jestExpect(spy).not[calledTimes](2);\n\n      jestExpect(fn)[calledTimes](3);\n      jestExpect(fn).not[calledTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('.not passes if function called less than expected times', () => {\n      const fn = jest.fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](1);\n      jestExpect(spy).not[calledTimes](2);\n\n      jestExpect(fn)[calledTimes](1);\n      jestExpect(fn).not[calledTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('includes the custom mock name in the error message', () => {\n      const fn = jest.fn().mockName('named-mock');\n      fn();\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  },\n);",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not works only on spies or jest.fn",
            "suites": [],
            "updatePoint": {
                "line": 96,
                "column": 45
            },
            "line": 96,
            "code": "    test('.not works only on spies or jest.fn', () => {\n      const fn = function fn() {};\n\n      expect(() =>\n        jestExpect(fn).not[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "only accepts a number argument",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 40
            },
            "line": 104,
            "code": "    test('only accepts a number argument', () => {\n      const fn = jest.fn();\n      fn();\n      jestExpect(fn)[calledTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn)[calledTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not only accepts a number argument",
            "suites": [],
            "updatePoint": {
                "line": 117,
                "column": 45
            },
            "line": 117,
            "code": "    test('.not only accepts a number argument', () => {\n      const fn = jest.fn();\n      jestExpect(fn).not[calledTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[calledTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes if function called equal to expected times",
            "suites": [],
            "updatePoint": {
                "line": 129,
                "column": 59
            },
            "line": 129,
            "code": "    test('passes if function called equal to expected times', () => {\n      const fn = jest.fn();\n      fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](2);\n      jestExpect(fn)[calledTimes](2);\n\n      expect(() =>\n        jestExpect(spy).not[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes if function called more than expected times",
            "suites": [],
            "updatePoint": {
                "line": 143,
                "column": 65
            },
            "line": 143,
            "code": "    test('.not passes if function called more than expected times', () => {\n      const fn = jest.fn();\n      fn();\n      fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](3);\n      jestExpect(spy).not[calledTimes](2);\n\n      jestExpect(fn)[calledTimes](3);\n      jestExpect(fn).not[calledTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes if function called less than expected times",
            "suites": [],
            "updatePoint": {
                "line": 161,
                "column": 65
            },
            "line": 161,
            "code": "    test('.not passes if function called less than expected times', () => {\n      const fn = jest.fn();\n      fn();\n\n      const spy = createSpy(fn);\n      jestExpect(spy)[calledTimes](1);\n      jestExpect(spy).not[calledTimes](2);\n\n      jestExpect(fn)[calledTimes](1);\n      jestExpect(fn).not[calledTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 60
            },
            "line": 177,
            "code": "    test('includes the custom mock name in the error message', () => {\n      const fn = jest.fn().mockName('named-mock');\n      fn();\n\n      expect(() =>\n        jestExpect(fn)[calledTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 188,
            "code": "describe.each([\n  'lastCalledWith',\n  'toHaveBeenLastCalledWith',\n  'nthCalledWith',\n  'toHaveBeenNthCalledWith',\n  'toBeCalledWith',\n  'toHaveBeenCalledWith',\n] as const)('%s', calledWith => {\n  function isToHaveNth(\n    calledWith: string,\n  ): calledWith is 'nthCalledWith' | 'toHaveBeenNthCalledWith' {\n    return (\n      calledWith === 'nthCalledWith' || calledWith === 'toHaveBeenNthCalledWith'\n    );\n  }\n\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() => jestExpect(fn)[calledWith]()).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1);\n      jestExpect(fn)[calledWith](1);\n    } else {\n      jestExpect(createSpy(fn))[calledWith]();\n      jestExpect(fn)[calledWith]();\n    }\n  });\n\n  test(\"works with arguments that don't match\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar1');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in number of arguments\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar', 'plop');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers even when argument is undefined\", () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        'foo',\n        jestExpect.any(String),\n      );\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', jestExpect.any(String));\n      jestExpect(fn).not[calledWith]('foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in size even if one is an optional matcher\", () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1, 'foo', 'bar');\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith]('foo', 'bar');\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match with matchers', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments if requested by the match query', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments when explicitly requested as optional by matcher', () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const fn = jest.fn();\n\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    fn(m1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, m2);\n      jestExpect(fn).not[calledWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](m2);\n      jestExpect(fn).not[calledWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const fn = jest.fn();\n\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    fn(s1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, s2);\n      jestExpect(fn).not[calledWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](s2);\n      jestExpect(fn).not[calledWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects', () => {\n    const fn = jest.fn();\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    fn(directlyCreated, indirectlyCreated);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(calledWith)) {\n    test('works with many arguments', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test(\"works with many arguments that don't match\", () => {\n      const fn = jest.fn();\n      fn('foo', 'bar1');\n      fn('foo', 'bar2');\n      fn('foo', 'bar3');\n\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  if (isToHaveNth(calledWith)) {\n    test('works with three calls', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith](1, 'foo1', 'bar');\n      jestExpect(fn)[calledWith](2, 'foo', 'bar1');\n      jestExpect(fn)[calledWith](3, 'foo', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not positive integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0.1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('negative throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](Infinity, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works only on spies or jest.fn",
            "suites": [],
            "updatePoint": {
                "line": 204,
                "column": 38
            },
            "line": 204,
            "code": "  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() => jestExpect(fn)[calledWith]()).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works when not called",
            "suites": [],
            "updatePoint": {
                "line": 216,
                "column": 29
            },
            "line": 216,
            "code": "  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with no arguments",
            "suites": [],
            "updatePoint": {
                "line": 236,
                "column": 31
            },
            "line": 236,
            "code": "  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1);\n      jestExpect(fn)[calledWith](1);\n    } else {\n      jestExpect(createSpy(fn))[calledWith]();\n      jestExpect(fn)[calledWith]();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that don't match",
            "suites": [],
            "updatePoint": {
                "line": 249,
                "column": 45
            },
            "line": 249,
            "code": "  test(\"works with arguments that don't match\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar1');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that don't match in number of arguments",
            "suites": [],
            "updatePoint": {
                "line": 270,
                "column": 68
            },
            "line": 270,
            "code": "  test(\"works with arguments that don't match in number of arguments\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar', 'plop');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that don't match with matchers",
            "suites": [],
            "updatePoint": {
                "line": 291,
                "column": 59
            },
            "line": 291,
            "code": "  test(\"works with arguments that don't match with matchers\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that don't match with matchers even when argument is undefined",
            "suites": [],
            "updatePoint": {
                "line": 333,
                "column": 91
            },
            "line": 333,
            "code": "  test(\"works with arguments that don't match with matchers even when argument is undefined\", () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        'foo',\n        jestExpect.any(String),\n      );\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', jestExpect.any(String));\n      jestExpect(fn).not[calledWith]('foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that don't match in size even if one is an optional matcher",
            "suites": [],
            "updatePoint": {
                "line": 358,
                "column": 88
            },
            "line": 358,
            "code": "  test(\"works with arguments that don't match in size even if one is an optional matcher\", () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that match",
            "suites": [],
            "updatePoint": {
                "line": 376,
                "column": 39
            },
            "line": 376,
            "code": "  test('works with arguments that match', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1, 'foo', 'bar');\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith]('foo', 'bar');\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with arguments that match with matchers",
            "suites": [],
            "updatePoint": {
                "line": 397,
                "column": 53
            },
            "line": 397,
            "code": "  test('works with arguments that match with matchers', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with trailing undefined arguments",
            "suites": [],
            "updatePoint": {
                "line": 439,
                "column": 47
            },
            "line": 439,
            "code": "  test('works with trailing undefined arguments', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with trailing undefined arguments if requested by the match query",
            "suites": [],
            "updatePoint": {
                "line": 454,
                "column": 79
            },
            "line": 454,
            "code": "  test('works with trailing undefined arguments if requested by the match query', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with trailing undefined arguments when explicitly requested as optional by matcher",
            "suites": [],
            "updatePoint": {
                "line": 471,
                "column": 96
            },
            "line": 471,
            "code": "  test('works with trailing undefined arguments when explicitly requested as optional by matcher', () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Map",
            "suites": [],
            "updatePoint": {
                "line": 489,
                "column": 22
            },
            "line": 489,
            "code": "  test('works with Map', () => {\n    const fn = jest.fn();\n\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    fn(m1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, m2);\n      jestExpect(fn).not[calledWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](m2);\n      jestExpect(fn).not[calledWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Set",
            "suites": [],
            "updatePoint": {
                "line": 530,
                "column": 22
            },
            "line": 530,
            "code": "  test('works with Set', () => {\n    const fn = jest.fn();\n\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    fn(s1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, s2);\n      jestExpect(fn).not[calledWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](s2);\n      jestExpect(fn).not[calledWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Immutable.js objects",
            "suites": [],
            "updatePoint": {
                "line": 562,
                "column": 39
            },
            "line": 562,
            "code": "  test('works with Immutable.js objects', () => {\n    const fn = jest.fn();\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    fn(directlyCreated, indirectlyCreated);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with many arguments",
            "suites": [],
            "updatePoint": {
                "line": 584,
                "column": 35
            },
            "line": 584,
            "code": "    test('works with many arguments', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with many arguments that don't match",
            "suites": [],
            "updatePoint": {
                "line": 597,
                "column": 52
            },
            "line": 597,
            "code": "    test(\"works with many arguments that don't match\", () => {\n      const fn = jest.fn();\n      fn('foo', 'bar1');\n      fn('foo', 'bar2');\n      fn('foo', 'bar3');\n\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with three calls",
            "suites": [],
            "updatePoint": {
                "line": 612,
                "column": 32
            },
            "line": 612,
            "code": "    test('works with three calls', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith](1, 'foo1', 'bar');\n      jestExpect(fn)[calledWith](2, 'foo', 'bar1');\n      jestExpect(fn)[calledWith](3, 'foo', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "positive throw matcher error for n that is not positive integer",
            "suites": [],
            "updatePoint": {
                "line": 627,
                "column": 73
            },
            "line": 627,
            "code": "    test('positive throw matcher error for n that is not positive integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "positive throw matcher error for n that is not integer",
            "suites": [],
            "updatePoint": {
                "line": 636,
                "column": 64
            },
            "line": 636,
            "code": "    test('positive throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0.1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "negative throw matcher error for n that is not integer",
            "suites": [],
            "updatePoint": {
                "line": 645,
                "column": 64
            },
            "line": 645,
            "code": "    test('negative throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](Infinity, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [],
            "updatePoint": {
                "line": 655,
                "column": 58
            },
            "line": 655,
            "code": "  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 675,
            "code": "describe.each(['toReturn', 'toHaveReturned'] as const)('%s', returned => {\n  test('.not works only on jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() => jestExpect(spy)[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when returned', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when undefined is returned', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when at least one call does not throw', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when not returned', () => {\n    const fn = jest.fn();\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when all calls throw', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when a call throws undefined', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returned](555)).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not[returned](555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        // Before returning from the base case of recursion, none of the\n        // calls have returned yet.\n        jestExpect(fn).not[returned]();\n        expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n        return 0;\n      } else {\n        return value + fn(value - 1);\n      }\n    });\n\n    fn(3);\n  });\n});",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not works only on jest.fn",
            "suites": [],
            "updatePoint": {
                "line": 676,
                "column": 34
            },
            "line": 676,
            "code": "  test('.not works only on jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throw matcher error if received is spy",
            "suites": [],
            "updatePoint": {
                "line": 682,
                "column": 46
            },
            "line": 682,
            "code": "  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() => jestExpect(spy)[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes when returned",
            "suites": [],
            "updatePoint": {
                "line": 688,
                "column": 28
            },
            "line": 688,
            "code": "  test('passes when returned', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes when undefined is returned",
            "suites": [],
            "updatePoint": {
                "line": 695,
                "column": 41
            },
            "line": 695,
            "code": "  test('passes when undefined is returned', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes when at least one call does not throw",
            "suites": [],
            "updatePoint": {
                "line": 702,
                "column": 52
            },
            "line": 702,
            "code": "  test('passes when at least one call does not throw', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes when not returned",
            "suites": [],
            "updatePoint": {
                "line": 725,
                "column": 37
            },
            "line": 725,
            "code": "  test('.not passes when not returned', () => {\n    const fn = jest.fn();\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes when all calls throw",
            "suites": [],
            "updatePoint": {
                "line": 732,
                "column": 40
            },
            "line": 732,
            "code": "  test('.not passes when all calls throw', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes when a call throws undefined",
            "suites": [],
            "updatePoint": {
                "line": 753,
                "column": 48
            },
            "line": 753,
            "code": "  test('.not passes when a call throws undefined', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not[returned]();\n    expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "fails with any argument passed",
            "suites": [],
            "updatePoint": {
                "line": 769,
                "column": 38
            },
            "line": 769,
            "code": "  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returned](555)).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not fails with any argument passed",
            "suites": [],
            "updatePoint": {
                "line": 777,
                "column": 43
            },
            "line": 777,
            "code": "  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not[returned](555),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [],
            "updatePoint": {
                "line": 786,
                "column": 58
            },
            "line": 786,
            "code": "  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    jestExpect(fn)[returned]();\n    expect(() => jestExpect(fn).not[returned]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "incomplete recursive calls are handled properly",
            "suites": [],
            "updatePoint": {
                "line": 793,
                "column": 55
            },
            "line": 793,
            "code": "  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        // Before returning from the base case of recursion, none of the\n        // calls have returned yet.\n        jestExpect(fn).not[returned]();\n        expect(() => jestExpect(fn)[returned]()).toThrowErrorMatchingSnapshot();\n        return 0;\n      } else {\n        return value + fn(value - 1);\n      }\n    });\n\n    fn(3);\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 811,
            "code": "describe.each(['toReturnTimes', 'toHaveReturnedTimes'] as const)(\n  '%s',\n  returnedTimes => {\n    test('throw matcher error if received is spy', () => {\n      const spy = createSpy(jest.fn());\n\n      expect(() =>\n        jestExpect(spy).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('only accepts a number argument', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      jestExpect(fn)[returnedTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn)[returnedTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    test('.not only accepts a number argument', () => {\n      const fn = jest.fn(() => 42);\n      jestExpect(fn).not[returnedTimes](2);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    test('passes if function returned equal to expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('calls that return undefined are counted as returns', () => {\n      const fn = jest.fn(() => undefined);\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('.not passes if function returned more than expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](3);\n      jestExpect(fn).not[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('.not passes if function called less than expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n\n      jestExpect(fn)[returnedTimes](1);\n      jestExpect(fn).not[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('calls that throw are not counted', () => {\n      const fn = jest.fn((causeError: boolean) => {\n        if (causeError) {\n          throw new Error('Error!');\n        }\n\n        return 42;\n      });\n\n      fn(false);\n\n      try {\n        fn(true);\n      } catch {\n        // ignore error\n      }\n\n      fn(false);\n\n      jestExpect(fn).not[returnedTimes](3);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](3),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('calls that throw undefined are not counted', () => {\n      const fn = jest.fn((causeError: boolean) => {\n        if (causeError) {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        }\n\n        return 42;\n      });\n\n      fn(false);\n\n      try {\n        fn(true);\n      } catch {\n        // ignore error\n      }\n\n      fn(false);\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('includes the custom mock name in the error message', () => {\n      const fn = jest.fn(() => 42).mockName('named-mock');\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](1),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('incomplete recursive calls are handled properly', () => {\n      // sums up all integers from 0 -> value, using recursion\n      const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n        if (value === 0) {\n          return 0;\n        } else {\n          const recursiveResult = fn(value - 1);\n\n          if (value === 2) {\n            // Only 2 of the recursive calls have returned at this point\n            jestExpect(fn)[returnedTimes](2);\n            expect(() =>\n              jestExpect(fn).not[returnedTimes](2),\n            ).toThrowErrorMatchingSnapshot();\n          }\n\n          return value + recursiveResult;\n        }\n      });\n\n      fn(3);\n    });\n  },\n);",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "throw matcher error if received is spy",
            "suites": [],
            "updatePoint": {
                "line": 814,
                "column": 48
            },
            "line": 814,
            "code": "    test('throw matcher error if received is spy', () => {\n      const spy = createSpy(jest.fn());\n\n      expect(() =>\n        jestExpect(spy).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "only accepts a number argument",
            "suites": [],
            "updatePoint": {
                "line": 822,
                "column": 40
            },
            "line": 822,
            "code": "    test('only accepts a number argument', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      jestExpect(fn)[returnedTimes](1);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn)[returnedTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not only accepts a number argument",
            "suites": [],
            "updatePoint": {
                "line": 835,
                "column": 45
            },
            "line": 835,
            "code": "    test('.not only accepts a number argument', () => {\n      const fn = jest.fn(() => 42);\n      jestExpect(fn).not[returnedTimes](2);\n\n      [{}, [], true, 'a', new Map(), () => {}].forEach(value => {\n        expect(() =>\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedTimes](value),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes if function returned equal to expected times",
            "suites": [],
            "updatePoint": {
                "line": 847,
                "column": 61
            },
            "line": 847,
            "code": "    test('passes if function returned equal to expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "calls that return undefined are counted as returns",
            "suites": [],
            "updatePoint": {
                "line": 859,
                "column": 60
            },
            "line": 859,
            "code": "    test('calls that return undefined are counted as returns', () => {\n      const fn = jest.fn(() => undefined);\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes if function returned more than expected times",
            "suites": [],
            "updatePoint": {
                "line": 871,
                "column": 67
            },
            "line": 871,
            "code": "    test('.not passes if function returned more than expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](3);\n      jestExpect(fn).not[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": ".not passes if function called less than expected times",
            "suites": [],
            "updatePoint": {
                "line": 885,
                "column": 65
            },
            "line": 885,
            "code": "    test('.not passes if function called less than expected times', () => {\n      const fn = jest.fn(() => 42);\n      fn();\n\n      jestExpect(fn)[returnedTimes](1);\n      jestExpect(fn).not[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "calls that throw are not counted",
            "suites": [],
            "updatePoint": {
                "line": 897,
                "column": 42
            },
            "line": 897,
            "code": "    test('calls that throw are not counted', () => {\n      const fn = jest.fn((causeError: boolean) => {\n        if (causeError) {\n          throw new Error('Error!');\n        }\n\n        return 42;\n      });\n\n      fn(false);\n\n      try {\n        fn(true);\n      } catch {\n        // ignore error\n      }\n\n      fn(false);\n\n      jestExpect(fn).not[returnedTimes](3);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](3),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "calls that throw undefined are not counted",
            "suites": [],
            "updatePoint": {
                "line": 923,
                "column": 52
            },
            "line": 923,
            "code": "    test('calls that throw undefined are not counted', () => {\n      const fn = jest.fn((causeError: boolean) => {\n        if (causeError) {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        }\n\n        return 42;\n      });\n\n      fn(false);\n\n      try {\n        fn(true);\n      } catch {\n        // ignore error\n      }\n\n      fn(false);\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn).not[returnedTimes](2),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [],
            "updatePoint": {
                "line": 950,
                "column": 60
            },
            "line": 950,
            "code": "    test('includes the custom mock name in the error message', () => {\n      const fn = jest.fn(() => 42).mockName('named-mock');\n      fn();\n      fn();\n\n      jestExpect(fn)[returnedTimes](2);\n\n      expect(() =>\n        jestExpect(fn)[returnedTimes](1),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "incomplete recursive calls are handled properly",
            "suites": [],
            "updatePoint": {
                "line": 962,
                "column": 57
            },
            "line": 962,
            "code": "    test('incomplete recursive calls are handled properly', () => {\n      // sums up all integers from 0 -> value, using recursion\n      const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n        if (value === 0) {\n          return 0;\n        } else {\n          const recursiveResult = fn(value - 1);\n\n          if (value === 2) {\n            // Only 2 of the recursive calls have returned at this point\n            jestExpect(fn)[returnedTimes](2);\n            expect(() =>\n              jestExpect(fn).not[returnedTimes](2),\n            ).toThrowErrorMatchingSnapshot();\n          }\n\n          return value + recursiveResult;\n        }\n      });\n\n      fn(3);\n    });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 987,
            "code": "describe.each([\n  'lastReturnedWith',\n  'toHaveLastReturnedWith',\n  'nthReturnedWith',\n  'toHaveNthReturnedWith',\n  'toReturnWith',\n  'toHaveReturnedWith',\n] as const)('%s', returnedWith => {\n  function isToHaveNth(\n    returnedWith: string,\n  ): returnedWith is 'nthReturnedWith' | 'toHaveNthReturnedWith' {\n    return (\n      returnedWith === 'nthReturnedWith' ||\n      returnedWith === 'toHaveNthReturnedWith'\n    );\n  }\n\n  function isToHaveLast(\n    returnedWith: string,\n  ): returnedWith is 'lastReturnedWith' | 'toHaveLastReturnedWith' {\n    return (\n      returnedWith === 'lastReturnedWith' ||\n      returnedWith === 'toHaveLastReturnedWith'\n    );\n  }\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returnedWith]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1);\n    } else {\n      jestExpect(fn)[returnedWith]();\n    }\n  });\n\n  test('works with argument that does not match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with argument that does match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with undefined', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    const fn = jest.fn(() => m1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, m2);\n      jestExpect(fn).not[returnedWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](m2);\n      jestExpect(fn).not[returnedWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    const fn = jest.fn(() => s1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, s2);\n      jestExpect(fn).not[returnedWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](s2);\n      jestExpect(fn).not[returnedWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects directly created', () => {\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const fn = jest.fn(() => directlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects indirectly created', () => {\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    const fn = jest.fn(() => indirectlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws undefined is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(returnedWith)) {\n    describe('returnedWith', () => {\n      test('works with more calls than the limit', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn.mockReturnValueOnce('foo4');\n        fn.mockReturnValueOnce('foo5');\n        fn.mockReturnValueOnce('foo6');\n\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn).not[returnedWith]('bar');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith]('bar');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            // This test ensures that the incomplete calls are not incorrectly\n            // interpreted as have returned undefined\n            jestExpect(fn).not[returnedWith](undefined);\n            expect(() =>\n              jestExpect(fn)[returnedWith](undefined),\n            ).toThrowErrorMatchingSnapshot();\n\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveNth(returnedWith)) {\n    describe('nthReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith](1, 'foo1');\n        jestExpect(fn)[returnedWith](2, 'foo2');\n        jestExpect(fn)[returnedWith](3, 'foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should replace 1st, 2nd, 3rd with first, second, third', async () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](1, 'bar1');\n          jestExpect(fn)[returnedWith](2, 'bar2');\n          jestExpect(fn)[returnedWith](3, 'bar3');\n        }).toThrowErrorMatchingSnapshot();\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not positive integer', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should reject nth value greater than number of calls', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](4, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not integer', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0.1, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('negative throw matcher error for n that is not number', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedWith]();\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            return 0;\n          } else {\n            const recursiveResult = fn(value - 1);\n\n            if (value === 2) {\n              // Only 2 of the recursive calls have returned at this point\n              jestExpect(fn).not[returnedWith](1, 6);\n              jestExpect(fn).not[returnedWith](2, 3);\n              jestExpect(fn)[returnedWith](3, 1);\n              jestExpect(fn)[returnedWith](4, 0);\n\n              expect(() =>\n                jestExpect(fn)[returnedWith](1, 6),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn)[returnedWith](2, 3),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](3, 1),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](4, 0),\n              ).toThrowErrorMatchingSnapshot();\n            }\n\n            return value + recursiveResult;\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveLast(returnedWith)) {\n    describe('lastReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith]('foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith]('foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            jestExpect(fn).not[returnedWith](0);\n            expect(() =>\n              jestExpect(fn)[returnedWith](0),\n            ).toThrowErrorMatchingSnapshot();\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works only on spies or jest.fn",
            "suites": [],
            "updatePoint": {
                "line": 1012,
                "column": 38
            },
            "line": 1012,
            "code": "  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returnedWith]()).toThrowErrorMatchingSnapshot();\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works when not called",
            "suites": [],
            "updatePoint": {
                "line": 1019,
                "column": 29
            },
            "line": 1019,
            "code": "  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with no arguments",
            "suites": [],
            "updatePoint": {
                "line": 1037,
                "column": 31
            },
            "line": 1037,
            "code": "  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1);\n    } else {\n      jestExpect(fn)[returnedWith]();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with argument that does not match",
            "suites": [],
            "updatePoint": {
                "line": 1048,
                "column": 47
            },
            "line": 1048,
            "code": "  test('works with argument that does not match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with argument that does match",
            "suites": [],
            "updatePoint": {
                "line": 1067,
                "column": 43
            },
            "line": 1067,
            "code": "  test('works with argument that does match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with undefined",
            "suites": [],
            "updatePoint": {
                "line": 1086,
                "column": 28
            },
            "line": 1086,
            "code": "  test('works with undefined', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Map",
            "suites": [],
            "updatePoint": {
                "line": 1105,
                "column": 22
            },
            "line": 1105,
            "code": "  test('works with Map', () => {\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    const fn = jest.fn(() => m1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, m2);\n      jestExpect(fn).not[returnedWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](m2);\n      jestExpect(fn).not[returnedWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Set",
            "suites": [],
            "updatePoint": {
                "line": 1145,
                "column": 22
            },
            "line": 1145,
            "code": "  test('works with Set', () => {\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    const fn = jest.fn(() => s1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, s2);\n      jestExpect(fn).not[returnedWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](s2);\n      jestExpect(fn).not[returnedWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Immutable.js objects directly created",
            "suites": [],
            "updatePoint": {
                "line": 1176,
                "column": 56
            },
            "line": 1176,
            "code": "  test('works with Immutable.js objects directly created', () => {\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const fn = jest.fn(() => directlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with Immutable.js objects indirectly created",
            "suites": [],
            "updatePoint": {
                "line": 1196,
                "column": 58
            },
            "line": 1196,
            "code": "  test('works with Immutable.js objects indirectly created', () => {\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    const fn = jest.fn(() => indirectlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "a call that throws is not considered to have returned",
            "suites": [],
            "updatePoint": {
                "line": 1216,
                "column": 61
            },
            "line": 1216,
            "code": "  test('a call that throws is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "a call that throws undefined is not considered to have returned",
            "suites": [],
            "updatePoint": {
                "line": 1248,
                "column": 71
            },
            "line": 1248,
            "code": "  test('a call that throws undefined is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with more calls than the limit",
            "suites": [
                "returnedWith"
            ],
            "updatePoint": {
                "line": 1283,
                "column": 48
            },
            "line": 1283,
            "code": "      test('works with more calls than the limit', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn.mockReturnValueOnce('foo4');\n        fn.mockReturnValueOnce('foo5');\n        fn.mockReturnValueOnce('foo6');\n\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn).not[returnedWith]('bar');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith]('bar');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "incomplete recursive calls are handled properly",
            "suites": [
                "returnedWith"
            ],
            "updatePoint": {
                "line": 1306,
                "column": 59
            },
            "line": 1306,
            "code": "      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            // This test ensures that the incomplete calls are not incorrectly\n            // interpreted as have returned undefined\n            jestExpect(fn).not[returnedWith](undefined);\n            expect(() =>\n              jestExpect(fn)[returnedWith](undefined),\n            ).toThrowErrorMatchingSnapshot();\n\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with three calls",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1332,
                "column": 34
            },
            "line": 1332,
            "code": "      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith](1, 'foo1');\n        jestExpect(fn)[returnedWith](2, 'foo2');\n        jestExpect(fn)[returnedWith](3, 'foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should replace 1st, 2nd, 3rd with first, second, third",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1352,
                "column": 66
            },
            "line": 1352,
            "code": "      test('should replace 1st, 2nd, 3rd with first, second, third', async () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](1, 'bar1');\n          jestExpect(fn)[returnedWith](2, 'bar2');\n          jestExpect(fn)[returnedWith](3, 'bar3');\n        }).toThrowErrorMatchingSnapshot();\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "positive throw matcher error for n that is not positive integer",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1374,
                "column": 75
            },
            "line": 1374,
            "code": "      test('positive throw matcher error for n that is not positive integer', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should reject nth value greater than number of calls",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1383,
                "column": 64
            },
            "line": 1383,
            "code": "      test('should reject nth value greater than number of calls', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](4, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "positive throw matcher error for n that is not integer",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1394,
                "column": 66
            },
            "line": 1394,
            "code": "      test('positive throw matcher error for n that is not integer', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0.1, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "negative throw matcher error for n that is not number",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 65
            },
            "line": 1403,
            "code": "      test('negative throw matcher error for n that is not number', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedWith]();\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "incomplete recursive calls are handled properly",
            "suites": [
                "nthReturnedWith"
            ],
            "updatePoint": {
                "line": 1413,
                "column": 59
            },
            "line": 1413,
            "code": "      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            return 0;\n          } else {\n            const recursiveResult = fn(value - 1);\n\n            if (value === 2) {\n              // Only 2 of the recursive calls have returned at this point\n              jestExpect(fn).not[returnedWith](1, 6);\n              jestExpect(fn).not[returnedWith](2, 3);\n              jestExpect(fn)[returnedWith](3, 1);\n              jestExpect(fn)[returnedWith](4, 0);\n\n              expect(() =>\n                jestExpect(fn)[returnedWith](1, 6),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn)[returnedWith](2, 3),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](3, 1),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](4, 0),\n              ).toThrowErrorMatchingSnapshot();\n            }\n\n            return value + recursiveResult;\n          }\n        });\n\n        fn(3);\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "works with three calls",
            "suites": [
                "lastReturnedWith"
            ],
            "updatePoint": {
                "line": 1453,
                "column": 34
            },
            "line": 1453,
            "code": "      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith]('foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith]('foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "incomplete recursive calls are handled properly",
            "suites": [
                "lastReturnedWith"
            ],
            "updatePoint": {
                "line": 1469,
                "column": 59
            },
            "line": 1469,
            "code": "      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            jestExpect(fn).not[returnedWith](0);\n            expect(() =>\n              jestExpect(fn)[returnedWith](0),\n            ).toThrowErrorMatchingSnapshot();\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "includes the custom mock name in the error message",
            "suites": [
                "lastReturnedWith"
            ],
            "updatePoint": {
                "line": 1490,
                "column": 58
            },
            "line": 1490,
            "code": "  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });",
            "file": "spyMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "stack trace points to correct location when using matchers",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 62
            },
            "line": 43,
            "code": "it('stack trace points to correct location when using matchers', () => {\n  try {\n    jestExpect(true).toBe(false);\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:45:22');\n  }\n});",
            "file": "stacktrace.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "stack trace points to correct location when using nested matchers",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 69
            },
            "line": 51,
            "code": "it('stack trace points to correct location when using nested matchers', () => {\n  try {\n    jestExpect(true).toMatchPredicate((value: unknown) => {\n      jestExpect(value).toBe(false);\n    });\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:54:25');\n  }\n});",
            "file": "stacktrace.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "stack trace points to correct location when throwing from a custom matcher",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 78
            },
            "line": 61,
            "code": "it('stack trace points to correct location when throwing from a custom matcher', () => {\n  try {\n    jestExpect(() => {\n      const foo = () => bar();\n      const bar = () => baz();\n      const baz = () => {\n        throw new Error('Expected');\n      };\n\n      foo();\n    }).toCustomMatch('bar');\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:67:15');\n  }\n});",
            "file": "stacktrace.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should compare objects with Symbol keys",
            "suites": [
                "Symbol in objects"
            ],
            "updatePoint": {
                "line": 12,
                "column": 47
            },
            "line": 12,
            "code": "  test('should compare objects with Symbol keys', () => {\n    const sym = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym]: 'two'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });",
            "file": "symbolInObjects.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should compare objects with mixed keys and Symbol",
            "suites": [
                "Symbol in objects"
            ],
            "updatePoint": {
                "line": 22,
                "column": 57
            },
            "line": 22,
            "code": "  test('should compare objects with mixed keys and Symbol', () => {\n    const sym = Symbol('foo2');\n    const obj1 = {foo: 2, [sym]: 'one'};\n    const obj2 = {foo: 2, [sym]: 'two'};\n    const obj3 = {foo: 2, [sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });",
            "file": "symbolInObjects.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "should compare objects with different Symbol keys",
            "suites": [
                "Symbol in objects"
            ],
            "updatePoint": {
                "line": 32,
                "column": 57
            },
            "line": 32,
            "code": "  test('should compare objects with different Symbol keys', () => {\n    const sym = Symbol('foo');\n    const sym2 = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym2]: 'one'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });",
            "file": "symbolInObjects.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "duck type",
                "Text"
            ],
            "updatePoint": {
                "line": 37,
                "column": 23
            },
            "line": 37,
            "code": "      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = createTextNode(data);\n        const b = createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "duck type",
                "Text"
            ],
            "updatePoint": {
                "line": 47,
                "column": 22
            },
            "line": 47,
            "code": "      test('isNot true', () => {\n        const a = createTextNode('not deep equal a');\n        const b = createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "duck type",
                "Element"
            ],
            "updatePoint": {
                "line": 57,
                "column": 23
            },
            "line": 57,
            "code": "      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = createElement(name, createTextNode(data));\n        const b = createElement(name, createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "duck type",
                "Element"
            ],
            "updatePoint": {
                "line": 68,
                "column": 22
            },
            "line": 68,
            "code": "      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = createElement('strong', createTextNode(data));\n        const b = createElement('span', createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "duck type",
                "Fragment"
            ],
            "updatePoint": {
                "line": 80,
                "column": 23
            },
            "line": 80,
            "code": "      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const a = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "duck type",
                "Fragment"
            ],
            "updatePoint": {
                "line": 99,
                "column": 22
            },
            "line": 99,
            "code": "      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const a = createDocumentFragment(\n          createElement('strong', createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name, createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "document",
                "createTextNode"
            ],
            "updatePoint": {
                "line": 121,
                "column": 23
            },
            "line": 121,
            "code": "      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = document.createTextNode(data);\n        const b = document.createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "document",
                "createTextNode"
            ],
            "updatePoint": {
                "line": 131,
                "column": 22
            },
            "line": 131,
            "code": "      test('isNot true', () => {\n        const a = document.createTextNode('not deep equal a');\n        const b = document.createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "document",
                "createElement"
            ],
            "updatePoint": {
                "line": 141,
                "column": 23
            },
            "line": 141,
            "code": "      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = document.createElement(name);\n        const b = document.createElement(name);\n        a.appendChild(document.createTextNode(data));\n        b.appendChild(document.createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "document",
                "createElement"
            ],
            "updatePoint": {
                "line": 154,
                "column": 22
            },
            "line": 154,
            "code": "      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = document.createElement('strong');\n        const b = document.createElement('span');\n        a.appendChild(document.createTextNode(data));\n        b.appendChild(document.createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "toEqual",
                "document",
                "createDocumentFragment"
            ],
            "updatePoint": {
                "line": 168,
                "column": 23
            },
            "line": 168,
            "code": "      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const aSpan1 = document.createElement(name1);\n        const bSpan1 = document.createElement(name1);\n        aSpan1.appendChild(document.createTextNode(data1));\n        bSpan1.appendChild(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name2);\n        const bSpan2 = document.createElement(name2);\n        aSpan2.appendChild(document.createTextNode(data2));\n        bSpan2.appendChild(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.appendChild(aSpan1);\n        a.appendChild(aSpan2);\n        b.appendChild(bSpan1);\n        b.appendChild(bSpan2);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "toEqual",
                "document",
                "createDocumentFragment"
            ],
            "updatePoint": {
                "line": 195,
                "column": 22
            },
            "line": 195,
            "code": "      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const aSpan1 = document.createElement('strong');\n        const bSpan1 = document.createElement(name);\n        aSpan1.appendChild(document.createTextNode(data1));\n        bSpan1.appendChild(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name);\n        const bSpan2 = document.createElement(name);\n        aSpan2.appendChild(document.createTextNode(data2));\n        bSpan2.appendChild(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.appendChild(aSpan1);\n        a.appendChild(aSpan2);\n        b.appendChild(bSpan1);\n        b.appendChild(bSpan2);\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });",
            "file": "toEqual-dom.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "%s",
            "suites": [],
            "line": 25,
            "code": "describe.each(['toThrowError', 'toThrow'] as const)('%s', toThrow => {\n  class Err extends CustomError {}\n  class Err2 extends CustomError {}\n\n  test('to throw or not to throw', () => {\n    jestExpect(() => {\n      throw new CustomError('apple');\n    })[toThrow]();\n    jestExpect(() => {}).not[toThrow]();\n  });\n\n  describe('substring', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      })[toThrow]('apple');\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not[toThrow]('apple');\n      jestExpect(() => {}).not[toThrow]('apple');\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {})[toThrow]('apple'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        })[toThrow]('banana');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw '';\n        })[toThrow]('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    it('properly escapes strings when matching against errors', () => {\n      jestExpect(() => {\n        throw new TypeError('\"this\"? throws.');\n      })[toThrow]('\"this\"? throws.');\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not[toThrow]('array');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 'Internal Server Error';\n        }).not[toThrow]('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('regexp', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      })[toThrow](/apple/);\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not[toThrow](/apple/);\n      jestExpect(() => {}).not[toThrow](/apple/);\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {})[toThrow](/apple/),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        })[toThrow](/banana/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 0;\n        })[toThrow](/^[123456789]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not[toThrow](/ array /);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 404;\n        }).not[toThrow](/^[123456789]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error class', () => {\n    class SubErr extends Err {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    class SubSubErr extends SubErr {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    it('passes', () => {\n      jestExpect(() => {\n        throw new Err();\n      })[toThrow](Err);\n      jestExpect(() => {\n        throw new Err();\n      })[toThrow](CustomError);\n      jestExpect(() => {\n        throw new Err();\n      }).not[toThrow](Err2);\n      jestExpect(() => {}).not[toThrow](Err);\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        expect(() => {})[toThrow](Err),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        })[toThrow](Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        })[toThrow](Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubErr('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subsubclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubSubErr('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error-message', () => {\n    // Received message in report if object has message property.\n    class ErrorMessage {\n      // not extending Error!\n      constructor(public message: string) {}\n    }\n    const expected = new ErrorMessage('apple');\n\n    describe('pass', () => {\n      test('isNot false', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('apple');\n        })[toThrow](expected);\n      });\n\n      test('isNot true', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('banana');\n        }).not[toThrow](expected);\n      });\n    });\n\n    describe('fail', () => {\n      test('isNot false', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage('banana');\n          })[toThrow](expected),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('isNot true', () => {\n        const message = 'Invalid array length';\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(message);\n          }).not[toThrow]({message}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('multiline diff highlight incorrect expected space', () => {\n        // jest/issues/2673\n        const a =\n          \"There is no route defined for key Settings. \\nMust be one of: 'Home'\";\n        const b =\n          \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(b);\n          })[toThrow]({message: a}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n  });\n\n  describe('asymmetric', () => {\n    describe('any-Class', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          })[toThrow](expect.any(Err));\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).not[toThrow](expect.any(Err2));\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            })[toThrow](expect.any(Err2)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).not[toThrow](expect.any(Err)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('anything', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](expect.anything());\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {}).not[toThrow](expect.anything());\n          jestExpect(() => {\n            // eslint-disable-next-line no-throw-literal\n            throw null;\n          }).not[toThrow](expect.anything());\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              // eslint-disable-next-line no-throw-literal\n              throw null;\n            })[toThrow](expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('no-symbol', () => {\n      // Test serialization of asymmetric matcher which has no property:\n      // this.$$typeof = Symbol.for('jest.asymmetricMatcher')\n      const matchError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name === 'Error'\n          );\n        },\n      };\n      const matchNotError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name !== 'Error'\n          );\n        },\n      };\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not[toThrow](matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            })[toThrow](matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('objectContaining', () => {\n      const matchError = expect.objectContaining({\n        name: 'Error',\n      });\n      const matchNotError = expect.objectContaining({\n        name: 'NotError',\n      });\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not[toThrow](matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            })[toThrow](matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n  });\n\n  describe('promise/async throws if Error-like object is returned', () => {\n    const asyncFn = async (shouldThrow?: boolean, resolve?: boolean) => {\n      let err;\n      if (shouldThrow) {\n        err = new Err('async apple');\n      }\n      if (resolve) {\n        return Promise.resolve(err || 'apple');\n      } else {\n        return Promise.reject(err || 'apple');\n      }\n    };\n\n    test('passes', async () => {\n      expect.assertions(24);\n      await jestExpect(Promise.reject(new Error())).rejects[toThrow]();\n\n      await jestExpect(asyncFn(true)).rejects[toThrow]();\n      await jestExpect(asyncFn(true)).rejects[toThrow](Err);\n      await jestExpect(asyncFn(true)).rejects[toThrow](Error);\n      await jestExpect(asyncFn(true)).rejects[toThrow]('apple');\n      await jestExpect(asyncFn(true)).rejects[toThrow](/app/);\n\n      await jestExpect(asyncFn(true)).rejects.not[toThrow](Err2);\n      await jestExpect(asyncFn(true)).rejects.not[toThrow]('banana');\n      await jestExpect(asyncFn(true)).rejects.not[toThrow](/banana/);\n\n      await jestExpect(asyncFn(true, true)).resolves[toThrow]();\n\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]();\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](Error);\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]('apple');\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](/apple/);\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]('banana');\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](/banana/);\n\n      await jestExpect(asyncFn()).rejects.not[toThrow]();\n      await jestExpect(asyncFn()).rejects.not[toThrow](Error);\n      await jestExpect(asyncFn()).rejects.not[toThrow]('apple');\n      await jestExpect(asyncFn()).rejects.not[toThrow](/apple/);\n      await jestExpect(asyncFn()).rejects.not[toThrow]('banana');\n      await jestExpect(asyncFn()).rejects.not[toThrow](/banana/);\n\n      // Works with nested functions inside promises\n      await jestExpect(\n        Promise.reject(() => {\n          throw new Error();\n        }),\n      ).rejects[toThrow]();\n      await jestExpect(Promise.reject(() => {})).rejects.not[toThrow]();\n    });\n\n    test('did not throw at all', async () => {\n      await expect(\n        jestExpect(asyncFn()).rejects[toThrow](),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects[toThrow](Err2),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but should not have', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.not[toThrow](),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('expected is undefined', () => {\n    test('threw, but should not have (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        }).not[toThrow]();\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  test('invalid arguments', () => {\n    expect(() =>\n      jestExpect(() => {}).not[toThrow](111),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('invalid actual', () => {\n    expect(() =>\n      jestExpect('a string')[toThrow](),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "to throw or not to throw",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 32
            },
            "line": 29,
            "code": "  test('to throw or not to throw', () => {\n    jestExpect(() => {\n      throw new CustomError('apple');\n    })[toThrow]();\n    jestExpect(() => {}).not[toThrow]();\n  });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 37,
                "column": 14
            },
            "line": 37,
            "code": "    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      })[toThrow]('apple');\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not[toThrow]('apple');\n      jestExpect(() => {}).not[toThrow]('apple');\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "did not throw at all",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 47,
                "column": 30
            },
            "line": 47,
            "code": "    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {})[toThrow]('apple'),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message did not match (error)",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 53,
                "column": 50
            },
            "line": 53,
            "code": "    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        })[toThrow]('banana');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message did not match (non-error falsey)",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 61,
                "column": 61
            },
            "line": 61,
            "code": "    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw '';\n        })[toThrow]('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "properly escapes strings when matching against errors",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 70,
                "column": 61
            },
            "line": 70,
            "code": "    it('properly escapes strings when matching against errors', () => {\n      jestExpect(() => {\n        throw new TypeError('\"this\"? throws.');\n      })[toThrow]('\"this\"? throws.');\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message should not match (error)",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 76,
                "column": 53
            },
            "line": 76,
            "code": "    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not[toThrow]('array');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message should not match (non-error truthy)",
            "suites": [
                "substring"
            ],
            "updatePoint": {
                "line": 84,
                "column": 64
            },
            "line": 84,
            "code": "    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 'Internal Server Error';\n        }).not[toThrow]('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 95,
                "column": 14
            },
            "line": 95,
            "code": "    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      })[toThrow](/apple/);\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not[toThrow](/apple/);\n      jestExpect(() => {}).not[toThrow](/apple/);\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "did not throw at all",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 105,
                "column": 30
            },
            "line": 105,
            "code": "    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {})[toThrow](/apple/),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message did not match (error)",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 111,
                "column": 50
            },
            "line": 111,
            "code": "    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        })[toThrow](/banana/);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message did not match (non-error falsey)",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 119,
                "column": 61
            },
            "line": 119,
            "code": "    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 0;\n        })[toThrow](/^[123456789]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message should not match (error)",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 128,
                "column": 53
            },
            "line": 128,
            "code": "    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not[toThrow](/ array /);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but message should not match (non-error truthy)",
            "suites": [
                "regexp"
            ],
            "updatePoint": {
                "line": 136,
                "column": 64
            },
            "line": 136,
            "code": "    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 404;\n        }).not[toThrow](/^[123456789]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 165,
                "column": 14
            },
            "line": 165,
            "code": "    it('passes', () => {\n      jestExpect(() => {\n        throw new Err();\n      })[toThrow](Err);\n      jestExpect(() => {\n        throw new Err();\n      })[toThrow](CustomError);\n      jestExpect(() => {\n        throw new Err();\n      }).not[toThrow](Err2);\n      jestExpect(() => {}).not[toThrow](Err);\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "did not throw at all",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 178,
                "column": 30
            },
            "line": 178,
            "code": "    test('did not throw at all', () => {\n      expect(() =>\n        expect(() => {})[toThrow](Err),\n      ).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class did not match (error)",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 184,
                "column": 48
            },
            "line": 184,
            "code": "    test('threw, but class did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        })[toThrow](Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class did not match (non-error falsey)",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 192,
                "column": 59
            },
            "line": 192,
            "code": "    test('threw, but class did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        })[toThrow](Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class should not match (error)",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 201,
                "column": 51
            },
            "line": 201,
            "code": "    test('threw, but class should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class should not match (error subclass)",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 209,
                "column": 60
            },
            "line": 209,
            "code": "    test('threw, but class should not match (error subclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubErr('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class should not match (error subsubclass)",
            "suites": [
                "error class"
            ],
            "updatePoint": {
                "line": 217,
                "column": 63
            },
            "line": 217,
            "code": "    test('threw, but class should not match (error subsubclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubSubErr('apple');\n        }).not[toThrow](Err);\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "error-message",
                "pass"
            ],
            "updatePoint": {
                "line": 235,
                "column": 23
            },
            "line": 235,
            "code": "      test('isNot false', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('apple');\n        })[toThrow](expected);\n      });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "error-message",
                "pass"
            ],
            "updatePoint": {
                "line": 241,
                "column": 22
            },
            "line": 241,
            "code": "      test('isNot true', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('banana');\n        }).not[toThrow](expected);\n      });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "error-message",
                "fail"
            ],
            "updatePoint": {
                "line": 249,
                "column": 23
            },
            "line": 249,
            "code": "      test('isNot false', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage('banana');\n          })[toThrow](expected),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "error-message",
                "fail"
            ],
            "updatePoint": {
                "line": 257,
                "column": 22
            },
            "line": 257,
            "code": "      test('isNot true', () => {\n        const message = 'Invalid array length';\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(message);\n          }).not[toThrow]({message}),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "multiline diff highlight incorrect expected space",
            "suites": [
                "error-message",
                "fail"
            ],
            "updatePoint": {
                "line": 266,
                "column": 61
            },
            "line": 266,
            "code": "      test('multiline diff highlight incorrect expected space', () => {\n        // jest/issues/2673\n        const a =\n          \"There is no route defined for key Settings. \\nMust be one of: 'Home'\";\n        const b =\n          \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(b);\n          })[toThrow]({message: a}),\n        ).toThrowErrorMatchingSnapshot();\n      });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "any-Class",
                "pass"
            ],
            "updatePoint": {
                "line": 284,
                "column": 25
            },
            "line": 284,
            "code": "        test('isNot false', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          })[toThrow](expect.any(Err));\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "any-Class",
                "pass"
            ],
            "updatePoint": {
                "line": 290,
                "column": 24
            },
            "line": 290,
            "code": "        test('isNot true', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).not[toThrow](expect.any(Err2));\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "any-Class",
                "fail"
            ],
            "updatePoint": {
                "line": 298,
                "column": 25
            },
            "line": 298,
            "code": "        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            })[toThrow](expect.any(Err2)),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "any-Class",
                "fail"
            ],
            "updatePoint": {
                "line": 306,
                "column": 24
            },
            "line": 306,
            "code": "        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).not[toThrow](expect.any(Err)),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "anything",
                "pass"
            ],
            "updatePoint": {
                "line": 318,
                "column": 25
            },
            "line": 318,
            "code": "        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](expect.anything());\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "anything",
                "pass"
            ],
            "updatePoint": {
                "line": 324,
                "column": 24
            },
            "line": 324,
            "code": "        test('isNot true', () => {\n          jestExpect(() => {}).not[toThrow](expect.anything());\n          jestExpect(() => {\n            // eslint-disable-next-line no-throw-literal\n            throw null;\n          }).not[toThrow](expect.anything());\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "anything",
                "fail"
            ],
            "updatePoint": {
                "line": 334,
                "column": 25
            },
            "line": 334,
            "code": "        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              // eslint-disable-next-line no-throw-literal\n              throw null;\n            })[toThrow](expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "anything",
                "fail"
            ],
            "updatePoint": {
                "line": 343,
                "column": 24
            },
            "line": 343,
            "code": "        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "no-symbol",
                "pass"
            ],
            "updatePoint": {
                "line": 376,
                "column": 25
            },
            "line": 376,
            "code": "        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](matchError);\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "no-symbol",
                "pass"
            ],
            "updatePoint": {
                "line": 382,
                "column": 24
            },
            "line": 382,
            "code": "        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not[toThrow](matchNotError);\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "no-symbol",
                "fail"
            ],
            "updatePoint": {
                "line": 390,
                "column": 25
            },
            "line": 390,
            "code": "        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            })[toThrow](matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "no-symbol",
                "fail"
            ],
            "updatePoint": {
                "line": 398,
                "column": 24
            },
            "line": 398,
            "code": "        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "objectContaining",
                "pass"
            ],
            "updatePoint": {
                "line": 417,
                "column": 25
            },
            "line": 417,
            "code": "        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          })[toThrow](matchError);\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "objectContaining",
                "pass"
            ],
            "updatePoint": {
                "line": 423,
                "column": 24
            },
            "line": 423,
            "code": "        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not[toThrow](matchNotError);\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot false",
            "suites": [
                "asymmetric",
                "objectContaining",
                "fail"
            ],
            "updatePoint": {
                "line": 431,
                "column": 25
            },
            "line": 431,
            "code": "        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            })[toThrow](matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "isNot true",
            "suites": [
                "asymmetric",
                "objectContaining",
                "fail"
            ],
            "updatePoint": {
                "line": 439,
                "column": 24
            },
            "line": 439,
            "code": "        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not[toThrow](matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "passes",
            "suites": [
                "promise/async throws if Error-like object is returned"
            ],
            "updatePoint": {
                "line": 463,
                "column": 16
            },
            "line": 463,
            "code": "    test('passes', async () => {\n      expect.assertions(24);\n      await jestExpect(Promise.reject(new Error())).rejects[toThrow]();\n\n      await jestExpect(asyncFn(true)).rejects[toThrow]();\n      await jestExpect(asyncFn(true)).rejects[toThrow](Err);\n      await jestExpect(asyncFn(true)).rejects[toThrow](Error);\n      await jestExpect(asyncFn(true)).rejects[toThrow]('apple');\n      await jestExpect(asyncFn(true)).rejects[toThrow](/app/);\n\n      await jestExpect(asyncFn(true)).rejects.not[toThrow](Err2);\n      await jestExpect(asyncFn(true)).rejects.not[toThrow]('banana');\n      await jestExpect(asyncFn(true)).rejects.not[toThrow](/banana/);\n\n      await jestExpect(asyncFn(true, true)).resolves[toThrow]();\n\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]();\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](Error);\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]('apple');\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](/apple/);\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow]('banana');\n      await jestExpect(asyncFn(false, true)).resolves.not[toThrow](/banana/);\n\n      await jestExpect(asyncFn()).rejects.not[toThrow]();\n      await jestExpect(asyncFn()).rejects.not[toThrow](Error);\n      await jestExpect(asyncFn()).rejects.not[toThrow]('apple');\n      await jestExpect(asyncFn()).rejects.not[toThrow](/apple/);\n      await jestExpect(asyncFn()).rejects.not[toThrow]('banana');\n      await jestExpect(asyncFn()).rejects.not[toThrow](/banana/);\n\n      // Works with nested functions inside promises\n      await jestExpect(\n        Promise.reject(() => {\n          throw new Error();\n        }),\n      ).rejects[toThrow]();\n      await jestExpect(Promise.reject(() => {})).rejects.not[toThrow]();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "did not throw at all",
            "suites": [
                "promise/async throws if Error-like object is returned"
            ],
            "updatePoint": {
                "line": 502,
                "column": 30
            },
            "line": 502,
            "code": "    test('did not throw at all', async () => {\n      await expect(\n        jestExpect(asyncFn()).rejects[toThrow](),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but class did not match",
            "suites": [
                "promise/async throws if Error-like object is returned"
            ],
            "updatePoint": {
                "line": 508,
                "column": 40
            },
            "line": 508,
            "code": "    test('threw, but class did not match', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects[toThrow](Err2),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but should not have",
            "suites": [
                "promise/async throws if Error-like object is returned"
            ],
            "updatePoint": {
                "line": 514,
                "column": 36
            },
            "line": 514,
            "code": "    test('threw, but should not have', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.not[toThrow](),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "threw, but should not have (non-error falsey)",
            "suites": [
                "expected is undefined"
            ],
            "updatePoint": {
                "line": 522,
                "column": 55
            },
            "line": 522,
            "code": "    test('threw, but should not have (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        }).not[toThrow]();\n      }).toThrowErrorMatchingSnapshot();\n    });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "invalid arguments",
            "suites": [
                "expected is undefined"
            ],
            "updatePoint": {
                "line": 532,
                "column": 25
            },
            "line": 532,
            "code": "  test('invalid arguments', () => {\n    expect(() =>\n      jestExpect(() => {}).not[toThrow](111),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "invalid actual",
            "suites": [
                "expected is undefined"
            ],
            "updatePoint": {
                "line": 538,
                "column": 22
            },
            "line": 538,
            "code": "  test('invalid actual', () => {\n    expect(() =>\n      jestExpect('a string')[toThrow](),\n    ).toThrowErrorMatchingSnapshot();\n  });",
            "file": "toThrowMatchers.test.ts",
            "skipped": false,
            "dir": "packages/expect/src/__tests__"
        },
        {
            "name": "tests are not marked done until their parent afterAll runs",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 64
            },
            "line": 10,
            "code": "test('tests are not marked done until their parent afterAll runs', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      afterAll(() => {});\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        afterAll(() => {});\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      afterAll(() => { throw new Error('alabama'); });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "describe block cannot have hooks and no tests",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 51
            },
            "line": 36,
            "code": "test('describe block cannot have hooks and no tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => {});\n      beforeEach(() => {});\n      afterAll(() => {});\n      beforeAll(() => {});\n    })\n  `);\n\n  expect(result.stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "describe block _can_ have hooks if a child describe block has tests",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 73
            },
            "line": 49,
            "code": "test('describe block _can_ have hooks if a child describe block has tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => console.log('> afterEach'));\n      beforeEach(() => console.log('> beforeEach'));\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      describe('child describe', () => {\n        test('my test', () => console.log('> my test'));\n      })\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "describe block hooks must not run if describe block is skipped",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 68
            },
            "line": 64,
            "code": "test('describe block hooks must not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "child tests marked with todo should not run if describe block is skipped",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 78
            },
            "line": 75,
            "code": "test('child tests marked with todo should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.todo('my test');\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "child tests marked with only should not run if describe block is skipped",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 78
            },
            "line": 86,
            "code": "test('child tests marked with only should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.only('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});",
            "file": "afterAll.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "simple test",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 17
            },
            "line": 10,
            "code": "test('simple test', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => {});\n      test('one', () => {});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "baseTest.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "function descriptors",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 26
            },
            "line": 23,
            "code": "test('function descriptors', () => {\n  const {stdout} = runTest(`\n    describe(function describer() {}, () => {\n      test(class One {}, () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "baseTest.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "failures",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 14
            },
            "line": 33,
            "code": "test('failures', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test('one', () => { throw new Error('kentucky')});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "baseTest.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it doesn't throw an error with valid arguments",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 23,
                "column": 52
            },
            "line": 23,
            "code": "  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt.failing('test1', () => {});\n    }).not.toThrow();\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws error with missing callback function",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 28,
                "column": 52
            },
            "line": 28,
            "code": "  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws an error when first argument isn't valid",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 36,
                "column": 56
            },
            "line": 36,
            "code": "  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws an error when callback function is not a function",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 44,
                "column": 65
            },
            "line": 44,
            "code": "  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws error with missing callback function",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 52,
                "column": 54
            },
            "line": 52,
            "code": "  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test5');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws an error when first argument isn't a string",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 60,
                "column": 61
            },
            "line": 60,
            "code": "  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws an error when callback function is not a function",
            "suites": [
                "test/it.failing error throwing"
            ],
            "updatePoint": {
                "line": 68,
                "column": 67
            },
            "line": 68,
            "code": "  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test7', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });",
            "file": "circusItFailingTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it doesn't throw an error with valid arguments",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 23,
                "column": 52
            },
            "line": 23,
            "code": "  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt('test1', () => {});\n    }).not.toThrow();\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws error with missing callback function",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 28,
                "column": 52
            },
            "line": 28,
            "code": "  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws an error when first argument isn't valid",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 36,
                "column": 56
            },
            "line": 36,
            "code": "  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "it throws an error when callback function is not a function",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 44,
                "column": 65
            },
            "line": 44,
            "code": "  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test doesn't throw an error with valid arguments",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 52,
                "column": 54
            },
            "line": 52,
            "code": "  it(\"test doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusTest('test5', () => {});\n    }).not.toThrow();\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws error with missing callback function",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 57,
                "column": 54
            },
            "line": 57,
            "code": "  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test6');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws an error when first argument isn't a string",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 65,
                "column": 61
            },
            "line": 65,
            "code": "  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "test throws an error when callback function is not a function",
            "suites": [
                "test/it error throwing"
            ],
            "updatePoint": {
                "line": 73,
                "column": 67
            },
            "line": 73,
            "code": "  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test8', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });",
            "file": "circusItTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "todo throws error when given no arguments",
            "suites": [
                "test/it.todo error throwing"
            ],
            "updatePoint": {
                "line": 21,
                "column": 47
            },
            "line": 21,
            "code": "  it('todo throws error when given no arguments', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo();\n    }).toThrow('Todo must be called with only a description.');\n  });",
            "file": "circusItTodoTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "todo throws error when given more than one argument",
            "suites": [
                "test/it.todo error throwing"
            ],
            "updatePoint": {
                "line": 27,
                "column": 57
            },
            "line": 27,
            "code": "  it('todo throws error when given more than one argument', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo('test1', () => {});\n    }).toThrow('Todo must be called with only a description.');\n  });",
            "file": "circusItTodoTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "todo throws error when given none string description",
            "suites": [
                "test/it.todo error throwing"
            ],
            "updatePoint": {
                "line": 33,
                "column": 58
            },
            "line": 33,
            "code": "  it('todo throws error when given none string description', () => {\n    expect(() => {\n      circusIt.todo(() => {});\n    }).toThrow('Todo must be called with only a description.');\n  });",
            "file": "circusItTodoTestError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "beforeEach is executed before each test in current/child describe blocks",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 78
            },
            "line": 10,
            "code": "test('beforeEach is executed before each test in current/child describe blocks', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => console.log('> describe beforeEach'));\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        beforeEach(() => console.log('> 2nd level describe beforeEach'));\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      beforeEach(() => {\n        console.log('> 2nd describe beforeEach that throws')\n        throw new Error('alabama');\n      });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "hooks.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "multiple before each hooks in one describe are executed in the right order",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 80
            },
            "line": 39,
            "code": "test('multiple before each hooks in one describe are executed in the right order', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeEach(() => {\n        console.log('before each 1');\n      });\n      beforeEach(() => {\n        console.log('before each 2');\n      });\n\n      describe('2nd level describe', () => {\n        test('test', () => {});\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "hooks.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "beforeAll is exectued correctly",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 37
            },
            "line": 58,
            "code": "test('beforeAll is exectued correctly', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeAll(() => console.log('> beforeAll 1'));\n      test('test 1', () => console.log('> test 1'));\n\n      describe('2nd level describe', () => {\n        beforeAll(() => console.log('> beforeAll 2'));\n        test('test 2', () => console.log('> test 2'));\n        test('test 3', () => console.log('> test 3'));\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});",
            "file": "hooks.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "%s hooks error throwing",
            "suites": [],
            "line": 10,
            "code": "describe.each(['beforeEach', 'beforeAll', 'afterEach', 'afterAll'] as const)(\n  '%s hooks error throwing',\n  fn => {\n    test.each(['String', 1, [], {}, Symbol('hello'), true, null, undefined])(\n      `${fn} throws an error when %p is provided as a first argument to it`,\n      el => {\n        expect(() => {\n          // @ts-expect-error: Testing runtime errors here\n          circus[fn](el);\n        }).toThrow('Invalid first argument. It must be a callback function.');\n      },\n    );\n  },\n);",
            "file": "hooksError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": " throws an error when %p is provided as a first argument to it",
            "suites": [],
            "line": 13,
            "code": "    test.each(['String', 1, [], {}, Symbol('hello'), true, null, undefined])(\n      `${fn} throws an error when %p is provided as a first argument to it`,\n      el => {\n        expect(() => {\n          // @ts-expect-error: Testing runtime errors here\n          circus[fn](el);\n        }).toThrow('Invalid first argument. It must be a callback function.');\n      },\n    );",
            "file": "hooksError.test.ts",
            "skipped": false,
            "dir": "packages/jest-circus/src/__tests__"
        },
        {
            "name": "get configuration defaults",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 32
            },
            "line": 10,
            "code": "test('get configuration defaults', () => {\n  expect(defaults).toBeDefined();\n});",
            "file": "Defaults.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Returns 1 when runInBand",
            "suites": [
                "getMaxWorkers"
            ],
            "updatePoint": {
                "line": 18,
                "column": 30
            },
            "line": 18,
            "code": "  it('Returns 1 when runInBand', () => {\n    const argv = {runInBand: true};\n    expect(getMaxWorkers(argv)).toBe(1);\n  });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Returns 1 when the OS CPUs are not available",
            "suites": [
                "getMaxWorkers"
            ],
            "updatePoint": {
                "line": 23,
                "column": 50
            },
            "line": 23,
            "code": "  it('Returns 1 when the OS CPUs are not available', () => {\n    require('os').__setCpus(undefined);\n    expect(getMaxWorkers({})).toBe(1);\n  });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Returns the `maxWorkers` when specified",
            "suites": [
                "getMaxWorkers"
            ],
            "updatePoint": {
                "line": 28,
                "column": 45
            },
            "line": 28,
            "code": "  it('Returns the `maxWorkers` when specified', () => {\n    const argv = {maxWorkers: 8};\n    expect(getMaxWorkers(argv)).toBe(8);\n  });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Returns based on the number of cpus",
            "suites": [
                "getMaxWorkers"
            ],
            "updatePoint": {
                "line": 33,
                "column": 41
            },
            "line": 33,
            "code": "  it('Returns based on the number of cpus', () => {\n    expect(getMaxWorkers({})).toBe(3);\n    expect(getMaxWorkers({watch: true})).toBe(2);\n    expect(getMaxWorkers({watchAll: true})).toBe(2);\n  });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "50% = 2 workers",
            "suites": [
                "getMaxWorkers",
                "% based"
            ],
            "updatePoint": {
                "line": 40,
                "column": 23
            },
            "line": 40,
            "code": "    it('50% = 2 workers', () => {\n      const argv = {maxWorkers: '50%'};\n      expect(getMaxWorkers(argv)).toBe(2);\n    });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "< 0 workers should become 1",
            "suites": [
                "getMaxWorkers",
                "% based"
            ],
            "updatePoint": {
                "line": 45,
                "column": 35
            },
            "line": 45,
            "code": "    it('< 0 workers should become 1', () => {\n      const argv = {maxWorkers: '1%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "0% shouldn't break",
            "suites": [
                "getMaxWorkers",
                "% based"
            ],
            "updatePoint": {
                "line": 50,
                "column": 26
            },
            "line": 50,
            "code": "    it(\"0% shouldn't break\", () => {\n      const argv = {maxWorkers: '0%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });",
            "file": "getMaxWorkers.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "picks an id based on the rootDir",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 36
            },
            "line": 73,
            "code": "it('picks an id based on the rootDir', async () => {\n  const rootDir = '/root/path/foo';\n  const expected = createHash('sha1')\n    .update('/root/path/foo')\n    .update(String(Infinity))\n    .digest('hex')\n    .substring(0, 32);\n  const {options} = await normalize(\n    {\n      rootDir,\n    },\n    {} as Config.Argv,\n  );\n  expect(options.id).toBe(expected);\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "keeps custom project id based on the projects rootDir",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 57
            },
            "line": 89,
            "code": "it('keeps custom project id based on the projects rootDir', async () => {\n  const id = 'test';\n  const {options} = await normalize(\n    {\n      projects: [{id, rootDir: '/path/to/foo'}],\n      rootDir: '/root/path/baz',\n    },\n    {} as Config.Argv,\n  );\n\n  expect((options.projects as Array<Config.InitialProjectOptions>)[0].id).toBe(\n    id,\n  );\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "validation warning occurs when options not for projects is set",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 66
            },
            "line": 104,
            "code": "it('validation warning occurs when options not for projects is set', async () => {\n  const mockWarn = jest.mocked(console.warn).mockImplementation(() => {});\n  const rootDir = '/root/path/foo';\n  await normalize(\n    {\n      bail: true, // an option not for projects\n      rootDir,\n    },\n    {} as Config.Argv,\n    rootDir,\n    1,\n    true, // isProjectOptions\n  );\n\n  expect(mockWarn).toHaveBeenCalledTimes(1);\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "keeps custom ids based on the rootDir",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 41
            },
            "line": 121,
            "code": "it('keeps custom ids based on the rootDir', async () => {\n  const {options} = await normalize(\n    {\n      id: 'custom-id',\n      rootDir: '/root/path/foo',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.id).toBe('custom-id');\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "minimal config is stable across runs",
            "suites": [],
            "updatePoint": {
                "line": 133,
                "column": 40
            },
            "line": 133,
            "code": "it('minimal config is stable across runs', async () => {\n  const firstNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55555,\n  } as Config.Argv);\n  const secondNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55555,\n  } as Config.Argv);\n\n  expect(firstNormalization).toEqual(secondNormalization);\n  expect(JSON.stringify(firstNormalization)).toBe(\n    JSON.stringify(secondNormalization),\n  );\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "sets coverageReporters correctly when argv.json is set",
            "suites": [],
            "updatePoint": {
                "line": 147,
                "column": 58
            },
            "line": 147,
            "code": "it('sets coverageReporters correctly when argv.json is set', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/path/foo',\n    },\n    {\n      json: true,\n    } as Config.Argv,\n  );\n\n  expect(options.coverageReporters).toEqual(['json', 'lcov', 'clover']);\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws if the options is missing a rootDir property",
            "suites": [
                "rootDir"
            ],
            "updatePoint": {
                "line": 161,
                "column": 57
            },
            "line": 161,
            "code": "  it('throws if the options is missing a rootDir property', async () => {\n    expect.assertions(1);\n\n    await expect(\n      normalize({}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "falsy automock is not overwritten",
            "suites": [
                "automock"
            ],
            "updatePoint": {
                "line": 171,
                "column": 39
            },
            "line": 171,
            "code": "  it('falsy automock is not overwritten', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        automock: false,\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.automock).toBe(false);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "ignores <rootDir> tokens",
            "suites": [
                "collectCoverageFrom"
            ],
            "updatePoint": {
                "line": 186,
                "column": 30
            },
            "line": 186,
            "code": "  it('ignores <rootDir> tokens', async () => {\n    const barBaz = 'bar/baz';\n    const quxQuux = 'qux/quux/';\n    const notQuxQuux = `!${quxQuux}`;\n\n    const {options} = await normalize(\n      {\n        collectCoverageFrom: [\n          barBaz,\n          notQuxQuux,\n          `<rootDir>/${barBaz}`,\n          `!<rootDir>/${quxQuux}`,\n        ],\n        rootDir: '/root/path/foo/',\n      },\n      {} as Config.Argv,\n    );\n\n    const expected = [barBaz, notQuxQuux, barBaz, notQuxQuux];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "it generates --coverageCoverageFrom patterns when needed",
            "suites": [
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 211,
                "column": 62
            },
            "line": 211,
            "code": "  it('it generates --coverageCoverageFrom patterns when needed', async () => {\n    const sourceFile = 'file1.js';\n\n    const {options} = await normalize(\n      {\n        collectCoverage: true,\n        rootDir: '/root/path/foo/',\n      },\n      {\n        _: [\n          `/root/path/${sourceFile}`,\n          sourceFile,\n          `<rootDir>/bar/${sourceFile}`,\n        ],\n        findRelatedTests: true,\n      } as Config.Argv,\n    );\n\n    const expected = [`../${sourceFile}`, `${sourceFile}`, `bar/${sourceFile}`];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes all paths relative to rootDir",
            "suites": [
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 236,
                "column": 46
            },
            "line": 236,
            "code": "  it('normalizes all paths relative to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar, expectedPathFooQux]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not change absolute paths",
            "suites": [
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 248,
                "column": 36
            },
            "line": 248,
            "code": "  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['/an/abs/path', '/another/abs/path'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathAbs, expectedPathAbsAnother]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 260,
                "column": 34
            },
            "line": 260,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['<rootDir>/bar/baz'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "allows empty list",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 285,
                "column": 23
            },
            "line": 285,
            "code": "  it('allows empty list', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes the path and options object",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 297,
                "column": 44
            },
            "line": 297,
            "code": "  it('normalizes the path and options object', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [\n          'default',\n          'github-actions',\n          '<rootDir>/custom-reporter.js',\n          ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n          ['jest-junit', {outputName: 'report.xml'}],\n        ],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([\n      ['default', {}],\n      ['github-actions', {}],\n      ['/root/custom-reporter.js', {}],\n      ['/root/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n      ['jest-junit', {outputName: 'report.xml'}],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws an error if value is neither string nor array",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 321,
                "column": 58
            },
            "line": 321,
            "code": "  it('throws an error if value is neither string nor array', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [123],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws an error if first value in the tuple is not a string",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 335,
                "column": 65
            },
            "line": 335,
            "code": "  it('throws an error if first value in the tuple is not a string', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [[123]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws an error if second value is missing in the tuple",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 349,
                "column": 61
            },
            "line": 349,
            "code": "  it('throws an error if second value is missing in the tuple', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter']],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws an error if second value in the tuple is not an object",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 363,
                "column": 67
            },
            "line": 363,
            "code": "  it('throws an error if second value in the tuple is not an object', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter', true]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes the path",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 386,
                "column": 25
            },
            "line": 386,
            "code": "  it('normalizes the path', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: 'babel-jest',\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "pulls in config if it's passed as an array, and defaults to empty object",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 405,
                "column": 78
            },
            "line": 405,
            "code": "  it(\"pulls in config if it's passed as an array, and defaults to empty object\", async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: ['babel-jest', {rootMode: 'upward'}],\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {rootMode: 'upward'}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes the path for hasteImplModulePath",
            "suites": [
                "haste"
            ],
            "updatePoint": {
                "line": 433,
                "column": 49
            },
            "line": 433,
            "code": "  it('normalizes the path for hasteImplModulePath', async () => {\n    const {options} = await normalize(\n      {\n        haste: {\n          hasteImplModulePath: '<rootDir>/haste_impl.js',\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.haste).toEqual({\n      hasteImplModulePath: '/root/haste_impl.js',\n    });\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes the path according to rootDir",
            "suites": [
                "setupFilesAfterEnv"
            ],
            "updatePoint": {
                "line": 460,
                "column": 46
            },
            "line": 460,
            "code": "  it('normalizes the path according to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not change absolute paths",
            "suites": [
                "setupFilesAfterEnv"
            ],
            "updatePoint": {
                "line": 472,
                "column": 36
            },
            "line": 472,
            "code": "  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['/an/abs/path'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathAbs]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "setupFilesAfterEnv"
            ],
            "updatePoint": {
                "line": 484,
                "column": 34
            },
            "line": 484,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['<rootDir>/bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize paths relative to rootDir",
            "suites": [
                "coveragePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 498,
                "column": 50
            },
            "line": 498,
            "code": "  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize trailing slashes",
            "suites": [
                "coveragePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 515,
                "column": 41
            },
            "line": 515,
            "code": "  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "coveragePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 532,
                "column": 34
            },
            "line": 532,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize paths relative to rootDir",
            "suites": [
                "watchPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 549,
                "column": 50
            },
            "line": 549,
            "code": "  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize trailing slashes",
            "suites": [
                "watchPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 566,
                "column": 41
            },
            "line": 566,
            "code": "  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "watchPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 583,
                "column": 34
            },
            "line": 583,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize paths relative to rootDir",
            "suites": [
                "testPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 600,
                "column": 50
            },
            "line": 600,
            "code": "  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize trailing slashes",
            "suites": [
                "testPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 617,
                "column": 41
            },
            "line": 617,
            "code": "  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "testPathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 634,
                "column": 34
            },
            "line": 634,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize paths relative to rootDir",
            "suites": [
                "modulePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 651,
                "column": 50
            },
            "line": 651,
            "code": "  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not normalize trailing slashes",
            "suites": [
                "modulePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 668,
                "column": 41
            },
            "line": 668,
            "code": "  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "substitutes <rootDir> tokens",
            "suites": [
                "modulePathIgnorePatterns"
            ],
            "updatePoint": {
                "line": 685,
                "column": 34
            },
            "line": 685,
            "code": "  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to Circus",
            "suites": [
                "testRunner"
            ],
            "updatePoint": {
                "line": 702,
                "column": 24
            },
            "line": 702,
            "code": "  it('defaults to Circus', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-circus');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves jasmine",
            "suites": [
                "testRunner"
            ],
            "updatePoint": {
                "line": 713,
                "column": 22
            },
            "line": 713,
            "code": "  it('resolves jasmine', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'jasmine2',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-jasmine2');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "is overwritten by argv",
            "suites": [
                "testRunner"
            ],
            "updatePoint": {
                "line": 729,
                "column": 28
            },
            "line": 729,
            "code": "  it('is overwritten by argv', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'mocha',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toBe('mocha');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to <rootDir>/coverage",
            "suites": [
                "coverageDirectory"
            ],
            "updatePoint": {
                "line": 747,
                "column": 36
            },
            "line": 747,
            "code": "  it('defaults to <rootDir>/coverage', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coverageDirectory).toBe('/root/path/foo/coverage');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves to an environment and prefers jest-environment-`name`",
            "suites": [
                "testEnvironment"
            ],
            "updatePoint": {
                "line": 775,
                "column": 68
            },
            "line": 775,
            "code": "  it('resolves to an environment and prefers jest-environment-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: 'jsdom',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('node_modules/jest-environment-jsdom');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves to node environment by default",
            "suites": [
                "testEnvironment"
            ],
            "updatePoint": {
                "line": 787,
                "column": 45
            },
            "line": 787,
            "code": "  it('resolves to node environment by default', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toEqual(\n      require.resolve('jest-environment-node'),\n    );\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws on invalid environment names",
            "suites": [
                "testEnvironment"
            ],
            "updatePoint": {
                "line": 800,
                "column": 41
            },
            "line": 800,
            "code": "  it('throws on invalid environment names', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testEnvironment: 'phantom',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "works with rootDir",
            "suites": [
                "testEnvironment"
            ],
            "updatePoint": {
                "line": 812,
                "column": 24
            },
            "line": 812,
            "code": "  it('works with rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: '<rootDir>/testEnvironment.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('/root/testEnvironment.js');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "correctly identifies and uses babel-jest",
            "suites": [
                "babel-jest"
            ],
            "updatePoint": {
                "line": 837,
                "column": 46
            },
            "line": 837,
            "code": "  it('correctly identifies and uses babel-jest', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(DEFAULT_JS_PATTERN);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "uses babel-jest if babel-jest is explicitly specified in a custom transform options",
            "suites": [
                "babel-jest"
            ],
            "updatePoint": {
                "line": 849,
                "column": 89
            },
            "line": 849,
            "code": "  it('uses babel-jest if babel-jest is explicitly specified in a custom transform options', async () => {\n    const customJSPattern = '\\\\.js$';\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        transform: {\n          [customJSPattern]: 'babel-jest',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(customJSPattern);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "testRegex empty string is mapped to empty array",
            "suites": [
                "testRegex"
            ],
            "updatePoint": {
                "line": 867,
                "column": 53
            },
            "line": 867,
            "code": "  it('testRegex empty string is mapped to empty array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "testRegex string is mapped to an array",
            "suites": [
                "testRegex"
            ],
            "updatePoint": {
                "line": 878,
                "column": 44
            },
            "line": 878,
            "code": "  it('testRegex string is mapped to an array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "testRegex array is preserved",
            "suites": [
                "testRegex"
            ],
            "updatePoint": {
                "line": 889,
                "column": 34
            },
            "line": 889,
            "code": "  it('testRegex array is preserved', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: ['.*', 'foo\\\\.bar'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*', 'foo\\\\.bar']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "testMatch default not applied if testRegex is set",
            "suites": [
                "testMatch"
            ],
            "updatePoint": {
                "line": 903,
                "column": 55
            },
            "line": 903,
            "code": "  it('testMatch default not applied if testRegex is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toHaveLength(0);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "testRegex default not applied if testMatch is set",
            "suites": [
                "testMatch"
            ],
            "updatePoint": {
                "line": 915,
                "column": 55
            },
            "line": 915,
            "code": "  it('testRegex default not applied if testMatch is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws if testRegex and testMatch are both specified",
            "suites": [
                "testMatch"
            ],
            "updatePoint": {
                "line": 927,
                "column": 58
            },
            "line": 927,
            "code": "  it('throws if testRegex and testMatch are both specified', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testMatch: ['**/*.js'],\n          testRegex: '.*',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes testMatch",
            "suites": [
                "testMatch"
            ],
            "updatePoint": {
                "line": 940,
                "column": 26
            },
            "line": 940,
            "code": "  it('normalizes testMatch', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['<rootDir>/**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toEqual(['/root/**/*.js']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to node_modules",
            "suites": [
                "moduleDirectories"
            ],
            "updatePoint": {
                "line": 954,
                "column": 30
            },
            "line": 954,
            "code": "  it('defaults to node_modules', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleDirectories).toEqual(['node_modules']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes moduleDirectories",
            "suites": [
                "moduleDirectories"
            ],
            "updatePoint": {
                "line": 960,
                "column": 34
            },
            "line": 960,
            "code": "  it('normalizes moduleDirectories', async () => {\n    const {options} = await normalize(\n      {\n        moduleDirectories: ['<rootDir>/src', '<rootDir>/node_modules'],\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleDirectories).toEqual([\n      '/root/src',\n      '/root/node_modules',\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws when preset not found",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1050,
                "column": 36
            },
            "line": 1050,
            "code": "  test('throws when preset not found', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'doesnt-exist',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws when module was found but no \"jest-preset.js\" or \"jest-preset.json\" files",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1062,
                "column": 88
            },
            "line": 1062,
            "code": "  test('throws when module was found but no \"jest-preset.js\" or \"jest-preset.json\" files', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'exist-but-no-jest-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws when a dependency is missing in the preset",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1074,
                "column": 57
            },
            "line": 1074,
            "code": "  test('throws when a dependency is missing in the preset', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => {\n        require('library-that-is-not-installed');\n        return {\n          transform: {} as Config.Argv,\n        };\n      },\n      {virtual: true},\n    );\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(/Cannot find module 'library-that-is-not-installed'/);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws when preset is invalid",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1097,
                "column": 37
            },
            "line": 1097,
            "code": "  test('throws when preset is invalid', async () => {\n    jest.doMock('/node_modules/react-native/jest-preset.json', () =>\n      jest.requireActual('./jest-preset.json'),\n    );\n\n    const errorMessage = semver.satisfies(process.versions.node, '<19.0.0')\n      ? /Unexpected token } in JSON at position (104|110)[\\s\\S]* at /\n      : 'SyntaxError: Expected double-quoted property name in JSON at position 104';\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws when preset evaluation throws type error",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1117,
                "column": 55
            },
            "line": 1117,
            "code": "  test('throws when preset evaluation throws type error', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => ({\n        // @ts-expect-error: Testing runtime error\n        transform: {}.nonExistingProp.call(),\n      }),\n      {virtual: true},\n    );\n\n    const errorMessage = semver.satisfies(process.versions.node, '<16.9.1')\n      ? /TypeError: Cannot read property 'call' of undefined[\\s\\S]* at /\n      : \"TypeError: Cannot read properties of undefined (reading 'call')\";\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "works with \"react-native\"",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1142,
                "column": 33
            },
            "line": 1142,
            "code": "  test('works with \"react-native\"', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "works with cjs preset",
            "suites": [
                "preset"
            ],
            "line": 1154,
            "code": "  test.each(['react-native-js-preset', 'cjs-preset'])(\n    'works with cjs preset',\n    async preset => {\n      await expect(\n        normalize(\n          {\n            preset,\n            rootDir: '/root/path/foo',\n          },\n          {} as Config.Argv,\n        ),\n      ).resolves.not.toThrow();\n    },\n  );",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "works with esm preset",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1169,
                "column": 29
            },
            "line": 1169,
            "code": "  test('works with esm preset', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'mjs-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "searches for .json, .js, .cjs, .mjs preset files",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1181,
                "column": 56
            },
            "line": 1181,
            "code": "  test('searches for .json, .js, .cjs, .mjs preset files', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n\n    await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    const options = jest.mocked(Resolver.findNodeModule).mock.calls[0][1];\n    expect(options.extensions).toEqual(['.json', '.js', '.cjs', '.mjs']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "merges with options",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1197,
                "column": 27
            },
            "line": 1197,
            "code": "  test('merges with options', async () => {\n    const {options} = await normalize(\n      {\n        moduleNameMapper: {a: 'a'},\n        modulePathIgnorePatterns: ['a'],\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        setupFiles: ['a'],\n        setupFilesAfterEnv: ['a'],\n        transform: {a: 'a'},\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['a', 'a'],\n      ['b', 'b'],\n    ]);\n    expect(options.modulePathIgnorePatterns).toEqual(['b', 'a']);\n    expect(options.setupFiles.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.setupFilesAfterEnv.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.transform).toEqual([\n      ['a', '/node_modules/a', {}],\n      ['b', '/node_modules/b', {}],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "merges with options and moduleNameMapper preset is overridden by options",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1230,
                "column": 80
            },
            "line": 1230,
            "code": "  test('merges with options and moduleNameMapper preset is overridden by options', async () => {\n    // Object initializer not used for properties as a workaround for\n    //  sort-keys eslint rule while specifying properties in\n    //  non-alphabetical order for a better test\n    const moduleNameMapper = {} as Record<string, string>;\n    moduleNameMapper.e = 'ee';\n    moduleNameMapper.b = 'bb';\n    moduleNameMapper.c = 'cc';\n    moduleNameMapper.a = 'aa';\n    const {options} = await normalize(\n      {\n        moduleNameMapper,\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['e', 'ee'],\n      ['b', 'bb'],\n      ['c', 'cc'],\n      ['a', 'aa'],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "merges with options and transform preset is overridden by options",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1256,
                "column": 73
            },
            "line": 1256,
            "code": "  test('merges with options and transform preset is overridden by options', async () => {\n    /* eslint-disable sort-keys */\n    const transform = {\n      e: 'ee',\n      b: 'bb',\n      c: 'cc',\n      a: 'aa',\n    };\n    /* eslint-enable */\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        transform,\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      ['e', '/node_modules/ee', {}],\n      ['b', '/node_modules/bb', {}],\n      ['c', '/node_modules/cc', {}],\n      ['a', '/node_modules/aa', {}],\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "extracts setupFilesAfterEnv from preset",
            "suites": [
                "preset"
            ],
            "updatePoint": {
                "line": 1282,
                "column": 47
            },
            "line": 1282,
            "code": "  test('extracts setupFilesAfterEnv from preset', async () => {\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual(['/node_modules/b']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should merge the globals preset correctly",
            "suites": [
                "preset with globals"
            ],
            "updatePoint": {
                "line": 1325,
                "column": 49
            },
            "line": 1325,
            "code": "  test('should merge the globals preset correctly', async () => {\n    const {options} = await normalize(\n      {\n        globals: {\n          __DEV__: true,\n          config: {\n            sideBySide: 'This should also live another day',\n          },\n          myString: 'hello sunshine',\n          textValue: 'This is just text',\n        },\n        preset: 'global-foo',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.globals).toEqual({\n      __DEV__: true,\n      config: {\n        hereToStay: 'This should stay here',\n        sideBySide: 'This should also live another day',\n      },\n      myString: 'hello sunshine',\n      textValue: 'This is just text',\n    });\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "preset without %s",
            "suites": [
                "preset with globals"
            ],
            "line": 1354,
            "code": "describe.each(['setupFiles', 'setupFilesAfterEnv'] as const)(\n  'preset without %s',\n  configKey => {\n    let Resolver;\n    beforeEach(() => {\n      Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n        .default;\n      Resolver.findNodeModule = jest.fn(\n        name => `${path.sep}node_modules${path.sep}${name}`,\n      );\n    });\n\n    beforeAll(() => {\n      jest.doMock(\n        '/node_modules/react-foo/jest-preset',\n        () => ({\n          moduleNameMapper: {b: 'b'},\n          modulePathIgnorePatterns: ['b'],\n        }),\n        {virtual: true},\n      );\n    });\n\n    afterAll(() => {\n      jest.dontMock('/node_modules/react-foo/jest-preset');\n    });\n\n    it(`should normalize ${configKey} correctly`, async () => {\n      const {options} = await normalize(\n        {\n          [configKey]: ['a'],\n          preset: 'react-foo',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      );\n\n      expect(options).toEqual(\n        expect.objectContaining({[configKey]: ['/node_modules/a']}),\n      );\n    });\n  },\n);",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should normalize  correctly",
            "suites": [
                "preset with globals"
            ],
            "updatePoint": {
                "line": 1381,
                "column": 47
            },
            "line": 1381,
            "code": "    it(`should normalize ${configKey} correctly`, async () => {\n      const {options} = await normalize(\n        {\n          [configKey]: ['a'],\n          preset: 'react-foo',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      );\n\n      expect(options).toEqual(\n        expect.objectContaining({[configKey]: ['/node_modules/a']}),\n      );\n    });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes 'reporters' option defined in preset",
            "suites": [
                "preset with 'reporters' option"
            ],
            "updatePoint": {
                "line": 1422,
                "column": 55
            },
            "line": 1422,
            "code": "  test(\"normalizes 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['default', {}]]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "overrides 'reporters' option defined in preset",
            "suites": [
                "preset with 'reporters' option"
            ],
            "updatePoint": {
                "line": 1434,
                "column": 54
            },
            "line": 1434,
            "code": "  test(\"overrides 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        reporters: ['summary'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['summary', {}]]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to `jest-runner`",
            "suites": [
                "runner"
            ],
            "updatePoint": {
                "line": 1464,
                "column": 31
            },
            "line": 1464,
            "code": "  it('defaults to `jest-runner`', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.runner).toBe(require.resolve('jest-runner'));\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves to runners that do not have the prefix",
            "suites": [
                "runner"
            ],
            "updatePoint": {
                "line": 1470,
                "column": 53
            },
            "line": 1470,
            "code": "  it('resolves to runners that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'my-runner-foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/my-runner-foo');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves to runners and prefers jest-runner-`name`",
            "suites": [
                "runner"
            ],
            "updatePoint": {
                "line": 1482,
                "column": 56
            },
            "line": 1482,
            "code": "  it('resolves to runners and prefers jest-runner-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'eslint',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/jest-runner-eslint');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throw error when a runner is not found",
            "suites": [
                "runner"
            ],
            "updatePoint": {
                "line": 1494,
                "column": 44
            },
            "line": 1494,
            "code": "  it('throw error when a runner is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          runner: 'missing-runner',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to undefined",
            "suites": [
                "watchPlugins"
            ],
            "updatePoint": {
                "line": 1526,
                "column": 27
            },
            "line": 1526,
            "code": "  it('defaults to undefined', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.watchPlugins).toBeUndefined();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves to watch plugins and prefers jest-watch-`name`",
            "suites": [
                "watchPlugins"
            ],
            "updatePoint": {
                "line": 1532,
                "column": 61
            },
            "line": 1532,
            "code": "  it('resolves to watch plugins and prefers jest-watch-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['typeahead'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "resolves watch plugins that do not have the prefix",
            "suites": [
                "watchPlugins"
            ],
            "updatePoint": {
                "line": 1546,
                "column": 56
            },
            "line": 1546,
            "code": "  it('resolves watch plugins that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['my-watch-plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/my-watch-plugin'},\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "normalizes multiple watchPlugins",
            "suites": [
                "watchPlugins"
            ],
            "updatePoint": {
                "line": 1560,
                "column": 38
            },
            "line": 1560,
            "code": "  it('normalizes multiple watchPlugins', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['jest-watch-typeahead', '<rootDir>/path/to/plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n      {config: {} as Config.Argv, path: '/root/path/to/plugin'},\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throw error when a watch plugin is not found",
            "suites": [
                "watchPlugins"
            ],
            "updatePoint": {
                "line": 1575,
                "column": 50
            },
            "line": 1575,
            "code": "  it('throw error when a watch plugin is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          watchPlugins: ['missing-plugin'],\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to empty",
            "suites": [
                "testPathPattern"
            ],
            "updatePoint": {
                "line": 1600,
                "column": 23
            },
            "line": 1600,
            "code": "  it('defaults to empty', async () => {\n    const {options} = await normalize(initialOptions, {} as Config.Argv);\n\n    expect(options.testPathPattern).toBe('');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "uses  if set",
            "suites": [
                "testPathPattern"
            ],
            "updatePoint": {
                "line": 1612,
                "column": 33
            },
            "line": 1612,
            "code": "      it(`uses ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPattern).toBe('a/b');\n      });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "ignores invalid regular expressions and logs a warning",
            "suites": [
                "testPathPattern"
            ],
            "updatePoint": {
                "line": 1619,
                "column": 64
            },
            "line": 1619,
            "code": "      it('ignores invalid regular expressions and logs a warning', async () => {\n        const argv = {[opt.property]: ['a(']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPattern).toBe('');\n        expect(jest.mocked(console.log).mock.calls[0][0]).toMatchSnapshot();\n      });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "joins multiple  if set",
            "suites": [
                "testPathPattern"
            ],
            "updatePoint": {
                "line": 1627,
                "column": 43
            },
            "line": 1627,
            "code": "      it(`joins multiple ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b', 'c/d']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPattern).toBe('a/b|c/d');\n      });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "coerces all patterns to strings",
            "suites": [
                "testPathPattern"
            ],
            "updatePoint": {
                "line": 1634,
                "column": 41
            },
            "line": 1634,
            "code": "      it('coerces all patterns to strings', async () => {\n        const argv = {[opt.property]: [1]} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPattern).toBe('1');\n      });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should not escape the pattern",
            "suites": [
                "testPathPattern",
                "posix"
            ],
            "updatePoint": {
                "line": 1642,
                "column": 41
            },
            "line": 1642,
            "code": "        it('should not escape the pattern', async () => {\n          const argv = {\n            [opt.property]: ['a\\\\/b', 'a/b', 'a\\\\b', 'a\\\\\\\\b'],\n          } as Config.Argv;\n          const {options} = await normalize(initialOptions, argv);\n\n          expect(options.testPathPattern).toBe('a\\\\/b|a/b|a\\\\b|a\\\\\\\\b');\n        });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "preserves any use of \"\\\"",
            "suites": [
                "testPathPattern",
                "win32"
            ],
            "updatePoint": {
                "line": 1667,
                "column": 37
            },
            "line": 1667,
            "code": "        it('preserves any use of \"\\\\\"', async () => {\n          const argv = {[opt.property]: ['a\\\\b', 'c\\\\\\\\d']} as Config.Argv;\n          const {options} = await (\n            require('../normalize') as typeof import('../normalize')\n          ).default(initialOptions, argv);\n\n          expect(options.testPathPattern).toBe('a\\\\b|c\\\\\\\\d');\n        });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "replaces POSIX path separators",
            "suites": [
                "testPathPattern",
                "win32"
            ],
            "updatePoint": {
                "line": 1676,
                "column": 42
            },
            "line": 1676,
            "code": "        it('replaces POSIX path separators', async () => {\n          const argv = {[opt.property]: ['a/b']} as Config.Argv;\n          const {options} = await (\n            require('../normalize') as typeof import('../normalize')\n          ).default(initialOptions, argv);\n\n          expect(options.testPathPattern).toBe('a\\\\\\\\b');\n        });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "replaces POSIX paths in multiple args",
            "suites": [
                "testPathPattern",
                "win32"
            ],
            "updatePoint": {
                "line": 1685,
                "column": 49
            },
            "line": 1685,
            "code": "        it('replaces POSIX paths in multiple args', async () => {\n          const argv = {[opt.property]: ['a/b', 'c/d']} as Config.Argv;\n          const {options} = await (\n            require('../normalize') as typeof import('../normalize')\n          ).default(initialOptions, argv);\n\n          expect(options.testPathPattern).toBe('a\\\\\\\\b|c\\\\\\\\d');\n        });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "joins multiple --testPathPatterns and <regexForTestFiles>",
            "suites": [
                "testPathPattern",
                "win32"
            ],
            "updatePoint": {
                "line": 1697,
                "column": 63
            },
            "line": 1697,
            "code": "  it('joins multiple --testPathPatterns and <regexForTestFiles>', async () => {\n    const {options} = await normalize(initialOptions, {\n      _: ['a', 'b'],\n      testPathPattern: ['c', 'd'],\n    } as Config.Argv);\n    expect(options.testPathPattern).toBe('a|b|c|d');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "gives precedence to --all",
            "suites": [
                "testPathPattern",
                "win32"
            ],
            "updatePoint": {
                "line": 1705,
                "column": 31
            },
            "line": 1705,
            "code": "  it('gives precedence to --all', async () => {\n    const {options} = await normalize(initialOptions, {\n      all: true,\n      onlyChanged: true,\n    } as Config.Argv);\n\n    expect(options.onlyChanged).toBe(false);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "defaults to something useful",
            "suites": [
                "moduleFileExtensions"
            ],
            "updatePoint": {
                "line": 1716,
                "column": 34
            },
            "line": 1716,
            "code": "  it('defaults to something useful', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleFileExtensions).toEqual([\n      'js',\n      'mjs',\n      'cjs',\n      'jsx',\n      'ts',\n      'tsx',\n      'json',\n      'node',\n    ]);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws if missing `js` but using jest-runner",
            "suites": [
                "moduleFileExtensions"
            ],
            "line": 1731,
            "code": "  it.each([undefined, 'jest-runner'] as const)(\n    'throws if missing `js` but using jest-runner',\n    async runner => {\n      await expect(\n        normalize(\n          {\n            moduleFileExtensions: ['json', 'jsx'],\n            rootDir: '/root/',\n            runner,\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrow(\"moduleFileExtensions must include 'js'\");\n    },\n  );",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "does not throw if missing `js` with a custom runner",
            "suites": [
                "moduleFileExtensions"
            ],
            "updatePoint": {
                "line": 1747,
                "column": 57
            },
            "line": 1747,
            "code": "  it('does not throw if missing `js` with a custom runner', async () => {\n    await expect(\n      normalize(\n        {\n          moduleFileExtensions: ['json', 'jsx'],\n          rootDir: '/root/',\n          runner: './', // does not need to be a valid runner for this validation\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "is set to process.cwd",
            "suites": [
                "cwd"
            ],
            "updatePoint": {
                "line": 1762,
                "column": 27
            },
            "line": 1762,
            "code": "  it('is set to process.cwd', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.cwd).toBe(process.cwd());\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "is not lost if the config has its own cwd property",
            "suites": [
                "cwd"
            ],
            "updatePoint": {
                "line": 1767,
                "column": 56
            },
            "line": 1767,
            "code": "  it('is not lost if the config has its own cwd property', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        cwd: '/tmp/config-sets-cwd-itself',\n        rootDir: '/root/',\n      } as Config.InitialOptions,\n      {} as Config.Argv,\n    );\n    expect(options.cwd).toBe(process.cwd());\n    expect(console.warn).toHaveBeenCalled();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be accepted by normalize",
            "suites": [
                "Defaults"
            ],
            "updatePoint": {
                "line": 1782,
                "column": 37
            },
            "line": 1782,
            "code": "  it('should be accepted by normalize', async () => {\n    await normalize({...Defaults, rootDir: '/root'}, {} as Config.Argv);\n\n    expect(console.warn).not.toHaveBeenCalled();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw an error when displayName is $description",
            "suites": [
                "displayName"
            ],
            "line": 1790,
            "code": "  test.each<{displayName: Config.DisplayName; description: string}>`\n    displayName             | description\n    ${{}}                   | ${'is an empty object'}\n    ${{name: 'hello'}}      | ${'missing color'}\n    ${{color: 'green'}}     | ${'missing name'}\n    ${{color: 2, name: []}} | ${'using invalid values'}\n  `(\n    'should throw an error when displayName is $description',\n    async ({displayName}) => {\n      await expect(\n        normalize(\n          {\n            displayName,\n            rootDir: '/root/',\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    },\n  );",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "generates a default color for the runner %s",
            "suites": [
                "displayName"
            ],
            "line": 1811,
            "code": "  it.each([\n    undefined,\n    'jest-runner',\n    'jest-runner-eslint',\n    'jest-runner-tslint',\n    'jest-runner-tsc',\n  ])('generates a default color for the runner %s', async runner => {\n    virtualModuleRegexes.push(/jest-runner-.+/);\n    const {\n      options: {displayName},\n    } = await normalize(\n      {\n        displayName: 'project',\n        rootDir: '/root/',\n        runner,\n      },\n      {} as Config.Argv,\n    );\n    expect(displayName!.name).toBe('project');\n    expect(displayName!.color).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should return timeout value if defined",
            "suites": [
                "testTimeout"
            ],
            "updatePoint": {
                "line": 1835,
                "column": 44
            },
            "line": 1835,
            "code": "  it('should return timeout value if defined', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {rootDir: '/root/', testTimeout: 1000},\n      {} as Config.Argv,\n    );\n\n    expect(options.testTimeout).toBe(1000);\n    expect(console.warn).not.toHaveBeenCalled();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw an error if timeout is a negative number",
            "suites": [
                "testTimeout"
            ],
            "updatePoint": {
                "line": 1846,
                "column": 59
            },
            "line": 1846,
            "code": "  it('should throw an error if timeout is a negative number', async () => {\n    await expect(\n      normalize({rootDir: '/root/', testTimeout: -1}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should pass valid config through",
            "suites": [
                "extensionsToTreatAsEsm"
            ],
            "updatePoint": {
                "line": 1868,
                "column": 38
            },
            "line": 1868,
            "code": "  it('should pass valid config through', async () => {\n    const {options} = await normalize(\n      {extensionsToTreatAsEsm: ['.ts'], rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.extensionsToTreatAsEsm).toEqual(['.ts']);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should enforce leading dots",
            "suites": [
                "extensionsToTreatAsEsm"
            ],
            "updatePoint": {
                "line": 1877,
                "column": 33
            },
            "line": 1877,
            "code": "  it('should enforce leading dots', async () => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: ['ts'], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws on %s",
            "suites": [
                "extensionsToTreatAsEsm"
            ],
            "line": 1886,
            "code": "  it.each(['.js', '.mjs', '.cjs'])('throws on %s', async ext => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: [ext], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw if watchman is not disabled",
            "suites": [
                "haste.enableSymlinks"
            ],
            "updatePoint": {
                "line": 1897,
                "column": 46
            },
            "line": 1897,
            "code": "  it('should throw if watchman is not disabled', async () => {\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: true},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    const {options} = await normalize(\n      {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: false},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.enableSymlinks).toBe(true);\n    expect(options.watchman).toBe(false);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should pass option through",
            "suites": [
                "haste.forceNodeFilesystemAPI"
            ],
            "updatePoint": {
                "line": 1923,
                "column": 32
            },
            "line": 1923,
            "code": "  it('should pass option through', async () => {\n    const {options} = await normalize(\n      {haste: {forceNodeFilesystemAPI: true}, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.forceNodeFilesystemAPI).toBe(true);\n    expect(console.warn).not.toHaveBeenCalled();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be all if updateSnapshot is true",
            "suites": [
                "updateSnapshot"
            ],
            "updatePoint": {
                "line": 1935,
                "column": 45
            },
            "line": 1935,
            "code": "  it('should be all if updateSnapshot is true', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      updateSnapshot: true,\n    } as Config.Argv);\n    expect(options.updateSnapshot).toBe('all');\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be new if updateSnapshot is falsy",
            "suites": [
                "updateSnapshot"
            ],
            "updatePoint": {
                "line": 1941,
                "column": 46
            },
            "line": 1941,
            "code": "  it('should be new if updateSnapshot is falsy', async () => {\n    {\n      const {options} = await normalize(\n        {ci: false, rootDir: '/root/'},\n        {} as Config.Argv,\n      );\n      expect(options.updateSnapshot).toBe('new');\n    }\n    {\n      const {options} = await normalize({ci: false, rootDir: '/root/'}, {\n        updateSnapshot: false,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('new');\n    }\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be none if updateSnapshot is falsy and ci mode is true",
            "suites": [
                "updateSnapshot"
            ],
            "updatePoint": {
                "line": 1956,
                "column": 67
            },
            "line": 1956,
            "code": "  it('should be none if updateSnapshot is falsy and ci mode is true', async () => {\n    const defaultCiConfig = Defaults.ci;\n    {\n      Defaults.ci = false;\n      const {options} = await normalize({rootDir: '/root/'}, {\n        ci: true,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    {\n      Defaults.ci = true;\n      const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    Defaults.ci = defaultCiConfig;\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be object if defined",
            "suites": [
                "shards"
            ],
            "updatePoint": {
                "line": 1975,
                "column": 33
            },
            "line": 1975,
            "code": "  it('should be object if defined', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      shard: '1/2',\n    } as Config.Argv);\n\n    expect(options.shard).toEqual({shardCount: 2, shardIndex: 1});\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'browser' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 1989,
                "column": 39
            },
            "line": 1989,
            "code": "  test(\"when 'browser' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        browser: true,\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'collectCoverageOnlyFrom' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2002,
                "column": 55
            },
            "line": 2002,
            "code": "  test(\"when 'collectCoverageOnlyFrom' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        collectCoverageOnlyFrom: {\n          '<rootDir>/this-directory-is-covered/Covered.js': true,\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'extraGlobals' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2017,
                "column": 44
            },
            "line": 2017,
            "code": "  test(\"when 'extraGlobals' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        extraGlobals: ['Math'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'moduleLoader' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2030,
                "column": 44
            },
            "line": 2030,
            "code": "  test(\"when 'moduleLoader' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        moduleLoader: '<rootDir>/runtime.js',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'preprocessorIgnorePatterns' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2043,
                "column": 58
            },
            "line": 2043,
            "code": "  test(\"when 'preprocessorIgnorePatterns' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        preprocessorIgnorePatterns: ['/node_modules/'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'scriptPreprocessor' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2056,
                "column": 50
            },
            "line": 2056,
            "code": "  test(\"when 'scriptPreprocessor' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        scriptPreprocessor: 'preprocessor.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'setupTestFrameworkScriptFile' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2069,
                "column": 60
            },
            "line": 2069,
            "code": "  test(\"when 'setupTestFrameworkScriptFile' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        setupTestFrameworkScriptFile: 'setup.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'testPathDirs' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2082,
                "column": 44
            },
            "line": 2082,
            "code": "  test(\"when 'testPathDirs' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testPathDirs: ['<rootDir>'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'testURL' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2095,
                "column": 39
            },
            "line": 2095,
            "code": "  test(\"when 'testURL' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testURL: 'https://jestjs.io',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "when 'timers' option is passed",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2108,
                "column": 38
            },
            "line": 2108,
            "code": "  test(\"when 'timers' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        timers: 'real',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "parses workerIdleMemoryLimit",
            "suites": [
                "logs a deprecation warning"
            ],
            "updatePoint": {
                "line": 2122,
                "column": 32
            },
            "line": 2122,
            "code": "it('parses workerIdleMemoryLimit', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/',\n      workerIdleMemoryLimit: '45MiB',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.workerIdleMemoryLimit).toBe(47185920);\n});",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "generates seed when not specified",
            "suites": [
                "seed"
            ],
            "updatePoint": {
                "line": 2135,
                "column": 39
            },
            "line": 2135,
            "code": "  it('generates seed when not specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.seed).toEqual(expect.any(Number));\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "uses seed specified",
            "suites": [
                "seed"
            ],
            "updatePoint": {
                "line": 2140,
                "column": 25
            },
            "line": 2140,
            "code": "  it('uses seed specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      seed: 4321,\n    } as Config.Argv);\n    expect(options.seed).toBe(4321);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "throws if seed is too large or too small",
            "suites": [
                "seed"
            ],
            "updatePoint": {
                "line": 2147,
                "column": 46
            },
            "line": 2147,
            "code": "  it('throws if seed is too large or too small', async () => {\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: 2 ** 33,\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - is 8589934592',\n    );\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: -(2 ** 33),\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - is -8589934592',\n    );\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "showSeed is set when argv flag is set",
            "suites": [
                "showSeed"
            ],
            "updatePoint": {
                "line": 2166,
                "column": 45
            },
            "line": 2166,
            "code": "  test('showSeed is set when argv flag is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      showSeed: true,\n    } as Config.Argv);\n    expect(options.showSeed).toBe(true);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "showSeed is set when the config is set",
            "suites": [
                "showSeed"
            ],
            "updatePoint": {
                "line": 2173,
                "column": 46
            },
            "line": 2173,
            "code": "  test('showSeed is set when the config is set', async () => {\n    const {options} = await normalize(\n      {rootDir: '/root/', showSeed: true},\n      {} as Config.Argv,\n    );\n    expect(options.showSeed).toBe(true);\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "showSeed is false when neither is set",
            "suites": [
                "showSeed"
            ],
            "updatePoint": {
                "line": 2181,
                "column": 45
            },
            "line": 2181,
            "code": "  test('showSeed is false when neither is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.showSeed).toBeFalsy();\n  });",
            "file": "normalize.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard has wrong format",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 49
            },
            "line": 9,
            "code": "it('raises an exception if shard has wrong format', () => {\n  expect(() => parseShardPair('mumble')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard pair has to many items",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 55
            },
            "line": 15,
            "code": "it('raises an exception if shard pair has to many items', () => {\n  expect(() => parseShardPair('1/2/3')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard has floating points",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 52
            },
            "line": 21,
            "code": "it('raises an exception if shard has floating points', () => {\n  expect(() => parseShardPair('1.0/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if first item in shard pair is no number",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 64
            },
            "line": 27,
            "code": "it('raises an exception if first item in shard pair is no number', () => {\n  expect(() => parseShardPair('a/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if second item in shard pair is no number",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 65
            },
            "line": 33,
            "code": "it('raises an exception if second item in shard pair is no number', () => {\n  expect(() => parseShardPair('1/a')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard contains negative number",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 57
            },
            "line": 39,
            "code": "it('raises an exception if shard contains negative number', () => {\n  expect(() => parseShardPair('1/-1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard is zero-indexed",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 48
            },
            "line": 45,
            "code": "it('raises an exception if shard is zero-indexed', () => {\n  expect(() => parseShardPair('0/1')).toThrow(\n    'requires 1-based values, received 0',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "raises an exception if shard index is larger than shard count",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 65
            },
            "line": 51,
            "code": "it('raises an exception if shard index is larger than shard count', () => {\n  expect(() => parseShardPair('2/1')).toThrow(\n    'requires <n> to be lower or equal than <m>',\n  );\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "allows valid shard format",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 29
            },
            "line": 57,
            "code": "it('allows valid shard format', () => {\n  expect(() => parseShardPair('1/2')).not.toThrow();\n});",
            "file": "parseShardPair.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "readConfig() throws when an object is passed without a file path",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 70
            },
            "line": 10,
            "code": "test('readConfig() throws when an object is passed without a file path', async () => {\n  await expect(\n    readConfig(\n      {$0: '', _: []},\n      {} /* packageRootOrConfig */,\n      false /* skipArgvConfigOption */,\n      null /* parentConfigPath */,\n    ),\n  ).rejects.toThrow(\n    'Jest: Cannot use configuration as an object without a file path',\n  );\n});",
            "file": "readConfig.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "readConfigs() throws when called without project paths",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 60
            },
            "line": 17,
            "code": "test('readConfigs() throws when called without project paths', async () => {\n  await expect(\n    // @ts-expect-error\n    readConfigs(null /* argv */, [] /* projectPaths */),\n  ).rejects.toThrow('jest: No configuration found for any project.');\n});",
            "file": "readConfigs.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should be able to use serialized jest config",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 52
            },
            "line": 11,
            "code": "  test('should be able to use serialized jest config', async () => {\n    const inputConfig = {jestConfig: 'serialized'};\n    const {config, configPath} = await readInitialOptions(\n      JSON.stringify(inputConfig),\n    );\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });",
            "file": "readInitialOptions.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should allow deserialized options",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 41
            },
            "line": 20,
            "code": "  test('should allow deserialized options', async () => {\n    const inputConfig = {jestConfig: 'deserialized'};\n    const {config, configPath} = await readInitialOptions(undefined, {\n      packageRootOrConfig: inputConfig as Config.InitialOptions,\n      parentConfigDirname: process.cwd(),\n    });\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });",
            "file": "readInitialOptions.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Resolve config path %s",
            "suites": [],
            "line": 22,
            "code": "describe.each(JEST_CONFIG_EXT_ORDER.slice(0))(\n  'Resolve config path %s',\n  extension => {\n    test(`file path with \"${extension}\"`, () => {\n      const relativeConfigPath = `a/b/c/my_config${extension}`;\n      const absoluteConfigPath = path.resolve(DIR, relativeConfigPath);\n\n      writeFiles(DIR, {[relativeConfigPath]: ''});\n\n      // absolute\n      expect(resolveConfigPath(absoluteConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('/does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n\n      // relative\n      expect(resolveConfigPath(relativeConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n    });\n\n    test(`directory path with \"${extension}\"`, () => {\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const relativeJestConfigPath = `a/b/c/jest.config${extension}`;\n      const absoluteJestConfigPath = path.resolve(DIR, relativeJestConfigPath);\n\n      // no configs yet. should throw\n      writeFiles(DIR, {[`a/b/c/some_random_file${extension}`]: ''});\n\n      expect(() =>\n        // absolute\n        resolveConfigPath(path.dirname(absoluteJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      expect(() =>\n        // relative\n        resolveConfigPath(path.dirname(relativeJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      writeFiles(DIR, {[relativePackageJsonPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // jest.config.js takes precedence\n      writeFiles(DIR, {[relativeJestConfigPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // jest.config.js and package.json with 'jest' cannot be used together\n      writeFiles(DIR, {[relativePackageJsonPath]: JSON.stringify({jest: {}})});\n\n      // absolute\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      // relative\n      expect(() =>\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      expect(() => {\n        resolveConfigPath(\n          path.join(path.dirname(relativePackageJsonPath), 'j/x/b/m/'),\n          DIR,\n        );\n      }).toThrow(NO_ROOT_DIR_ERROR_PATTERN);\n    });\n  },\n);",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "file path with \"\"",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 39
            },
            "line": 25,
            "code": "    test(`file path with \"${extension}\"`, () => {\n      const relativeConfigPath = `a/b/c/my_config${extension}`;\n      const absoluteConfigPath = path.resolve(DIR, relativeConfigPath);\n\n      writeFiles(DIR, {[relativeConfigPath]: ''});\n\n      // absolute\n      expect(resolveConfigPath(absoluteConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('/does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n\n      // relative\n      expect(resolveConfigPath(relativeConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n    });",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "directory path with \"\"",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 44
            },
            "line": 48,
            "code": "    test(`directory path with \"${extension}\"`, () => {\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const relativeJestConfigPath = `a/b/c/jest.config${extension}`;\n      const absoluteJestConfigPath = path.resolve(DIR, relativeJestConfigPath);\n\n      // no configs yet. should throw\n      writeFiles(DIR, {[`a/b/c/some_random_file${extension}`]: ''});\n\n      expect(() =>\n        // absolute\n        resolveConfigPath(path.dirname(absoluteJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      expect(() =>\n        // relative\n        resolveConfigPath(path.dirname(relativeJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      writeFiles(DIR, {[relativePackageJsonPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // jest.config.js takes precedence\n      writeFiles(DIR, {[relativeJestConfigPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // jest.config.js and package.json with 'jest' cannot be used together\n      writeFiles(DIR, {[relativePackageJsonPath]: JSON.stringify({jest: {}})});\n\n      // absolute\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      // relative\n      expect(() =>\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      expect(() => {\n        resolveConfigPath(\n          path.join(path.dirname(relativePackageJsonPath), 'j/x/b/m/'),\n          DIR,\n        );\n      }).toThrow(NO_ROOT_DIR_ERROR_PATTERN);\n    });",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "pickPairsWithSameOrder",
            "suites": [],
            "updatePoint": {
                "line": 125,
                "column": 28
            },
            "line": 125,
            "code": "test('pickPairsWithSameOrder', () => {\n  expect(pickPairsWithSameOrder([1, 2, 3])).toStrictEqual([\n    [1, 2],\n    [1, 3],\n    [2, 3],\n  ]);\n});",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Using multiple configs shows error",
            "suites": [],
            "line": 133,
            "code": "describe.each(pickPairsWithSameOrder(JEST_CONFIG_EXT_ORDER))(\n  'Using multiple configs shows error',\n  (extension1, extension2) => {\n    test(`Using jest.config${extension1} and jest.config${extension2} shows error`, () => {\n      const relativeJestConfigPaths = [\n        `a/b/c/jest.config${extension1}`,\n        `a/b/c/jest.config${extension2}`,\n      ];\n\n      writeFiles(DIR, {\n        [relativeJestConfigPaths[0]]: '',\n        [relativeJestConfigPaths[1]]: '',\n      });\n\n      expect(() =>\n        resolveConfigPath(path.dirname(relativeJestConfigPaths[0]), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n    });\n  },\n);",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "Using jest.config and jest.config shows error",
            "suites": [],
            "updatePoint": {
                "line": 136,
                "column": 81
            },
            "line": 136,
            "code": "    test(`Using jest.config${extension1} and jest.config${extension2} shows error`, () => {\n      const relativeJestConfigPaths = [\n        `a/b/c/jest.config${extension1}`,\n        `a/b/c/jest.config${extension2}`,\n      ];\n\n      writeFiles(DIR, {\n        [relativeJestConfigPaths[0]]: '',\n        [relativeJestConfigPaths[1]]: '',\n      });\n\n      expect(() =>\n        resolveConfigPath(path.dirname(relativeJestConfigPaths[0]), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n    });",
            "file": "resolveConfigPath.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "maps special values to valid options",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 42
            },
            "line": 12,
            "code": "test('maps special values to valid options', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    coverage: true,\n    env: 'node',\n    json: true,\n    watchAll: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverage: true,\n    testEnvironment: 'node',\n    useStderr: true,\n    watch: false,\n    watchAll: true,\n  });\n});",
            "file": "setFromArgv.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "maps regular values to themselves",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 39
            },
            "line": 30,
            "code": "test('maps regular values to themselves', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  });\n});",
            "file": "setFromArgv.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "works with string objects",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 31
            },
            "line": 45,
            "code": "test('works with string objects', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    moduleNameMapper:\n      '{\"types/(.*)\": \"<rootDir>/src/types/$1\", \"types2/(.*)\": [\"<rootDir>/src/types2/$1\", \"<rootDir>/src/types3/$1\"]}',\n    testEnvironmentOptions: '{\"userAgent\": \"Agent/007\"}',\n    transform: '{\"*.js\": \"<rootDir>/transformer\"}',\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({\n    moduleNameMapper: {\n      'types/(.*)': '<rootDir>/src/types/$1',\n      'types2/(.*)': ['<rootDir>/src/types2/$1', '<rootDir>/src/types3/$1'],\n    },\n    testEnvironmentOptions: {\n      userAgent: 'Agent/007',\n    },\n    transform: {\n      '*.js': '<rootDir>/transformer',\n    },\n  });\n});",
            "file": "setFromArgv.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "explicit flags override those from --config",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 49
            },
            "line": 67,
            "code": "test('explicit flags override those from --config', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    config: '{\"watch\": false}',\n    watch: true,\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({watch: true});\n});",
            "file": "setFromArgv.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "> 1 represents bytes",
            "suites": [
                "numeric input"
            ],
            "updatePoint": {
                "line": 11,
                "column": 28
            },
            "line": 11,
            "code": "  test('> 1 represents bytes', () => {\n    expect(stringToBytes(50.8)).toBe(50);\n  });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "1.1 should be a 1",
            "suites": [
                "numeric input"
            ],
            "updatePoint": {
                "line": 15,
                "column": 25
            },
            "line": 15,
            "code": "  test('1.1 should be a 1', () => {\n    expect(stringToBytes(1.1, 54)).toBe(1);\n  });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "< 1 represents a %",
            "suites": [
                "numeric input"
            ],
            "updatePoint": {
                "line": 19,
                "column": 26
            },
            "line": 19,
            "code": "  test('< 1 represents a %', () => {\n    expect(stringToBytes(0.3, 51)).toBe(15);\n  });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw when no reference supplied",
            "suites": [
                "numeric input"
            ],
            "updatePoint": {
                "line": 23,
                "column": 47
            },
            "line": 23,
            "code": "  test('should throw when no reference supplied', () => {\n    expect(() => stringToBytes(0.3)).toThrow(\n      'For a percentage based memory limit a percentageReference must be supplied',\n    );\n  });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw on a bad input",
            "suites": [
                "numeric input"
            ],
            "updatePoint": {
                "line": 29,
                "column": 35
            },
            "line": 29,
            "code": "  test('should throw on a bad input', () => {\n    expect(() => stringToBytes(-0.3, 51)).toThrow('Unexpected numerical input');\n  });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "> 1 represents bytes",
            "suites": [
                "string input",
                "numeric passthrough"
            ],
            "updatePoint": {
                "line": 36,
                "column": 30
            },
            "line": 36,
            "code": "    test('> 1 represents bytes', () => {\n      expect(stringToBytes('50.8')).toBe(50);\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "< 1 represents a %",
            "suites": [
                "string input",
                "numeric passthrough"
            ],
            "updatePoint": {
                "line": 40,
                "column": 28
            },
            "line": 40,
            "code": "    test('< 1 represents a %', () => {\n      expect(stringToBytes('0.3', 51)).toBe(15);\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw when no reference supplied",
            "suites": [
                "string input",
                "numeric passthrough"
            ],
            "updatePoint": {
                "line": 44,
                "column": 49
            },
            "line": 44,
            "code": "    test('should throw when no reference supplied', () => {\n      expect(() => stringToBytes('0.3')).toThrow(\n        'For a percentage based memory limit a percentageReference must be supplied',\n      );\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "should throw on a bad input",
            "suites": [
                "string input",
                "numeric passthrough"
            ],
            "updatePoint": {
                "line": 50,
                "column": 37
            },
            "line": 50,
            "code": "    test('should throw on a bad input', () => {\n      expect(() => stringToBytes('-0.3', 51)).toThrow(\n        'Unexpected numerical input',\n      );\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "0% should throw an error",
            "suites": [
                "string input",
                "parsing"
            ],
            "updatePoint": {
                "line": 58,
                "column": 34
            },
            "line": 58,
            "code": "    test('0% should throw an error', () => {\n      expect(() => stringToBytes('0%', 51)).toThrow(\n        'Unexpected numerical input',\n      );\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30%",
            "suites": [
                "string input",
                "parsing"
            ],
            "updatePoint": {
                "line": 64,
                "column": 13
            },
            "line": 64,
            "code": "    test('30%', () => {\n      expect(stringToBytes('30%', 51)).toBe(15);\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "80%",
            "suites": [
                "string input",
                "parsing"
            ],
            "updatePoint": {
                "line": 68,
                "column": 13
            },
            "line": 68,
            "code": "    test('80%', () => {\n      expect(stringToBytes('80%', 51)).toBe(40);\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "100%",
            "suites": [
                "string input",
                "parsing"
            ],
            "updatePoint": {
                "line": 72,
                "column": 14
            },
            "line": 72,
            "code": "    test('100%', () => {\n      expect(stringToBytes('100%', 51)).toBe(51);\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30k",
            "suites": [
                "string input",
                "parsing",
                "k"
            ],
            "updatePoint": {
                "line": 78,
                "column": 15
            },
            "line": 78,
            "code": "      test('30k', () => {\n        expect(stringToBytes('30K')).toBe(30000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30KB",
            "suites": [
                "string input",
                "parsing",
                "k"
            ],
            "updatePoint": {
                "line": 82,
                "column": 16
            },
            "line": 82,
            "code": "      test('30KB', () => {\n        expect(stringToBytes('30kB')).toBe(30000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30KiB",
            "suites": [
                "string input",
                "parsing",
                "k"
            ],
            "updatePoint": {
                "line": 86,
                "column": 17
            },
            "line": 86,
            "code": "      test('30KiB', () => {\n        expect(stringToBytes('30kIb')).toBe(30720);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30M",
            "suites": [
                "string input",
                "parsing",
                "m"
            ],
            "updatePoint": {
                "line": 92,
                "column": 15
            },
            "line": 92,
            "code": "      test('30M', () => {\n        expect(stringToBytes('30M')).toBe(30000000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30MB",
            "suites": [
                "string input",
                "parsing",
                "m"
            ],
            "updatePoint": {
                "line": 96,
                "column": 16
            },
            "line": 96,
            "code": "      test('30MB', () => {\n        expect(stringToBytes('30MB')).toBe(30000000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30MiB",
            "suites": [
                "string input",
                "parsing",
                "m"
            ],
            "updatePoint": {
                "line": 100,
                "column": 17
            },
            "line": 100,
            "code": "      test('30MiB', () => {\n        expect(stringToBytes('30MiB')).toBe(31457280);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30G",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 106,
                "column": 15
            },
            "line": 106,
            "code": "      test('30G', () => {\n        expect(stringToBytes('30G')).toBe(30000000000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30GB",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 110,
                "column": 16
            },
            "line": 110,
            "code": "      test('30GB', () => {\n        expect(stringToBytes('30gB')).toBe(30000000000);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "30GiB",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 114,
                "column": 17
            },
            "line": 114,
            "code": "      test('30GiB', () => {\n        expect(stringToBytes('30GIB')).toBe(32212254720);\n      });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "unknown unit",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 119,
                "column": 22
            },
            "line": 119,
            "code": "    test('unknown unit', () => {\n      expect(() => stringToBytes('50XX')).toThrow('Unexpected input');\n    });",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "nesting",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 125,
                "column": 13
            },
            "line": 125,
            "code": "test('nesting', () => {\n  expect(stringToBytes(stringToBytes(stringToBytes('30%', 51)))).toBe(15);\n});",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "null",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 129,
                "column": 10
            },
            "line": 129,
            "code": "test('null', () => {\n  expect(stringToBytes(null)).toBeNull();\n});",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "undefined",
            "suites": [
                "string input",
                "parsing",
                "g"
            ],
            "updatePoint": {
                "line": 133,
                "column": 15
            },
            "line": 133,
            "code": "test('undefined', () => {\n  expect(stringToBytes(undefined)).toBeUndefined();\n});",
            "file": "stringToBytes.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "without passed args returns true",
            "suites": [
                "validate pattern function"
            ],
            "updatePoint": {
                "line": 12,
                "column": 38
            },
            "line": 12,
            "code": "  it('without passed args returns true', () => {\n    const isValid = validatePattern();\n\n    expect(isValid).toBeTruthy();\n  });",
            "file": "validatePattern.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "returns true for empty pattern",
            "suites": [
                "validate pattern function"
            ],
            "updatePoint": {
                "line": 18,
                "column": 36
            },
            "line": 18,
            "code": "  it('returns true for empty pattern', () => {\n    const isValid = validatePattern('');\n\n    expect(isValid).toBeTruthy();\n  });",
            "file": "validatePattern.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "returns true for valid pattern",
            "suites": [
                "validate pattern function"
            ],
            "updatePoint": {
                "line": 24,
                "column": 36
            },
            "line": 24,
            "code": "  it('returns true for valid pattern', () => {\n    const isValid = validatePattern('abc+');\n\n    expect(isValid).toBeTruthy();\n  });",
            "file": "validatePattern.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "returns false for invalid pattern",
            "suites": [
                "validate pattern function"
            ],
            "updatePoint": {
                "line": 30,
                "column": 39
            },
            "line": 30,
            "code": "  it('returns false for invalid pattern', () => {\n    const isValid = validatePattern('\\\\');\n\n    expect(isValid).toBeFalsy();\n  });",
            "file": "validatePattern.test.ts",
            "skipped": false,
            "dir": "packages/jest-config/src/__tests__"
        },
        {
            "name": "do not log when the assertion is truthy",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 27,
                "column": 49
            },
            "line": 27,
            "code": "    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(stdout()).toMatch('');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "do not log when the assertion is truthy and there is a message",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 33,
                "column": 72
            },
            "line": 33,
            "code": "    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(stdout()).toMatch('');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "log the assertion error when the assertion is falsy",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 39,
                "column": 61
            },
            "line": 39,
            "code": "    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch(\n        /false == true|The expression evaluated to a falsy value/,\n      );\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "log the assertion error when the assertion is falsy with another message argument",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 48,
                "column": 91
            },
            "line": 48,
            "code": "    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'ok');\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch('ok');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "count using the default counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 57,
                "column": 41
            },
            "line": 57,
            "code": "    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 3');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "count using the a labeled counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 65,
                "column": 43
            },
            "line": 65,
            "code": "    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 3');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "countReset restarts default counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 73,
                "column": 45
            },
            "line": 73,
            "code": "    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 1');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "countReset restarts custom counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 81,
                "column": 44
            },
            "line": 81,
            "code": "    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 1');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "group without label",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 92,
                "column": 29
            },
            "line": 92,
            "code": "    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\n    there');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "group with label",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 101,
                "column": 26
            },
            "line": 101,
            "code": "    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(stdout()).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there`);\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "groupEnd remove the indentation of the current group",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 113,
                "column": 62
            },
            "line": 113,
            "code": "    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "groupEnd can not remove the indentation below the starting point",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 122,
                "column": 74
            },
            "line": 122,
            "code": "    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on default timer",
            "suites": [
                "CustomConsole",
                "time"
            ],
            "updatePoint": {
                "line": 135,
                "column": 78
            },
            "line": 135,
            "code": "    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on custom timer",
            "suites": [
                "CustomConsole",
                "time"
            ],
            "updatePoint": {
                "line": 143,
                "column": 77
            },
            "line": 143,
            "code": "    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should print the deepest value",
            "suites": [
                "CustomConsole",
                "dir"
            ],
            "updatePoint": {
                "line": 153,
                "column": 40
            },
            "line": 153,
            "code": "    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(stdout()).toMatch('value');\n      expect(stdout()).not.toMatch('depth');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on default timer",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 163,
                "column": 78
            },
            "line": 163,
            "code": "    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd();\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on custom timer",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 172,
                "column": 77
            },
            "line": 172,
            "code": "    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd('custom');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "default timer with data",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 181,
                "column": 33
            },
            "line": 181,
            "code": "    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd();\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "custom timer with data",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 190,
                "column": 32
            },
            "line": 190,
            "code": "    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should be able to initialize console instance",
            "suites": [
                "CustomConsole",
                "console"
            ],
            "updatePoint": {
                "line": 201,
                "column": 55
            },
            "line": 201,
            "code": "    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });",
            "file": "bufferedConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should print to stdout",
            "suites": [
                "CustomConsole",
                "log"
            ],
            "updatePoint": {
                "line": 39,
                "column": 32
            },
            "line": 39,
            "code": "    test('should print to stdout', () => {\n      _console.log('Hello world!');\n\n      expect(_stdout).toBe('Hello world!\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should print to stderr",
            "suites": [
                "CustomConsole",
                "error"
            ],
            "updatePoint": {
                "line": 47,
                "column": 32
            },
            "line": 47,
            "code": "    test('should print to stderr', () => {\n      _console.error('Found some error!');\n\n      expect(_stderr).toBe('Found some error!\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should print to stderr",
            "suites": [
                "CustomConsole",
                "warn"
            ],
            "updatePoint": {
                "line": 55,
                "column": 32
            },
            "line": 55,
            "code": "    test('should print to stderr', () => {\n      _console.warn('Found some warning!');\n\n      expect(_stderr).toBe('Found some warning!\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "do not log when the assertion is truthy",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 63,
                "column": 49
            },
            "line": 63,
            "code": "    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(_stderr).toMatch('');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "do not log when the assertion is truthy and there is a message",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 69,
                "column": 72
            },
            "line": 69,
            "code": "    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(_stderr).toMatch('');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "log the assertion error when the assertion is falsy",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 75,
                "column": 61
            },
            "line": 75,
            "code": "    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch(\n        // The message may differ across Node versions\n        /(false == true)|(The expression evaluated to a falsy value:)/,\n      );\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "log the assertion error when the assertion is falsy with another message argument",
            "suites": [
                "CustomConsole",
                "assert"
            ],
            "updatePoint": {
                "line": 85,
                "column": 91
            },
            "line": 85,
            "code": "    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'this should not happen');\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch('this should not happen');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "count using the default counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 94,
                "column": 41
            },
            "line": 94,
            "code": "    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 3\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "count using the a labeled counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 102,
                "column": 43
            },
            "line": 102,
            "code": "    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 3\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "countReset restarts default counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 110,
                "column": 45
            },
            "line": 110,
            "code": "    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 1\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "countReset restarts custom counter",
            "suites": [
                "CustomConsole",
                "count"
            ],
            "updatePoint": {
                "line": 118,
                "column": 44
            },
            "line": 118,
            "code": "    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 1\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "group without label",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 129,
                "column": 29
            },
            "line": 129,
            "code": "    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\n    there\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "group with label",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 138,
                "column": 26
            },
            "line": 138,
            "code": "    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(_stdout).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there\n`);\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "groupEnd remove the indentation of the current group",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 151,
                "column": 62
            },
            "line": 151,
            "code": "    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "groupEnd can not remove the indentation below the starting point",
            "suites": [
                "CustomConsole",
                "group"
            ],
            "updatePoint": {
                "line": 160,
                "column": 74
            },
            "line": 160,
            "code": "    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on default timer",
            "suites": [
                "CustomConsole",
                "time"
            ],
            "updatePoint": {
                "line": 173,
                "column": 78
            },
            "line": 173,
            "code": "    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on custom timer",
            "suites": [
                "CustomConsole",
                "time"
            ],
            "updatePoint": {
                "line": 181,
                "column": 77
            },
            "line": 181,
            "code": "    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should print the deepest value",
            "suites": [
                "CustomConsole",
                "dir"
            ],
            "updatePoint": {
                "line": 191,
                "column": 40
            },
            "line": 191,
            "code": "    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(_stdout).toMatch('value');\n      expect(_stdout).not.toMatch('depth');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on default timer",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 201,
                "column": 78
            },
            "line": 201,
            "code": "    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd();\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should return the time between time() and timeEnd() on custom timer",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 210,
                "column": 77
            },
            "line": 210,
            "code": "    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd('custom');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "default timer with data",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 219,
                "column": 33
            },
            "line": 219,
            "code": "    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd();\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "custom timer with data",
            "suites": [
                "CustomConsole",
                "timeLog"
            ],
            "updatePoint": {
                "line": 228,
                "column": 32
            },
            "line": 228,
            "code": "    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should be able to initialize console instance",
            "suites": [
                "CustomConsole",
                "console"
            ],
            "updatePoint": {
                "line": 239,
                "column": 55
            },
            "line": 239,
            "code": "    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });",
            "file": "CustomConsole.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "takes noStackTrace and pass it on for %s",
            "suites": [
                "getConsoleOutput"
            ],
            "line": 23,
            "code": "  it.each([\n    'assert',\n    'count',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'info',\n    'log',\n    'time',\n    'warn',\n  ] as const)('takes noStackTrace and pass it on for %s', logType => {\n    getConsoleOutput(\n      BufferedConsole.write([], logType, 'message', 4),\n      {\n        rootDir: 'root',\n        testMatch: [],\n      },\n      globalConfig,\n    );\n    expect(formatStackTrace).toHaveBeenCalled();\n    expect(formatStackTrace).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.anything(),\n      expect.objectContaining({\n        noCodeFrame: expect.anything(),\n        noStackTrace: true,\n      }),\n    );\n  });",
            "file": "getConsoleOutput.test.ts",
            "skipped": false,
            "dir": "packages/jest-console/src/__tests__"
        },
        {
            "name": "should collect Timeout",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 18,
                "column": 28
            },
            "line": 18,
            "code": "  it('should collect Timeout', async () => {\n    const handleCollector = collectHandles();\n\n    const interval = setInterval(() => {}, 100);\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).toContainEqual(\n      expect.objectContaining({message: 'Timeout'}),\n    );\n\n    clearInterval(interval);\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not collect the PerformanceObserver open handle",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 32,
                "column": 60
            },
            "line": 32,
            "code": "  it('should not collect the PerformanceObserver open handle', async () => {\n    const handleCollector = collectHandles();\n    const obs = new PerformanceObserver((list, observer) => {});\n    obs.observe({entryTypes: ['mark']});\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'PerformanceObserver'}),\n    );\n    obs.disconnect();\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not collect the DNSCHANNEL open handle",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 45,
                "column": 51
            },
            "line": 45,
            "code": "  it('should not collect the DNSCHANNEL open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const resolver = new dns.Resolver();\n    resolver.getServers();\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'DNSCHANNEL'}),\n    );\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not collect the ZLIB open handle",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 58,
                "column": 45
            },
            "line": 58,
            "code": "  it('should not collect the ZLIB open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const decompressed = zlib.inflateRawSync(\n      Buffer.from('cb2a2d2e5128492d2ec9cc4b0700', 'hex'),\n    );\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'ZLIB'}),\n    );\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not collect the SIGNREQUEST open handle",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 72,
                "column": 52
            },
            "line": 72,
            "code": "  it('should not collect the SIGNREQUEST open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const key =\n      '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD' +\n      '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';\n    const data = Buffer.from('a');\n    crypto.sign(null, data, key);\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'SIGNREQUEST'}),\n    );\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should collect handles opened in test functions with `done` callbacks",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 88,
                "column": 75
            },
            "line": 88,
            "code": "  it('should collect handles opened in test functions with `done` callbacks', done => {\n    const handleCollector = collectHandles();\n    const server = http.createServer((_, response) => response.end('ok'));\n    server.listen(0, () => {\n      // Collect results while server is still open.\n      handleCollector()\n        .then(openHandles => {\n          server.close(() => {\n            expect(openHandles).toContainEqual(\n              expect.objectContaining({message: 'TCPSERVERWRAP'}),\n            );\n            done();\n          });\n        })\n        .catch(done);\n    });\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not collect handles that have been queued to close",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 106,
                "column": 63
            },
            "line": 106,
            "code": "  it('should not collect handles that have been queued to close', async () => {\n    const handleCollector = collectHandles();\n    const server = http.createServer((_, response) => response.end('ok'));\n\n    // Start and stop server.\n    await new Promise(r => server.listen(0, r));\n    await new Promise(r => server.close(r));\n\n    const openHandles = await handleCollector();\n    expect(openHandles).toHaveLength(0);\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should collect handles indirectly triggered by user code",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 118,
                "column": 62
            },
            "line": 118,
            "code": "  it('should collect handles indirectly triggered by user code', async () => {\n    const handleCollector = collectHandles();\n\n    // Calling `server.listen` with just a port (e.g. `server.listen(0)`)\n    // creates a `TCPSERVERWRAP` async resource. However, including a `host`\n    // option instead creates a `GETADDRINFOREQWRAP` resource that only\n    // lasts for the lifetime of the `listen()` call, but which *indirectly*\n    // creates a long-lived `TCPSERVERWRAP` resource. We want to make sure we\n    // capture that long-lived resource.\n    const server = new http.Server();\n    await new Promise(r => server.listen({host: 'localhost', port: 0}, r));\n\n    const openHandles = await handleCollector();\n\n    await new Promise(r => server.close(r));\n\n    expect(openHandles).toContainEqual(\n      expect.objectContaining({message: 'TCPSERVERWRAP'}),\n    );\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not be false positives for some special objects such as `TLSWRAP`",
            "suites": [
                "collectHandles"
            ],
            "updatePoint": {
                "line": 139,
                "column": 78
            },
            "line": 139,
            "code": "  it('should not be false positives for some special objects such as `TLSWRAP`', async () => {\n    const handleCollector = collectHandles();\n\n    const socket = new TLSSocket();\n    socket.destroy();\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).toHaveLength(0);\n  });",
            "file": "collectHandles.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should filter tests",
            "suites": [
                "FailedTestsCache"
            ],
            "updatePoint": {
                "line": 11,
                "column": 27
            },
            "line": 11,
            "code": "  test('should filter tests', () => {\n    const failedTestsCache = new FailedTestsCache();\n    failedTestsCache.setTestResults([\n      {\n        numFailingTests: 0,\n        testFilePath: '/path/to/passing.js',\n        testResults: [\n          {fullName: 'test 1', status: 'passed'},\n          {fullName: 'test 2', status: 'passed'},\n        ],\n      },\n      {\n        numFailingTests: 2,\n        testFilePath: '/path/to/failed_1.js',\n        testResults: [\n          {fullName: 'test 3', status: 'failed'},\n          {fullName: 'test 4', status: 'failed'},\n        ],\n      },\n      {\n        numFailingTests: 1,\n        testFilePath: '/path/to/failed_2.js',\n        testResults: [\n          {fullName: 'test 5', status: 'failed'},\n          {fullName: 'test 6', status: 'passed'},\n        ],\n      },\n    ]);\n\n    const result = failedTestsCache.filterTests([\n      {\n        path: '/path/to/passing.js',\n      },\n      {\n        path: '/path/to/failed_1.js',\n      },\n      {\n        path: '/path/to/failed_2.js',\n      },\n      {\n        path: '/path/to/unknown.js',\n      },\n    ]);\n    expect(result).toMatchObject([\n      {\n        path: '/path/to/failed_1.js',\n      },\n      {\n        path: '/path/to/failed_2.js',\n      },\n    ]);\n  });",
            "file": "FailedTestsCache.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "renders usage information when all failures resolved",
            "suites": [
                "FailedTestsInteractiveMode",
                "updateWithResults"
            ],
            "updatePoint": {
                "line": 16,
                "column": 60
            },
            "line": 16,
            "code": "    it('renders usage information when all failures resolved', () => {\n      const mockWrite = jest.fn();\n\n      new FailedTestsInteractiveMode({write: mockWrite}).updateWithResults({\n        numFailedTests: 1,\n        snapshot: {},\n      });\n\n      expect(mockWrite).toHaveBeenCalledWith(\n        `${chalk.bold('Watch Usage')}\\n${chalk.dim(\n          `${ARROW}Press`,\n        )} Enter ${chalk.dim('to return to watch mode.')}\\n`,\n      );\n    });",
            "file": "FailedTestsInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "is inactive at construction",
            "suites": [
                "FailedTestsInteractiveMode",
                "updateWithResults"
            ],
            "updatePoint": {
                "line": 32,
                "column": 33
            },
            "line": 32,
            "code": "  it('is inactive at construction', () => {\n    expect(new FailedTestsInteractiveMode().isActive()).toBeFalsy();\n  });",
            "file": "FailedTestsInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "skips activation when no failed tests are present",
            "suites": [
                "FailedTestsInteractiveMode",
                "updateWithResults"
            ],
            "updatePoint": {
                "line": 36,
                "column": 55
            },
            "line": 36,
            "code": "  it('skips activation when no failed tests are present', () => {\n    const plugin = new FailedTestsInteractiveMode();\n\n    plugin.run([]);\n    expect(plugin.isActive()).toBeFalsy();\n\n    plugin.run([{}]);\n    expect(plugin.isActive()).toBeTruthy();\n  });",
            "file": "FailedTestsInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message when monitoring only failures",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 26,
                "column": 61
            },
            "line": 26,
            "code": "  test('returns correct message when monitoring only failures', () => {\n    const config = createGlobalConfig({onlyFailures: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message when monitoring only changed",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 31,
                "column": 60
            },
            "line": 31,
            "code": "  test('returns correct message when monitoring only changed', () => {\n    const config = createGlobalConfig({onlyChanged: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message with verbose option",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 36,
                "column": 51
            },
            "line": 36,
            "code": "  test('returns correct message with verbose option', () => {\n    const config = createGlobalConfig({verbose: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message without options",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 41,
                "column": 47
            },
            "line": 41,
            "code": "  test('returns correct message without options', () => {\n    const config = createGlobalConfig();\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message with passWithNoTests",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 46,
                "column": 52
            },
            "line": 46,
            "code": "  test('returns correct message with passWithNoTests', () => {\n    const config = createGlobalConfig({passWithNoTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns correct message with findRelatedTests",
            "suites": [
                "getNoTestsFoundMessage"
            ],
            "updatePoint": {
                "line": 51,
                "column": 53
            },
            "line": 51,
            "code": "  test('returns correct message with findRelatedTests', () => {\n    const config = createGlobalConfig({findRelatedTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n    expect(\n      getNoTestsFoundMessage([], {...config, passWithNoTests: true}),\n    ).toMatchSnapshot();\n  });",
            "file": "getNoTestsFoundMessage.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "check process",
            "suites": [
                "Common globals"
            ],
            "updatePoint": {
                "line": 9,
                "column": 19
            },
            "line": 9,
            "code": "  it('check process', () => {\n    if (Symbol && Symbol.toStringTag) {\n      expect(Object.prototype.toString.call(process)).toBe('[object process]');\n    }\n  });",
            "file": "globals.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "when watch is set then exit process",
            "suites": [
                "runJest"
            ],
            "updatePoint": {
                "line": 39,
                "column": 43
            },
            "line": 39,
            "code": "  test('when watch is set then exit process', () => {\n    expect(process.exit).toHaveBeenCalledWith(1);\n  });",
            "file": "runJest.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "when watch is set then an error message is printed",
            "suites": [
                "runJest"
            ],
            "updatePoint": {
                "line": 43,
                "column": 58
            },
            "line": 43,
            "code": "  test('when watch is set then an error message is printed', () => {\n    expect(stderrSpy).toHaveBeenCalled();\n  });",
            "file": "runJest.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "supports ../ paths and unix separators via testRegex",
            "suites": [
                "SearchSource",
                "isTestFilePath"
            ],
            "updatePoint": {
                "line": 76,
                "column": 60
            },
            "line": 76,
            "code": "    it('supports ../ paths and unix separators via testRegex', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      const {searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: [],\n        testMatch: undefined,\n        testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.jsx?$',\n      });\n\n      const path = '/path/to/__tests__/foo/bar/baz/../../../test.js';\n      expect(searchSource.isTestFilePath(path)).toBe(true);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "supports unix separators",
            "suites": [
                "SearchSource",
                "isTestFilePath"
            ],
            "updatePoint": {
                "line": 92,
                "column": 32
            },
            "line": 92,
            "code": "    it('supports unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "supports win32 separators",
            "suites": [
                "SearchSource",
                "isTestFilePath"
            ],
            "updatePoint": {
                "line": 99,
                "column": 33
            },
            "line": 99,
            "code": "    it('supports win32 separators', () => {\n      if (process.platform === 'win32') {\n        const path = '\\\\path\\\\to\\\\__tests__\\\\test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests matching a pattern via testRegex",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 117,
                "column": 52
            },
            "line": 117,
            "code": "    it('finds tests matching a pattern via testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'not-really-a-test',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests matching a pattern via testMatch",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 131,
                "column": 52
            },
            "line": 131,
            "code": "    it('finds tests matching a pattern via testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: ['**/not-really-a-test.txt', '!**/do-not-match-me.txt'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests matching a JS regex pattern",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 145,
                "column": 47
            },
            "line": 145,
            "code": "    it('finds tests matching a JS regex pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'test.jsx?',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests matching a JS glob pattern",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 159,
                "column": 46
            },
            "line": 159,
            "code": "    it('finds tests matching a JS glob pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: ['**/test.js?(x)'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests matching a JS with overriding glob patterns",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 173,
                "column": 63
            },
            "line": 173,
            "code": "    it('finds tests matching a JS with overriding glob patterns', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: [\n          '**/*.js?(x)',\n          '!**/test.js?(x)',\n          '**/test.js',\n          '!**/test.js',\n        ],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('module.jsx'),\n        path.normalize('noTests.js'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with default file extensions using testRegex",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 192,
                "column": 64
            },
            "line": 192,
            "code": "    it('finds tests with default file extensions using testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with default file extensions using testMatch",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 205,
                "column": 64
            },
            "line": 205,
            "code": "    it('finds tests with default file extensions using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with parentheses in their rootDir when using testMatch",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 218,
                "column": 74
            },
            "line": 218,
            "code": "    it('finds tests with parentheses in their rootDir when using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir: path.resolve(__dirname, 'test_root_with_(parentheses)'),\n        testMatch: ['<rootDir>**/__testtests__/**/*'],\n        testRegex: undefined,\n      });\n      expect(paths).toEqual([\n        expect.stringContaining(path.normalize('__testtests__/test.js')),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with similar but custom file extensions",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 230,
                "column": 59
            },
            "line": 230,
            "code": "    it('finds tests with similar but custom file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with totally custom foobar file extensions",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 243,
                "column": 62
            },
            "line": 243,
            "code": "    it('finds tests with totally custom foobar file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'foobar'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.foobar'),\n        path.normalize('__testtests__/test.js'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests with many kinds of file extensions",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 256,
                "column": 54
            },
            "line": 256,
            "code": "    it('finds tests with many kinds of file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests using a regex only",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 269,
                "column": 38
            },
            "line": 269,
            "code": "    it('finds tests using a regex only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests using a glob only",
            "suites": [
                "SearchSource",
                "getTestPaths"
            ],
            "updatePoint": {
                "line": 282,
                "column": 37
            },
            "line": 282,
            "code": "    it('finds tests using a glob only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow a simple match",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 316,
                "column": 35
            },
            "line": 316,
            "code": "    it('should allow a simple match', async () => {\n      const result = searchSource.filterPathsWin32(['packages/lib/my-lib.ts']);\n      expect(result).toEqual([path.resolve('packages/lib/my-lib.ts')]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow to match a file inside a hidden directory",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 320,
                "column": 62
            },
            "line": 320,
            "code": "    it('should allow to match a file inside a hidden directory', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/.hidden/my-app-hidden.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/.hidden/my-app-hidden.ts'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow to match a file inside a directory prefixed with a \"@\"",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 328,
                "column": 75
            },
            "line": 328,
            "code": "    it('should allow to match a file inside a directory prefixed with a \"@\"', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@core/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow to match a file inside a directory prefixed with a \"+\"",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 334,
                "column": 75
            },
            "line": 334,
            "code": "    it('should allow to match a file inside a directory prefixed with a \"+\"', async () => {\n      const result = searchSource.filterPathsWin32(['packages/+cli/my-cli.ts']);\n      expect(result).toEqual([path.resolve('packages/+cli/my-cli.ts')]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow an @(pattern)",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 338,
                "column": 34
            },
            "line": 338,
            "code": "    it('should allow an @(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow a +(pattern)",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 344,
                "column": 33
            },
            "line": 344,
            "code": "    it('should allow a +(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/+(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow for (pattern) in file path",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 350,
                "column": 47
            },
            "line": 350,
            "code": "    it('should allow for (pattern) in file path', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/programs (x86)/my-program.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/programs (x86)/my-program.ts'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should allow no results found",
            "suites": [
                "SearchSource",
                "filterPathsWin32"
            ],
            "updatePoint": {
                "line": 358,
                "column": 37
            },
            "line": 358,
            "code": "    it('should allow no results found', () => {\n      const result = searchSource.filterPathsWin32(['not/exists']);\n      expect(result).toHaveLength(0);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "makes sure a file is related to itself",
            "suites": [
                "SearchSource",
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 396,
                "column": 46
            },
            "line": 396,
            "code": "    it('makes sure a file is related to itself', async () => {\n      const data = await searchSource.findRelatedTests(\n        new Set([rootPath]),\n        false,\n      );\n      expect(toPaths(data.tests)).toEqual([rootPath]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests that depend directly on the path",
            "suites": [
                "SearchSource",
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 404,
                "column": 52
            },
            "line": 404,
            "code": "    it('finds tests that depend directly on the path', async () => {\n      const filePath = path.join(rootDir, 'RegularModule.js');\n      const file2Path = path.join(rootDir, 'RequireRegularModule.js');\n      const parentDep = path.join(rootDir, 'ModuleWithSideEffects.js');\n      const data = await searchSource.findRelatedTests(\n        new Set([filePath]),\n        false,\n      );\n      expect(toPaths(data.tests).sort()).toEqual([\n        parentDep,\n        filePath,\n        file2Path,\n        rootPath,\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "excludes untested files from coverage",
            "suites": [
                "SearchSource",
                "findRelatedTests"
            ],
            "updatePoint": {
                "line": 420,
                "column": 45
            },
            "line": 420,
            "code": "    it('excludes untested files from coverage', async () => {\n      const unrelatedFile = path.join(rootDir, 'JSONFile.json');\n      const regular = path.join(rootDir, 'RegularModule.js');\n      const requireRegular = path.join(rootDir, 'RequireRegularMode.js');\n\n      const data = await searchSource.findRelatedTests(\n        new Set([regular, requireRegular, unrelatedFile]),\n        true,\n      );\n      expect(Array.from(data.collectCoverageFrom || [])).toEqual([\n        'RegularModule.js',\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns empty search result for empty input",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 445,
                "column": 51
            },
            "line": 445,
            "code": "    it('returns empty search result for empty input', async () => {\n      const input: Array<string> = [];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns empty search result for invalid input",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 451,
                "column": 53
            },
            "line": 451,
            "code": "    it('returns empty search result for invalid input', async () => {\n      const input = ['non-existend.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "returns empty search result if no related tests were found",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 457,
                "column": 66
            },
            "line": 457,
            "code": "    it('returns empty search result if no related tests were found', async () => {\n      const input = ['no_tests.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests for a single file",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 463,
                "column": 37
            },
            "line": 463,
            "code": "    it('finds tests for a single file', async () => {\n      const input = ['packages/jest-core/src/__tests__/test_root/module.jsx'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "finds tests for multiple files",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 472,
                "column": 38
            },
            "line": 472,
            "code": "    it('finds tests for multiple files', async () => {\n      const input = [\n        'packages/jest-core/src/__tests__/test_root/module.jsx',\n        'packages/jest-core/src/__tests__/test_root/module.foobar',\n      ];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.foobar'),\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "does not mistake roots folders with prefix names",
            "suites": [
                "SearchSource",
                "findRelatedTestsFromPattern"
            ],
            "updatePoint": {
                "line": 485,
                "column": 56
            },
            "line": 485,
            "code": "    it('does not mistake roots folders with prefix names', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      ({searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: ['/foo/bar/prefix'],\n      }));\n\n      const input = ['/foo/bar/prefix-suffix/__tests__/my-test.test.js'];\n      const data = searchSource.findTestsByPaths(input);\n      expect(data.tests).toEqual([]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "return empty set if no SCM",
            "suites": [
                "SearchSource",
                "findRelatedSourcesFromTestsInChangedFiles"
            ],
            "updatePoint": {
                "line": 520,
                "column": 34
            },
            "line": 520,
            "code": "    it('return empty set if no SCM', async () => {\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set(),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "return sources required by tests",
            "suites": [
                "SearchSource",
                "findRelatedSourcesFromTestsInChangedFiles"
            ],
            "updatePoint": {
                "line": 536,
                "column": 40
            },
            "line": 536,
            "code": "    it('return sources required by tests', async () => {\n      const regularModule = path.join(rootDir, 'RegularModule.js');\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set('/path/to/git'),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([regularModule]);\n    });",
            "file": "SearchSource.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "is inactive at construction",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 30,
                "column": 35
            },
            "line": 30,
            "code": "  test('is inactive at construction', () => {\n    expect(instance.isActive()).toBeFalsy();\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "call to run process the first file",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 34,
                "column": 42
            },
            "line": 34,
            "code": "  test('call to run process the first file', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "call to abort",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 44,
                "column": 21
            },
            "line": 44,
            "code": "  test('call to abort', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    instance.abort();\n    expect(instance.isActive()).toBeFalsy();\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenCalledWith(null, false);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "call to reset",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 57,
                "column": 21
            },
            "line": 57,
            "code": "  test('call to reset', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    instance.restart();\n    expect(instance.isActive()).toBeTruthy();\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "press Q or ESC triggers an abort",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 70,
                "column": 40
            },
            "line": 70,
            "code": "  test('press Q or ESC triggers an abort', () => {\n    instance.abort = jest.fn();\n    instance.put('q');\n    instance.put(KEYS.ESCAPE);\n    expect(instance.abort).toHaveBeenCalledTimes(2);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "press ENTER trigger a run",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 77,
                "column": 33
            },
            "line": 77,
            "code": "  test('press ENTER trigger a run', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n    instance.run(assertions, mockCallback);\n    instance.put(KEYS.ENTER);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "skip 1 test, then restart",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 85,
                "column": 33
            },
            "line": 85,
            "code": "  test('skip 1 test, then restart', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "skip 1 test, then quit",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 105,
                "column": 30
            },
            "line": 105,
            "code": "  test('skip 1 test, then quit', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('q');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(2, null, false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "update 1 test, then finish and return",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 124,
                "column": 45
            },
            "line": 124,
            "code": "  test('update 1 test, then finish and return', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n\n    instance.put(KEYS.ENTER);\n    expect(instance.isActive()).toBe(false);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, null, false);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "skip 2 tests, then finish and restart",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 153,
                "column": 45
            },
            "line": 153,
            "code": "  test('skip 2 tests, then finish and restart', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "update 2 tests, then finish and return",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 181,
                "column": 46
            },
            "line": 181,
            "code": "  test('update 2 tests, then finish and return', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[1], true);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put(KEYS.ENTER);\n    expect(instance.isActive()).toBe(false);\n    expect(mockCallback).toHaveBeenNthCalledWith(5, null, false);\n    expect(mockCallback).toHaveBeenCalledTimes(5);\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "update 1 test, skip 1 test, then finish and restart",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 229,
                "column": 59
            },
            "line": 229,
            "code": "  test('update 1 test, skip 1 test, then finish and restart', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "skip 1 test, update 1 test, then finish and restart",
            "suites": [
                "SnapshotInteractiveMode"
            ],
            "updatePoint": {
                "line": 277,
                "column": 59
            },
            "line": 277,
            "code": "  test('skip 1 test, update 1 test, then finish and restart', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], true);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });",
            "file": "SnapshotInteractiveMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "works with default value",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 69,
                "column": 32
            },
            "line": 69,
            "code": "  test('works with default value', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: undefined,\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "does not enable any reporters, if empty list is passed",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 86,
                "column": 62
            },
            "line": 86,
            "code": "  test('does not enable any reporters, if empty list is passed', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(0);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up default reporters",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 103,
                "column": 33
            },
            "line": 103,
            "code": "  test('sets up default reporters', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up verbose reporter",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 120,
                "column": 32
            },
            "line": 120,
            "code": "  test('sets up verbose reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['default', {}]],\n        verbose: true,\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(1);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up github actions reporter",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 138,
                "column": 39
            },
            "line": 138,
            "code": "  test('sets up github actions reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [\n          ['default', {}],\n          ['github-actions', {}],\n        ],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(1);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up notify reporter",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 158,
                "column": 31
            },
            "line": 158,
            "code": "  test('sets up notify reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        notify: true,\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(1);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up coverage reporter",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 176,
                "column": 33
            },
            "line": 176,
            "code": "  test('sets up coverage reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        collectCoverage: true,\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(1);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows enabling summary reporter separately",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 194,
                "column": 51
            },
            "line": 194,
            "code": "  test('allows enabling summary reporter separately', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['summary', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "sets up custom reporter",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 211,
                "column": 31
            },
            "line": 211,
            "code": "  test('sets up custom reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [\n          ['default', {}],\n          ['/custom-reporter.js', {}],\n        ],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n    expect(CustomReporter).toHaveBeenCalledTimes(1);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": ".addReporter() .removeReporter()",
            "suites": [
                "reporters"
            ],
            "updatePoint": {
                "line": 233,
                "column": 38
            },
            "line": 233,
            "code": "test('.addReporter() .removeReporter()', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const reporter = new SummaryReporter();\n  scheduler.addReporter(reporter);\n  expect(scheduler._dispatcher._reporters).toContain(reporter);\n  scheduler.removeReporter(SummaryReporter);\n  expect(scheduler._dispatcher._reporters).not.toContain(reporter);\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "during normal run",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 274,
                "column": 25
            },
            "line": 274,
            "code": "  test('during normal run', async () => {\n    expect.hasAssertions();\n    const result = await scheduler.scheduleTests([t], {\n      isInterrupted: jest.fn(),\n      isWatchMode: () => true,\n      setState: jest.fn(),\n    });\n\n    expect(result.numTotalTestSuites).toBe(1);\n\n    expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n    expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n    const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n    expect(aggregatedResult.runExecError).toBeUndefined();\n\n    expect(aggregatedResult).toEqual(result);\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "with runtime error: $runtimeError",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "line": 291,
            "code": "  test.each`\n    runtimeError                                  | message\n    ${errorMsg}                                   | ${errorMsg}\n    ${123}                                        | ${'123'}\n    ${new Error(errorMsg)}                        | ${errorMsg}\n    ${{message: errorMsg}}                        | ${errorMsg}\n    ${{message: errorMsg, stack: 'stack-string'}} | ${errorMsg}\n    ${`${errorMsg}\\n Require stack:xxxx`}         | ${errorMsg}\n  `('with runtime error: $runtimeError', async ({runtimeError, message}) => {\n    expect.hasAssertions();\n\n    const spyCreateScriptTransformer = jest.spyOn(\n      transform,\n      'createScriptTransformer',\n    );\n    spyCreateScriptTransformer.mockImplementation(async () => {\n      throw runtimeError;\n    });\n\n    await expect(\n      scheduler.scheduleTests([t], {\n        isInterrupted: jest.fn(),\n        isWatchMode: () => true,\n        setState: jest.fn(),\n      }),\n    ).rejects.toEqual(runtimeError);\n\n    expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n    expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n    const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n    expect(aggregatedResult.runExecError.message).toEqual(message);\n    expect(aggregatedResult.runExecError.stack.length).toBeGreaterThan(0);\n\n    spyCreateScriptTransformer.mockRestore();\n  });",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "with runner exception: watchMode=$watchMode, isInterrupted=$isInterrupted",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "line": 326,
            "code": "  test.each`\n    watchMode | isInterrupted | hasExecError\n    ${false}  | ${false}      | ${true}\n    ${true}   | ${false}      | ${true}\n    ${true}   | ${true}       | ${false}\n  `(\n    'with runner exception: watchMode=$watchMode, isInterrupted=$isInterrupted',\n    async ({watchMode, isInterrupted, hasExecError}) => {\n      expect.hasAssertions();\n\n      mockSerialRunner.runTests.mockImplementation(() => {\n        throw errorMsg;\n      });\n\n      try {\n        const result = await scheduler.scheduleTests([t], {\n          isInterrupted: () => isInterrupted,\n          isWatchMode: () => watchMode,\n          setState: jest.fn(),\n        });\n        if (hasExecError) {\n          throw new Error('should throw exception');\n        }\n        expect(result.runExecError).toBeUndefined();\n      } catch (e) {\n        expect(e).toEqual(errorMsg);\n      }\n\n      expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n      expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n\n      const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n      if (hasExecError) {\n        expect(aggregatedResult.runExecError.message).toEqual(errorMsg);\n        expect(aggregatedResult.runExecError.stack.length).toBeGreaterThan(0);\n      } else {\n        expect(aggregatedResult.runExecError).toBeUndefined();\n      }\n\n      mockSerialRunner.runTests.mockReset();\n    },\n  );",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "schedule tests run in parallel per default",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 370,
                "column": 48
            },
            "line": 370,
            "code": "test('schedule tests run in parallel per default', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeFalsy();\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "schedule tests run in serial if the runner flags them",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 393,
                "column": 59
            },
            "line": 393,
            "code": "test('schedule tests run in serial if the runner flags them', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test, test];\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(mockSerialRunner.runTests).toHaveBeenCalled();\n  expect(mockSerialRunner.runTests.mock.calls[0][5].serial).toBeTruthy();\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should bail after `n` failures",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 416,
                "column": 36
            },
            "line": 416,
            "code": "test('should bail after `n` failures', async () => {\n  const scheduler = await createTestScheduler(\n    makeGlobalConfig({bail: 2}),\n    {},\n    {},\n  );\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        rootDir: './',\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test];\n  const setState = jest.fn();\n  await scheduler.scheduleTests(tests, {\n    isInterrupted: jest.fn(),\n    isWatchMode: () => true,\n    setState,\n  });\n  await mockSerialRunner.runTests.mock.calls[0][3](test, {\n    numFailingTests: 2,\n    snapshot: {},\n    testResults: [{}],\n  });\n  expect(setState).toHaveBeenCalledWith({interrupted: true});\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should not bail if less than `n` failures",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 452,
                "column": 47
            },
            "line": 452,
            "code": "test('should not bail if less than `n` failures', async () => {\n  const scheduler = await createTestScheduler(\n    makeGlobalConfig({bail: 2}),\n    {},\n    {},\n  );\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        rootDir: './',\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test];\n  const setState = jest.fn();\n  await scheduler.scheduleTests(tests, {\n    isInterrupted: jest.fn(),\n    isWatchMode: () => true,\n    setState,\n  });\n  await mockSerialRunner.runTests.mock.calls[0][3](test, {\n    numFailingTests: 1,\n    snapshot: {},\n    testResults: [{}],\n  });\n  expect(setState).not.toHaveBeenCalled();\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should set runInBand to run in serial",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 488,
                "column": 43
            },
            "line": 488,
            "code": "test('should set runInBand to run in serial', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  spyShouldRunInBand.mockReturnValue(true);\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(spyShouldRunInBand).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeTruthy();\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should set runInBand to not run in serial",
            "suites": [
                "scheduleTests should always dispatch runStart and runComplete events"
            ],
            "updatePoint": {
                "line": 514,
                "column": 47
            },
            "line": 514,
            "code": "test('should set runInBand to not run in serial', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  spyShouldRunInBand.mockReturnValue(false);\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(spyShouldRunInBand).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeFalsy();\n});",
            "file": "TestScheduler.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "shouldRunInBand() - should return $expectedResult for runInBand mode",
            "suites": [],
            "line": 25,
            "code": "test.each`\n  tests              | timings        | detectOpenHandles | maxWorkers   | watch    | expectedResult\n  ${[getTestMock()]} | ${[500, 500]}  | ${false}          | ${undefined} | ${true}  | ${true}\n  ${getTestsMock()}  | ${[2000, 500]} | ${false}          | ${1}         | ${true}  | ${true}\n  ${getTestsMock()}  | ${[2000, 500]} | ${false}          | ${2}         | ${true}  | ${false}\n  ${[getTestMock()]} | ${[2000, 500]} | ${false}          | ${undefined} | ${true}  | ${false}\n  ${getTestMock()}   | ${[500, 500]}  | ${false}          | ${undefined} | ${true}  | ${false}\n  ${getTestsMock()}  | ${[2000, 500]} | ${false}          | ${1}         | ${false} | ${true}\n  ${getTestMock()}   | ${[2000, 500]} | ${false}          | ${2}         | ${false} | ${false}\n  ${[getTestMock()]} | ${[2000]}      | ${false}          | ${undefined} | ${false} | ${true}\n  ${getTestsMock()}  | ${[500, 500]}  | ${false}          | ${undefined} | ${false} | ${true}\n  ${new Array(45)}   | ${[500]}       | ${false}          | ${undefined} | ${false} | ${false}\n  ${getTestsMock()}  | ${[2000, 500]} | ${false}          | ${undefined} | ${false} | ${false}\n  ${getTestsMock()}  | ${[2000, 500]} | ${true}           | ${undefined} | ${false} | ${true}\n`(\n  'shouldRunInBand() - should return $expectedResult for runInBand mode',\n  ({tests, timings, detectOpenHandles, maxWorkers, watch, expectedResult}) => {\n    expect(\n      shouldRunInBand(tests, timings, {detectOpenHandles, maxWorkers, watch}),\n    ).toBe(expectedResult);\n  },\n);",
            "file": "testSchedulerHelper.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Correctly passing test path pattern",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 134,
                "column": 41
            },
            "line": 134,
            "code": "  it('Correctly passing test path pattern', () => {\n    globalConfig.testPathPattern = 'test-*';\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Correctly passing test name pattern",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 150,
                "column": 41
            },
            "line": 150,
            "code": "  it('Correctly passing test name pattern', () => {\n    globalConfig.testNamePattern = 'test-*';\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Runs Jest once by default and shows usage",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 166,
                "column": 47
            },
            "line": 166,
            "code": "  it('Runs Jest once by default and shows usage', () => {\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Runs Jest in a non-interactive environment not showing usage",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 180,
                "column": 66
            },
            "line": 180,
            "code": "  it('Runs Jest in a non-interactive environment not showing usage', () => {\n    jest.resetModules();\n    isInteractive = false;\n\n    watch = require('../watch').default;\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "resolves relative to the package root",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 198,
                "column": 43
            },
            "line": 198,
            "code": "  it('resolves relative to the package root', () => {\n    expect(async () => {\n      await watch(\n        {\n          ...globalConfig,\n          rootDir: __dirname,\n          watchPlugins: [{config: {}, path: watchPluginPath}],\n        },\n        contexts,\n        pipe,\n        hasteMapInstances,\n        stdin,\n      );\n    }).not.toThrow();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "shows prompts for WatchPlugins in alphabetical order",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 214,
                "column": 58
            },
            "line": 214,
            "code": "  it('shows prompts for WatchPlugins in alphabetical order', async () => {\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {config: {}, path: watchPluginPath},\n          {config: {}, path: watchPlugin2Path},\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "shows update snapshot prompt (without interactive)",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 239,
                "column": 56
            },
            "line": 239,
            "code": "  it('shows update snapshot prompt (without interactive)', async () => {\n    results = {snapshot: {failure: true}};\n\n    watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "shows update snapshot prompt (with interactive)",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 263,
                "column": 53
            },
            "line": 263,
            "code": "  it('shows update snapshot prompt (with interactive)', async () => {\n    results = {\n      numFailedTests: 1,\n      snapshot: {\n        failure: true,\n      },\n      testPath: 'test.js',\n      testResults: [\n        {\n          snapshot: {\n            unmatched: true,\n          },\n          testResults: [\n            {\n              status: 'failed',\n              title: 'test a',\n            },\n          ],\n        },\n      ],\n    };\n\n    watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to hook into JestHook",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 306,
                "column": 47
            },
            "line": 306,
            "code": "  it('allows WatchPlugins to hook into JestHook', async () => {\n    const apply = jest.fn();\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_register`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor() {\n            this.apply = apply;\n          }\n        },\n      {virtual: true},\n    );\n\n    watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    await nextTick();\n\n    expect(apply).toHaveBeenCalled();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to override eligible internal plugins",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 337,
                "column": 63
            },
            "line": 337,
            "code": "  it('allows WatchPlugins to override eligible internal plugins', async () => {\n    const run = jest.fn(() => Promise.resolve());\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_override`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor() {\n            this.run = run;\n          }\n          getUsageInfo() {\n            return {\n              key: 'p',\n              prompt: 'custom \"P\" plugin',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    await nextTick();\n\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n\n    stdin.emit('p');\n    await nextTick();\n\n    expect(run).toHaveBeenCalled();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "forbids WatchPlugins overriding reserved internal plugins",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "line": 380,
            "code": "    it.each`\n      key    | plugin\n      ${'q'} | ${'Quit'}\n      ${'u'} | ${'UpdateSnapshots'}\n      ${'i'} | ${'UpdateSnapshotsInteractive'}\n    `(\n      'forbids WatchPlugins overriding reserved internal plugins',\n      async ({key}) => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_bad_override_${key}`;\n        jest.doMock(\n          pluginPath,\n          () =>\n            class OffendingWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key,\n                  prompt: `custom \"${key.toUpperCase()}\" plugin`,\n                };\n              }\n            },\n          {virtual: true},\n        );\n\n        await expect(\n          watch(\n            {\n              ...globalConfig,\n              rootDir: __dirname,\n              watchPlugins: [{config: {}, path: pluginPath}],\n            },\n            contexts,\n            pipe,\n            hasteMapInstances,\n            stdin,\n          ),\n        ).rejects.toThrow(\n          new RegExp(\n            `Watch plugin OffendingWatchPlugin attempted to register key <${key}>,\\\\s+that is reserved internally for .+\\\\.\\\\s+Please change the configuration key for this plugin\\\\.`,\n            'm',\n          ),\n        );\n      },\n    );",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to override non-reserved internal plugins",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "line": 430,
            "code": "    it.each`\n      key    | plugin\n      ${'t'} | ${'TestNamePattern'}\n      ${'p'} | ${'TestPathPattern'}\n    `(\n      'allows WatchPlugins to override non-reserved internal plugins',\n      ({key}) => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_valid_override_${key}`;\n        jest.doMock(\n          pluginPath,\n          () =>\n            class ValidWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key,\n                  prompt: `custom \"${key.toUpperCase()}\" plugin`,\n                };\n              }\n            },\n          {virtual: true},\n        );\n\n        watch(\n          {\n            ...globalConfig,\n            rootDir: __dirname,\n            watchPlugins: [{config: {}, path: pluginPath}],\n          },\n          contexts,\n          pipe,\n          hasteMapInstances,\n          stdin,\n        );\n      },\n    );",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "forbids third-party WatchPlugins overriding each other",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 470,
                "column": 62
            },
            "line": 470,
            "code": "    it('forbids third-party WatchPlugins overriding each other', async () => {\n      const pluginPaths = ['Foo', 'Bar'].map(ident => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_bad_override_${ident.toLowerCase()}`;\n        jest.doMock(\n          pluginPath,\n          () => {\n            class OffendingThirdPartyWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key: '!',\n                  prompt: `custom \"!\" plugin ${ident}`,\n                };\n              }\n            }\n            OffendingThirdPartyWatchPlugin.displayName = `Offending${ident}ThirdPartyWatchPlugin`;\n            return OffendingThirdPartyWatchPlugin;\n          },\n          {virtual: true},\n        );\n        return pluginPath;\n      });\n\n      await expect(\n        watch(\n          {\n            ...globalConfig,\n            rootDir: __dirname,\n            watchPlugins: pluginPaths.map(path => ({config: {}, path})),\n          },\n          contexts,\n          pipe,\n          hasteMapInstances,\n          stdin,\n        ),\n      ).rejects.toThrow(\n        /Watch plugins OffendingFooThirdPartyWatchPlugin and OffendingBarThirdPartyWatchPlugin both attempted to register key <!>\\.\\s+Please change the key configuration for one of the conflicting plugins to avoid overlap\\./m,\n      );\n    });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to be configured",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 514,
                "column": 42
            },
            "line": 514,
            "code": "  it('allows WatchPlugins to be configured', async () => {\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_with_config`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor({config}) {\n            this._key = config.key;\n            this._prompt = config.prompt;\n          }\n          onKey() {}\n          run() {}\n          getUsageInfo() {\n            return {\n              key: this._key || 'z',\n              prompt: this._prompt || 'default prompt',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {\n            config: {key: 'k', prompt: 'filter with a custom prompt'},\n            path: pluginPath,\n          },\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to hook into file system changes",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 556,
                "column": 58
            },
            "line": 556,
            "code": "  it('allows WatchPlugins to hook into file system changes', async () => {\n    const onFileChange = jest.fn();\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_fs_change`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          apply(jestHooks) {\n            jestHooks.onFileChange(onFileChange);\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    expect(onFileChange).toHaveBeenCalledWith({\n      projects: [\n        {\n          config: contexts[0].config,\n          testPaths: ['./path/to/file1-test.js', './path/to/file2-test.js'],\n        },\n      ],\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "makes watch plugin initialization errors look nice",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 592,
                "column": 56
            },
            "line": 592,
            "code": "  it('makes watch plugin initialization errors look nice', async () => {\n    const pluginPath = `${__dirname}/__fixtures__/watchPluginThrows`;\n\n    await expect(\n      watch(\n        {\n          ...globalConfig,\n          rootDir: __dirname,\n          watchPlugins: [{config: {}, path: pluginPath}],\n        },\n        contexts,\n        pipe,\n        hasteMapInstances,\n        stdin,\n      ),\n    ).rejects.toMatchSnapshot();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "allows WatchPlugins to modify only white-listed global config keys",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "line": 610,
            "code": "  it.each`\n    ok      | option\n    ${'✔︎'} | ${'bail'}\n    ${'✖︎'} | ${'changedFilesWithAncestor'}\n    ${'✔︎'} | ${'changedSince'}\n    ${'✔︎'} | ${'collectCoverage'}\n    ${'✔︎'} | ${'collectCoverageFrom'}\n    ${'✔︎'} | ${'coverageDirectory'}\n    ${'✔︎'} | ${'coverageReporters'}\n    ${'✖︎'} | ${'coverageThreshold'}\n    ${'✖︎'} | ${'detectLeaks'}\n    ${'✖︎'} | ${'detectOpenHandles'}\n    ${'✖︎'} | ${'errorOnDeprecated'}\n    ${'✖︎'} | ${'expand'}\n    ${'✖︎'} | ${'filter'}\n    ${'✔︎'} | ${'findRelatedTests'}\n    ${'✖︎'} | ${'forceExit'}\n    ${'✖︎'} | ${'globalSetup'}\n    ${'✖︎'} | ${'globalTeardown'}\n    ${'✖︎'} | ${'json'}\n    ${'✖︎'} | ${'lastCommit'}\n    ${'✖︎'} | ${'listTests'}\n    ${'✖︎'} | ${'logHeapUsage'}\n    ${'✖︎'} | ${'maxWorkers'}\n    ${'✔︎'} | ${'nonFlagArgs'}\n    ${'✖︎'} | ${'noSCM'}\n    ${'✖︎'} | ${'noStackTrace'}\n    ${'✔︎'} | ${'notify'}\n    ${'✔︎'} | ${'notifyMode'}\n    ${'✖︎'} | ${'onlyChanged'}\n    ${'✔︎'} | ${'onlyFailures'}\n    ${'✖︎'} | ${'outputFile'}\n    ${'✖︎'} | ${'passWithNoTests'}\n    ${'✖︎'} | ${'projects'}\n    ${'✖︎'} | ${'replname'}\n    ${'✔︎'} | ${'reporters'}\n    ${'✖︎'} | ${'rootDir'}\n    ${'✖︎'} | ${'runTestsByPath'}\n    ${'✖︎'} | ${'silent'}\n    ${'✖︎'} | ${'skipFilter'}\n    ${'✖︎'} | ${'testFailureExitCode'}\n    ${'✔︎'} | ${'testNamePattern'}\n    ${'✔︎'} | ${'testPathPattern'}\n    ${'✖︎'} | ${'testResultsProcessor'}\n    ${'✔︎'} | ${'updateSnapshot'}\n    ${'✖︎'} | ${'useStderr'}\n    ${'✔︎'} | ${'verbose'}\n    ${'✖︎'} | ${'watch'}\n    ${'✖︎'} | ${'watchAll'}\n    ${'✖︎'} | ${'watchman'}\n    ${'✖︎'} | ${'watchPlugins'}\n  `(\n    'allows WatchPlugins to modify only white-listed global config keys',\n    async ({ok, option}) => {\n      ok = ok === '✔︎';\n      const pluginPath = `${__dirname}/__fixtures__/plugin_path_config_updater_${option}`;\n\n      jest.doMock(\n        pluginPath,\n        () =>\n          class WatchPlugin {\n            getUsageInfo() {\n              return {key: 'x', prompt: 'test option white-listing'};\n            }\n\n            run(globalConfig, updateConfigAndRun) {\n              updateConfigAndRun({[option]: '__JUST_TRYING__'});\n              return Promise.resolve();\n            }\n          },\n        {virtual: true},\n      );\n\n      const config = {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      };\n\n      watch(config, contexts, pipe, hasteMapInstances, stdin);\n      await nextTick();\n\n      stdin.emit('x');\n      await nextTick();\n\n      // We need the penultimate call as Jest forces a final call to restore\n      // updateSnapshot because it's not sticky after a run…?\n      const lastCall = updateGlobalConfig.mock.calls.slice(-2)[0];\n      // eslint-disable-next-line jest/valid-expect\n      let expector = expect(lastCall[1]);\n      if (!ok) {\n        expector = expector.not;\n      }\n      expector.toHaveProperty(option, '__JUST_TRYING__');\n    },\n  );",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "triggers enter on a WatchPlugin when its key is pressed",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 707,
                "column": 61
            },
            "line": 707,
            "code": "  it('triggers enter on a WatchPlugin when its key is pressed', async () => {\n    const run = jest.fn(() => Promise.resolve());\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = run;\n          }\n          getUsageInfo() {\n            return {\n              key: 's',\n              prompt: 'do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    stdin.emit('s');\n\n    await nextTick();\n\n    expect(run).toHaveBeenCalled();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "prevents Jest from handling keys when active and returns control when end is called",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 746,
                "column": 89
            },
            "line": 746,
            "code": "  it('prevents Jest from handling keys when active and returns control when end is called', async () => {\n    let resolveShowPrompt;\n    const run = jest.fn(() => new Promise(res => (resolveShowPrompt = res)));\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_1`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = run;\n          }\n          onKey() {}\n          getUsageInfo() {\n            return {\n              key: 's',\n              prompt: 'do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    const showPrompt2 = jest.fn(() => Promise.resolve());\n    const pluginPath2 = `${__dirname}/__fixtures__/plugin_path_2`;\n    jest.doMock(\n      pluginPath2,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = showPrompt2;\n          }\n          onKey() {}\n          getUsageInfo() {\n            return {\n              key: 'z',\n              prompt: 'also do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {config: {}, path: pluginPath},\n          {config: {}, path: pluginPath2},\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    stdin.emit('s');\n    await nextTick();\n    expect(run).toHaveBeenCalled();\n    stdin.emit('z');\n    await nextTick();\n    expect(showPrompt2).not.toHaveBeenCalled();\n    await resolveShowPrompt();\n    stdin.emit('z');\n    expect(showPrompt2).toHaveBeenCalled();\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"o\" runs test in \"only changed files\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 814,
                "column": 57
            },
            "line": 814,
            "code": "  it('Pressing \"o\" runs test in \"only changed files\" mode', () => {\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    runJestMock.mockReset();\n\n    stdin.emit('o');\n\n    expect(runJestMock).toHaveBeenCalled();\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: true,\n      watch: true,\n      watchAll: false,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"a\" runs test in \"watch all\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 828,
                "column": 48
            },
            "line": 828,
            "code": "  it('Pressing \"a\" runs test in \"watch all\" mode', () => {\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    runJestMock.mockReset();\n\n    stdin.emit('a');\n\n    expect(runJestMock).toHaveBeenCalled();\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: false,\n      watch: false,\n      watchAll: true,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"ENTER\" reruns the tests",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 842,
                "column": 39
            },
            "line": 842,
            "code": "  it('Pressing \"ENTER\" reruns the tests', () => {\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock).toHaveBeenCalledTimes(1);\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalledTimes(2);\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"t\" reruns the tests in \"test name pattern\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 849,
                "column": 63
            },
            "line": 849,
            "code": "  it('Pressing \"t\" reruns the tests in \"test name pattern\" mode', async () => {\n    const hooks = new JestHook();\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('t');\n    ['t', 'e', 's', 't'].forEach(key => stdin.emit(key));\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      testNamePattern: 'test',\n      watch: true,\n      watchAll: false,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"p\" reruns the tests in \"filename pattern\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 867,
                "column": 62
            },
            "line": 867,
            "code": "  it('Pressing \"p\" reruns the tests in \"filename pattern\" mode', async () => {\n    const hooks = new JestHook();\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('p');\n    ['f', 'i', 'l', 'e'].forEach(key => stdin.emit(key));\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      testPathPattern: 'file',\n      watch: true,\n      watchAll: false,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Can combine \"p\" and \"t\" filters",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 885,
                "column": 37
            },
            "line": 885,
            "code": "  it('Can combine \"p\" and \"t\" filters', async () => {\n    const hooks = new JestHook();\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('p');\n    ['f', 'i', 'l', 'e'].forEach(key => stdin.emit(key));\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    stdin.emit('t');\n    ['t', 'e', 's', 't'].forEach(key => stdin.emit(key));\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[1][0].globalConfig).toMatchObject({\n      testNamePattern: 'test',\n      testPathPattern: 'file',\n      watch: true,\n      watchAll: false,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"u\" reruns the tests in \"update snapshot\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 909,
                "column": 61
            },
            "line": 909,
            "code": "  it('Pressing \"u\" reruns the tests in \"update snapshot\" mode', async () => {\n    const hooks = new JestHook();\n\n    globalConfig.updateSnapshot = 'new';\n\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    hooks.getEmitter().onTestRunComplete({snapshot: {failure: true}});\n\n    stdin.emit('u');\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      updateSnapshot: 'all',\n      watch: true,\n      watchAll: false,\n    });\n\n    stdin.emit('a');\n\n    await nextTick();\n    // updateSnapshot is not sticky after a run.\n    expect(runJestMock.mock.calls[1][0].globalConfig).toMatchObject({\n      updateSnapshot: 'new',\n      watch: false,\n      watchAll: true,\n    });\n\n    results = {snapshot: {failure: true}};\n\n    stdin.emit('a');\n    await nextTick();\n\n    runJestMock.mockReset();\n    stdin.emit('u');\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      updateSnapshot: 'all',\n      watch: false,\n      watchAll: true,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "passWithNoTest should be set to true in watch mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 954,
                "column": 56
            },
            "line": 954,
            "code": "  it('passWithNoTest should be set to true in watch mode', () => {\n    globalConfig.passWithNoTests = false;\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    globalConfig.passWithNoTests = true;\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      globalConfig,\n    });\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "shows the correct usage for the f key in \"only failed tests\" mode",
            "suites": [
                "Watch mode flows",
                "when dealing with potential watch plugin key conflicts"
            ],
            "updatePoint": {
                "line": 963,
                "column": 71
            },
            "line": 963,
            "code": "  it('shows the correct usage for the f key in \"only failed tests\" mode', () => {\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    stdin.emit('f');\n    stdin.emit('w');\n\n    const lastWatchDisplay = pipe.write.mock.calls.reverse()[0][0];\n    expect(lastWatchDisplay).toMatch('Press a to run all tests.');\n    expect(lastWatchDisplay).toMatch(\n      'Press f to quit \"only failed tests\" mode',\n    );\n  });",
            "file": "watch.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "should correct require new files without legacy cache",
            "suites": [
                "Watch mode flows with changed files"
            ],
            "updatePoint": {
                "line": 53,
                "column": 59
            },
            "line": 53,
            "code": "  it('should correct require new files without legacy cache', async () => {\n    fs.writeFileSync(\n      fileTargetPath2,\n      `\n        require('./lost-file.js');\n        describe('Fake test', () => {\n            it('Hey', () => {\n\n            });\n        });\n      `,\n    );\n\n    const config = (\n      await normalize(\n        {\n          cache: false,\n          cacheDirectory,\n          coverageReporters: [],\n          maxConcurrency: 1,\n          maxWorkers: 1,\n          moduleDirectories: ['node_modules'],\n          onlyChanged: false,\n          reporters: [],\n          rootDir: testDirectory,\n          silent: true,\n          testRegex: ['watch-test-fake\\\\.test\\\\.js$'],\n          watch: false,\n          watchman: false,\n        },\n        {} as unknown,\n      )\n    ).options;\n\n    hasteMapInstance = await Runtime.createHasteMap(config, {\n      maxWorkers: 1,\n      resetCache: true,\n      watch: true,\n      watchman: false,\n    });\n\n    const realContext = await hasteMapInstance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap),\n    }));\n\n    const hook = new JestHook();\n    const firstErrorPromise = new Promise(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n    await watch(\n      {\n        ...config,\n        watchPlugins: [],\n      },\n      [realContext],\n      pipe,\n      [hasteMapInstance],\n      stdin,\n      hook,\n    );\n\n    await firstErrorPromise;\n\n    const successPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Create lost file\n    fs.writeFileSync(\n      fileTargetPath,\n      `\n        describe('Fake group', () => {\n            it('Fake 1', () => {});\n            it('Fake 2', () => {});\n            it('Fake 3', () => {});\n        });\n      `,\n    );\n\n    const resultSuccessReport = await successPromise;\n\n    expect(resultSuccessReport).toMatchObject({\n      numFailedTestSuites: 0,\n      numFailedTests: 0,\n      numPassedTests: 4,\n      numRuntimeErrorTestSuites: 0,\n      success: true,\n      wasInterrupted: false,\n    });\n    expect(resultSuccessReport.testResults[0]).toMatchObject({\n      failureMessage: null,\n    });\n\n    const errorPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Remove again to ensure about no legacy cache\n    fs.unlinkSync(fileTargetPath);\n\n    const resultErrorReport = await errorPromise;\n\n    // After remove file we have to fail tests\n    expect(resultErrorReport).toMatchObject({\n      numFailedTestSuites: 1,\n      numPassedTests: 0,\n      numRuntimeErrorTestSuites: 1,\n      success: false,\n      wasInterrupted: false,\n    });\n  });",
            "file": "watchFileChanges.test.ts",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"P\" enters pattern mode",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 90,
                "column": 38
            },
            "line": 90,
            "code": "  it('Pressing \"P\" enters pattern mode', () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    // Write a enter pattern mode\n    stdin.emit('p');\n    expect(pipe.write).toHaveBeenCalledWith(' pattern › ');\n\n    const assertPattern = hex => {\n      pipe.write.mockReset();\n      stdin.emit(hex);\n      expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    };\n\n    // Write a pattern\n    ['p', '.', '*', '1', '0'].forEach(assertPattern);\n\n    [KEYS.BACKSPACE, KEYS.BACKSPACE].forEach(assertPattern);\n\n    ['3'].forEach(assertPattern);\n\n    // Runs Jest again\n    runJestMock.mockReset();\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalled();\n\n    // globalConfig is updated with the current pattern\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchSnapshot();\n  });",
            "file": "watchFilenamePatternMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"c\" clears the filters",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 120,
                "column": 37
            },
            "line": 120,
            "code": "  it('Pressing \"c\" clears the filters', async () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    stdin.emit('p');\n    await nextTick();\n\n    ['p', '.', '*', '1', '0']\n\n      .concat(KEYS.ENTER)\n      .forEach(key => stdin.emit(key));\n\n    stdin.emit('t');\n    await nextTick();\n\n    ['t', 'e', 's', 't'].concat(KEYS.ENTER).forEach(key => stdin.emit(key));\n\n    await nextTick();\n\n    stdin.emit('c');\n    await nextTick();\n\n    pipe.write.mockReset();\n    stdin.emit('p');\n    await nextTick();\n\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });",
            "file": "watchFilenamePatternMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "Pressing \"T\" enters pattern mode",
            "suites": [
                "Watch mode flows"
            ],
            "updatePoint": {
                "line": 104,
                "column": 38
            },
            "line": 104,
            "code": "  it('Pressing \"T\" enters pattern mode', () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    // Write a enter pattern mode\n    stdin.emit('t');\n    expect(pipe.write).toHaveBeenCalledWith(' pattern › ');\n\n    const assertPattern = hex => {\n      pipe.write.mockReset();\n      stdin.emit(hex);\n      expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    };\n\n    // Write a pattern\n    ['c', 'o', 'n', ' ', '1', '2'].forEach(assertPattern);\n\n    [KEYS.BACKSPACE, KEYS.BACKSPACE].forEach(assertPattern);\n\n    ['*'].forEach(assertPattern);\n\n    // Runs Jest again\n    runJestMock.mockReset();\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalled();\n\n    // globalConfig is updated with the current pattern\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: false,\n      testNamePattern: 'con *',\n      watch: true,\n      watchAll: false,\n    });\n  });",
            "file": "watchTestNamePatternMode.test.js",
            "skipped": false,
            "dir": "packages/jest-core/src/__tests__"
        },
        {
            "name": "creation of a cache key",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 29
            },
            "line": 25,
            "code": "test('creation of a cache key', () => {\n  const createCacheKeyFunction = interopRequireDefault(\n    require('../index'),\n  ).default;\n  const createCacheKey = createCacheKeyFunction([], ['value']);\n  const hashA = createCacheKey('test', 'test.js', null, {\n    config: {},\n    instrument: false,\n  });\n  const hashB = createCacheKey('test code;', 'test.js', null, {\n    config: {},\n    instrument: false,\n  });\n  const hashC = createCacheKey('test', 'test.js', null, {\n    config: {},\n    instrument: true,\n  });\n\n  expect(hashA).toHaveLength(32);\n  expect(hashA).not.toEqual(hashB);\n  expect(hashA).not.toEqual(hashC);\n});",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-create-cache-key-function/src/__tests__"
        },
        {
            "name": "'' and ''",
            "suites": [
                "different types"
            ],
            "updatePoint": {
                "line": 62,
                "column": 43
            },
            "line": 62,
            "code": "    test(`'${String(a)}' and '${String(b)}'`, () => {\n      expect(stripped(a, b)).toBe(\n        '  Comparing two different types of values. ' +\n          `Expected ${String(typeA)} but received ${String(typeB)}.`,\n      );\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "'' and ''",
            "suites": [
                "no visual difference"
            ],
            "updatePoint": {
                "line": 92,
                "column": 7
            },
            "line": 90,
            "code": "    test(`'${JSON.stringify(values[0])}' and '${JSON.stringify(\n      values[1],\n    )}'`, () => {\n      expect(stripped(values[0], values[1])).toBe(NO_DIFF_MESSAGE);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "Map key order should be irrelevant",
            "suites": [
                "no visual difference"
            ],
            "updatePoint": {
                "line": 97,
                "column": 42
            },
            "line": 97,
            "code": "  test('Map key order should be irrelevant', () => {\n    const arg1 = new Map([\n      [1, 'foo'],\n      [2, 'bar'],\n    ]);\n    const arg2 = new Map([\n      [2, 'bar'],\n      [1, 'foo'],\n    ]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "Set value order should be irrelevant",
            "suites": [
                "no visual difference"
            ],
            "updatePoint": {
                "line": 110,
                "column": 44
            },
            "line": 110,
            "code": "  test('Set value order should be irrelevant', () => {\n    const arg1 = new Set([1, 2]);\n    const arg2 = new Set([2, 1]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "oneline strings",
            "suites": [
                "no visual difference"
            ],
            "updatePoint": {
                "line": 118,
                "column": 21
            },
            "line": 118,
            "code": "test('oneline strings', () => {\n  expect(diff('ab', 'aa', optionsCounts)).toMatchSnapshot();\n  expect(diff('123456789', '234567890', optionsCounts)).toMatchSnapshot();\n  expect(diff('oneline', 'multi\\nline', optionsCounts)).toMatchSnapshot();\n  expect(diff('multi\\nline', 'oneline', optionsCounts)).toMatchSnapshot();\n});",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "but then objects have differences",
            "suites": [
                "falls back to not call toJSON",
                "if serialization has no differences"
            ],
            "updatePoint": {
                "line": 131,
                "column": 43
            },
            "line": 131,
            "code": "    test('but then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "and then objects have no differences",
            "suites": [
                "falls back to not call toJSON",
                "if serialization has no differences"
            ],
            "updatePoint": {
                "line": 136,
                "column": 46
            },
            "line": 136,
            "code": "    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "and then objects have differences",
            "suites": [
                "falls back to not call toJSON",
                "if it throws"
            ],
            "updatePoint": {
                "line": 147,
                "column": 43
            },
            "line": 147,
            "code": "    test('and then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "and then objects have no differences",
            "suites": [
                "falls back to not call toJSON",
                "if it throws"
            ],
            "updatePoint": {
                "line": 152,
                "column": 46
            },
            "line": 152,
            "code": "    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "multiline strings"
            ],
            "updatePoint": {
                "line": 184,
                "column": 20
            },
            "line": 184,
            "code": "  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "multiline strings"
            ],
            "updatePoint": {
                "line": 187,
                "column": 18
            },
            "line": 187,
            "code": "  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "objects"
            ],
            "updatePoint": {
                "line": 206,
                "column": 20
            },
            "line": 206,
            "code": "  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "objects"
            ],
            "updatePoint": {
                "line": 209,
                "column": 18
            },
            "line": 209,
            "code": "  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "numbers",
            "suites": [
                "objects"
            ],
            "updatePoint": {
                "line": 214,
                "column": 13
            },
            "line": 214,
            "code": "test('numbers', () => {\n  expect(diff(1, 2, optionsBe)).toBe('- 1\\n+ 2');\n});",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "-0 and 0",
            "suites": [
                "objects"
            ],
            "updatePoint": {
                "line": 218,
                "column": 14
            },
            "line": 218,
            "code": "test('-0 and 0', () => {\n  expect(diff(-0, 0, optionsBe)).toBe('- -0\\n+ 0');\n});",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "booleans",
            "suites": [
                "objects"
            ],
            "updatePoint": {
                "line": 222,
                "column": 14
            },
            "line": 222,
            "code": "test('booleans', () => {\n  expect(diff(false, true, optionsBe)).toBe('- false\\n+ true');\n});",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "multiline string non-snapshot"
            ],
            "updatePoint": {
                "line": 247,
                "column": 20
            },
            "line": 247,
            "code": "  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "multiline string non-snapshot"
            ],
            "updatePoint": {
                "line": 250,
                "column": 18
            },
            "line": 250,
            "code": "  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "multiline string snapshot"
            ],
            "updatePoint": {
                "line": 279,
                "column": 20
            },
            "line": 279,
            "code": "  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "multiline string snapshot"
            ],
            "updatePoint": {
                "line": 282,
                "column": 18
            },
            "line": 282,
            "code": "  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "React elements"
            ],
            "updatePoint": {
                "line": 313,
                "column": 20
            },
            "line": 313,
            "code": "  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "React elements"
            ],
            "updatePoint": {
                "line": 316,
                "column": 18
            },
            "line": 316,
            "code": "  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "multiline string as value of object property",
                "(non-snapshot)"
            ],
            "updatePoint": {
                "line": 340,
                "column": 22
            },
            "line": 340,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "multiline string as value of object property",
                "(non-snapshot)"
            ],
            "updatePoint": {
                "line": 343,
                "column": 20
            },
            "line": 343,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "multiline string as value of object property",
                "(snapshot)"
            ],
            "updatePoint": {
                "line": 364,
                "column": 22
            },
            "line": 364,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "multiline string as value of object property",
                "(snapshot)"
            ],
            "updatePoint": {
                "line": 367,
                "column": 20
            },
            "line": 367,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in JavaScript structures",
                "from less to more"
            ],
            "updatePoint": {
                "line": 403,
                "column": 22
            },
            "line": 403,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in JavaScript structures",
                "from less to more"
            ],
            "updatePoint": {
                "line": 406,
                "column": 20
            },
            "line": 406,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in JavaScript structures",
                "from more to less"
            ],
            "updatePoint": {
                "line": 426,
                "column": 22
            },
            "line": 426,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in JavaScript structures",
                "from more to less"
            ],
            "updatePoint": {
                "line": 429,
                "column": 20
            },
            "line": 429,
            "code": "    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "color of text"
            ],
            "updatePoint": {
                "line": 451,
                "column": 18
            },
            "line": 451,
            "code": "  test('(expanded)', () => {\n    expect(received).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "color of text"
            ],
            "updatePoint": {
                "line": 454,
                "column": 20
            },
            "line": 454,
            "code": "  test('(unexpanded)', () => {\n    // Expect same result, unless diff is long enough to require patch marks.\n    expect(diff(a, b, unexpanded)).toBe(received);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in React elements (non-snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 503,
                "column": 22
            },
            "line": 503,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in React elements (non-snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 506,
                "column": 20
            },
            "line": 506,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in React elements (non-snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 523,
                "column": 22
            },
            "line": 523,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in React elements (non-snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 526,
                "column": 20
            },
            "line": 526,
            "code": "    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in React elements (snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 566,
                "column": 22
            },
            "line": 566,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in React elements (snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 569,
                "column": 20
            },
            "line": 569,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "indentation in React elements (snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 589,
                "column": 22
            },
            "line": 589,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "indentation in React elements (snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 592,
                "column": 20
            },
            "line": 592,
            "code": "    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "outer React element (non-snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 636,
                "column": 22
            },
            "line": 636,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "outer React element (non-snapshot)",
                "from less to more"
            ],
            "updatePoint": {
                "line": 639,
                "column": 20
            },
            "line": 639,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "outer React element (non-snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 657,
                "column": 22
            },
            "line": 657,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "outer React element (non-snapshot)",
                "from more to less"
            ],
            "updatePoint": {
                "line": 660,
                "column": 20
            },
            "line": 660,
            "code": "    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "trailing newline in multiline string not enclosed in quotes",
                "from less to more"
            ],
            "updatePoint": {
                "line": 673,
                "column": 22
            },
            "line": 673,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "trailing newline in multiline string not enclosed in quotes",
                "from less to more"
            ],
            "updatePoint": {
                "line": 676,
                "column": 20
            },
            "line": 676,
            "code": "    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(unexpanded)",
            "suites": [
                "trailing newline in multiline string not enclosed in quotes",
                "from more to less"
            ],
            "updatePoint": {
                "line": 684,
                "column": 22
            },
            "line": 684,
            "code": "    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "(expanded)",
            "suites": [
                "trailing newline in multiline string not enclosed in quotes",
                "from more to less"
            ],
            "updatePoint": {
                "line": 687,
                "column": 20
            },
            "line": 687,
            "code": "    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "collapses big diffs to patch format",
            "suites": [
                "trailing newline in multiline string not enclosed in quotes",
                "from more to less"
            ],
            "updatePoint": {
                "line": 693,
                "column": 41
            },
            "line": 693,
            "code": "test('collapses big diffs to patch format', () => {\n  const result = diff(\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n    unexpanded,\n  );\n\n  expect(result).toMatchSnapshot();\n});",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "number of lines:  ",
            "suites": [
                "context"
            ],
            "updatePoint": {
                "line": 712,
                "column": 47
            },
            "line": 710,
            "code": "    test(`number of lines: ${\n      typeof contextLines === 'number' ? contextLines : 'undefined'\n    } ${validContextLines ? '' : '(5 default)'}`, () => {\n      const options = {\n        ...optionsCounts,\n        contextLines,\n        expand: false,\n      };\n      if (!validContextLines) {\n        options.patchColor = chalk.dim;\n      }\n\n      const result = diff(\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n        options,\n      );\n      expect(result).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a empty string b empty string",
            "suites": [
                "diffLinesUnified edge cases"
            ],
            "updatePoint": {
                "line": 740,
                "column": 37
            },
            "line": 740,
            "code": "  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a empty string b one line",
            "suites": [
                "diffLinesUnified edge cases"
            ],
            "updatePoint": {
                "line": 750,
                "column": 33
            },
            "line": 750,
            "code": "  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a multiple lines b empty string",
            "suites": [
                "diffLinesUnified edge cases"
            ],
            "updatePoint": {
                "line": 760,
                "column": 39
            },
            "line": 760,
            "code": "  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a one line b multiple lines",
            "suites": [
                "diffLinesUnified edge cases"
            ],
            "updatePoint": {
                "line": 770,
                "column": 35
            },
            "line": 770,
            "code": "  test('a one line b multiple lines', () => {\n    const a = 'line 2';\n    const b = 'line 1\\nline 2\\nline 3';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1\\n  line 2\\n+ line 3';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a empty string b empty string",
            "suites": [
                "diffLinesUnified2 edge cases"
            ],
            "updatePoint": {
                "line": 782,
                "column": 37
            },
            "line": 782,
            "code": "  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a empty string b one line",
            "suites": [
                "diffLinesUnified2 edge cases"
            ],
            "updatePoint": {
                "line": 798,
                "column": 33
            },
            "line": 798,
            "code": "  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a multiple lines b empty string",
            "suites": [
                "diffLinesUnified2 edge cases"
            ],
            "updatePoint": {
                "line": 814,
                "column": 39
            },
            "line": 814,
            "code": "  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a one line b multiple lines",
            "suites": [
                "diffLinesUnified2 edge cases"
            ],
            "updatePoint": {
                "line": 830,
                "column": 35
            },
            "line": 830,
            "code": "  test('a one line b multiple lines', () => {\n    const aDisplay = 'LINE 2';\n    const bDisplay = 'Line 1\\nLine 2\\nLine 3';\n    const aCompare = aDisplay.toLowerCase();\n    const bCompare = bDisplay.toLowerCase();\n\n    const received = diffLinesUnified2(\n      aDisplay.split('\\n'),\n      bDisplay.split('\\n'),\n      aCompare.split('\\n'),\n      bCompare.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ Line 1\\n  Line 2\\n+ Line 3';\n\n    expect(received).toBe(expected);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "a",
            "suites": [
                "diffLinesUnified2 edge cases",
                "lengths not equal"
            ],
            "updatePoint": {
                "line": 851,
                "column": 11
            },
            "line": 851,
            "code": "    test('a', () => {\n      const aDisplay = 'MiXeD cAsE';\n      const bDisplay = 'Mixed case\\nUPPER CASE';\n      const aCompare = `${aDisplay.toLowerCase()}\\nlower case`;\n      const bCompare = bDisplay.toLowerCase();\n\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n      const expected = '- MiXeD cAsE\\n+ Mixed case\\n+ UPPER CASE';\n\n      expect(received).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "b",
            "suites": [
                "diffLinesUnified2 edge cases",
                "lengths not equal"
            ],
            "updatePoint": {
                "line": 869,
                "column": 11
            },
            "line": 869,
            "code": "    test('b', () => {\n      const aDisplay = '{\\n  \"key\": \"value\",\\n}';\n      const bDisplay = '{\\n}';\n      const aCompare = '{\\n\"key\": \"value\",\\n}';\n      const bCompare = '{}';\n\n      const expected = '  {\\n-   \"key\": \"value\",\\n  }';\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n\n      expect(received).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "empty both a and b",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 890,
                "column": 26
            },
            "line": 890,
            "code": "  test('empty both a and b', () => {\n    const a = '';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "empty only a",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 897,
                "column": 20
            },
            "line": 897,
            "code": "  test('empty only a', () => {\n    const a = '';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "empty only b",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 904,
                "column": 20
            },
            "line": 904,
            "code": "  test('empty only b', () => {\n    const a = 'one-line string';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "equal both non-empty",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 911,
                "column": 28
            },
            "line": 911,
            "code": "  test('equal both non-empty', () => {\n    const a = 'one-line string';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "multiline has no common after clean up chaff",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 918,
                "column": 52
            },
            "line": 918,
            "code": "  test('multiline has no common after clean up chaff', () => {\n    const a = 'delete\\ntwo';\n    const b = 'insert\\n2';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "one-line has no common after clean up chaff",
            "suites": [
                "diffStringsUnified edge cases"
            ],
            "updatePoint": {
                "line": 925,
                "column": 51
            },
            "line": 925,
            "code": "  test('one-line has no common after clean up chaff', () => {\n    const a = 'delete';\n    const b = 'insert';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff",
            "suites": [
                "options 7980"
            ],
            "updatePoint": {
                "line": 946,
                "column": 12
            },
            "line": 946,
            "code": "  test('diff', () => {\n    expect(diff(a, b, options)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified",
            "suites": [
                "options 7980"
            ],
            "updatePoint": {
                "line": 950,
                "column": 26
            },
            "line": 950,
            "code": "  test('diffStringsUnified', () => {\n    expect(diffStringsUnified(a, b, options)).toMatchSnapshot();\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff",
            "suites": [
                "options",
                "change indicators"
            ],
            "updatePoint": {
                "line": 968,
                "column": 14
            },
            "line": 968,
            "code": "    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified",
            "suites": [
                "options",
                "change color"
            ],
            "updatePoint": {
                "line": 979,
                "column": 28
            },
            "line": 979,
            "code": "    test('diffStringsUnified', () => {\n      const aChanged = a.join('\\n').replace('change', 'changed');\n      const bChanged = b.join('\\n').replace('change', 'changed');\n      expect(diffStringsUnified(aChanged, bChanged, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "no diff",
            "suites": [
                "options",
                "change color"
            ],
            "updatePoint": {
                "line": 985,
                "column": 17
            },
            "line": 985,
            "code": "    test('no diff', () => {\n      expect(diff(a, a, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff",
            "suites": [
                "options",
                "common"
            ],
            "updatePoint": {
                "line": 996,
                "column": 14
            },
            "line": 996,
            "code": "    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "no diff",
            "suites": [
                "options",
                "common"
            ],
            "updatePoint": {
                "line": 1000,
                "column": 17
            },
            "line": 1000,
            "code": "    test('no diff', () => {\n      expect(diff(a, a, options)).toBe(NO_DIFF_MESSAGE);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffLinesUnified",
            "suites": [
                "options",
                "includeChangeCounts false"
            ],
            "updatePoint": {
                "line": 1010,
                "column": 26
            },
            "line": 1010,
            "code": "    test('diffLinesUnified', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified",
            "suites": [
                "options",
                "includeChangeCounts false"
            ],
            "updatePoint": {
                "line": 1014,
                "column": 28
            },
            "line": 1014,
            "code": "    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffLinesUnified a has 2 digits",
            "suites": [
                "options",
                "includeChangeCounts true padding"
            ],
            "updatePoint": {
                "line": 1026,
                "column": 41
            },
            "line": 1026,
            "code": "    test('diffLinesUnified a has 2 digits', () => {\n      const has2 = 'common\\na\\na\\na\\na\\na\\na\\na\\na\\na\\na';\n      const has1 = 'common\\nb';\n      expect(diff(has2, has1, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffLinesUnified b has 2 digits",
            "suites": [
                "options",
                "includeChangeCounts true padding"
            ],
            "updatePoint": {
                "line": 1032,
                "column": 41
            },
            "line": 1032,
            "code": "    test('diffLinesUnified b has 2 digits', () => {\n      const has1 = 'common\\na';\n      const has2 = 'common\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb';\n      expect(diff(has1, has2, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified",
            "suites": [
                "options",
                "includeChangeCounts true padding"
            ],
            "updatePoint": {
                "line": 1038,
                "column": 28
            },
            "line": 1038,
            "code": "    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff",
            "suites": [
                "options",
                "omitAnnotationLines true"
            ],
            "updatePoint": {
                "line": 1048,
                "column": 14
            },
            "line": 1048,
            "code": "    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified and includeChangeCounts true",
            "suites": [
                "options",
                "omitAnnotationLines true"
            ],
            "updatePoint": {
                "line": 1052,
                "column": 57
            },
            "line": 1052,
            "code": "    test('diffStringsUnified and includeChangeCounts true', () => {\n      const options2 = {...options, includeChangeCounts: true};\n\n      expect(diffStringsUnified(aString, bString, options2)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified empty strings",
            "suites": [
                "options",
                "omitAnnotationLines true"
            ],
            "updatePoint": {
                "line": 1058,
                "column": 42
            },
            "line": 1058,
            "code": "    test('diffStringsUnified empty strings', () => {\n      expect(diffStringsUnified('', '', options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff default no color",
            "suites": [
                "options",
                "trailingSpaceFormatter"
            ],
            "updatePoint": {
                "line": 1075,
                "column": 31
            },
            "line": 1075,
            "code": "    test('diff default no color', () => {\n      expect(diff(aTrailingSpaces, bTrailingSpaces)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff middle dot",
            "suites": [
                "options",
                "trailingSpaceFormatter"
            ],
            "updatePoint": {
                "line": 1079,
                "column": 25
            },
            "line": 1079,
            "code": "    test('diff middle dot', () => {\n      const replaceSpacesWithMiddleDot = (string: string) =>\n        '·'.repeat(string.length);\n      const options = {\n        changeLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n        commonLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff yellowish common",
            "suites": [
                "options",
                "trailingSpaceFormatter"
            ],
            "updatePoint": {
                "line": 1090,
                "column": 31
            },
            "line": 1090,
            "code": "    test('diff yellowish common', () => {\n      const options = {\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diff",
            "suites": [
                "options",
                "emptyFirstOrLastLinePlaceholder default empty string"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 14
            },
            "line": 1116,
            "code": "    test('diff', () => {\n      expect(diff(aEmpty, bEmpty, options)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "diffStringsUnified",
            "suites": [
                "options",
                "emptyFirstOrLastLinePlaceholder default empty string"
            ],
            "updatePoint": {
                "line": 1120,
                "column": 28
            },
            "line": 1120,
            "code": "    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aEmpty, bEmpty, options)).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "keeps the object keys in their original order",
            "suites": [
                "options",
                "compare keys"
            ],
            "updatePoint": {
                "line": 1129,
                "column": 55
            },
            "line": 1129,
            "code": "    test('keeps the object keys in their original order', () => {\n      const compareKeys = () => 0;\n      const expected = [\n        '  Object {',\n        '    \"a\": Object {',\n        '      \"d\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"f\": 1,',\n        '    },',\n        '    \"b\": 1,',\n        '    \"c\": 1,',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "sorts the object keys in reverse order",
            "suites": [
                "options",
                "compare keys"
            ],
            "updatePoint": {
                "line": 1146,
                "column": 48
            },
            "line": 1146,
            "code": "    test('sorts the object keys in reverse order', () => {\n      const compareKeys = (a: string, b: string) => (a > b ? -1 : 1);\n      const expected = [\n        '  Object {',\n        '    \"c\": 1,',\n        '    \"b\": 1,',\n        '    \"a\": Object {',\n        '      \"f\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"d\": 1,',\n        '    },',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "one-line with cleanup",
            "suites": [
                "diffStringsRaw"
            ],
            "updatePoint": {
                "line": 11,
                "column": 29
            },
            "line": 11,
            "code": "  test('one-line with cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'from'),\n      new Diff(DIFF_INSERT, 'to'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', true);\n\n    expect(received).toEqual(expected);\n  });",
            "file": "diffStringsRaw.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "one-line without cleanup",
            "suites": [
                "diffStringsRaw"
            ],
            "updatePoint": {
                "line": 22,
                "column": 32
            },
            "line": 22,
            "code": "  test('one-line without cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'fr'),\n      new Diff(DIFF_INSERT, 't'),\n      new Diff(DIFF_EQUAL, 'o'),\n      new Diff(DIFF_DELETE, 'm'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', false);\n\n    expect(received).toEqual(expected);\n  });",
            "file": "diffStringsRaw.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "change preceding and following common",
            "suites": [
                "getAlignedDiffs",
                "lines"
            ],
            "updatePoint": {
                "line": 35,
                "column": 47
            },
            "line": 35,
            "code": "    test('change preceding and following common', () => {\n      const a = 'delete\\ncommon between changes\\nprev';\n      const b = 'insert\\ncommon between changes\\nnext';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common preceding and following change",
            "suites": [
                "getAlignedDiffs",
                "lines"
            ],
            "updatePoint": {
                "line": 41,
                "column": 47
            },
            "line": 41,
            "code": "    test('common preceding and following change', () => {\n      const a = 'common preceding\\ndelete\\ncommon following';\n      const b = 'common preceding\\ninsert\\ncommon following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common at end when both current change lines are empty",
            "suites": [
                "getAlignedDiffs",
                "lines"
            ],
            "updatePoint": {
                "line": 47,
                "column": 64
            },
            "line": 47,
            "code": "    test('common at end when both current change lines are empty', () => {\n      const a = 'delete\\ncommon at end';\n      const b = 'common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common between delete and insert",
            "suites": [
                "getAlignedDiffs",
                "lines"
            ],
            "updatePoint": {
                "line": 53,
                "column": 42
            },
            "line": 53,
            "code": "    test('common between delete and insert', () => {\n      const a = 'delete\\ncommon between changes';\n      const b = 'common between changes\\ninsert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common between insert and delete",
            "suites": [
                "getAlignedDiffs",
                "lines"
            ],
            "updatePoint": {
                "line": 59,
                "column": 42
            },
            "line": 59,
            "code": "    test('common between insert and delete', () => {\n      const a = 'common between changes\\ndelete';\n      const b = 'insert\\ncommon between changes';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "delete only",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 67,
                "column": 21
            },
            "line": 67,
            "code": "    test('delete only', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precedingfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "insert only",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 73,
                "column": 21
            },
            "line": 73,
            "code": "    test('insert only', () => {\n      const a = 'precedingfollowing';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "delete with adjacent change",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 79,
                "column": 37
            },
            "line": 79,
            "code": "    test('delete with adjacent change', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precededfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "insert with adjacent changes",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 85,
                "column": 38
            },
            "line": 85,
            "code": "    test('insert with adjacent changes', () => {\n      const a = 'precededfollowing';\n      const b = 'preceding\\nFollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "change from space",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 91,
                "column": 27
            },
            "line": 91,
            "code": "    test('change from space', () => {\n      const a = 'preceding following';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "change to space",
            "suites": [
                "getAlignedDiffs",
                "newline"
            ],
            "updatePoint": {
                "line": 97,
                "column": 25
            },
            "line": 97,
            "code": "    test('change to space', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'preceding following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common when both current change lines are empty",
            "suites": [
                "getAlignedDiffs",
                "substrings first"
            ],
            "updatePoint": {
                "line": 105,
                "column": 57
            },
            "line": 105,
            "code": "    test('common when both current change lines are empty', () => {\n      const a = 'first\\nmiddle\\nlast prev';\n      const b = 'insert\\nfirst\\nmiddle\\nlast next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "common when either current change line is non-empty",
            "suites": [
                "getAlignedDiffs",
                "substrings first"
            ],
            "updatePoint": {
                "line": 111,
                "column": 61
            },
            "line": 111,
            "code": "    test('common when either current change line is non-empty', () => {\n      const a = 'expected first\\n\\nlast';\n      const b = 'first\\n\\nlast';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "delete completes the current line",
            "suites": [
                "getAlignedDiffs",
                "substrings first"
            ],
            "updatePoint": {
                "line": 117,
                "column": 43
            },
            "line": 117,
            "code": "    test('delete completes the current line', () => {\n      const a = 'common preceding first\\nmiddle\\nlast and following';\n      const b = 'common preceding and following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "insert completes the current line",
            "suites": [
                "getAlignedDiffs",
                "substrings first"
            ],
            "updatePoint": {
                "line": 123,
                "column": 43
            },
            "line": 123,
            "code": "    test('insert completes the current line', () => {\n      const a = 'common preceding';\n      const b = 'common preceding first\\nmiddle\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is empty in delete between common",
            "suites": [
                "getAlignedDiffs",
                "substrings middle"
            ],
            "updatePoint": {
                "line": 131,
                "column": 43
            },
            "line": 131,
            "code": "    test('is empty in delete between common', () => {\n      const a = 'common at start precedes delete\\n\\nexpected common at end';\n      const b = 'common at start precedes received common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is empty in insert at start",
            "suites": [
                "getAlignedDiffs",
                "substrings middle"
            ],
            "updatePoint": {
                "line": 137,
                "column": 37
            },
            "line": 137,
            "code": "    test('is empty in insert at start', () => {\n      const a = 'expected common at end';\n      const b = 'insert line\\n\\nreceived common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is non-empty in delete at end",
            "suites": [
                "getAlignedDiffs",
                "substrings middle"
            ],
            "updatePoint": {
                "line": 143,
                "column": 39
            },
            "line": 143,
            "code": "    test('is non-empty in delete at end', () => {\n      const a = 'common at start precedes delete\\nnon-empty line\\nnext';\n      const b = 'common at start precedes prev';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is non-empty in insert between common",
            "suites": [
                "getAlignedDiffs",
                "substrings middle"
            ],
            "updatePoint": {
                "line": 149,
                "column": 47
            },
            "line": 149,
            "code": "    test('is non-empty in insert between common', () => {\n      const a = 'common at start precedes delete expected';\n      const b = 'common at start precedes insert\\nnon-empty\\nreceived';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is empty in delete at end",
            "suites": [
                "getAlignedDiffs",
                "substrings last"
            ],
            "updatePoint": {
                "line": 157,
                "column": 35
            },
            "line": 157,
            "code": "    test('is empty in delete at end', () => {\n      const a = 'common string preceding prev\\n';\n      const b = 'common string preceding next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is empty in insert at end",
            "suites": [
                "getAlignedDiffs",
                "substrings last"
            ],
            "updatePoint": {
                "line": 163,
                "column": 35
            },
            "line": 163,
            "code": "    test('is empty in insert at end', () => {\n      const a = 'common string preceding prev';\n      const b = 'common string preceding next\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "is non-empty in common not at end",
            "suites": [
                "getAlignedDiffs",
                "substrings last"
            ],
            "updatePoint": {
                "line": 169,
                "column": 43
            },
            "line": 169,
            "code": "    test('is non-empty in common not at end', () => {\n      const a = 'common first\\nlast expected';\n      const b = 'common first\\nlast received';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "change at start and delete or insert at end",
            "suites": [
                "getAlignedDiffs",
                "strings"
            ],
            "updatePoint": {
                "line": 177,
                "column": 53
            },
            "line": 177,
            "code": "    test('change at start and delete or insert at end', () => {\n      const a = 'prev change common delete\\nunchanged\\nexpected change common';\n      const b = 'next change common\\nunchanged\\nreceived change common insert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "delete or insert at start and change at end",
            "suites": [
                "getAlignedDiffs",
                "strings"
            ],
            "updatePoint": {
                "line": 183,
                "column": 53
            },
            "line": 183,
            "code": "    test('delete or insert at start and change at end', () => {\n      const a = 'common change prev\\nunchanged\\ndelete common change this';\n      const b = 'insert common change next\\nunchanged\\ncommon change that';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });",
            "file": "getAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "first line is empty common",
            "suites": [
                "joinAlignedDiffsExpand"
            ],
            "updatePoint": {
                "line": 74,
                "column": 34
            },
            "line": 74,
            "code": "  test('first line is empty common', () => {\n    const options = normalizeDiffOptions(optionsNoColor);\n\n    expect(\n      joinAlignedDiffsExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "patch 0 with context 1 and change at start and end",
            "suites": [
                "joinAlignedDiffsNoExpand"
            ],
            "updatePoint": {
                "line": 84,
                "column": 58
            },
            "line": 84,
            "code": "  test('patch 0 with context 1 and change at start and end', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 1,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsChangeStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "patch 0 with context 5 and first line is empty common",
            "suites": [
                "joinAlignedDiffsNoExpand"
            ],
            "updatePoint": {
                "line": 96,
                "column": 61
            },
            "line": 96,
            "code": "  test('patch 0 with context 5 and first line is empty common', () => {\n    const options = normalizeDiffOptions({...optionsNoColor, expand: false});\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "patch 1 with context 4 and last line is empty common",
            "suites": [
                "joinAlignedDiffsNoExpand"
            ],
            "updatePoint": {
                "line": 104,
                "column": 60
            },
            "line": 104,
            "code": "  test('patch 1 with context 4 and last line is empty common', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 4,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "patch 2 with context 3",
            "suites": [
                "joinAlignedDiffsNoExpand"
            ],
            "updatePoint": {
                "line": 116,
                "column": 30
            },
            "line": 116,
            "code": "  test('patch 2 with context 3', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 3,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "patch 3 with context 2 and omit excess common at start",
            "suites": [
                "joinAlignedDiffsNoExpand"
            ],
            "updatePoint": {
                "line": 128,
                "column": 62
            },
            "line": 128,
            "code": "  test('patch 3 with context 2 and omit excess common at start', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 2,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });",
            "file": "joinAlignedDiffs.test.ts",
            "skipped": false,
            "dir": "packages/jest-diff/src/__tests__"
        },
        {
            "name": "extracts valid docblock with line comment",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 12,
                "column": 47
            },
            "line": 12,
            "code": "  it('extracts valid docblock with line comment', () => {\n    const code = `/**${EOL} * @team foo${EOL}* // TODO: test${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(\n      `/**${EOL} * @team foo${EOL}* // TODO: test${EOL}*/`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts valid docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 19,
                "column": 29
            },
            "line": 19,
            "code": "  it('extracts valid docblock', () => {\n    const code = `/**${EOL} * @team foo${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(`/**${EOL} * @team foo${EOL}*/`);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts valid docblock with more comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 24,
                "column": 48
            },
            "line": 24,
            "code": "  it('extracts valid docblock with more comments', () => {\n    const code = `/**${EOL} * @team foo${EOL}*/${EOL}const x = foo;${EOL}/**foo*/`;\n    expect(docblock.extract(code)).toBe(`/**${EOL} * @team foo${EOL}*/`);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts from invalid docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 29,
                "column": 36
            },
            "line": 29,
            "code": "  it('extracts from invalid docblock', () => {\n    const code = `/*${EOL} * @team foo${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(`/*${EOL} * @team foo${EOL}*/`);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts from invalid docblock singleline",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 34,
                "column": 47
            },
            "line": 34,
            "code": "  it('extracts from invalid docblock singleline', () => {\n    const code = `/* some comment @team foo */${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe('/* some comment @team foo */');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "returns extract and parsedocblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 39,
                "column": 39
            },
            "line": 39,
            "code": "  it('returns extract and parsedocblock', () => {\n    const code = `/** @provides module-name */${EOL}${EOL}.dummy {}${EOL}`;\n\n    expect(docblock.parse(docblock.extract(code))).toEqual({\n      provides: 'module-name',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses directives out of a docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 47,
                "column": 41
            },
            "line": 47,
            "code": "  it('parses directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @team foo${EOL}` +\n      ` * @css a b${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      css: 'a b',\n      'preserve-whitespace': '',\n      team: 'foo',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses multiple of the same directives out of a docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 61,
                "column": 62
            },
            "line": 61,
            "code": "  it('parses multiple of the same directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @x foo${EOL}` +\n      ` * @x bar${EOL}` +\n      ` * @y${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      x: ['foo', 'bar'],\n      y: '',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses >=3 of the same directives out of a docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 74,
                "column": 57
            },
            "line": 74,
            "code": "  it('parses >=3 of the same directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @x foo${EOL}` +\n      ` * @x bar${EOL}` +\n      ` * @x baz${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      x: ['foo', 'bar', 'baz'],\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses directives out of a docblock with comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 86,
                "column": 55
            },
            "line": 86,
            "code": "  it('parses directives out of a docblock with comments', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.${EOL}` +\n      ` * @team foo${EOL}` +\n      ` * @css a b${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      css: 'a b',\n      'preserve-whitespace': '',\n      team: 'foo',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses directives out of a docblock with line comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 103,
                "column": 60
            },
            "line": 103,
            "code": "  it('parses directives out of a docblock with line comments', () => {\n    const code = `/**${EOL} * @team foo${EOL} * // TODO: test${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// TODO: test',\n      pragmas: {team: 'foo'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses multiline directives",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 111,
                "column": 33
            },
            "line": 111,
            "code": "  it('parses multiline directives', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.${EOL}` +\n      ` * @class A long declaration of a class${EOL}` +\n      ` *        goes here, so we can read it and enjoy${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      class:\n        'A long declaration of a class goes here, ' +\n        'so we can read it and enjoy',\n      'preserve-whitespace': '',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "parses multiline directives even if there are linecomments within the docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 129,
                "column": 84
            },
            "line": 129,
            "code": "  it('parses multiline directives even if there are linecomments within the docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.${EOL}` +\n      ` * @class A long declaration of a class${EOL}` +\n      ` *        goes here, so we can read it and enjoy${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      '// heres a comment' +\n      ' */';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.${EOL}${EOL}And some license here${EOL}// heres a comment`,\n      pragmas: {\n        class:\n          'A long declaration of a class goes here, ' +\n          'so we can read it and enjoy',\n        'preserve-whitespace': '',\n      },\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "supports slashes in @team directive",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 151,
                "column": 41
            },
            "line": 151,
            "code": "  it('supports slashes in @team directive', () => {\n    const code = `/**${EOL} * @team apple/banana${EOL} */`;\n    expect(docblock.parse(code)).toEqual({\n      team: 'apple/banana',\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts comments from docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 158,
                "column": 37
            },
            "line": 158,
            "code": "  it('extracts comments from docblock', () => {\n    const code = `/**${EOL} * hello world${EOL} * @flow yes${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'hello world',\n      pragmas: {flow: 'yes'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts multiline comments from docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 166,
                "column": 47
            },
            "line": 166,
            "code": "  it('extracts multiline comments from docblock', () => {\n    const code = `/**${EOL} * hello${EOL} * world${EOL} * @flow yes${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `hello${EOL}world`,\n      pragmas: {flow: 'yes'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "preserves leading whitespace in multiline comments from docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 174,
                "column": 70
            },
            "line": 174,
            "code": "  it('preserves leading whitespace in multiline comments from docblock', () => {\n    const code = `/**${EOL} *  hello${EOL} *   world${EOL} */`;\n\n    expect(docblock.parseWithComments(code).comments).toBe(\n      ` hello${EOL}  world`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "removes leading newlines in multiline comments from docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 182,
                "column": 66
            },
            "line": 182,
            "code": "  it('removes leading newlines in multiline comments from docblock', () => {\n    const code = `/**${EOL} * @snailcode${EOL} *${EOL} *  hello world${EOL} */`;\n\n    expect(docblock.parseWithComments(code).comments).toBe(' hello world');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts comments from beginning and end of docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 188,
                "column": 58
            },
            "line": 188,
            "code": "  it('extracts comments from beginning and end of docblock', () => {\n    const code = `/**${EOL} * hello${EOL} * @flow yes${EOL} * ${EOL} * world${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `hello${EOL}${EOL}world`,\n      pragmas: {flow: 'yes'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "preserve urls within a pragma's values",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 196,
                "column": 44
            },
            "line": 196,
            "code": "  it(\"preserve urls within a pragma's values\", () => {\n    const code = `/**${EOL} * @see: https://example.com${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '',\n      pragmas: {'see:': 'https://example.com'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "strip linecomments from pragmas but preserve for comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 204,
                "column": 63
            },
            "line": 204,
            "code": "  it('strip linecomments from pragmas but preserve for comments', () => {\n    const code = `/**${EOL} * @format: everything${EOL}// keep me */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// keep me',\n      pragmas: {'format:': 'everything'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extract from invalid docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 212,
                "column": 35
            },
            "line": 212,
            "code": "  it('extract from invalid docblock', () => {\n    const code = `/* @format: everything${EOL}// keep me */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// keep me',\n      pragmas: {'format:': 'everything'},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extract from invalid docblock singleline",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 220,
                "column": 46
            },
            "line": 220,
            "code": "  it('extract from invalid docblock singleline', () => {\n    const code = '/* some test */';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: ' some test',\n      pragmas: {},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts docblock comments as CRLF when docblock contains CRLF",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 228,
                "column": 68
            },
            "line": 228,
            "code": "  it('extracts docblock comments as CRLF when docblock contains CRLF', () => {\n    const code = '/**\\r\\n * foo\\r\\n * bar\\r\\n*/';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'foo\\r\\nbar',\n      pragmas: {},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "extracts docblock comments as LF when docblock contains LF",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 236,
                "column": 64
            },
            "line": 236,
            "code": "  it('extracts docblock comments as LF when docblock contains LF', () => {\n    const code = '/**\\n * foo\\n * bar\\n*/';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'foo\\nbar',\n      pragmas: {},\n    });\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "strips the docblock out of a file that contains a top docblock",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 244,
                "column": 68
            },
            "line": 244,
            "code": "  it('strips the docblock out of a file that contains a top docblock', () => {\n    const code = '/**\\n * foo\\n * bar\\n*/\\nthe rest';\n    expect(docblock.strip(code)).toBe('\\nthe rest');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "returns a file unchanged if there is no top docblock to strip",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 249,
                "column": 67
            },
            "line": 249,
            "code": "  it('returns a file unchanged if there is no top docblock to strip', () => {\n    const code = 'someCodeAtTheTop();\\n/** docblock */';\n    expect(docblock.strip(code)).toEqual(code);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with no pragmas as empty string",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 254,
                "column": 54
            },
            "line": 254,
            "code": "  it('prints docblocks with no pragmas as empty string', () => {\n    const pragmas = {};\n    expect(docblock.print({pragmas})).toBe('');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with one pragma on one line",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 259,
                "column": 50
            },
            "line": 259,
            "code": "  it('prints docblocks with one pragma on one line', () => {\n    const pragmas = {flow: ''};\n    expect(docblock.print({pragmas})).toBe('/** @flow */');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with multiple pragmas on multiple lines",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 264,
                "column": 62
            },
            "line": 264,
            "code": "  it('prints docblocks with multiple pragmas on multiple lines', () => {\n    const pragmas = {\n      flow: '',\n      format: '',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @flow${EOL} * @format${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with multiple of the same pragma",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 274,
                "column": 55
            },
            "line": 274,
            "code": "  it('prints docblocks with multiple of the same pragma', () => {\n    const pragmas = {\n      x: ['a', 'b'],\n      y: 'c',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @x a${EOL} * @x b${EOL} * @y c${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with pragmas",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 283,
                "column": 35
            },
            "line": 283,
            "code": "  it('prints docblocks with pragmas', () => {\n    const pragmas = {\n      flow: 'foo',\n      team: 'x/y/z',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @flow foo${EOL} * @team x/y/z${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 293,
                "column": 36
            },
            "line": 293,
            "code": "  it('prints docblocks with comments', () => {\n    const pragmas = {flow: 'foo'};\n    const comments = 'hello';\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * hello${EOL} *${EOL} * @flow foo${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with comments and no keys",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 301,
                "column": 48
            },
            "line": 301,
            "code": "  it('prints docblocks with comments and no keys', () => {\n    const pragmas = {};\n    const comments =\n      'Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.';\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * ${comments}${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks with multiline comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 310,
                "column": 46
            },
            "line": 310,
            "code": "  it('prints docblocks with multiline comments', () => {\n    const pragmas = {};\n    const comments = `hello${EOL}world`;\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * hello${EOL} * world${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks that are parseable",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 318,
                "column": 41
            },
            "line": 318,
            "code": "  it('prints docblocks that are parseable', () => {\n    const pragmas = {a: 'b', c: ''};\n    const comments = 'hello world!';\n    const formatted = docblock.print({comments, pragmas});\n    const parsed = docblock.parse(formatted);\n    expect(parsed).toEqual(pragmas);\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "can augment existing docblocks with comments",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 326,
                "column": 50
            },
            "line": 326,
            "code": "  it('can augment existing docblocks with comments', () => {\n    const before = `/**${EOL} * Legalese${EOL} * @flow${EOL} */`;\n    const {comments, pragmas} = docblock.parseWithComments(before);\n    pragmas.format = '';\n    const after = docblock.print({comments, pragmas});\n    expect(after).toBe(\n      `/**${EOL} * Legalese${EOL} *${EOL} * @flow${EOL} * @format${EOL} */`,\n    );\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks using CRLF if comments contains CRLF",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 336,
                "column": 59
            },
            "line": 336,
            "code": "  it('prints docblocks using CRLF if comments contains CRLF', () => {\n    const pragmas = {};\n    const comments = 'hello\\r\\nworld';\n    const formatted = docblock.print({comments, pragmas});\n    expect(formatted).toBe('/**\\r\\n * hello\\r\\n * world\\r\\n */');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        },
        {
            "name": "prints docblocks using LF if comments contains LF",
            "suites": [
                "docblock"
            ],
            "updatePoint": {
                "line": 343,
                "column": 55
            },
            "line": 343,
            "code": "  it('prints docblocks using LF if comments contains LF', () => {\n    const pragmas = {};\n    const comments = 'hello\\nworld';\n    const formatted = docblock.print({comments, pragmas});\n    expect(formatted).toBe('/**\\n * hello\\n * world\\n */');\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/jest-docblock/src/__tests__"
        }
    ],
    "error": "Cannot read properties of undefined (reading 'object')"
}