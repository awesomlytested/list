{"repo":"luin/ioredis","url":"https://github.com/luin/ioredis","branch":"master","configs":[{"package":"ioredis","lang":"js","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"discovers nodes from master","suites":["cluster"],"updatePoint":{"line":17,"column":33,"index":506},"line":17,"code":"  it(\"discovers nodes from master\", async () => {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: masters[0]\n    }]);\n    await cluster.set(\"foo\", \"bar\");\n    expect(await cluster.get(\"foo\")).to.eql(\"bar\");\n  });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"discovers nodes from replica","suites":["cluster"],"updatePoint":{"line":25,"column":34,"index":744},"line":25,"code":"  it(\"discovers nodes from replica\", async () => {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: replicas[0]\n    }]);\n    await cluster.set(\"foo\", \"bar\");\n    expect(await cluster.get(\"foo\")).to.eql(\"bar\");\n  });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"returns master nodes","suites":["cluster","#nodes()"],"updatePoint":{"line":34,"column":28,"index":1008},"line":34,"code":"    it(\"returns master nodes\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      await cluster.info();\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.map(node => node.options.port).sort()).to.eql(masters);\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"returns replica nodes","suites":["cluster","#nodes()"],"updatePoint":{"line":43,"column":29,"index":1310},"line":43,"code":"    it(\"returns replica nodes\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      await cluster.info();\n      const nodes = cluster.nodes(\"slave\");\n      expect(nodes.map(node => node.options.port).sort()).to.eql(replicas);\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"returns all nodes","suites":["cluster","#nodes()"],"updatePoint":{"line":52,"column":25,"index":1608},"line":52,"code":"    it(\"returns all nodes\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      await cluster.info();\n      const nodes = cluster.nodes();\n      expect(nodes.map(node => node.options.port).sort()).to.eql(masters.concat(replicas));\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"ensures non-readonly commands still working","suites":["cluster","scaleReads"],"updatePoint":{"line":63,"column":51,"index":1980},"line":63,"code":"    it(\"ensures non-readonly commands still working\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }], {\n        scaleReads: \"slave\"\n      });\n      await cluster.set(\"foo\", \"bar\");\n      expect(await cluster.get(\"foo\")).to.eql(\"bar\");\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"ensures script ordering when not loaded","suites":["cluster","pipeline"],"updatePoint":{"line":75,"column":47,"index":2321},"line":75,"code":"    it(\"ensures script ordering when not loaded\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      cluster.defineCommand(\"myget\", {\n        numberOfKeys: 1,\n        lua: \"return redis.call('GET', KEYS[1])\"\n      });\n      expect(await cluster.pipeline()\n      // @ts-expect-error\n      .myget(\"foo\").set(\"foo\", \"setAfterMyGET\").myget(\"foo\").exec()).to.eql([[null, null], [null, \"OK\"], [null, \"setAfterMyGET\"]]);\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"falls back to eval when the cache is flushed","suites":["cluster","pipeline"],"updatePoint":{"line":88,"column":52,"index":2817},"line":88,"code":"    it(\"falls back to eval when the cache is flushed\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      cluster.defineCommand(\"myget\", {\n        numberOfKeys: 1,\n        lua: \"return redis.call('GET', KEYS[1])\"\n      });\n\n      // @ts-expect-error\n      await cluster.myget(\"foo\");\n      for (const node of cluster.nodes(\"master\")) {\n        await node.script(\"FLUSH\");\n      }\n      expect(await cluster.pipeline()\n      // @ts-expect-error\n      .myget(\"foo\").set(\"foo\", \"setAfterMyGET\").myget(\"foo\").exec()).to.eql([[null, \"setAfterMyGET\"], [null, \"OK\"], [null, \"setAfterMyGET\"]]);\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"works","suites":["cluster","auto pipelining"],"updatePoint":{"line":109,"column":13,"index":3486},"line":109,"code":"    it(\"works\", async () => {\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }], {\n        enableAutoPipelining: true\n      });\n      cluster.set(\"foo\", \"auto pipelining\");\n      expect(await cluster.get(\"foo\")).to.eql(\"auto pipelining\");\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"works when passing via redisOptions","suites":["cluster","key prefixing"],"updatePoint":{"line":121,"column":43,"index":3853},"line":121,"code":"    it(\"works when passing via redisOptions\", async () => {\n      const cluster1 = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }], {\n        redisOptions: {\n          keyPrefix: \"prefix:\"\n        }\n      });\n      await cluster1.set(\"foo\", \"bar\");\n      const cluster2 = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      expect(await cluster2.get(\"prefix:foo\")).to.eql(\"bar\");\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"works when passing via root","suites":["cluster","key prefixing"],"updatePoint":{"line":137,"column":35,"index":4293},"line":137,"code":"    it(\"works when passing via root\", async () => {\n      const cluster1 = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }], {\n        keyPrefix: \"prefix:\"\n      });\n      await cluster1.set(\"foo\", \"bar\");\n      const cluster2 = new Cluster([{\n        host: \"127.0.0.1\",\n        port: masters[0]\n      }]);\n      expect(await cluster2.get(\"prefix:foo\")).to.eql(\"bar\");\n    });","file":"cluster/basic.ts","skipped":false,"dir":"test"},{"name":"should send auth before other commands","suites":["auth"],"updatePoint":{"line":7,"column":44,"index":268},"line":7,"code":"  it(\"should send auth before other commands\", done => {\n    let authed = false;\n    new MockServer(17379, argv => {\n      if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n        authed = true;\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(authed).to.eql(true);\n        redis.disconnect();\n        done();\n      }\n    });\n    const redis = new Redis({\n      port: 17379,\n      password: \"pass\"\n    });\n    redis.get(\"foo\").catch(() => {});\n  });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should resend auth after reconnect","suites":["auth"],"updatePoint":{"line":24,"column":40,"index":738},"line":24,"code":"  it(\"should resend auth after reconnect\", done => {\n    let begin = false;\n    let authed = false;\n    new MockServer(17379, argv => {\n      if (!begin) {\n        return;\n      }\n      if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n        authed = true;\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(authed).to.eql(true);\n        redis.disconnect();\n        done();\n      }\n    });\n    const redis = new Redis({\n      port: 17379,\n      password: \"pass\"\n    });\n    redis.once(\"ready\", () => {\n      begin = true;\n      redis.disconnect(true);\n      redis.get(\"foo\").catch(() => {});\n    });\n  });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle auth with Redis URL string (redis://:foo@bar.com/) correctly","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":50,"column":82,"index":1452},"line":50,"code":"    it(\"should handle auth with Redis URL string (redis://:foo@bar.com/) correctly\", done => {\n      const password = \"pass\";\n      let redis;\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis(`redis://:${password}@localhost:17379/`);\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should not emit \"error\" when the server doesn't need auth","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":61,"column":66,"index":1817},"line":61,"code":"    it('should not emit \"error\" when the server doesn\\'t need auth', done => {\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR Client sent AUTH, but no password is set\");\n        }\n      });\n      let errorEmitted = false;\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      redis.on(\"error\", () => {\n        errorEmitted = true;\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"but a password was supplied\") !== -1) {\n          stub.restore();\n          setTimeout(() => {\n            expect(errorEmitted).to.eql(false);\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when the password is wrong","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":86,"column":54,"index":2598},"line":86,"code":"    it('should emit \"error\" when the password is wrong', done => {\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR invalid password\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      let pending = 2;\n      function check() {\n        if (! --pending) {\n          redis.disconnect();\n          done();\n        }\n      }\n      redis.on(\"error\", error => {\n        expect(error).to.have.property(\"message\", \"ERR invalid password\");\n        check();\n      });\n      redis.get(\"foo\", function (err, res) {\n        expect(err.message).to.eql(\"ERR invalid password\");\n        check();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when password is not provided","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":112,"column":57,"index":3340},"line":112,"code":"    it('should emit \"error\" when password is not provided', done => {\n      new MockServer(17379, argv => {\n        if (argv[0] === \"info\") {\n          return new Error(\"NOAUTH Authentication required.\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379\n      });\n      redis.on(\"error\", error => {\n        expect(error).to.have.property(\"message\", \"NOAUTH Authentication required.\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when username and password are set for a Redis 5 server","suites":["auth","auth:redis5-specific"],"updatePoint":{"line":127,"column":83,"index":3836},"line":127,"code":"    it('should emit \"error\" when username and password are set for a Redis 5 server', done => {\n      let username = \"user\";\n      let password = \"password\";\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          return new Error(\"ERR wrong number of arguments for 'auth' command\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379,\n        username,\n        password\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"You are probably passing both username and password to Redis version 5 or below\") !== -1) {\n          stub.restore();\n          setTimeout(() => {\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle username and password auth (Redis >=6) correctly","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":153,"column":70,"index":4717},"line":153,"code":"    it(\"should handle username and password auth (Redis >=6) correctly\", done => {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username,\n        password\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should handle auth with Redis URL string with username and password (Redis >=6) (redis://foo:bar@baz.com/) correctly","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":169,"column":124,"index":5217},"line":169,"code":"    it(\"should handle auth with Redis URL string with username and password (Redis >=6) (redis://foo:bar@baz.com/) correctly\", done => {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === username && argv[2] === password) {\n          redis.disconnect();\n          done();\n        }\n      });\n      redis = new Redis(`redis://user:pass@localhost:17379/?allowUsernameInURI=true`);\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should not emit \"error\" when the Redis >=6 server doesn't need auth","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":181,"column":76,"index":5664},"line":181,"code":"    it('should not emit \"error\" when the Redis >=6 server doesn\\'t need auth', done => {\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          return new Error(\"ERR AUTH <password> called without any password configured for the default user. Are you sure your configuration is correct?\");\n        }\n      });\n      let errorEmited = false;\n      const redis = new Redis({\n        port: 17379,\n        password: \"pass\"\n      });\n      redis.on(\"error\", () => {\n        errorEmited = true;\n      });\n      const stub = sinon.stub(console, \"warn\").callsFake(warn => {\n        if (warn.indexOf(\"`default` user does not require a password\") !== -1) {\n          stub.restore();\n          setTimeout(() => {\n            expect(errorEmited).to.eql(false);\n            redis.disconnect();\n            done();\n          }, 0);\n        }\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when passing username but not password to Redis >=6 instance","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":206,"column":88,"index":6571},"line":206,"code":"    it('should emit \"error\" when passing username but not password to Redis >=6 instance', done => {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\") {\n          if (argv[1] === username && argv[2] === password) {\n            return \"OK\";\n          } else {\n            return new Error(\"WRONGPASS invalid username-password pair\");\n          }\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username\n      });\n      redis.on(\"error\", error => {\n        expect(error).to.have.property(\"message\", \"WRONGPASS invalid username-password pair\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when the password is wrong","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":229,"column":54,"index":7263},"line":229,"code":"    it('should emit \"error\" when the password is wrong', done => {\n      let username = \"user\";\n      let password = \"pass\";\n      let redis;\n      new MockServer(17379, argv => {\n        if (argv[0] === \"auth\") {\n          if (argv[1] === username && argv[2] === password) {\n            return \"OK\";\n          } else {\n            return new Error(\"WRONGPASS invalid username-password pair\");\n          }\n        }\n      });\n      redis = new Redis({\n        port: 17379,\n        username,\n        password: \"notpass\"\n      });\n      redis.on(\"error\", error => {\n        expect(error).to.have.property(\"message\", \"WRONGPASS invalid username-password pair\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should emit \"error\" when password is required but not provided","suites":["auth","auth:redis6-specific"],"updatePoint":{"line":253,"column":70,"index":8000},"line":253,"code":"    it('should emit \"error\" when password is required but not provided', done => {\n      new MockServer(17379, argv => {\n        if (argv[0] === \"info\") {\n          return new Error(\"NOAUTH Authentication required.\");\n        }\n      });\n      const redis = new Redis({\n        port: 17379\n      });\n      redis.on(\"error\", error => {\n        expect(error).to.have.property(\"message\", \"NOAUTH Authentication required.\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/auth.ts","skipped":false,"dir":"test"},{"name":"should automatic add commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":5,"column":53,"index":212},"line":5,"code":"  it(\"should automatic add commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise = redis.get(\"foo\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    const res = await promise;\n    expect(res).to.eql(\"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add non-compatible commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":17,"column":62,"index":656},"line":17,"code":"  it(\"should not add non-compatible commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promises = [];\n    promises.push(redis.subscribe(\"subscribe\").catch(() => {}));\n    promises.push(redis.unsubscribe(\"subscribe\").catch(() => {}));\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    await promises;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should work with db parameter","suites":["autoPipelining for single node"],"updatePoint":{"line":28,"column":35,"index":1064},"line":28,"code":"  it(\"should work with db parameter\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true,\n      db: 1\n    });\n    redis.set(\"foo\", \"bar\");\n    await new Promise(resolve => {\n      redis.once(\"ready\", resolve);\n    });\n    expect(await redis.get(\"foo\")).to.eql(\"bar\");\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add blacklisted commands to auto pipelines","suites":["autoPipelining for single node"],"updatePoint":{"line":39,"column":59,"index":1388},"line":39,"code":"  it(\"should not add blacklisted commands to auto pipelines\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true,\n      autoPipeliningIgnoredCommands: [\"hmget\"]\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise = redis.hmget(\"foo\").catch(() => {});\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    await promise;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support buffer commands","suites":["autoPipelining for single node"],"updatePoint":{"line":49,"column":36,"index":1743},"line":49,"code":"  it(\"should support buffer commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    const buffer = Buffer.from(\"bar\");\n    await redis.set(\"foo\", buffer);\n    const promise = redis.getBuffer(\"foo\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql(buffer);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support custom commands","suites":["autoPipelining for single node"],"updatePoint":{"line":59,"column":36,"index":2085},"line":59,"code":"  it(\"should support custom commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    redis.defineCommand(\"myecho\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n\n    // @ts-expect-error\n    const promise = redis.myecho(\"foo1\", \"foo2\", \"bar1\", \"bar2\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql([\"foo1\", \"foo2\", \"bar1\", \"bar2\"]);\n\n    // @ts-expect-error\n    await redis.myecho(\"foo1\", \"foo2\", \"bar1\", \"bar2\");\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support call()","suites":["autoPipelining for single node"],"updatePoint":{"line":76,"column":27,"index":2618},"line":76,"code":"  it(\"should support call()\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.call(\"set\", \"foo\", \"call()\");\n    expect(await Promise.all([redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\")])).to.eql([\"call()\", \"call()\", \"call()\", \"call()\", \"call()\"]);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support multiple commands","suites":["autoPipelining for single node"],"updatePoint":{"line":83,"column":38,"index":2978},"line":83,"code":"  it(\"should support multiple commands\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    expect(await Promise.all([redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\")])).to.eql([\"bar\", \"bar\", \"bar\", \"bar\", \"bar\"]);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support commands queued after a pipeline is already queued for execution","suites":["autoPipelining for single node"],"updatePoint":{"line":90,"column":85,"index":3359},"line":90,"code":"  it(\"should support commands queued after a pipeline is already queued for execution\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    let value1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", () => {});\n    redis.set(\"foo2\", \"bar2\", () => {});\n    redis.get(\"foo1\", (err, v1) => {\n      expect(err).to.eql(null);\n      value1 = v1;\n    });\n    process.nextTick(() => {\n      redis.get(\"foo2\", (err, value2) => {\n        expect(err).to.eql(null);\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar2\");\n        expect(redis.autoPipelineQueueSize).to.eql(0);\n        done();\n      });\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(3);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should correctly track pipeline length","suites":["autoPipelining for single node"],"updatePoint":{"line":113,"column":44,"index":4062},"line":113,"code":"  it(\"should correctly track pipeline length\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise1 = redis.set(\"foo\", \"bar\");\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    await promise1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    const promise2 = Promise.all([redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\"), redis.get(\"foo\")]);\n    expect(redis.autoPipelineQueueSize).to.eql(5);\n    await promise2;\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle rejections","suites":["autoPipelining for single node"],"updatePoint":{"line":126,"column":30,"index":4602},"line":126,"code":"  it(\"should handle rejections\", async () => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    await redis.set(\"foo\", \"bar\");\n    // @ts-expect-error\n    await expect(redis.set(\"foo\")).to.eventually.be.rejectedWith(\"ERR wrong number of arguments for 'set' command\");\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the happy case","suites":["autoPipelining for single node"],"updatePoint":{"line":134,"column":48,"index":4920},"line":134,"code":"  it(\"should support callbacks in the happy case\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    let value1;\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", () => {});\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n    redis.set(\"foo2\", \"bar2\", () => {\n      redis.get(\"foo1\", (err, v1) => {\n        expect(err).to.eql(null);\n        value1 = v1;\n      });\n      expect(redis.autoPipelineQueueSize).to.eql(1);\n      redis.get(\"foo2\", (err, value2) => {\n        expect(err).to.eql(null);\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar2\");\n        expect(redis.autoPipelineQueueSize).to.eql(0);\n        done();\n      });\n      expect(redis.autoPipelineQueueSize).to.eql(2);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the failure case","suites":["autoPipelining for single node"],"updatePoint":{"line":159,"column":50,"index":5762},"line":159,"code":"  it(\"should support callbacks in the failure case\", done => {\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", err => {\n      expect(err).to.eql(null);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(1);\n\n    // @ts-expect-error\n    redis.set(\"foo2\", err => {\n      expect(err.message).to.include(\"ERR wrong number of arguments for 'set' command\");\n      done();\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle callbacks failures","suites":["autoPipelining for single node"],"updatePoint":{"line":176,"column":38,"index":6289},"line":176,"code":"  it(\"should handle callbacks failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n      done();\n    });\n    const redis = new Redis({\n      enableAutoPipelining: true\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(0);\n    redis.set(\"foo1\", \"bar1\", err => {\n      expect(err).to.eql(null);\n      throw new Error(\"ERROR\");\n    });\n    redis.set(\"foo2\", \"bar2\", err => {\n      expect(err).to.eql(null);\n      expect(redis.autoPipelineQueueSize).to.eql(0);\n    });\n    expect(redis.autoPipelineQueueSize).to.eql(2);\n  });","file":"functional/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support ASK","suites":["cluster:ASK"],"updatePoint":{"line":6,"column":24,"index":231},"line":6,"code":"  it(\"should support ASK\", done => {\n    let asked = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n      } else if (argv[0] === \"asking\") {\n        asked = true;\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (++times === 2) {\n          process.nextTick(() => {\n            cluster.disconnect();\n            done();\n          });\n        } else {\n          return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n        }\n      }\n    });\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\", () => {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/ask.ts","skipped":false,"dir":"test"},{"name":"should be able to redirect a command to a unknown node","suites":["cluster:ASK"],"updatePoint":{"line":45,"column":60,"index":1356},"line":45,"code":"  it(\"should be able to redirect a command to a unknown node\", done => {\n    let asked = false;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n        return \"bar\";\n      } else if (argv[0] === \"asking\") {\n        asked = true;\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }]);\n    cluster.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/ask.ts","skipped":false,"dir":"test"},{"name":"should automatic add commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":74,"column":53,"index":2310},"line":74,"code":"  it(\"should automatic add commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise = cluster.get(\"foo1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(1);\n    const res = await promise;\n    expect(res).to.eql(\"bar1\");\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add non-compatible commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":88,"column":62,"index":2873},"line":88,"code":"  it(\"should not add non-compatible commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promises = [];\n    promises.push(cluster.subscribe(\"subscribe\").catch(() => {}));\n    promises.push(cluster.unsubscribe(\"subscribe\").catch(() => {}));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    await promises;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should not add blacklisted commands to auto pipelines","suites":["autoPipelining for cluster"],"updatePoint":{"line":101,"column":59,"index":3418},"line":101,"code":"  it(\"should not add blacklisted commands to auto pipelines\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      autoPipeliningIgnoredCommands: [\"hmget\"]\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise = cluster.hmget(\"foo1\").catch(() => {});\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    await promise;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support custom commands","suites":["autoPipelining for cluster"],"updatePoint":{"line":113,"column":36,"index":3885},"line":113,"code":"  it(\"should support custom commands\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    cluster.defineCommand(\"echo\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n    const promise = cluster.echo(\"foo1\", \"foo1\", \"bar1\", \"bar2\");\n    expect(cluster.autoPipelineQueueSize).to.eql(1);\n    expect(await promise).to.eql([\"foo1\", \"foo1\", \"bar1\", \"bar2\"]);\n    await cluster.echo(\"foo1\", \"foo1\", \"bar1\", \"bar2\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support multiple commands","suites":["autoPipelining for cluster"],"updatePoint":{"line":128,"column":38,"index":4486},"line":128,"code":"  it(\"should support multiple commands\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo5\", \"bar5\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")])).to.eql([\"bar1\", \"bar5\", \"bar1\", \"bar5\", \"bar1\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support building pipelines when a prefix is used","suites":["autoPipelining for cluster"],"updatePoint":{"line":138,"column":61,"index":5011},"line":138,"code":"  it(\"should support building pipelines when a prefix is used\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      keyPrefix: \"baz:\"\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo10\", \"bar10\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo10\")])).to.eql([\"bar1\", \"bar10\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support building pipelines when a prefix is used with arrays to flatten","suites":["autoPipelining for cluster"],"updatePoint":{"line":149,"column":84,"index":5501},"line":149,"code":"  it(\"should support building pipelines when a prefix is used with arrays to flatten\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      keyPrefix: \"baz:\"\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    await cluster.set([\"foo1\"], \"bar1\");\n    await cluster.set([\"foo10\"], \"bar10\");\n    expect(await Promise.all([cluster.get([\"foo1\"]), cluster.get([\"foo10\"])])).to.eql([\"bar1\", \"bar10\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support commands queued after a pipeline is already queued for execution","suites":["autoPipelining for cluster"],"updatePoint":{"line":160,"column":85,"index":6000},"line":160,"code":"  it(\"should support commands queued after a pipeline is already queued for execution\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let value1;\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", () => {});\n      cluster.set(\"foo5\", \"bar5\", () => {});\n      cluster.get(\"foo1\", (err, v1) => {\n        expect(err).to.eql(null);\n        value1 = v1;\n      });\n      process.nextTick(() => {\n        cluster.get(\"foo5\", (err, value2) => {\n          expect(err).to.eql(null);\n          expect(value1).to.eql(\"bar1\");\n          expect(value2).to.eql(\"bar5\");\n          expect(cluster.autoPipelineQueueSize).to.eql(0);\n          cluster.disconnect();\n          done();\n        });\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should correctly track pipeline length","suites":["autoPipelining for cluster"],"updatePoint":{"line":186,"column":44,"index":6840},"line":186,"code":"  it(\"should correctly track pipeline length\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise1 = cluster.set(\"foo1\", \"bar\");\n    const promise2 = cluster.set(\"foo5\", \"bar\");\n    expect(cluster.autoPipelineQueueSize).to.eql(2);\n    await promise1;\n    await promise2;\n    expect(cluster.autoPipelineQueueSize).to.eql(0);\n    const promise3 = Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")]);\n    expect(cluster.autoPipelineQueueSize).to.eql(5);\n    await promise3;\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle rejections","suites":["autoPipelining for cluster"],"updatePoint":{"line":203,"column":30,"index":7580},"line":203,"code":"  it(\"should handle rejections\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await cluster.set(\"foo1\", \"bar\");\n    await expect(cluster.set(\"foo1\")).to.eventually.be.rejectedWith(\"ERR wrong number of arguments for 'set' command\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the happy case","suites":["autoPipelining for cluster"],"updatePoint":{"line":211,"column":48,"index":7917},"line":211,"code":"  it(\"should support callbacks in the happy case\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let value1, value2;\n      function cb() {\n        expect(value1).to.eql(\"bar1\");\n        expect(value2).to.eql(\"bar5\");\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n        cluster.disconnect();\n        done();\n      }\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n\n      /*\n        In this test, foo1 and foo5 usually (like in the case of 3 nodes scenario) belongs\n        to different nodes group.\n        Therefore we are also testing callback scenario with multiple pipelines fired together.\n      */\n      cluster.set(\"foo1\", \"bar1\", () => {});\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo5\", \"bar5\", () => {\n        cluster.get(\"foo1\", (err, v1) => {\n          expect(err).to.eql(null);\n          value1 = v1;\n\n          // This is needed as we cannot really predict which nodes responds first\n          if (value1 && value2) {\n            cb();\n          }\n        });\n        expect(cluster.autoPipelineQueueSize).to.eql(1);\n        cluster.get(\"foo5\", (err, v2) => {\n          expect(err).to.eql(null);\n          value2 = v2;\n\n          // This is needed as we cannot really predict which nodes responds first\n          if (value1 && value2) {\n            cb();\n          }\n        });\n        expect(cluster.autoPipelineQueueSize).to.eql(2);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support callbacks in the failure case","suites":["autoPipelining for cluster"],"updatePoint":{"line":258,"column":50,"index":9489},"line":258,"code":"  it(\"should support callbacks in the failure case\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo5\", err => {\n        expect(err.message).to.include(\"ERR wrong number of arguments for 'set' command\");\n        cluster.disconnect();\n        done();\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle callbacks failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":276,"column":38,"index":10106},"line":276,"code":"  it(\"should handle callbacks failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n      cluster.disconnect();\n      done();\n    });\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n        throw new Error(\"ERROR\");\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        expect(err).to.eql(null);\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":303,"column":45,"index":11027},"line":303,"code":"  it(\"should handle general pipeline failures\", done => {\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    process.once(\"uncaughtException\", err => {\n      expect(err.message).to.eql(\"ERROR\");\n      for (const listener of listeners) {\n        process.on(\"uncaughtException\", listener);\n      }\n      cluster.disconnect();\n      done();\n    });\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        expect(err).to.eql(null);\n        throw new Error(\"ERROR\");\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        expect(err).to.eql(null);\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline rejections","suites":["autoPipelining for cluster"],"updatePoint":{"line":330,"column":47,"index":11950},"line":330,"code":"  it(\"should handle general pipeline rejections\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    await new Promise(resolve => cluster.once(\"connect\", resolve));\n    const promise1 = cluster.set(\"foo1\", \"bar\");\n    const promise2 = cluster.set(\"foo5\", \"bar\");\n    const promise3 = cluster.set(\"foo2\", \"bar\");\n    const promise4 = cluster.set(\"foo6\", \"bar\");\n\n    // Override slots to induce a failure\n    const key1Slot = calculateKeySlot(\"foo1\");\n    const key2Slot = calculateKeySlot(\"foo2\");\n    const key5Slot = calculateKeySlot(\"foo5\");\n    changeSlot(cluster, key1Slot, key2Slot);\n    changeSlot(cluster, key2Slot, key5Slot);\n    await expect(promise1).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise2).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise3).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    await expect(promise4).to.eventually.be.rejectedWith(\"All keys in the pipeline should belong to the same slots allocation group\");\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures","suites":["autoPipelining for cluster"],"updatePoint":{"line":352,"column":45,"index":13204},"line":352,"code":"  it(\"should handle general pipeline failures\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    cluster.once(\"connect\", () => {\n      let err1, err2, err3, err4;\n      function cb() {\n        expect(err1.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err2.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err3.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err4.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(cluster.autoPipelineQueueSize).to.eql(0);\n        cluster.disconnect();\n        done();\n      }\n      expect(cluster.autoPipelineQueueSize).to.eql(0);\n      cluster.set(\"foo1\", \"bar1\", err => {\n        err1 = err;\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(1);\n      cluster.set(\"foo2\", \"bar2\", err => {\n        err2 = err;\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n      cluster.set(\"foo5\", \"bar5\", err => {\n        err3 = err;\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n      cluster.set(\"foo6\", \"bar6\", err => {\n        err4 = err;\n        if (err1 && err2 && err3 && err4) {\n          cb();\n        }\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(4);\n\n      // Override slots to induce a failure\n      const key1Slot = calculateKeySlot(\"foo1\");\n      const key2Slot = calculateKeySlot(\"foo2\");\n      const key5Slot = calculateKeySlot(\"foo5\");\n      changeSlot(cluster, key1Slot, key2Slot);\n      changeSlot(cluster, key2Slot, key5Slot);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should handle general pipeline failures callbacks failure","suites":["autoPipelining for cluster"],"updatePoint":{"line":405,"column":63,"index":15168},"line":405,"code":"  it(\"should handle general pipeline failures callbacks failure\", done => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true\n    });\n    const listeners = process.listeners(\"uncaughtException\");\n    process.removeAllListeners(\"uncaughtException\");\n    cluster.once(\"connect\", () => {\n      let err1, err5;\n      process.once(\"uncaughtException\", err => {\n        expect(err.message).to.eql(\"ERROR\");\n        expect(err1.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        expect(err5.message).to.eql(\"All keys in the pipeline should belong to the same slots allocation group\");\n        for (const listener of listeners) {\n          process.on(\"uncaughtException\", listener);\n        }\n        cluster.disconnect();\n        done();\n      });\n      cluster.set(\"foo1\", \"bar1\", err => {\n        err1 = err;\n      });\n      cluster.set(\"foo5\", \"bar5\", err => {\n        err5 = err;\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(2);\n      cluster.set(\"foo2\", err => {\n        throw new Error(\"ERROR\");\n      });\n      expect(cluster.autoPipelineQueueSize).to.eql(3);\n      const key1Slot = calculateKeySlot(\"foo1\");\n      const key2Slot = calculateKeySlot(\"foo2\");\n      changeSlot(cluster, key1Slot, key2Slot);\n    });\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should support lazyConnect","suites":["autoPipelining for cluster"],"updatePoint":{"line":439,"column":32,"index":16447},"line":439,"code":"  it(\"should support lazyConnect\", async () => {\n    const cluster = new Cluster(hosts, {\n      enableAutoPipelining: true,\n      lazyConnect: true\n    });\n    await cluster.set(\"foo1\", \"bar1\");\n    await cluster.set(\"foo5\", \"bar5\");\n    expect(await Promise.all([cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\"), cluster.get(\"foo5\"), cluster.get(\"foo1\")])).to.eql([\"bar1\", \"bar5\", \"bar1\", \"bar5\", \"bar1\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/autopipelining.ts","skipped":false,"dir":"test"},{"name":"should redirect the command to a random node","suites":["cluster:CLUSTERDOWN"],"updatePoint":{"line":5,"column":50,"index":214},"line":5,"code":"  it(\"should redirect the command to a random node\", done => {\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"CLUSTERDOWN\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false,\n      retryDelayOnClusterDown: 1\n    });\n    cluster.get(\"foo\", function (_, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/clusterdown.ts","skipped":false,"dir":"test"},{"name":"cleans up subscribers when selecting a new one","suites":["ClusterSubscriber"],"updatePoint":{"line":7,"column":52,"index":351},"line":7,"code":"  it(\"cleans up subscribers when selecting a new one\", async () => {\n    const pool = new ConnectionPool({});\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    let rejectSubscribes = false;\n    const server = new MockServer(30000, argv => {\n      if (rejectSubscribes && argv[0] === \"subscribe\") {\n        return new Error(\"Failed to subscribe\");\n      }\n      return \"OK\";\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    rejectSubscribes = true;\n    subscriber.start();\n    await subscriber.getInstance().echo(\"hello\");\n    subscriber.start();\n    await subscriber.getInstance().echo(\"hello\");\n    expect(server.getAllClients()).to.have.lengthOf(1);\n    subscriber.stop();\n    pool.reset([]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"sets correct connection name when connectionName is set","suites":["ClusterSubscriber"],"updatePoint":{"line":32,"column":61,"index":1202},"line":32,"code":"  it(\"sets correct connection name when connectionName is set\", async () => {\n    const pool = new ConnectionPool({\n      connectionName: \"test\"\n    });\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    const clientNames = [];\n    new MockServer(30000, argv => {\n      if (argv[0] === \"client\" && argv[1] === \"setname\") {\n        clientNames.push(argv[2]);\n      }\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    subscriber.stop();\n    pool.reset([]);\n    expect(clientNames).to.eql([\"ioredis-cluster(subscriber):test\"]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"sets correct connection name when connectionName is absent","suites":["ClusterSubscriber"],"updatePoint":{"line":53,"column":64,"index":1875},"line":53,"code":"  it(\"sets correct connection name when connectionName is absent\", async () => {\n    const pool = new ConnectionPool({});\n    const subscriber = new ClusterSubscriber(pool, new EventEmitter());\n    const clientNames = [];\n    new MockServer(30000, argv => {\n      if (argv[0] === \"client\" && argv[1] === \"setname\") {\n        clientNames.push(argv[2]);\n      }\n    });\n    pool.findOrCreate({\n      host: \"127.0.0.1\",\n      port: 30000\n    });\n    subscriber.start();\n    await subscriber.getInstance().subscribe(\"foo\");\n    subscriber.stop();\n    pool.reset([]);\n    expect(clientNames).to.eql([\"ioredis-cluster(subscriber)\"]);\n  });","file":"functional/cluster/ClusterSubscriber.ts","skipped":false,"dir":"test"},{"name":"should flush the queue when all startup nodes are unreachable","suites":["cluster:connect"],"updatePoint":{"line":6,"column":67,"index":259},"line":6,"code":"  it(\"should flush the queue when all startup nodes are unreachable\", done => {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      clusterRetryStrategy: null\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(err.message).to.match(/None of startup nodes is available/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should invoke clusterRetryStrategy when all startup nodes are unreachable","suites":["cluster:connect"],"updatePoint":{"line":19,"column":79,"index":652},"line":19,"code":"  it(\"should invoke clusterRetryStrategy when all startup nodes are unreachable\", done => {\n    let t = 0;\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: function (times) {\n        expect(times).to.eql(++t);\n        if (times === 3) {\n          return;\n        }\n        return 0;\n      }\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(t).to.eql(3);\n      expect(err.message).to.match(/None of startup nodes is available/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should invoke clusterRetryStrategy when none nodes are ready","suites":["cluster:connect"],"updatePoint":{"line":43,"column":66,"index":1258},"line":43,"code":"  it(\"should invoke clusterRetryStrategy when none nodes are ready\", done => {\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\") {\n        return new Error(\"CLUSTERDOWN\");\n      }\n    };\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    let t = 0;\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: function (times) {\n        expect(times).to.eql(++t);\n        if (times === 3) {\n          cluster.disconnect();\n          done();\n          return;\n        }\n        return 0;\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should connect to cluster successfully","suites":["cluster:connect"],"updatePoint":{"line":70,"column":44,"index":1912},"line":70,"code":"  it(\"should connect to cluster successfully\", done => {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    node.once(\"connect\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should wait for ready state before resolving","suites":["cluster:connect"],"updatePoint":{"line":81,"column":50,"index":2193},"line":81,"code":"  it(\"should wait for ready state before resolving\", done => {\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    const argvHandler = function (argv) {\n      if (argv[0] === \"info\") {\n        // return 'role:master'\n      }\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"cluster\" && argv[1] === \"INFO\") {\n        return \"cluster_state:ok\";\n      }\n    };\n    new MockServer(30001, argvHandler);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: true\n    });\n    cluster.connect().then(() => {\n      expect(cluster.status).to.eql(\"ready\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should support url schema","suites":["cluster:connect"],"updatePoint":{"line":107,"column":31,"index":2907},"line":107,"code":"  it(\"should support url schema\", done => {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([\"redis://127.0.0.1:30001\"]);\n    node.once(\"connect\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should support a single port","suites":["cluster:connect"],"updatePoint":{"line":115,"column":34,"index":3145},"line":115,"code":"  it(\"should support a single port\", done => {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([30001]);\n    node.once(\"connect\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should return a promise to be resolved when connected","suites":["cluster:connect"],"updatePoint":{"line":123,"column":59,"index":3388},"line":123,"code":"  it(\"should return a promise to be resolved when connected\", done => {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    };\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    new MockServer(30003, argvHandler);\n    const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => Promise.resolve());\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    stub.restore();\n    cluster.connect().then(() => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should return a promise to be rejected when closed","suites":["cluster:connect"],"updatePoint":{"line":146,"column":56,"index":4178},"line":146,"code":"  it(\"should return a promise to be rejected when closed\", done => {\n    const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => Promise.resolve());\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    stub.restore();\n    cluster.connect().catch(() => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting when disconnected","suites":["cluster:connect"],"updatePoint":{"line":160,"column":48,"index":4568},"line":160,"code":"  it(\"should stop reconnecting when disconnected\", done => {\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      clusterRetryStrategy: () => {\n        return 0;\n      }\n    });\n    cluster.on(\"close\", () => {\n      cluster.disconnect();\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      setTimeout(() => {\n        stub.restore();\n        done();\n      }, 1);\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should discover other nodes automatically","suites":["cluster:connect"],"updatePoint":{"line":178,"column":47,"index":5053},"line":178,"code":"  it(\"should discover other nodes automatically\", done => {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    };\n    const node1 = new MockServer(30001, argvHandler);\n    const node2 = new MockServer(30002, argvHandler);\n    const node3 = new MockServer(30003, argvHandler);\n    let pending = 3;\n    node1.once(\"connect\", check);\n    node2.once(\"connect\", check);\n    node3.once(\"connect\", check);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      redisOptions: {\n        lazyConnect: false\n      }\n    });\n    function check() {\n      if (! --pending) {\n        cluster.disconnect();\n        done();\n      }\n    }\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should send command to the correct node","suites":["cluster:connect"],"updatePoint":{"line":207,"column":45,"index":5938},"line":207,"code":"  it(\"should send command to the correct node\", done => {\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        process.nextTick(() => {\n          cluster.disconnect();\n          done();\n        });\n      }\n    });\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should emit errors when cluster cannot be connected","suites":["cluster:connect"],"updatePoint":{"line":229,"column":57,"index":6549},"line":229,"code":"  it(\"should emit errors when cluster cannot be connected\", done => {\n    const errorMessage = \"ERR This instance has cluster support disabled\";\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return new Error(errorMessage);\n      }\n    };\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    let pending = 2;\n    let retry = 0;\n    var cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }], {\n      clusterRetryStrategy: () => {\n        cluster.once(\"error\", function (err) {\n          retry = null;\n          expect(err.message).to.eql(\"Failed to refresh slots cache.\");\n          expect(err.lastNodeError.message).to.eql(errorMessage);\n          checkDone();\n        });\n        return retry;\n      }\n    });\n    cluster.once(\"node error\", function (err, key) {\n      expect(err.message).to.eql(errorMessage);\n      expect([\"127.0.0.1:30001\", \"127.0.0.1:30002\"]).to.include(key);\n      checkDone();\n    });\n    function checkDone() {\n      if (! --pending) {\n        cluster.disconnect();\n        done();\n      }\n    }\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should using the specified password","suites":["cluster:connect"],"updatePoint":{"line":269,"column":41,"index":7729},"line":269,"code":"  it(\"should using the specified password\", done => {\n    let cluster;\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n    const argvHandler = function (port, argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"auth\") {\n        const password = argv[1];\n        if (port === 30001) {\n          expect(password).to.eql(\"other password\");\n        } else if (port === 30002) {\n          throw new Error(\"30002 got password\");\n        } else if (port === 30003) {\n          expect(password).to.eql(\"default password\");\n          cluster.disconnect();\n          done();\n        }\n      }\n    };\n    new MockServer(30001, argvHandler.bind(null, 30001));\n    new MockServer(30002, argvHandler.bind(null, 30002));\n    new MockServer(30003, argvHandler.bind(null, 30003));\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\",\n      password: \"other password\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\",\n      password: null\n    }], {\n      redisOptions: {\n        lazyConnect: false,\n        password: \"default password\"\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should discover other nodes automatically every slotsRefreshInterval","suites":["cluster:connect"],"updatePoint":{"line":307,"column":74,"index":8984},"line":307,"code":"  it(\"should discover other nodes automatically every slotsRefreshInterval\", done => {\n    let times = 0;\n    let cluster;\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        times++;\n        if (times === 1) {\n          return [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30001]], [10923, 16383, [\"127.0.0.1\", 30001]]];\n        }\n        return [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30001]], [10923, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    };\n    const node1 = new MockServer(30001, argvHandler);\n    const node2 = new MockServer(30002, argvHandler);\n    node1.once(\"connect\", () => {\n      node2.once(\"connect\", () => {\n        cluster.disconnect();\n        done();\n      });\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      slotsRefreshInterval: 100,\n      redisOptions: {\n        lazyConnect: false\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"throws when startupNodes is empty","suites":["cluster:connect"],"updatePoint":{"line":337,"column":39,"index":9923},"line":337,"code":"  it(\"throws when startupNodes is empty\", done => {\n    const message = \"`startupNodes` should contain at least one node.\";\n    let pending = 2;\n    const cluster = new Cluster(null, {\n      lazyConnect: true,\n      clusterRetryStrategy(_, reason) {\n        expect(reason.message).to.eql(message);\n        if (! --pending) {\n          done();\n        }\n        return null;\n      }\n    });\n    cluster.connect().catch(err => {\n      expect(err.message).to.eql(message);\n      cluster.disconnect();\n      if (! --pending) {\n        done();\n      }\n    });\n  });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should reconnect after multiple consecutive disconnect(true) are called","suites":["cluster:connect","multiple reconnect"],"updatePoint":{"line":359,"column":79,"index":10565},"line":359,"code":"    it(\"should reconnect after multiple consecutive disconnect(true) are called\", done => {\n      new MockServer(30001);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        enableReadyCheck: false\n      });\n      cluster.once(\"reconnecting\", () => {\n        cluster.disconnect(true);\n      });\n      cluster.once(\"ready\", () => {\n        cluster.disconnect(true);\n        const rejectTimeout = setTimeout(() => {\n          cluster.disconnect();\n          done(new Error(\"second disconnect(true) didn't reconnect redis\"));\n        }, 1000);\n        process.nextTick(() => {\n          cluster.once(\"ready\", () => {\n            clearTimeout(rejectTimeout);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });\n    });","file":"functional/cluster/connect.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on disconnect","suites":["disconnection"],"updatePoint":{"line":9,"column":43,"index":280},"line":9,"code":"  it(\"should clear all timers on disconnect\", done => {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30000\"\n    }]);\n    cluster.on(\"connect\", () => {\n      cluster.disconnect();\n    });\n    cluster.on(\"end\", () => {\n      setTimeout(() => {\n        // wait for disconnect with refresher.\n        expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n        server.disconnect();\n        done();\n      }, 500);\n    });\n  });","file":"functional/cluster/disconnection.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on server exits","suites":["disconnection"],"updatePoint":{"line":29,"column":45,"index":928},"line":29,"code":"  it(\"should clear all timers on server exits\", done => {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30000\"\n    }], {\n      clusterRetryStrategy: null\n    });\n    cluster.on(\"end\", () => {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      done();\n    });\n    server.disconnect();\n  });","file":"functional/cluster/disconnection.ts","skipped":false,"dir":"test"},{"name":"resolve hostnames to IPs","suites":["cluster:dnsLookup"],"updatePoint":{"line":5,"column":30,"index":192},"line":5,"code":"  it(\"resolve hostnames to IPs\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, () => {}, slotTable);\n    new MockServer(30002, () => {}, slotTable);\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }]);\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(2);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(nodes[1].options.host).to.eql(\"127.0.0.1\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"support customize dnsLookup function","suites":["cluster:dnsLookup"],"updatePoint":{"line":22,"column":42,"index":811},"line":22,"code":"  it(\"support customize dnsLookup function\", done => {\n    let dnsLookupCalledCount = 0;\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    const cluster = new Cluster([{\n      host: \"a.com\",\n      port: \"30001\"\n    }], {\n      dnsLookup(hostname, callback) {\n        dnsLookupCalledCount += 1;\n        if (hostname === \"a.com\") {\n          callback(null, \"127.0.0.1\");\n        } else {\n          callback(new Error(\"Unknown hostname\"));\n        }\n      }\n    });\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(2);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(nodes[1].options.host).to.eql(\"127.0.0.1\");\n      expect(dnsLookupCalledCount).to.eql(1);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"reconnects when dns lookup fails","suites":["cluster:dnsLookup"],"updatePoint":{"line":50,"column":38,"index":1759},"line":50,"code":"  it(\"reconnects when dns lookup fails\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    let retried = false;\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }], {\n      dnsLookup(_, callback) {\n        if (retried) {\n          callback(null, \"127.0.0.1\");\n        } else {\n          callback(new Error(\"Random Exception\"));\n        }\n      },\n      clusterRetryStrategy: function (_, reason) {\n        expect(reason.message).to.eql(\"Random Exception\");\n        expect(retried).to.eql(false);\n        retried = true;\n        return 0;\n      }\n    });\n    cluster.on(\"ready\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"reconnects when dns lookup thrown an error","suites":["cluster:dnsLookup"],"updatePoint":{"line":78,"column":48,"index":2614},"line":78,"code":"  it(\"reconnects when dns lookup thrown an error\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, (argv, c) => {}, slotTable);\n    new MockServer(30002, (argv, c) => {}, slotTable);\n    let retried = false;\n    const cluster = new Cluster([{\n      host: \"localhost\",\n      port: \"30001\"\n    }], {\n      dnsLookup(_, callback) {\n        if (retried) {\n          callback(null, \"127.0.0.1\");\n        } else {\n          throw new Error(\"Random Exception\");\n        }\n      },\n      clusterRetryStrategy: function (_, reason) {\n        expect(reason.message).to.eql(\"Random Exception\");\n        expect(retried).to.eql(false);\n        retried = true;\n        return 0;\n      }\n    });\n    cluster.on(\"ready\", () => {\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/dnsLookup.ts","skipped":false,"dir":"test"},{"name":"clone the options","suites":["cluster:duplicate"],"updatePoint":{"line":5,"column":23,"index":185},"line":5,"code":"  it(\"clone the options\", done => {\n    const node = new MockServer(30001);\n    const cluster = new Cluster([]);\n    const duplicatedCluster = cluster.duplicate([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    node.once(\"connect\", () => {\n      expect(duplicatedCluster.nodes()).to.have.lengthOf(1);\n      expect(duplicatedCluster.nodes()[0].options.port).to.eql(30001);\n      cluster.disconnect();\n      duplicatedCluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/duplicate.ts","skipped":false,"dir":"test"},{"name":"should return the error successfully","suites":["cluster"],"updatePoint":{"line":7,"column":42,"index":289},"line":7,"code":"  it(\"should return the error successfully\", done => {\n    let called = false;\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n      if (argv.toString() === \"get,foo,bar\") {\n        called = true;\n        return new Error(\"Wrong arguments count\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", \"bar\", function (err) {\n      expect(called).to.eql(true);\n      expect(err.message).to.match(/Wrong arguments count/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should get value successfully","suites":["cluster"],"updatePoint":{"line":29,"column":35,"index":939},"line":29,"code":"  it(\"should get value successfully\", done => {\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should reconnect when cluster state is not ok","suites":["cluster","enableReadyCheck"],"updatePoint":{"line":51,"column":53,"index":1590},"line":51,"code":"    it(\"should reconnect when cluster state is not ok\", done => {\n      let state = \"fail\";\n      new MockServer(30001, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return [[0, 16383, [\"127.0.0.1\", 30001]]];\n        } else if (argv[0] === \"cluster\" && argv[1] === \"INFO\") {\n          return \"cluster_state:\" + state;\n        }\n      });\n      let count = 0;\n      const client = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        clusterRetryStrategy: function (times) {\n          expect(++count).to.eql(times);\n          if (count === 3) {\n            state = \"ok\";\n          }\n          return 0;\n        }\n      });\n      client.on(\"ready\", () => {\n        client.disconnect();\n        done();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should allow updating startupNodes","suites":["cluster","startupNodes"],"updatePoint":{"line":80,"column":42,"index":2403},"line":80,"code":"    it(\"should allow updating startupNodes\", done => {\n      new MockServer(30001, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return [[0, 16383, [\"127.0.0.1\", 30001]]];\n        }\n        if (argv[0] === \"cluster\" && argv[1] === \"INFO\") {\n          return \"cluster_state:fail\";\n        }\n      });\n      const client = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        clusterRetryStrategy: function () {\n          this.startupNodes = [{\n            port: 30002\n          }];\n          return 0;\n        }\n      });\n      let hasDone = false;\n      new MockServer(30002, () => {\n        if (hasDone) {\n          return;\n        }\n        hasDone = true;\n        client.disconnect();\n        done();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should only send reads to master","suites":["cluster","scaleReads","master"],"updatePoint":{"line":125,"column":42,"index":3843},"line":125,"code":"      it(\"should only send reads to master\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }]);\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should only send reads to slave","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":142,"column":41,"index":4362},"line":142,"code":"      it(\"should only send reads to slave\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(1);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send writes to masters","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":163,"column":39,"index":5067},"line":163,"code":"      it(\"should send writes to masters\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.set(\"foo\", \"bar\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send custom readOnly scripts to a slave","suites":["cluster","scaleReads","slave"],"updatePoint":{"line":180,"column":56,"index":5614},"line":180,"code":"      it(\"should send custom readOnly scripts to a slave\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"slave\"\n        });\n        cluster.on(\"ready\", () => {\n          const redis = cluster;\n          redis.defineCommand(\"test\", {\n            numberOfKeys: 1,\n            lua: \"return {KEYS[1],ARGV[1],ARGV[2]}\",\n            readOnly: true\n          });\n          const stub = sinon.stub(utils, \"sample\").returns(\"127.0.0.1:30003\");\n          redis.test(\"k1\", \"a1\", \"a2\", function (err, result) {\n            stub.restore();\n            expect(stub.callCount).to.eql(1);\n            // because of the beforeEach handler this will be the port of the slave called\n            expect(result).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send to selected slave","suites":["cluster","scaleReads","custom"],"updatePoint":{"line":207,"column":39,"index":6524},"line":207,"code":"      it(\"should send to selected slave\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: function (node, command) {\n            if (command.name === \"get\") {\n              return node[1];\n            }\n            return node[2];\n          }\n        });\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(1);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.hgetall(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30004);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send writes to masters","suites":["cluster","scaleReads","custom"],"updatePoint":{"line":233,"column":39,"index":7378},"line":233,"code":"      it(\"should send writes to masters\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: function (node, command) {\n            if (command.name === \"get\") {\n              return node[1];\n            }\n            return node[2];\n          }\n        });\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").throws(\"sample is called\");\n          cluster.set(\"foo\", \"bar\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30001);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should send reads to all nodes randomly","suites":["cluster","scaleReads","all"],"updatePoint":{"line":257,"column":49,"index":8098},"line":257,"code":"      it(\"should send reads to all nodes randomly\", done => {\n        const cluster = new Cluster([{\n          host: \"127.0.0.1\",\n          port: \"30001\"\n        }], {\n          scaleReads: \"all\"\n        });\n        cluster.on(\"ready\", () => {\n          const stub = sinon.stub(utils, \"sample\").callsFake((array, from) => {\n            expect(array).to.eql([\"127.0.0.1:30001\", \"127.0.0.1:30003\", \"127.0.0.1:30004\"]);\n            expect(from).to.eql(undefined);\n            return \"127.0.0.1:30003\";\n          });\n          cluster.get(\"foo\", function (err, res) {\n            stub.restore();\n            expect(res).to.eql(30003);\n            cluster.disconnect();\n            done();\n          });\n        });\n      });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should return the corrent nodes","suites":["cluster","#nodes()"],"updatePoint":{"line":281,"column":39,"index":8854},"line":281,"code":"    it(\"should return the corrent nodes\", done => {\n      const slotTable = [[0, 16381, [\"127.0.0.1\", 30001], [\"127.0.0.1\", 30003]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n      const node = new MockServer(30001, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30002, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30003, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]);\n      // Make sure 30001 has been connected\n      cluster.get(\"foo\", () => {\n        expect(cluster.nodes()).to.have.lengthOf(3);\n        expect(cluster.nodes(\"all\")).to.have.lengthOf(3);\n        expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n        expect(cluster.nodes(\"slave\")).to.have.lengthOf(1);\n        cluster.once(\"-node\", () => {\n          expect(cluster.nodes()).to.have.lengthOf(2);\n          expect(cluster.nodes(\"all\")).to.have.lengthOf(2);\n          expect(cluster.nodes(\"master\")).to.have.lengthOf(1);\n          expect(cluster.nodes(\"slave\")).to.have.lengthOf(1);\n          cluster.disconnect();\n          done();\n        });\n        node.disconnect();\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should refresh master nodes","suites":["cluster","#getInfoFromNode"],"updatePoint":{"line":321,"column":35,"index":10309},"line":321,"code":"    it(\"should refresh master nodes\", done => {\n      let slotTable = [[0, 5460, [\"127.0.0.1\", 30001], [\"127.0.0.1\", 30003]], [5461, 10922, [\"127.0.0.1\", 30002]]];\n      new MockServer(30001, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30002, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      new MockServer(30003, argv => {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      });\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }], {\n        redisOptions: {\n          showFriendlyErrorStack: true\n        }\n      });\n      cluster.on(\"ready\", () => {\n        expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n        slotTable = [[0, 5460, [\"127.0.0.1\", 30003]], [5461, 10922, [\"127.0.0.1\", 30002]]];\n        cluster.refreshSlotsCache(() => {\n          cluster.once(\"-node\", function (removed) {\n            expect(removed.options.port).to.eql(30001);\n            expect(cluster.nodes(\"master\")).to.have.lengthOf(2);\n            expect([cluster.nodes(\"master\")[0].options.port, cluster.nodes(\"master\")[1].options.port].sort()).to.eql([30002, 30003]);\n            cluster.nodes(\"master\").forEach(function (node) {\n              expect(node.options).to.have.property(\"readOnly\", false);\n            });\n            cluster.disconnect();\n            done();\n          });\n        });\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should quit the connection gracefully","suites":["cluster","#quit()"],"updatePoint":{"line":365,"column":45,"index":11923},"line":365,"code":"    it(\"should quit the connection gracefully\", done => {\n      const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002], [\"127.0.0.1\", 30003]]];\n      const argvHandler = function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n      };\n      new MockServer(30001, argvHandler);\n      new MockServer(30002, argvHandler);\n      new MockServer(30003, argvHandler);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]);\n      let setCommandHandled = false;\n      cluster.on(\"ready\", () => {\n        cluster.set(\"foo\", \"bar\", () => {\n          setCommandHandled = true;\n        });\n        cluster.quit(function (err, state) {\n          expect(setCommandHandled).to.eql(true);\n          expect(state).to.eql(\"OK\");\n          cluster.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/cluster/index.ts","skipped":false,"dir":"test"},{"name":"should return error when reached max redirection","suites":["cluster:maxRedirections"],"updatePoint":{"line":6,"column":54,"index":273},"line":6,"code":"  it(\"should return error when reached max redirection\", done => {\n    let redirectTimes = 0;\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        redirectTimes += 1;\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    };\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      maxRedirections: 5\n    });\n    cluster.get(\"foo\", function (err) {\n      expect(redirectTimes).to.eql(6);\n      expect(err.message).to.match(/Too many Cluster redirections/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/maxRedirections.ts","skipped":false,"dir":"test"},{"name":"should auto redirect the command to the correct nodes","suites":["cluster:MOVED"],"updatePoint":{"line":7,"column":59,"index":300},"line":7,"code":"  it(\"should auto redirect the command to the correct nodes\", done => {\n    let cluster = undefined;\n    let moved = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          expect(moved).to.eql(true);\n          process.nextTick(() => {\n            cluster.disconnect();\n            done();\n          });\n        }\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(moved).to.eql(false);\n        moved = true;\n        slotTable[0][1] = 16381;\n        slotTable[1][0] = 16382;\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", () => {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should be able to redirect a command to a unknown node","suites":["cluster:MOVED"],"updatePoint":{"line":46,"column":60,"index":1463},"line":46,"code":"  it(\"should be able to redirect a command to a unknown node\", done => {\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30002\");\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16381, [\"127.0.0.1\", 30001]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnFailover: 1\n    });\n    cluster.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"bar\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should auto redirect the command within a pipeline","suites":["cluster:MOVED"],"updatePoint":{"line":75,"column":56,"index":2376},"line":75,"code":"  it(\"should auto redirect the command within a pipeline\", done => {\n    let cluster = undefined;\n    let moved = false;\n    let times = 0;\n    const slotTable = [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          expect(moved).to.eql(true);\n          process.nextTick(() => {\n            cluster.disconnect();\n            done();\n          });\n        }\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(moved).to.eql(false);\n        moved = true;\n        slotTable[0][1] = 16381;\n        slotTable[1][0] = 16382;\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      lazyConnect: false\n    });\n    cluster.get(\"foo\", () => {\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"should supports retryDelayOnMoved","suites":["cluster:MOVED"],"updatePoint":{"line":116,"column":39,"index":3552},"line":116,"code":"  it(\"should supports retryDelayOnMoved\", done => {\n    let cluster = undefined;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30002\");\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    });\n    const retryDelayOnMoved = 789;\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnMoved\n    });\n    cluster.on(\"ready\", () => {\n      sinon.stub(global, \"setTimeout\").callsFake((body, ms) => {\n        if (ms === retryDelayOnMoved) {\n          process.nextTick(() => {\n            body();\n          });\n        }\n      });\n      cluster.get(\"foo\");\n    });\n  });","file":"functional/cluster/moved.ts","skipped":false,"dir":"test"},{"name":"works for normal case","suites":["NAT"],"updatePoint":{"line":7,"column":27,"index":258},"line":7,"code":"  it(\"works for normal case\", done => {\n    const slotTable = [[0, 1, [\"192.168.1.1\", 30001]], [2, 16383, [\"192.168.1.2\", 30001]]];\n    let cluster;\n    new MockServer(30001, null, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works if natMap does not match all the cases","suites":["NAT"],"updatePoint":{"line":34,"column":50,"index":972},"line":34,"code":"  it(\"works if natMap does not match all the cases\", done => {\n    const slotTable = [[0, 1, [\"192.168.1.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n    let cluster;\n    new MockServer(30001, null, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works for moved","suites":["NAT"],"updatePoint":{"line":57,"column":21,"index":1562},"line":57,"code":"  it(\"works for moved\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    let cluster;\n    new MockServer(30001, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 192.168.1.2:30001\");\n      }\n    }, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"works for ask","suites":["NAT"],"updatePoint":{"line":88,"column":19,"index":2374},"line":88,"code":"  it(\"works for ask\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    let cluster;\n    let asked = false;\n    new MockServer(30001, ([command, arg]) => {\n      if (command === \"get\" && arg === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 192.168.1.2:30001\");\n      }\n    }, slotTable);\n    new MockServer(30002, ([command, arg]) => {\n      if (command === \"asking\") {\n        asked = true;\n      }\n      if (command === \"get\" && arg === \"foo\") {\n        if (!asked) {\n          throw new Error(\"expected asked to be true\");\n        }\n        cluster.disconnect();\n        done();\n      }\n    }, slotTable);\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], {\n      natMap: {\n        \"192.168.1.1:30001\": {\n          host: \"127.0.0.1\",\n          port: 30001\n        },\n        \"192.168.1.2:30001\": {\n          host: \"127.0.0.1\",\n          port: 30002\n        }\n      }\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"keeps options immutable","suites":["NAT"],"updatePoint":{"line":126,"column":29,"index":3369},"line":126,"code":"  it(\"keeps options immutable\", done => {\n    const slotTable = [[0, 16383, [\"192.168.1.1\", 30001]]];\n    new MockServer(30001, null, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: 30001\n    }], Object.freeze({\n      natMap: Object.freeze({\n        \"192.168.1.1:30001\": Object.freeze({\n          host: \"127.0.0.1\",\n          port: 30001\n        })\n      })\n    }));\n    const reset = sinon.spy(cluster.connectionPool, \"reset\");\n    cluster.on(\"ready\", () => {\n      expect(reset.secondCall.args[0]).to.deep.equal([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/nat.ts","skipped":false,"dir":"test"},{"name":"should throw when not all keys in a pipeline command belong to the same slot","suites":["cluster:pipeline"],"updatePoint":{"line":7,"column":82,"index":326},"line":7,"code":"  it(\"should throw when not all keys in a pipeline command belong to the same slot\", done => {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().set(\"foo\", \"bar\").mget(\"foo1\", \"foo2\").exec().catch(function (err) {\n      expect(err.message).to.match(/All the keys in a pipeline command should belong to the same slot/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should throw when not all keys in different pipeline commands belong to the same allocation group","suites":["cluster:pipeline"],"updatePoint":{"line":29,"column":103,"index":1152},"line":29,"code":"  it(\"should throw when not all keys in different pipeline commands belong to the same allocation group\", done => {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().set(\"foo1\", \"bar\").get(\"foo2\").exec().catch(function (err) {\n      expect(err.message).to.match(/All keys in the pipeline should belong to the same slots allocation group/);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should auto redirect commands on MOVED","suites":["cluster:pipeline"],"updatePoint":{"line":51,"column":44,"index":1919},"line":51,"code":"  it(\"should auto redirect commands on MOVED\", done => {\n    let moved = false;\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[1] === \"foo\") {\n        if (argv[0] === \"set\") {\n          expect(moved).to.eql(false);\n          moved = true;\n        }\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should auto redirect commands on ASK","suites":["cluster:pipeline"],"updatePoint":{"line":86,"column":42,"index":3024},"line":86,"code":"  it(\"should auto redirect commands on ASK\", done => {\n    let asked = false;\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"asking\") {\n        asked = true;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        expect(asked).to.eql(true);\n        return \"bar\";\n      }\n      if (argv[0] !== \"asking\") {\n        asked = false;\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[1] === \"foo\") {\n        return new Error(\"ASK \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should retry the command on TRYAGAIN","suites":["cluster:pipeline"],"updatePoint":{"line":124,"column":42,"index":4186},"line":124,"code":"  it(\"should retry the command on TRYAGAIN\", done => {\n    let times = 0;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[1] === \"foo\") {\n        if (times++ < 2) {\n          return new Error(\"TRYAGAIN Multiple keys request during rehashing of slot\");\n        }\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnTryAgain: 1\n    });\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(result[0][1]).to.eql(\"OK\");\n      expect(result[1][1]).to.eql(\"OK\");\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should not redirect commands on a non-readonly command is successful","suites":["cluster:pipeline"],"updatePoint":{"line":150,"column":74,"index":4997},"line":150,"code":"  it(\"should not redirect commands on a non-readonly command is successful\", done => {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return new Error(\"MOVED \" + calculateSlot(\"foo\") + \" 127.0.0.1:30001\");\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0][0].message).to.match(/MOVED/);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should retry when redis is down","suites":["cluster:pipeline"],"updatePoint":{"line":180,"column":37,"index":5996},"line":180,"code":"  it(\"should retry when redis is down\", done => {\n    const slotTable = [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    });\n    const node2 = new MockServer(30002, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        return \"bar\";\n      }\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnFailover: 1\n    });\n    const stub = sinon.stub(cluster, \"refreshSlotsCache\").callsFake((...args) => {\n      node2.connect();\n      stub.restore();\n      cluster.refreshSlotsCache(...args);\n    });\n    node2.disconnect();\n    cluster.pipeline().get(\"foo\").set(\"foo\", \"bar\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result[0]).to.eql([null, \"bar\"]);\n      expect(result[1]).to.eql([null, \"OK\"]);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pipeline.ts","skipped":false,"dir":"test"},{"name":"should receive messages","suites":["cluster:pub/sub"],"updatePoint":{"line":8,"column":29,"index":333},"line":8,"code":"  it(\"should receive messages\", done => {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    };\n    const node1 = new MockServer(30001, handler);\n    new MockServer(30002, handler);\n    const options = [{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }];\n    const sub = new Cluster(options);\n    sub.subscribe(\"test cluster\", function () {\n      node1.write(node1.findClientByName(\"ioredis-cluster(subscriber)\"), [\"message\", \"test channel\", \"hi\"]);\n    });\n    sub.on(\"message\", function (channel, message) {\n      expect(channel).to.eql(\"test channel\");\n      expect(message).to.eql(\"hi\");\n      sub.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should works when sending regular commands","suites":["cluster:pub/sub"],"updatePoint":{"line":31,"column":48,"index":1137},"line":31,"code":"  it(\"should works when sending regular commands\", done => {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n    new MockServer(30001, handler);\n    const sub = new Cluster([{\n      port: \"30001\"\n    }]);\n    sub.subscribe(\"test cluster\", function () {\n      sub.set(\"foo\", \"bar\").then(res => {\n        expect(res).to.eql(\"OK\");\n        sub.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"supports password","suites":["cluster:pub/sub"],"updatePoint":{"line":49,"column":23,"index":1621},"line":49,"code":"  it(\"supports password\", done => {\n    const handler = function (argv, c) {\n      if (argv[0] === \"auth\") {\n        c.password = argv[1];\n        return;\n      }\n      if (argv[0] === \"subscribe\") {\n        expect(c.password).to.eql(\"abc\");\n        expect(getConnectionName(c)).to.eql(\"ioredis-cluster(subscriber)\");\n      }\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n    new MockServer(30001, handler);\n    const sub = new Cluster([{\n      port: \"30001\",\n      password: \"abc\"\n    }]);\n    sub.subscribe(\"test cluster\", function () {\n      sub.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should re-subscribe after reconnection","suites":["cluster:pub/sub"],"updatePoint":{"line":73,"column":44,"index":2311},"line":73,"code":"  it(\"should re-subscribe after reconnection\", done => {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      } else if (argv[0] === \"subscribe\" || argv[0] === \"psubscribe\") {\n        return [argv[0], argv[1]];\n      }\n    });\n    const client = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    client.subscribe(\"test cluster\", function () {\n      const stub = sinon.stub(Redis.prototype, \"subscribe\").callsFake(channels => {\n        expect(channels).to.eql([\"test cluster\"]);\n        stub.restore();\n        client.disconnect();\n        done();\n        return Redis.prototype.subscribe.apply(this, arguments);\n      });\n      client.once(\"end\", function () {\n        client.connect().catch(noop);\n      });\n      client.disconnect();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should re-psubscribe after reconnection","suites":["cluster:pub/sub"],"updatePoint":{"line":99,"column":45,"index":3191},"line":99,"code":"  it(\"should re-psubscribe after reconnection\", done => {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      } else if (argv[0] === \"subscribe\" || argv[0] === \"psubscribe\") {\n        return [argv[0], argv[1]];\n      }\n    });\n    const client = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    client.psubscribe(\"test?\", function () {\n      const stub = sinon.stub(Redis.prototype, \"psubscribe\").callsFake(channels => {\n        expect(channels).to.eql([\"test?\"]);\n        stub.restore();\n        client.disconnect();\n        done();\n        return Redis.prototype.psubscribe.apply(this, arguments);\n      });\n      client.once(\"end\", function () {\n        client.connect().catch(noop);\n      });\n      client.disconnect();\n    });\n  });","file":"functional/cluster/pub_sub.ts","skipped":false,"dir":"test"},{"name":"quit successfully when server is disconnecting","suites":["cluster:quit"],"updatePoint":{"line":5,"column":52,"index":209},"line":5,"code":"  it(\"quit successfully when server is disconnecting\", done => {\n    const slotTable = [[0, 1000, [\"127.0.0.1\", 30001]], [1001, 16383, [\"127.0.0.1\", 30002]]];\n    const server = new MockServer(30001, (argv, c) => {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    new MockServer(30002, (argv, c) => {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.on(\"ready\", () => {\n      server.disconnect();\n      cluster.quit((err, res) => {\n        expect(err).to.eql(null);\n        expect(res).to.eql(\"OK\");\n        cluster.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/quit.ts","skipped":false,"dir":"test"},{"name":"failed when quit returns error","suites":["cluster:quit"],"updatePoint":{"line":31,"column":36,"index":930},"line":31,"code":"  it(\"failed when quit returns error\", done => {\n    const ERROR_MESSAGE = \"quit random error\";\n    const slotTable = [[0, 16381, [\"127.0.0.1\", 30001]], [16382, 16383, [\"127.0.0.1\", 30002]]];\n    new MockServer(30001, function (argv, c) {\n      if (argv[0] === \"quit\") {\n        return new Error(ERROR_MESSAGE);\n      }\n    }, slotTable);\n    new MockServer(30002, function (argv, c) {\n      if (argv[0] === \"quit\") {\n        c.destroy();\n      }\n    }, slotTable);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    cluster.get(\"foo\", () => {\n      cluster.quit(err => {\n        expect(err.message).to.eql(ERROR_MESSAGE);\n        cluster.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/quit.ts","skipped":false,"dir":"test"},{"name":"support customize resolveSrv function","suites":["cluster:resolveSrv"],"updatePoint":{"line":5,"column":43,"index":206},"line":5,"code":"  it(\"support customize resolveSrv function\", done => {\n    let resolveSrvCalledCount = 0;\n    new MockServer(30001, (argv, c) => {}, [[0, 1000, [\"127.0.0.1\", 30001]]]);\n    const cluster = new Cluster([{\n      host: \"a.com\"\n    }], {\n      useSRVRecords: true,\n      resolveSrv(hostname, callback) {\n        resolveSrvCalledCount++;\n        if (hostname === \"a.com\") {\n          callback(null, [{\n            priority: 1,\n            weight: 1,\n            port: 30001,\n            name: \"127.0.0.1\"\n          }]);\n        } else {\n          callback(new Error(\"Unknown hostname\"));\n        }\n      }\n    });\n    cluster.on(\"ready\", () => {\n      const nodes = cluster.nodes(\"master\");\n      expect(nodes.length).to.eql(1);\n      expect(nodes[0].options.host).to.eql(\"127.0.0.1\");\n      expect(resolveSrvCalledCount).to.eql(1);\n      cluster.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/resolveSrv.ts","skipped":false,"dir":"test"},{"name":"should throw when not all keys in a pipeline command belong to the same slot","suites":["cluster:scripting"],"updatePoint":{"line":5,"column":82,"index":244},"line":5,"code":"  it(\"should throw when not all keys in a pipeline command belong to the same slot\", async () => {\n    const lua = \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\";\n    const handler = argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 12181, [\"127.0.0.1\", 30001]], [12182, 16383, [\"127.0.0.1\", 30002]]];\n      }\n      if (argv[0] === \"eval\" && argv[1] === lua && argv[2] === \"2\") {\n        return argv.slice(3);\n      }\n    };\n    new MockServer(30001, handler);\n    new MockServer(30002, handler);\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      scripts: {\n        test: {\n          lua,\n          numberOfKeys: 2\n        },\n        testDynamic: {\n          lua\n        }\n      }\n    });\n\n    // @ts-expect-error\n    expect(await cluster.test(\"{foo}1\", \"{foo}2\", \"argv1\", \"argv2\")).to.eql([\"{foo}1\", \"{foo}2\", \"argv1\", \"argv2\"]);\n    expect(\n    // @ts-expect-error\n    await cluster.testDynamic(2, \"{foo}1\", \"{foo}2\", \"argv1\", \"argv2\")).to.eql([\"{foo}1\", \"{foo}2\", \"argv1\", \"argv2\"]);\n    cluster.disconnect();\n  });","file":"functional/cluster/scripting.ts","skipped":false,"dir":"test"},{"name":"should receive messages","suites":["cluster:spub/ssub"],"updatePoint":{"line":8,"column":29,"index":335},"line":8,"code":"  it(\"should receive messages\", done => {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 1, [\"127.0.0.1\", 30001]], [2, 16383, [\"127.0.0.1\", 30002]]];\n      }\n    };\n    const node1 = new MockServer(30001, handler);\n    new MockServer(30002, handler);\n    const options = [{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }];\n    const ssub = new Cluster(options);\n    ssub.ssubscribe(\"test cluster\", function () {\n      node1.write(node1.findClientByName(\"ioredis-cluster(subscriber)\"), [\"smessage\", \"test shard channel\", \"hi\"]);\n    });\n    ssub.on(\"smessage\", function (channel, message) {\n      expect(channel).to.eql(\"test shard channel\");\n      expect(message).to.eql(\"hi\");\n      ssub.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should works when sending regular commands","suites":["cluster:spub/ssub"],"updatePoint":{"line":31,"column":48,"index":1158},"line":31,"code":"  it(\"should works when sending regular commands\", done => {\n    const handler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n    new MockServer(30001, handler);\n    const ssub = new Cluster([{\n      port: \"30001\"\n    }]);\n    ssub.ssubscribe(\"test cluster\", function () {\n      ssub.set(\"foo\", \"bar\").then(res => {\n        expect(res).to.eql(\"OK\");\n        ssub.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/cluster/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"supports password","suites":["cluster:spub/ssub"],"updatePoint":{"line":49,"column":23,"index":1647},"line":49,"code":"  it(\"supports password\", done => {\n    const handler = function (argv, c) {\n      if (argv[0] === \"auth\") {\n        c.password = argv[1];\n        return;\n      }\n      if (argv[0] === \"ssubscribe\") {\n        expect(c.password).to.eql(\"abc\");\n        expect(getConnectionName(c)).to.eql(\"ioredis-cluster(subscriber)\");\n      }\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      }\n    };\n    new MockServer(30001, handler);\n    const ssub = new Redis.Cluster([{\n      port: \"30001\",\n      password: \"abc\"\n    }]);\n    ssub.ssubscribe(\"test cluster\", function () {\n      ssub.disconnect();\n      done();\n    });\n  });","file":"functional/cluster/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should re-ssubscribe after reconnection","suites":["cluster:spub/ssub"],"updatePoint":{"line":73,"column":45,"index":2349},"line":73,"code":"  it(\"should re-ssubscribe after reconnection\", done => {\n    new MockServer(30001, function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return [[0, 16383, [\"127.0.0.1\", 30001]]];\n      } else if (argv[0] === \"ssubscribe\" || argv[0] === \"psubscribe\") {\n        return [argv[0], argv[1]];\n      }\n    });\n    const client = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }]);\n    client.ssubscribe(\"test cluster\", function () {\n      const stub = sinon.stub(Redis.prototype, \"ssubscribe\").callsFake(channels => {\n        expect(channels).to.eql([\"test cluster\"]);\n        stub.restore();\n        client.disconnect();\n        done();\n        return Redis.prototype.ssubscribe.apply(this, arguments);\n      });\n      client.once(\"end\", function () {\n        client.connect().catch(noop);\n      });\n      client.disconnect();\n    });\n  });","file":"functional/cluster/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["cluster:tls option"],"updatePoint":{"line":8,"column":18,"index":269},"line":8,"code":"  it(\"supports tls\", done => {\n    const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n    const argvHandler = function (argv) {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n    };\n    new MockServer(30001, argvHandler);\n    new MockServer(30002, argvHandler);\n    new MockServer(30003, argvHandler);\n\n    // @ts-expect-error\n    const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n      // @ts-expect-error\n      expect(op.ca).to.eql(\"123\");\n      // @ts-expect-error\n      expect(op.port).to.be.oneOf([30001, 30003, 30003]);\n      const stream = net.createConnection(op);\n      stream.on(\"connect\", data => {\n        stream.emit(\"secureConnect\", data);\n      });\n      return stream;\n    });\n    const cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30002\"\n    }, {\n      host: \"127.0.0.1\",\n      port: \"30003\"\n    }], {\n      redisOptions: {\n        tls: {\n          ca: \"123\"\n        }\n      }\n    });\n    cluster.on(\"ready\", () => {\n      expect(cluster.subscriber.subscriber.options.tls).to.deep.equal({\n        ca: \"123\"\n      });\n      cluster.disconnect();\n      stub.restore();\n      cluster.on(\"end\", () => done());\n    });\n  });","file":"functional/cluster/tls.ts","skipped":false,"dir":"test"},{"name":"should retry the command","suites":["cluster:TRYAGAIN"],"updatePoint":{"line":4,"column":30,"index":160},"line":4,"code":"  it(\"should retry the command\", done => {\n    let cluster;\n    let times = 0;\n    const slotTable = [[0, 16383, [\"127.0.0.1\", 30001]]];\n    new MockServer(30001, argv => {\n      if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n        return slotTable;\n      }\n      if (argv[0] === \"get\" && argv[1] === \"foo\") {\n        if (times++ === 1) {\n          process.nextTick(() => {\n            cluster.disconnect();\n            done();\n          });\n        } else {\n          return new Error(\"TRYAGAIN Multiple keys request during rehashing of slot\");\n        }\n      }\n    });\n    cluster = new Cluster([{\n      host: \"127.0.0.1\",\n      port: \"30001\"\n    }], {\n      retryDelayOnTryAgain: 1\n    });\n    cluster.get(\"foo\");\n  });","file":"functional/cluster/tryagain.ts","skipped":false,"dir":"test"},{"name":"rejects if command timed out","suites":["commandTimeout"],"updatePoint":{"line":6,"column":34,"index":219},"line":6,"code":"  it(\"rejects if command timed out\", done => {\n    const server = new MockServer(30001, (argv, socket, flags) => {\n      if (argv[0] === \"hget\") {\n        flags.hang = true;\n        return;\n      }\n    });\n    const redis = new Redis({\n      port: 30001,\n      commandTimeout: 1000\n    });\n    const clock = sinon.useFakeTimers();\n    redis.hget(\"foo\", err => {\n      expect(err.message).to.eql(\"Command timed out\");\n      clock.restore();\n      redis.disconnect();\n      server.disconnect(() => done());\n    });\n    clock.tick(1000);\n  });","file":"functional/commandTimeout.ts","skipped":false,"dir":"test"},{"name":"does not leak timers for commands in offline queue","suites":["commandTimeout"],"updatePoint":{"line":26,"column":56,"index":782},"line":26,"code":"  it(\"does not leak timers for commands in offline queue\", async () => {\n    const server = new MockServer(30001);\n    const redis = new Redis({\n      port: 30001,\n      commandTimeout: 1000\n    });\n    const clock = sinon.useFakeTimers();\n    await redis.hget(\"foo\");\n    expect(clock.countTimers()).to.eql(0);\n    clock.restore();\n    redis.disconnect();\n    await server.disconnectPromise();\n  });","file":"functional/commandTimeout.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on disconnect","suites":["disconnection"],"updatePoint":{"line":9,"column":43,"index":274},"line":9,"code":"  it(\"should clear all timers on disconnect\", done => {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const redis = new Redis({});\n    redis.on(\"connect\", () => {\n      redis.disconnect();\n    });\n    redis.on(\"end\", () => {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      server.disconnect();\n      done();\n    });\n  });","file":"functional/disconnection.ts","skipped":false,"dir":"test"},{"name":"should clear all timers on server exits","suites":["disconnection"],"updatePoint":{"line":23,"column":45,"index":767},"line":23,"code":"  it(\"should clear all timers on server exits\", done => {\n    const server = new MockServer(30000);\n    const setIntervalCalls = sinon.spy(global, \"setInterval\");\n    const clearIntervalCalls = sinon.spy(global, \"clearInterval\");\n    const redis = new Redis({\n      port: 30000,\n      retryStrategy: null\n    });\n    redis.on(\"end\", () => {\n      expect(setIntervalCalls.callCount).to.equal(clearIntervalCalls.callCount);\n      done();\n    });\n    server.disconnect();\n  });","file":"functional/disconnection.ts","skipped":false,"dir":"test"},{"name":"clone the options","suites":["duplicate"],"updatePoint":{"line":4,"column":23,"index":122},"line":4,"code":"  it(\"clone the options\", () => {\n    const redis = new Redis();\n    const duplicatedRedis = redis.duplicate();\n    redis.options.port = 1234;\n    expect(duplicatedRedis.options.port).to.eql(6379);\n  });","file":"functional/duplicate.ts","skipped":false,"dir":"test"},{"name":"should abort a failed transaction when connection is lost","suites":["elasticache"],"updatePoint":{"line":42,"column":63,"index":1326},"line":42,"code":"  it(\"should abort a failed transaction when connection is lost\", done => {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: true\n    });\n    redis.multi().del(\"foo\").del(\"bar\").exec(err => {\n      expectAbortError(err);\n      expect(err.command).to.eql({\n        name: \"exec\",\n        args: []\n      });\n      expect(err.previousErrors).to.have.lengthOf(2);\n      expectReplyError(err.previousErrors[0]);\n      expect(err.previousErrors[0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(err.previousErrors[1]);\n      expect(err.previousErrors[1].command).to.eql({\n        name: \"del\",\n        args: [\"bar\"]\n      });\n\n      // ensure we've recovered into a healthy state\n      redis.get(\"foo\", (err, res) => {\n        expect(res).to.eql(\"foo\");\n        done();\n      });\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should not resend failed transaction commands","suites":["elasticache"],"updatePoint":{"line":71,"column":51,"index":2167},"line":71,"code":"  it(\"should not resend failed transaction commands\", done => {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: 2\n    });\n    redis.multi().del(\"foo\").get(\"bar\").exec(err => {\n      expectAbortError(err);\n      expect(err.command).to.eql({\n        name: \"exec\",\n        args: []\n      });\n      expect(err.previousErrors).to.have.lengthOf(2);\n      expectAbortError(err.previousErrors[0]);\n      expect(err.previousErrors[0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(err.previousErrors[1]);\n      expect(err.previousErrors[1].command).to.eql({\n        name: \"get\",\n        args: [\"bar\"]\n      });\n\n      // ensure we've recovered into a healthy state\n      redis.get(\"foo\", (err, res) => {\n        expect(res).to.eql(\"foo\");\n        done();\n      });\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should resend intact pipelines","suites":["elasticache"],"updatePoint":{"line":100,"column":36,"index":2990},"line":100,"code":"  it(\"should resend intact pipelines\", done => {\n    const redis = simulateElasticache({\n      reconnectOnErrorValue: true\n    });\n    let p1Result;\n    redis.pipeline().del(\"foo\").get(\"bar\").exec((err, result) => p1Result = result);\n    redis.pipeline().get(\"baz\").get(\"qux\").exec((err, p2Result) => {\n      // First pipeline should have been aborted\n      expect(p1Result).to.have.lengthOf(2);\n      expect(p1Result[0]).to.have.lengthOf(1);\n      expect(p1Result[1]).to.have.lengthOf(1);\n      expectReplyError(p1Result[0][0]);\n      expect(p1Result[0][0].command).to.eql({\n        name: \"del\",\n        args: [\"foo\"]\n      });\n      expectAbortError(p1Result[1][0]);\n      expect(p1Result[1][0].command).to.eql({\n        name: \"get\",\n        args: [\"bar\"]\n      });\n\n      // Second pipeline was intact and should have been retried successfully\n      expect(p2Result).to.have.lengthOf(2);\n      expect(p2Result[0]).to.eql([null, \"baz\"]);\n      expect(p2Result[1]).to.eql([null, \"qux\"]);\n      done();\n    });\n  });","file":"functional/elasticache.ts","skipped":false,"dir":"test"},{"name":"should be `Command`","suites":["exports",".Command"],"updatePoint":{"line":5,"column":27,"index":176},"line":5,"code":"    it(\"should be `Command`\", () => {\n      expect(Command).to.eql(require(\"../../lib/Command\").default);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should be `Cluster`","suites":["exports",".Cluster"],"updatePoint":{"line":10,"column":27,"index":327},"line":10,"code":"    it(\"should be `Cluster`\", () => {\n      expect(Cluster).to.eql(require(\"../../lib/cluster\").default);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should be `ReplyError`","suites":["exports",".ReplyError"],"updatePoint":{"line":15,"column":30,"index":484},"line":15,"code":"    it(\"should be `ReplyError`\", () => {\n      expect(ReplyError).to.eql(require(\"redis-errors\").ReplyError);\n    });","file":"functional/exports.ts","skipped":false,"dir":"test"},{"name":"should handle fatal error of parser","suites":["fatal_error"],"updatePoint":{"line":5,"column":41,"index":191},"line":5,"code":"  it(\"should handle fatal error of parser\", done => {\n    let recovered = false;\n    new MockServer(30000, argv => {\n      if (recovered) {\n        return;\n      }\n      if (argv[0] === \"get\") {\n        return MockServer.raw(\"&\");\n      }\n    });\n    const redis = new Redis(30000);\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/Protocol error/);\n      recovered = true;\n      redis.get(\"bar\", function (err) {\n        expect(err).to.eql(null);\n        done();\n      });\n    });\n  });","file":"functional/fatal_error.ts","skipped":false,"dir":"test"},{"name":"should not call `connect` when init","suites":["lazy connect"],"updatePoint":{"line":7,"column":41,"index":255},"line":7,"code":"  it(\"should not call `connect` when init\", () => {\n    // TODO: use spy\n    const stub = sinon.stub(Redis.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n    new Redis({\n      lazyConnect: true\n    });\n    stub.restore();\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should connect when calling a command","suites":["lazy connect"],"updatePoint":{"line":15,"column":43,"index":513},"line":15,"code":"  it(\"should connect when calling a command\", done => {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect when disconnected manually","suites":["lazy connect"],"updatePoint":{"line":25,"column":60,"index":787},"line":25,"code":"  it(\"should not try to reconnect when disconnected manually\", done => {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.get(\"foo\", () => {\n      redis.disconnect();\n      redis.get(\"foo\", function (err) {\n        expect(err.message).to.match(/Connection is closed/);\n        done();\n      });\n    });\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should be able to disconnect","suites":["lazy connect"],"updatePoint":{"line":37,"column":34,"index":1093},"line":37,"code":"  it(\"should be able to disconnect\", done => {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    redis.on(\"end\", () => {\n      done();\n    });\n    redis.disconnect();\n  });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should not call `connect` when init","suites":["lazy connect","Cluster"],"updatePoint":{"line":47,"column":43,"index":1321},"line":47,"code":"    it(\"should not call `connect` when init\", () => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      new Cluster([], {\n        lazyConnect: true\n      });\n      stub.restore();\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should call connect when pipeline exec","suites":["lazy connect","Cluster"],"updatePoint":{"line":54,"column":46,"index":1581},"line":54,"code":"    it(\"should call connect when pipeline exec\", done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      const pipline = new Pipeline(cluster);\n      pipline.get(\"fool1\").exec(() => {});\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should call connect when transction exec","suites":["lazy connect","Cluster"],"updatePoint":{"line":65,"column":48,"index":1942},"line":65,"code":"    it(\"should call connect when transction exec\", done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.multi().get(\"fool1\").exec(() => {});\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should quit before \"close\" being emited","suites":["lazy connect","Cluster"],"updatePoint":{"line":75,"column":47,"index":2265},"line":75,"code":"    it('should quit before \"close\" being emited', done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.quit(() => {\n        cluster.once(\"close\", () => {\n          cluster.once(\"end\", () => {\n            stub.restore();\n            done();\n          });\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should disconnect before \"close\" being emited","suites":["lazy connect","Cluster"],"updatePoint":{"line":89,"column":53,"index":2715},"line":89,"code":"    it('should disconnect before \"close\" being emited', done => {\n      const stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true\n      });\n      cluster.disconnect();\n      cluster.once(\"close\", () => {\n        cluster.once(\"end\", () => {\n          stub.restore();\n          done();\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"should support disconnecting with reconnect","suites":["lazy connect","Cluster"],"updatePoint":{"line":102,"column":51,"index":3142},"line":102,"code":"    it(\"should support disconnecting with reconnect\", done => {\n      let stub = sinon.stub(Cluster.prototype, \"connect\").throws(new Error(\"`connect` should not be called\"));\n      const cluster = new Cluster([], {\n        lazyConnect: true,\n        clusterRetryStrategy: () => {\n          return 1;\n        }\n      });\n      cluster.disconnect(true);\n      cluster.once(\"close\", () => {\n        stub.restore();\n        stub = sinon.stub(Cluster.prototype, \"connect\").callsFake(() => {\n          stub.restore();\n          done();\n          return Promise.resolve();\n        });\n      });\n    });","file":"functional/lazy_connect.ts","skipped":false,"dir":"test"},{"name":"throw the correct error when reached the limit","suites":["maxRetriesPerRequest"],"updatePoint":{"line":5,"column":52,"index":224},"line":5,"code":"  it(\"throw the correct error when reached the limit\", done => {\n    const redis = new Redis(9999, {\n      connectTimeout: 1,\n      retryStrategy() {\n        return 1;\n      }\n    });\n    redis.get(\"foo\", err => {\n      expect(err).instanceOf(MaxRetriesPerRequestError);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"defaults to max 20 retries","suites":["maxRetriesPerRequest"],"updatePoint":{"line":18,"column":32,"index":529},"line":18,"code":"  it(\"defaults to max 20 retries\", done => {\n    const redis = new Redis(9999, {\n      connectTimeout: 1,\n      retryStrategy() {\n        return 1;\n      }\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(21);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(42);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"can be changed","suites":["maxRetriesPerRequest"],"updatePoint":{"line":34,"column":20,"index":903},"line":34,"code":"  it(\"can be changed\", done => {\n    const redis = new Redis(9999, {\n      maxRetriesPerRequest: 1,\n      retryStrategy() {\n        return 1;\n      }\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(2);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(4);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"allows 0","suites":["maxRetriesPerRequest"],"updatePoint":{"line":50,"column":14,"index":1275},"line":50,"code":"  it(\"allows 0\", done => {\n    const redis = new Redis(9999, {\n      maxRetriesPerRequest: 0,\n      retryStrategy() {\n        return 1;\n      }\n    });\n    redis.get(\"foo\", () => {\n      expect(redis.retryAttempts).to.eql(1);\n      redis.get(\"foo\", () => {\n        expect(redis.retryAttempts).to.eql(2);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/maxRetriesPerRequest.ts","skipped":false,"dir":"test"},{"name":"should receive commands","suites":["monitor"],"updatePoint":{"line":7,"column":29,"index":252},"line":7,"code":"  it(\"should receive commands\", done => {\n    const redis = new Redis();\n    redis.on(\"ready\", () => {\n      redis.monitor(async (err, monitor) => {\n        if (err) {\n          done(err);\n          return;\n        }\n        monitor.on(\"monitor\", function (time, args) {\n          expect(args[0]).to.match(/get/i);\n          expect(args[1]).to.eql(\"foo\");\n          redis.disconnect();\n          monitor.disconnect();\n          done();\n        });\n        await waitForMonitorReady();\n        redis.get(\"foo\");\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should reject processing commands","suites":["monitor"],"updatePoint":{"line":27,"column":39,"index":797},"line":27,"code":"  it(\"should reject processing commands\", done => {\n    const redis = new Redis();\n    redis.monitor(async (err, monitor) => {\n      await waitForMonitorReady();\n      monitor.get(\"foo\", function (err) {\n        expect(err.message).to.match(/Connection is in monitoring mode/);\n        redis.disconnect();\n        monitor.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should report being in 'monitor' mode","suites":["monitor"],"updatePoint":{"line":39,"column":43,"index":1177},"line":39,"code":"  it(\"should report being in 'monitor' mode\", done => {\n    const redis = new Redis();\n    redis.monitor(async (err, monitor) => {\n      await waitForMonitorReady();\n      expect(redis.mode).to.equal(\"normal\");\n      expect(monitor.mode).to.equal(\"monitor\");\n      redis.disconnect();\n      monitor.disconnect();\n      done();\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should continue monitoring after reconnection","suites":["monitor"],"updatePoint":{"line":50,"column":51,"index":1526},"line":50,"code":"  it(\"should continue monitoring after reconnection\", done => {\n    const redis = new Redis();\n    redis.monitor((err, monitor) => {\n      if (err) {\n        done(err);\n        return;\n      }\n      monitor.on(\"monitor\", (_time, args) => {\n        if (args[0] === \"set\" || args[0] === \"SET\") {\n          redis.disconnect();\n          monitor.disconnect();\n          done();\n        }\n      });\n      monitor.disconnect(true);\n      monitor.on(\"ready\", async () => {\n        await waitForMonitorReady();\n        redis.set(\"foo\", \"bar\");\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should wait for the ready event before monitoring","suites":["monitor"],"updatePoint":{"line":71,"column":55,"index":2090},"line":71,"code":"  it(\"should wait for the ready event before monitoring\", done => {\n    const redis = new Redis();\n    redis.on(\"ready\", () => {\n      // @ts-expect-error\n      const readyCheck = sinon.spy(Redis.prototype, \"_readyCheck\");\n      redis.monitor((err, monitor) => {\n        expect(readyCheck.callCount).to.eql(1);\n        redis.disconnect();\n        monitor.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"rejects when monitor is disabled","suites":["monitor"],"updatePoint":{"line":84,"column":38,"index":2482},"line":84,"code":"  it(\"rejects when monitor is disabled\", async () => {\n    const redis = new Redis();\n    await redis.acl(\"SETUSER\", \"nomonitor\", \"reset\", \"+info\", \">123456\", \"on\");\n    await expect(new Redis({\n      username: \"nomonitor\",\n      password: \"123456\"\n    }).monitor()).to.eventually.be.rejectedWith(/NOPERM/);\n  });","file":"functional/monitor.ts","skipped":false,"dir":"test"},{"name":"should return correct result","suites":["pipeline"],"updatePoint":{"line":6,"column":34,"index":222},"line":6,"code":"  it(\"should return correct result\", done => {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\", \"1\").get(\"foo\").set(\"foo\", \"2\").incr(\"foo\").get(\"foo\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"1\"], [null, \"OK\"], [null, 3], [null, \"3\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should return an empty array on empty pipeline","suites":["pipeline"],"updatePoint":{"line":15,"column":52,"index":619},"line":15,"code":"  it(\"should return an empty array on empty pipeline\", done => {\n    const redis = new Redis();\n    redis.pipeline().exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support mix string command and buffer command","suites":["pipeline"],"updatePoint":{"line":24,"column":58,"index":893},"line":24,"code":"  it(\"should support mix string command and buffer command\", done => {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\", \"bar\").set(\"foo\", Buffer.from(\"bar\")).getBuffer(\"foo\").get(Buffer.from(\"foo\")).exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"OK\"], [null, Buffer.from(\"bar\")], [null, \"bar\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should handle error correctly","suites":["pipeline"],"updatePoint":{"line":33,"column":35,"index":1303},"line":33,"code":"  it(\"should handle error correctly\", done => {\n    const redis = new Redis();\n    redis.pipeline().set(\"foo\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results.length).to.eql(1);\n      expect(results[0].length).to.eql(1);\n      expect(results[0][0].toString()).to.match(/wrong number of arguments/);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should also invoke the command's callback","suites":["pipeline"],"updatePoint":{"line":44,"column":47,"index":1704},"line":44,"code":"  it(\"should also invoke the command's callback\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.pipeline().set(\"foo\", \"bar\").get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      pending -= 1;\n    }).exec(function (err, results) {\n      expect(pending).to.eql(0);\n      expect(results[1][1]).to.eql(\"bar\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support inline transaction","suites":["pipeline"],"updatePoint":{"line":57,"column":39,"index":2107},"line":57,"code":"  it(\"should support inline transaction\", done => {\n    const redis = new Redis();\n    redis.pipeline().multi().set(\"foo\", \"bar\").get(\"foo\").exec().exec(function (err, result) {\n      expect(result[0][1]).to.eql(\"OK\");\n      expect(result[1][1]).to.eql(\"QUEUED\");\n      expect(result[2][1]).to.eql(\"QUEUED\");\n      expect(result[3][1]).to.eql([\"OK\", \"bar\"]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should have the same options as its container","suites":["pipeline"],"updatePoint":{"line":68,"column":51,"index":2532},"line":68,"code":"  it(\"should have the same options as its container\", () => {\n    const redis = new Redis({\n      showFriendlyErrorStack: true\n    });\n    const pipeline = redis.pipeline();\n    expect(pipeline.options).to.have.property(\"showFriendlyErrorStack\", true);\n    redis.disconnect();\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["pipeline"],"updatePoint":{"line":76,"column":34,"index":2798},"line":76,"code":"  it(\"should support key prefixing\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.pipeline().set(\"bar\", \"baz\").get(\"bar\").lpush(\"app1\", \"test1\").lpop(\"app1\").keys(\"*\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results).to.eql([[null, \"OK\"], [null, \"baz\"], [null, 1], [null, \"test1\"], [null, [\"foo:bar\"]]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should include added built in commands","suites":["pipeline"],"updatePoint":{"line":87,"column":44,"index":3240},"line":87,"code":"  it(\"should include added built in commands\", async () => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.addBuiltinCommand(\"someCommand\");\n    sinon.stub(redis, \"sendCommand\").callsFake(command => {\n      return command.resolve(Buffer.from(\"OK\"));\n    });\n    const result = await redis.pipeline().someCommand().exec();\n    expect(result).to.eql([[null, \"OK\"]]);\n  });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["pipeline","custom commands"],"updatePoint":{"line":110,"column":19,"index":3906},"line":110,"code":"    it(\"should work\", done => {\n      redis.pipeline().echo(\"foo\", \"bar\", \"123\", \"abc\").exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results).to.eql([[null, [\"foo\", \"bar\", \"123\", \"abc\"]]]);\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support callbacks","suites":["pipeline","custom commands"],"updatePoint":{"line":117,"column":32,"index":4178},"line":117,"code":"    it(\"should support callbacks\", done => {\n      let pending = 1;\n      redis.pipeline().echo(\"foo\", \"bar\", \"123\", \"abc\", function (err, result) {\n        pending -= 1;\n        expect(err).to.eql(null);\n        expect(result).to.eql([\"foo\", \"bar\", \"123\", \"abc\"]);\n      }).exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results).to.eql([[null, [\"foo\", \"bar\", \"123\", \"abc\"]]]);\n        expect(pending).to.eql(0);\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should be supported in transaction blocks","suites":["pipeline","custom commands"],"updatePoint":{"line":130,"column":49,"index":4676},"line":130,"code":"    it(\"should be supported in transaction blocks\", done => {\n      redis.pipeline().multi().set(\"foo\", \"asdf\").echo(\"bar\", \"baz\", \"123\", \"abc\").get(\"foo\").exec().exec(function (err, results) {\n        expect(err).to.eql(null);\n        expect(results[4][1][1]).to.eql([\"bar\", \"baz\", \"123\", \"abc\"]);\n        expect(results[4][1][2]).to.eql(\"asdf\");\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should accept commands in constructor","suites":["pipeline","#addBatch"],"updatePoint":{"line":140,"column":45,"index":5092},"line":140,"code":"    it(\"should accept commands in constructor\", done => {\n      const redis = new Redis();\n      let pending = 1;\n      redis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\", function (err, result) {\n        expect(result).to.eql(\"bar\");\n        pending -= 1;\n      }]]).exec(function (err, results) {\n        expect(pending).to.eql(0);\n        expect(results[1][1]).to.eql(\"bar\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should group results","suites":["pipeline","exec"],"updatePoint":{"line":155,"column":28,"index":5551},"line":155,"code":"    it(\"should group results\", done => {\n      const redis = new Redis();\n      redis.multi({\n        pipeline: false\n      });\n      redis.set(\"foo\", \"bar\");\n      redis.get(\"foo\");\n      redis.exec().then(() => {\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should allow omitting callback","suites":["pipeline","exec"],"updatePoint":{"line":167,"column":38,"index":5838},"line":167,"code":"    it(\"should allow omitting callback\", done => {\n      const redis = new Redis();\n      redis.exec().catch(function (err) {\n        expect(err.message).to.eql(\"ERR EXEC without MULTI\");\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should batch all commands before ready event","suites":["pipeline","exec"],"updatePoint":{"line":175,"column":52,"index":6102},"line":175,"code":"    it(\"should batch all commands before ready event\", done => {\n      const redis = new Redis();\n      redis.on(\"connect\", () => {\n        redis.pipeline().info().config(\"get\", \"maxmemory\").exec(function (err, res) {\n          expect(err).to.eql(null);\n          expect(res).to.have.lengthOf(2);\n          expect(res[0][0]).to.eql(null);\n          expect(typeof res[0][1]).to.eql(\"string\");\n          expect(res[1][0]).to.eql(null);\n          expect(Array.isArray(res[1][1])).to.eql(true);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should check and load uniq scripts only","suites":["pipeline","exec"],"updatePoint":{"line":190,"column":47,"index":6666},"line":190,"code":"    it(\"should check and load uniq scripts only\", async () => {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 2,\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n      redis.defineCommand(\"echo\", {\n        numberOfKeys: 1,\n        lua: \"return {KEYS[1],ARGV[1]}\"\n      });\n      const expectedCommands = [[\"eval\"], [\"evalsha\"], [\"eval\"], [\"evalsha\"], [\"evalsha\"], [\"evalsha\"]];\n      const expectedResults = [[null, [\"a\", \"1\"]], [null, [\"b\", \"2\"]], [null, [\"k1\", \"k2\", \"v1\", \"v2\"]], [null, [\"k3\", \"k4\", \"v3\", \"v4\"]], [null, [\"c\", \"3\"]], [null, [\"k5\", \"k6\", \"v5\", \"v6\"]]];\n      const commands = await getCommandsFromMonitor(redis, 6, () => {\n        return redis.pipeline().echo(\"a\", \"1\").echo(\"b\", \"2\").test(\"k1\", \"k2\", \"v1\", \"v2\").test(\"k3\", \"k4\", \"v3\", \"v4\").echo(\"c\", \"3\").test(\"k5\", \"k6\", \"v5\", \"v6\").exec().then(results => {\n          expect(results).to.eql(expectedResults);\n        });\n      });\n      redis.disconnect();\n      expectedCommands.forEach((expectedCommand, j) => {\n        expectedCommand.forEach((arg, i) => expect(arg).to.eql(commands[j][i].toLowerCase()));\n      });\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should support parallel script execution","suites":["pipeline","exec"],"updatePoint":{"line":212,"column":48,"index":7829},"line":212,"code":"    it(\"should support parallel script execution\", done => {\n      const random = `${Math.random()}`;\n      const redis = new Redis();\n      redis.defineCommand(\"something\", {\n        numberOfKeys: 0,\n        lua: `return \"${random}\"`\n      });\n      Promise.all([redis.multi([[\"something\"]]).exec(), redis.multi([[\"something\"]]).exec()]).then(([[first], [second]]) => {\n        expect(first[0]).to.equal(null);\n        expect(first[1]).to.equal(random);\n        expect(second[0]).to.equal(null);\n        expect(second[1]).to.equal(random);\n        redis.disconnect();\n        done();\n      }).catch(done);\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should reload scripts on redis restart (reconnect)","suites":["pipeline","exec"],"updatePoint":{"line":228,"column":58,"index":8454},"line":228,"code":"    it(\"should reload scripts on redis restart (reconnect)\", async () => {\n      const redis = new Redis({\n        connectionName: \"load-script-on-reconnect\"\n      });\n      const redis2 = new Redis();\n      redis.defineCommand(\"execafterreconnect\", {\n        numberOfKeys: 0,\n        lua: `return \"Foo\"`\n      });\n      const preloadscript = await redis.pipeline().execafterreconnect().exec();\n      expect(preloadscript[0][0]).to.equal(null);\n      expect(preloadscript[0][1]).to.equal(\"Foo\");\n      const client = await redis.client(\"list\").then(clients => {\n        const myInfo = clients.split(\"\\n\").find(client => client.includes(\"load-script-on-reconnect\"));\n        const match = / addr=([^ ]+)/.exec(myInfo);\n        if (match) return match[1];\n      });\n      await redis2.script(\"flush\");\n      await redis2.client(\"kill\", \"addr\", client);\n      await redis.get(\"waitforready\");\n      const commands = await getCommandsFromMonitor(redis2, 3, () => {\n        return redis.pipeline([[\"set\", \"foo\", \"bar\"], [\"execafterreconnect\"], [\"get\", \"foo\"]]).exec();\n      });\n      redis.disconnect();\n      redis2.disconnect();\n      const expected = [\"set\", \"eval\", \"get\"];\n      expect(commands.map(c => c[0].toLowerCase())).to.have.members(expected);\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"return the command count","suites":["pipeline","#length"],"updatePoint":{"line":258,"column":32,"index":9725},"line":258,"code":"    it(\"return the command count\", () => {\n      const redis = new Redis();\n      const pipeline1 = redis.pipeline().multi().set(\"foo\", \"bar\").get(\"foo\").exec();\n      expect(pipeline1.length).to.eql(4);\n      const pipeline2 = redis.pipeline([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\"]]);\n      expect(pipeline2.length).to.eql(2);\n      redis.disconnect();\n    });","file":"functional/pipeline.ts","skipped":false,"dir":"test"},{"name":"should invoke the callback when subscribe successfully","suites":["pub/sub"],"updatePoint":{"line":4,"column":60,"index":163},"line":4,"code":"  it(\"should invoke the callback when subscribe successfully\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.subscribe(\"foo\", \"bar\", function (err, count) {\n      expect(count).to.eql(2);\n      pending -= 1;\n    });\n    redis.subscribe(\"foo\", \"zoo\", function (err, count) {\n      expect(count).to.eql(3);\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should reject when issue a command in the subscriber mode","suites":["pub/sub"],"updatePoint":{"line":18,"column":63,"index":584},"line":18,"code":"  it(\"should reject when issue a command in the subscriber mode\", done => {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", function () {\n      redis.set(\"foo\", \"bar\", function (err) {\n        expect(err instanceof Error);\n        expect(err.message).to.match(/subscriber mode/);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should report being in 'subscriber' mode when subscribed","suites":["pub/sub"],"updatePoint":{"line":29,"column":62,"index":941},"line":29,"code":"  it(\"should report being in 'subscriber' mode when subscribed\", done => {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", function () {\n      expect(redis.mode).to.equal(\"subscriber\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should exit subscriber mode using unsubscribe","suites":["pub/sub"],"updatePoint":{"line":37,"column":51,"index":1180},"line":37,"code":"  it(\"should exit subscriber mode using unsubscribe\", done => {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", \"bar\", function () {\n      redis.unsubscribe(\"foo\", \"bar\", function (err, count) {\n        expect(count).to.eql(0);\n        redis.set(\"foo\", \"bar\", function (err) {\n          expect(err).to.eql(null);\n          redis.subscribe(\"zoo\", \"foo\", function () {\n            redis.unsubscribe(function (err, count) {\n              expect(count).to.eql(0);\n              redis.set(\"foo\", \"bar\", function (err) {\n                expect(err).to.eql(null);\n                redis.disconnect();\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should report being in 'normal' mode after unsubscribing","suites":["pub/sub"],"updatePoint":{"line":58,"column":62,"index":1902},"line":58,"code":"  it(\"should report being in 'normal' mode after unsubscribing\", done => {\n    const redis = new Redis();\n    redis.subscribe(\"foo\", \"bar\", function () {\n      redis.unsubscribe(\"foo\", \"bar\", function (err, count) {\n        expect(redis.mode).to.equal(\"normal\");\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should receive messages when subscribe a channel","suites":["pub/sub"],"updatePoint":{"line":68,"column":54,"index":2225},"line":68,"code":"  it(\"should receive messages when subscribe a channel\", done => {\n    const redis = new Redis();\n    const pub = new Redis();\n    let pending = 2;\n    redis.subscribe(\"foo\", function () {\n      pub.publish(\"foo\", \"bar\");\n    });\n    redis.on(\"message\", function (channel, message) {\n      expect(channel).to.eql(\"foo\");\n      expect(message).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n    redis.on(\"messageBuffer\", function (channel, message) {\n      expect(channel).to.be.instanceof(Buffer);\n      expect(channel.toString()).to.eql(\"foo\");\n      expect(message).to.be.instanceof(Buffer);\n      expect(message.toString()).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should receive messages when psubscribe a pattern","suites":["pub/sub"],"updatePoint":{"line":94,"column":55,"index":3012},"line":94,"code":"  it(\"should receive messages when psubscribe a pattern\", done => {\n    const redis = new Redis();\n    const pub = new Redis();\n    let pending = 2;\n    redis.psubscribe(\"f?oo\", function () {\n      pub.publish(\"fzoo\", \"bar\");\n    });\n    redis.on(\"pmessage\", function (pattern, channel, message) {\n      expect(pattern).to.eql(\"f?oo\");\n      expect(channel).to.eql(\"fzoo\");\n      expect(message).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        pub.disconnect();\n        done();\n      }\n    });\n    redis.on(\"pmessageBuffer\", function (pattern, channel, message) {\n      expect(pattern).to.eql(\"f?oo\");\n      expect(channel).to.be.instanceof(Buffer);\n      expect(channel.toString()).to.eql(\"fzoo\");\n      expect(message).to.be.instanceof(Buffer);\n      expect(message.toString()).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        pub.disconnect();\n        done();\n      }\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should exit subscriber mode using punsubscribe","suites":["pub/sub"],"updatePoint":{"line":124,"column":52,"index":3949},"line":124,"code":"  it(\"should exit subscriber mode using punsubscribe\", async () => {\n    const redis = new Redis();\n    await redis.psubscribe(\"f?oo\", \"b?ar\");\n    const count = await redis.punsubscribe(\"f?oo\", \"b?ar\");\n    expect(count).to.eql(0);\n    await redis.set(\"foo\", \"bar\");\n    await redis.psubscribe(\"z?oo\", \"f?oo\");\n    const newCount = await redis.punsubscribe();\n    expect(newCount).to.eql(0);\n    await redis.set(\"foo\", \"bar\");\n    redis.disconnect();\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should be able to send quit command in the subscriber mode","suites":["pub/sub"],"updatePoint":{"line":136,"column":64,"index":4419},"line":136,"code":"  it(\"should be able to send quit command in the subscriber mode\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.subscribe(\"foo\", function () {\n      redis.quit(function () {\n        pending -= 1;\n      });\n    });\n    redis.on(\"end\", function () {\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should restore subscription after reconnecting(subscribe)","suites":["pub/sub"],"updatePoint":{"line":150,"column":63,"index":4780},"line":150,"code":"  it(\"should restore subscription after reconnecting(subscribe)\", done => {\n    const redis = new Redis();\n    const pub = new Redis();\n    redis.subscribe(\"foo\", \"bar\", function () {\n      redis.on(\"ready\", function () {\n        // Execute a random command to make sure that `subscribe`\n        // is sent\n        redis.ping(function () {\n          let pending = 2;\n          redis.on(\"message\", function (channel, message) {\n            if (! --pending) {\n              redis.disconnect();\n              pub.disconnect();\n              done();\n            }\n          });\n          pub.publish(\"foo\", \"hi1\");\n          pub.publish(\"bar\", \"hi2\");\n        });\n      });\n      redis.disconnect(true);\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should restore subscription after reconnecting(psubscribe)","suites":["pub/sub"],"updatePoint":{"line":173,"column":64,"index":5495},"line":173,"code":"  it(\"should restore subscription after reconnecting(psubscribe)\", done => {\n    const redis = new Redis();\n    const pub = new Redis();\n    redis.psubscribe(\"fo?o\", \"ba?r\", function () {\n      redis.on(\"ready\", function () {\n        redis.ping(function () {\n          let pending = 2;\n          redis.on(\"pmessage\", function (pattern, channel, message) {\n            if (! --pending) {\n              redis.disconnect();\n              pub.disconnect();\n              done();\n            }\n          });\n          pub.publish(\"fo1o\", \"hi1\");\n          pub.publish(\"ba1r\", \"hi2\");\n        });\n      });\n      redis.disconnect(true);\n    });\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should unsubscribe when stringNumbers is enabled","suites":["pub/sub"],"updatePoint":{"line":194,"column":54,"index":6130},"line":194,"code":"  it(\"should unsubscribe when stringNumbers is enabled\", async () => {\n    const redis = new Redis({\n      stringNumbers: true\n    });\n    await redis.subscribe(\"foo\");\n    const count = await redis.unsubscribe();\n    expect(count).to.eql(\"0\");\n    expect(await redis.set(\"foo\", \"bar\")).to.eql(\"OK\");\n    redis.disconnect();\n  });","file":"functional/pub_sub.ts","skipped":false,"dir":"test"},{"name":"should retry when redis is not ready","suites":["ready_check"],"updatePoint":{"line":14,"column":42,"index":517},"line":14,"code":"  it(\"should retry when redis is not ready\", done => {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    stubInfo(redis, [null, \"loading:1\\r\\nloading_eta_seconds:7\"]);\n\n    // @ts-expect-error\n    sinon.stub(global, \"setTimeout\").callsFake((_body, ms) => {\n      if (ms === 7000) {\n        done();\n      }\n    });\n    redis.connect().catch(noop);\n  });","file":"functional/ready_check.ts","skipped":false,"dir":"test"},{"name":"should reconnect when info return a error","suites":["ready_check"],"updatePoint":{"line":28,"column":47,"index":891},"line":28,"code":"  it(\"should reconnect when info return a error\", done => {\n    const redis = new Redis({\n      lazyConnect: true,\n      retryStrategy: () => {\n        done();\n        return;\n      }\n    });\n    stubInfo(redis, [new Error(\"info error\"), undefined]);\n    redis.connect().catch(noop);\n  });","file":"functional/ready_check.ts","skipped":false,"dir":"test"},{"name":"warns for NOPERM error","suites":["ready_check"],"updatePoint":{"line":39,"column":28,"index":1162},"line":39,"code":"  it(\"warns for NOPERM error\", async () => {\n    const redis = new Redis({\n      lazyConnect: true\n    });\n    const warn = sinon.stub(console, \"warn\");\n    stubInfo(redis, [new Error(\"NOPERM this user has no permissions to run the 'info' command\"), undefined]);\n    await redis.connect();\n    expect(warn.calledOnce).to.eql(true);\n  });","file":"functional/ready_check.ts","skipped":false,"dir":"test"},{"name":"should pass the error as the first param","suites":["reconnectOnError"],"updatePoint":{"line":5,"column":46,"index":184},"line":5,"code":"  it(\"should pass the error as the first param\", done => {\n    let pending = 2;\n    function assert(err) {\n      expect(err.name).to.eql(\"ReplyError\");\n      expect(err.command.name).to.eql(\"set\");\n      expect(err.command.args).to.eql([\"foo\"]);\n      if (! --pending) {\n        done();\n      }\n    }\n    const redis = new Redis({\n      reconnectOnError: function (err) {\n        assert(err);\n        return 1;\n      }\n    });\n    redis.set(\"foo\", function (err) {\n      assert(err);\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should not reconnect if reconnectOnError returns false","suites":["reconnectOnError"],"updatePoint":{"line":25,"column":60,"index":696},"line":25,"code":"  it(\"should not reconnect if reconnectOnError returns false\", done => {\n    const redis = new Redis({\n      reconnectOnError: function (err) {\n        return false;\n      }\n    });\n    redis.disconnect = () => {\n      throw new Error(\"should not disconnect\");\n    };\n    redis.set(\"foo\", function (err) {\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should reconnect if reconnectOnError returns true or 1","suites":["reconnectOnError"],"updatePoint":{"line":38,"column":60,"index":1030},"line":38,"code":"  it(\"should reconnect if reconnectOnError returns true or 1\", done => {\n    const redis = new Redis({\n      reconnectOnError: () => {\n        return true;\n      }\n    });\n    redis.set(\"foo\", () => {\n      redis.on(\"ready\", () => {\n        done();\n      });\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should reconnect and retry the command if reconnectOnError returns 2","suites":["reconnectOnError"],"updatePoint":{"line":50,"column":74,"index":1317},"line":50,"code":"  it(\"should reconnect and retry the command if reconnectOnError returns 2\", done => {\n    const redis = new Redis({\n      reconnectOnError: () => {\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.sadd(\"foo\", \"a\", function (err, res) {\n      expect(res).to.eql(1);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should select the currect database","suites":["reconnectOnError"],"updatePoint":{"line":63,"column":40,"index":1627},"line":63,"code":"  it(\"should select the currect database\", done => {\n    const redis = new Redis({\n      reconnectOnError: () => {\n        redis.select(3);\n        redis.del(\"foo\");\n        redis.select(0);\n        return 2;\n      }\n    });\n    redis.select(3);\n    redis.set(\"foo\", \"bar\");\n    redis.sadd(\"foo\", \"a\", function (err, res) {\n      expect(res).to.eql(1);\n      redis.select(3);\n      redis.type(\"foo\", function (err, type) {\n        expect(type).to.eql(\"set\");\n        done();\n      });\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should work with pipeline","suites":["reconnectOnError"],"updatePoint":{"line":83,"column":31,"index":2117},"line":83,"code":"  it(\"should work with pipeline\", done => {\n    const redis = new Redis({\n      reconnectOnError: () => {\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.pipeline().get(\"foo\").sadd(\"foo\", \"a\").exec(function (err, res) {\n      expect(res).to.eql([[null, \"bar\"], [null, 1]]);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should work with pipelined multi","suites":["reconnectOnError"],"updatePoint":{"line":96,"column":38,"index":2477},"line":96,"code":"  it(\"should work with pipelined multi\", done => {\n    const redis = new Redis({\n      reconnectOnError: () => {\n        // deleting foo allows sadd below to succeed on the second try\n        redis.del(\"foo\");\n        return 2;\n      }\n    });\n    const delSpy = sinon.spy(redis, \"del\");\n    redis.set(\"foo\", \"bar\");\n    redis.set(\"i\", 1);\n    redis.pipeline().sadd(\"foo\", \"a\") // trigger a WRONGTYPE error\n    .multi().get(\"foo\").incr(\"i\").exec().exec(function (err, res) {\n      expect(delSpy.calledOnce).to.eql(true);\n      expect(delSpy.firstCall.args[0]).to.eql(\"foo\");\n      expect(err).to.be.null;\n      expect(res).to.eql([[null, 1], [null, \"OK\"], [null, \"QUEUED\"], [null, \"QUEUED\"], [null, [\"bar\", 2]]]);\n      done();\n    });\n  });","file":"functional/reconnect_on_error.ts","skipped":false,"dir":"test"},{"name":"should return a readable stream","suites":["*scanStream","scanStream"],"updatePoint":{"line":9,"column":39,"index":326},"line":9,"code":"    it(\"should return a readable stream\", () => {\n      const redis = new Redis();\n      const stream = redis.scanStream();\n      expect(stream instanceof Readable).to.eql(true);\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should iterate all keys","suites":["*scanStream","scanStream"],"updatePoint":{"line":14,"column":31,"index":505},"line":14,"code":"    it(\"should iterate all keys\", done => {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, () => {\n        const stream = redis.scanStream();\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys.sort()).to.eql([\"foo1\", \"foo10\", \"foo2\", \"foo3\", \"foo4\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `MATCH`","suites":["*scanStream","scanStream"],"updatePoint":{"line":29,"column":32,"index":1012},"line":29,"code":"    it(\"should recognize `MATCH`\", done => {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, () => {\n        const stream = redis.scanStream({\n          match: \"foo??\"\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys).to.eql([\"foo10\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `TYPE`","suites":["*scanStream","scanStream"],"updatePoint":{"line":46,"column":31,"index":1515},"line":46,"code":"    it(\"should recognize `TYPE`\", async () => {\n      let keys = [];\n      const redis = new Redis();\n      redis.set(\"foo1\", \"bar\");\n      redis.set(\"foo2\", \"bar\");\n      redis.set(\"foo3\", \"bar\");\n      redis.lpush(\"loo1\", \"1\");\n      redis.lpush(\"loo2\", \"1\");\n      redis.lpush(\"loo3\", \"1\");\n      const stream = redis.scanStream({\n        type: \"list\"\n      });\n      stream.on(\"data\", function (data) {\n        keys = keys.concat(data);\n      });\n      return new Promise(resolve => {\n        stream.on(\"end\", () => {\n          expect(keys.sort()).to.eql([\"loo1\", \"loo2\", \"loo3\"]);\n          redis.disconnect();\n          resolve();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should recognize `COUNT`","suites":["*scanStream","scanStream"],"updatePoint":{"line":69,"column":32,"index":2183},"line":69,"code":"    it(\"should recognize `COUNT`\", done => {\n      let keys = [];\n      const redis = new Redis();\n      sinon.spy(Redis.prototype, \"scan\");\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, () => {\n        const stream = redis.scanStream({\n          count: 2\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys.sort()).to.eql([\"foo1\", \"foo10\", \"foo2\", \"foo3\", \"foo4\"]);\n          const [args] = Redis.prototype.scan.getCall(0).args;\n          let count;\n          for (let i = 0; i < args.length; ++i) {\n            if (typeof args[i] === \"string\" && args[i].toUpperCase() === \"COUNT\") {\n              count = args[i + 1];\n              break;\n            }\n          }\n          expect(count).to.eql(\"2\");\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should emit an error when connection is down","suites":["*scanStream","scanStream"],"updatePoint":{"line":96,"column":52,"index":3119},"line":96,"code":"    it(\"should emit an error when connection is down\", done => {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, () => {\n        redis.disconnect();\n        const stream = redis.scanStream({\n          count: 1\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"error\", function (err) {\n          expect(err.message).to.eql(\"Connection is closed.\");\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should return buffer","suites":["*scanStream","scanBufferStream"],"updatePoint":{"line":115,"column":28,"index":3688},"line":115,"code":"    it(\"should return buffer\", done => {\n      let keys = [];\n      const redis = new Redis();\n      redis.mset(\"foo1\", 1, \"foo2\", 1, \"foo3\", 1, \"foo4\", 1, \"foo10\", 1, () => {\n        const stream = redis.scanBufferStream();\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys.sort()).to.eql([Buffer.from(\"foo1\"), Buffer.from(\"foo10\"), Buffer.from(\"foo2\"), Buffer.from(\"foo3\"), Buffer.from(\"foo4\")]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should iterate all values in the set","suites":["*scanStream","sscanStream"],"updatePoint":{"line":132,"column":44,"index":4318},"line":132,"code":"    it(\"should iterate all values in the set\", done => {\n      let keys = [];\n      const redis = new Redis();\n      redis.sadd(\"set\", \"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo10\", () => {\n        const stream = redis.sscanStream(\"set\", {\n          match: \"foo??\"\n        });\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys).to.eql([\"foo10\"]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"should work in cluster mode","suites":["*scanStream","Cluster"],"updatePoint":{"line":151,"column":35,"index":4861},"line":151,"code":"    it(\"should work in cluster mode\", done => {\n      const slotTable = [[0, 5460, [\"127.0.0.1\", 30001]], [5461, 10922, [\"127.0.0.1\", 30002]], [10923, 16383, [\"127.0.0.1\", 30003]]];\n      const serverKeys = [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo10\"];\n      const argvHandler = function (argv) {\n        if (argv[0] === \"cluster\" && argv[1] === \"SLOTS\") {\n          return slotTable;\n        }\n        if (argv[0] === \"sscan\" && argv[1] === \"set\") {\n          const cursor = Number(argv[2]);\n          if (cursor >= serverKeys.length) {\n            return [\"0\", []];\n          }\n          return [String(cursor + 1), [serverKeys[cursor]]];\n        }\n      };\n      new MockServer(30001, argvHandler);\n      new MockServer(30002, argvHandler);\n      new MockServer(30003, argvHandler);\n      const cluster = new Cluster([{\n        host: \"127.0.0.1\",\n        port: \"30001\"\n      }]);\n      let keys = [];\n      // @ts-expect-error\n      cluster.sadd(\"set\", serverKeys, () => {\n        // @ts-expect-error\n        const stream = cluster.sscanStream(\"set\");\n        stream.on(\"data\", function (data) {\n          keys = keys.concat(data);\n        });\n        stream.on(\"end\", () => {\n          expect(keys).to.eql(serverKeys);\n          cluster.disconnect();\n          done();\n        });\n      });\n    });","file":"functional/scan_stream.ts","skipped":false,"dir":"test"},{"name":"accepts constructor options","suites":["scripting"],"updatePoint":{"line":6,"column":33,"index":222},"line":6,"code":"  it(\"accepts constructor options\", async () => {\n    const redis = new Redis({\n      scripts: {\n        test: {\n          numberOfKeys: 2,\n          lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n        },\n        testDynamic: {\n          lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n        }\n      }\n    });\n\n    // @ts-expect-error\n    expect(await redis.test(\"k1\", \"k2\", \"a1\", \"a2\")).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n    // @ts-expect-error\n    expect(await redis.testDynamic(2, \"k1\", \"k2\", \"a1\", \"a2\")).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n    redis.disconnect();\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should recognize the numberOfKeys property","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":26,"column":50,"index":854},"line":26,"code":"    it(\"should recognize the numberOfKeys property\", done => {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 2,\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n\n      // @ts-expect-error\n      redis.test(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n        expect(result).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support dynamic key count","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":40,"column":40,"index":1273},"line":40,"code":"    it(\"should support dynamic key count\", done => {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n\n      // @ts-expect-error\n      redis.test(2, \"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n        expect(result).to.eql([\"k1\", \"k2\", \"a1\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support numberOfKeys being 0","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":53,"column":43,"index":1673},"line":53,"code":"    it(\"should support numberOfKeys being 0\", done => {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        numberOfKeys: 0,\n        lua: \"return {ARGV[1],ARGV[2]}\"\n      });\n\n      // @ts-expect-error\n      redis.test(\"2\", \"a2\", (err, result) => {\n        expect(result).to.eql([\"2\", \"a2\"]);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should throw when numberOfKeys is omit","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":67,"column":46,"index":2056},"line":67,"code":"    it(\"should throw when numberOfKeys is omit\", done => {\n      const redis = new Redis();\n      redis.defineCommand(\"test\", {\n        lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n      });\n\n      // @ts-expect-error\n      redis.test(\"k1\", \"k2\", \"a1\", \"a2\", function (err) {\n        expect(err).to.be.instanceof(Error);\n        expect(err.toString()).to.match(/value is not an integer/);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should have a buffer version","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":82,"column":34,"index":2504},"line":82,"code":"  it(\"should have a buffer version\", done => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n\n    // @ts-expect-error\n    redis.testBuffer(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n      expect(result).to.eql([Buffer.from(\"k1\"), Buffer.from(\"k2\"), Buffer.from(\"a1\"), Buffer.from(\"a2\")]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should work well with pipeline","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":96,"column":36,"index":2953},"line":96,"code":"  it(\"should work well with pipeline\", done => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.pipeline().set(\"test\", \"pipeline\")\n    // @ts-expect-error\n    .test(\"test\").exec((err, results) => {\n      expect(results).to.eql([[null, \"OK\"], [null, \"pipeline\"]]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should following pipeline style when throw","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":110,"column":48,"index":3389},"line":110,"code":"  it(\"should following pipeline style when throw\", done => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n    redis.pipeline().set(\"test\", \"pipeline\")\n    // @ts-expect-error\n    .test(\"test\").exec(function (err, results) {\n      expect(err).to.eql(null);\n      expect(results[1][0]).to.be.instanceof(Error);\n      expect(results[1][0].message).to.match(/value is not an integer/);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should use evalsha when script is loaded","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":125,"column":46,"index":3898},"line":125,"code":"  it(\"should use evalsha when script is loaded\", async () => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      lua: \"return 1\"\n    });\n    // @ts-expect-error\n    await redis.test(0);\n    const commands = await getCommandsFromMonitor(redis, 1, () => {\n      // @ts-expect-error\n      return redis.test(0);\n    });\n    expect(commands[0]).to.eql([\"evalsha\", \"e0e1f9fabfc9d4800c877a703b823ac0578ff8db\", \"0\"]);\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should try to use EVALSHA and fallback to EVAL if fails","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":138,"column":61,"index":4350},"line":138,"code":"  it(\"should try to use EVALSHA and fallback to EVAL if fails\", async () => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n\n    // @ts-expect-error\n    await redis.test(\"preload\");\n    // @ts-expect-error\n    await redis.script(\"flush\");\n    const commands = await getCommandsFromMonitor(redis, 5, async () => {\n      // @ts-expect-error\n      await redis.test(\"foo\");\n      // @ts-expect-error\n      await redis.test(\"bar\");\n    });\n    const expectedComands = [\"evalsha\", \"eval\", \"get\", \"evalsha\", \"get\"];\n    expect(commands.map(c => c[0].toLowerCase())).to.have.members(expectedComands);\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should load scripts first before execution of pipeline","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":158,"column":60,"index":5045},"line":158,"code":"  it(\"should load scripts first before execution of pipeline\", async () => {\n    const redis = new Redis();\n    redis.defineCommand(\"testGet\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n\n    // @ts-expect-error\n    await redis.testGet(\"init\");\n    redis.defineCommand(\"testSet\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"set\", KEYS[1], \"bar\")'\n    });\n    const commands = await getCommandsFromMonitor(redis, 5, () => {\n      // @ts-expect-error\n      return redis.pipeline().testGet(\"foo\").testSet(\"foo\").get(\"foo\").exec();\n    });\n    const expectedComands = [\"evalsha\", \"get\", \"eval\", \"set\", \"get\"];\n    expect(commands.map(c => c[0].toLowerCase())).to.have.members(expectedComands);\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"does not fallback to EVAL in regular transaction","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":178,"column":54,"index":5783},"line":178,"code":"  it(\"does not fallback to EVAL in regular transaction\", async () => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n\n    // @ts-expect-error\n    await redis.test(\"preload\");\n    // @ts-expect-error\n    await redis.script(\"flush\");\n    const spy = sinon.spy(redis, \"sendCommand\");\n    const commands = await getCommandsFromMonitor(redis, 4, async () => {\n      // @ts-expect-error\n      const [a, b] = await redis.multi().test(\"foo\").test(\"bar\").exec();\n      expect(a[0].message).to.equal(\"NOSCRIPT No matching script. Please use EVAL.\");\n      expect(b[0].message).to.equal(\"NOSCRIPT No matching script. Please use EVAL.\");\n    });\n    spy.restore();\n    expect(spy.callCount).to.equal(4);\n    const expectedComands = [\"multi\", \"evalsha\", \"evalsha\", \"exec\"];\n    expect(commands.map(c => c[0].toLowerCase())).to.have.members(expectedComands);\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"does not fallback to EVAL in manual transaction","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":201,"column":53,"index":6730},"line":201,"code":"  it(\"does not fallback to EVAL in manual transaction\", async () => {\n    const redis = new Redis();\n    redis.defineCommand(\"test\", {\n      numberOfKeys: 1,\n      lua: 'return redis.call(\"get\", KEYS[1])'\n    });\n\n    // @ts-expect-error\n    await redis.test(\"preload\");\n    // @ts-expect-error\n    await redis.script(\"flush\");\n    const spy = sinon.spy(redis, \"sendCommand\");\n    const commands = await getCommandsFromMonitor(redis, 4, async () => {\n      await redis.pipeline([[\"multi\"], [\"test\", \"foo\"], [\"test\", \"bar\"], [\"exec\"]]).exec();\n    });\n    spy.restore();\n    expect(spy.callCount).to.equal(4);\n    const expectedComands = [\"multi\", \"evalsha\", \"evalsha\", \"exec\"];\n    expect(commands.map(c => c[0].toLowerCase())).to.have.members(expectedComands);\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["scripting","#numberOfKeys"],"updatePoint":{"line":221,"column":34,"index":7479},"line":221,"code":"  it(\"should support key prefixing\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.defineCommand(\"echo\", {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\"\n    });\n\n    // @ts-expect-error\n    redis.echo(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n      expect(result).to.eql([\"foo:k1\", \"foo:k2\", \"a1\", \"a2\"]);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/scripting.ts","skipped":false,"dir":"test"},{"name":"should support auto select","suites":["select"],"updatePoint":{"line":4,"column":32,"index":134},"line":4,"code":"  it(\"should support auto select\", done => {\n    const redis = new Redis({\n      db: 2\n    });\n    redis.set(\"foo\", \"2\");\n    redis.select(\"2\");\n    redis.get(\"foo\", function (err, res) {\n      expect(res).to.eql(\"2\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should resend commands to the correct db","suites":["select"],"updatePoint":{"line":16,"column":46,"index":421},"line":16,"code":"  it(\"should resend commands to the correct db\", done => {\n    const redis = new Redis();\n    redis.once(\"ready\", function () {\n      redis.set(\"foo\", \"2\", function () {\n        redis.stream.destroy();\n        redis.select(\"3\");\n        redis.set(\"foo\", \"3\");\n        redis.select(\"0\");\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"2\");\n          redis.select(\"3\");\n          redis.get(\"foo\", function (err, res) {\n            expect(res).to.eql(\"3\");\n            redis.disconnect();\n            done();\n          });\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should re-select the current db when reconnect","suites":["select"],"updatePoint":{"line":36,"column":52,"index":1013},"line":36,"code":"  it(\"should re-select the current db when reconnect\", done => {\n    const redis = new Redis();\n    redis.once(\"ready\", function () {\n      redis.set(\"foo\", \"bar\");\n      redis.select(2);\n      redis.set(\"foo\", \"2\", function () {\n        redis.stream.destroy();\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"2\");\n          redis.disconnect();\n          done();\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should emit \"select\" event when db changes","suites":["select"],"updatePoint":{"line":51,"column":48,"index":1437},"line":51,"code":"  it('should emit \"select\" event when db changes', done => {\n    const changes = [];\n    const redis = new Redis();\n    redis.on(\"select\", function (db) {\n      changes.push(db);\n    });\n    redis.select(\"2\", function () {\n      expect(changes).to.eql([2]);\n      redis.select(\"4\", function () {\n        expect(changes).to.eql([2, 4]);\n        redis.select(\"4\", function () {\n          expect(changes).to.eql([2, 4]);\n          redis.disconnect();\n          done();\n        });\n      });\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should be sent on the connect event","suites":["select"],"updatePoint":{"line":69,"column":41,"index":1932},"line":69,"code":"  it(\"should be sent on the connect event\", done => {\n    const redis = new Redis({\n      db: 2\n    });\n    const select = redis.select;\n    redis.select = function () {\n      return select.apply(redis, arguments).then(function () {\n        redis.select = select;\n        redis.disconnect();\n        done();\n      });\n    };\n    redis.on(\"connect\", function () {\n      redis.subscribe(\"anychannel\");\n    });\n  });","file":"functional/select.ts","skipped":false,"dir":"test"},{"name":"should support callback","suites":["send command"],"updatePoint":{"line":4,"column":29,"index":131},"line":4,"code":"  it(\"should support callback\", done => {\n    const redis = new Redis();\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\", function (err, result) {\n      expect(result).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support promise","suites":["send command"],"updatePoint":{"line":12,"column":28,"index":342},"line":12,"code":"  it(\"should support promise\", () => {\n    const redis = new Redis();\n    redis.set(\"foo\", \"bar\");\n    return redis.get(\"foo\").then(function (result) {\n      expect(result).to.eql(\"bar\");\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should keep the response order when mix using callback & promise","suites":["send command"],"updatePoint":{"line":19,"column":70,"index":586},"line":19,"code":"  it(\"should keep the response order when mix using callback & promise\", done => {\n    const redis = new Redis();\n    let order = 0;\n    redis.get(\"foo\").then(() => {\n      expect(++order).to.eql(1);\n    });\n    redis.get(\"foo\", () => {\n      expect(++order).to.eql(2);\n    });\n    redis.get(\"foo\").then(() => {\n      expect(++order).to.eql(3);\n    });\n    redis.get(\"foo\", () => {\n      expect(++order).to.eql(4);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support get & set buffer","suites":["send command"],"updatePoint":{"line":36,"column":37,"index":996},"line":36,"code":"  it(\"should support get & set buffer\", done => {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"foo\"), Buffer.from(\"bar\"), function (err, res) {\n      expect(res).to.eql(\"OK\");\n    });\n    redis.getBuffer(Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support get & set buffer via `call`","suites":["send command"],"updatePoint":{"line":47,"column":48,"index":1391},"line":47,"code":"  it(\"should support get & set buffer via `call`\", done => {\n    const redis = new Redis();\n    redis.call(\"set\", Buffer.from(\"foo\"), Buffer.from(\"bar\"), function (err, res) {\n      expect(res).to.eql(\"OK\");\n    });\n    redis.callBuffer(\"get\", Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"bar\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should handle empty buffer","suites":["send command"],"updatePoint":{"line":58,"column":32,"index":1786},"line":58,"code":"  it(\"should handle empty buffer\", done => {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"foo\"), Buffer.from(\"\"));\n    redis.getBuffer(Buffer.from(\"foo\"), function (err, result) {\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support utf8","suites":["send command"],"updatePoint":{"line":67,"column":25,"index":2091},"line":67,"code":"  it(\"should support utf8\", done => {\n    const redis = new Redis();\n    redis.set(Buffer.from(\"\"), String(\"\"));\n    redis.getBuffer(\"\", function (err, result) {\n      expect(result.toString()).to.eql(\"\");\n      redis.get(\"\", function (err, result) {\n        expect(result).to.eql(\"\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should consider null as empty str","suites":["send command"],"updatePoint":{"line":78,"column":39,"index":2443},"line":78,"code":"  it(\"should consider null as empty str\", done => {\n    const redis = new Redis();\n    redis.set(\"foo\", null, () => {\n      redis.get(\"foo\", function (err, res) {\n        expect(res).to.eql(\"\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support return int value","suites":["send command"],"updatePoint":{"line":87,"column":37,"index":2676},"line":87,"code":"  it(\"should support return int value\", done => {\n    const redis = new Redis();\n    redis.exists(\"foo\", function (err, exists) {\n      expect(typeof exists).to.eql(\"number\");\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject when disconnected","suites":["send command"],"updatePoint":{"line":94,"column":37,"index":2880},"line":94,"code":"  it(\"should reject when disconnected\", done => {\n    const redis = new Redis();\n    redis.disconnect();\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/Connection is closed./);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject when enableOfflineQueue is disabled","suites":["send command"],"updatePoint":{"line":102,"column":55,"index":3130},"line":102,"code":"  it(\"should reject when enableOfflineQueue is disabled\", done => {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.get(\"foo\", function (err) {\n      expect(err.message).to.match(/enableOfflineQueue options is false/);\n      done();\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing","suites":["send command"],"updatePoint":{"line":111,"column":34,"index":3388},"line":111,"code":"  it(\"should support key prefixing\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.set(\"bar\", \"baz\");\n    redis.get(\"bar\", function (err, result) {\n      expect(result).to.eql(\"baz\");\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.eql([\"foo:bar\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing with multiple keys","suites":["send command"],"updatePoint":{"line":124,"column":53,"index":3758},"line":124,"code":"  it(\"should support key prefixing with multiple keys\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.lpush(\"app1\", \"test1\");\n    redis.lpush(\"app2\", \"test2\");\n    redis.lpush(\"app3\", \"test3\");\n    redis.blpop(\"app1\", \"app2\", \"app3\", 0, function (err, result) {\n      expect(result).to.eql([\"foo:app1\", \"test1\"]);\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.have.members([\"foo:app2\", \"foo:app3\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support prefixing buffer keys","suites":["send command"],"updatePoint":{"line":139,"column":42,"index":4250},"line":139,"code":"  it(\"should support prefixing buffer keys\", async () => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    await redis.mset(Buffer.from(\"bar\"), Buffer.from(\"baz\"), Buffer.from(\"foo\"), Buffer.from(\"baz\"));\n    await redis.set(Buffer.from([0xff]), Buffer.from(\"baz\"));\n    const redisWOPrefix = new Redis();\n    expect(await redisWOPrefix.get(\"foo:bar\")).to.eql(\"baz\");\n    expect(await redisWOPrefix.get(\"foo:foo\")).to.eql(\"baz\");\n    expect(await redisWOPrefix.get(Buffer.from([0x66, 0x6f, 0x6f, 0x3a, 0xff]))).to.eql(\"baz\");\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support buffer as keyPrefix","suites":["send command"],"updatePoint":{"line":150,"column":40,"index":4798},"line":150,"code":"  it(\"should support buffer as keyPrefix\", async () => {\n    // @ts-expect-error\n    const redis = new Redis({\n      keyPrefix: Buffer.from([0xff])\n    });\n    await redis.mset(\"bar\", Buffer.from(\"baz\"), \"foo\", Buffer.from(\"bar\"));\n    await redis.set(Buffer.from([0xff]), Buffer.from(\"baz\"));\n    const redisWOPrefix = new Redis();\n    expect(await redisWOPrefix.get(Buffer.from([0xff, 0x62, 0x61, 0x72]))).to.eql(\"baz\");\n    expect(await redisWOPrefix.get(Buffer.from([0xff, 0x66, 0x6f, 0x6f]))).to.eql(\"bar\");\n    expect(await redisWOPrefix.get(Buffer.from([0xff, 0xff]))).to.eql(\"baz\");\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing for zunionstore","suites":["send command"],"updatePoint":{"line":162,"column":50,"index":5405},"line":162,"code":"  it(\"should support key prefixing for zunionstore\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.zadd(\"zset1\", 1, \"one\");\n    redis.zadd(\"zset1\", 2, \"two\");\n    redis.zadd(\"zset2\", 1, \"one\");\n    redis.zadd(\"zset2\", 2, \"two\");\n    redis.zadd(\"zset2\", 3, \"three\");\n    redis.zunionstore(\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3, function (err, result) {\n      expect(result).to.eql(3);\n      redis.keys(\"*\", function (err, result) {\n        expect(result).to.have.members([\"foo:zset1\", \"foo:zset2\", \"foo:out\"]);\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should support key prefixing for sort","suites":["send command"],"updatePoint":{"line":179,"column":43,"index":5990},"line":179,"code":"  it(\"should support key prefixing for sort\", done => {\n    const redis = new Redis({\n      keyPrefix: \"foo:\"\n    });\n    redis.hset(\"object_1\", \"name\", \"better\");\n    redis.hset(\"weight_1\", \"value\", \"20\");\n    redis.hset(\"object_2\", \"name\", \"best\");\n    redis.hset(\"weight_2\", \"value\", \"30\");\n    redis.hset(\"object_3\", \"name\", \"good\");\n    redis.hset(\"weight_3\", \"value\", \"10\");\n    redis.lpush(\"src\", \"1\", \"2\", \"3\");\n    redis.sort(\"src\", \"BY\", \"weight_*->value\", \"GET\", \"object_*->name\", \"STORE\", \"dest\", function (err, result) {\n      redis.lrange(\"dest\", 0, -1, function (err, result) {\n        expect(result).to.eql([\"good\", \"better\", \"best\"]);\n        redis.keys(\"*\", function (err, result) {\n          expect(result).to.have.members([\"foo:object_1\", \"foo:weight_1\", \"foo:object_2\", \"foo:weight_2\", \"foo:object_3\", \"foo:weight_3\", \"foo:src\", \"foo:dest\"]);\n          done();\n        });\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should allow sending the loading valid commands in connect event","suites":["send command"],"updatePoint":{"line":200,"column":70,"index":6935},"line":200,"code":"  it(\"should allow sending the loading valid commands in connect event\", done => {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.on(\"connect\", () => {\n      redis.select(2, function (err, res) {\n        expect(res).to.eql(\"OK\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"should reject loading invalid commands in connect event","suites":["send command"],"updatePoint":{"line":211,"column":61,"index":7229},"line":211,"code":"  it(\"should reject loading invalid commands in connect event\", done => {\n    const redis = new Redis({\n      enableOfflineQueue: false\n    });\n    redis.on(\"connect\", () => {\n      redis.get(\"foo\", function (err) {\n        expect(err.message).to.eql(\"Stream isn't writeable and enableOfflineQueue options is false\");\n        done();\n      });\n    });\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"throws for invalid command","suites":["send command"],"updatePoint":{"line":222,"column":32,"index":7558},"line":222,"code":"  it(\"throws for invalid command\", async () => {\n    const redis = new Redis();\n    const invalidCommand = \"\";\n    let err;\n    try {\n      await redis.call(invalidCommand, []);\n    } catch (e) {\n      err = e.message;\n    }\n    expect(err).to.contain(\"unknown command\");\n    expect(err).to.contain(invalidCommand);\n  });","file":"functional/send_command.ts","skipped":false,"dir":"test"},{"name":"connects to server as expected","suites":["sentinel_nat"],"updatePoint":{"line":4,"column":36,"index":156},"line":4,"code":"  it(\"connects to server as expected\", done => {\n    const sentinel = new MockServer(27379, argv => {\n      if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n        return [\"127.0.0.1\", \"17380\"];\n      }\n    });\n    const redis = new Redis({\n      sentinels: [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }],\n      natMap: {\n        \"127.0.0.1:17380\": {\n          host: \"localhost\",\n          port: 6379\n        }\n      },\n      name: \"master\",\n      lazyConnect: true\n    });\n    redis.connect(function (err) {\n      if (err) {\n        sentinel.disconnect(() => {});\n        return done(err);\n      }\n      sentinel.disconnect(done);\n    });\n  });","file":"functional/sentinel_nat.ts","skipped":false,"dir":"test"},{"name":"rejects connection if host is not defined in map","suites":["sentinel_nat"],"updatePoint":{"line":32,"column":54,"index":855},"line":32,"code":"  it(\"rejects connection if host is not defined in map\", done => {\n    const sentinel = new MockServer(27379, argv => {\n      if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n        return [\"127.0.0.1\", \"17380\"];\n      }\n      if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\" && argv[2] === \"master\") {\n        return [\"127.0.0.1\", \"27379\"];\n      }\n    });\n    const redis = new Redis({\n      sentinels: [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }],\n      natMap: {\n        \"127.0.0.1:17381\": {\n          host: \"localhost\",\n          port: 6379\n        }\n      },\n      maxRetriesPerRequest: 1,\n      name: \"master\",\n      lazyConnect: true\n    });\n    redis.connect().then(() => {\n      throw new Error(\"Should not call\");\n    }).catch(function (err) {\n      if (err.message === \"Connection is closed.\") {\n        return done(null);\n      }\n      sentinel.disconnect(done);\n    });\n  });","file":"functional/sentinel_nat.ts","skipped":false,"dir":"test"},{"name":"should connect to sentinel successfully","suites":["sentinel","connect"],"updatePoint":{"line":14,"column":47,"index":495},"line":14,"code":"    it(\"should connect to sentinel successfully\", done => {\n      const sentinel = new MockServer(27379);\n      sentinel.once(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should default to the default sentinel port","suites":["sentinel","connect"],"updatePoint":{"line":28,"column":51,"index":875},"line":28,"code":"    it(\"should default to the default sentinel port\", done => {\n      const sentinel = new MockServer(26379);\n      sentinel.once(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\"\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should try to connect to all sentinel","suites":["sentinel","connect"],"updatePoint":{"line":41,"column":45,"index":1226},"line":41,"code":"    it(\"should try to connect to all sentinel\", done => {\n      const sentinel = new MockServer(27380);\n      sentinel.once(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should skip an unresponsive sentinel","suites":["sentinel","connect"],"updatePoint":{"line":58,"column":44,"index":1663},"line":58,"code":"    it(\"should skip an unresponsive sentinel\", async () => {\n      const sentinel1 = new MockServer(27379, (_argv, _socket, flags) => {\n        flags.hang = true;\n      });\n      const sentinel2 = new MockServer(27380, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      const clock = sinon.useFakeTimers();\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        sentinelCommandTimeout: 1000\n      });\n      clock.tick(1000);\n      clock.restore();\n      await once(master, \"connect\");\n      redis.disconnect();\n      await Promise.all([sentinel1.disconnectPromise(), sentinel2.disconnectPromise(), master.disconnectPromise()]);\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should call sentinelRetryStrategy when all sentinels are unreachable","suites":["sentinel","connect"],"updatePoint":{"line":86,"column":76,"index":2638},"line":86,"code":"    it(\"should call sentinelRetryStrategy when all sentinels are unreachable\", done => {\n      let t = 0;\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        sentinelRetryStrategy: function (times) {\n          expect(times).to.eql(++t);\n          const sentinel = new MockServer(27380);\n          sentinel.once(\"connect\", () => {\n            redis.disconnect();\n            sentinel.disconnect(done);\n          });\n          return 0;\n        },\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should raise error when all sentinel are unreachable and retry is disabled","suites":["sentinel","connect"],"updatePoint":{"line":108,"column":82,"index":3268},"line":108,"code":"    it(\"should raise error when all sentinel are unreachable and retry is disabled\", done => {\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        sentinelRetryStrategy: null,\n        name: \"master\"\n      });\n      redis.get(\"foo\", error => {\n        finish();\n        expect(error.message).to.match(/are unreachable/);\n      });\n      redis.on(\"error\", error => {\n        expect(error.message).to.match(/are unreachable/);\n        finish();\n      });\n      redis.on(\"end\", () => {\n        finish();\n      });\n      let pending = 3;\n      function finish() {\n        if (! --pending) {\n          redis.disconnect();\n          done();\n        }\n      }\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should close the connection to the sentinel when resolving unsuccessfully","suites":["sentinel","connect"],"updatePoint":{"line":139,"column":81,"index":4064},"line":139,"code":"    it(\"should close the connection to the sentinel when resolving unsuccessfully\", done => {\n      const sentinel = new MockServer(27379); // Does not respond properly to get-master-addr-by-name\n      sentinel.once(\"disconnect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should add additionally discovered sentinels when resolving successfully","suites":["sentinel","connect"],"updatePoint":{"line":153,"column":80,"index":4532},"line":153,"code":"    it(\"should add additionally discovered sentinels when resolving successfully\", done => {\n      const sentinels = [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }];\n      let cloned;\n      sinon.stub(sentinels, \"slice\").callsFake((start, end) => {\n        cloned = [].slice.call(sentinels, start, end);\n        return cloned;\n      });\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        } else if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"27379\"], [\"ip\", \"127.0.0.1\", \"port\", \"27380\"]];\n        }\n      });\n      const master = new MockServer(17380);\n      const redis = new Redis({\n        sentinels: sentinels,\n        name: \"master\"\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        master.disconnect(() => {\n          expect(cloned.length).to.eql(2);\n          sentinel.disconnect(done);\n        });\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should skip additionally discovered sentinels even if they are resolved successfully","suites":["sentinel","connect"],"updatePoint":{"line":183,"column":92,"index":5597},"line":183,"code":"    it(\"should skip additionally discovered sentinels even if they are resolved successfully\", done => {\n      const sentinels = [{\n        host: \"127.0.0.1\",\n        port: 27379\n      }];\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        } else if (argv[0] === \"sentinel\" && argv[1] === \"sentinels\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"27379\"], [\"ip\", \"127.0.0.1\", \"port\", \"27380\"]];\n        }\n      });\n      const master = new MockServer(17380);\n      const redis = new Redis({\n        sentinels: sentinels,\n        updateSentinels: false,\n        name: \"master\"\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        master.disconnect(() => {\n          expect(sentinels.length).to.eql(1);\n          expect(sentinels[0].port).to.eql(27379);\n          sentinel.disconnect(done);\n        });\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to sentinel with authentication successfully","suites":["sentinel","connect"],"updatePoint":{"line":210,"column":67,"index":6552},"line":210,"code":"    it(\"should connect to sentinel with authentication successfully\", done => {\n      let authed = false;\n      var redisServer = new MockServer(17380, argv => {\n        if (argv[0] === \"auth\" && argv[1] === \"pass\") {\n          authed = true;\n        } else if (argv[0] === \"get\" && argv[1] === \"foo\") {\n          expect(authed).to.eql(true);\n          redisServer.disconnect();\n          done();\n        }\n      });\n      var sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          sentinel.disconnect(done);\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const redis = new Redis({\n        sentinelPassword: \"pass\",\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n      redis.get(\"foo\").catch(() => {});\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the master successfully","suites":["sentinel","master"],"updatePoint":{"line":239,"column":49,"index":7448},"line":239,"code":"    it(\"should connect to the master successfully\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      master.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          master.disconnect(done);\n        });\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should reject when sentinel is rejected","suites":["sentinel","master"],"updatePoint":{"line":260,"column":47,"index":8061},"line":260,"code":"    it(\"should reject when sentinel is rejected\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return new Error(\"just rejected\");\n        }\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        sentinelRetryStrategy: null,\n        lazyConnect: true\n      });\n      redis.connect().then(() => {\n        throw new Error(\"Expect `connect` to be thrown\");\n      }).catch(function (err) {\n        expect(err.message).to.eql(\"All sentinels are unreachable and retry is disabled. Last error: just rejected\");\n        redis.disconnect();\n        sentinel.disconnect(done);\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if getting master failed","suites":["sentinel","master"],"updatePoint":{"line":283,"column":68,"index":8879},"line":283,"code":"    it(\"should connect to the next sentinel if getting master failed\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return null;\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          sentinel2.disconnect(done);\n        });\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if the role is wrong","suites":["sentinel","master"],"updatePoint":{"line":307,"column":64,"index":9564},"line":307,"code":"    it(\"should connect to the next sentinel if the role is wrong\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\" && argv[2] === \"master\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          sentinel2.disconnect(done);\n        });\n      });\n      new MockServer(17380, argv => {\n        if (argv[0] === \"info\") {\n          return \"role:slave\";\n        }\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully","suites":["sentinel","slave"],"updatePoint":{"line":338,"column":48,"index":10431},"line":338,"code":"    it(\"should connect to the slave successfully\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      });\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          slave.disconnect(done);\n        });\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n        preferredSlaves: [{\n          ip: \"127.0.0.1\",\n          port: \"17381\",\n          prio: 10\n        }]\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully based on preferred slave priority","suites":["sentinel","slave"],"updatePoint":{"line":365,"column":82,"index":11251},"line":365,"code":"    it(\"should connect to the slave successfully based on preferred slave priority\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"44444\", \"flags\", \"slave\"], [\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"], [\"ip\", \"127.0.0.1\", \"port\", \"55555\", \"flags\", \"slave\"]];\n        }\n      });\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          slave.disconnect(done);\n        });\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n        // for code coverage (sorting, etc), use multiple valid values that resolve to prio 1\n        preferredSlaves: [{\n          ip: \"127.0.0.1\",\n          port: \"11111\",\n          prio: 100\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\",\n          prio: 1\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"22222\",\n          prio: 100\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\"\n        }, {\n          ip: \"127.0.0.1\",\n          port: \"17381\"\n        }]\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the slave successfully based on preferred slave filter function","suites":["sentinel","slave"],"updatePoint":{"line":407,"column":89,"index":12581},"line":407,"code":"    it(\"should connect to the slave successfully based on preferred slave filter function\", done => {\n      new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      });\n      // only one running slave, which we will prefer\n      const slave = new MockServer(17381);\n      slave.on(\"connect\", () => {\n        redis.disconnect();\n        done();\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\",\n        role: \"slave\",\n        preferredSlaves(slaves) {\n          for (let i = 0; i < slaves.length; i++) {\n            const slave = slaves[i];\n            if (slave.ip == \"127.0.0.1\" && slave.port == \"17381\") {\n              return slave;\n            }\n          }\n          return null;\n        }\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if getting slave failed","suites":["sentinel","slave"],"updatePoint":{"line":437,"column":67,"index":13525},"line":437,"code":"    it(\"should connect to the next sentinel if getting slave failed\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", () => {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          sentinel2.disconnect(done);\n        });\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        role: \"slave\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to the next sentinel if the role is wrong","suites":["sentinel","slave"],"updatePoint":{"line":462,"column":64,"index":14238},"line":462,"code":"    it(\"should connect to the next sentinel if the role is wrong\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"slaves\" && argv[2] === \"master\") {\n          return [[\"ip\", \"127.0.0.1\", \"port\", \"17381\", \"flags\", \"slave\"]];\n        }\n      });\n      const sentinel2 = new MockServer(27380);\n      sentinel2.on(\"connect\", function (c) {\n        redis.disconnect();\n        sentinel.disconnect(() => {\n          slave.disconnect(() => {\n            sentinel2.disconnect(done);\n          });\n        });\n      });\n      var slave = new MockServer(17381, argv => {\n        if (argv[0] === \"info\") {\n          return \"role:master\";\n        }\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }, {\n          host: \"127.0.0.1\",\n          port: 27380\n        }],\n        name: \"master\",\n        role: \"slave\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should switch to new master automatically without any commands being lost","suites":["sentinel","failover"],"updatePoint":{"line":496,"column":81,"index":15253},"line":496,"code":"    it(\"should switch to new master automatically without any commands being lost\", done => {\n      const sentinel = new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"17380\"];\n        }\n      });\n      const master = new MockServer(17380);\n      master.on(\"connect\", function (c) {\n        c.destroy();\n        master.disconnect();\n        redis.get(\"foo\", function (err, res) {\n          expect(res).to.eql(\"bar\");\n          redis.disconnect();\n          newMaster.disconnect(() => {\n            sentinel.disconnect(done);\n          });\n        });\n        var newMaster = new MockServer(17381, argv => {\n          if (argv[0] === \"get\" && argv[1] === \"foo\") {\n            return \"bar\";\n          }\n        });\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n      });\n      const redis = new Redis({\n        sentinels: [{\n          host: \"127.0.0.1\",\n          port: 27379\n        }],\n        name: \"master\"\n      });\n    });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should connect to new master after +switch-master","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":533,"column":59,"index":16437},"line":533,"code":"      it(\"should connect to new master after +switch-master\", async () => {\n        const sentinel = new MockServer(27379, argv => {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }],\n          failoverDetector: true,\n          name: \"master\"\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]);\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n        sentinel.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"),\n        // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover from secondary sentinel","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":563,"column":56,"index":17742},"line":563,"code":"      it(\"should detect failover from secondary sentinel\", async () => {\n        const sentinel1 = new MockServer(27379, argv => {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const sentinel2 = new MockServer(27380);\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }, {\n            host: \"127.0.0.1\",\n            port: 27380\n          }],\n          name: \"master\",\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]);\n\n        // In this test, only the first sentinel is used to resolve the master\n        sentinel1.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n\n        // But only the second sentinel broadcasts +switch-master\n        sentinel2.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"),\n        // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel1.disconnectPromise(), sentinel2.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover when some sentinels fail","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":601,"column":57,"index":19349},"line":601,"code":"      it(\"should detect failover when some sentinels fail\", async () => {\n        // Will disconnect before failover\n        const sentinel1 = new MockServer(27379, argv => {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n\n        // Will emit an error before failover\n        let sentinel2Socket = null;\n        const sentinel2 = new MockServer(27380, (argv, socket) => {\n          sentinel2Socket = socket;\n        });\n\n        // Fails to subscribe\n        const sentinel3 = new MockServer(27381, (argv, socket, flags) => {\n          if (argv[0] === \"subscribe\") {\n            triggerParseError(socket);\n          }\n        });\n\n        // The only sentinel that can successfully publish the failover message\n        const sentinel4 = new MockServer(27382);\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }, {\n            host: \"127.0.0.1\",\n            port: 27380\n          }, {\n            host: \"127.0.0.1\",\n            port: 27381\n          }, {\n            host: \"127.0.0.1\",\n            port: 27382\n          }],\n          name: \"master\",\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"),\n        // Must resolve even though subscribing to sentinel3 fails\n        once(redis, \"failoverSubscribed\")]);\n\n        // Fail sentinels 1 and 2\n        await sentinel1.disconnectPromise();\n        triggerParseError(sentinel2Socket);\n        sentinel4.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n        };\n        sentinel4.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"),\n        // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([\n        // sentinel1 is already disconnected\n        sentinel2.disconnectPromise(), sentinel3.disconnectPromise(), sentinel4.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should detect failover after sentinel disconnects and reconnects","suites":["sentinel","failover","failoverDetector"],"updatePoint":{"line":665,"column":74,"index":21783},"line":665,"code":"      it(\"should detect failover after sentinel disconnects and reconnects\", async () => {\n        const sentinel = new MockServer(27379, argv => {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17380\"];\n          }\n        });\n        const master = new MockServer(17380);\n        const newMaster = new MockServer(17381);\n        const redis = new Redis({\n          sentinels: [{\n            host: \"127.0.0.1\",\n            port: 27379\n          }],\n          name: \"master\",\n          sentinelReconnectStrategy: () => 1000,\n          failoverDetector: true\n        });\n        await Promise.all([once(master, \"connect\"), once(redis, \"failoverSubscribed\")]);\n        await sentinel.disconnectPromise();\n        sentinel.handler = function (argv) {\n          if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n            return [\"127.0.0.1\", \"17381\"];\n          }\n          if (argv[0] === \"subscribe\") {\n            sentinel.emit(\"test:resubscribed\"); // Custom event only used in tests\n          }\n        };\n\n        sentinel.connect();\n        const clock = sinon.useFakeTimers();\n        await once(redis, \"sentinelReconnecting\"); // Wait for the timeout to be set\n        clock.tick(1000);\n        clock.restore();\n        await once(sentinel, \"test:resubscribed\");\n        sentinel.broadcast([\"message\", \"+switch-master\", \"master 127.0.0.1 17380 127.0.0.1 17381\"]);\n        await Promise.all([once(redis, \"close\"),\n        // Wait until disconnects from old master\n        once(master, \"disconnect\"), once(newMaster, \"connect\")]);\n        redis.disconnect(); // Disconnect from new master\n\n        await Promise.all([sentinel.disconnectPromise(), master.disconnectPromise(), newMaster.disconnectPromise()]);\n      });","file":"functional/sentinel.ts","skipped":false,"dir":"test"},{"name":"should show friendly error stack","suites":["showFriendlyErrorStack"],"updatePoint":{"line":6,"column":38,"index":226},"line":6,"code":"  it(\"should show friendly error stack\", done => {\n    const redis = new Redis({\n      showFriendlyErrorStack: true\n    });\n    redis.set(\"foo\").catch(function (err) {\n      const errors = err.stack.split(\"\\n\");\n      expect(errors[0].indexOf(\"ReplyError\")).not.eql(-1);\n      expect(errors[1].indexOf(scriptName)).not.eql(-1);\n      done();\n    });\n  });","file":"functional/show_friendly_error_stack.ts","skipped":false,"dir":"test"},{"name":"should invoke the callback when subscribe successfully","suites":["spub/ssub"],"updatePoint":{"line":4,"column":60,"index":165},"line":4,"code":"  it(\"should invoke the callback when subscribe successfully\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.ssubscribe(\"foo\", \"bar\", function (err, count) {\n      expect(count).to.eql(2);\n      pending -= 1;\n    });\n    redis.ssubscribe(\"foo\", \"zoo\", function (err, count) {\n      expect(count).to.eql(3);\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should reject when issue a command in the subscriber mode","suites":["spub/ssub"],"updatePoint":{"line":18,"column":63,"index":588},"line":18,"code":"  it(\"should reject when issue a command in the subscriber mode\", done => {\n    const redis = new Redis();\n    redis.ssubscribe(\"foo\", function () {\n      redis.set(\"foo\", \"bar\", function (err) {\n        expect(err instanceof Error);\n        expect(err.message).to.match(/subscriber mode/);\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should report being in 'subscriber' mode when subscribed","suites":["spub/ssub"],"updatePoint":{"line":29,"column":62,"index":946},"line":29,"code":"  it(\"should report being in 'subscriber' mode when subscribed\", done => {\n    const redis = new Redis();\n    redis.ssubscribe(\"foo\", function () {\n      expect(redis.mode).to.equal(\"subscriber\");\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should exit subscriber mode using sunsubscribe","suites":["spub/ssub"],"updatePoint":{"line":37,"column":52,"index":1187},"line":37,"code":"  it(\"should exit subscriber mode using sunsubscribe\", done => {\n    const redis = new Redis();\n    redis.ssubscribe(\"foo\", \"bar\", function () {\n      redis.sunsubscribe(\"foo\", \"bar\", function (err, count) {\n        expect(count).to.eql(0);\n        redis.set(\"foo\", \"bar\", function (err) {\n          expect(err).to.eql(null);\n          redis.ssubscribe(\"zoo\", \"foo\", function () {\n            redis.sunsubscribe(function (err, count) {\n              expect(count).to.eql(0);\n              redis.set(\"foo\", \"bar\", function (err) {\n                expect(err).to.eql(null);\n                redis.disconnect();\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should report being in 'normal' mode after sunsubscribing","suites":["spub/ssub"],"updatePoint":{"line":58,"column":63,"index":1914},"line":58,"code":"  it(\"should report being in 'normal' mode after sunsubscribing\", done => {\n    const redis = new Redis();\n    redis.ssubscribe(\"foo\", \"bar\", function () {\n      redis.sunsubscribe(\"foo\", \"bar\", function (err, count) {\n        expect(redis.mode).to.equal(\"normal\");\n        redis.disconnect();\n        done();\n      });\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should receive messages when subscribe a shard channel","suites":["spub/ssub"],"updatePoint":{"line":68,"column":60,"index":2245},"line":68,"code":"  it(\"should receive messages when subscribe a shard channel\", done => {\n    const redis = new Redis();\n    const pub = new Redis();\n    let pending = 2;\n    redis.ssubscribe(\"foo\", function () {\n      pub.spublish(\"foo\", \"bar\");\n    });\n    redis.on(\"smessage\", function (channel, message) {\n      expect(channel).to.eql(\"foo\");\n      expect(message).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n    redis.on(\"smessageBuffer\", function (channel, message) {\n      expect(channel).to.be.instanceof(Buffer);\n      expect(channel.toString()).to.eql(\"foo\");\n      expect(message).to.be.instanceof(Buffer);\n      expect(message.toString()).to.eql(\"bar\");\n      if (! --pending) {\n        redis.disconnect();\n        done();\n      }\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should be able to send quit command in the subscriber mode","suites":["spub/ssub"],"updatePoint":{"line":94,"column":64,"index":3045},"line":94,"code":"  it(\"should be able to send quit command in the subscriber mode\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.ssubscribe(\"foo\", function () {\n      redis.quit(function () {\n        pending -= 1;\n      });\n    });\n    redis.on(\"end\", function () {\n      expect(pending).to.eql(0);\n      redis.disconnect();\n      done();\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"should restore subscription after reconnecting(ssubscribe)","suites":["spub/ssub"],"updatePoint":{"line":110,"column":64,"index":3450},"line":110,"code":"  it(\"should restore subscription after reconnecting(ssubscribe)\", done => {\n    const redis = new Redis({\n      port: 6379,\n      host: \"127.0.0.1\"\n    });\n    const pub = new Redis({\n      port: 6379,\n      host: \"127.0.0.1\"\n    });\n    // redis.ping(function (err, result) {\n    //   // redis.on(\"message\", function (channel, message) {\n    //   console.log(`${err}-${result}`);\n    //   // });\n    // });\n    redis.ssubscribe(\"foo\", \"bar\", function () {\n      redis.on(\"ready\", function () {\n        // Execute a random command to make sure that `subscribe`\n        // is sent\n        redis.ping(function () {\n          let pending = 2;\n          redis.on(\"smessage\", function (channel, message) {\n            if (! --pending) {\n              redis.disconnect();\n              pub.disconnect();\n              done();\n            }\n          });\n          pub.spublish(\"foo\", \"hi1\");\n          pub.spublish(\"bar\", \"hi2\");\n        });\n      });\n      redis.disconnect(true);\n    });\n  });","file":"functional/spub_ssub.ts","skipped":false,"dir":"test"},{"name":"returns numbers as strings","suites":["stringNumbers","enabled"],"updatePoint":{"line":7,"column":34,"index":231},"line":7,"code":"    it(\"returns numbers as strings\", async () => {\n      const redis = new Redis({\n        stringNumbers: true\n      });\n      await redis.set(\"foo\", MAX_NUMBER);\n      expect(await redis.incr(\"foo\")).to.equal(\"9007199254740992\");\n      expect(await redis.incr(\"foo\")).to.equal(\"9007199254740993\");\n      expect(await redis.incr(\"foo\")).to.equal(\"9007199254740994\");\n\n      // also works for small interger\n      await redis.set(\"foo\", 123);\n      expect(await redis.incr(\"foo\")).to.equal(\"124\");\n\n      // and floats\n      await redis.set(\"foo\", 123.23);\n      expect(Number(await redis.incrbyfloat(\"foo\", 1.2))).to.be.within(124.42999, 124.430001);\n      redis.disconnect();\n    });","file":"functional/string_numbers.ts","skipped":false,"dir":"test"},{"name":"returns numbers","suites":["stringNumbers","disabled"],"updatePoint":{"line":27,"column":23,"index":941},"line":27,"code":"    it(\"returns numbers\", done => {\n      const redis = new Redis();\n      redis.set(\"foo\", \"123\");\n      redis.incr(\"foo\", function (err, res) {\n        expect(res).to.eql(124);\n        redis.disconnect();\n        done();\n      });\n    });","file":"functional/string_numbers.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["tls option","Standalone"],"updatePoint":{"line":9,"column":20,"index":290},"line":9,"code":"    it(\"supports tls\", done => {\n      let redis;\n\n      // @ts-expect-error\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-expect-error\n        expect(op.ca).to.eql(\"123\");\n        // @ts-expect-error\n        expect(op.servername).to.eql(\"localhost\");\n        // @ts-expect-error\n        expect(op.rejectUnauthorized).to.eql(false);\n        // @ts-expect-error\n        expect(op.port).to.eql(6379);\n        const stream = net.createConnection(op);\n        stream.on(\"connect\", data => {\n          stream.emit(\"secureConnect\", data);\n        });\n        return stream;\n      });\n      redis = new Redis({\n        tls: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        redis.on(\"end\", () => done());\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"does not use tls option by default","suites":["tls option","Sentinel"],"updatePoint":{"line":43,"column":42,"index":1254},"line":43,"code":"    it(\"does not use tls option by default\", done => {\n      new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      const stub = sinon.stub(tls, \"connect\").callsFake(() => {\n        throw new Error(\"called\");\n      });\n      const redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        tls: {\n          ca: \"123\"\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        done();\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"can be enabled by `enableTLSForSentinelMode`","suites":["tls option","Sentinel"],"updatePoint":{"line":67,"column":52,"index":1886},"line":67,"code":"    it(\"can be enabled by `enableTLSForSentinelMode`\", done => {\n      new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      let redis;\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-expect-error\n        expect(op.ca).to.eql(\"123\");\n        // @ts-expect-error\n        expect(op.servername).to.eql(\"localhost\");\n        // @ts-expect-error\n        expect(op.rejectUnauthorized).to.eql(false);\n        redis.disconnect();\n        stub.restore();\n        process.nextTick(done);\n        return tls.connect(op);\n      });\n      redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        tls: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        },\n        enableTLSForSentinelMode: true\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"supports sentinelTLS","suites":["tls option","Sentinel"],"updatePoint":{"line":99,"column":28,"index":2813},"line":99,"code":"    it(\"supports sentinelTLS\", done => {\n      new MockServer(27379, argv => {\n        if (argv[0] === \"sentinel\" && argv[1] === \"get-master-addr-by-name\") {\n          return [\"127.0.0.1\", \"6379\"];\n        }\n      });\n      let redis;\n\n      // @ts-expect-error\n      const stub = sinon.stub(tls, \"connect\").callsFake(op => {\n        // @ts-expect-error\n        expect(op.ca).to.eql(\"123\");\n        // @ts-expect-error\n        expect(op.servername).to.eql(\"localhost\");\n        // @ts-expect-error\n        expect(op.rejectUnauthorized).to.eql(false);\n        // @ts-expect-error\n        expect(op.port).to.eql(27379);\n        const stream = net.createConnection(op);\n        stream.on(\"connect\", data => {\n          stream.emit(\"secureConnect\", data);\n        });\n        return stream;\n      });\n      redis = new Redis({\n        sentinels: [{\n          port: 27379\n        }],\n        name: \"my\",\n        sentinelTLS: {\n          ca: \"123\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      redis.on(\"ready\", () => {\n        redis.disconnect();\n        stub.restore();\n        redis.on(\"end\", () => done());\n      });\n    });","file":"functional/tls.ts","skipped":false,"dir":"test"},{"name":"should works like pipeline by default","suites":["transaction"],"updatePoint":{"line":5,"column":43,"index":185},"line":5,"code":"  it(\"should works like pipeline by default\", done => {\n    const redis = new Redis();\n    redis.multi().set(\"foo\", \"transaction\").get(\"foo\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result).to.eql([[null, \"OK\"], [null, \"transaction\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle runtime errors correctly","suites":["transaction"],"updatePoint":{"line":13,"column":44,"index":486},"line":13,"code":"  it(\"should handle runtime errors correctly\", done => {\n    const redis = new Redis();\n    redis.multi().set(\"foo\", \"bar\").lpush(\"foo\", \"abc\").exec(function (err, result) {\n      expect(err).to.eql(null);\n      expect(result.length).to.eql(2);\n      expect(result[0]).to.eql([null, \"OK\"]);\n      expect(result[1][0]).to.be.instanceof(Error);\n      expect(result[1][0].toString()).to.match(/wrong kind of value/);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle compile-time errors correctly","suites":["transaction"],"updatePoint":{"line":24,"column":49,"index":933},"line":24,"code":"  it(\"should handle compile-time errors correctly\", done => {\n    const redis = new Redis();\n    redis.multi().set(\"foo\").get(\"foo\").exec(function (err) {\n      expect(err).to.be.instanceof(Error);\n      expect(err.toString()).to.match(/Transaction discarded because of previous errors/);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should also support command callbacks","suites":["transaction"],"updatePoint":{"line":32,"column":43,"index":1244},"line":32,"code":"  it(\"should also support command callbacks\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.multi().set(\"foo\", \"bar\").get(\"foo\", function (err, value) {\n      pending -= 1;\n      expect(value).to.eql(\"QUEUED\");\n    }).exec(function (err, result) {\n      expect(pending).to.eql(0);\n      expect(result).to.eql([[null, \"OK\"], [null, \"bar\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should also handle errors in command callbacks","suites":["transaction"],"updatePoint":{"line":44,"column":52,"index":1648},"line":44,"code":"  it(\"should also handle errors in command callbacks\", done => {\n    const redis = new Redis();\n    let pending = 1;\n    redis.multi().set(\"foo\", function (err) {\n      expect(err.toString()).to.match(/wrong number of arguments/);\n      pending -= 1;\n    }).exec(function (err) {\n      expect(err.toString()).to.match(/Transaction discarded because of previous errors/);\n      if (!pending) {\n        done();\n      }\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should work without pipeline","suites":["transaction"],"updatePoint":{"line":57,"column":34,"index":2061},"line":57,"code":"  it(\"should work without pipeline\", done => {\n    const redis = new Redis();\n    redis.multi({\n      pipeline: false\n    });\n    redis.set(\"foo\", \"bar\");\n    redis.get(\"foo\");\n    redis.exec(function (err, results) {\n      expect(results).to.eql([[null, \"OK\"], [null, \"bar\"]]);\n      done();\n    });\n  });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should trigger transformer","suites":["transaction","transformer"],"updatePoint":{"line":70,"column":34,"index":2402},"line":70,"code":"    it(\"should trigger transformer\", done => {\n      const redis = new Redis();\n      let pending = 2;\n      const data = {\n        name: \"Bob\",\n        age: \"17\"\n      };\n      redis.multi().hmset(\"foo\", data).hgetall(\"foo\", function (err, res) {\n        expect(res).to.eql(\"QUEUED\");\n        if (! --pending) {\n          done();\n        }\n      }).hgetallBuffer(\"foo\").get(\"foo\").getBuffer(\"foo\").exec(function (err, res) {\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(data);\n        expect(res[2][1]).to.eql({\n          name: Buffer.from(\"Bob\"),\n          age: Buffer.from(\"17\")\n        });\n        expect(res[3][0]).to.have.property(\"message\", \"WRONGTYPE Operation against a key holding the wrong kind of value\");\n        expect(res[4][0]).to.have.property(\"message\", \"WRONGTYPE Operation against a key holding the wrong kind of value\");\n        if (! --pending) {\n          done();\n        }\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should trigger transformer inside pipeline","suites":["transaction","transformer"],"updatePoint":{"line":96,"column":50,"index":3361},"line":96,"code":"    it(\"should trigger transformer inside pipeline\", done => {\n      const redis = new Redis();\n      const data = {\n        name: \"Bob\",\n        age: \"17\"\n      };\n      redis.pipeline().hmset(\"foo\", data).multi().typeBuffer(\"foo\").hgetall(\"foo\").exec().hgetall(\"foo\").exec(function (err, res) {\n        expect(res[0][1]).to.eql(\"OK\");\n        expect(res[1][1]).to.eql(\"OK\");\n        expect(res[2][1]).to.eql(Buffer.from(\"QUEUED\"));\n        expect(res[3][1]).to.eql(\"QUEUED\");\n        expect(res[4][1]).to.eql([Buffer.from(\"hash\"), data]);\n        expect(res[5][1]).to.eql(data);\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should handle custom transformer exception","suites":["transaction","transformer"],"updatePoint":{"line":112,"column":50,"index":3976},"line":112,"code":"    it(\"should handle custom transformer exception\", done => {\n      const transformError = \"transformer error\";\n      // @ts-expect-error\n      Command._transformer.reply.get = () => {\n        throw new Error(transformError);\n      };\n      const redis = new Redis();\n      redis.multi().get(\"foo\").exec(function (err, res) {\n        expect(res[0][0]).to.have.property(\"message\", transformError);\n        // @ts-expect-error\n        delete Command._transformer.reply.get;\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should accept commands in constructor","suites":["transaction","#addBatch"],"updatePoint":{"line":128,"column":45,"index":4516},"line":128,"code":"    it(\"should accept commands in constructor\", done => {\n      const redis = new Redis();\n      let pending = 1;\n      redis.multi([[\"set\", \"foo\", \"bar\"], [\"get\", \"foo\", function (err, result) {\n        expect(result).to.eql(\"QUEUED\");\n        pending -= 1;\n      }]]).exec(function (err, results) {\n        expect(pending).to.eql(0);\n        expect(results[1][1]).to.eql(\"bar\");\n        done();\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should batch all commands before ready event","suites":["transaction","#exec"],"updatePoint":{"line":142,"column":52,"index":4972},"line":142,"code":"    it(\"should batch all commands before ready event\", done => {\n      const redis = new Redis();\n      redis.on(\"connect\", () => {\n        redis.multi().info().config(\"get\", \"maxmemory\").exec(function (err, res) {\n          expect(err).to.eql(null);\n          expect(res).to.have.lengthOf(2);\n          expect(res[0][0]).to.eql(null);\n          expect(typeof res[0][1]).to.eql(\"string\");\n          expect(res[1][0]).to.eql(null);\n          expect(Array.isArray(res[1][1])).to.eql(true);\n          done();\n        });\n      });\n    });","file":"functional/transaction.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":6,"column":31,"index":204},"line":6,"code":"      it(\"should support object\", async () => {\n        const redis = new Redis();\n        expect(await redis.hmset(\"foo\", {\n          a: 1,\n          b: \"2\"\n        })).to.eql(\"OK\");\n        expect(await redis.hget(\"foo\", \"b\")).to.eql(\"2\");\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map with string keys","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":14,"column":45,"index":470},"line":14,"code":"      it(\"should support Map with string keys\", async () => {\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        map.set(42, true);\n        map.set(Buffer.from(\"buffer\"), \"utf8\");\n        map.set(Buffer.from([0xff]), \"binary\");\n        expect(await redis.hmset(\"foo\", map)).to.eql(\"OK\");\n        expect(await redis.hget(\"foo\", \"a\")).to.eql(\"1\");\n        expect(await redis.hget(\"foo\", \"b\")).to.eql(\"2\");\n        expect(await redis.hget(\"foo\", \"42\")).to.eql(\"true\");\n        expect(await redis.hget(\"foo\", \"buffer\")).to.eql(\"utf8\");\n        expect(await redis.hget(\"foo\", Buffer.from([0xff]))).to.eql(\"binary\");\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","hmset"],"updatePoint":{"line":29,"column":39,"index":1160},"line":29,"code":"      it(\"should not affect the old way\", async () => {\n        const redis = new Redis();\n        expect(await redis.hmset(\"foo\", \"a\", 1, \"b\", \"2\")).to.eql(\"OK\");\n        expect(await redis.hget(\"foo\", \"b\")).to.eql(\"2\");\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","mset"],"updatePoint":{"line":36,"column":31,"index":1421},"line":36,"code":"      it(\"should support object\", async () => {\n        const redis = new Redis();\n        expect(await redis.mset({\n          a: 1,\n          b: \"2\"\n        })).to.eql(\"OK\");\n        expect(await redis.mget(\"a\", \"b\")).to.eql([\"1\", \"2\"]);\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","mset"],"updatePoint":{"line":44,"column":28,"index":1667},"line":44,"code":"      it(\"should support Map\", async () => {\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        expect(await redis.mset(map)).to.eql(\"OK\");\n        expect(await redis.mget(\"a\", \"b\")).to.eql([\"1\", \"2\"]);\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","mset"],"updatePoint":{"line":52,"column":39,"index":1966},"line":52,"code":"      it(\"should not affect the old way\", async () => {\n        const redis = new Redis();\n        expect(await redis.mset(\"a\", 1, \"b\", \"2\")).to.eql(\"OK\");\n        expect(await redis.mget(\"a\", \"b\")).to.eql([\"1\", \"2\"]);\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should work with keyPrefix option","suites":["transformer","default transformer","mset"],"updatePoint":{"line":57,"column":43,"index":2199},"line":57,"code":"      it(\"should work with keyPrefix option\", async () => {\n        const redis = new Redis({\n          keyPrefix: \"foo:\"\n        });\n        expect(await redis.mset({\n          a: 1,\n          b: \"2\"\n        })).to.eql(\"OK\");\n        const otherRedis = new Redis();\n        expect(await otherRedis.mget(\"foo:a\", \"foo:b\")).to.eql([\"1\", \"2\"]);\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":70,"column":31,"index":2579},"line":70,"code":"      it(\"should support object\", done => {\n        const redis = new Redis();\n        redis.msetnx({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":83,"column":28,"index":2942},"line":83,"code":"      it(\"should support Map\", done => {\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"2\");\n        redis.msetnx(map, function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should not affect the old way","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":96,"column":39,"index":3358},"line":96,"code":"      it(\"should not affect the old way\", done => {\n        const redis = new Redis();\n        redis.msetnx(\"a\", 1, \"b\", \"2\", function (err, result) {\n          expect(result).to.eql(1);\n          redis.mget(\"a\", \"b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should work with keyPrefix option","suites":["transformer","default transformer","msetnx"],"updatePoint":{"line":106,"column":43,"index":3708},"line":106,"code":"      it(\"should work with keyPrefix option\", done => {\n        const redis = new Redis({\n          keyPrefix: \"foo:\"\n        });\n        redis.msetnx({\n          a: 1,\n          b: \"2\"\n        }, function (err, result) {\n          expect(result).to.eql(1);\n          const otherRedis = new Redis();\n          otherRedis.mget(\"foo:a\", \"foo:b\", function (err, result) {\n            expect(result).to.eql([\"1\", \"2\"]);\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should return an object","suites":["transformer","default transformer","hgetall"],"updatePoint":{"line":124,"column":33,"index":4210},"line":124,"code":"      it(\"should return an object\", done => {\n        const redis = new Redis();\n        redis.hmset(\"foo\", \"k1\", \"v1\", \"k2\", \"v2\", () => {\n          redis.hgetall(\"foo\", function (err, result) {\n            expect(result).to.eql({\n              k1: \"v1\",\n              k2: \"v2\"\n            });\n            done();\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should return {} when key not exists","suites":["transformer","default transformer","hgetall"],"updatePoint":{"line":136,"column":46,"index":4574},"line":136,"code":"      it(\"should return {} when key not exists\", done => {\n        const redis = new Redis();\n        redis.hgetall(\"foo\", function (err, result) {\n          expect(result).to.eql({});\n          done();\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support object","suites":["transformer","default transformer","hset"],"updatePoint":{"line":145,"column":31,"index":4821},"line":145,"code":"      it(\"should support object\", async () => {\n        const redis = new Redis();\n        // NOTE: could simplify these tests using await redis.hset instead,\n        // but not sure if this is deliberately testing the transformers with callbacks\n        return new Promise((resolve, reject) => {\n          redis.hset(\"foo\", {\n            a: 1,\n            b: \"e\",\n            c: 123\n          }, function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n            expect(result).to.eql(3);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support Map","suites":["transformer","default transformer","hset"],"updatePoint":{"line":166,"column":28,"index":5528},"line":166,"code":"      it(\"should support Map\", async () => {\n        const redis = new Redis();\n        const map = new Map();\n        map.set(\"a\", 1);\n        map.set(\"b\", \"e\");\n        return new Promise((resolve, reject) => {\n          redis.hset(\"foo\", map, function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n            expect(result).to.eql(2);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              if (err) {\n                return reject(err);\n              }\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should affect the old way","suites":["transformer","default transformer","hset"],"updatePoint":{"line":187,"column":35,"index":6171},"line":187,"code":"      it(\"should affect the old way\", async () => {\n        const redis = new Redis();\n        return new Promise(resolve => {\n          redis.hset(\"foo\", \"a\", 1, \"b\", \"e\", function (err, result) {\n            expect(result).to.eql(2);\n            redis.hget(\"foo\", \"b\", function (err, result) {\n              expect(result).to.eql(\"e\");\n              resolve();\n            });\n          });\n        });\n      });","file":"functional/transformer.ts","skipped":false,"dir":"test"},{"name":"should support watch/exec transactions","suites":["watch-exec"],"updatePoint":{"line":4,"column":44,"index":144},"line":4,"code":"  it(\"should support watch/exec transactions\", () => {\n    const redis1 = new Redis();\n    return redis1.watch(\"watchkey\").then(() => {\n      return redis1.multi().set(\"watchkey\", \"1\").exec();\n    }).then(function (result) {\n      expect(result.length).to.eql(1);\n      expect(result[0]).to.eql([null, \"OK\"]);\n    });\n  });","file":"functional/watch-exec.ts","skipped":false,"dir":"test"},{"name":"should support watch/exec transaction rollback","suites":["watch-exec"],"updatePoint":{"line":13,"column":52,"index":476},"line":13,"code":"  it(\"should support watch/exec transaction rollback\", () => {\n    const redis1 = new Redis();\n    const redis2 = new Redis();\n    return redis1.watch(\"watchkey\").then(() => {\n      return redis2.set(\"watchkey\", \"2\");\n    }).then(() => {\n      return redis1.multi().set(\"watchkey\", \"1\").exec();\n    }).then(function (result) {\n      expect(result).to.be.null;\n    });\n  });","file":"functional/watch-exec.ts","skipped":false,"dir":"test"},{"name":"should be able to efficiently get array args","suites":["autoPipelining"],"updatePoint":{"line":7,"column":50,"index":326},"line":7,"code":"  it(\"should be able to efficiently get array args\", function () {\n    expectGetFirstValueIs([], undefined);\n    expectGetFirstValueIs([null, \"key\"], null);\n    expectGetFirstValueIs([\"key\", \"value\"], \"key\");\n    expectGetFirstValueIs([[], \"key\"], \"key\");\n    expectGetFirstValueIs([[\"key\"]], \"key\");\n    expectGetFirstValueIs([[[\"key\"]]], [\"key\"]);\n    expectGetFirstValueIs([0, 1, 2, 3, 4], 0);\n    expectGetFirstValueIs([[true]], true);\n    expectGetFirstValueIs([Buffer.from(\"test\")], Buffer.from(\"test\"));\n    expectGetFirstValueIs([{}], {});\n    // lodash.isArguments is true for this legacy js way to get argument lists\n    const createArguments = function () {\n      return arguments;\n    };\n    // @ts-expect-error\n    expectGetFirstValueIs([createArguments(), createArguments(\"key\")], \"key\");\n    // @ts-expect-error\n    expectGetFirstValueIs([createArguments(\"\")], \"\");\n  });","file":"unit/autoPipelining.ts","skipped":false,"dir":"test"},{"name":"prefers to master if there are two same node for a slot","suites":["ConnectionPool","#reset"],"updatePoint":{"line":6,"column":63,"index":257},"line":6,"code":"    it(\"prefers to master if there are two same node for a slot\", () => {\n      const pool = new ConnectionPool({});\n      const stub = sinon.stub(pool, \"findOrCreate\");\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: true\n      }, {\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }]);\n      expect(stub.callCount).to.eql(1);\n      expect(stub.firstCall.args[1]).to.eql(false);\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: false\n      }, {\n        host: \"127.0.0.1\",\n        port: 30001,\n        readOnly: true\n      }]);\n      expect(stub.callCount).to.eql(2);\n      expect(stub.firstCall.args[1]).to.eql(false);\n    });","file":"unit/clusters/ConnectionPool.ts","skipped":false,"dir":"test"},{"name":"remove the node immediately instead of waiting for 'end' event","suites":["ConnectionPool","#reset"],"updatePoint":{"line":32,"column":70,"index":996},"line":32,"code":"    it(\"remove the node immediately instead of waiting for 'end' event\", () => {\n      const pool = new ConnectionPool({});\n      pool.reset([{\n        host: \"127.0.0.1\",\n        port: 300001\n      }]);\n      expect(pool.getNodes().length).to.eql(1);\n      pool.reset([]);\n      expect(pool.getNodes().length).to.eql(0);\n    });","file":"unit/clusters/ConnectionPool.ts","skipped":false,"dir":"test"},{"name":"should support frozen options","suites":["cluster"],"updatePoint":{"line":14,"column":35,"index":427},"line":14,"code":"  it(\"should support frozen options\", () => {\n    const options = Object.freeze({\n      maxRedirections: 1000\n    });\n    const cluster = new Cluster([{\n      port: 7777\n    }], options);\n    expect(cluster.options).to.have.property(\"maxRedirections\", 1000);\n    expect(cluster.options).to.have.property(\"scaleReads\", \"master\");\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"should allow overriding Commander options","suites":["cluster"],"updatePoint":{"line":24,"column":47,"index":774},"line":24,"code":"  it(\"should allow overriding Commander options\", () => {\n    const cluster = new Cluster([{\n      port: 7777\n    }], {\n      showFriendlyErrorStack: true\n    });\n    expect(cluster.options).to.have.property(\"showFriendlyErrorStack\", true);\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"should support passing keyPrefix via redisOptions","suites":["cluster"],"updatePoint":{"line":32,"column":55,"index":1029},"line":32,"code":"  it(\"should support passing keyPrefix via redisOptions\", () => {\n    const cluster = new Cluster([{\n      port: 7777\n    }], {\n      redisOptions: {\n        keyPrefix: \"prefix:\"\n      }\n    });\n    expect(cluster.options).to.have.property(\"keyPrefix\", \"prefix:\");\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"throws when scaleReads is invalid","suites":["cluster"],"updatePoint":{"line":42,"column":39,"index":1284},"line":42,"code":"  it(\"throws when scaleReads is invalid\", () => {\n    expect(() => {\n      // @ts-expect-error\n      new Cluster([{}], {\n        scaleReads: \"invalid\"\n      });\n    }).to.throw(/Invalid option scaleReads/);\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"disables slotsRefreshTimeout by default","suites":["cluster"],"updatePoint":{"line":50,"column":45,"index":1503},"line":50,"code":"  it(\"disables slotsRefreshTimeout by default\", () => {\n    const cluster = new Cluster([{}]);\n    expect(cluster.options.slotsRefreshInterval).to.eql(undefined);\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"throws when role is invalid","suites":["cluster","#nodes()"],"updatePoint":{"line":55,"column":35,"index":1693},"line":55,"code":"    it(\"throws when role is invalid\", () => {\n      const cluster = new Cluster([{}]);\n      expect(() => {\n        // @ts-expect-error\n        cluster.nodes(\"invalid\");\n      }).to.throw(/Invalid role/);\n    });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"returns correct result","suites":["nodeKeyToRedisOptions()"],"updatePoint":{"line":65,"column":28,"index":1953},"line":65,"code":"  it(\"returns correct result\", () => {\n    expect(nodeKeyToRedisOptions(\"127.0.0.1:6379\")).to.eql({\n      port: 6379,\n      host: \"127.0.0.1\"\n    });\n    expect(nodeKeyToRedisOptions(\"192.168.1.1:30001\")).to.eql({\n      port: 30001,\n      host: \"192.168.1.1\"\n    });\n    expect(nodeKeyToRedisOptions(\"::0:6379\")).to.eql({\n      port: 6379,\n      host: \"::0\"\n    });\n    expect(nodeKeyToRedisOptions(\"0:0:6379\")).to.eql({\n      port: 6379,\n      host: \"0:0\"\n    });\n  });","file":"unit/clusters/index.ts","skipped":false,"dir":"test"},{"name":"should flatten the args","suites":["Command","constructor()"],"updatePoint":{"line":5,"column":31,"index":168},"line":5,"code":"    it(\"should flatten the args\", () => {\n      const command = new Command(\"get\", [\"foo\", [\"bar\", [\"zoo\", \"zoo\"]]]);\n      expect(command.args).to.eql([\"foo\", \"bar\", \"zoo,zoo\"]);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correct string","suites":["Command","#toWritable()"],"updatePoint":{"line":11,"column":36,"index":403},"line":11,"code":"    it(\"should return correct string\", () => {\n      const command = new Command(\"get\", [\"foo\", \"bar\", \"zooo\"]);\n      expect(command.toWritable()).to.eql(\"*4\\r\\n$3\\r\\nget\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n$4\\r\\nzooo\\r\\n\");\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return buffer when there's at least one arg is a buffer","suites":["Command","#toWritable()"],"updatePoint":{"line":15,"column":70,"index":664},"line":15,"code":"    it(\"should return buffer when there's at least one arg is a buffer\", () => {\n      const command = new Command(\"get\", [\"foo\", Buffer.from(\"bar\"), \"zooo\"]);\n      const result = command.toWritable();\n      expect(result).to.be.instanceof(Buffer);\n      expect(result.toString()).to.eql(\"*4\\r\\n$3\\r\\nget\\r\\n$3\\r\\nfoo\\r\\n$3\\r\\nbar\\r\\n$4\\r\\nzooo\\r\\n\");\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return buffer when replyEncoding is not set","suites":["Command","#resolve()"],"updatePoint":{"line":23,"column":58,"index":1052},"line":23,"code":"    it(\"should return buffer when replyEncoding is not set\", done => {\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: null\n      }, function (err, result) {\n        expect(result).to.be.instanceof(Buffer);\n        expect(result.toString()).to.eql(\"foo\");\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should covert result to string if replyEncoding is specified","suites":["Command","#resolve()"],"updatePoint":{"line":33,"column":68,"index":1422},"line":33,"code":"    it(\"should covert result to string if replyEncoding is specified\", done => {\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: \"utf8\"\n      }, function (err, result) {\n        expect(result).to.eql(\"foo\");\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should regard replyEncoding","suites":["Command","#resolve()"],"updatePoint":{"line":42,"column":35,"index":1701},"line":42,"code":"    it(\"should regard replyEncoding\", done => {\n      const base64 = Buffer.from(\"foo\").toString(\"base64\");\n      const command = new Command(\"get\", [\"foo\"], {\n        replyEncoding: \"base64\"\n      }, function (err, result) {\n        expect(result).to.eql(base64);\n        done();\n      });\n      command.resolve(Buffer.from(\"foo\"));\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return keys","suites":["Command","#getKeys()"],"updatePoint":{"line":54,"column":26,"index":2073},"line":54,"code":"    it(\"should return keys\", () => {\n      expect(getKeys(\"get\", [\"foo\"])).to.eql([\"foo\"]);\n      expect(getKeys(\"mget\", [\"foo\", \"bar\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"mset\", [\"foo\", \"v1\", \"bar\", \"v2\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"hmset\", [\"key\", \"foo\", \"v1\", \"bar\", \"v2\"])).to.eql([\"key\"]);\n      expect(getKeys(\"blpop\", [\"key1\", \"key2\", \"17\"])).to.eql([\"key1\", \"key2\"]);\n      expect(getKeys(\"evalsha\", [\"23123\", \"2\", \"foo\", \"bar\", \"zoo\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"evalsha\", [\"23123\", 2, \"foo\", \"bar\", \"zoo\"])).to.eql([\"foo\", \"bar\"]);\n      expect(getKeys(\"sort\", [\"key\"])).to.eql([\"key\"]);\n      expect(getKeys(\"sort\", [\"key\", \"BY\", \"hash:*->field\"])).to.eql([\"key\", \"hash:*->field\"]);\n      expect(getKeys(\"sort\", [\"key\", \"BY\", \"hash:*->field\", \"LIMIT\", 2, 3, \"GET\", \"gk\", \"GET\", \"#\", \"Get\", \"gh->f*\", \"DESC\", \"ALPHA\", \"STORE\", \"store\"])).to.eql([\"key\", \"hash:*->field\", \"gk\", \"gh->f*\", \"store\"]);\n      expect(getKeys(\"zunionstore\", [\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3])).to.eql([\"out\", \"zset1\", \"zset2\"]);\n      expect(getKeys(\"zinterstore\", [\"out\", 2, \"zset1\", \"zset2\", \"WEIGHTS\", 2, 3])).to.eql([\"out\", \"zset1\", \"zset2\"]);\n      function getKeys(commandName, args) {\n        const command = new Command(commandName, args);\n        return command.getKeys();\n      }\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["Command","#getSlot()"],"updatePoint":{"line":77,"column":31,"index":3571},"line":77,"code":"    it(\"should return correctly\", () => {\n      expectSlot(\"123\", 5970);\n      expectSlot(123, 5970);\n      expectSlot(\"ab{c\", 4619);\n      expectSlot(\"ab{c}2\", 7365);\n      expectSlot(\"ab{{c}2\", 2150);\n      expectSlot(\"ab{qq}{c}2\", 5598);\n      expectSlot(\"ab}\", 11817);\n      expectSlot(\"encoding\", 3060);\n      expectSlot(true, 13635);\n      expectSlot(\"true\", 13635);\n      expectSlot(\"\", 0);\n      expectSlot(null, 0);\n      expectSlot(undefined, 0);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"supports buffers","suites":["Command","#getSlot()"],"updatePoint":{"line":92,"column":24,"index":4029},"line":92,"code":"    it(\"supports buffers\", () => {\n      expectSlot(Buffer.from(\"encoding\"), 3060);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"should return correct result","suites":["Command",".checkFlag()"],"updatePoint":{"line":97,"column":36,"index":4174},"line":97,"code":"    it(\"should return correct result\", () => {\n      expect(Command.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", \"ping\")).to.eql(true);\n      expect(Command.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", \"get\")).to.eql(false);\n      expect(Command.checkFlag(\"WILL_DISCONNECT\", \"quit\")).to.eql(true);\n    });","file":"unit/command.ts","skipped":false,"dir":"test"},{"name":"returns a new copy of commands","suites":["Commander","#getBuiltinCommands()"],"updatePoint":{"line":6,"column":38,"index":227},"line":6,"code":"    it(\"returns a new copy of commands\", () => {\n      const c = new Commander();\n      const commands = c.getBuiltinCommands();\n      commands.unshift(\"abc\");\n      const commandsNew = c.getBuiltinCommands();\n      expect(commands.slice(1)).to.eql(commandsNew);\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"adds string command","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":17,"column":27,"index":644},"line":17,"code":"    it(\"adds string command\", () => {\n      const c = new Commander();\n      c.addBuiltinCommand(\"someCommand\");\n      c.someCommand();\n      const command = Commander.prototype.sendCommand.getCall(0).args[0];\n      expect(command.name).to.eql(\"someCommand\");\n      expect(command.replyEncoding).to.eql(\"utf8\");\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"adds buffer command","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":25,"column":27,"index":964},"line":25,"code":"    it(\"adds buffer command\", () => {\n      const c = new Commander();\n      c.addBuiltinCommand(\"someCommand\");\n      c.someCommandBuffer();\n      const command = Commander.prototype.sendCommand.getCall(0).args[0];\n      expect(command.name).to.eql(\"someCommand\");\n      expect(command.replyEncoding).to.eql(null);\n    });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"should pass the correct arguments","suites":["Commander","#addBuiltinCommand()"],"updatePoint":{"line":34,"column":39,"index":1306},"line":34,"code":"  it(\"should pass the correct arguments\", () => {\n    sinon.stub(Commander.prototype, \"sendCommand\").callsFake(command => {\n      return command;\n    });\n    let command;\n    const c = new Commander();\n    command = c.call(\"set\", \"foo\", \"bar\");\n    expect(command.name).to.eql(\"set\");\n    expect(command.args[0]).to.eql(\"foo\");\n    expect(command.args[1]).to.eql(\"bar\");\n    command = c.callBuffer(\"set\", [\"foo\", \"bar\"]);\n    expect(command.name).to.eql(\"set\");\n    expect(command.args[0]).to.eql(\"foo\");\n    expect(command.args[1]).to.eql(\"bar\");\n    command = c.call(\"set\", \"foo\", \"bar\", () => {});\n    expect(command.name).to.eql(\"set\");\n    expect(command.args.length).to.eql(2);\n    command = c.callBuffer(\"set\", \"foo\", \"bar\", () => {});\n    expect(command.name).to.eql(\"set\");\n    expect(command.args.length).to.eql(2);\n    Commander.prototype.sendCommand.restore();\n  });","file":"unit/commander.ts","skipped":false,"dir":"test"},{"name":"first tries path","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":8,"column":24,"index":279},"line":8,"code":"    it(\"first tries path\", async () => {\n      const spy = sinon.spy(net, \"createConnection\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        path: \"/tmp\"\n      });\n      try {\n        const stream = await connector.connect(() => {});\n        stream.on(\"error\", () => {});\n      } catch (err) {\n        // ignore errors\n      }\n      expect(spy.calledOnce).to.eql(true);\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"ignore path when port is set and path is null","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":23,"column":53,"index":748},"line":23,"code":"    it(\"ignore path when port is set and path is null\", async () => {\n      const spy = sinon.spy(net, \"createConnection\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        path: null\n      });\n      await connector.connect(() => {});\n      expect(spy.calledOnce).to.eql(true);\n      expect(spy.firstCall.args[0]).to.eql({\n        port: 6379\n      });\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"supports tls","suites":["StandaloneConnector","connect()"],"updatePoint":{"line":36,"column":20,"index":1134},"line":36,"code":"    it(\"supports tls\", async () => {\n      const spy = sinon.spy(tls, \"connect\");\n      const connector = new StandaloneConnector({\n        port: 6379,\n        tls: {\n          ca: \"on\",\n          servername: \"localhost\",\n          rejectUnauthorized: false\n        }\n      });\n      await connector.connect(() => {});\n      expect(spy.calledOnce).to.eql(true);\n      expect(spy.firstCall.args[0]).to.eql({\n        port: 6379,\n        ca: \"on\",\n        servername: \"localhost\",\n        rejectUnauthorized: false\n      });\n      connector.disconnect();\n    });","file":"unit/connectors/connector.ts","skipped":false,"dir":"test"},{"name":"keep the options immutable","suites":["SentinelIterator"],"updatePoint":{"line":4,"column":32,"index":195},"line":4,"code":"  it(\"keep the options immutable\", () => {\n    function getSentinels() {\n      return [{\n        host: \"127.0.0.1\",\n        port: 30001\n      }];\n    }\n    const sentinels = getSentinels();\n    const iter = new SentinelIterator(sentinels);\n    iter.add({\n      host: \"127.0..0.1\",\n      port: 30002\n    });\n    expect(sentinels).to.eql(getSentinels());\n    expect(iter.next().value.port).to.eql(30001);\n    expect(iter.next().value.port).to.eql(30002);\n  });","file":"unit/connectors/SentinelConnector/SentinelIterator.ts","skipped":false,"dir":"test"},{"name":"prints logs","suites":["index","print()"],"updatePoint":{"line":6,"column":19,"index":174},"line":6,"code":"    it(\"prints logs\", () => {\n      const stub = sinon.stub(console, \"log\");\n      print(new Error(\"err\"));\n      print(null, \"success\");\n      expect(stub.calledTwice).to.eql(true);\n      stub.restore();\n    });","file":"unit/index.ts","skipped":false,"dir":"test"},{"name":"should properly mark commands as transactions","suites":["Pipeline"],"updatePoint":{"line":16,"column":51,"index":508},"line":16,"code":"  it(\"should properly mark commands as transactions\", () => {\n    const redis = new Redis();\n    const p = new Pipeline(redis);\n    let i = 0;\n    function validate(name, inTransaction) {\n      const command = p._queue[i++];\n      expect(command.name).to.eql(name);\n      expect(command.inTransaction).to.eql(inTransaction);\n    }\n    p.get();\n    p.multi();\n    p.get();\n    p.multi();\n    p.exec();\n    p.exec();\n    p.get();\n    validate(\"get\", false);\n    validate(\"multi\", true);\n    validate(\"get\", true);\n    validate(\"multi\", true);\n    validate(\"exec\", true);\n    validate(\"exec\", false);\n    validate(\"get\", false);\n  });","file":"unit/pipeline.ts","skipped":false,"dir":"test"},{"name":"should properly set pipelineIndex on commands","suites":["Pipeline"],"updatePoint":{"line":40,"column":51,"index":1140},"line":40,"code":"  it(\"should properly set pipelineIndex on commands\", () => {\n    const redis = new Redis();\n    const p = new Pipeline(redis);\n    let i = 0;\n    function validate(name) {\n      const command = p._queue[i];\n      expect(command.name).to.eql(name);\n      expect(command.pipelineIndex).to.eql(i);\n      i++;\n    }\n    p.get();\n    p.set();\n    p.del();\n    p.ping();\n    validate(\"get\");\n    validate(\"set\");\n    validate(\"del\");\n    validate(\"ping\");\n  });","file":"unit/pipeline.ts","skipped":false,"dir":"test"},{"name":"should parse options correctly","suites":["Redis","constructor"],"updatePoint":{"line":6,"column":38,"index":199},"line":6,"code":"    it(\"should parse options correctly\", () => {\n      const stub = sinon.stub(Redis.prototype, \"connect\").returns(Promise.resolve());\n      let option;\n      try {\n        option = getOption();\n        expect(option).to.have.property(\"port\", 6379);\n        expect(option).to.have.property(\"host\", \"localhost\");\n        expect(option).to.have.property(\"family\", 4);\n        option = getOption(6380);\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"localhost\");\n        option = getOption(\"6380\");\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption(6381, \"192.168.1.1\");\n        expect(option).to.have.property(\"port\", 6381);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption(6381, \"192.168.1.1\", {\n          password: \"123\",\n          db: 2\n        });\n        expect(option).to.have.property(\"port\", 6381);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        expect(option).to.have.property(\"password\", \"123\");\n        expect(option).to.have.property(\"db\", 2);\n        option = getOption(\"redis://:authpassword@127.0.0.1:6380/4\");\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"127.0.0.1\");\n        expect(option).to.have.property(\"password\", \"authpassword\");\n        expect(option).to.have.property(\"db\", 4);\n        option = getOption(\"redis://:1+1@127.0.0.1:6380\");\n        expect(option).to.have.property(\"password\", \"1+1\");\n        option = getOption(`redis://127.0.0.1:6380/?password=${encodeURIComponent(\"1+1\")}`);\n        expect(option).to.have.property(\"password\", \"1+1\");\n        option = getOption(\"redis://127.0.0.1/\");\n        expect(option).to.have.property(\"db\", 0);\n        option = getOption(\"/tmp/redis.sock\");\n        expect(option).to.have.property(\"path\", \"/tmp/redis.sock\");\n        option = getOption({\n          port: 6380,\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption({\n          path: \"/tmp/redis.sock\"\n        });\n        expect(option).to.have.property(\"path\", \"/tmp/redis.sock\");\n        option = getOption({\n          port: \"6380\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption({\n          showFriendlyErrorStack: true\n        });\n        expect(option).to.have.property(\"showFriendlyErrorStack\", true);\n        option = getOption(6380, {\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        expect(option).to.have.property(\"host\", \"192.168.1.1\");\n        option = getOption(\"6380\", {\n          host: \"192.168.1.1\"\n        });\n        expect(option).to.have.property(\"port\", 6380);\n        option = getOption(\"rediss://host\");\n        expect(option).to.have.property(\"tls\", true);\n        option = getOption(\"rediss://example.test\", {\n          tls: {\n            hostname: \"example.test\"\n          }\n        });\n        expect(option.tls).to.deep.equal({\n          hostname: \"example.test\"\n        });\n        option = getOption(\"redis://localhost?family=6\");\n        expect(option).to.have.property(\"family\", 6);\n      } catch (err) {\n        stub.restore();\n        throw err;\n      }\n      stub.restore();\n      function getOption(...args) {\n        // @ts-expect-error\n        const redis = new Redis(...args);\n        return redis.options;\n      }\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should throw when arguments is invalid","suites":["Redis","constructor"],"updatePoint":{"line":93,"column":46,"index":3747},"line":93,"code":"    it(\"should throw when arguments is invalid\", () => {\n      expect(() => {\n        // @ts-expect-error\n        new Redis(() => {});\n      }).to.throw(Error);\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should redirect to constructor","suites":["Redis",".createClient"],"updatePoint":{"line":101,"column":38,"index":3950},"line":101,"code":"    it(\"should redirect to constructor\", () => {\n      const redis = Redis.createClient({\n        name: \"pass\",\n        lazyConnect: true\n      });\n      expect(redis.options).to.have.property(\"name\", \"pass\");\n      expect(redis.options).to.have.property(\"lazyConnect\", true);\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should redirect to #disconnect","suites":["Redis","#end"],"updatePoint":{"line":111,"column":38,"index":4268},"line":111,"code":"    it(\"should redirect to #disconnect\", done => {\n      const redis = new Redis({\n        lazyConnect: true\n      });\n      const stub = sinon.stub(redis, \"disconnect\").callsFake(() => {\n        stub.restore();\n        done();\n      });\n      redis.end();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should flush all queues by default","suites":["Redis","#flushQueue"],"updatePoint":{"line":123,"column":42,"index":4577},"line":123,"code":"    it(\"should flush all queues by default\", () => {\n      const flushQueue = Redis.prototype.flushQueue;\n      const redis = {\n        offlineQueue: [{\n          command: {\n            reject: () => {}\n          }\n        }],\n        commandQueue: [{\n          command: {\n            reject: () => {}\n          }\n        }]\n      };\n      const offline = sinon.mock(redis.offlineQueue[0].command);\n      const command = sinon.mock(redis.commandQueue[0].command);\n      offline.expects(\"reject\").once();\n      command.expects(\"reject\").once();\n      flushQueue.call(redis);\n      offline.verify();\n      command.verify();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should be able to ignore a queue","suites":["Redis","#flushQueue"],"updatePoint":{"line":145,"column":40,"index":5205},"line":145,"code":"    it(\"should be able to ignore a queue\", () => {\n      const flushQueue = Redis.prototype.flushQueue;\n      const redis = {\n        offlineQueue: [{\n          command: {\n            reject: () => {}\n          }\n        }],\n        commandQueue: [{\n          command: {\n            reject: () => {}\n          }\n        }]\n      };\n      const offline = sinon.mock(redis.offlineQueue[0].command);\n      const command = sinon.mock(redis.commandQueue[0].command);\n      offline.expects(\"reject\").once();\n      command.expects(\"reject\").never();\n      flushQueue.call(redis, new Error(), {\n        commandQueue: false\n      });\n      offline.verify();\n      command.verify();\n    });","file":"unit/redis.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertBufferToString"],"updatePoint":{"line":7,"column":31,"index":267},"line":7,"code":"    it(\"should return correctly\", () => {\n      expect(utils.convertBufferToString(Buffer.from(\"123\"))).to.eql(\"123\");\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), Buffer.from(\"abc\")])).to.eql([\"abc\", \"abc\"]);\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), [[Buffer.from(\"abc\")]]])).to.eql([\"abc\", [[\"abc\"]]]);\n      expect(utils.convertBufferToString([Buffer.from(\"abc\"), 5, \"b\", [[Buffer.from(\"abc\"), 4]]])).to.eql([\"abc\", 5, \"b\", [[\"abc\", 4]]]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".wrapMultiResult"],"updatePoint":{"line":15,"column":31,"index":801},"line":15,"code":"    it(\"should return correctly\", () => {\n      expect(utils.wrapMultiResult(null)).to.eql(null);\n      expect(utils.wrapMultiResult([1, 2])).to.eql([[null, 1], [null, 2]]);\n      const error = new Error(\"2\");\n      expect(utils.wrapMultiResult([1, 2, error])).to.eql([[null, 1], [null, 2], [error]]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".isInt"],"updatePoint":{"line":23,"column":31,"index":1146},"line":23,"code":"    it(\"should return correctly\", () => {\n      expect(utils.isInt(2)).to.eql(true);\n      expect(utils.isInt(\"2231\")).to.eql(true);\n      expect(utils.isInt(\"s\")).to.eql(false);\n      expect(utils.isInt(\"1s\")).to.eql(false);\n      expect(utils.isInt(false)).to.eql(false);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".packObject"],"updatePoint":{"line":32,"column":31,"index":1468},"line":32,"code":"    it(\"should return correctly\", () => {\n      expect(utils.packObject([1, 2])).to.eql({\n        1: 2\n      });\n      expect(utils.packObject([1, \"2\"])).to.eql({\n        1: \"2\"\n      });\n      expect(utils.packObject([1, \"2\", \"abc\", \"def\"])).to.eql({\n        1: \"2\",\n        abc: \"def\"\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return a callback","suites":["utils",".timeout"],"updatePoint":{"line":46,"column":32,"index":1811},"line":46,"code":"    it(\"should return a callback\", done => {\n      let invoked = false;\n      const wrappedCallback1 = utils.timeout(() => {\n        invoked = true;\n      }, 0);\n      wrappedCallback1();\n      let invokedTimes = 0;\n      var wrappedCallback2 = utils.timeout(function (err) {\n        expect(err.message).to.match(/timeout/);\n        invokedTimes += 1;\n        wrappedCallback2();\n        setTimeout(() => {\n          expect(invoked).to.eql(true);\n          expect(invokedTimes).to.eql(1);\n          done();\n        }, 0);\n      }, 0);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertObjectToArray"],"updatePoint":{"line":66,"column":31,"index":2403},"line":66,"code":"    it(\"should return correctly\", () => {\n      const nullObject = Object.create(null);\n      nullObject.abc = \"def\";\n      expect(utils.convertObjectToArray(nullObject)).to.eql([\"abc\", \"def\"]);\n      expect(utils.convertObjectToArray({\n        1: 2\n      })).to.eql([\"1\", 2]);\n      expect(utils.convertObjectToArray({\n        1: \"2\"\n      })).to.eql([\"1\", \"2\"]);\n      expect(utils.convertObjectToArray({\n        1: \"2\",\n        abc: \"def\"\n      })).to.eql([\"1\", \"2\", \"abc\", \"def\"]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".convertMapToArray"],"updatePoint":{"line":83,"column":31,"index":2944},"line":83,"code":"    it(\"should return correctly\", () => {\n      expect(utils.convertMapToArray(new Map([[\"1\", 2]]))).to.eql([\"1\", 2]);\n      expect(utils.convertMapToArray(new Map([[1, 2]]))).to.eql([1, 2]);\n      expect(utils.convertMapToArray(new Map() < number | string, string > [[1, \"2\"], [\"abc\", \"def\"]])).to.eql([1, \"2\", \"abc\", \"def\"]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".toArg"],"updatePoint":{"line":90,"column":31,"index":3315},"line":90,"code":"    it(\"should return correctly\", () => {\n      expect(utils.toArg(null)).to.eql(\"\");\n      expect(utils.toArg(undefined)).to.eql(\"\");\n      expect(utils.toArg(\"abc\")).to.eql(\"abc\");\n      expect(utils.toArg(123)).to.eql(\"123\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".optimizeErrorStack"],"updatePoint":{"line":98,"column":31,"index":3600},"line":98,"code":"    it(\"should return correctly\", () => {\n      const error = new Error();\n      const res = utils.optimizeErrorStack(error, new Error().stack + \"\\n@\", __dirname);\n      expect(res.stack.split(\"\\n\").pop()).to.eql(\"@\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return correctly","suites":["utils",".parseURL"],"updatePoint":{"line":105,"column":31,"index":3865},"line":105,"code":"    it(\"should return correctly\", () => {\n      expect(utils.parseURL(\"/tmp.sock\")).to.eql({\n        path: \"/tmp.sock\"\n      });\n      expect(utils.parseURL(\"127.0.0.1\")).to.eql({\n        host: \"127.0.0.1\"\n      });\n      expect(utils.parseURL(\"6379\")).to.eql({\n        port: \"6379\"\n      });\n      expect(utils.parseURL(\"127.0.0.1:6379\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6379\"\n      });\n      expect(utils.parseURL(\"127.0.0.1:6379?db=2&key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6379\",\n        db: \"2\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user:pass@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"pass\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user:pass:word@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"pass:word\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://user@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://127.0.0.1/\")).to.eql({\n        host: \"127.0.0.1\"\n      });\n      expect(utils.parseURL(\"rediss://user:pass@127.0.0.1:6380/4?key=value\")).to.eql({\n        host: \"127.0.0.1\",\n        port: \"6380\",\n        db: \"4\",\n        username: \"user\",\n        password: \"pass\",\n        key: \"value\"\n      });\n      expect(utils.parseURL(\"redis://127.0.0.1/?family=6\")).to.eql({\n        host: \"127.0.0.1\",\n        family: 6\n      });\n      expect(utils.parseURL(\"redis://127.0.0.1/?family=IPv6\")).to.eql({\n        host: \"127.0.0.1\",\n        family: \"IPv6\"\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should leave options alone when no tls profile is set","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":171,"column":61,"index":5819},"line":171,"code":"    it(\"should leave options alone when no tls profile is set\", () => {\n      [{\n        host: \"localhost\",\n        port: 6379\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: true\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: false\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: \"foo\"\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: {}\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: {\n          ca: \"foo\"\n        }\n      }, {\n        host: \"localhost\",\n        port: 6379,\n        tls: {\n          profile: \"foo\"\n        }\n      }].forEach(options => {\n        expect(utils.resolveTLSProfile(options)).to.eql(options);\n      });\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should have redis.com profiles defined","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":207,"column":46,"index":6560},"line":207,"code":"    it(\"should have redis.com profiles defined\", () => {\n      expect(TLSProfiles).to.have.property(\"RedisCloudFixed\");\n      expect(TLSProfiles).to.have.property(\"RedisCloudFlexible\");\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should read profile from options.tls.profile","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":211,"column":52,"index":6760},"line":211,"code":"    it(\"should read profile from options.tls.profile\", () => {\n      const input = {\n        host: \"localhost\",\n        port: 6379,\n        tls: {\n          profile: \"RedisCloudFixed\"\n        }\n      };\n      const expected = {\n        host: \"localhost\",\n        port: 6379,\n        tls: TLSProfiles.RedisCloudFixed\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should read profile from options.tls","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":226,"column":44,"index":7148},"line":226,"code":"    it(\"should read profile from options.tls\", () => {\n      const input = {\n        host: \"localhost\",\n        port: 6379,\n        tls: \"RedisCloudFixed\"\n      };\n      const expected = {\n        host: \"localhost\",\n        port: 6379,\n        tls: TLSProfiles.RedisCloudFixed\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"supports extra options when using options.tls.profile","suites":["utils",".resolveTLSProfile"],"updatePoint":{"line":239,"column":61,"index":7522},"line":239,"code":"    it(\"supports extra options when using options.tls.profile\", () => {\n      const input = {\n        host: \"localhost\",\n        port: 6379,\n        tls: {\n          profile: \"RedisCloudFixed\",\n          key: \"foo\"\n        }\n      };\n      const expected = {\n        host: \"localhost\",\n        port: 6379,\n        tls: {\n          ...TLSProfiles.RedisCloudFixed,\n          key: \"foo\"\n        }\n      };\n      expect(utils.resolveTLSProfile(input)).to.eql(expected);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"should return a random value","suites":["utils",".sample"],"updatePoint":{"line":260,"column":36,"index":8007},"line":260,"code":"    it(\"should return a random value\", () => {\n      let stub = sinon.stub(Math, \"random\").callsFake(() => 0);\n      expect(utils.sample([1, 2, 3])).to.eql(1);\n      expect(utils.sample([1, 2, 3], 1)).to.eql(2);\n      expect(utils.sample([1, 2, 3], 2)).to.eql(3);\n      stub.restore();\n      stub = sinon.stub(Math, \"random\").callsFake(() => 0.999999);\n      expect(utils.sample([1, 2, 3])).to.eql(3);\n      expect(utils.sample([1, 2, 3], 1)).to.eql(3);\n      expect(utils.sample([1, 2, 3], 2)).to.eql(3);\n      stub.restore();\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"contains all items","suites":["utils",".shuffle"],"updatePoint":{"line":291,"column":26,"index":9009},"line":291,"code":"    it(\"contains all items\", () => {\n      testShuffle([1]);\n      testShuffle([1, 2]);\n      testShuffle([2, 1]);\n      testShuffle([1, 1, 1]);\n      testShuffle([1, 2, 3]);\n      testShuffle([3, -1, 0, 2, -1]);\n      testShuffle([\"a\", \"b\", \"d\", \"c\"]);\n      testShuffle([\"c\", \"b\"]);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"mutates the original array","suites":["utils",".shuffle"],"updatePoint":{"line":301,"column":34,"index":9310},"line":301,"code":"    it(\"mutates the original array\", () => {\n      const arr = [3, 7];\n      const ret = utils.shuffle(arr);\n      expect(arr === ret).to.eql(true);\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"},{"name":"shuffles the array","suites":["utils",".shuffle"],"updatePoint":{"line":306,"column":26,"index":9459},"line":306,"code":"    it(\"shuffles the array\", () => {\n      const arr = [1, 2, 3, 4];\n      const copy = arr.slice(0);\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        utils.shuffle(copy);\n        for (let i = 0; i < copy.length; i++) {\n          if (arr[i] !== copy[i]) {\n            return;\n          }\n        }\n      }\n    });","file":"unit/utils.ts","skipped":false,"dir":"test"}]}