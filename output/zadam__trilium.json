{"repo":"zadam/trilium","url":"https://github.com/zadam/trilium","branch":"master","configs":[{"package":"trilium","lang":"js","dir":"spec","framework":"jasmine","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"simple lexing","suites":["Lexer fulltext"],"line":3,"updatePoint":{"line":3,"column":19,"index":118},"code":"  it(\"simple lexing\", () => {\n    expect(lex(\"hello world\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"world\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"use quotes to keep words together","suites":["Lexer fulltext"],"line":6,"updatePoint":{"line":6,"column":39,"index":267},"code":"  it(\"use quotes to keep words together\", () => {\n    expect(lex(\"'hello world' my friend\").fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n    expect(lex('\"hello world\" my friend').fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n    expect(lex('`hello world` my friend').fulltextTokens.map(t => t.token)).toEqual([\"hello world\", \"my\", \"friend\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"you can use different quotes and other special characters inside quotes","suites":["Lexer fulltext"],"line":11,"updatePoint":{"line":11,"column":77,"index":715},"code":"  it(\"you can use different quotes and other special characters inside quotes\", () => {\n    expect(lex(\"'i can use \\\" or ` or #~=*' without problem\").fulltextTokens.map(t => t.token)).toEqual([\"i can use \\\" or ` or #~=*\", \"without\", \"problem\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"I can use backslash to escape quotes","suites":["Lexer fulltext"],"line":14,"updatePoint":{"line":14,"column":42,"index":932},"code":"  it(\"I can use backslash to escape quotes\", () => {\n    expect(lex(\"hello \\\\\\\"world\\\\\\\"\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", '\"world\"']);\n    expect(lex(\"hello \\\\\\'world\\\\\\'\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"'world'\"]);\n    expect(lex(\"hello \\\\\\`world\\\\\\`\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", '`world`']);\n    expect(lex('\"hello \\\\\\\"world\\\\\\\"').fulltextTokens.map(t => t.token)).toEqual(['hello \"world\"']);\n    expect(lex(\"'hello \\\\\\'world\\\\\\''\").fulltextTokens.map(t => t.token)).toEqual([\"hello 'world'\"]);\n    expect(lex(\"`hello \\\\\\`world\\\\\\``\").fulltextTokens.map(t => t.token)).toEqual([\"hello `world`\"]);\n    expect(lex(\"\\\\#token\").fulltextTokens.map(t => t.token)).toEqual([\"#token\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"quote inside a word does not have a special meaning","suites":["Lexer fulltext"],"line":23,"updatePoint":{"line":23,"column":57,"index":1702},"code":"  it(\"quote inside a word does not have a special meaning\", () => {\n    const lexResult = lex(\"d'Artagnan is dead #hero = d'Artagnan\");\n    expect(lexResult.fulltextTokens.map(t => t.token)).toEqual([\"d'artagnan\", \"is\", \"dead\"]);\n    expect(lexResult.expressionTokens.map(t => t.token)).toEqual(['#hero', '=', \"d'artagnan\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"if quote is not ended then it's just one long token","suites":["Lexer fulltext"],"line":28,"updatePoint":{"line":28,"column":57,"index":2034},"code":"  it(\"if quote is not ended then it's just one long token\", () => {\n    expect(lex(\"'unfinished quote\").fulltextTokens.map(t => t.token)).toEqual([\"unfinished quote\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"parenthesis and symbols in fulltext section are just normal characters","suites":["Lexer fulltext"],"line":31,"updatePoint":{"line":31,"column":76,"index":2228},"code":"  it(\"parenthesis and symbols in fulltext section are just normal characters\", () => {\n    expect(lex(\"what's u=p <b(r*t)h>\").fulltextTokens.map(t => t.token)).toEqual([\"what's\", \"u=p\", \"<b(r*t)h>\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"operator characters in expressions are separate tokens","suites":["Lexer fulltext"],"line":34,"updatePoint":{"line":34,"column":60,"index":2419},"code":"  it(\"operator characters in expressions are separate tokens\", () => {\n    expect(lex(\"# abc+=-def**-+d\").expressionTokens.map(t => t.token)).toEqual([\"#\", \"abc\", \"+=-\", \"def\", \"**-+\", \"d\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"escaping special characters","suites":["Lexer fulltext"],"line":37,"updatePoint":{"line":37,"column":33,"index":2590},"code":"  it(\"escaping special characters\", () => {\n    expect(lex(\"hello \\\\#\\\\~\\\\'\").fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"#~'\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"simple attribute existence","suites":["Lexer expression"],"line":42,"updatePoint":{"line":42,"column":32,"index":2775},"code":"  it(\"simple attribute existence\", () => {\n    expect(lex(\"#label ~relation\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"~relation\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"simple label operators","suites":["Lexer expression"],"line":45,"updatePoint":{"line":45,"column":28,"index":2925},"code":"  it(\"simple label operators\", () => {\n    expect(lex(\"#label*=*text\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"*=*\", \"text\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"simple label operator with in quotes","suites":["Lexer expression"],"line":48,"updatePoint":{"line":48,"column":42,"index":3088},"code":"  it(\"simple label operator with in quotes\", () => {\n    expect(lex(\"#label*=*'text'\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"*=*\",\n      inQuotes: false,\n      startIndex: 6,\n      endIndex: 8\n    }, {\n      token: \"text\",\n      inQuotes: true,\n      startIndex: 10,\n      endIndex: 13\n    }]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"simple label operator with param without quotes","suites":["Lexer expression"],"line":66,"updatePoint":{"line":66,"column":53,"index":3499},"code":"  it(\"simple label operator with param without quotes\", () => {\n    expect(lex(\"#label*=*text\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"*=*\",\n      inQuotes: false,\n      startIndex: 6,\n      endIndex: 8\n    }, {\n      token: \"text\",\n      inQuotes: false,\n      startIndex: 9,\n      endIndex: 12\n    }]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"simple label operator with empty string param","suites":["Lexer expression"],"line":84,"updatePoint":{"line":84,"column":51,"index":3906},"code":"  it(\"simple label operator with empty string param\", () => {\n    expect(lex(\"#label = ''\").expressionTokens).toEqual([{\n      token: \"#label\",\n      inQuotes: false,\n      startIndex: 0,\n      endIndex: 5\n    }, {\n      token: \"=\",\n      inQuotes: false,\n      startIndex: 7,\n      endIndex: 7\n    },\n    // weird case for empty strings which ends up with endIndex < startIndex :-(\n    {\n      token: \"\",\n      inQuotes: true,\n      startIndex: 10,\n      endIndex: 9\n    }]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"note. prefix also separates fulltext from expression","suites":["Lexer expression"],"line":104,"updatePoint":{"line":104,"column":58,"index":4396},"code":"  it(\"note. prefix also separates fulltext from expression\", () => {\n    expect(lex(`hello fulltext note.labels.capital = Prague`).expressionTokens.map(t => t.token)).toEqual([\"note\", \".\", \"labels\", \".\", \"capital\", \"=\", \"prague\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"note. prefix in quotes will note start expression","suites":["Lexer expression"],"line":107,"updatePoint":{"line":107,"column":55,"index":4631},"code":"  it(\"note. prefix in quotes will note start expression\", () => {\n    expect(lex(`hello fulltext \"note.txt\"`).expressionTokens.map(t => t.token)).toEqual([]);\n    expect(lex(`hello fulltext \"note.txt\"`).fulltextTokens.map(t => t.token)).toEqual([\"hello\", \"fulltext\", \"note.txt\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"complex expressions with and, or and parenthesis","suites":["Lexer expression"],"line":111,"updatePoint":{"line":111,"column":54,"index":4917},"code":"  it(\"complex expressions with and, or and parenthesis\", () => {\n    expect(lex(`# (#label=text OR #second=text) AND ~relation`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"(\", \"#label\", \"=\", \"text\", \"or\", \"#second\", \"=\", \"text\", \")\", \"and\", \"~relation\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"dot separated properties","suites":["Lexer expression"],"line":114,"updatePoint":{"line":114,"column":30,"index":5163},"code":"  it(\"dot separated properties\", () => {\n    expect(lex(`# ~author.title = 'Hugh Howey' AND note.'book title' = 'Silo'`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"~author\", \".\", \"title\", \"=\", \"hugh howey\", \"and\", \"note\", \".\", \"book title\", \"=\", \"silo\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"negation of label and relation","suites":["Lexer expression"],"line":117,"updatePoint":{"line":117,"column":36,"index":5439},"code":"  it(\"negation of label and relation\", () => {\n    expect(lex(`#!capital ~!neighbor`).expressionTokens.map(t => t.token)).toEqual([\"#!capital\", \"~!neighbor\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"negation of sub-expression","suites":["Lexer expression"],"line":120,"updatePoint":{"line":120,"column":32,"index":5601},"code":"  it(\"negation of sub-expression\", () => {\n    expect(lex(`# not(#capital) and note.noteId != \"root\"`).expressionTokens.map(t => t.token)).toEqual([\"#\", \"not\", \"(\", \"#capital\", \")\", \"and\", \"note\", \".\", \"noteid\", \"!=\", \"root\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"concatenated attributes","suites":["Lexer invalid queries and edge cases"],"line":125,"updatePoint":{"line":125,"column":29,"index":5893},"code":"  it(\"concatenated attributes\", () => {\n    expect(lex(\"#label~relation\").expressionTokens.map(t => t.token)).toEqual([\"#label\", \"~relation\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"trailing escape \\","suites":["Lexer invalid queries and edge cases"],"line":128,"updatePoint":{"line":128,"column":24,"index":6038},"code":"  it(\"trailing escape \\\\\", () => {\n    expect(lex('abc \\\\').fulltextTokens.map(t => t.token)).toEqual([\"abc\", \"\\\\\"]);\n  });","file":"search/lexer.spec.js","skipped":false,"dir":"spec"},{"name":"handles parens","suites":["Parens handler"],"line":3,"updatePoint":{"line":3,"column":20,"index":138},"code":"  it(\"handles parens\", () => {\n    const input = [\"(\", \"hello\", \")\", \"and\", \"(\", \"(\", \"pick\", \"one\", \")\", \"and\", \"another\", \")\"].map(token => ({\n      token\n    }));\n    expect(handleParens(input)).toEqual([[{\n      token: \"hello\"\n    }], {\n      token: \"and\"\n    }, [[{\n      token: \"pick\"\n    }, {\n      token: \"one\"\n    }], {\n      token: \"and\"\n    }, {\n      token: \"another\"\n    }]]);\n  });","file":"search/parens.spec.js","skipped":false,"dir":"spec"},{"name":"fulltext parser without content","suites":["Parser"],"line":25,"updatePoint":{"line":25,"column":37,"index":746},"code":"  it(\"fulltext parser without content\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\", \"hi\"]),\n      expressionTokens: [],\n      searchContext: new SearchContext({\n        includeNoteContent: false,\n        excludeArchived: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    expect(rootExp.subExpressions[0].constructor.name).toEqual(\"PropertyComparisonExp\");\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    expect(rootExp.subExpressions[1].subExpressions[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(rootExp.subExpressions[1].subExpressions[0].tokens).toEqual([\"hello\", \"hi\"]);\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"fulltext parser with content","suites":["Parser"],"line":40,"updatePoint":{"line":40,"column":34,"index":1431},"code":"  it(\"fulltext parser with content\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\", \"hi\"]),\n      expressionTokens: [],\n      searchContext: new SearchContext({\n        includeNoteContent: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const subs = rootExp.subExpressions[1].subExpressions;\n    expect(subs[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(subs[0].tokens).toEqual([\"hello\", \"hi\"]);\n    expect(subs[1].constructor.name).toEqual(\"NoteContentFulltextExp\");\n    expect(subs[1].tokens).toEqual([\"hello\", \"hi\"]);\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple label comparison","suites":["Parser"],"line":57,"updatePoint":{"line":57,"column":29,"index":2151},"code":"  it(\"simple label comparison\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#mylabel\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(rootExp.subExpressions[1].attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].attributeName).toEqual(\"mylabel\");\n    expect(rootExp.subExpressions[1].comparator).toBeTruthy();\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple attribute negation","suites":["Parser"],"line":70,"updatePoint":{"line":70,"column":31,"index":2757},"code":"  it(\"simple attribute negation\", () => {\n    let rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#!mylabel\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"NotExp\");\n    expect(rootExp.subExpressions[1].subExpression.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(rootExp.subExpressions[1].subExpression.attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].subExpression.attributeName).toEqual(\"mylabel\");\n    rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"~!myrelation\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"NotExp\");\n    expect(rootExp.subExpressions[1].subExpression.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(rootExp.subExpressions[1].subExpression.attributeType).toEqual(\"relation\");\n    expect(rootExp.subExpressions[1].subExpression.attributeName).toEqual(\"myrelation\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple label AND","suites":["Parser"],"line":94,"updatePoint":{"line":94,"column":22,"index":3995},"code":"  it(\"simple label AND\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"and\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext(true)\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple label AND without explicit AND","suites":["Parser"],"line":109,"updatePoint":{"line":109,"column":43,"index":4752},"code":"  it(\"simple label AND without explicit AND\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple label OR","suites":["Parser"],"line":124,"updatePoint":{"line":124,"column":21,"index":5476},"code":"  it(\"simple label OR\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"or\", \"#second\", \"=\", \"text\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSub.attributeName).toEqual(\"second\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"fulltext and simple label","suites":["Parser"],"line":139,"updatePoint":{"line":139,"column":31,"index":6215},"code":"  it(\"fulltext and simple label\", () => {\n    const rootExp = parse({\n      fulltextTokens: tokens([\"hello\"]),\n      expressionTokens: tokens([\"#mylabel\", \"=\", \"text\"]),\n      searchContext: new SearchContext({\n        excludeArchived: true\n      })\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub, thirdSub] = rootExp.subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"PropertyComparisonExp\");\n    expect(firstSub.propertyName).toEqual('isArchived');\n    expect(secondSub.constructor.name).toEqual(\"OrExp\");\n    expect(secondSub.subExpressions[0].constructor.name).toEqual(\"NoteFlatTextExp\");\n    expect(secondSub.subExpressions[0].tokens).toEqual([\"hello\"]);\n    expect(thirdSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(thirdSub.attributeName).toEqual(\"mylabel\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"label sub-expression","suites":["Parser"],"line":157,"updatePoint":{"line":157,"column":26,"index":7060},"code":"  it(\"label sub-expression\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"text\", \"or\", [\"#second\", \"=\", \"text\", \"and\", \"#third\", \"=\", \"text\"]]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"OrExp\");\n    const [firstSub, secondSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"AndExp\");\n    const [firstSubSub, secondSubSub] = secondSub.subExpressions;\n    expect(firstSubSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(firstSubSub.attributeName).toEqual(\"second\");\n    expect(secondSubSub.constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(secondSubSub.attributeName).toEqual(\"third\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"label sub-expression without explicit operator","suites":["Parser"],"line":176,"updatePoint":{"line":176,"column":52,"index":8110},"code":"  it(\"label sub-expression without explicit operator\", () => {\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", [\"#second\", \"or\", \"#third\"], \"#fourth\"]),\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"AndExp\");\n    const [firstSub, secondSub, thirdSub] = rootExp.subExpressions[1].subExpressions;\n    expect(firstSub.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(firstSub.attributeName).toEqual(\"first\");\n    expect(secondSub.constructor.name).toEqual(\"OrExp\");\n    const [firstSubSub, secondSubSub] = secondSub.subExpressions;\n    expect(firstSubSub.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(firstSubSub.attributeName).toEqual(\"second\");\n    expect(secondSubSub.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(secondSubSub.attributeName).toEqual(\"third\");\n    expect(thirdSub.constructor.name).toEqual(\"AttributeExistsExp\");\n    expect(thirdSub.attributeName).toEqual(\"fourth\");\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"incomplete comparison","suites":["Invalid expressions"],"line":199,"updatePoint":{"line":199,"column":27,"index":9277},"code":"  it(\"incomplete comparison\", () => {\n    const searchContext = new SearchContext();\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual('Misplaced or incomplete expression \"=\"');\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"comparison between labels is impossible","suites":["Invalid expressions"],"line":208,"updatePoint":{"line":208,"column":45,"index":9584},"code":"  it(\"comparison between labels is impossible\", () => {\n    let searchContext = new SearchContext();\n    searchContext.originalQuery = \"#first = #second\";\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"#second\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual(`Error near token \"#second\" in \"#first = #second\", it's possible to compare with constant only.`);\n    searchContext = new SearchContext();\n    searchContext.originalQuery = \"#first = note.relations.second\";\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"#first\", \"=\", \"note\", \".\", \"relations\", \"second\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual(`Error near token \"note\" in \"#first = note.relations.second\", it's possible to compare with constant only.`);\n    const rootExp = parse({\n      fulltextTokens: [],\n      expressionTokens: [{\n        token: \"#first\",\n        inQuotes: false\n      }, {\n        token: \"=\",\n        inQuotes: false\n      }, {\n        token: \"#second\",\n        inQuotes: true\n      }],\n      searchContext: new SearchContext()\n    });\n    expect(rootExp.constructor.name).toEqual(\"AndExp\");\n    assertIsArchived(rootExp.subExpressions[0]);\n    expect(rootExp.subExpressions[1].constructor.name).toEqual(\"LabelComparisonExp\");\n    expect(rootExp.subExpressions[1].attributeType).toEqual(\"label\");\n    expect(rootExp.subExpressions[1].attributeName).toEqual(\"first\");\n    expect(rootExp.subExpressions[1].comparator).toBeTruthy();\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"searching by relation without note property","suites":["Invalid expressions"],"line":246,"updatePoint":{"line":246,"column":49,"index":11122},"code":"  it(\"searching by relation without note property\", () => {\n    const searchContext = new SearchContext();\n    parse({\n      fulltextTokens: [],\n      expressionTokens: tokens([\"~first\", \"=\", \"text\", \"-\", \"abc\"]),\n      searchContext\n    });\n    expect(searchContext.error).toEqual('Relation can be compared only with property, e.g. ~relation.title=hello in \"\"');\n  });","file":"search/parser.spec.js","skipped":false,"dir":"spec"},{"name":"simple path match","suites":["Search"],"line":28,"updatePoint":{"line":28,"column":23,"index":802},"code":"  it(\"simple path match\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('europe austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"normal search looks also at attributes","suites":["Search"],"line":35,"updatePoint":{"line":35,"column":44,"index":1177},"code":"  it(\"normal search looks also at attributes\", () => {\n    const austria = note(\"Austria\");\n    const vienna = note(\"Vienna\");\n    rootNote.child(austria.relation('capital', vienna)).child(vienna.label('inhabitants', '1888776'));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('capital', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('inhabitants', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Vienna\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"normal search looks also at type and mime","suites":["Search"],"line":47,"updatePoint":{"line":47,"column":47,"index":1860},"code":"  it(\"normal search looks also at type and mime\", () => {\n    rootNote.child(note(\"Effective Java\", {\n      type: 'book',\n      mime: ''\n    })).child(note(\"Hello World.java\", {\n      type: 'code',\n      mime: 'text/x-java'\n    }));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('book', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Effective Java\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('text', searchContext); // should match mime\n\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Hello World.java\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('java', searchContext);\n    expect(searchResults.length).toEqual(2);\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"only end leafs are results","suites":["Search"],"line":66,"updatePoint":{"line":66,"column":32,"index":2681},"code":"  it(\"only end leafs are results\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"only end leafs are results","suites":["Search"],"line":73,"updatePoint":{"line":73,"column":32,"index":3035},"code":"  it(\"only end leafs are results\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('Vienna', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"label comparison with short syntax","suites":["Search"],"line":80,"updatePoint":{"line":80,"column":40,"index":3425},"code":"  it(\"label comparison with short syntax\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')).child(note(\"Czech Republic\").label('capital', 'Prague')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#capital=Vienna', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n\n    // case sensitivity:\n    searchResults = searchService.findResultsWithQuery('#CAPITAL=VIENNA', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#caPItal=vienNa', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"label comparison with full syntax","suites":["Search"],"line":95,"updatePoint":{"line":95,"column":39,"index":4310},"code":"  it(\"label comparison with full syntax\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").label('capital', 'Vienna')).child(note(\"Czech Republic\").label('capital', 'Prague')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.labels.capital=Prague', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"numeric label comparison","suites":["Search"],"line":102,"updatePoint":{"line":102,"column":30,"index":4774},"code":"  it(\"numeric label comparison\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('population', '8859000')).child(note(\"Czech Republic\").label('population', '10650000')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('#country #population >= 10000000', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"inherited label comparison","suites":["Search"],"line":109,"updatePoint":{"line":109,"column":32,"index":5282},"code":"  it(\"inherited label comparison\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\")).child(note(\"Czech Republic\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('austria #country', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"numeric label comparison fallback to string comparison","suites":["Search"],"line":116,"updatePoint":{"line":116,"column":60,"index":5732},"code":"  it(\"numeric label comparison fallback to string comparison\", () => {\n    // dates should not be coerced into numbers which would then give wrong numbers\n\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('established', '1955-07-27')).child(note(\"Czech Republic\").label('established', '1993-01-01')).child(note(\"Hungary\").label('established', '1920-06-04')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#established <= \"1955-01-01\"', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Hungary\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#established > \"1955-01-01\"', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"smart date comparisons","suites":["Search"],"line":129,"updatePoint":{"line":129,"column":28,"index":6663},"code":"  it(\"smart date comparisons\", () => {\n    // dates should not be coerced into numbers which would then give wrong numbers\n\n    rootNote.child(note(\"My note\", {\n      dateCreated: dateUtils.localNowDateTime()\n    }).label('year', new Date().getFullYear().toString()).label('month', dateUtils.localNowDate().substr(0, 7)).label('date', dateUtils.localNowDate()).label('dateTime', dateUtils.localNowDateTime()));\n    const searchContext = new SearchContext();\n    function test(query, expectedResultCount) {\n      const searchResults = searchService.findResultsWithQuery(query, searchContext);\n      expect(searchResults.length).toEqual(expectedResultCount);\n      if (expectedResultCount === 1) {\n        expect(findNoteByTitle(searchResults, \"My note\")).toBeTruthy();\n      }\n    }\n    test(\"#year = YEAR\", 1);\n    test(\"#year = 'YEAR'\", 0);\n    test(\"#year >= YEAR\", 1);\n    test(\"#year <= YEAR\", 1);\n    test(\"#year < YEAR+1\", 1);\n    test(\"#year < YEAR + 1\", 1);\n    test(\"#year < year + 1\", 1);\n    test(\"#year > YEAR+1\", 0);\n    test(\"#month = MONTH\", 1);\n    test(\"#month = month\", 1);\n    test(\"#month = 'MONTH'\", 0);\n    test(\"note.dateCreated =* month\", 2);\n    test(\"#date = TODAY\", 1);\n    test(\"#date = today\", 1);\n    test(\"#date = 'today'\", 0);\n    test(\"#date > TODAY\", 0);\n    test(\"#date > TODAY-1\", 1);\n    test(\"#date > TODAY - 1\", 1);\n    test(\"#date < TODAY+1\", 1);\n    test(\"#date < TODAY + 1\", 1);\n    test(\"#date < 'TODAY + 1'\", 1);\n    test(\"#dateTime <= NOW+10\", 1);\n    test(\"#dateTime <= NOW + 10\", 1);\n    test(\"#dateTime < NOW-10\", 0);\n    test(\"#dateTime >= NOW-10\", 1);\n    test(\"#dateTime < NOW-10\", 0);\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"logical or","suites":["Search"],"line":170,"updatePoint":{"line":170,"column":16,"index":8294},"code":"  it(\"logical or\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('languageFamily', 'germanic')).child(note(\"Czech Republic\").label('languageFamily', 'slavic')).child(note(\"Hungary\").label('languageFamily', 'finnougric')));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('#languageFamily = slavic OR #languageFamily = germanic', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"fuzzy attribute search","suites":["Search"],"line":178,"updatePoint":{"line":178,"column":28,"index":8956},"code":"  it(\"fuzzy attribute search\", () => {\n    rootNote.child(note(\"Europe\").label('country', '', true).child(note(\"Austria\").label('languageFamily', 'germanic')).child(note(\"Czech Republic\").label('languageFamily', 'slavic')));\n    let searchContext = new SearchContext({\n      fuzzyAttributeSearch: false\n    });\n    let searchResults = searchService.findResultsWithQuery('#language', searchContext);\n    expect(searchResults.length).toEqual(0);\n    searchResults = searchService.findResultsWithQuery('#languageFamily=ger', searchContext);\n    expect(searchResults.length).toEqual(0);\n    searchContext = new SearchContext({\n      fuzzyAttributeSearch: true\n    });\n    searchResults = searchService.findResultsWithQuery('#language', searchContext);\n    expect(searchResults.length).toEqual(2);\n    searchResults = searchService.findResultsWithQuery('#languageFamily=ger', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by note property","suites":["Search"],"line":196,"updatePoint":{"line":196,"column":29,"index":9963},"code":"  it(\"filter by note property\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\")));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('# note.title =* czech', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by note's parent","suites":["Search"],"line":203,"updatePoint":{"line":203,"column":29,"index":10367},"code":"  it(\"filter by note's parent\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\").child(note(\"Prague\")))).child(note(\"Asia\").child(note('Taiwan')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Asia', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Taiwan\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.parents.parents.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Prague\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by note's ancestor","suites":["Search"],"line":217,"updatePoint":{"line":217,"column":31,"index":11349},"code":"  it(\"filter by note's ancestor\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\")).child(note(\"Czech Republic\").child(note(\"Prague\").label('city')))).child(note(\"Asia\").child(note('Taiwan').child(note('Taipei').label('city'))));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('#city AND note.ancestors.title = Europe', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Prague\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('#city AND note.ancestors.title = Asia', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Taipei\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by note's child","suites":["Search"],"line":227,"updatePoint":{"line":227,"column":28,"index":12098},"code":"  it(\"filter by note's child\", () => {\n    rootNote.child(note(\"Europe\").child(note(\"Austria\").child(note(\"Vienna\"))).child(note(\"Czech Republic\").child(note(\"Prague\")))).child(note(\"Oceania\").child(note('Australia')));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.children.title =* Aust', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Oceania\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.children.title =* Aust AND note.children.title *= republic', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.children.children.title = Prague', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Europe\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by relation's note properties using short syntax","suites":["Search"],"line":241,"updatePoint":{"line":241,"column":61,"index":13170},"code":"  it(\"filter by relation's note properties using short syntax\", () => {\n    const austria = note(\"Austria\");\n    const portugal = note(\"Portugal\");\n    rootNote.child(note(\"Europe\").child(austria).child(note(\"Czech Republic\").relation('neighbor', austria.note)).child(portugal).child(note(\"Spain\").relation('neighbor', portugal.note)));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# ~neighbor.title = Austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# ~neighbor.title = Portugal', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Spain\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by relation's note properties using long syntax","suites":["Search"],"line":253,"updatePoint":{"line":253,"column":60,"index":13999},"code":"  it(\"filter by relation's note properties using long syntax\", () => {\n    const austria = note(\"Austria\");\n    const portugal = note(\"Portugal\");\n    rootNote.child(note(\"Europe\").child(austria).child(note(\"Czech Republic\").relation('neighbor', austria.note)).child(portugal).child(note(\"Spain\").relation('neighbor', portugal.note)));\n    const searchContext = new SearchContext();\n    const searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.title = Austria', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"filter by multiple level relation","suites":["Search"],"line":262,"updatePoint":{"line":262,"column":39,"index":14609},"code":"  it(\"filter by multiple level relation\", () => {\n    const austria = note(\"Austria\");\n    const slovakia = note(\"Slovakia\");\n    const italy = note(\"Italy\");\n    const ukraine = note(\"Ukraine\");\n    rootNote.child(note(\"Europe\").child(austria.relation('neighbor', italy.note).relation('neighbor', slovakia.note)).child(note(\"Czech Republic\").relation('neighbor', austria.note).relation('neighbor', slovakia.note)).child(slovakia.relation('neighbor', ukraine.note)).child(ukraine));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.relations.neighbor.title = Italy', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    searchResults = searchService.findResultsWithQuery('# note.relations.neighbor.relations.neighbor.title = Ukraine', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(findNoteByTitle(searchResults, \"Czech Republic\")).toBeTruthy();\n    expect(findNoteByTitle(searchResults, \"Austria\")).toBeTruthy();\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"test note properties","suites":["Search"],"line":277,"updatePoint":{"line":277,"column":26,"index":15712},"code":"  it(\"test note properties\", () => {\n    const austria = note(\"Austria\");\n    austria.relation('myself', austria.note);\n    austria.label('capital', 'Vienna');\n    austria.label('population', '8859000');\n    rootNote.child(note(\"Asia\")).child(note(\"Europe\").child(austria.child(note(\"Vienna\")).child(note(\"Sebastian Kurz\")))).child(note(\"Mozart\").child(austria));\n    austria.note.isProtected = false;\n    austria.note.dateCreated = '2020-05-14 12:11:42.001+0200';\n    austria.note.dateModified = '2020-05-14 13:11:42.001+0200';\n    austria.note.utcDateCreated = '2020-05-14 10:11:42.001Z';\n    austria.note.utcDateModified = '2020-05-14 11:11:42.001Z';\n    austria.note.contentLength = 1001;\n    const searchContext = new SearchContext();\n    function test(propertyName, value, expectedResultCount) {\n      const searchResults = searchService.findResultsWithQuery(`# note.${propertyName} = ${value}`, searchContext);\n      expect(searchResults.length).toEqual(expectedResultCount);\n    }\n    test(\"type\", \"text\", 7);\n    test(\"TYPE\", \"TEXT\", 7);\n    test(\"type\", \"code\", 0);\n    test(\"mime\", \"text/html\", 6);\n    test(\"mime\", \"application/json\", 0);\n    test(\"isProtected\", \"false\", 7);\n    test(\"isProtected\", \"FALSE\", 7);\n    test(\"isProtected\", \"true\", 0);\n    test(\"isProtected\", \"TRUE\", 0);\n    test(\"dateCreated\", \"'2020-05-14 12:11:42.001+0200'\", 1);\n    test(\"dateCreated\", \"wrong\", 0);\n    test(\"dateModified\", \"'2020-05-14 13:11:42.001+0200'\", 1);\n    test(\"dateModified\", \"wrong\", 0);\n    test(\"utcDateCreated\", \"'2020-05-14 10:11:42.001Z'\", 1);\n    test(\"utcDateCreated\", \"wrong\", 0);\n    test(\"utcDateModified\", \"'2020-05-14 11:11:42.001Z'\", 1);\n    test(\"utcDateModified\", \"wrong\", 0);\n    test(\"parentCount\", \"2\", 1);\n    test(\"parentCount\", \"3\", 0);\n    test(\"childrenCount\", \"2\", 1);\n    test(\"childrenCount\", \"10\", 0);\n    test(\"attributeCount\", \"3\", 1);\n    test(\"attributeCount\", \"4\", 0);\n    test(\"labelCount\", \"2\", 1);\n    test(\"labelCount\", \"3\", 0);\n    test(\"relationCount\", \"1\", 1);\n    test(\"relationCount\", \"2\", 0);\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"test order by","suites":["Search"],"line":322,"updatePoint":{"line":322,"column":19,"index":17755},"code":"  it(\"test order by\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    const austria = note(\"Austria\").label(\"capital\", \"Vienna\");\n    const ukraine = note(\"Ukraine\").label(\"capital\", \"Kiev\");\n    rootNote.child(note(\"Europe\").child(ukraine).child(slovakia).child(austria).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.title', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Slovakia\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Ukraine\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Slovakia\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Ukraine\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Austria\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital DESC', searchContext);\n    expect(searchResults.length).toEqual(4);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    expect(becca.notes[searchResults[2].noteId].title).toEqual(\"Ukraine\");\n    expect(becca.notes[searchResults[3].noteId].title).toEqual(\"Slovakia\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy note.labels.capital DESC limit 2', searchContext);\n    expect(searchResults.length).toEqual(2);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Austria\");\n    expect(becca.notes[searchResults[1].noteId].title).toEqual(\"Italy\");\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy #capital DESC limit 1', searchContext);\n    expect(searchResults.length).toEqual(1);\n    searchResults = searchService.findResultsWithQuery('# note.parents.title = Europe orderBy #capital DESC limit 1000', searchContext);\n    expect(searchResults.length).toEqual(4);\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"test not(...)","suites":["Search"],"line":356,"updatePoint":{"line":356,"column":19,"index":20314},"code":"  it(\"test not(...)\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Europe\").child(slovakia).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# not(#capital) and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Europe\");\n    searchResults = searchService.findResultsWithQuery('#!capital and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Europe\");\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"test note.text *=* something","suites":["Search"],"line":368,"updatePoint":{"line":368,"column":34,"index":21069},"code":"  it(\"test note.text *=* something\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Europe\").child(slovakia).child(italy));\n    const searchContext = new SearchContext();\n    let searchResults = searchService.findResultsWithQuery('# note.text *=* vaki and note.noteId != root', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Slovakia\");\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"test that fulltext does not match archived notes","suites":["Search"],"line":377,"updatePoint":{"line":377,"column":54,"index":21624},"code":"  it(\"test that fulltext does not match archived notes\", () => {\n    const italy = note(\"Italy\").label(\"capital\", \"Rome\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    rootNote.child(note(\"Reddit\").label('archived', '', true).child(note('Post X')).child(note('Post Y'))).child(note('Reddit is bad'));\n    const searchContext = new SearchContext({\n      excludeArchived: true\n    });\n    let searchResults = searchService.findResultsWithQuery('reddit', searchContext);\n    expect(searchResults.length).toEqual(1);\n    expect(becca.notes[searchResults[0].noteId].title).toEqual(\"Reddit is bad\");\n  });","file":"search/search.spec.js","skipped":false,"dir":"spec"},{"name":"simple title extraction","suites":["Value extractor"],"line":12,"updatePoint":{"line":12,"column":29,"index":392},"code":"  it(\"simple title extraction\", async () => {\n    const europe = note(\"Europe\").note;\n    const valueExtractor = new ValueExtractor(dsc, [\"note\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(europe)).toEqual(\"Europe\");\n  });","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"label extraction","suites":["Value extractor"],"line":18,"updatePoint":{"line":18,"column":22,"index":661},"code":"  it(\"label extraction\", async () => {\n    const austria = note(\"Austria\").label(\"Capital\", \"Vienna\").note;\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria)).toEqual(\"Vienna\");\n    valueExtractor = new ValueExtractor(dsc, [\"#capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria)).toEqual(\"Vienna\");\n  });","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"parent/child property extraction","suites":["Value extractor"],"line":27,"updatePoint":{"line":27,"column":38,"index":1160},"code":"  it(\"parent/child property extraction\", async () => {\n    const vienna = note(\"Vienna\");\n    const europe = note(\"Europe\").child(note(\"Austria\").child(vienna));\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"children\", \"children\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(europe.note)).toEqual(\"Vienna\");\n    valueExtractor = new ValueExtractor(dsc, [\"note\", \"parents\", \"parents\", \"title\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(vienna.note)).toEqual(\"Europe\");\n  });","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"extract through relation","suites":["Value extractor"],"line":37,"updatePoint":{"line":37,"column":30,"index":1736},"code":"  it(\"extract through relation\", async () => {\n    const czechRepublic = note(\"Czech Republic\").label(\"capital\", \"Prague\");\n    const slovakia = note(\"Slovakia\").label(\"capital\", \"Bratislava\");\n    const austria = note(\"Austria\").relation('neighbor', czechRepublic.note).relation('neighbor', slovakia.note);\n    let valueExtractor = new ValueExtractor(dsc, [\"note\", \"relations\", \"neighbor\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria.note)).toEqual(\"Prague\");\n    valueExtractor = new ValueExtractor(dsc, [\"~neighbor\", \"labels\", \"capital\"]);\n    expect(valueExtractor.validate()).toBeFalsy();\n    expect(valueExtractor.extract(austria.note)).toEqual(\"Prague\");\n  });","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"each path must start with \"note\" (or label/relation)","suites":["Invalid value extractor property path"],"line":50,"updatePoint":{"line":50,"column":58,"index":2566},"code":"  it('each path must start with \"note\" (or label/relation)', () => expect(new ValueExtractor(dsc, [\"neighbor\"]).validate()).toBeTruthy());","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"extra path element after terminal label","suites":["Invalid value extractor property path"],"line":51,"updatePoint":{"line":51,"column":45,"index":2692},"code":"  it(\"extra path element after terminal label\", () => expect(new ValueExtractor(dsc, [\"~neighbor\", \"labels\", \"capital\", \"noteId\"]).validate()).toBeTruthy());","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"extra path element after terminal title","suites":["Invalid value extractor property path"],"line":52,"updatePoint":{"line":52,"column":45,"index":2850},"code":"  it(\"extra path element after terminal title\", () => expect(new ValueExtractor(dsc, [\"note\", \"title\", \"isProtected\"]).validate()).toBeTruthy());","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"relation name and note property is missing","suites":["Invalid value extractor property path"],"line":53,"updatePoint":{"line":53,"column":48,"index":2999},"code":"  it(\"relation name and note property is missing\", () => expect(new ValueExtractor(dsc, [\"note\", \"relations\"]).validate()).toBeTruthy());","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"},{"name":"relation is specified but target note property is not specified","suites":["Invalid value extractor property path"],"line":54,"updatePoint":{"line":54,"column":69,"index":3158},"code":"  it(\"relation is specified but target note property is not specified\", () => expect(new ValueExtractor(dsc, [\"note\", \"relations\", \"myrel\"]).validate()).toBeTruthy());","file":"search/value_extractor.spec.js","skipped":false,"dir":"spec"}]}