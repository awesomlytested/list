{"repo":"puppeteer/puppeteer","url":"https://github.com/puppeteer/puppeteer","branch":"main","configs":[{"package":"puppeteer","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should work","suites":["Accessibility"],"updatePoint":{"line":30,"column":17},"line":30,"code":"  it('should work', async () => {\n    const {page, isFirefox} = getTestState();\n\n    await page.setContent(`\n      <head>\n        <title>Accessibility Test</title>\n      </head>\n      <body>\n        <div>Hello World</div>\n        <h1>Inputs</h1>\n        <input placeholder=\"Empty input\" autofocus />\n        <input placeholder=\"readonly input\" readonly />\n        <input placeholder=\"disabled input\" disabled />\n        <input aria-label=\"Input with whitespace\" value=\"  \" />\n        <input value=\"value only\" />\n        <input aria-placeholder=\"placeholder\" value=\"and a value\" />\n        <div aria-hidden=\"true\" id=\"desc\">This is a description!</div>\n        <input aria-placeholder=\"placeholder\" value=\"and a value\" aria-describedby=\"desc\" />\n        <select>\n          <option>First Option</option>\n          <option>Second Option</option>\n        </select>\n      </body>`);\n\n    await page.focus('[placeholder=\"Empty input\"]');\n    const golden = isFirefox\n      ? {\n          role: 'document',\n          name: 'Accessibility Test',\n          children: [\n            {role: 'text leaf', name: 'Hello World'},\n            {role: 'heading', name: 'Inputs', level: 1},\n            {role: 'entry', name: 'Empty input', focused: true},\n            {role: 'entry', name: 'readonly input', readonly: true},\n            {role: 'entry', name: 'disabled input', disabled: true},\n            {role: 'entry', name: 'Input with whitespace', value: '  '},\n            {role: 'entry', name: '', value: 'value only'},\n            {role: 'entry', name: '', value: 'and a value'}, // firefox doesn't use aria-placeholder for the name\n            {\n              role: 'entry',\n              name: '',\n              value: 'and a value',\n              description: 'This is a description!',\n            }, // and here\n            {\n              role: 'combobox',\n              name: '',\n              value: 'First Option',\n              haspopup: true,\n              children: [\n                {\n                  role: 'combobox option',\n                  name: 'First Option',\n                  selected: true,\n                },\n                {role: 'combobox option', name: 'Second Option'},\n              ],\n            },\n          ],\n        }\n      : {\n          role: 'RootWebArea',\n          name: 'Accessibility Test',\n          children: [\n            {role: 'StaticText', name: 'Hello World'},\n            {role: 'heading', name: 'Inputs', level: 1},\n            {role: 'textbox', name: 'Empty input', focused: true},\n            {role: 'textbox', name: 'readonly input', readonly: true},\n            {role: 'textbox', name: 'disabled input', disabled: true},\n            {role: 'textbox', name: 'Input with whitespace', value: '  '},\n            {role: 'textbox', name: '', value: 'value only'},\n            {role: 'textbox', name: 'placeholder', value: 'and a value'},\n            {\n              role: 'textbox',\n              name: 'placeholder',\n              value: 'and a value',\n              description: 'This is a description!',\n            },\n            {\n              role: 'combobox',\n              name: '',\n              value: 'First Option',\n              haspopup: 'menu',\n              children: [\n                {role: 'menuitem', name: 'First Option', selected: true},\n                {role: 'menuitem', name: 'Second Option'},\n              ],\n            },\n          ],\n        };\n    expect(await page.accessibility.snapshot()).toEqual(golden);\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should report uninteresting nodes","suites":["Accessibility"],"updatePoint":{"line":122,"column":39},"line":122,"code":"  it('should report uninteresting nodes', async () => {\n    const {page, isFirefox} = getTestState();\n\n    await page.setContent(`<textarea>hi</textarea>`);\n    await page.focus('textarea');\n    const golden = isFirefox\n      ? {\n          role: 'entry',\n          name: '',\n          value: 'hi',\n          focused: true,\n          multiline: true,\n          children: [\n            {\n              role: 'text leaf',\n              name: 'hi',\n            },\n          ],\n        }\n      : {\n          role: 'textbox',\n          name: '',\n          value: 'hi',\n          focused: true,\n          multiline: true,\n          children: [\n            {\n              role: 'generic',\n              name: '',\n              children: [\n                {\n                  role: 'StaticText',\n                  name: 'hi',\n                },\n              ],\n            },\n          ],\n        };\n    expect(\n      findFocusedNode(\n        await page.accessibility.snapshot({interestingOnly: false})\n      )\n    ).toEqual(golden);\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"get snapshots while the tree is re-calculated","suites":["Accessibility"],"updatePoint":{"line":166,"column":51},"line":166,"code":"  it('get snapshots while the tree is re-calculated', async () => {\n    // see https://github.com/puppeteer/puppeteer/issues/9404\n    const {page} = getTestState();\n\n    await page.setContent(\n      `<!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Accessible name + aria-expanded puppeteer bug</title>\n        <style>\n          [aria-expanded=\"false\"] + * {\n            display: none;\n          }\n        </style>\n      </head>\n      <body>\n        <button hidden>Show</button>\n        <p>Some content</p>\n        <script>\n          const button = document.querySelector('button');\n          button.removeAttribute('hidden')\n          button.setAttribute('aria-expanded', 'false');\n          button.addEventListener('click', function() {\n            button.setAttribute('aria-expanded', button.getAttribute('aria-expanded') !== 'true')\n            if (button.getAttribute('aria-expanded') == 'true') {\n              button.textContent = 'Hide'\n            } else {\n              button.textContent = 'Show'\n            }\n          })\n        </script>\n      </body>\n      </html>`\n    );\n    async function getAccessibleName(page: any, element: any) {\n      return (await page.accessibility.snapshot({root: element})).name;\n    }\n    const button = await page.$('button');\n    expect(await getAccessibleName(page, button)).toEqual('Show');\n    await button?.click();\n    await page.waitForSelector('aria/Hide');\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"roledescription","suites":["Accessibility"],"updatePoint":{"line":211,"column":21},"line":211,"code":"  it('roledescription', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(\n      '<div tabIndex=-1 aria-roledescription=\"foo\">Hi</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    // See https://chromium-review.googlesource.com/c/chromium/src/+/3088862\n    assert(snapshot);\n    assert(snapshot.children);\n    assert(snapshot.children[0]!);\n    expect(snapshot.children[0]!.roledescription).toBeUndefined();\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"orientation","suites":["Accessibility"],"updatePoint":{"line":224,"column":17},"line":224,"code":"  it('orientation', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(\n      '<a href=\"\" role=\"slider\" aria-orientation=\"vertical\">11</a>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    assert(snapshot);\n    assert(snapshot.children);\n    assert(snapshot.children[0]!);\n    expect(snapshot.children[0]!.orientation).toEqual('vertical');\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"autocomplete","suites":["Accessibility"],"updatePoint":{"line":236,"column":18},"line":236,"code":"  it('autocomplete', async () => {\n    const {page} = getTestState();\n\n    await page.setContent('<input type=\"number\" aria-autocomplete=\"list\" />');\n    const snapshot = await page.accessibility.snapshot();\n    assert(snapshot);\n    assert(snapshot.children);\n    assert(snapshot.children[0]!);\n    expect(snapshot.children[0]!.autocomplete).toEqual('list');\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"multiselectable","suites":["Accessibility"],"updatePoint":{"line":246,"column":21},"line":246,"code":"  it('multiselectable', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(\n      '<div role=\"grid\" tabIndex=-1 aria-multiselectable=true>hey</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    assert(snapshot);\n    assert(snapshot.children);\n    assert(snapshot.children[0]!);\n    expect(snapshot.children[0]!.multiselectable).toEqual(true);\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"keyshortcuts","suites":["Accessibility"],"updatePoint":{"line":258,"column":18},"line":258,"code":"  it('keyshortcuts', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(\n      '<div role=\"grid\" tabIndex=-1 aria-keyshortcuts=\"foo\">hey</div>'\n    );\n    const snapshot = await page.accessibility.snapshot();\n    assert(snapshot);\n    assert(snapshot.children);\n    assert(snapshot.children[0]!);\n    expect(snapshot.children[0]!.keyshortcuts).toEqual('foo');\n  });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should not report text nodes inside controls","suites":["Accessibility","filtering children of leaf nodes"],"updatePoint":{"line":271,"column":52},"line":271,"code":"    it('should not report text nodes inside controls', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div role=\"tablist\">\n          <div role=\"tab\" aria-selected=\"true\"><b>Tab1</b></div>\n          <div role=\"tab\">Tab2</div>\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'document',\n            name: '',\n            children: [\n              {\n                role: 'pagetab',\n                name: 'Tab1',\n                selected: true,\n              },\n              {\n                role: 'pagetab',\n                name: 'Tab2',\n              },\n            ],\n          }\n        : {\n            role: 'RootWebArea',\n            name: '',\n            children: [\n              {\n                role: 'tab',\n                name: 'Tab1',\n                selected: true,\n              },\n              {\n                role: 'tab',\n                name: 'Tab2',\n              },\n            ],\n          };\n      expect(await page.accessibility.snapshot()).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"rich text editable fields should have children","suites":["Accessibility","filtering children of leaf nodes"],"updatePoint":{"line":312,"column":54},"line":312,"code":"    it('rich text editable fields should have children', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div contenteditable=\"true\">\n          Edit this image: <img src=\"fakeimage.png\" alt=\"my fake image\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'section',\n            name: '',\n            children: [\n              {\n                role: 'text leaf',\n                name: 'Edit this image:',\n              },\n              {\n                role: 'StaticText',\n                name: 'my fake image',\n              },\n            ],\n          }\n        : {\n            role: 'generic',\n            name: '',\n            value: 'Edit this image: ',\n            children: [\n              {\n                role: 'StaticText',\n                name: 'Edit this image: ',\n              },\n              {\n                role: 'img',\n                name: 'my fake image',\n              },\n            ],\n          };\n      const snapshot = await page.accessibility.snapshot();\n      assert(snapshot);\n      assert(snapshot.children);\n      expect(snapshot.children[0]!).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"rich text editable fields with role should have children","suites":["Accessibility","filtering children of leaf nodes"],"updatePoint":{"line":354,"column":64},"line":354,"code":"    it('rich text editable fields with role should have children', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div contenteditable=\"true\" role='textbox'>\n          Edit this image: <img src=\"fakeimage.png\" alt=\"my fake image\">\n        </div>`);\n      // Image node should not be exposed in contenteditable elements. See https://crbug.com/1324392.\n      const golden = isFirefox\n        ? {\n            role: 'entry',\n            name: '',\n            value: 'Edit this image: my fake image',\n            children: [\n              {\n                role: 'StaticText',\n                name: 'my fake image',\n              },\n            ],\n          }\n        : {\n            role: 'textbox',\n            name: '',\n            value: 'Edit this image: ',\n            multiline: true,\n            children: [\n              {\n                role: 'StaticText',\n                name: 'Edit this image: ',\n              },\n            ],\n          };\n      const snapshot = await page.accessibility.snapshot();\n      assert(snapshot);\n      assert(snapshot.children);\n      expect(snapshot.children[0]!).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"plain text field with role should not have children","suites":["Accessibility","filtering children of leaf nodes","plaintext contenteditable"],"updatePoint":{"line":394,"column":61},"line":394,"code":"      it('plain text field with role should not have children', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`\n          <div contenteditable=\"plaintext-only\" role='textbox'>Edit this image:<img src=\"fakeimage.png\" alt=\"my fake image\"></div>`);\n        const snapshot = await page.accessibility.snapshot();\n        assert(snapshot);\n        assert(snapshot.children);\n        expect(snapshot.children[0]!).toEqual({\n          role: 'textbox',\n          name: '',\n          value: 'Edit this image:',\n          multiline: true,\n        });\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"non editable textbox with role and tabIndex and label should not have children","suites":["Accessibility","filtering children of leaf nodes","plaintext contenteditable"],"updatePoint":{"line":410,"column":86},"line":410,"code":"    it('non editable textbox with role and tabIndex and label should not have children', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div role=\"textbox\" tabIndex=0 aria-checked=\"true\" aria-label=\"my favorite textbox\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'entry',\n            name: 'my favorite textbox',\n            value: 'this is the inner content yo',\n          }\n        : {\n            role: 'textbox',\n            name: 'my favorite textbox',\n            value: 'this is the inner content ',\n          };\n      const snapshot = await page.accessibility.snapshot();\n      assert(snapshot);\n      assert(snapshot.children);\n      expect(snapshot.children[0]!).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"checkbox with and tabIndex and label should not have children","suites":["Accessibility","filtering children of leaf nodes","plaintext contenteditable"],"updatePoint":{"line":434,"column":69},"line":434,"code":"    it('checkbox with and tabIndex and label should not have children', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div role=\"checkbox\" tabIndex=0 aria-checked=\"true\" aria-label=\"my favorite checkbox\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'checkbutton',\n            name: 'my favorite checkbox',\n            checked: true,\n          }\n        : {\n            role: 'checkbox',\n            name: 'my favorite checkbox',\n            checked: true,\n          };\n      const snapshot = await page.accessibility.snapshot();\n      assert(snapshot);\n      assert(snapshot.children);\n      expect(snapshot.children[0]!).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"checkbox without label should not have children","suites":["Accessibility","filtering children of leaf nodes","plaintext contenteditable"],"updatePoint":{"line":458,"column":55},"line":458,"code":"    it('checkbox without label should not have children', async () => {\n      const {page, isFirefox} = getTestState();\n\n      await page.setContent(`\n        <div role=\"checkbox\" aria-checked=\"true\">\n          this is the inner content\n          <img alt=\"yo\" src=\"fakeimg.png\">\n        </div>`);\n      const golden = isFirefox\n        ? {\n            role: 'checkbutton',\n            name: 'this is the inner content yo',\n            checked: true,\n          }\n        : {\n            role: 'checkbox',\n            name: 'this is the inner content yo',\n            checked: true,\n          };\n      const snapshot = await page.accessibility.snapshot();\n      assert(snapshot);\n      assert(snapshot.children);\n      expect(snapshot.children[0]!).toEqual(golden);\n    });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work a button","suites":["Accessibility","filtering children of leaf nodes","root option"],"updatePoint":{"line":484,"column":30},"line":484,"code":"      it('should work a button', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`<button>My Button</button>`);\n\n        const button = (await page.$('button'))!;\n        expect(await page.accessibility.snapshot({root: button})).toEqual({\n          role: 'button',\n          name: 'My Button',\n        });\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work an input","suites":["Accessibility","filtering children of leaf nodes","root option"],"updatePoint":{"line":495,"column":30},"line":495,"code":"      it('should work an input', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`<input title=\"My Input\" value=\"My Value\">`);\n\n        const input = (await page.$('input'))!;\n        expect(await page.accessibility.snapshot({root: input})).toEqual({\n          role: 'textbox',\n          name: 'My Input',\n          value: 'My Value',\n        });\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should work a menu","suites":["Accessibility","filtering children of leaf nodes","root option"],"updatePoint":{"line":507,"column":28},"line":507,"code":"      it('should work a menu', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`\n            <div role=\"menu\" title=\"My Menu\">\n              <div role=\"menuitem\">First Item</div>\n              <div role=\"menuitem\">Second Item</div>\n              <div role=\"menuitem\">Third Item</div>\n            </div>\n          `);\n\n        const menu = (await page.$('div[role=\"menu\"]'))!;\n        expect(await page.accessibility.snapshot({root: menu})).toEqual({\n          role: 'menu',\n          name: 'My Menu',\n          children: [\n            {role: 'menuitem', name: 'First Item'},\n            {role: 'menuitem', name: 'Second Item'},\n            {role: 'menuitem', name: 'Third Item'},\n          ],\n          orientation: 'vertical',\n        });\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should return null when the element is no longer in DOM","suites":["Accessibility","filtering children of leaf nodes","root option"],"updatePoint":{"line":530,"column":65},"line":530,"code":"      it('should return null when the element is no longer in DOM', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`<button>My Button</button>`);\n        const button = (await page.$('button'))!;\n        await page.$eval('button', button => {\n          return button.remove();\n        });\n        expect(await page.accessibility.snapshot({root: button})).toEqual(null);\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should support the interestingOnly option","suites":["Accessibility","filtering children of leaf nodes","root option"],"updatePoint":{"line":540,"column":51},"line":540,"code":"      it('should support the interestingOnly option', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(`<div><button>My Button</button></div>`);\n        const div = (await page.$('div'))!;\n        expect(await page.accessibility.snapshot({root: div})).toEqual(null);\n        expect(\n          await page.accessibility.snapshot({\n            root: div,\n            interestingOnly: false,\n          })\n        ).toEqual({\n          role: 'generic',\n          name: '',\n          children: [\n            {\n              role: 'button',\n              name: 'My Button',\n              children: [{role: 'StaticText', name: 'My Button'}],\n            },\n          ],\n        });\n      });","file":"src/accessibility.spec.ts","skipped":false,"dir":"test"},{"name":"should find button","suites":["AriaQueryHandler","parseAriaSelector"],"updatePoint":{"line":40,"column":26},"line":40,"code":"    it('should find button', async () => {\n      const {page} = getTestState();\n      const expectFound = async (button: ElementHandle | null) => {\n        assert(button);\n        const id = await button.evaluate((button: Element) => {\n          return button.id;\n        });\n        expect(id).toBe('btn');\n      };\n      let button = await page.$(\n        'aria/Submit button and some spaces[role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        \"aria/Submit button and some spaces[role='button']\"\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/  Submit button and some spaces[role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit button and some spaces  [role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit  button   and  some  spaces   [  role  =  \"button\" ] '\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/[role=\"button\"]Submit button and some spaces'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/Submit button [role=\"button\"]and some spaces'\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/[name=\"  Submit  button and some  spaces\"][role=\"button\"]'\n      );\n      await expectFound(button);\n      button = await page.$(\n        \"aria/[name='  Submit  button and some  spaces'][role='button']\"\n      );\n      await expectFound(button);\n      button = await page.$(\n        'aria/ignored[name=\"Submit  button and some  spaces\"][role=\"button\"]'\n      );\n      await expectFound(button);\n      await expect(page.$('aria/smth[smth=\"true\"]')).rejects.toThrow(\n        'Unknown aria attribute \"smth\" in selector'\n      );\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find button by role","suites":["AriaQueryHandler","queryOne"],"updatePoint":{"line":96,"column":34},"line":96,"code":"    it('should find button by role', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"div\"><button id=\"btn\" role=\"button\">Submit</button></div>'\n      );\n      const button = (await page.$(\n        'aria/[role=\"button\"]'\n      )) as ElementHandle<HTMLButtonElement>;\n      const id = await button!.evaluate(button => {\n        return button.id;\n      });\n      expect(id).toBe('btn');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find button by name and role","suites":["AriaQueryHandler","queryOne"],"updatePoint":{"line":110,"column":43},"line":110,"code":"    it('should find button by name and role', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"div\"><button id=\"btn\" role=\"button\">Submit</button></div>'\n      );\n      const button = (await page.$(\n        'aria/Submit[role=\"button\"]'\n      )) as ElementHandle<HTMLButtonElement>;\n      const id = await button!.evaluate(button => {\n        return button.id;\n      });\n      expect(id).toBe('btn');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find first matching element","suites":["AriaQueryHandler","queryOne"],"updatePoint":{"line":124,"column":42},"line":124,"code":"    it('should find first matching element', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu div\"></div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu div\"></div>\n        `\n      );\n      const div = (await page.$(\n        'aria/menu div'\n      )) as ElementHandle<HTMLDivElement>;\n      const id = await div!.evaluate(div => {\n        return div.id;\n      });\n      expect(id).toBe('mnu1');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name","suites":["AriaQueryHandler","queryOne"],"updatePoint":{"line":141,"column":27},"line":141,"code":"    it('should find by name', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu-label1\">menu div</div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu-label2\">menu div</div>\n        `\n      );\n      const menu = (await page.$(\n        'aria/menu-label1'\n      )) as ElementHandle<HTMLDivElement>;\n      const id = await menu!.evaluate(div => {\n        return div.id;\n      });\n      expect(id).toBe('mnu1');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name","suites":["AriaQueryHandler","queryOne"],"updatePoint":{"line":158,"column":27},"line":158,"code":"    it('should find by name', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu-label1\">menu div</div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu-label2\">menu div</div>\n        `\n      );\n      const menu = (await page.$(\n        'aria/menu-label2'\n      )) as ElementHandle<HTMLDivElement>;\n      const id = await menu!.evaluate(div => {\n        return div.id;\n      });\n      expect(id).toBe('mnu2');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find menu by name","suites":["AriaQueryHandler","queryAll"],"updatePoint":{"line":177,"column":32},"line":177,"code":"    it('should find menu by name', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        `\n        <div role=\"menu\" id=\"mnu1\" aria-label=\"menu div\"></div>\n        <div role=\"menu\" id=\"mnu2\" aria-label=\"menu div\"></div>\n        `\n      );\n      const divs = (await page.$$('aria/menu div')) as Array<\n        ElementHandle<HTMLDivElement>\n      >;\n      const ids = await Promise.all(\n        divs.map(n => {\n          return n.evaluate(div => {\n            return div.id;\n          });\n        })\n      );\n      expect(ids.join(', ')).toBe('mnu1, mnu2');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should handle many elements","suites":["AriaQueryHandler","queryAllArray"],"updatePoint":{"line":199,"column":42},"line":199,"code":"    it('$$eval should handle many elements', async () => {\n      const {page} = getTestState();\n      await page.setContent('');\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 10000; i++) {\n            const button = document.createElement('button');\n            button.textContent = i;\n            document.body.appendChild(button);\n        }\n        `\n      );\n      const sum = await page.$$eval('aria/[role=\"button\"]', buttons => {\n        return buttons.reduce((acc, button) => {\n          return acc + Number(button.textContent);\n        }, 0);\n      });\n      expect(sum).toBe(50005000);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should immediately resolve promise if node exists","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":225,"column":57},"line":225,"code":"    it('should immediately resolve promise if node exists', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work for ElementHandle.waitForSelector","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":232,"column":53},"line":232,"code":"    it('should work for ElementHandle.waitForSelector', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        return (document.body.innerHTML = `<div><button>test</button></div>`);\n      });\n      const element = (await page.$('div'))!;\n      await element!.waitForSelector('aria/test');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should persist query handler bindings across reloads","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":242,"column":60},"line":242,"code":"    it('should persist query handler bindings across reloads', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n      await page.reload();\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should persist query handler bindings across navigations","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":252,"column":64},"line":252,"code":"    it('should persist query handler bindings across navigations', async () => {\n      const {page, server} = getTestState();\n\n      // Reset page but make sure that execution context ids start with 1.\n      await page.goto('data:text/html,');\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n\n      // Reset page but again make sure that execution context ids start with 1.\n      await page.goto('data:text/html,');\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work independently of `exposeFunction`","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":268,"column":53},"line":268,"code":"    it('should work independently of `exposeFunction`', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.exposeFunction('ariaQuerySelector', (a: number, b: number) => {\n        return a + b;\n      });\n      await page.evaluate(addElement, 'button');\n      await page.waitForSelector('aria/[role=\"button\"]');\n      const result = await page.evaluate('globalThis.ariaQuerySelector(2,8)');\n      expect(result).toBe(10);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work with removed MutationObserver","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":280,"column":49},"line":280,"code":"    it('should work with removed MutationObserver', async () => {\n      const {page} = getTestState();\n\n      await page.evaluate(() => {\n        // @ts-expect-error This is the point of the test.\n        return delete window.MutationObserver;\n      });\n      const [handle] = await Promise.all([\n        page.waitForSelector('aria/anything'),\n        page.setContent(`<h1>anything</h1>`),\n      ]);\n      assert(handle);\n      expect(\n        await page.evaluate(x => {\n          return x.textContent;\n        }, handle)\n      ).toBe('anything');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve promise when node is added","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":299,"column":49},"line":299,"code":"    it('should resolve promise when node is added', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const watchdog = frame.waitForSelector('aria/[role=\"heading\"]');\n      await frame.evaluate(addElement, 'br');\n      await frame.evaluate(addElement, 'h1');\n      const elementHandle = (await watchdog)!;\n      const tagName = await (\n        await elementHandle.getProperty('tagName')\n      ).jsonValue();\n      expect(tagName).toBe('H1');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work when node is added through innerHTML","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":314,"column":56},"line":314,"code":"    it('should work when node is added through innerHTML', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const watchdog = page.waitForSelector('aria/name');\n      await page.evaluate(addElement, 'span');\n      await page.evaluate(() => {\n        return (document.querySelector('span')!.innerHTML =\n          '<h3><div aria-label=\"name\"></div></h3>');\n      });\n      await watchdog;\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"Page.waitForSelector is shortcut for main frame","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":327,"column":55},"line":327,"code":"    it('Page.waitForSelector is shortcut for main frame', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const otherFrame = page.frames()[1];\n      const watchdog = page.waitForSelector('aria/[role=\"button\"]');\n      await otherFrame!.evaluate(addElement, 'button');\n      await page.evaluate(addElement, 'button');\n      const elementHandle = await watchdog;\n      expect(elementHandle!.frame).toBe(page.mainFrame());\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should run in specified frame","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":340,"column":37},"line":340,"code":"    it('should run in specified frame', async () => {\n      const {page, server} = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame2', server.EMPTY_PAGE);\n      const frame1 = page.frames()[1];\n      const frame2 = page.frames()[2];\n      const waitForSelectorPromise = frame2!.waitForSelector(\n        'aria/[role=\"button\"]'\n      );\n      await frame1!.evaluate(addElement, 'button');\n      await frame2!.evaluate(addElement, 'button');\n      const elementHandle = await waitForSelectorPromise;\n      expect(elementHandle!.frame).toBe(frame2);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when frame is detached","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":356,"column":43},"line":356,"code":"    it('should throw when frame is detached', async () => {\n      const {page, server} = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const frame = page.frames()[1];\n      let waitError!: Error;\n      const waitPromise = frame!\n        .waitForSelector('aria/does-not-exist')\n        .catch(error => {\n          return (waitError = error);\n        });\n      await utils.detachFrame(page, 'frame1');\n      await waitPromise;\n      expect(waitError).toBeTruthy();\n      expect(waitError.message).toContain(\n        'waitForFunction failed: frame got detached.'\n      );\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":375,"column":47},"line":375,"code":"    it('should survive cross-process navigation', async () => {\n      const {page, server} = getTestState();\n\n      let imgFound = false;\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"img\"]')\n        .then(() => {\n          return (imgFound = true);\n        });\n      await page.goto(server.EMPTY_PAGE);\n      expect(imgFound).toBe(false);\n      await page.reload();\n      expect(imgFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      await waitForSelector;\n      expect(imgFound).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":393,"column":31},"line":393,"code":"    it('should wait for visible', async () => {\n      const {page} = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page\n        .waitForSelector('aria/name', {visible: true})\n        .then(() => {\n          return (divFound = true);\n        });\n      await page.setContent(\n        `<div aria-label='name' style='display: none; visibility: hidden;'>1</div>`\n      );\n      expect(divFound).toBe(false);\n      await page.evaluate(() => {\n        return document.querySelector('div')!.style.removeProperty('display');\n      });\n      expect(divFound).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')!\n          .style.removeProperty('visibility');\n      });\n      expect(await waitForSelector).toBe(true);\n      expect(divFound).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for visible recursively","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":419,"column":43},"line":419,"code":"    it('should wait for visible recursively', async () => {\n      const {page} = getTestState();\n\n      let divVisible = false;\n      const waitForSelector = page\n        .waitForSelector('aria/inner', {visible: true})\n        .then(() => {\n          return (divVisible = true);\n        });\n      await page.setContent(\n        `<div style='display: none; visibility: hidden;'><div aria-label=\"inner\">hi</div></div>`\n      );\n      expect(divVisible).toBe(false);\n      await page.evaluate(() => {\n        return document.querySelector('div')!.style.removeProperty('display');\n      });\n      expect(divVisible).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')!\n          .style.removeProperty('visibility');\n      });\n      expect(await waitForSelector).toBe(true);\n      expect(divVisible).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for visibility: hidden","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":445,"column":49},"line":445,"code":"    it('hidden should wait for visibility: hidden', async () => {\n      const {page} = getTestState();\n\n      let divHidden = false;\n      await page.setContent(\n        `<div role='button' style='display: block;'>text</div>`\n      );\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"button\"]', {hidden: true})\n        .then(() => {\n          return (divHidden = true);\n        });\n      await page.waitForSelector('aria/[role=\"button\"]'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')!\n          .style.setProperty('visibility', 'hidden');\n      });\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for display: none","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":468,"column":44},"line":468,"code":"    it('hidden should wait for display: none', async () => {\n      const {page} = getTestState();\n\n      let divHidden = false;\n      await page.setContent(\n        `<div role='main' style='display: block;'>text</div>`\n      );\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"main\"]', {hidden: true})\n        .then(() => {\n          return (divHidden = true);\n        });\n      await page.waitForSelector('aria/[role=\"main\"]'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')!\n          .style.setProperty('display', 'none');\n      });\n      expect(await waitForSelector).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for removal","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":491,"column":38},"line":491,"code":"    it('hidden should wait for removal', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div role='main'>text</div>`);\n      let divRemoved = false;\n      const waitForSelector = page\n        .waitForSelector('aria/[role=\"main\"]', {hidden: true})\n        .then(() => {\n          return (divRemoved = true);\n        });\n      await page.waitForSelector('aria/[role=\"main\"]'); // do a round trip\n      expect(divRemoved).toBe(false);\n      await page.evaluate(() => {\n        return document.querySelector('div')!.remove();\n      });\n      expect(await waitForSelector).toBe(true);\n      expect(divRemoved).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return null if waiting to hide non-existing element","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":510,"column":66},"line":510,"code":"    it('should return null if waiting to hide non-existing element', async () => {\n      const {page} = getTestState();\n\n      const handle = await page.waitForSelector('aria/non-existing', {\n        hidden: true,\n      });\n      expect(handle).toBe(null);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":519,"column":30},"line":519,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      const error = await page\n        .waitForSelector('aria/[role=\"button\"]', {\n          timeout: 10,\n        })\n        .catch(error => {\n          return error;\n        });\n      expect(error.message).toContain(\n        'Waiting for selector `[role=\"button\"]` failed: Waiting failed: 10ms exceeded'\n      );\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should have an error message specifically for awaiting an element to be hidden","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":535,"column":86},"line":535,"code":"    it('should have an error message specifically for awaiting an element to be hidden', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div role='main'>text</div>`);\n      const promise = page.waitForSelector('aria/[role=\"main\"]', {\n        hidden: true,\n        timeout: 10,\n      });\n      await expect(promise).rejects.toMatchObject({\n        message:\n          'Waiting for selector `[role=\"main\"]` failed: Waiting failed: 10ms exceeded',\n      });\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should respond to node attribute mutation","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":549,"column":49},"line":549,"code":"    it('should respond to node attribute mutation', async () => {\n      const {page} = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page.waitForSelector('aria/zombo').then(() => {\n        return (divFound = true);\n      });\n      await page.setContent(`<div aria-label='notZombo'></div>`);\n      expect(divFound).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')!\n          .setAttribute('aria-label', 'zombo');\n      });\n      expect(await waitForSelector).toBe(true);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":566,"column":40},"line":566,"code":"    it('should return the element handle', async () => {\n      const {page} = getTestState();\n\n      const waitForSelector = page.waitForSelector('aria/zombo');\n      await page.setContent(`<div aria-label='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, await waitForSelector)\n      ).toBe('anything');\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should have correct stack trace for timeout","suites":["AriaQueryHandler","waitForSelector (aria)"],"updatePoint":{"line":578,"column":51},"line":578,"code":"    it('should have correct stack trace for timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.waitForSelector('aria/zombo', {timeout: 10}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error!.stack).toContain(\n        'Waiting for selector `zombo` failed: Waiting failed: 10ms exceeded'\n      );\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name \"foo\"","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":649,"column":33},"line":649,"code":"    it('should find by name \"foo\"', async () => {\n      const {page} = getTestState();\n      const found = await page.$$('aria/foo');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node3', 'node5', 'node6']);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by name \"bar\"","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":655,"column":33},"line":655,"code":"    it('should find by name \"bar\"', async () => {\n      const {page} = getTestState();\n      const found = await page.$$('aria/bar');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node1', 'node2', 'node8']);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find treeitem by name","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":661,"column":36},"line":661,"code":"    it('should find treeitem by name', async () => {\n      const {page} = getTestState();\n      const found = await page.$$('aria/item1 item2 item3');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['node30']);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by role \"button\"","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":667,"column":36},"line":667,"code":"    it('should find by role \"button\"', async () => {\n      const {page} = getTestState();\n      const found = (await page.$$('aria/[role=\"button\"]')) as Array<\n        ElementHandle<HTMLButtonElement>\n      >;\n      const ids = await getIds(found);\n      expect(ids).toEqual([\n        'node5',\n        'node6',\n        'node7',\n        'node8',\n        'node10',\n        'node21',\n      ]);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find by role \"heading\"","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":682,"column":37},"line":682,"code":"    it('should find by role \"heading\"', async () => {\n      const {page} = getTestState();\n      const found = await page.$$('aria/[role=\"heading\"]');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['shown', 'hidden', 'node11', 'node13']);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find both ignored and unignored","suites":["AriaQueryHandler","queryOne (Chromium web test)"],"updatePoint":{"line":688,"column":46},"line":688,"code":"    it('should find both ignored and unignored', async () => {\n      const {page} = getTestState();\n      const found = await page.$$('aria/title');\n      const ids = await getIds(found);\n      expect(ids).toEqual(['shown']);\n    });","file":"src/ariaqueryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["WebDriver BiDi","Connection"],"updatePoint":{"line":36,"column":19},"line":36,"code":"    it('should work', async () => {\n      const transport = new TestConnectionTransport();\n      const connection = new Connection(transport);\n      const responsePromise = connection.send('session.status', {\n        context: 'context',\n      });\n      expect(transport.sent).toEqual([\n        `{\"id\":1,\"method\":\"session.status\",\"params\":{\"context\":\"context\"}}`,\n      ]);\n      const id = JSON.parse(transport.sent[0]!).id;\n      const rawResponse = {\n        id,\n        result: {ready: false, message: 'already connected'},\n      };\n      (transport as ConnectionTransport).onmessage?.(\n        JSON.stringify(rawResponse)\n      );\n      const response = await responsePromise;\n      expect(response).toEqual(rawResponse);\n      connection.dispose();\n      expect(transport.closed).toBeTruthy();\n    });","file":"src/bidi/Connection.spec.ts","skipped":false,"dir":"test"},{"name":"should return whether we are in headless","suites":["Browser specs","Browser.version"],"updatePoint":{"line":24,"column":48},"line":24,"code":"    it('should return whether we are in headless', async () => {\n      const {browser, isHeadless, headless} = getTestState();\n\n      const version = await browser.version();\n      expect(version.length).toBeGreaterThan(0);\n      expect(version.startsWith('Headless')).toBe(\n        isHeadless && headless !== 'new'\n      );\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should include WebKit","suites":["Browser specs","Browser.userAgent"],"updatePoint":{"line":36,"column":29},"line":36,"code":"    it('should include WebKit', async () => {\n      const {browser, isChrome} = getTestState();\n\n      const userAgent = await browser.userAgent();\n      expect(userAgent.length).toBeGreaterThan(0);\n      if (isChrome) {\n        expect(userAgent).toContain('WebKit');\n      } else {\n        expect(userAgent).toContain('Gecko');\n      }\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should return browser target","suites":["Browser specs","Browser.target"],"updatePoint":{"line":50,"column":36},"line":50,"code":"    it('should return browser target', async () => {\n      const {browser} = getTestState();\n\n      const target = browser.target();\n      expect(target.type()).toBe('browser');\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should return child_process instance","suites":["Browser specs","Browser.process"],"updatePoint":{"line":59,"column":44},"line":59,"code":"    it('should return child_process instance', async () => {\n      const {browser} = getTestState();\n\n      const process = await browser.process();\n      expect(process!.pid).toBeGreaterThan(0);\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should not return child_process for remote browser","suites":["Browser specs","Browser.process"],"updatePoint":{"line":65,"column":58},"line":65,"code":"    it('should not return child_process for remote browser', async () => {\n      const {browser, puppeteer} = getTestState();\n\n      const browserWSEndpoint = browser.wsEndpoint();\n      const remoteBrowser = await puppeteer.connect({\n        browserWSEndpoint,\n      });\n      expect(remoteBrowser.process()).toBe(null);\n      remoteBrowser.disconnect();\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should set the browser connected state","suites":["Browser specs","Browser.isConnected"],"updatePoint":{"line":78,"column":46},"line":78,"code":"    it('should set the browser connected state', async () => {\n      const {browser, puppeteer} = getTestState();\n\n      const browserWSEndpoint = browser.wsEndpoint();\n      const newBrowser = await puppeteer.connect({\n        browserWSEndpoint,\n      });\n      expect(newBrowser.isConnected()).toBe(true);\n      newBrowser.disconnect();\n      expect(newBrowser.isConnected()).toBe(false);\n    });","file":"src/browser.spec.ts","skipped":false,"dir":"test"},{"name":"should have default context","suites":["BrowserContext"],"updatePoint":{"line":24,"column":33},"line":24,"code":"  it('should have default context', async () => {\n    const {browser} = getTestState();\n    expect(browser.browserContexts().length).toEqual(1);\n    const defaultContext = browser.browserContexts()[0]!;\n    expect(defaultContext!.isIncognito()).toBe(false);\n    let error!: Error;\n    await defaultContext!.close().catch(error_ => {\n      return (error = error_);\n    });\n    expect(browser.defaultBrowserContext()).toBe(defaultContext);\n    expect(error.message).toContain('cannot be closed');\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should create new incognito context","suites":["BrowserContext"],"updatePoint":{"line":36,"column":41},"line":36,"code":"  it('should create new incognito context', async () => {\n    const {browser} = getTestState();\n\n    expect(browser.browserContexts().length).toBe(1);\n    const context = await browser.createIncognitoBrowserContext();\n    expect(context.isIncognito()).toBe(true);\n    expect(browser.browserContexts().length).toBe(2);\n    expect(browser.browserContexts().indexOf(context) !== -1).toBe(true);\n    await context.close();\n    expect(browser.browserContexts().length).toBe(1);\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should close all belonging targets once closing context","suites":["BrowserContext"],"updatePoint":{"line":47,"column":61},"line":47,"code":"  it('should close all belonging targets once closing context', async () => {\n    const {browser} = getTestState();\n\n    expect((await browser.pages()).length).toBe(1);\n\n    const context = await browser.createIncognitoBrowserContext();\n    await context.newPage();\n    expect((await browser.pages()).length).toBe(2);\n    expect((await context.pages()).length).toBe(1);\n\n    await context.close();\n    expect((await browser.pages()).length).toBe(1);\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"window.open should use parent tab context","suites":["BrowserContext"],"updatePoint":{"line":60,"column":47},"line":60,"code":"  it('window.open should use parent tab context', async () => {\n    const {browser, server} = getTestState();\n\n    const context = await browser.createIncognitoBrowserContext();\n    const page = await context.newPage();\n    await page.goto(server.EMPTY_PAGE);\n    const [popupTarget] = await Promise.all([\n      waitEvent(browser, 'targetcreated'),\n      page.evaluate(url => {\n        return window.open(url);\n      }, server.EMPTY_PAGE),\n    ]);\n    expect(popupTarget.browserContext()).toBe(context);\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should fire target events","suites":["BrowserContext"],"updatePoint":{"line":75,"column":31},"line":75,"code":"  it('should fire target events', async () => {\n    const {browser, server} = getTestState();\n\n    const context = await browser.createIncognitoBrowserContext();\n    const events: any[] = [];\n    context.on('targetcreated', target => {\n      return events.push('CREATED: ' + target.url());\n    });\n    context.on('targetchanged', target => {\n      return events.push('CHANGED: ' + target.url());\n    });\n    context.on('targetdestroyed', target => {\n      return events.push('DESTROYED: ' + target.url());\n    });\n    const page = await context.newPage();\n    await page.goto(server.EMPTY_PAGE);\n    await page.close();\n    expect(events).toEqual([\n      'CREATED: about:blank',\n      `CHANGED: ${server.EMPTY_PAGE}`,\n      `DESTROYED: ${server.EMPTY_PAGE}`,\n    ]);\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for a target","suites":["BrowserContext"],"updatePoint":{"line":99,"column":30},"line":99,"code":"  it('should wait for a target', async () => {\n    const {browser, server} = getTestState();\n\n    const context = await browser.createIncognitoBrowserContext();\n    let resolved = false;\n\n    const targetPromise = context.waitForTarget(target => {\n      return target.url() === server.EMPTY_PAGE;\n    });\n    targetPromise\n      .then(() => {\n        return (resolved = true);\n      })\n      .catch(error => {\n        resolved = true;\n        if (error instanceof TimeoutError) {\n          console.error(error);\n        } else {\n          throw error;\n        }\n      });\n    const page = await context.newPage();\n    expect(resolved).toBe(false);\n    await page.goto(server.EMPTY_PAGE);\n    try {\n      const target = await targetPromise;\n      expect(await target.page()).toBe(page);\n    } catch (error) {\n      if (error instanceof TimeoutError) {\n        console.error(error);\n      } else {\n        throw error;\n      }\n    }\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should timeout waiting for a non-existent target","suites":["BrowserContext"],"updatePoint":{"line":136,"column":54},"line":136,"code":"  it('should timeout waiting for a non-existent target', async () => {\n    const {browser, server} = getTestState();\n\n    const context = await browser.createIncognitoBrowserContext();\n    const error = await context\n      .waitForTarget(\n        target => {\n          return target.url() === server.EMPTY_PAGE;\n        },\n        {\n          timeout: 1,\n        }\n      )\n      .catch(error_ => {\n        return error_;\n      });\n    expect(error).toBeInstanceOf(TimeoutError);\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should isolate localStorage and cookies","suites":["BrowserContext"],"updatePoint":{"line":156,"column":45},"line":156,"code":"  it('should isolate localStorage and cookies', async () => {\n    const {browser, server} = getTestState();\n\n    // Create two incognito contexts.\n    const context1 = await browser.createIncognitoBrowserContext();\n    const context2 = await browser.createIncognitoBrowserContext();\n    expect(context1.targets().length).toBe(0);\n    expect(context2.targets().length).toBe(0);\n\n    // Create a page in first incognito context.\n    const page1 = await context1.newPage();\n    await page1.goto(server.EMPTY_PAGE);\n    await page1.evaluate(() => {\n      localStorage.setItem('name', 'page1');\n      document.cookie = 'name=page1';\n    });\n\n    expect(context1.targets().length).toBe(1);\n    expect(context2.targets().length).toBe(0);\n\n    // Create a page in second incognito context.\n    const page2 = await context2.newPage();\n    await page2.goto(server.EMPTY_PAGE);\n    await page2.evaluate(() => {\n      localStorage.setItem('name', 'page2');\n      document.cookie = 'name=page2';\n    });\n\n    expect(context1.targets().length).toBe(1);\n    expect(context1.targets()[0]!).toBe(page1.target());\n    expect(context2.targets().length).toBe(1);\n    expect(context2.targets()[0]!).toBe(page2.target());\n\n    // Make sure pages don't share localstorage or cookies.\n    expect(\n      await page1.evaluate(() => {\n        return localStorage.getItem('name');\n      })\n    ).toBe('page1');\n    expect(\n      await page1.evaluate(() => {\n        return document.cookie;\n      })\n    ).toBe('name=page1');\n    expect(\n      await page2.evaluate(() => {\n        return localStorage.getItem('name');\n      })\n    ).toBe('page2');\n    expect(\n      await page2.evaluate(() => {\n        return document.cookie;\n      })\n    ).toBe('name=page2');\n\n    // Cleanup contexts.\n    await Promise.all([context1.close(), context2.close()]);\n    expect(browser.browserContexts().length).toBe(1);\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should work across sessions","suites":["BrowserContext"],"updatePoint":{"line":216,"column":33},"line":216,"code":"  it('should work across sessions', async () => {\n    const {browser, puppeteer} = getTestState();\n\n    expect(browser.browserContexts().length).toBe(1);\n    const context = await browser.createIncognitoBrowserContext();\n    expect(browser.browserContexts().length).toBe(2);\n    const remoteBrowser = await puppeteer.connect({\n      browserWSEndpoint: browser.wsEndpoint(),\n    });\n    const contexts = remoteBrowser.browserContexts();\n    expect(contexts.length).toBe(2);\n    remoteBrowser.disconnect();\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should provide a context id","suites":["BrowserContext"],"updatePoint":{"line":231,"column":33},"line":231,"code":"  it('should provide a context id', async () => {\n    const {browser} = getTestState();\n\n    expect(browser.browserContexts().length).toBe(1);\n    expect(browser.browserContexts()[0]!.id).toBeUndefined();\n\n    const context = await browser.createIncognitoBrowserContext();\n    expect(browser.browserContexts().length).toBe(2);\n    expect(browser.browserContexts()[1]!.id).toBeDefined();\n    await context.close();\n  });","file":"src/browsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Target.createCDPSession"],"updatePoint":{"line":30,"column":17},"line":30,"code":"  it('should work', async () => {\n    const {page} = getTestState();\n\n    const client = await page.target().createCDPSession();\n\n    await Promise.all([\n      client.send('Runtime.enable'),\n      client.send('Runtime.evaluate', {expression: 'window.foo = \"bar\"'}),\n    ]);\n    const foo = await page.evaluate(() => {\n      return (globalThis as any).foo;\n    });\n    expect(foo).toBe('bar');\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should not report created targets for custom CDP sessions","suites":["Target.createCDPSession"],"updatePoint":{"line":45,"column":63},"line":45,"code":"  it('should not report created targets for custom CDP sessions', async () => {\n    const {browser} = getTestState();\n    let called = 0;\n    browser.browserContexts()[0]!.on('targetcreated', async target => {\n      called++;\n      if (called > 1) {\n        throw new Error('Too many targets created');\n      }\n      await target.createCDPSession();\n    });\n    await browser.newPage();\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should send events","suites":["Target.createCDPSession"],"updatePoint":{"line":58,"column":24},"line":58,"code":"  it('should send events', async () => {\n    const {page, server} = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Network.enable');\n    const events = [];\n    client.on('Network.requestWillBeSent', event => {\n      return events.push(event);\n    });\n    await Promise.all([\n      waitEvent(client, 'Network.requestWillBeSent'),\n      page.goto(server.EMPTY_PAGE),\n    ]);\n    expect(events.length).toBe(1);\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should enable and disable domains independently","suites":["Target.createCDPSession"],"updatePoint":{"line":73,"column":53},"line":73,"code":"  it('should enable and disable domains independently', async () => {\n    const {page} = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Runtime.enable');\n    await client.send('Debugger.enable');\n    // JS coverage enables and then disables Debugger domain.\n    await page.coverage.startJSCoverage();\n    await page.coverage.stopJSCoverage();\n    // generate a script in page and wait for the event.\n    const [event] = await Promise.all([\n      waitEvent(client, 'Debugger.scriptParsed'),\n      page.evaluate('//# sourceURL=foo.js'),\n    ]);\n    // expect events to be dispatched.\n    expect(event.url).toBe('foo.js');\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to detach session","suites":["Target.createCDPSession"],"updatePoint":{"line":90,"column":38},"line":90,"code":"  it('should be able to detach session', async () => {\n    const {page} = getTestState();\n\n    const client = await page.target().createCDPSession();\n    await client.send('Runtime.enable');\n    const evalResponse = await client.send('Runtime.evaluate', {\n      expression: '1 + 2',\n      returnByValue: true,\n    });\n    expect(evalResponse.result.value).toBe(3);\n    await client.detach();\n    let error!: Error;\n    try {\n      await client.send('Runtime.evaluate', {\n        expression: '3 + 1',\n        returnByValue: true,\n      });\n    } catch (error_) {\n      if (isErrorLike(error_)) {\n        error = error_ as Error;\n      }\n    }\n    expect(error.message).toContain('Session closed.');\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should throw nice errors","suites":["Target.createCDPSession"],"updatePoint":{"line":114,"column":30},"line":114,"code":"  it('should throw nice errors', async () => {\n    const {page} = getTestState();\n\n    const client = await page.target().createCDPSession();\n    const error = await theSourceOfTheProblems().catch(error => {\n      return error;\n    });\n    expect(error.stack).toContain('theSourceOfTheProblems');\n    expect(error.message).toContain('ThisCommand.DoesNotExist');\n\n    async function theSourceOfTheProblems() {\n      // @ts-expect-error This fails in TS as it knows that command does not\n      // exist but we want to have this tests for our users who consume in JS\n      // not TS.\n      await client.send('ThisCommand.DoesNotExist');\n    }\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should expose the underlying connection","suites":["Target.createCDPSession"],"updatePoint":{"line":132,"column":45},"line":132,"code":"  it('should expose the underlying connection', async () => {\n    const {page} = getTestState();\n\n    const client = await page.target().createCDPSession();\n    expect(client.connection()).toBeTruthy();\n  });","file":"src/CDPSession.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect using browserUrl, with and without trailing slash","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |browserURL| option"],"updatePoint":{"line":26,"column":83},"line":26,"code":"    it('should be able to connect using browserUrl, with and without trailing slash', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:21222';\n\n      const browser1 = await puppeteer.connect({browserURL});\n      const page1 = await browser1.newPage();\n      expect(\n        await page1.evaluate(() => {\n          return 7 * 8;\n        })\n      ).toBe(56);\n      browser1.disconnect();\n\n      const browser2 = await puppeteer.connect({\n        browserURL: browserURL + '/',\n      });\n      const page2 = await browser2.newPage();\n      expect(\n        await page2.evaluate(() => {\n          return 8 * 7;\n        })\n      ).toBe(56);\n      browser2.disconnect();\n      originalBrowser.close();\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when using both browserWSEndpoint and browserURL","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |browserURL| option"],"updatePoint":{"line":57,"column":69},"line":57,"code":"    it('should throw when using both browserWSEndpoint and browserURL', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:21222';\n\n      let error!: Error;\n      await puppeteer\n        .connect({\n          browserURL,\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain(\n        'Exactly one of browserWSEndpoint, browserURL or transport'\n      );\n\n      originalBrowser.close();\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when trying to connect to non-existing browser","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |browserURL| option"],"updatePoint":{"line":82,"column":67},"line":82,"code":"    it('should throw when trying to connect to non-existing browser', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n\n      const originalBrowser = await puppeteer.launch(\n        Object.assign({}, defaultBrowserOptions, {\n          args: ['--remote-debugging-port=21222'],\n        })\n      );\n      const browserURL = 'http://127.0.0.1:32333';\n\n      let error!: Error;\n      await puppeteer.connect({browserURL}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain(\n        'Failed to fetch browser webSocket URL from'\n      );\n      originalBrowser.close();\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should support the pipe option","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |pipe| option"],"updatePoint":{"line":104,"column":38},"line":104,"code":"    it('should support the pipe option', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n      const options = Object.assign({pipe: true}, defaultBrowserOptions);\n      const browser = await puppeteer.launch(options);\n      expect((await browser.pages()).length).toBe(1);\n      expect(browser.wsEndpoint()).toBe('');\n      const page = await browser.newPage();\n      expect(await page.evaluate('11 * 11')).toBe(121);\n      await page.close();\n      await browser.close();\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should support the pipe argument","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |pipe| option"],"updatePoint":{"line":115,"column":40},"line":115,"code":"    it('should support the pipe argument', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n      const options = Object.assign({}, defaultBrowserOptions);\n      options.args = ['--remote-debugging-pipe'].concat(options.args || []);\n      const browser = await puppeteer.launch(options);\n      expect(browser.wsEndpoint()).toBe('');\n      const page = await browser.newPage();\n      expect(await page.evaluate('11 * 11')).toBe(121);\n      await page.close();\n      await browser.close();\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should fire \"disconnected\" when closing with pipe","suites":["Chromium-Specific Launcher tests","Puppeteer.launch |pipe| option"],"updatePoint":{"line":126,"column":57},"line":126,"code":"    it('should fire \"disconnected\" when closing with pipe', async () => {\n      const {defaultBrowserOptions, puppeteer} = getTestState();\n      const options = Object.assign({pipe: true}, defaultBrowserOptions);\n      const browser = await puppeteer.launch(options);\n      const disconnectedEventPromise = new Promise(resolve => {\n        return browser.once('disconnected', resolve);\n      });\n      // Emulate user exiting browser.\n      browser.process()!.kill();\n      await disconnectedEventPromise;\n    });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"Page.setRequestInterception should work with intervention headers","suites":["Chromium-Specific Page Tests"],"updatePoint":{"line":143,"column":71},"line":143,"code":"  it('Page.setRequestInterception should work with intervention headers', async () => {\n    const {server, page} = getTestState();\n\n    server.setRoute('/intervention', (_req, res) => {\n      return res.end(`\n        <script>\n          document.write('<script src=\"${server.CROSS_PROCESS_PREFIX}/intervention.js\">' + '</scr' + 'ipt>');\n        </script>\n      `);\n    });\n    server.setRedirect('/intervention.js', '/redirect.js');\n    let serverRequest: IncomingMessage | undefined;\n    server.setRoute('/redirect.js', (req, res) => {\n      serverRequest = req;\n      res.end('console.log(1);');\n    });\n\n    await page.setRequestInterception(true);\n    page.on('request', request => {\n      return request.continue();\n    });\n    await page.goto(server.PREFIX + '/intervention');\n    // Check for feature URL substring rather than https://www.chromestatus.com to\n    // make it work with Edgium.\n    expect(serverRequest!.headers['intervention']).toContain(\n      'feature/5718547946799104'\n    );\n  });","file":"src/chromiumonly.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button","suites":["Page.click"],"updatePoint":{"line":29,"column":29},"line":29,"code":"  it('should click the button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click svg","suites":["Page.click"],"updatePoint":{"line":40,"column":22},"line":40,"code":"  it('should click svg', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(`\n        <svg height=\"100\" width=\"100\">\n          <circle onclick=\"javascript:window.__CLICKED=42\" cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n        </svg>\n      `);\n    await page.click('circle');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).__CLICKED;\n      })\n    ).toBe(42);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button if window.Node is removed","suites":["Page.click"],"updatePoint":{"line":55,"column":55},"line":55,"code":"  it('should click the button if window.Node is removed', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.evaluate(() => {\n      // @ts-expect-error Expected.\n      return delete window.Node;\n    });\n    await page.click('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click on a span with an inline element inside","suites":["Page.click"],"updatePoint":{"line":71,"column":58},"line":71,"code":"  it('should click on a span with an inline element inside', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(`\n        <style>\n        span::before {\n          content: 'q';\n        }\n        </style>\n        <span onclick='javascript:window.CLICKED=42'></span>\n      `);\n    await page.click('span');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).CLICKED;\n      })\n    ).toBe(42);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw UnhandledPromiseRejection when page closes","suites":["Page.click"],"updatePoint":{"line":89,"column":65},"line":89,"code":"  it('should not throw UnhandledPromiseRejection when page closes', async () => {\n    const {page} = getTestState();\n\n    const newPage = await page.browser().newPage();\n    await Promise.all([newPage.close(), newPage.mouse.click(1, 2)]).catch(\n      () => {}\n    );\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button after navigation ","suites":["Page.click"],"updatePoint":{"line":97,"column":47},"line":97,"code":"  it('should click the button after navigation ', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.click('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click with disabled javascript","suites":["Page.click"],"updatePoint":{"line":110,"column":43},"line":110,"code":"  it('should click with disabled javascript', async () => {\n    const {page, server} = getTestState();\n\n    await page.setJavaScriptEnabled(false);\n    await page.goto(server.PREFIX + '/wrappedlink.html');\n    await Promise.all([page.click('a'), page.waitForNavigation()]);\n    expect(page.url()).toBe(server.PREFIX + '/wrappedlink.html#clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click when one of inline box children is outside of viewport","suites":["Page.click"],"updatePoint":{"line":118,"column":73},"line":118,"code":"  it('should click when one of inline box children is outside of viewport', async () => {\n    const {page} = getTestState();\n\n    await page.setContent(`\n        <style>\n        i {\n          position: absolute;\n          top: -1000px;\n        }\n        </style>\n        <span onclick='javascript:window.CLICKED = 42;'><i>woof</i><b>doggo</b></span>\n      `);\n    await page.click('span');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).CLICKED;\n      })\n    ).toBe(42);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should select the text by triple clicking","suites":["Page.click"],"updatePoint":{"line":137,"column":47},"line":137,"code":"  it('should select the text by triple clicking', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    const text =\n      \"This is the text that we are going to try to select. Let's see how it goes.\";\n    await page.keyboard.type(text);\n    await page.click('textarea');\n    await page.click('textarea', {clickCount: 2});\n    await page.click('textarea', {clickCount: 3});\n    expect(\n      await page.evaluate(() => {\n        const textarea = document.querySelector('textarea');\n        return textarea!.value.substring(\n          textarea!.selectionStart,\n          textarea!.selectionEnd\n        );\n      })\n    ).toBe(text);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click offscreen buttons","suites":["Page.click"],"updatePoint":{"line":158,"column":36},"line":158,"code":"  it('should click offscreen buttons', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/offscreenbuttons.html');\n    const messages: any[] = [];\n    page.on('console', msg => {\n      if (msg.type() === 'log') {\n        return messages.push(msg.text());\n      }\n      return;\n    });\n    for (let i = 0; i < 11; ++i) {\n      // We might've scrolled to click a button - reset to (0, 0).\n      await page.evaluate(() => {\n        return window.scrollTo(0, 0);\n      });\n      await page.click(`#btn${i}`);\n    }\n    expect(messages).toEqual([\n      'button #0 clicked',\n      'button #1 clicked',\n      'button #2 clicked',\n      'button #3 clicked',\n      'button #4 clicked',\n      'button #5 clicked',\n      'button #6 clicked',\n      'button #7 clicked',\n      'button #8 clicked',\n      'button #9 clicked',\n      'button #10 clicked',\n    ]);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click wrapped links","suites":["Page.click"],"updatePoint":{"line":191,"column":32},"line":191,"code":"  it('should click wrapped links', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/wrappedlink.html');\n    await page.click('a');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).__clicked;\n      })\n    ).toBe(true);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click on checkbox input and toggle","suites":["Page.click"],"updatePoint":{"line":203,"column":47},"line":203,"code":"  it('should click on checkbox input and toggle', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/checkbox.html');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(null);\n    await page.click('input#agree');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.events;\n      })\n    ).toEqual([\n      'mouseover',\n      'mouseenter',\n      'mousemove',\n      'mousedown',\n      'mouseup',\n      'click',\n      'input',\n      'change',\n    ]);\n    await page.click('input#agree');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(false);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click on checkbox label and toggle","suites":["Page.click"],"updatePoint":{"line":240,"column":47},"line":240,"code":"  it('should click on checkbox label and toggle', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/checkbox.html');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(null);\n    await page.click('label[for=\"agree\"]');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.events;\n      })\n    ).toEqual(['click', 'input', 'change']);\n    await page.click('label[for=\"agree\"]');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result.check;\n      })\n    ).toBe(false);\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should fail to click a missing button","suites":["Page.click"],"updatePoint":{"line":268,"column":43},"line":268,"code":"  it('should fail to click a missing button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    let error!: Error;\n    await page.click('button.does-not-exist').catch(error_ => {\n      return (error = error_);\n    });\n    expect(error.message).toBe(\n      'No element found for selector: button.does-not-exist'\n    );\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang with touch-enabled viewports","suites":["Page.click"],"updatePoint":{"line":281,"column":50},"line":281,"code":"  it('should not hang with touch-enabled viewports', async () => {\n    const {page} = getTestState();\n\n    await page.setViewport(KnownDevices['iPhone 6'].viewport);\n    await page.mouse.down();\n    await page.mouse.move(100, 10);\n    await page.mouse.up();\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should scroll and click the button","suites":["Page.click"],"updatePoint":{"line":289,"column":40},"line":289,"code":"  it('should scroll and click the button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-5');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-5')!.textContent;\n      })\n    ).toBe('clicked');\n    await page.click('#button-80');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-80')!.textContent;\n      })\n    ).toBe('clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should double click the button","suites":["Page.click"],"updatePoint":{"line":306,"column":36},"line":306,"code":"  it('should double click the button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.evaluate(() => {\n      (globalThis as any).double = false;\n      const button = document.querySelector('button');\n      button!.addEventListener('dblclick', () => {\n        (globalThis as any).double = true;\n      });\n    });\n    const button = (await page.$('button'))!;\n    await button!.click({clickCount: 2});\n    expect(await page.evaluate('double')).toBe(true);\n    expect(await page.evaluate('result')).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click a partially obscured button","suites":["Page.click"],"updatePoint":{"line":322,"column":46},"line":322,"code":"  it('should click a partially obscured button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.evaluate(() => {\n      const button = document.querySelector('button');\n      button!.textContent = 'Some really long text that will go offscreen';\n      button!.style.position = 'absolute';\n      button!.style.left = '368px';\n    });\n    await page.click('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click a rotated button","suites":["Page.click"],"updatePoint":{"line":339,"column":35},"line":339,"code":"  it('should click a rotated button', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/rotatedButton.html');\n    await page.click('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should fire contextmenu event on right click","suites":["Page.click"],"updatePoint":{"line":350,"column":50},"line":350,"code":"  it('should fire contextmenu event on right click', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-8', {button: 'right'});\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-8')!.textContent;\n      })\n    ).toBe('context menu');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should fire aux event on middle click","suites":["Page.click"],"updatePoint":{"line":361,"column":43},"line":361,"code":"  it('should fire aux event on middle click', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-8', {button: 'middle'});\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-8')!.textContent;\n      })\n    ).toBe('aux click');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should fire back click","suites":["Page.click"],"updatePoint":{"line":372,"column":28},"line":372,"code":"  it('should fire back click', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-8', {button: 'back'});\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-8')!.textContent;\n      })\n    ).toBe('back click');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should fire forward click","suites":["Page.click"],"updatePoint":{"line":383,"column":31},"line":383,"code":"  it('should fire forward click', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.click('#button-8', {button: 'forward'});\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('#button-8')!.textContent;\n      })\n    ).toBe('forward click');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click links which cause navigation","suites":["Page.click"],"updatePoint":{"line":395,"column":47},"line":395,"code":"  it('should click links which cause navigation', async () => {\n    const {page, server} = getTestState();\n\n    await page.setContent(`<a href=\"${server.EMPTY_PAGE}\">empty.html</a>`);\n    // This await should not hang.\n    await page.click('a');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button inside an iframe","suites":["Page.click"],"updatePoint":{"line":402,"column":46},"line":402,"code":"  it('should click the button inside an iframe', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setContent('<div style=\"width:100px;height:100px\">spacer</div>');\n    await utils.attachFrame(\n      page,\n      'button-test',\n      server.PREFIX + '/input/button.html'\n    );\n    const frame = page.frames()[1];\n    const button = await frame!.$('button');\n    await button!.click();\n    expect(\n      await frame!.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should click the button with fixed position inside an iframe","suites":["Page.click"],"line":422,"code":"  it.skip('should click the button with fixed position inside an iframe', async () => {","file":"src/click.spec.ts","skipped":true,"dir":"test"},{"name":"should click the button with deviceScaleFactor set","suites":["Page.click"],"updatePoint":{"line":446,"column":56},"line":446,"code":"  it('should click the button with deviceScaleFactor set', async () => {\n    const {page, server} = getTestState();\n\n    await page.setViewport({width: 400, height: 400, deviceScaleFactor: 5});\n    expect(\n      await page.evaluate(() => {\n        return window.devicePixelRatio;\n      })\n    ).toBe(5);\n    await page.setContent('<div style=\"width:100px;height:100px\">spacer</div>');\n    await utils.attachFrame(\n      page,\n      'button-test',\n      server.PREFIX + '/input/button.html'\n    );\n    const frame = page.frames()[1];\n    const button = await frame!.$('button');\n    await button!.click();\n    expect(\n      await frame!.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/click.spec.ts","skipped":false,"dir":"test"},{"name":"should return no cookies in pristine browser context","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":29,"column":60},"line":29,"code":"    it('should return no cookies in pristine browser context', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      expectCookieEquals(await page.cookies(), []);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should get a cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":34,"column":27},"line":34,"code":"    it('should get a cookie', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        document.cookie = 'username=John Doe';\n      });\n\n      expectCookieEquals(await page.cookies(), [\n        {\n          name: 'username',\n          value: 'John Doe',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 16,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report httpOnly cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":57,"column":46},"line":57,"code":"    it('should properly report httpOnly cookie', async () => {\n      const {page, server} = getTestState();\n      server.setRoute('/empty.html', (_req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; HttpOnly; Path=/');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0]!.httpOnly).toBe(true);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report \"Strict\" sameSite cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":68,"column":55},"line":68,"code":"    it('should properly report \"Strict\" sameSite cookie', async () => {\n      const {page, server} = getTestState();\n      server.setRoute('/empty.html', (_req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; SameSite=Strict');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0]!.sameSite).toBe('Strict');\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should properly report \"Lax\" sameSite cookie","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":79,"column":52},"line":79,"code":"    it('should properly report \"Lax\" sameSite cookie', async () => {\n      const {page, server} = getTestState();\n      server.setRoute('/empty.html', (_req, res) => {\n        res.setHeader('Set-Cookie', 'a=b; SameSite=Lax');\n        res.end();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const cookies = await page.cookies();\n      expect(cookies.length).toBe(1);\n      expect(cookies[0]!.sameSite).toBe('Lax');\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should get multiple cookies","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":90,"column":35},"line":90,"code":"    it('should get multiple cookies', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        document.cookie = 'username=John Doe';\n        document.cookie = 'password=1234';\n      });\n      const cookies = await page.cookies();\n      cookies.sort((a, b) => {\n        return a.name.localeCompare(b.name);\n      });\n      expectCookieEquals(cookies, [\n        {\n          name: 'password',\n          value: '1234',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 12,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourceScheme: 'NonSecure',\n        },\n        {\n          name: 'username',\n          value: 'John Doe',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 16,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should get cookies from multiple urls","suites":["Cookie specs","Page.cookies"],"updatePoint":{"line":130,"column":45},"line":130,"code":"    it('should get cookies from multiple urls', async () => {\n      const {page} = getTestState();\n      await page.setCookie(\n        {\n          url: 'https://foo.com',\n          name: 'doggo',\n          value: 'woofs',\n        },\n        {\n          url: 'https://bar.com',\n          name: 'catto',\n          value: 'purrs',\n        },\n        {\n          url: 'https://baz.com',\n          name: 'birdo',\n          value: 'tweets',\n        }\n      );\n      const cookies = await page.cookies('https://foo.com', 'https://baz.com');\n      cookies.sort((a, b) => {\n        return a.name.localeCompare(b.name);\n      });\n      expectCookieEquals(cookies, [\n        {\n          name: 'birdo',\n          value: 'tweets',\n          domain: 'baz.com',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 11,\n          httpOnly: false,\n          secure: true,\n          session: true,\n          sourcePort: 443,\n          sourceScheme: 'Secure',\n        },\n        {\n          name: 'doggo',\n          value: 'woofs',\n          domain: 'foo.com',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 10,\n          httpOnly: false,\n          secure: true,\n          session: true,\n          sourcePort: 443,\n          sourceScheme: 'Secure',\n        },\n      ]);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":186,"column":19},"line":186,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({\n        name: 'password',\n        value: '123456',\n      });\n      expect(\n        await page.evaluate(() => {\n          return document.cookie;\n        })\n      ).toEqual('password=123456');\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should isolate cookies in browser contexts","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":200,"column":50},"line":200,"code":"    it('should isolate cookies in browser contexts', async () => {\n      const {page, server, browser} = getTestState();\n\n      const anotherContext = await browser.createIncognitoBrowserContext();\n      const anotherPage = await anotherContext.newPage();\n\n      await page.goto(server.EMPTY_PAGE);\n      await anotherPage.goto(server.EMPTY_PAGE);\n\n      await page.setCookie({name: 'page1cookie', value: 'page1value'});\n      await anotherPage.setCookie({name: 'page2cookie', value: 'page2value'});\n\n      const cookies1 = await page.cookies();\n      const cookies2 = await anotherPage.cookies();\n      expect(cookies1.length).toBe(1);\n      expect(cookies2.length).toBe(1);\n      expect(cookies1[0]!.name).toBe('page1cookie');\n      expect(cookies1[0]!.value).toBe('page1value');\n      expect(cookies2[0]!.name).toBe('page2cookie');\n      expect(cookies2[0]!.value).toBe('page2value');\n      await anotherContext.close();\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set multiple cookies","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":222,"column":35},"line":222,"code":"    it('should set multiple cookies', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie(\n        {\n          name: 'password',\n          value: '123456',\n        },\n        {\n          name: 'foo',\n          value: 'bar',\n        }\n      );\n      const cookieStrings = await page.evaluate(() => {\n        const cookies = document.cookie.split(';');\n        return cookies\n          .map(cookie => {\n            return cookie.trim();\n          })\n          .sort();\n      });\n\n      expect(cookieStrings).toEqual(['foo=bar', 'password=123456']);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should have |expires| set to |-1| for session cookies","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":247,"column":61},"line":247,"code":"    it('should have |expires| set to |-1| for session cookies', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({\n        name: 'password',\n        value: '123456',\n      });\n      const cookies = await page.cookies();\n      expect(cookies[0]!.session).toBe(true);\n      expect(cookies[0]!.expires).toBe(-1);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set cookie with reasonable defaults","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":259,"column":50},"line":259,"code":"    it('should set cookie with reasonable defaults', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({\n        name: 'password',\n        value: '123456',\n      });\n      const cookies = await page.cookies();\n      expectCookieEquals(\n        cookies.sort((a, b) => {\n          return a.name.localeCompare(b.name);\n        }),\n        [\n          {\n            name: 'password',\n            value: '123456',\n            domain: 'localhost',\n            path: '/',\n            sameParty: false,\n            expires: -1,\n            size: 14,\n            httpOnly: false,\n            secure: false,\n            session: true,\n            sourcePort: 80,\n            sourceScheme: 'NonSecure',\n          },\n        ]\n      );\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set a cookie with a path","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":290,"column":39},"line":290,"code":"    it('should set a cookie with a path', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/grid.html');\n      await page.setCookie({\n        name: 'gridcookie',\n        value: 'GRID',\n        path: '/grid.html',\n      });\n      expectCookieEquals(await page.cookies(), [\n        {\n          name: 'gridcookie',\n          value: 'GRID',\n          domain: 'localhost',\n          path: '/grid.html',\n          sameParty: false,\n          expires: -1,\n          size: 14,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 80,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n      expect(await page.evaluate('document.cookie')).toBe('gridcookie=GRID');\n      await page.goto(server.EMPTY_PAGE);\n      expectCookieEquals(await page.cookies(), []);\n      expect(await page.evaluate('document.cookie')).toBe('');\n      await page.goto(server.PREFIX + '/grid.html');\n      expect(await page.evaluate('document.cookie')).toBe('gridcookie=GRID');\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie on a blank page","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":322,"column":47},"line":322,"code":"    it('should not set a cookie on a blank page', async () => {\n      const {page} = getTestState();\n\n      await page.goto('about:blank');\n      let error!: Error;\n      try {\n        await page.setCookie({name: 'example-cookie', value: 'best'});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toContain(\n        'At least one of the url and domain needs to be specified'\n      );\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie with blank page URL","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":336,"column":51},"line":336,"code":"    it('should not set a cookie with blank page URL', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      await page.goto(server.EMPTY_PAGE);\n      try {\n        await page.setCookie(\n          {name: 'example-cookie', value: 'best'},\n          {url: 'about:blank', name: 'example-cookie-blank', value: 'best'}\n        );\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toEqual(\n        `Blank page can not have cookie \"example-cookie-blank\"`\n      );\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should not set a cookie on a data URL page","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":353,"column":50},"line":353,"code":"    it('should not set a cookie on a data URL page', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.goto('data:,Hello%2C%20World!');\n      try {\n        await page.setCookie({name: 'example-cookie', value: 'best'});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toContain(\n        'At least one of the url and domain needs to be specified'\n      );\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should default to setting secure cookie for HTTPS websites","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":367,"column":66},"line":367,"code":"    it('should default to setting secure cookie for HTTPS websites', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const SECURE_URL = 'https://example.com';\n      await page.setCookie({\n        url: SECURE_URL,\n        name: 'foo',\n        value: 'bar',\n      });\n      const [cookie] = await page.cookies(SECURE_URL);\n      expect(cookie!.secure).toBe(true);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to set insecure cookie for HTTP website","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":380,"column":62},"line":380,"code":"    it('should be able to set insecure cookie for HTTP website', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const HTTP_URL = 'http://example.com';\n      await page.setCookie({\n        url: HTTP_URL,\n        name: 'foo',\n        value: 'bar',\n      });\n      const [cookie] = await page.cookies(HTTP_URL);\n      expect(cookie!.secure).toBe(false);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set a cookie on a different domain","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":393,"column":49},"line":393,"code":"    it('should set a cookie on a different domain', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({\n        url: 'https://www.example.com',\n        name: 'example-cookie',\n        value: 'best',\n      });\n      expect(await page.evaluate('document.cookie')).toBe('');\n      expectCookieEquals(await page.cookies(), []);\n      expectCookieEquals(await page.cookies('https://www.example.com'), [\n        {\n          name: 'example-cookie',\n          value: 'best',\n          domain: 'www.example.com',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 18,\n          httpOnly: false,\n          secure: true,\n          session: true,\n          sourcePort: 443,\n          sourceScheme: 'Secure',\n        },\n      ]);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set cookies from a frame","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":421,"column":39},"line":421,"code":"    it('should set cookies from a frame', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/grid.html');\n      await page.setCookie({name: 'localhost-cookie', value: 'best'});\n      await page.evaluate(src => {\n        let fulfill!: () => void;\n        const promise = new Promise<void>(x => {\n          return (fulfill = x);\n        });\n        const iframe = document.createElement('iframe');\n        document.body.appendChild(iframe);\n        iframe.onload = fulfill;\n        iframe.src = src;\n        return promise;\n      }, server.CROSS_PROCESS_PREFIX);\n      await page.setCookie({\n        name: '127-cookie',\n        value: 'worst',\n        url: server.CROSS_PROCESS_PREFIX,\n      });\n      expect(await page.evaluate('document.cookie')).toBe(\n        'localhost-cookie=best'\n      );\n      expect(await page.frames()[1]!.evaluate('document.cookie')).toBe('');\n\n      expectCookieEquals(await page.cookies(), [\n        {\n          name: 'localhost-cookie',\n          value: 'best',\n          domain: 'localhost',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 20,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 80,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n\n      expectCookieEquals(await page.cookies(server.CROSS_PROCESS_PREFIX), [\n        {\n          name: '127-cookie',\n          value: 'worst',\n          domain: '127.0.0.1',\n          path: '/',\n          sameParty: false,\n          expires: -1,\n          size: 15,\n          httpOnly: false,\n          secure: false,\n          session: true,\n          sourcePort: 80,\n          sourceScheme: 'NonSecure',\n        },\n      ]);\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should set secure same-site cookies from a frame","suites":["Cookie specs","Page.setCookie"],"updatePoint":{"line":481,"column":56},"line":481,"code":"    it('should set secure same-site cookies from a frame', async () => {\n      const {httpsServer, puppeteer, defaultBrowserOptions} = getTestState();\n\n      const browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        ignoreHTTPSErrors: true,\n      });\n\n      const page = await browser.newPage();\n\n      try {\n        await page.goto(httpsServer.PREFIX + '/grid.html');\n        await page.evaluate(src => {\n          let fulfill!: () => void;\n          const promise = new Promise<void>(x => {\n            return (fulfill = x);\n          });\n          const iframe = document.createElement('iframe');\n          document.body.appendChild(iframe);\n          iframe.onload = fulfill;\n          iframe.src = src;\n          return promise;\n        }, httpsServer.CROSS_PROCESS_PREFIX);\n        await page.setCookie({\n          name: '127-same-site-cookie',\n          value: 'best',\n          url: httpsServer.CROSS_PROCESS_PREFIX,\n          sameSite: 'None',\n        });\n\n        expect(await page.frames()[1]!.evaluate('document.cookie')).toBe(\n          '127-same-site-cookie=best'\n        );\n        expectCookieEquals(\n          await page.cookies(httpsServer.CROSS_PROCESS_PREFIX),\n          [\n            {\n              name: '127-same-site-cookie',\n              value: 'best',\n              domain: '127.0.0.1',\n              path: '/',\n              sameParty: false,\n              expires: -1,\n              size: 24,\n              httpOnly: false,\n              sameSite: 'None',\n              secure: true,\n              session: true,\n              sourcePort: 443,\n              sourceScheme: 'Secure',\n            },\n          ]\n        );\n      } finally {\n        await page.close();\n        await browser.close();\n      }\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Cookie specs","Page.deleteCookie"],"updatePoint":{"line":542,"column":19},"line":542,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie(\n        {\n          name: 'cookie1',\n          value: '1',\n        },\n        {\n          name: 'cookie2',\n          value: '2',\n        },\n        {\n          name: 'cookie3',\n          value: '3',\n        }\n      );\n      expect(await page.evaluate('document.cookie')).toBe(\n        'cookie1=1; cookie2=2; cookie3=3'\n      );\n      await page.deleteCookie({name: 'cookie2'});\n      expect(await page.evaluate('document.cookie')).toBe(\n        'cookie1=1; cookie3=3'\n      );\n    });","file":"src/cookies.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":29,"column":19},"line":29,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n        waitUntil: 'networkidle0',\n      });\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toContain('/jscoverage/simple.html');\n      expect(coverage[0]!.ranges).toEqual([\n        {start: 0, end: 17},\n        {start: 35, end: 61},\n      ]);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report sourceURLs","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":43,"column":32},"line":43,"code":"    it('should report sourceURLs', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/sourceurl.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toBe('nicename.js');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore eval() scripts by default","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":52,"column":47},"line":52,"code":"    it('should ignore eval() scripts by default', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/eval.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't ignore eval() scripts if reportAnonymousScripts is true","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":60,"column":73},"line":60,"code":"    it(\"shouldn't ignore eval() scripts if reportAnonymousScripts is true\", async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage({reportAnonymousScripts: true});\n      await page.goto(server.PREFIX + '/jscoverage/eval.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(\n        coverage.find(entry => {\n          return entry.url.startsWith('debugger://');\n        })\n      ).not.toBe(null);\n      expect(coverage.length).toBe(2);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore pptr internal scripts if reportAnonymousScripts is true","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":73,"column":77},"line":73,"code":"    it('should ignore pptr internal scripts if reportAnonymousScripts is true', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage({reportAnonymousScripts: true});\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate('console.log(\"foo\")');\n      await page.evaluate(() => {\n        return console.log('bar');\n      });\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(0);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple scripts","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":85,"column":38},"line":85,"code":"    it('should report multiple scripts', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(2);\n      coverage.sort((a, b) => {\n        return a.url.localeCompare(b.url);\n      });\n      expect(coverage[0]!.url).toContain('/jscoverage/script1.js');\n      expect(coverage[1]!.url).toContain('/jscoverage/script2.js');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report right ranges","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":98,"column":34},"line":98,"code":"    it('should report right ranges', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/ranges.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      const entry = coverage[0]!;\n      expect(entry.ranges.length).toBe(2);\n      const range1 = entry.ranges[0]!;\n      expect(entry.text.substring(range1.start, range1.end)).toBe('\\n');\n      const range2 = entry.ranges[1]!;\n      expect(entry.text.substring(range2.start, range2.end)).toBe(\n        `console.log('used!');if(true===false)`\n      );\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report right ranges for \"per function\" scope","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":114,"column":59},"line":114,"code":"    it('should report right ranges for \"per function\" scope', async () => {\n      const {page, server} = getTestState();\n\n      const coverageOptions = {\n        useBlockCoverage: false,\n      };\n\n      await page.coverage.startJSCoverage(coverageOptions);\n      await page.goto(server.PREFIX + '/jscoverage/ranges.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      const entry = coverage[0]!;\n      expect(entry.ranges.length).toBe(2);\n      const range1 = entry.ranges[0]!;\n      expect(entry.text.substring(range1.start, range1.end)).toBe('\\n');\n      const range2 = entry.ranges[1]!;\n      expect(entry.text.substring(range2.start, range2.end)).toBe(\n        `console.log('used!');if(true===false)console.log('unused!');`\n      );\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report scripts that have no coverage","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":134,"column":51},"line":134,"code":"    it('should report scripts that have no coverage', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/unused.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(coverage.length).toBe(1);\n      const entry = coverage[0]!;\n      expect(entry.url).toContain('unused.html');\n      expect(entry.ranges.length).toBe(0);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with conditionals","suites":["Coverage specs","JSCoverage"],"updatePoint":{"line":145,"column":37},"line":145,"code":"    it('should work with conditionals', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startJSCoverage();\n      await page.goto(server.PREFIX + '/jscoverage/involved.html');\n      const coverage = await page.coverage.stopJSCoverage();\n      expect(\n        JSON.stringify(coverage, null, 2).replace(/:\\d{4,5}\\//g, ':<PORT>/')\n      ).toBeGolden('jscoverage-involved.txt');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang when there is a debugger statement","suites":["Coverage specs","JSCoverage"],"line":156,"code":"    it.skip('should not hang when there is a debugger statement', async () => {","file":"src/coverage.spec.ts","skipped":true,"dir":"test"},{"name":"should report scripts across navigations when disabled","suites":["Coverage specs","JSCoverage","resetOnNavigation"],"updatePoint":{"line":167,"column":64},"line":167,"code":"      it('should report scripts across navigations when disabled', async () => {\n        const {page, server} = getTestState();\n\n        await page.coverage.startJSCoverage({resetOnNavigation: false});\n        await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(2);\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should NOT report scripts across navigations when enabled","suites":["Coverage specs","JSCoverage","resetOnNavigation"],"updatePoint":{"line":177,"column":67},"line":177,"code":"      it('should NOT report scripts across navigations when enabled', async () => {\n        const {page, server} = getTestState();\n\n        await page.coverage.startJSCoverage(); // Enabled by default.\n        await page.goto(server.PREFIX + '/jscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(0);\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not include rawScriptCoverage field when disabled","suites":["Coverage specs","JSCoverage","includeRawScriptCoverage"],"updatePoint":{"line":188,"column":66},"line":188,"code":"      it('should not include rawScriptCoverage field when disabled', async () => {\n        const {page, server} = getTestState();\n        await page.coverage.startJSCoverage();\n        await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n          waitUntil: 'networkidle0',\n        });\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(1);\n        expect(coverage[0]!.rawScriptCoverage).toBeUndefined();\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should include rawScriptCoverage field when enabled","suites":["Coverage specs","JSCoverage","includeRawScriptCoverage"],"updatePoint":{"line":198,"column":61},"line":198,"code":"      it('should include rawScriptCoverage field when enabled', async () => {\n        const {page, server} = getTestState();\n        await page.coverage.startJSCoverage({\n          includeRawScriptCoverage: true,\n        });\n        await page.goto(server.PREFIX + '/jscoverage/simple.html', {\n          waitUntil: 'networkidle0',\n        });\n        const coverage = await page.coverage.stopJSCoverage();\n        expect(coverage.length).toBe(1);\n        expect(coverage[0]!.rawScriptCoverage).toBeTruthy();\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang when there is a debugger statement","suites":["Coverage specs","JSCoverage","includeRawScriptCoverage"],"line":212,"code":"    it.skip('should not hang when there is a debugger statement', async () => {","file":"src/coverage.spec.ts","skipped":true,"dir":"test"},{"name":"should work","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":228,"column":19},"line":228,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/simple.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toContain('/csscoverage/simple.html');\n      expect(coverage[0]!.ranges).toEqual([{start: 1, end: 22}]);\n      const range = coverage[0]!.ranges[0]!;\n      expect(coverage[0]!.text.substring(range.start, range.end)).toBe(\n        'div { color: green; }'\n      );\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report sourceURLs","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":242,"column":32},"line":242,"code":"    it('should report sourceURLs', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/sourceurl.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toBe('nicename.css');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple stylesheets","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":251,"column":42},"line":251,"code":"    it('should report multiple stylesheets', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(2);\n      coverage.sort((a, b) => {\n        return a.url.localeCompare(b.url);\n      });\n      expect(coverage[0]!.url).toContain('/csscoverage/stylesheet1.css');\n      expect(coverage[1]!.url).toContain('/csscoverage/stylesheet2.css');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report stylesheets that have no coverage","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":264,"column":55},"line":264,"code":"    it('should report stylesheets that have no coverage', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/unused.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toBe('unused.css');\n      expect(coverage[0]!.ranges.length).toBe(0);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with media queries","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":274,"column":38},"line":274,"code":"    it('should work with media queries', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/media.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n      expect(coverage[0]!.url).toContain('/csscoverage/media.html');\n      expect(coverage[0]!.ranges).toEqual([{start: 8, end: 40}]);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with complicated usecases","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":284,"column":45},"line":284,"code":"    it('should work with complicated usecases', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/involved.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(\n        JSON.stringify(coverage, null, 2).replace(/:\\d{4,5}\\//g, ':<PORT>/')\n      ).toBeGolden('csscoverage-involved.txt');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with empty stylesheets","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":294,"column":42},"line":294,"code":"    it('should work with empty stylesheets', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.goto(server.PREFIX + '/csscoverage/empty.html');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toEqual(1);\n      expect(coverage[0]!.text).toEqual('');\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore injected stylesheets","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":303,"column":42},"line":303,"code":"    it('should ignore injected stylesheets', async () => {\n      const {page} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.addStyleTag({content: 'body { margin: 10px;}'});\n      // trigger style recalc\n      const margin = await page.evaluate(() => {\n        return window.getComputedStyle(document.body).margin;\n      });\n      expect(margin).toBe('10px');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(0);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a recently loaded stylesheet","suites":["Coverage specs","CSSCoverage"],"updatePoint":{"line":316,"column":53},"line":316,"code":"    it('should work with a recently loaded stylesheet', async () => {\n      const {page, server} = getTestState();\n\n      await page.coverage.startCSSCoverage();\n      await page.evaluate(async url => {\n        document.body.textContent = 'hello, world';\n\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = url;\n        document.head.appendChild(link);\n        await new Promise(x => {\n          return (link.onload = x);\n        });\n      }, server.PREFIX + '/csscoverage/stylesheet1.css');\n      const coverage = await page.coverage.stopCSSCoverage();\n      expect(coverage.length).toBe(1);\n    });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should report stylesheets across navigations","suites":["Coverage specs","CSSCoverage","resetOnNavigation"],"updatePoint":{"line":335,"column":54},"line":335,"code":"      it('should report stylesheets across navigations', async () => {\n        const {page, server} = getTestState();\n\n        await page.coverage.startCSSCoverage({resetOnNavigation: false});\n        await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopCSSCoverage();\n        expect(coverage.length).toBe(2);\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"should NOT report scripts across navigations","suites":["Coverage specs","CSSCoverage","resetOnNavigation"],"updatePoint":{"line":344,"column":54},"line":344,"code":"      it('should NOT report scripts across navigations', async () => {\n        const {page, server} = getTestState();\n\n        await page.coverage.startCSSCoverage(); // Enabled by default.\n        await page.goto(server.PREFIX + '/csscoverage/multiple.html');\n        await page.goto(server.EMPTY_PAGE);\n        const coverage = await page.coverage.stopCSSCoverage();\n        expect(coverage.length).toBe(0);\n      });","file":"src/coverage.spec.ts","skipped":false,"dir":"test"},{"name":"page.cookies() should work","suites":["DefaultBrowserContext"],"updatePoint":{"line":27,"column":32},"line":27,"code":"  it('page.cookies() should work', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.evaluate(() => {\n      document.cookie = 'username=John Doe';\n    });\n    expectCookieEquals(await page.cookies(), [\n      {\n        name: 'username',\n        value: 'John Doe',\n        domain: 'localhost',\n        path: '/',\n        sameParty: false,\n        expires: -1,\n        size: 16,\n        httpOnly: false,\n        secure: false,\n        session: true,\n        sourceScheme: 'NonSecure',\n      },\n    ]);\n  });","file":"src/defaultbrowsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"page.setCookie() should work","suites":["DefaultBrowserContext"],"updatePoint":{"line":50,"column":34},"line":50,"code":"  it('page.setCookie() should work', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setCookie({\n      name: 'username',\n      value: 'John Doe',\n    });\n    expect(\n      await page.evaluate(() => {\n        return document.cookie;\n      })\n    ).toBe('username=John Doe');\n    expectCookieEquals(await page.cookies(), [\n      {\n        name: 'username',\n        value: 'John Doe',\n        domain: 'localhost',\n        path: '/',\n        sameParty: false,\n        expires: -1,\n        size: 16,\n        httpOnly: false,\n        secure: false,\n        session: true,\n        sourcePort: 80,\n        sourceScheme: 'NonSecure',\n      },\n    ]);\n  });","file":"src/defaultbrowsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"page.deleteCookie() should work","suites":["DefaultBrowserContext"],"updatePoint":{"line":80,"column":37},"line":80,"code":"  it('page.deleteCookie() should work', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setCookie(\n      {\n        name: 'cookie1',\n        value: '1',\n      },\n      {\n        name: 'cookie2',\n        value: '2',\n      }\n    );\n    expect(await page.evaluate('document.cookie')).toBe('cookie1=1; cookie2=2');\n    await page.deleteCookie({name: 'cookie2'});\n    expect(await page.evaluate('document.cookie')).toBe('cookie1=1');\n    expectCookieEquals(await page.cookies(), [\n      {\n        name: 'cookie1',\n        value: '1',\n        domain: 'localhost',\n        path: '/',\n        sameParty: false,\n        expires: -1,\n        size: 8,\n        httpOnly: false,\n        secure: false,\n        session: true,\n        sourcePort: 80,\n        sourceScheme: 'NonSecure',\n      },\n    ]);\n  });","file":"src/defaultbrowsercontext.spec.ts","skipped":false,"dir":"test"},{"name":"should fire","suites":["Page.Events.Dialog"],"updatePoint":{"line":29,"column":17},"line":29,"code":"  it('should fire', async () => {\n    const {page} = getTestState();\n\n    const onDialog = sinon.stub().callsFake(dialog => {\n      dialog.accept();\n    });\n    page.on('dialog', onDialog);\n\n    await page.evaluate(() => {\n      return alert('yo');\n    });\n\n    expect(onDialog.callCount).toEqual(1);\n    const dialog = onDialog.firstCall.args[0]!;\n    expect(dialog.type()).toBe('alert');\n    expect(dialog.defaultValue()).toBe('');\n    expect(dialog.message()).toBe('yo');\n  });","file":"src/dialog.spec.ts","skipped":false,"dir":"test"},{"name":"should allow accepting prompts","suites":["Page.Events.Dialog"],"updatePoint":{"line":48,"column":36},"line":48,"code":"  it('should allow accepting prompts', async () => {\n    const {page} = getTestState();\n\n    const onDialog = sinon.stub().callsFake(dialog => {\n      dialog.accept('answer!');\n    });\n    page.on('dialog', onDialog);\n\n    const result = await page.evaluate(() => {\n      return prompt('question?', 'yes.');\n    });\n\n    expect(onDialog.callCount).toEqual(1);\n    const dialog = onDialog.firstCall.args[0]!;\n    expect(dialog.type()).toBe('prompt');\n    expect(dialog.defaultValue()).toBe('yes.');\n    expect(dialog.message()).toBe('question?');\n\n    expect(result).toBe('answer!');\n  });","file":"src/dialog.spec.ts","skipped":false,"dir":"test"},{"name":"should dismiss the prompt","suites":["Page.Events.Dialog"],"updatePoint":{"line":68,"column":31},"line":68,"code":"  it('should dismiss the prompt', async () => {\n    const {page} = getTestState();\n\n    page.on('dialog', dialog => {\n      dialog.dismiss();\n    });\n    const result = await page.evaluate(() => {\n      return prompt('question?');\n    });\n    expect(result).toBe(null);\n  });","file":"src/dialog.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an exception if not enabled before usage","suites":["Input.drag"],"updatePoint":{"line":27,"column":59},"line":27,"code":"  it('should throw an exception if not enabled before usage', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    const draggable = (await page.$('#drag'))!;\n\n    try {\n      await draggable!.drag({x: 1, y: 1});\n    } catch (error) {\n      expect((error as Error).message).toContain(\n        'Drag Interception is not enabled!'\n      );\n    }\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragIntercepted event when dragged","suites":["Input.drag"],"updatePoint":{"line":41,"column":54},"line":41,"code":"  it('should emit a dragIntercepted event when dragged', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    const data = await draggable.drag({x: 1, y: 1});\n\n    expect(data.items.length).toBe(1);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragStart;\n      })\n    ).toBe(true);\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragEnter","suites":["Input.drag"],"updatePoint":{"line":58,"column":29},"line":58,"code":"  it('should emit a dragEnter', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    const data = await draggable.drag({x: 1, y: 1});\n    const dropzone = (await page.$('#drop'))!;\n    await dropzone.dragEnter(data);\n\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragStart;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragEnter;\n      })\n    ).toBe(true);\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should emit a dragOver event","suites":["Input.drag"],"updatePoint":{"line":81,"column":34},"line":81,"code":"  it('should emit a dragOver event', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    const data = await draggable.drag({x: 1, y: 1});\n    const dropzone = (await page.$('#drop'))!;\n    await dropzone.dragEnter(data);\n    await dropzone.dragOver(data);\n\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragStart;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragEnter;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragOver;\n      })\n    ).toBe(true);\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be dropped","suites":["Input.drag"],"updatePoint":{"line":110,"column":20},"line":110,"code":"  it('can be dropped', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    const dropzone = (await page.$('#drop'))!;\n    const data = await draggable.drag({x: 1, y: 1});\n    await dropzone.dragEnter(data);\n    await dropzone.dragOver(data);\n    await dropzone.drop(data);\n\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragStart;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragEnter;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragOver;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDrop;\n      })\n    ).toBe(true);\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be dragged and dropped with a single function","suites":["Input.drag"],"updatePoint":{"line":145,"column":55},"line":145,"code":"  it('can be dragged and dropped with a single function', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    const dropzone = (await page.$('#drop'))!;\n    await draggable.dragAndDrop(dropzone);\n\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragStart;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragEnter;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDragOver;\n      })\n    ).toBe(true);\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).didDrop;\n      })\n    ).toBe(true);\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"can be disabled","suites":["Input.drag"],"updatePoint":{"line":177,"column":21},"line":177,"code":"  it('can be disabled', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/drag-and-drop.html');\n    expect(page.isDragInterceptionEnabled()).toBe(false);\n    await page.setDragInterception(true);\n    expect(page.isDragInterceptionEnabled()).toBe(true);\n    const draggable = (await page.$('#drag'))!;\n    await draggable.drag({x: 1, y: 1});\n    await page.setDragInterception(false);\n\n    try {\n      await draggable.drag({x: 1, y: 1});\n    } catch (error) {\n      expect((error as Error).message).toContain(\n        'Drag Interception is not enabled!'\n      );\n    }\n  });","file":"src/drag-and-drop.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.boundingBox"],"updatePoint":{"line":34,"column":19},"line":34,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const elementHandle = (await page.$('.box:nth-of-type(13)'))!;\n      const box = await elementHandle.boundingBox();\n      expect(box).toEqual({x: 100, y: 50, width: 50, height: 50});\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should handle nested frames","suites":["ElementHandle specs","ElementHandle.boundingBox"],"updatePoint":{"line":43,"column":35},"line":43,"code":"    it('should handle nested frames', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      const nestedFrame = page.frames()[1]!.childFrames()[1]!;\n      const elementHandle = (await nestedFrame.$('div'))!;\n      const box = await elementHandle.boundingBox();\n      if (isChrome) {\n        expect(box).toEqual({x: 28, y: 182, width: 264, height: 18});\n      } else {\n        expect(box).toEqual({x: 28, y: 182, width: 254, height: 18});\n      }\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for invisible elements","suites":["ElementHandle specs","ElementHandle.boundingBox"],"updatePoint":{"line":57,"column":49},"line":57,"code":"    it('should return null for invisible elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div style=\"display:none\">hi</div>');\n      const element = (await page.$('div'))!;\n      expect(await element.boundingBox()).toBe(null);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should force a layout","suites":["ElementHandle specs","ElementHandle.boundingBox"],"updatePoint":{"line":64,"column":29},"line":64,"code":"    it('should force a layout', async () => {\n      const {page} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.setContent(\n        '<div style=\"width: 100px; height: 100px\">hello</div>'\n      );\n      const elementHandle = (await page.$('div'))!;\n      await page.evaluate((element: HTMLElement) => {\n        return (element.style.height = '200px');\n      }, elementHandle);\n      const box = await elementHandle.boundingBox();\n      expect(box).toEqual({x: 8, y: 8, width: 100, height: 200});\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with SVG nodes","suites":["ElementHandle specs","ElementHandle.boundingBox"],"updatePoint":{"line":78,"column":34},"line":78,"code":"    it('should work with SVG nodes', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\">\n          <rect id=\"theRect\" x=\"30\" y=\"50\" width=\"200\" height=\"300\"></rect>\n        </svg>\n      `);\n      const element = (await page.$(\n        '#therect'\n      )) as ElementHandle<SVGRectElement>;\n      const pptrBoundingBox = await element.boundingBox();\n      const webBoundingBox = await page.evaluate(e => {\n        const rect = e.getBoundingClientRect();\n        return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n      }, element);\n      expect(pptrBoundingBox).toEqual(webBoundingBox);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.boxModel"],"updatePoint":{"line":99,"column":19},"line":99,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/resetcss.html');\n\n      // Step 1: Add Frame and position it absolutely.\n      await utils.attachFrame(page, 'frame1', server.PREFIX + '/resetcss.html');\n      await page.evaluate(() => {\n        const frame = document.querySelector<HTMLElement>('#frame1')!;\n        frame.style.position = 'absolute';\n        frame.style.left = '1px';\n        frame.style.top = '2px';\n      });\n\n      // Step 2: Add div and position it absolutely inside frame.\n      const frame = page.frames()[1]!;\n      const divHandle = (\n        await frame.evaluateHandle(() => {\n          const div = document.createElement('div');\n          document.body.appendChild(div);\n          div.style.boxSizing = 'border-box';\n          div.style.position = 'absolute';\n          div.style.borderLeft = '1px solid black';\n          div.style.paddingLeft = '2px';\n          div.style.marginLeft = '3px';\n          div.style.left = '4px';\n          div.style.top = '5px';\n          div.style.width = '6px';\n          div.style.height = '7px';\n          return div;\n        })\n      ).asElement()!;\n\n      // Step 3: query div's boxModel and assert box values.\n      const box = (await divHandle.boxModel())!;\n      expect(box.width).toBe(6);\n      expect(box.height).toBe(7);\n      expect(box.margin[0]!).toEqual({\n        x: 1 + 4, // frame.left + div.left\n        y: 2 + 5,\n      });\n      expect(box.border[0]!).toEqual({\n        x: 1 + 4 + 3, // frame.left + div.left + div.margin-left\n        y: 2 + 5,\n      });\n      expect(box.padding[0]!).toEqual({\n        x: 1 + 4 + 3 + 1, // frame.left + div.left + div.marginLeft + div.borderLeft\n        y: 2 + 5,\n      });\n      expect(box.content[0]!).toEqual({\n        x: 1 + 4 + 3 + 1 + 2, // frame.left + div.left + div.marginLeft + div.borderLeft + dif.paddingLeft\n        y: 2 + 5,\n      });\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for invisible elements","suites":["ElementHandle specs","ElementHandle.boxModel"],"updatePoint":{"line":154,"column":49},"line":154,"code":"    it('should return null for invisible elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div style=\"display:none\">hi</div>');\n      const element = (await page.$('div'))!;\n      expect(await element.boxModel()).toBe(null);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.contentFrame"],"updatePoint":{"line":164,"column":19},"line":164,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const elementHandle = (await page.$('#frame1'))!;\n      const frame = await elementHandle.contentFrame();\n      expect(frame).toBe(page.frames()[1]!);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":177,"column":19},"line":177,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = (await page.$('button'))!;\n      await button.click();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result;\n        })\n      ).toBe('Clicked');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for Shadow DOM v1","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":189,"column":37},"line":189,"code":"    it('should work for Shadow DOM v1', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/shadow.html');\n      const buttonHandle = await page.evaluateHandle(() => {\n        // @ts-expect-error button is expected to be in the page's scope.\n        return button as HTMLButtonElement;\n      });\n      await buttonHandle.click();\n      expect(\n        await page.evaluate(() => {\n          // @ts-expect-error clicked is expected to be in the page's scope.\n          return clicked;\n        })\n      ).toBe(true);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should not work for TextNodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":205,"column":37},"line":205,"code":"    it('should not work for TextNodes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const buttonTextNode = await page.evaluateHandle(() => {\n        return document.querySelector('button')!.firstChild as HTMLElement;\n      });\n      let error!: Error;\n      await buttonTextNode.click().catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Node is not of type HTMLElement');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for detached nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":218,"column":39},"line":218,"code":"    it('should throw for detached nodes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = (await page.$('button'))!;\n      await page.evaluate((button: HTMLElement) => {\n        return button.remove();\n      }, button);\n      let error!: Error;\n      await button.click().catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Node is detached from document');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for hidden nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":232,"column":37},"line":232,"code":"    it('should throw for hidden nodes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = (await page.$('button'))!;\n      await page.evaluate((button: HTMLElement) => {\n        return (button.style.display = 'none');\n      }, button);\n      const error = await button.click().catch(error_ => {\n        return error_;\n      });\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for recursively hidden nodes","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":247,"column":49},"line":247,"code":"    it('should throw for recursively hidden nodes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = (await page.$('button'))!;\n      await page.evaluate((button: HTMLElement) => {\n        return (button.parentElement!.style.display = 'none');\n      }, button);\n      const error = await button.click().catch(error_ => {\n        return error_;\n      });\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for <br> elements","suites":["ElementHandle specs","ElementHandle.click"],"updatePoint":{"line":262,"column":38},"line":262,"code":"    it('should throw for <br> elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('hello<br>goodbye');\n      const br = (await page.$('br'))!;\n      const error = await br.click().catch(error_ => {\n        return error_;\n      });\n      expect(error.message).toBe(\n        'Node is either not clickable or not an HTMLElement'\n      );\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector on an element","suites":["ElementHandle specs","Element.waitForSelector"],"updatePoint":{"line":277,"column":64},"line":277,"code":"    it('should wait correctly with waitForSelector on an element', async () => {\n      const {page} = getTestState();\n      const waitFor = page.waitForSelector('.foo') as Promise<\n        ElementHandle<HTMLDivElement>\n      >;\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"bar\">bar2</div><div class=\"foo\">Foo1</div>'\n      );\n      let element = (await waitFor)!;\n      expect(element).toBeDefined();\n\n      const innerWaitFor = element.waitForSelector('.bar') as Promise<\n        ElementHandle<HTMLDivElement>\n      >;\n      await element.evaluate(el => {\n        el.innerHTML = '<div class=\"bar\">bar1</div>';\n      });\n      element = (await innerWaitFor)!;\n      expect(element).toBeDefined();\n      expect(\n        await element.evaluate(el => {\n          return (el as HTMLElement).innerText;\n        })\n      ).toStrictEqual('bar1');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForXPath on an element","suites":["ElementHandle specs","Element.waitForXPath"],"updatePoint":{"line":306,"column":61},"line":306,"code":"    it('should wait correctly with waitForXPath on an element', async () => {\n      const {page} = getTestState();\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        `<div id=el1>\n          el1\n          <div id=el2>\n            el2\n          </div>\n        </div>\n        <div id=el3>\n          el3\n        </div>`\n      );\n\n      const el1 = (await page.waitForSelector(\n        '#el1'\n      )) as ElementHandle<HTMLDivElement>;\n\n      for (const path of ['//div', './/div']) {\n        const e = (await el1.waitForXPath(\n          path\n        )) as ElementHandle<HTMLDivElement>;\n        expect(\n          await e.evaluate(el => {\n            return el.id;\n          })\n        ).toStrictEqual('el2');\n      }\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.hover"],"updatePoint":{"line":339,"column":19},"line":339,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/scrollable.html');\n      const button = (await page.$('#button-6'))!;\n      await button.hover();\n      expect(\n        await page.evaluate(() => {\n          return document.querySelector('button:hover')!.id;\n        })\n      ).toBe('button-6');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":354,"column":19},"line":354,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      for (let i = 0; i < 11; ++i) {\n        const button = (await page.$('#btn' + i))!;\n        // All but last button are visible.\n        const visible = i < 10;\n        expect(await button.isIntersectingViewport()).toBe(visible);\n      }\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with threshold","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":365,"column":34},"line":365,"code":"    it('should work with threshold', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      // a button almost cannot be seen\n      // sometimes we expect to return false by isIntersectingViewport1\n      const button = (await page.$('#btn11'))!;\n      expect(\n        await button.isIntersectingViewport({\n          threshold: 0.001,\n        })\n      ).toBe(false);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with threshold of 1","suites":["ElementHandle specs","ElementHandle.isIntersectingViewport"],"updatePoint":{"line":378,"column":39},"line":378,"code":"    it('should work with threshold of 1', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/offscreenbuttons.html');\n      // a button almost cannot be seen\n      // sometimes we expect to return false by isIntersectingViewport1\n      const button = (await page.$('#btn0'))!;\n      expect(\n        await button.isIntersectingViewport({\n          threshold: 1,\n        })\n      ).toBe(true);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should register and unregister","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":397,"column":38},"line":397,"code":"    it('should register and unregister', async () => {\n      const {page} = getTestState();\n      await page.setContent('<div id=\"not-foo\"></div><div id=\"foo\"></div>');\n\n      // Register.\n      Puppeteer.registerCustomQueryHandler('getById', {\n        queryOne: (_element, selector) => {\n          return document.querySelector(`[id=\"${selector}\"]`);\n        },\n      });\n      const element = (await page.$(\n        'getById/foo'\n      )) as ElementHandle<HTMLDivElement>;\n      expect(\n        await page.evaluate(element => {\n          return element.id;\n        }, element)\n      ).toBe('foo');\n      const handlerNamesAfterRegistering = Puppeteer.customQueryHandlerNames();\n      expect(handlerNamesAfterRegistering.includes('getById')).toBeTruthy();\n\n      // Unregister.\n      Puppeteer.unregisterCustomQueryHandler('getById');\n      try {\n        await page.$('getById/foo');\n        throw new Error('Custom query handler name not set - throw expected');\n      } catch (error) {\n        expect(error).not.toStrictEqual(\n          new Error('Custom query handler name not set - throw expected')\n        );\n      }\n      const handlerNamesAfterUnregistering =\n        Puppeteer.customQueryHandlerNames();\n      expect(handlerNamesAfterUnregistering.includes('getById')).toBeFalsy();\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw with invalid query names","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":432,"column":45},"line":432,"code":"    it('should throw with invalid query names', () => {\n      try {\n        Puppeteer.registerCustomQueryHandler('1/2/3', {\n          queryOne: () => {\n            return document.querySelector('foo');\n          },\n        });\n        throw new Error(\n          'Custom query handler name was invalid - throw expected'\n        );\n      } catch (error) {\n        expect(error).toStrictEqual(\n          new Error('Custom query handler names may only contain [a-zA-Z]')\n        );\n      }\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for multiple elements","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":448,"column":41},"line":448,"code":"    it('should work for multiple elements', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div><div class=\"foo baz\">Foo2</div>'\n      );\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryAll: (_element, selector) => {\n          return [...document.querySelectorAll(`.${selector}`)];\n        },\n      });\n      const elements = (await page.$$('getByClass/foo')) as Array<\n        ElementHandle<HTMLDivElement>\n      >;\n      const classNames = await Promise.all(\n        elements.map(async element => {\n          return await page.evaluate(element => {\n            return element.className;\n          }, element);\n        })\n      );\n\n      expect(classNames).toStrictEqual(['foo', 'foo baz']);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should eval correctly","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":471,"column":29},"line":471,"code":"    it('should eval correctly', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div><div class=\"foo baz\">Foo2</div>'\n      );\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryAll: (_element, selector) => {\n          return [...document.querySelectorAll(`.${selector}`)];\n        },\n      });\n      const elements = await page.$$eval('getByClass/foo', divs => {\n        return divs.length;\n      });\n\n      expect(elements).toBe(2);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":487,"column":50},"line":487,"code":"    it('should wait correctly with waitForSelector', async () => {\n      const {page} = getTestState();\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => {\n          return (element as Element).querySelector(`.${selector}`);\n        },\n      });\n      const waitFor = page.waitForSelector('getByClass/foo');\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div>'\n      );\n      const element = await waitFor;\n\n      expect(element).toBeDefined();\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitForSelector on an element","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":505,"column":64},"line":505,"code":"    it('should wait correctly with waitForSelector on an element', async () => {\n      const {page} = getTestState();\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => {\n          return (element as Element).querySelector(`.${selector}`);\n        },\n      });\n      const waitFor = page.waitForSelector('getByClass/foo') as Promise<\n        ElementHandle<HTMLElement>\n      >;\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"bar\">bar2</div><div class=\"foo\">Foo1</div>'\n      );\n      let element = (await waitFor)!;\n      expect(element).toBeDefined();\n\n      const innerWaitFor = element.waitForSelector('getByClass/bar') as Promise<\n        ElementHandle<HTMLElement>\n      >;\n\n      await element.evaluate(el => {\n        el.innerHTML = '<div class=\"bar\">bar1</div>';\n      });\n\n      element = (await innerWaitFor)!;\n      expect(element).toBeDefined();\n      expect(\n        await element.evaluate(el => {\n          return el.innerText;\n        })\n      ).toStrictEqual('bar1');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should wait correctly with waitFor","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":540,"column":42},"line":540,"code":"    it('should wait correctly with waitFor', async () => {\n      /* page.waitFor is deprecated so we silence the warning to avoid test noise */\n      sinon.stub(console, 'warn').callsFake(() => {});\n      const {page} = getTestState();\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => {\n          return (element as Element).querySelector(`.${selector}`);\n        },\n      });\n      const waitFor = page.waitForSelector('getByClass/foo');\n\n      // Set the page content after the waitFor has been started.\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">Foo1</div>'\n      );\n      const element = await waitFor;\n\n      expect(element).toBeDefined();\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work when both queryOne and queryAll are registered","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":559,"column":66},"line":559,"code":"    it('should work when both queryOne and queryAll are registered', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\"><div id=\"nested-foo\" class=\"foo\"/></div><div class=\"foo baz\">Foo2</div>'\n      );\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => {\n          return (element as Element).querySelector(`.${selector}`);\n        },\n        queryAll: (element, selector) => {\n          return [...(element as Element).querySelectorAll(`.${selector}`)];\n        },\n      });\n\n      const element = (await page.$('getByClass/foo'))!;\n      expect(element).toBeDefined();\n\n      const elements = await page.$$('getByClass/foo');\n      expect(elements.length).toBe(3);\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should eval when both queryOne and queryAll are registered","suites":["ElementHandle specs","Custom queries"],"updatePoint":{"line":579,"column":66},"line":579,"code":"    it('should eval when both queryOne and queryAll are registered', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div id=\"not-foo\"></div><div class=\"foo\">text</div><div class=\"foo baz\">content</div>'\n      );\n      Puppeteer.registerCustomQueryHandler('getByClass', {\n        queryOne: (element, selector) => {\n          return (element as Element).querySelector(`.${selector}`);\n        },\n        queryAll: (element, selector) => {\n          return [...(element as Element).querySelectorAll(`.${selector}`)];\n        },\n      });\n\n      const txtContent = await page.$eval('getByClass/foo', div => {\n        return div.textContent;\n      });\n      expect(txtContent).toBe('text');\n\n      const txtContents = await page.$$eval('getByClass/foo', divs => {\n        return divs\n          .map(d => {\n            return d.textContent;\n          })\n          .join('');\n      });\n      expect(txtContents).toBe('textcontent');\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ElementHandle specs","Element.toElement"],"updatePoint":{"line":610,"column":19},"line":610,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n      await page.setContent('<div class=\"foo\">Foo1</div>');\n      const element = await page.$('.foo');\n      const div = await element?.toElement('div');\n      expect(div).toBeDefined();\n    });","file":"src/elementhandle.spec.ts","skipped":false,"dir":"test"},{"name":"should get the proper viewport size","suites":["Emulation","Page.viewport"],"updatePoint":{"line":33,"column":43},"line":33,"code":"    it('should get the proper viewport size', async () => {\n      const {page} = getTestState();\n\n      expect(page.viewport()).toEqual({width: 800, height: 600});\n      await page.setViewport({width: 123, height: 456});\n      expect(page.viewport()).toEqual({width: 123, height: 456});\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support mobile emulation","suites":["Emulation","Page.viewport"],"updatePoint":{"line":40,"column":39},"line":40,"code":"    it('should support mobile emulation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(\n        await page.evaluate(() => {\n          return window.innerWidth;\n        })\n      ).toBe(800);\n      await page.setViewport(iPhone.viewport);\n      expect(\n        await page.evaluate(() => {\n          return window.innerWidth;\n        })\n      ).toBe(375);\n      await page.setViewport({width: 400, height: 300});\n      expect(\n        await page.evaluate(() => {\n          return window.innerWidth;\n        })\n      ).toBe(400);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support touch emulation","suites":["Emulation","Page.viewport"],"updatePoint":{"line":62,"column":38},"line":62,"code":"    it('should support touch emulation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(\n        await page.evaluate(() => {\n          return 'ontouchstart' in window;\n        })\n      ).toBe(false);\n      await page.setViewport(iPhone.viewport);\n      expect(\n        await page.evaluate(() => {\n          return 'ontouchstart' in window;\n        })\n      ).toBe(true);\n      expect(await page.evaluate(dispatchTouch)).toBe('Received touch');\n      await page.setViewport({width: 100, height: 100});\n      expect(\n        await page.evaluate(() => {\n          return 'ontouchstart' in window;\n        })\n      ).toBe(false);\n\n      function dispatchTouch() {\n        let fulfill!: (value: string) => void;\n        const promise = new Promise(x => {\n          fulfill = x;\n        });\n        window.ontouchstart = () => {\n          fulfill('Received touch');\n        };\n        window.dispatchEvent(new Event('touchstart'));\n\n        fulfill('Did not receive touch');\n\n        return promise;\n      }\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should be detectable by Modernizr","suites":["Emulation","Page.viewport"],"updatePoint":{"line":100,"column":41},"line":100,"code":"    it('should be detectable by Modernizr', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/detect-touch.html');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent!.trim();\n        })\n      ).toBe('NO');\n      await page.setViewport(iPhone.viewport);\n      await page.goto(server.PREFIX + '/detect-touch.html');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent!.trim();\n        })\n      ).toBe('YES');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should detect touch when applying viewport with touches","suites":["Emulation","Page.viewport"],"updatePoint":{"line":117,"column":63},"line":117,"code":"    it('should detect touch when applying viewport with touches', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 800, height: 600, hasTouch: true});\n      await page.addScriptTag({url: server.PREFIX + '/modernizr.js'});\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).Modernizr.touchevents;\n        })\n      ).toBe(true);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support landscape emulation","suites":["Emulation","Page.viewport"],"updatePoint":{"line":128,"column":42},"line":128,"code":"    it('should support landscape emulation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(\n        await page.evaluate(() => {\n          return screen.orientation.type;\n        })\n      ).toBe('portrait-primary');\n      await page.setViewport(iPhoneLandscape.viewport);\n      expect(\n        await page.evaluate(() => {\n          return screen.orientation.type;\n        })\n      ).toBe('landscape-primary');\n      await page.setViewport({width: 100, height: 100});\n      expect(\n        await page.evaluate(() => {\n          return screen.orientation.type;\n        })\n      ).toBe('portrait-primary');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulate"],"updatePoint":{"line":153,"column":19},"line":153,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      await page.emulate(iPhone);\n      expect(\n        await page.evaluate(() => {\n          return window.innerWidth;\n        })\n      ).toBe(375);\n      expect(\n        await page.evaluate(() => {\n          return navigator.userAgent;\n        })\n      ).toContain('iPhone');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should support clicking","suites":["Emulation","Page.emulate"],"updatePoint":{"line":169,"column":31},"line":169,"code":"    it('should support clicking', async () => {\n      const {page, server} = getTestState();\n\n      await page.emulate(iPhone);\n      await page.goto(server.PREFIX + '/input/button.html');\n      const button = (await page.$('button'))!;\n      await page.evaluate((button: HTMLElement) => {\n        return (button.style.marginTop = '200px');\n      }, button);\n      await button.click();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result;\n        })\n      ).toBe('Clicked');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateMediaType"],"updatePoint":{"line":188,"column":19},"line":188,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('screen').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('print').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaType('print');\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('screen').matches;\n        })\n      ).toBe(false);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('print').matches;\n        })\n      ).toBe(true);\n      await page.emulateMediaType();\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('screen').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('print').matches;\n        })\n      ).toBe(false);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of bad argument","suites":["Emulation","Page.emulateMediaType"],"updatePoint":{"line":224,"column":44},"line":224,"code":"    it('should throw in case of bad argument', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.emulateMediaType('bad').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Unsupported media type: bad');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":236,"column":19},"line":236,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.emulateMediaFeatures([\n        {name: 'prefers-reduced-motion', value: 'reduce'},\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-reduced-motion: reduce)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-reduced-motion: no-preference)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([\n        {name: 'prefers-color-scheme', value: 'light'},\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: light)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: dark)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([\n        {name: 'prefers-color-scheme', value: 'dark'},\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: dark)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: light)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([\n        {name: 'prefers-reduced-motion', value: 'reduce'},\n        {name: 'prefers-color-scheme', value: 'light'},\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-reduced-motion: reduce)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-reduced-motion: no-preference)').matches;\n        })\n      ).toBe(false);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: light)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(prefers-color-scheme: dark)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([{name: 'color-gamut', value: 'srgb'}]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: p3)').matches;\n        })\n      ).toBe(false);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: srgb)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: rec2020)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: p3)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: srgb)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: rec2020)').matches;\n        })\n      ).toBe(false);\n      await page.emulateMediaFeatures([\n        {name: 'color-gamut', value: 'rec2020'},\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: p3)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: srgb)').matches;\n        })\n      ).toBe(true);\n      expect(\n        await page.evaluate(() => {\n          return matchMedia('(color-gamut: rec2020)').matches;\n        })\n      ).toBe(true);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of bad argument","suites":["Emulation","Page.emulateMediaFeatures"],"updatePoint":{"line":353,"column":44},"line":353,"code":"    it('should throw in case of bad argument', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .emulateMediaFeatures([{name: 'bad', value: ''}])\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toBe('Unsupported media feature: bad');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateTimezone"],"updatePoint":{"line":367,"column":19},"line":367,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.evaluate(() => {\n        (globalThis as any).date = new Date(1479579154987);\n      });\n      await page.emulateTimezone('America/Jamaica');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).date.toString();\n        })\n      ).toBe('Sat Nov 19 2016 13:12:34 GMT-0500 (Eastern Standard Time)');\n\n      await page.emulateTimezone('Pacific/Honolulu');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).date.toString();\n        })\n      ).toBe(\n        'Sat Nov 19 2016 08:12:34 GMT-1000 (Hawaii-Aleutian Standard Time)'\n      );\n\n      await page.emulateTimezone('America/Buenos_Aires');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).date.toString();\n        })\n      ).toBe('Sat Nov 19 2016 15:12:34 GMT-0300 (Argentina Standard Time)');\n\n      await page.emulateTimezone('Europe/Berlin');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).date.toString();\n        })\n      ).toBe(\n        'Sat Nov 19 2016 19:12:34 GMT+0100 (Central European Standard Time)'\n      );\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for invalid timezone IDs","suites":["Emulation","Page.emulateTimezone"],"updatePoint":{"line":406,"column":45},"line":406,"code":"    it('should throw for invalid timezone IDs', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.emulateTimezone('Foo/Bar').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Invalid timezone ID: Foo/Bar');\n      await page.emulateTimezone('Baz/Qux').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Invalid timezone ID: Baz/Qux');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Emulation","Page.emulateVisionDeficiency"],"updatePoint":{"line":422,"column":19},"line":422,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n\n      {\n        await page.emulateVisionDeficiency('none');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('screenshot-sanity.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('achromatopsia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-achromatopsia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('blurredVision');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-blurredVision.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('deuteranopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-deuteranopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('protanopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-protanopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('tritanopia');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('vision-deficiency-tritanopia.png');\n      }\n\n      {\n        await page.emulateVisionDeficiency('none');\n        const screenshot = await page.screenshot();\n        expect(screenshot).toBeGolden('screenshot-sanity.png');\n      }\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for invalid vision deficiencies","suites":["Emulation","Page.emulateVisionDeficiency"],"updatePoint":{"line":471,"column":52},"line":471,"code":"    it('should throw for invalid vision deficiencies', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        // @ts-expect-error deliberately passing invalid deficiency\n        .emulateVisionDeficiency('invalid')\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toBe('Unsupported vision deficiency: invalid');\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should change navigator.connection.effectiveType","suites":["Emulation","Page.emulateNetworkConditions"],"updatePoint":{"line":486,"column":56},"line":486,"code":"    it('should change navigator.connection.effectiveType', async () => {\n      const {page} = getTestState();\n\n      const slow3G = PredefinedNetworkConditions['Slow 3G']!;\n      const fast3G = PredefinedNetworkConditions['Fast 3G']!;\n\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('4g');\n      await page.emulateNetworkConditions(fast3G);\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('3g');\n      await page.emulateNetworkConditions(slow3G);\n      expect(\n        await page.evaluate('window.navigator.connection.effectiveType')\n      ).toBe('2g');\n      await page.emulateNetworkConditions(null);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should change the CPU throttling rate successfully","suites":["Emulation","Page.emulateCPUThrottling"],"updatePoint":{"line":508,"column":58},"line":508,"code":"    it('should change the CPU throttling rate successfully', async () => {\n      const {page} = getTestState();\n\n      await page.emulateCPUThrottling(100);\n      await page.emulateCPUThrottling(null);\n    });","file":"src/emulation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return 7 * 3;\n      });\n      expect(result).toBe(21);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer NaN","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":48,"column":27},"line":48,"code":"    it('should transfer NaN', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(a => {\n        return a;\n      }, NaN);\n      expect(Object.is(result, NaN)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer -0","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":56,"column":26},"line":56,"code":"    it('should transfer -0', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(a => {\n        return a;\n      }, -0);\n      expect(Object.is(result, -0)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":64,"column":32},"line":64,"code":"    it('should transfer Infinity', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(a => {\n        return a;\n      }, Infinity);\n      expect(Object.is(result, Infinity)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer -Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":72,"column":33},"line":72,"code":"    it('should transfer -Infinity', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(a => {\n        return a;\n      }, -Infinity);\n      expect(Object.is(result, -Infinity)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer arrays","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":80,"column":30},"line":80,"code":"    it('should transfer arrays', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(\n        a => {\n          return a;\n        },\n        [1, 2, 3]\n      );\n      expect(result).toEqual([1, 2, 3]);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer arrays as arrays, not objects","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":91,"column":53},"line":91,"code":"    it('should transfer arrays as arrays, not objects', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(\n        a => {\n          return Array.isArray(a);\n        },\n        [1, 2, 3]\n      );\n      expect(result).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should modify global environment","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":102,"column":40},"line":102,"code":"    it('should modify global environment', async () => {\n      const {page} = getTestState();\n\n      await page.evaluate(() => {\n        return ((globalThis as any).globalVar = 123);\n      });\n      expect(await page.evaluate('globalVar')).toBe(123);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate in the page context","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":110,"column":43},"line":110,"code":"    it('should evaluate in the page context', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/global-var.html');\n      expect(await page.evaluate('globalVar')).toBe(123);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined for objects with symbols","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":116,"column":56},"line":116,"code":"    it('should return undefined for objects with symbols', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return [Symbol('foo4')];\n        })\n      ).toBe(undefined);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with function shorthands","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":125,"column":44},"line":125,"code":"    it('should work with function shorthands', async () => {\n      const {page} = getTestState();\n\n      const a = {\n        sum(a: number, b: number) {\n          return a + b;\n        },\n\n        async mult(a: number, b: number) {\n          return a * b;\n        },\n      };\n      expect(await page.evaluate(a.sum, 1, 2)).toBe(3);\n      expect(await page.evaluate(a.mult, 2, 4)).toBe(8);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with unicode chars","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":140,"column":38},"line":140,"code":"    it('should work with unicode chars', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(\n        a => {\n          return a[''];\n        },\n        {\n          : 42,\n        }\n      );\n      expect(result).toBe(42);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when evaluation triggers reload","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":153,"column":52},"line":153,"code":"    it('should throw when evaluation triggers reload', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .evaluate(() => {\n          location.reload();\n          return new Promise(() => {});\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain('Protocol error');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should await promise","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":167,"column":28},"line":167,"code":"    it('should await promise', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return Promise.resolve(8 * 7);\n      });\n      expect(result).toBe(56);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work right after framenavigated","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":175,"column":46},"line":175,"code":"    it('should work right after framenavigated', async () => {\n      const {page, server} = getTestState();\n\n      let frameEvaluation = null;\n      page.on('framenavigated', async frame => {\n        frameEvaluation = frame.evaluate(() => {\n          return 6 * 7;\n        });\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(await frameEvaluation).toBe(42);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work from-inside an exposed function","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":187,"column":51},"line":187,"code":"    it('should work from-inside an exposed function', async () => {\n      const {page} = getTestState();\n\n      // Setup inpage callback, which calls Page.evaluate\n      await page.exposeFunction(\n        'callController',\n        async function (a: number, b: number) {\n          return await page.evaluate(\n            (a: number, b: number): number => {\n              return a * b;\n            },\n            a,\n            b\n          );\n        }\n      );\n      const result = await page.evaluate(async function () {\n        return await (globalThis as any).callController(9, 3);\n      });\n      expect(result).toBe(27);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should reject promise with exception","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":208,"column":44},"line":208,"code":"    it('should reject promise with exception', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .evaluate(() => {\n          // @ts-expect-error we know the object doesn't exist\n          return notExistingObject.property;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('notExistingObject');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should support thrown strings as error messages","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":223,"column":55},"line":223,"code":"    it('should support thrown strings as error messages', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .evaluate(() => {\n          throw 'qwerty';\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('qwerty');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should support thrown numbers as error messages","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":237,"column":55},"line":237,"code":"    it('should support thrown numbers as error messages', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .evaluate(() => {\n          throw 100500;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n      expect(error.message).toContain('100500');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return complex objects","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":251,"column":37},"line":251,"code":"    it('should return complex objects', async () => {\n      const {page} = getTestState();\n\n      const object = {foo: 'bar!'};\n      const result = await page.evaluate(a => {\n        return a;\n      }, object);\n      expect(result).not.toBe(object);\n      expect(result).toEqual(object);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return NaN","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":269,"column":25},"line":269,"code":"    it('should return NaN', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return NaN;\n      });\n      expect(Object.is(result, NaN)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return -0","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":277,"column":24},"line":277,"code":"    it('should return -0', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return -0;\n      });\n      expect(Object.is(result, -0)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":285,"column":30},"line":285,"code":"    it('should return Infinity', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return Infinity;\n      });\n      expect(Object.is(result, Infinity)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return -Infinity","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":293,"column":31},"line":293,"code":"    it('should return -Infinity', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return -Infinity;\n      });\n      expect(Object.is(result, -Infinity)).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept \"null\" as one of multiple parameters","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":301,"column":58},"line":301,"code":"    it('should accept \"null\" as one of multiple parameters', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(\n        (a, b) => {\n          return Object.is(a, null) && Object.is(b, 'foo');\n        },\n        null,\n        'foo'\n      );\n      expect(result).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should properly serialize null fields","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":313,"column":45},"line":313,"code":"    it('should properly serialize null fields', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return {a: undefined};\n        })\n      ).toEqual({});\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined for non-serializable objects","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":322,"column":60},"line":322,"code":"    it('should return undefined for non-serializable objects', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return window;\n        })\n      ).toBe(undefined);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should return promise as empty object","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":331,"column":45},"line":331,"code":"    it('should return promise as empty object', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        return {\n          promise: new Promise(resolve => {\n            setTimeout(resolve, 1000);\n          }),\n        };\n      });\n      expect(result).toEqual({\n        promise: {},\n      });\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail for circular object","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":345,"column":39},"line":345,"code":"    it('should fail for circular object', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        const a: {[x: string]: any} = {};\n        const b = {a};\n        a['b'] = b;\n        return a;\n      });\n      expect(result).toBe(undefined);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to throw a tricky error","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":356,"column":46},"line":356,"code":"    it('should be able to throw a tricky error', async () => {\n      const {page} = getTestState();\n\n      const windowHandle = await page.evaluateHandle(() => {\n        return window;\n      });\n      const errorText = await windowHandle.jsonValue().catch(error_ => {\n        return error_.message;\n      });\n      const error = await page\n        .evaluate(errorText => {\n          throw new Error(errorText);\n        }, errorText)\n        .catch(error_ => {\n          return error_;\n        });\n      expect(error.message).toContain(errorText);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":374,"column":30},"line":374,"code":"    it('should accept a string', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate('1 + 2');\n      expect(result).toBe(3);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string with semi colons","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":380,"column":47},"line":380,"code":"    it('should accept a string with semi colons', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate('1 + 5;');\n      expect(result).toBe(6);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string with comments","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":386,"column":44},"line":386,"code":"    it('should accept a string with comments', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate('2 + 5;\\n// do some math!');\n      expect(result).toBe(7);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should accept element handle as an argument","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":392,"column":51},"line":392,"code":"    it('should accept element handle as an argument', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>42</section>');\n      const element = (await page.$('section'))!;\n      const text = await page.evaluate(e => {\n        return e.textContent;\n      }, element);\n      expect(text).toBe('42');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if underlying element was disposed","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":402,"column":55},"line":402,"code":"    it('should throw if underlying element was disposed', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>39</section>');\n      const element = (await page.$('section'))!;\n      expect(element).toBeTruthy();\n      await element.dispose();\n      let error!: Error;\n      await page\n        .evaluate((e: HTMLElement) => {\n          return e.textContent;\n        }, element)\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain('JSHandle is disposed');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if elementHandles are from other frames","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":419,"column":60},"line":419,"code":"    it('should throw if elementHandles are from other frames', async () => {\n      const {page, server} = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const bodyHandle = await page.frames()[1]!.$('body');\n      let error!: Error;\n      await page\n        .evaluate(body => {\n          return body?.innerHTML;\n        }, bodyHandle)\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n      expect(error.message).toContain(\n        'JSHandles can be evaluated only in the context they were created'\n      );\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should simulate a user gesture","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":437,"column":38},"line":437,"code":"    it('should simulate a user gesture', async () => {\n      const {page} = getTestState();\n\n      const result = await page.evaluate(() => {\n        document.body.appendChild(document.createTextNode('test'));\n        document.execCommand('selectAll');\n        return document.execCommand('copy');\n      });\n      expect(result).toBe(true);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a nice error after a navigation","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":447,"column":52},"line":447,"code":"    it('should throw a nice error after a navigation', async () => {\n      const {page} = getTestState();\n\n      const executionContext = await page.mainFrame().executionContext();\n\n      await Promise.all([\n        page.waitForNavigation(),\n        executionContext.evaluate(() => {\n          return window.location.reload();\n        }),\n      ]);\n      const error = await executionContext\n        .evaluate(() => {\n          return null;\n        })\n        .catch(error_ => {\n          return error_;\n        });\n      expect((error as Error).message).toContain('navigation');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw an error when evaluation does a navigation","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":467,"column":67},"line":467,"code":"    it('should not throw an error when evaluation does a navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/one-style.html');\n      const result = await page.evaluate(() => {\n        (window as any).location = '/empty.html';\n        return [42];\n      });\n      expect(result).toEqual([42]);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should transfer 100Mb of data from page to node.js","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":477,"column":58},"line":477,"code":"    it('should transfer 100Mb of data from page to node.js', async function () {\n      const {page} = getTestState();\n\n      const a = await page.evaluate(() => {\n        return Array(100 * 1024 * 1024 + 1).join('a');\n      });\n      expect(a.length).toBe(100 * 1024 * 1024);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error with detailed information on exception inside promise ","suites":["Evaluation specs","Page.evaluate"],"updatePoint":{"line":485,"column":81},"line":485,"code":"    it('should throw error with detailed information on exception inside promise ', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .evaluate(() => {\n          return new Promise(() => {\n            throw new Error('Error in promise');\n          });\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain('Error in promise');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate before anything else on the page","suites":["Evaluation specs","Page.evaluateOnNewDocument"],"updatePoint":{"line":503,"column":56},"line":503,"code":"    it('should evaluate before anything else on the page', async () => {\n      const {page, server} = getTestState();\n\n      await page.evaluateOnNewDocument(function () {\n        (globalThis as any).injected = 123;\n      });\n      await page.goto(server.PREFIX + '/tamperable.html');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result;\n        })\n      ).toBe(123);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with CSP","suites":["Evaluation specs","Page.evaluateOnNewDocument"],"updatePoint":{"line":516,"column":28},"line":516,"code":"    it('should work with CSP', async () => {\n      const {page, server} = getTestState();\n\n      server.setCSP('/empty.html', 'script-src ' + server.PREFIX);\n      await page.evaluateOnNewDocument(function () {\n        (globalThis as any).injected = 123;\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).injected;\n        })\n      ).toBe(123);\n\n      // Make sure CSP works.\n      await page.addScriptTag({content: 'window.e = 10;'}).catch(error => {\n        return void error;\n      });\n      expect(\n        await page.evaluate(() => {\n          return (window as any).e;\n        })\n      ).toBe(undefined);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should have different execution contexts","suites":["Evaluation specs","Frame.evaluate"],"updatePoint":{"line":543,"column":48},"line":543,"code":"    it('should have different execution contexts', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      expect(page.frames().length).toBe(2);\n      await page.frames()[0]!.evaluate(() => {\n        return ((globalThis as any).FOO = 'foo');\n      });\n      await page.frames()[1]!.evaluate(() => {\n        return ((globalThis as any).FOO = 'bar');\n      });\n      expect(\n        await page.frames()[0]!.evaluate(() => {\n          return (globalThis as any).FOO;\n        })\n      ).toBe('foo');\n      expect(\n        await page.frames()[1]!.evaluate(() => {\n          return (globalThis as any).FOO;\n        })\n      ).toBe('bar');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should have correct execution contexts","suites":["Evaluation specs","Frame.evaluate"],"updatePoint":{"line":566,"column":46},"line":566,"code":"    it('should have correct execution contexts', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      expect(page.frames().length).toBe(2);\n      expect(\n        await page.frames()[0]!.evaluate(() => {\n          return document.body.textContent!.trim();\n        })\n      ).toBe('');\n      expect(\n        await page.frames()[1]!.evaluate(() => {\n          return document.body.textContent!.trim();\n        })\n      ).toBe(`Hi, I'm frame`);\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":"should execute after cross-site navigation","suites":["Evaluation specs","Frame.evaluate"],"updatePoint":{"line":582,"column":50},"line":582,"code":"    it('should execute after cross-site navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      expect(\n        await mainFrame.evaluate(() => {\n          return window.location.href;\n        })\n      ).toContain('localhost');\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/empty.html');\n      expect(\n        await mainFrame.evaluate(() => {\n          return window.location.href;\n        })\n      ).toContain('127');\n    });","file":"src/evaluation.spec.ts","skipped":false,"dir":"test"},{"name":": adds an event listener that is fired when the event is emitted","suites":["EventEmitter","on"],"updatePoint":{"line":30,"column":87},"line":30,"code":"      it(`${methodName}: adds an event listener that is fired when the event is emitted`, () => {\n        const listener = sinon.spy();\n        emitter[methodName]('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n      });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":" sends the event data to the handler","suites":["EventEmitter","on"],"updatePoint":{"line":37,"column":59},"line":37,"code":"      it(`${methodName} sends the event data to the handler`, () => {\n        const listener = sinon.spy();\n        const data = {};\n        emitter[methodName]('foo', listener);\n        emitter.emit('foo', data);\n        expect(listener.callCount).toEqual(1);\n        expect(listener.firstCall.args[0]!).toBe(data);\n      });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": supports chaining","suites":["EventEmitter","on"],"updatePoint":{"line":46,"column":42},"line":46,"code":"      it(`${methodName}: supports chaining`, () => {\n        const listener = sinon.spy();\n        const returnValue = emitter[methodName]('foo', listener);\n        expect(returnValue).toBe(emitter);\n      });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": removes the listener so it is no longer called","suites":["EventEmitter","off"],"updatePoint":{"line":59,"column":71},"line":59,"code":"      it(`${methodName}: removes the listener so it is no longer called`, () => {\n        const listener = sinon.spy();\n        emitter.on('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n        emitter.off('foo', listener);\n        emitter.emit('foo');\n        expect(listener.callCount).toEqual(1);\n      });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":": supports chaining","suites":["EventEmitter","off"],"updatePoint":{"line":69,"column":42},"line":69,"code":"      it(`${methodName}: supports chaining`, () => {\n        const listener = sinon.spy();\n        emitter.on('foo', listener);\n        const returnValue = emitter.off('foo', listener);\n        expect(returnValue).toBe(emitter);\n      });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"only calls the listener once and then removes it","suites":["EventEmitter","once"],"updatePoint":{"line":82,"column":56},"line":82,"code":"    it('only calls the listener once and then removes it', () => {\n      const listener = sinon.spy();\n      emitter.once('foo', listener);\n      emitter.emit('foo');\n      expect(listener.callCount).toEqual(1);\n      emitter.emit('foo');\n      expect(listener.callCount).toEqual(1);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"supports chaining","suites":["EventEmitter","once"],"updatePoint":{"line":91,"column":25},"line":91,"code":"    it('supports chaining', () => {\n      const listener = sinon.spy();\n      const returnValue = emitter.once('foo', listener);\n      expect(returnValue).toBe(emitter);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"calls all the listeners for an event","suites":["EventEmitter","emit"],"updatePoint":{"line":99,"column":44},"line":99,"code":"    it('calls all the listeners for an event', () => {\n      const listener1 = sinon.spy();\n      const listener2 = sinon.spy();\n      const listener3 = sinon.spy();\n      emitter.on('foo', listener1).on('foo', listener2).on('bar', listener3);\n\n      emitter.emit('foo');\n\n      expect(listener1.callCount).toEqual(1);\n      expect(listener2.callCount).toEqual(1);\n      expect(listener3.callCount).toEqual(0);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"passes data through to the listener","suites":["EventEmitter","emit"],"updatePoint":{"line":112,"column":43},"line":112,"code":"    it('passes data through to the listener', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      const data = {};\n\n      emitter.emit('foo', data);\n      expect(listener.callCount).toEqual(1);\n      expect(listener.firstCall.args[0]!).toBe(data);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns true if the event has listeners","suites":["EventEmitter","emit"],"updatePoint":{"line":122,"column":47},"line":122,"code":"    it('returns true if the event has listeners', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      expect(emitter.emit('foo')).toBe(true);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns false if the event has listeners","suites":["EventEmitter","emit"],"updatePoint":{"line":128,"column":48},"line":128,"code":"    it('returns false if the event has listeners', () => {\n      const listener = sinon.spy();\n      emitter.on('foo', listener);\n      expect(emitter.emit('notFoo')).toBe(false);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns the number of listeners for the given event","suites":["EventEmitter","listenerCount"],"updatePoint":{"line":136,"column":59},"line":136,"code":"    it('returns the number of listeners for the given event', () => {\n      emitter.on('foo', () => {});\n      emitter.on('foo', () => {});\n      emitter.on('bar', () => {});\n      expect(emitter.listenerCount('foo')).toEqual(2);\n      expect(emitter.listenerCount('bar')).toEqual(1);\n      expect(emitter.listenerCount('noListeners')).toEqual(0);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"removes every listener from all events by default","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":147,"column":57},"line":147,"code":"    it('removes every listener from all events by default', () => {\n      emitter.on('foo', () => {}).on('bar', () => {});\n\n      emitter.removeAllListeners();\n      expect(emitter.emit('foo')).toBe(false);\n      expect(emitter.emit('bar')).toBe(false);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"returns the emitter for chaining","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":155,"column":40},"line":155,"code":"    it('returns the emitter for chaining', () => {\n      expect(emitter.removeAllListeners()).toBe(emitter);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"can filter to remove only listeners for a given event name","suites":["EventEmitter","removeAllListeners"],"updatePoint":{"line":159,"column":66},"line":159,"code":"    it('can filter to remove only listeners for a given event name', () => {\n      emitter\n        .on('foo', () => {})\n        .on('bar', () => {})\n        .on('bar', () => {});\n\n      emitter.removeAllListeners('bar');\n      expect(emitter.emit('foo')).toBe(true);\n      expect(emitter.emit('bar')).toBe(false);\n    });","file":"src/EventEmitter.spec.ts","skipped":false,"dir":"test"},{"name":"dumpio option should work with pipe option","suites":["Fixtures"],"updatePoint":{"line":25,"column":48},"line":25,"code":"  it('dumpio option should work with pipe option', async () => {\n    const {defaultBrowserOptions, puppeteerPath, headless} = getTestState();\n    if (headless === 'new') {\n      // This test only works in the old headless mode.\n      return;\n    }\n\n    let dumpioData = '';\n    const {spawn} = await import('child_process');\n    const options = Object.assign({}, defaultBrowserOptions, {\n      pipe: true,\n      dumpio: true,\n    });\n    const res = spawn('node', [\n      path.join(__dirname, '../fixtures', 'dumpio.js'),\n      puppeteerPath,\n      JSON.stringify(options),\n    ]);\n    res.stderr.on('data', data => {\n      return (dumpioData += data.toString('utf8'));\n    });\n    await new Promise(resolve => {\n      return res.on('close', resolve);\n    });\n    expect(dumpioData).toContain('message from dumpio');\n  });","file":"src/fixtures.spec.ts","skipped":false,"dir":"test"},{"name":"should dump browser process stderr","suites":["Fixtures"],"updatePoint":{"line":51,"column":40},"line":51,"code":"  it('should dump browser process stderr', async () => {\n    const {defaultBrowserOptions, puppeteerPath} = getTestState();\n\n    let dumpioData = '';\n    const {spawn} = await import('child_process');\n    const options = Object.assign({}, defaultBrowserOptions, {dumpio: true});\n    const res = spawn('node', [\n      path.join(__dirname, '../fixtures', 'dumpio.js'),\n      puppeteerPath,\n      JSON.stringify(options),\n    ]);\n    res.stderr.on('data', data => {\n      return (dumpioData += data.toString('utf8'));\n    });\n    await new Promise(resolve => {\n      return res.on('close', resolve);\n    });\n    expect(dumpioData).toContain('DevTools listening on ws://');\n  });","file":"src/fixtures.spec.ts","skipped":false,"dir":"test"},{"name":"should close the browser when the node process closes","suites":["Fixtures"],"updatePoint":{"line":70,"column":59},"line":70,"code":"  it('should close the browser when the node process closes', async () => {\n    const {defaultBrowserOptions, puppeteerPath, puppeteer} = getTestState();\n\n    const {spawn, execSync} = await import('child_process');\n    const options = Object.assign({}, defaultBrowserOptions, {\n      // Disable DUMPIO to cleanly read stdout.\n      dumpio: false,\n    });\n    const res = spawn('node', [\n      path.join(__dirname, '../fixtures', 'closeme.js'),\n      puppeteerPath,\n      JSON.stringify(options),\n    ]);\n    let wsEndPointCallback: (value: string) => void;\n    const wsEndPointPromise = new Promise<string>(x => {\n      return (wsEndPointCallback = x);\n    });\n    let output = '';\n    res.stdout.on('data', data => {\n      output += data;\n      if (output.indexOf('\\n')) {\n        wsEndPointCallback(output.substring(0, output.indexOf('\\n')));\n      }\n    });\n    const browser = await puppeteer.connect({\n      browserWSEndpoint: await wsEndPointPromise,\n    });\n    const promises = [\n      new Promise(resolve => {\n        return browser.once('disconnected', resolve);\n      }),\n      new Promise(resolve => {\n        return res.on('close', resolve);\n      }),\n    ];\n    if (process.platform === 'win32') {\n      execSync(`taskkill /pid ${res.pid} /T /F`);\n    } else {\n      process.kill(res.pid!);\n    }\n    await Promise.all(promises);\n  });","file":"src/fixtures.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Frame specs","Frame.executionContext"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      expect(page.frames().length).toBe(2);\n      const [frame1, frame2] = page.frames();\n      const context1 = await frame1!.executionContext();\n      const context2 = await frame2!.executionContext();\n      expect(context1).toBeTruthy();\n      expect(context2).toBeTruthy();\n      expect(context1 !== context2).toBeTruthy();\n      expect(context1._world?.frame()).toBe(frame1);\n      expect(context2._world?.frame()).toBe(frame2);\n\n      await Promise.all([\n        context1.evaluate(() => {\n          return ((globalThis as any).a = 1);\n        }),\n        context2.evaluate(() => {\n          return ((globalThis as any).a = 2);\n        }),\n      ]);\n      const [a1, a2] = await Promise.all([\n        context1.evaluate(() => {\n          return (globalThis as any).a;\n        }),\n        context2.evaluate(() => {\n          return (globalThis as any).a;\n        }),\n      ]);\n      expect(a1).toBe(1);\n      expect(a2).toBe(2);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Frame specs","Frame.evaluateHandle"],"updatePoint":{"line":69,"column":19},"line":69,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      const windowHandle = await mainFrame.evaluateHandle(() => {\n        return window;\n      });\n      expect(windowHandle).toBeTruthy();\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for detached frames","suites":["Frame specs","Frame.evaluate"],"updatePoint":{"line":82,"column":40},"line":82,"code":"    it('should throw for detached frames', async () => {\n      const {page, server} = getTestState();\n\n      const frame1 = (await utils.attachFrame(\n        page,\n        'frame1',\n        server.EMPTY_PAGE\n      ))!;\n      await utils.detachFrame(page, 'frame1');\n      let error!: Error;\n      await frame1\n        .evaluate(() => {\n          return 7 * 8;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain(\n        'Execution context is not available in detached frame'\n      );\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"allows readonly array to be an argument","suites":["Frame specs","Frame.evaluate"],"updatePoint":{"line":104,"column":47},"line":104,"code":"    it('allows readonly array to be an argument', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n\n      // This test checks if Frame.evaluate allows a readonly array to be an argument.\n      // See https://github.com/puppeteer/puppeteer/issues/6953.\n      const readonlyArray: readonly string[] = ['a', 'b', 'c'];\n      await mainFrame.evaluate(arr => {\n        return arr;\n      }, readonlyArray);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should retrieve the page from a frame","suites":["Frame specs","Frame.page"],"updatePoint":{"line":119,"column":45},"line":119,"code":"    it('should retrieve the page from a frame', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      expect(mainFrame.page()).toEqual(page);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should handle nested frames","suites":["Frame specs","Frame Management"],"updatePoint":{"line":128,"column":35},"line":128,"code":"    it('should handle nested frames', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      expect(dumpFrames(page.mainFrame())).toEqual([\n        'http://localhost:<PORT>/frames/nested-frames.html',\n        '    http://localhost:<PORT>/frames/two-frames.html (2frames)',\n        '        http://localhost:<PORT>/frames/frame.html (uno)',\n        '        http://localhost:<PORT>/frames/frame.html (dos)',\n        '    http://localhost:<PORT>/frames/frame.html (aframe)',\n      ]);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should send events when frames are manipulated dynamically","suites":["Frame specs","Frame Management"],"updatePoint":{"line":140,"column":66},"line":140,"code":"    it('should send events when frames are manipulated dynamically', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      // validate frameattached events\n      const attachedFrames: Frame[] = [];\n      page.on('frameattached', frame => {\n        return attachedFrames.push(frame);\n      });\n      await utils.attachFrame(page, 'frame1', './assets/frame.html');\n      expect(attachedFrames.length).toBe(1);\n      expect(attachedFrames[0]!.url()).toContain('/assets/frame.html');\n\n      // validate framenavigated events\n      const navigatedFrames: Frame[] = [];\n      page.on('framenavigated', frame => {\n        return navigatedFrames.push(frame);\n      });\n      await utils.navigateFrame(page, 'frame1', './empty.html');\n      expect(navigatedFrames.length).toBe(1);\n      expect(navigatedFrames[0]!.url()).toBe(server.EMPTY_PAGE);\n\n      // validate framedetached events\n      const detachedFrames: Frame[] = [];\n      page.on('framedetached', frame => {\n        return detachedFrames.push(frame);\n      });\n      await utils.detachFrame(page, 'frame1');\n      expect(detachedFrames.length).toBe(1);\n      expect(detachedFrames[0]!.isDetached()).toBe(true);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should send \"framenavigated\" when navigating on anchor URLs","suites":["Frame specs","Frame Management"],"updatePoint":{"line":171,"column":67},"line":171,"code":"    it('should send \"framenavigated\" when navigating on anchor URLs', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await Promise.all([\n        page.goto(server.EMPTY_PAGE + '#foo'),\n        utils.waitEvent(page, 'framenavigated'),\n      ]);\n      expect(page.url()).toBe(server.EMPTY_PAGE + '#foo');\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should persist mainFrame on cross-process navigation","suites":["Frame specs","Frame Management"],"updatePoint":{"line":181,"column":60},"line":181,"code":"    it('should persist mainFrame on cross-process navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const mainFrame = page.mainFrame();\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/empty.html');\n      expect(page.mainFrame() === mainFrame).toBeTruthy();\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should not send attach/detach events for main frame","suites":["Frame specs","Frame Management"],"updatePoint":{"line":189,"column":59},"line":189,"code":"    it('should not send attach/detach events for main frame', async () => {\n      const {page, server} = getTestState();\n\n      let hasEvents = false;\n      page.on('frameattached', () => {\n        return (hasEvents = true);\n      });\n      page.on('framedetached', () => {\n        return (hasEvents = true);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(hasEvents).toBe(false);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should detach child frames on navigation","suites":["Frame specs","Frame Management"],"updatePoint":{"line":202,"column":48},"line":202,"code":"    it('should detach child frames on navigation', async () => {\n      const {page, server} = getTestState();\n\n      let attachedFrames = [];\n      let detachedFrames = [];\n      let navigatedFrames = [];\n      page.on('frameattached', frame => {\n        return attachedFrames.push(frame);\n      });\n      page.on('framedetached', frame => {\n        return detachedFrames.push(frame);\n      });\n      page.on('framenavigated', frame => {\n        return navigatedFrames.push(frame);\n      });\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      expect(attachedFrames.length).toBe(4);\n      expect(detachedFrames.length).toBe(0);\n      expect(navigatedFrames.length).toBe(5);\n\n      attachedFrames = [];\n      detachedFrames = [];\n      navigatedFrames = [];\n      await page.goto(server.EMPTY_PAGE);\n      expect(attachedFrames.length).toBe(0);\n      expect(detachedFrames.length).toBe(4);\n      expect(navigatedFrames.length).toBe(1);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should support framesets","suites":["Frame specs","Frame Management"],"updatePoint":{"line":230,"column":32},"line":230,"code":"    it('should support framesets', async () => {\n      const {page, server} = getTestState();\n\n      let attachedFrames = [];\n      let detachedFrames = [];\n      let navigatedFrames = [];\n      page.on('frameattached', frame => {\n        return attachedFrames.push(frame);\n      });\n      page.on('framedetached', frame => {\n        return detachedFrames.push(frame);\n      });\n      page.on('framenavigated', frame => {\n        return navigatedFrames.push(frame);\n      });\n      await page.goto(server.PREFIX + '/frames/frameset.html');\n      expect(attachedFrames.length).toBe(4);\n      expect(detachedFrames.length).toBe(0);\n      expect(navigatedFrames.length).toBe(5);\n\n      attachedFrames = [];\n      detachedFrames = [];\n      navigatedFrames = [];\n      await page.goto(server.EMPTY_PAGE);\n      expect(attachedFrames.length).toBe(0);\n      expect(detachedFrames.length).toBe(4);\n      expect(navigatedFrames.length).toBe(1);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should report frame from-inside shadow DOM","suites":["Frame specs","Frame Management"],"updatePoint":{"line":258,"column":50},"line":258,"code":"    it('should report frame from-inside shadow DOM', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/shadow.html');\n      await page.evaluate(async (url: string) => {\n        const frame = document.createElement('iframe');\n        frame.src = url;\n        document.body.shadowRoot!.appendChild(frame);\n        await new Promise(x => {\n          return (frame.onload = x);\n        });\n      }, server.EMPTY_PAGE);\n      expect(page.frames().length).toBe(2);\n      expect(page.frames()[1]!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should report frame.name()","suites":["Frame specs","Frame Management"],"updatePoint":{"line":273,"column":34},"line":273,"code":"    it('should report frame.name()', async () => {\n      const {page, server} = getTestState();\n\n      await utils.attachFrame(page, 'theFrameId', server.EMPTY_PAGE);\n      await page.evaluate((url: string) => {\n        const frame = document.createElement('iframe');\n        frame.name = 'theFrameName';\n        frame.src = url;\n        document.body.appendChild(frame);\n        return new Promise(x => {\n          return (frame.onload = x);\n        });\n      }, server.EMPTY_PAGE);\n      expect(page.frames()[0]!.name()).toBe('');\n      expect(page.frames()[1]!.name()).toBe('theFrameId');\n      expect(page.frames()[2]!.name()).toBe('theFrameName');\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should report frame.parent()","suites":["Frame specs","Frame Management"],"updatePoint":{"line":290,"column":36},"line":290,"code":"    it('should report frame.parent()', async () => {\n      const {page, server} = getTestState();\n\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame2', server.EMPTY_PAGE);\n      expect(page.frames()[0]!.parentFrame()).toBe(null);\n      expect(page.frames()[1]!.parentFrame()).toBe(page.mainFrame());\n      expect(page.frames()[2]!.parentFrame()).toBe(page.mainFrame());\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should report different frame instance when frame re-attaches","suites":["Frame specs","Frame Management"],"updatePoint":{"line":299,"column":69},"line":299,"code":"    it('should report different frame instance when frame re-attaches', async () => {\n      const {page, server} = getTestState();\n\n      const frame1 = await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        (globalThis as any).frame = document.querySelector('#frame1');\n        (globalThis as any).frame.remove();\n      });\n      expect(frame1!.isDetached()).toBe(true);\n      const [frame2] = await Promise.all([\n        utils.waitEvent(page, 'frameattached'),\n        page.evaluate(() => {\n          return document.body.appendChild((globalThis as any).frame);\n        }),\n      ]);\n      expect(frame2.isDetached()).toBe(false);\n      expect(frame1).not.toBe(frame2);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should support url fragment","suites":["Frame specs","Frame Management"],"updatePoint":{"line":317,"column":35},"line":317,"code":"    it('should support url fragment', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame-url-fragment.html');\n\n      expect(page.frames().length).toBe(2);\n      expect(page.frames()[1]!.url()).toBe(\n        server.PREFIX + '/frames/frame.html?param=value#fragment'\n      );\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should support lazy frames","suites":["Frame specs","Frame Management"],"updatePoint":{"line":327,"column":34},"line":327,"code":"    it('should support lazy frames', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 1000, height: 1000});\n      await page.goto(server.PREFIX + '/frames/lazy-frame.html');\n\n      expect(\n        page.frames().map(frame => {\n          return frame._hasStartedLoading;\n        })\n      ).toEqual([true, true, false]);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"should return the client instance","suites":["Frame specs","Frame.client"],"updatePoint":{"line":342,"column":41},"line":342,"code":"    it('should return the client instance', async () => {\n      const {page} = getTestState();\n      expect(page.mainFrame()._client()).toBeInstanceOf(CDPSession);\n    });","file":"src/frame.spec.ts","skipped":false,"dir":"test"},{"name":"background_page target type should be available","suites":["headful tests","HEADFUL"],"updatePoint":{"line":118,"column":55},"line":118,"code":"    it('background_page target type should be available', async () => {\n      const {puppeteer} = getTestState();\n      const browserWithExtension = await launchBrowser(\n        puppeteer,\n        extensionOptions\n      );\n      const page = await browserWithExtension.newPage();\n      const backgroundPageTarget = await browserWithExtension.waitForTarget(\n        target => {\n          return target.type() === 'background_page';\n        }\n      );\n      await page.close();\n      await browserWithExtension.close();\n      expect(backgroundPageTarget).toBeTruthy();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"service_worker target type should be available","suites":["headful tests","HEADFUL"],"updatePoint":{"line":134,"column":54},"line":134,"code":"    it('service_worker target type should be available', async () => {\n      const {puppeteer, defaultBrowserOptions} = getTestState();\n      const browserWithExtension = await launchBrowser(puppeteer, {\n        ...defaultBrowserOptions,\n        headless: false,\n        args: [\n          `--disable-extensions-except=${serviceWorkerExtensionPath}`,\n          `--load-extension=${serviceWorkerExtensionPath}`,\n        ],\n      });\n      const page = await browserWithExtension.newPage();\n      const serviceWorkerTarget = await browserWithExtension.waitForTarget(\n        target => {\n          return target.type() === 'service_worker';\n        }\n      );\n      await page.close();\n      await browserWithExtension.close();\n      expect(serviceWorkerTarget).toBeTruthy();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"target.page() should return a background_page","suites":["headful tests","HEADFUL"],"updatePoint":{"line":154,"column":53},"line":154,"code":"    it('target.page() should return a background_page', async function () {\n      const {puppeteer} = getTestState();\n      const browserWithExtension = await launchBrowser(\n        puppeteer,\n        extensionOptions\n      );\n      const backgroundPageTarget = await browserWithExtension.waitForTarget(\n        target => {\n          return target.type() === 'background_page';\n        }\n      );\n      const page = (await backgroundPageTarget.page())!;\n      expect(\n        await page.evaluate(() => {\n          return 2 * 3;\n        })\n      ).toBe(6);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).MAGIC;\n        })\n      ).toBe(42);\n      await browserWithExtension.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"target.page() should return a DevTools page if custom isPageTarget is provided","suites":["headful tests","HEADFUL"],"updatePoint":{"line":178,"column":86},"line":178,"code":"    it('target.page() should return a DevTools page if custom isPageTarget is provided', async function () {\n      const {puppeteer} = getTestState();\n      const originalBrowser = await launchBrowser(puppeteer, devtoolsOptions);\n\n      const browserWSEndpoint = originalBrowser.wsEndpoint();\n\n      const browser = await puppeteer.connect({\n        browserWSEndpoint,\n        _isPageTarget(target) {\n          return (\n            target.type === 'other' && target.url.startsWith('devtools://')\n          );\n        },\n      });\n      const devtoolsPageTarget = await browser.waitForTarget(target => {\n        return target.type() === 'other';\n      });\n      const page = (await devtoolsPageTarget.page())!;\n      expect(\n        await page.evaluate(() => {\n          return 2 * 3;\n        })\n      ).toBe(6);\n      expect(await browser.pages()).toContainEqual(page);\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"should have default url when launching browser","suites":["headful tests","HEADFUL"],"updatePoint":{"line":204,"column":54},"line":204,"code":"    it('should have default url when launching browser', async function () {\n      const {puppeteer} = getTestState();\n      const browser = await launchBrowser(puppeteer, extensionOptions);\n      const pages = (await browser.pages()).map((page: {url: () => any}) => {\n        return page.url();\n      });\n      expect(pages).toEqual(['about:blank']);\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"headless should be able to read cookies written by headful","suites":["headful tests","HEADFUL"],"updatePoint":{"line":213,"column":66},"line":213,"code":"    it('headless should be able to read cookies written by headful', async () => {\n      /* Needs investigation into why but this fails consistently on Windows CI. */\n      const {server, puppeteer} = getTestState();\n\n      const userDataDir = await mkdtempAsync(TMP_FOLDER);\n      // Write a cookie in headful chrome\n      const headfulBrowser = await launchBrowser(\n        puppeteer,\n        Object.assign({userDataDir}, headfulOptions)\n      );\n      const headfulPage = await headfulBrowser.newPage();\n      await headfulPage.goto(server.EMPTY_PAGE);\n      await headfulPage.evaluate(() => {\n        return (document.cookie =\n          'foo=true; expires=Fri, 31 Dec 9999 23:59:59 GMT');\n      });\n      await headfulBrowser.close();\n      // Read the cookie from headless chrome\n      const headlessBrowser = await launchBrowser(\n        puppeteer,\n        Object.assign({userDataDir}, headlessOptions)\n      );\n      const headlessPage = await headlessBrowser.newPage();\n      await headlessPage.goto(server.EMPTY_PAGE);\n      const cookie = await headlessPage.evaluate(() => {\n        return document.cookie;\n      });\n      await headlessBrowser.close();\n      // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n      await rmAsync(userDataDir).catch(() => {});\n      expect(cookie).toBe('foo=true');\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"OOPIF: should report google.com frame","suites":["headful tests","HEADFUL"],"line":246,"code":"    it.skip('OOPIF: should report google.com frame', async () => {","file":"src/headful.spec.ts","skipped":true,"dir":"test"},{"name":"OOPIF: should expose events within OOPIFs","suites":["headful tests","HEADFUL"],"updatePoint":{"line":275,"column":49},"line":275,"code":"    it('OOPIF: should expose events within OOPIFs', async () => {\n      const {server, puppeteer} = getTestState();\n\n      const browser = await launchBrowser(puppeteer, forcedOopifOptions);\n      const page = await browser.newPage();\n\n      // Setup our session listeners to observe OOPIF activity.\n      const session = await page.target().createCDPSession();\n      const networkEvents: any[] = [];\n      const otherSessions: any[] = [];\n      await session.send('Target.setAutoAttach', {\n        autoAttach: true,\n        flatten: true,\n        waitForDebuggerOnStart: true,\n      });\n      session.on(\n        'sessionattached',\n        async (session: {\n          on: (arg0: string, arg1: (params: any) => number) => void;\n          send: (arg0: string) => any;\n        }) => {\n          otherSessions.push(session);\n\n          session.on('Network.requestWillBeSent', (params: any) => {\n            return networkEvents.push(params);\n          });\n          await session.send('Network.enable');\n          await session.send('Runtime.runIfWaitingForDebugger');\n        }\n      );\n\n      // Navigate to the empty page and add an OOPIF iframe with at least one request.\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate((frameUrl: string) => {\n        const frame = document.createElement('iframe');\n        frame.setAttribute('src', frameUrl);\n        document.body.appendChild(frame);\n        return new Promise((x, y) => {\n          frame.onload = x;\n          frame.onerror = y;\n        });\n      }, server.PREFIX.replace('localhost', 'oopifdomain') + '/one-style.html');\n      await page.waitForSelector('iframe');\n\n      // Ensure we found the iframe session.\n      expect(otherSessions).toHaveLength(1);\n\n      // Resume the iframe and trigger another request.\n      const iframeSession = otherSessions[0]!;\n      await iframeSession.send('Runtime.evaluate', {\n        expression: `fetch('/fetch')`,\n        awaitPromise: true,\n      });\n      await browser.close();\n\n      const requests = networkEvents.map(event => {\n        return event.request.url;\n      });\n      expect(requests).toContain(`http://oopifdomain:${server.PORT}/fetch`);\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"should close browser with beforeunload page","suites":["headful tests","HEADFUL"],"updatePoint":{"line":335,"column":51},"line":335,"code":"    it('should close browser with beforeunload page', async () => {\n      const {server, puppeteer} = getTestState();\n\n      const browser = await launchBrowser(puppeteer, headfulOptions);\n      const page = await browser.newPage();\n      await page.goto(server.PREFIX + '/beforeunload.html');\n      // We have to interact with a page so that 'beforeunload' handlers\n      // fire.\n      await page.click('body');\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"should open devtools when \"devtools: true\" option is given","suites":["headful tests","HEADFUL"],"updatePoint":{"line":346,"column":66},"line":346,"code":"    it('should open devtools when \"devtools: true\" option is given', async () => {\n      const {puppeteer} = getTestState();\n\n      const browser = await launchBrowser(\n        puppeteer,\n        Object.assign({devtools: true}, headfulOptions)\n      );\n      const context = await browser.createIncognitoBrowserContext();\n      await Promise.all([\n        context.newPage(),\n        browser.waitForTarget((target: {url: () => string | string[]}) => {\n          return target.url().includes('devtools://');\n        }),\n      ]);\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["headful tests","Page.bringToFront"],"updatePoint":{"line":365,"column":19},"line":365,"code":"    it('should work', async () => {\n      const {puppeteer} = getTestState();\n      const browser = await launchBrowser(puppeteer, headfulOptions);\n      const page1 = await browser.newPage();\n      const page2 = await browser.newPage();\n\n      await page1.bringToFront();\n      expect(\n        await page1.evaluate(() => {\n          return document.visibilityState;\n        })\n      ).toBe('visible');\n      expect(\n        await page2.evaluate(() => {\n          return document.visibilityState;\n        })\n      ).toBe('hidden');\n\n      await page2.bringToFront();\n      expect(\n        await page1.evaluate(() => {\n          return document.visibilityState;\n        })\n      ).toBe('hidden');\n      expect(\n        await page2.evaluate(() => {\n          return document.visibilityState;\n        })\n      ).toBe('visible');\n\n      await page1.close();\n      await page2.close();\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel in multiple pages","suites":["headful tests","Page.screenshot"],"updatePoint":{"line":402,"column":48},"line":402,"code":"    it('should run in parallel in multiple pages', async () => {\n      const {server, puppeteer} = getTestState();\n      const browser = await puppeteer.launch(headfulOptions);\n      const context = await browser.createIncognitoBrowserContext();\n\n      const N = 2;\n      const pages = await Promise.all(\n        Array(N)\n          .fill(0)\n          .map(async () => {\n            const page = await context.newPage();\n            await page.goto(server.PREFIX + '/grid.html');\n            return page;\n          })\n      );\n      const promises = [];\n      for (let i = 0; i < N; ++i) {\n        promises.push(\n          pages[i]!.screenshot({\n            clip: {x: 50 * i, y: 0, width: 50, height: 50},\n          })\n        );\n      }\n      const screenshots = await Promise.all(promises);\n      for (let i = 0; i < N; ++i) {\n        expect(screenshots[i]).toBeGolden(`grid-cell-${i}.png`);\n      }\n      await Promise.all(\n        pages.map(page => {\n          return page.close();\n        })\n      );\n\n      await browser.close();\n    });","file":"src/headful.spec.ts","skipped":false,"dir":"test"},{"name":"changing idle state emulation causes change of the IdleDetector state","suites":["Emulate idle state"],"updatePoint":{"line":43,"column":75},"line":43,"code":"  it('changing idle state emulation causes change of the IdleDetector state', async () => {\n    const {page, server, context} = getTestState();\n    await context.overridePermissions(server.PREFIX + '/idle-detector.html', [\n      'idle-detection',\n    ]);\n\n    await page.goto(server.PREFIX + '/idle-detector.html');\n\n    // Store initial state, as soon as it is not guaranteed to be `active, unlocked`.\n    const initialState = await getIdleState();\n\n    // Emulate Idle states and verify IdleDetector updates state accordingly.\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: idle, locked.');\n\n    await page.emulateIdleState({\n      isUserActive: true,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: active, locked.');\n\n    await page.emulateIdleState({\n      isUserActive: true,\n      isScreenUnlocked: true,\n    });\n    await verifyState('Idle state: active, unlocked.');\n\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: true,\n    });\n    await verifyState('Idle state: idle, unlocked.');\n\n    // Remove Idle emulation and verify IdleDetector is in initial state.\n    await page.emulateIdleState();\n    await verifyState(initialState);\n\n    // Emulate idle state again after removing emulation.\n    await page.emulateIdleState({\n      isUserActive: false,\n      isScreenUnlocked: false,\n    });\n    await verifyState('Idle state: idle, locked.');\n\n    // Remove emulation second time.\n    await page.emulateIdleState();\n    await verifyState(initialState);\n  });","file":"src/idle_override.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":57,"column":19},"line":57,"code":"    it('should work', async () => {\n      const {httpsServer} = getTestState();\n\n      const [serverRequest, response] = await Promise.all([\n        httpsServer.waitForRequest('/empty.html'),\n        page.goto(httpsServer.EMPTY_PAGE),\n      ]);\n      const securityDetails = response!.securityDetails()!;\n      expect(securityDetails.issuer()).toBe('puppeteer-tests');\n      const protocol = (serverRequest.socket as TLSSocket)\n        .getProtocol()!\n        .replace('v', ' ');\n      expect(securityDetails.protocol()).toBe(protocol);\n      expect(securityDetails.subjectName()).toBe('puppeteer-tests');\n      expect(securityDetails.validFrom()).toBe(1589357069);\n      expect(securityDetails.validTo()).toBe(1904717069);\n      expect(securityDetails.subjectAlternativeNames()).toEqual([\n        'www.puppeteer-tests.test',\n        'www.puppeteer-tests-1.test',\n      ]);\n    });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should be |null| for non-secure requests","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":78,"column":48},"line":78,"code":"    it('should be |null| for non-secure requests', async () => {\n      const {server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.securityDetails()).toBe(null);\n    });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"Network redirects should report SecurityDetails","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":84,"column":55},"line":84,"code":"    it('Network redirects should report SecurityDetails', async () => {\n      const {httpsServer} = getTestState();\n\n      httpsServer.setRedirect('/plzredirect', '/empty.html');\n      const responses: HTTPResponse[] = [];\n      page.on('response', response => {\n        return responses.push(response);\n      });\n      const [serverRequest] = await Promise.all([\n        httpsServer.waitForRequest('/plzredirect'),\n        page.goto(httpsServer.PREFIX + '/plzredirect'),\n      ]);\n      expect(responses.length).toBe(2);\n      expect(responses[0]!.status()).toBe(302);\n      const securityDetails = responses[0]!.securityDetails()!;\n      const protocol = (serverRequest.socket as TLSSocket)\n        .getProtocol()!\n        .replace('v', ' ');\n      expect(securityDetails.protocol()).toBe(protocol);\n    });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":106,"column":17},"line":106,"code":"  it('should work', async () => {\n    const {httpsServer} = getTestState();\n\n    let error!: Error;\n    const response = await page.goto(httpsServer.EMPTY_PAGE).catch(error_ => {\n      return (error = error_);\n    });\n    expect(error).toBeUndefined();\n    expect(response.ok()).toBe(true);\n  });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should work with request interception","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":116,"column":43},"line":116,"code":"  it('should work with request interception', async () => {\n    const {httpsServer} = getTestState();\n\n    await page.setRequestInterception(true);\n    page.on('request', request => {\n      return request.continue();\n    });\n    const response = (await page.goto(httpsServer.EMPTY_PAGE))!;\n    expect(response.status()).toBe(200);\n  });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should work with mixed content","suites":["ignoreHTTPSErrors","Response.securityDetails"],"updatePoint":{"line":126,"column":36},"line":126,"code":"  it('should work with mixed content', async () => {\n    const {server, httpsServer} = getTestState();\n\n    httpsServer.setRoute('/mixedcontent.html', (_req, res) => {\n      res.end(`<iframe src=${server.EMPTY_PAGE}></iframe>`);\n    });\n    await page.goto(httpsServer.PREFIX + '/mixedcontent.html', {\n      waitUntil: 'load',\n    });\n    expect(page.frames().length).toBe(2);\n    // Make sure blocked iframe has functional execution context\n    // @see https://github.com/puppeteer/puppeteer/issues/2709\n    expect(await page.frames()[0]!.evaluate('1 + 2')).toBe(3);\n    expect(await page.frames()[1]!.evaluate('2 + 3')).toBe(5);\n  });","file":"src/ignorehttpserrors.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["PuppeteerUtil tests"],"updatePoint":{"line":30,"column":17},"line":30,"code":"  it('should work', async () => {\n    const {page} = getTestState();\n\n    const world = page.mainFrame().worlds[PUPPETEER_WORLD];\n    const value = await world.evaluate(\n      PuppeteerUtil => {\n        return typeof PuppeteerUtil === 'object';\n      },\n      LazyArg.create(context => {\n        return context.puppeteerUtil;\n      })\n    );\n    expect(value).toBeTruthy();\n  });","file":"src/injected.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["PuppeteerUtil tests","createFunction tests"],"updatePoint":{"line":46,"column":19},"line":46,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const world = page.mainFrame().worlds[PUPPETEER_WORLD];\n      const value = await world.evaluate(\n        ({createFunction}, fnString) => {\n          return createFunction(fnString)(4);\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        (() => {\n          return 4;\n        }).toString()\n      );\n      expect(value).toBe(4);\n    });","file":"src/injected.spec.ts","skipped":false,"dir":"test"},{"name":"should upload the file","suites":["input tests","input"],"updatePoint":{"line":33,"column":30},"line":33,"code":"    it('should upload the file', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/fileupload.html');\n      const filePath = path.relative(process.cwd(), FILE_TO_UPLOAD);\n      const input = (await page.$('input'))!;\n      await page.evaluate((e: HTMLElement) => {\n        (globalThis as any)._inputEvents = [];\n        e.addEventListener('change', ev => {\n          return (globalThis as any)._inputEvents.push(ev.type);\n        });\n        e.addEventListener('input', ev => {\n          return (globalThis as any)._inputEvents.push(ev.type);\n        });\n      }, input);\n      await input.uploadFile(filePath);\n      expect(\n        await page.evaluate((e: HTMLInputElement) => {\n          return e.files![0]!.name;\n        }, input)\n      ).toBe('file-to-upload.txt');\n      expect(\n        await page.evaluate((e: HTMLInputElement) => {\n          return e.files![0]!.type;\n        }, input)\n      ).toBe('text/plain');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any)._inputEvents;\n        })\n      ).toEqual(['input', 'change']);\n      expect(\n        await page.evaluate((e: HTMLInputElement) => {\n          const reader = new FileReader();\n          const promise = new Promise(fulfill => {\n            return (reader.onload = fulfill);\n          });\n          reader.readAsText(e.files![0]!);\n          return promise.then(() => {\n            return reader.result;\n          });\n        }, input)\n      ).toBe('contents of the file');\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work when file input is attached to DOM","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":80,"column":54},"line":80,"code":"    it('should work when file input is attached to DOM', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work when file input is not attached to DOM","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":90,"column":58},"line":90,"code":"    it('should work when file input is not attached to DOM', async () => {\n      const {page} = getTestState();\n\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.evaluate(() => {\n          const el = document.createElement('input');\n          el.type = 'file';\n          el.click();\n        }),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":103,"column":30},"line":103,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.waitForFileChooser({timeout: 1}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout when there is no custom timeout","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":112,"column":70},"line":112,"code":"    it('should respect default timeout when there is no custom timeout', async () => {\n      const {page} = getTestState();\n\n      page.setDefaultTimeout(1);\n      let error!: Error;\n      await page.waitForFileChooser().catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should prioritize exact timeout over default timeout","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":122,"column":60},"line":122,"code":"    it('should prioritize exact timeout over default timeout', async () => {\n      const {page} = getTestState();\n\n      page.setDefaultTimeout(0);\n      let error!: Error;\n      await page.waitForFileChooser({timeout: 1}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":132,"column":35},"line":132,"code":"    it('should work with no timeout', async () => {\n      const {page} = getTestState();\n\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser({timeout: 0}),\n        page.evaluate(() => {\n          return setTimeout(() => {\n            const el = document.createElement('input');\n            el.type = 'file';\n            el.click();\n          }, 50);\n        }),\n      ]);\n      expect(chooser).toBeTruthy();\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should return the same file chooser when there are many watchdogs simultaneously","suites":["input tests","Page.waitForFileChooser"],"updatePoint":{"line":147,"column":88},"line":147,"code":"    it('should return the same file chooser when there are many watchdogs simultaneously', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser1, fileChooser2] = await Promise.all([\n        page.waitForFileChooser(),\n        page.waitForFileChooser(),\n        page.$eval('input', input => {\n          return (input as HTMLInputElement).click();\n        }),\n      ]);\n      expect(fileChooser1 === fileChooser2).toBe(true);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should accept single file","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":163,"column":33},"line":163,"code":"    it('should accept single file', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        `<input type=file oninput='javascript:console.timeStamp()'>`\n      );\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      await Promise.all([\n        chooser.accept([FILE_TO_UPLOAD]),\n        new Promise(x => {\n          return page.once('metrics', x);\n        }),\n      ]);\n      expect(\n        await page.$eval('input', input => {\n          return (input as HTMLInputElement).files!.length;\n        })\n      ).toBe(1);\n      expect(\n        await page.$eval('input', input => {\n          return (input as HTMLInputElement).files![0]!.name;\n        })\n      ).toBe('file-to-upload.txt');\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to read selected file","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":190,"column":44},"line":190,"code":"    it('should be able to read selected file', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      page.waitForFileChooser().then(chooser => {\n        return chooser.accept([FILE_TO_UPLOAD]);\n      });\n      expect(\n        await page.$eval('input', async picker => {\n          const pick = picker as HTMLInputElement;\n          pick.click();\n          await new Promise(x => {\n            return (pick.oninput = x);\n          });\n          const reader = new FileReader();\n          const promise = new Promise(fulfill => {\n            return (reader.onload = fulfill);\n          });\n          reader.readAsText(pick.files![0]!);\n          return promise.then(() => {\n            return reader.result;\n          });\n        })\n      ).toBe('contents of the file');\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to reset selected files with empty file list","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":215,"column":67},"line":215,"code":"    it('should be able to reset selected files with empty file list', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      page.waitForFileChooser().then(chooser => {\n        return chooser.accept([FILE_TO_UPLOAD]);\n      });\n      expect(\n        await page.$eval('input', async picker => {\n          const pick = picker as HTMLInputElement;\n          pick.click();\n          await new Promise(x => {\n            return (pick.oninput = x);\n          });\n          return pick.files!.length;\n        })\n      ).toBe(1);\n      page.waitForFileChooser().then(chooser => {\n        return chooser.accept([]);\n      });\n      expect(\n        await page.$eval('input', async picker => {\n          const pick = picker as HTMLInputElement;\n          pick.click();\n          await new Promise(x => {\n            return (pick.oninput = x);\n          });\n          return pick.files!.length;\n        })\n      ).toBe(0);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should not accept multiple files for single-file input","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":246,"column":62},"line":246,"code":"    it('should not accept multiple files for single-file input', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      let error!: Error;\n      await chooser\n        .accept([\n          path.relative(\n            process.cwd(),\n            __dirname + '/../assets/file-to-upload.txt'\n          ),\n          path.relative(process.cwd(), __dirname + '/../assets/pptr.png'),\n        ])\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).not.toBe(null);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should succeed even for non-existent files","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":268,"column":50},"line":268,"code":"    it('should succeed even for non-existent files', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      let error!: Error;\n      await chooser.accept(['file-does-not-exist.txt']).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeUndefined();\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should error on read of non-existent files","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":282,"column":50},"line":282,"code":"    it('should error on read of non-existent files', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      page.waitForFileChooser().then(chooser => {\n        return chooser.accept(['file-does-not-exist.txt']);\n      });\n      expect(\n        await page.$eval('input', async picker => {\n          const pick = picker as HTMLInputElement;\n          pick.click();\n          await new Promise(x => {\n            return (pick.oninput = x);\n          });\n          const reader = new FileReader();\n          const promise = new Promise(fulfill => {\n            return (reader.onerror = fulfill);\n          });\n          reader.readAsText(pick.files![0]!);\n          return promise.then(() => {\n            return false;\n          });\n        })\n      ).toBeFalsy();\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when accepting file chooser twice","suites":["input tests","FileChooser.accept"],"updatePoint":{"line":307,"column":53},"line":307,"code":"    it('should fail when accepting file chooser twice', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', input => {\n          return (input as HTMLInputElement).click();\n        }),\n      ]);\n      await fileChooser.accept([]);\n      let error!: Error;\n      await fileChooser.accept([]).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe(\n        'Cannot accept FileChooser which is already handled!'\n      );\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should cancel dialog","suites":["input tests","FileChooser.cancel"],"updatePoint":{"line":329,"column":28},"line":329,"code":"    it('should cancel dialog', async () => {\n      const {page} = getTestState();\n\n      // Consider file chooser canceled if we can summon another one.\n      // There's no reliable way in WebPlatform to see that FileChooser was\n      // canceled.\n      await page.setContent(`<input type=file>`);\n      const [fileChooser1] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', input => {\n          return (input as HTMLInputElement).click();\n        }),\n      ]);\n      await fileChooser1.cancel();\n      // If this resolves, than we successfully canceled file chooser.\n      await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', input => {\n          return (input as HTMLInputElement).click();\n        }),\n      ]);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when canceling file chooser twice","suites":["input tests","FileChooser.cancel"],"updatePoint":{"line":351,"column":53},"line":351,"code":"    it('should fail when canceling file chooser twice', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [fileChooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.$eval('input', input => {\n          return (input as HTMLElement).click();\n        }),\n      ]);\n      await fileChooser.cancel();\n      let error!: Error;\n\n      try {\n        fileChooser.cancel();\n      } catch (error_) {\n        error = error_ as Error;\n      }\n\n      expect(error.message).toBe(\n        'Cannot cancel FileChooser which is already handled!'\n      );\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for single file pick","suites":["input tests","FileChooser.isMultiple"],"updatePoint":{"line":377,"column":40},"line":377,"code":"    it('should work for single file pick', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(false);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for \"multiple\"","suites":["input tests","FileChooser.isMultiple"],"updatePoint":{"line":387,"column":34},"line":387,"code":"    it('should work for \"multiple\"', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input multiple type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(true);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work for \"webkitdirectory\"","suites":["input tests","FileChooser.isMultiple"],"updatePoint":{"line":397,"column":41},"line":397,"code":"    it('should work for \"webkitdirectory\"', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<input multiple webkitdirectory type=file>`);\n      const [chooser] = await Promise.all([\n        page.waitForFileChooser(),\n        page.click('input'),\n      ]);\n      expect(chooser.isMultiple()).toBe(true);\n    });","file":"src/input.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":30,"column":19},"line":30,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const windowHandle = await page.evaluateHandle(() => {\n        return window;\n      });\n      expect(windowHandle).toBeTruthy();\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return the RemoteObject","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":38,"column":38},"line":38,"code":"    it('should return the RemoteObject', async () => {\n      const {page} = getTestState();\n\n      const windowHandle = await page.evaluateHandle(() => {\n        return window;\n      });\n      expect(windowHandle.remoteObject()).toBeTruthy();\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle as an argument","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":46,"column":50},"line":46,"code":"    it('should accept object handle as an argument', async () => {\n      const {page} = getTestState();\n\n      const navigatorHandle = await page.evaluateHandle(() => {\n        return navigator;\n      });\n      const text = await page.evaluate(e => {\n        return e.userAgent;\n      }, navigatorHandle);\n      expect(text).toContain('Mozilla');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle to primitive types","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":57,"column":54},"line":57,"code":"    it('should accept object handle to primitive types', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return 5;\n      });\n      const isFive = await page.evaluate(e => {\n        return Object.is(e, 5);\n      }, aHandle);\n      expect(isFive).toBeTruthy();\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should warn about recursive objects","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":68,"column":43},"line":68,"code":"    it('should warn about recursive objects', async () => {\n      const {page} = getTestState();\n\n      const test: {obj?: unknown} = {};\n      test.obj = test;\n      let error!: Error;\n      await page\n        .evaluateHandle(opts => {\n          return opts;\n        }, test)\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain('Recursive objects are not allowed.');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should accept object handle to unserializable value","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":83,"column":59},"line":83,"code":"    it('should accept object handle to unserializable value', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return Infinity;\n      });\n      expect(\n        await page.evaluate(e => {\n          return Object.is(e, Infinity);\n        }, aHandle)\n      ).toBe(true);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should use the same JS wrappers","suites":["JSHandle","Page.evaluateHandle"],"updatePoint":{"line":95,"column":39},"line":95,"code":"    it('should use the same JS wrappers', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        (globalThis as any).FOO = 123;\n        return window;\n      });\n      expect(\n        await page.evaluate(e => {\n          return (e as any).FOO;\n        }, aHandle)\n      ).toBe(123);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.getProperty"],"updatePoint":{"line":111,"column":19},"line":111,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return {\n          one: 1,\n          two: 2,\n          three: 3,\n        };\n      });\n      const twoHandle = await aHandle.getProperty('two');\n      expect(await twoHandle.jsonValue()).toEqual(2);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":127,"column":19},"line":127,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return {foo: 'bar'};\n      });\n      const json = await aHandle.jsonValue();\n      expect(json).toEqual({foo: 'bar'});\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"works with jsonValues that are not objects","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":137,"column":50},"line":137,"code":"    it('works with jsonValues that are not objects', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return ['a', 'b'];\n      });\n      const json = await aHandle.jsonValue();\n      expect(json).toEqual(['a', 'b']);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"works with jsonValues that are primitives","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":147,"column":49},"line":147,"code":"    it('works with jsonValues that are primitives', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return 'foo';\n      });\n      expect(await aHandle.jsonValue()).toEqual('foo');\n\n      const bHandle = await page.evaluateHandle(() => {\n        return undefined;\n      });\n      expect(await bHandle.jsonValue()).toEqual(undefined);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should not work with dates","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":161,"column":34},"line":161,"code":"    it('should not work with dates', async () => {\n      const {page} = getTestState();\n\n      const dateHandle = await page.evaluateHandle(() => {\n        return new Date('2017-09-26T00:00:00.000Z');\n      });\n      const json = await dateHandle.jsonValue();\n      expect(json).toEqual({});\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for circular objects","suites":["JSHandle","JSHandle.jsonValue"],"updatePoint":{"line":170,"column":41},"line":170,"code":"    it('should throw for circular objects', async () => {\n      const {page, isChrome} = getTestState();\n\n      const handle = await page.evaluateHandle(() => {\n        const t: {t?: unknown; g: number} = {g: 1};\n        t.t = t;\n        return t;\n      });\n      let error!: Error;\n      await handle.jsonValue().catch(error_ => {\n        return (error = error_);\n      });\n      if (isChrome) {\n        expect(error.message).toContain(\n          'Could not serialize referenced object'\n        );\n      } else {\n        expect(error.message).toContain('Object is not serializable');\n      }\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.getProperties"],"updatePoint":{"line":193,"column":19},"line":193,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return {\n          foo: 'bar',\n        };\n      });\n      const properties = await aHandle.getProperties();\n      const foo = properties.get('foo')!;\n      expect(foo).toBeTruthy();\n      expect(await foo.jsonValue()).toBe('bar');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return even non-own properties","suites":["JSHandle","JSHandle.getProperties"],"updatePoint":{"line":206,"column":45},"line":206,"code":"    it('should return even non-own properties', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        class A {\n          a: string;\n          constructor() {\n            this.a = '1';\n          }\n        }\n        class B extends A {\n          b: string;\n          constructor() {\n            super();\n            this.b = '2';\n          }\n        }\n        return new B();\n      });\n      const properties = await aHandle.getProperties();\n      expect(await properties.get('a')!.jsonValue()).toBe('1');\n      expect(await properties.get('b')!.jsonValue()).toBe('2');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":232,"column":19},"line":232,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return document.body;\n      });\n      const element = aHandle.asElement();\n      expect(element).toBeTruthy();\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-elements","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":241,"column":43},"line":241,"code":"    it('should return null for non-elements', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return 2;\n      });\n      const element = aHandle.asElement();\n      expect(element).toBeFalsy();\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should return ElementHandle for TextNodes","suites":["JSHandle","JSHandle.asElement"],"updatePoint":{"line":250,"column":49},"line":250,"code":"    it('should return ElementHandle for TextNodes', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>ee!</div>');\n      const aHandle = await page.evaluateHandle(() => {\n        return document.querySelector('div')!.firstChild;\n      });\n      const element = aHandle.asElement();\n      expect(element).toBeTruthy();\n      expect(\n        await page.evaluate(e => {\n          return e?.nodeType === Node.TEXT_NODE;\n        }, element)\n      );\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for primitives","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":268,"column":34},"line":268,"code":"    it('should work for primitives', async () => {\n      const {page} = getTestState();\n\n      const numberHandle = await page.evaluateHandle(() => {\n        return 2;\n      });\n      expect(numberHandle.toString()).toBe('JSHandle:2');\n      const stringHandle = await page.evaluateHandle(() => {\n        return 'a';\n      });\n      expect(stringHandle.toString()).toBe('JSHandle:a');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for complicated objects","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":280,"column":43},"line":280,"code":"    it('should work for complicated objects', async () => {\n      const {page} = getTestState();\n\n      const aHandle = await page.evaluateHandle(() => {\n        return window;\n      });\n      expect(aHandle.toString()).toBe('JSHandle@object');\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work with different subtypes","suites":["JSHandle","JSHandle.toString"],"updatePoint":{"line":288,"column":43},"line":288,"code":"    it('should work with different subtypes', async () => {\n      const {page} = getTestState();\n\n      expect((await page.evaluateHandle('(function(){})')).toString()).toBe(\n        'JSHandle@function'\n      );\n      expect((await page.evaluateHandle('12')).toString()).toBe('JSHandle:12');\n      expect((await page.evaluateHandle('true')).toString()).toBe(\n        'JSHandle:true'\n      );\n      expect((await page.evaluateHandle('undefined')).toString()).toBe(\n        'JSHandle:undefined'\n      );\n      expect((await page.evaluateHandle('\"foo\"')).toString()).toBe(\n        'JSHandle:foo'\n      );\n      expect((await page.evaluateHandle('Symbol()')).toString()).toBe(\n        'JSHandle@symbol'\n      );\n      expect((await page.evaluateHandle('new Map()')).toString()).toBe(\n        'JSHandle@map'\n      );\n      expect((await page.evaluateHandle('new Set()')).toString()).toBe(\n        'JSHandle@set'\n      );\n      expect((await page.evaluateHandle('[]')).toString()).toBe(\n        'JSHandle@array'\n      );\n      expect((await page.evaluateHandle('null')).toString()).toBe(\n        'JSHandle:null'\n      );\n      expect((await page.evaluateHandle('/foo/')).toString()).toBe(\n        'JSHandle@regexp'\n      );\n      expect((await page.evaluateHandle('document.body')).toString()).toBe(\n        'JSHandle@node'\n      );\n      expect((await page.evaluateHandle('new Date()')).toString()).toBe(\n        'JSHandle@date'\n      );\n      expect((await page.evaluateHandle('new WeakMap()')).toString()).toBe(\n        'JSHandle@weakmap'\n      );\n      expect((await page.evaluateHandle('new WeakSet()')).toString()).toBe(\n        'JSHandle@weakset'\n      );\n      expect((await page.evaluateHandle('new Error()')).toString()).toBe(\n        'JSHandle@error'\n      );\n      expect((await page.evaluateHandle('new Int32Array()')).toString()).toBe(\n        'JSHandle@typedarray'\n      );\n      expect((await page.evaluateHandle('new Proxy({}, {})')).toString()).toBe(\n        'JSHandle@proxy'\n      );\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.clickablePoint"],"updatePoint":{"line":347,"column":19},"line":347,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.evaluate(() => {\n        document.body.style.padding = '0';\n        document.body.style.margin = '0';\n        document.body.innerHTML = `\n          <div style=\"cursor: pointer; width: 120px; height: 60px; margin: 30px; padding: 15px;\"></div>\n        `;\n      });\n      await page.evaluate(async () => {\n        return new Promise(resolve => {\n          return window.requestAnimationFrame(resolve);\n        });\n      });\n      const divHandle = (await page.$('div'))!;\n      expect(await divHandle.clickablePoint()).toEqual({\n        x: 45 + 60, // margin + middle point offset\n        y: 45 + 30, // margin + middle point offset\n      });\n      expect(\n        await divHandle.clickablePoint({\n          x: 10,\n          y: 15,\n        })\n      ).toEqual({\n        x: 30 + 10, // margin + offset\n        y: 30 + 15, // margin + offset\n      });\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work for iframes","suites":["JSHandle","JSHandle.clickablePoint"],"updatePoint":{"line":378,"column":31},"line":378,"code":"    it('should work for iframes', async () => {\n      const {page} = getTestState();\n      await page.evaluate(() => {\n        document.body.style.padding = '10px';\n        document.body.style.margin = '10px';\n        document.body.innerHTML = `\n          <iframe style=\"border: none; margin: 0; padding: 0;\" seamless sandbox srcdoc=\"<style>* { margin: 0; padding: 0;}</style><div style='cursor: pointer; width: 120px; height: 60px; margin: 30px; padding: 15px;' />\"></iframe>\n        `;\n      });\n      await page.evaluate(async () => {\n        return new Promise(resolve => {\n          return window.requestAnimationFrame(resolve);\n        });\n      });\n      const frame = page.frames()[1]!;\n      const divHandle = (await frame.$('div'))!;\n      expect(await divHandle.clickablePoint()).toEqual({\n        x: 20 + 45 + 60, // iframe pos + margin + middle point offset\n        y: 20 + 45 + 30, // iframe pos + margin + middle point offset\n      });\n      expect(\n        await divHandle.clickablePoint({\n          x: 10,\n          y: 15,\n        })\n      ).toEqual({\n        x: 20 + 30 + 10, // iframe pos + margin + offset\n        y: 20 + 30 + 15, // iframe pos + margin + offset\n      });\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["JSHandle","JSHandle.click"],"updatePoint":{"line":411,"column":19},"line":411,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const clicks: Array<[x: number, y: number]> = [];\n\n      await page.exposeFunction('reportClick', (x: number, y: number): void => {\n        clicks.push([x, y]);\n      });\n\n      await page.evaluate(() => {\n        document.body.style.padding = '0';\n        document.body.style.margin = '0';\n        document.body.innerHTML = `\n          <div style=\"cursor: pointer; width: 120px; height: 60px; margin: 30px; padding: 15px;\"></div>\n        `;\n        document.body.addEventListener('click', e => {\n          (window as any).reportClick(e.clientX, e.clientY);\n        });\n      });\n\n      const divHandle = (await page.$('div'))!;\n      await divHandle.click();\n      await divHandle.click({\n        offset: {\n          x: 10,\n          y: 15,\n        },\n      });\n      await shortWaitForArrayToHaveAtLeastNElements(clicks, 2);\n      expect(clicks).toEqual([\n        [45 + 60, 45 + 30], // margin + middle point offset\n        [30 + 10, 30 + 15], // margin + offset\n      ]);\n    });","file":"src/jshandle.spec.ts","skipped":false,"dir":"test"},{"name":"should type into a textarea","suites":["Keyboard"],"updatePoint":{"line":31,"column":33},"line":31,"code":"  it('should type into a textarea', async () => {\n    const {page} = getTestState();\n\n    await page.evaluate(() => {\n      const textarea = document.createElement('textarea');\n      document.body.appendChild(textarea);\n      textarea.focus();\n    });\n    const text = 'Hello world. I am the text that was typed!';\n    await page.keyboard.type(text);\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe(text);\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should press the metaKey","suites":["Keyboard"],"updatePoint":{"line":47,"column":30},"line":47,"code":"  it('should press the metaKey', async () => {\n    const {page, isFirefox} = getTestState();\n\n    await page.evaluate(() => {\n      (window as any).keyPromise = new Promise(resolve => {\n        return document.addEventListener('keydown', event => {\n          return resolve(event.key);\n        });\n      });\n    });\n    await page.keyboard.press('Meta');\n    expect(await page.evaluate('keyPromise')).toBe(\n      isFirefox && os.platform() !== 'darwin' ? 'OS' : 'Meta'\n    );\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should move with the arrow keys","suites":["Keyboard"],"updatePoint":{"line":62,"column":37},"line":62,"code":"  it('should move with the arrow keys', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.type('textarea', 'Hello World!');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('Hello World!');\n    for (let i = 0; i < 'World!'.length; i++) {\n      page.keyboard.press('ArrowLeft');\n    }\n    await page.keyboard.type('inserted ');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('Hello inserted World!');\n    page.keyboard.down('Shift');\n    for (let i = 0; i < 'inserted '.length; i++) {\n      page.keyboard.press('ArrowLeft');\n    }\n    page.keyboard.up('Shift');\n    await page.keyboard.press('Backspace');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('Hello World!');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger commands of keyboard shortcuts","suites":["Keyboard"],"updatePoint":{"line":94,"column":51},"line":94,"code":"  it('should trigger commands of keyboard shortcuts', async () => {\n    const {page, server} = getTestState();\n    const cmdKey = os.platform() !== 'darwin' ? 'Meta' : 'Control';\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.type('textarea', 'hello');\n\n    await page.keyboard.down(cmdKey);\n    await page.keyboard.press('a', {commands: ['SelectAll']});\n    await page.keyboard.up(cmdKey);\n\n    await page.keyboard.down(cmdKey);\n    await page.keyboard.down('c', {commands: ['Copy']});\n    await page.keyboard.up('c');\n    await page.keyboard.up(cmdKey);\n\n    await page.keyboard.down(cmdKey);\n    await page.keyboard.press('v', {commands: ['Paste']});\n    await page.keyboard.up(cmdKey);\n    await page.keyboard.down(cmdKey);\n    await page.keyboard.press('v', {commands: ['Paste']});\n    await page.keyboard.up(cmdKey);\n\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('hellohello');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send a character with ElementHandle.press","suites":["Keyboard"],"updatePoint":{"line":123,"column":54},"line":123,"code":"  it('should send a character with ElementHandle.press', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    const textarea = (await page.$('textarea'))!;\n    await textarea.press('a');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('a');\n\n    await page.evaluate(() => {\n      return window.addEventListener(\n        'keydown',\n        e => {\n          return e.preventDefault();\n        },\n        true\n      );\n    });\n\n    await textarea.press('b');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('a');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"ElementHandle.press should support |text| option","suites":["Keyboard"],"updatePoint":{"line":152,"column":54},"line":152,"code":"  it('ElementHandle.press should support |text| option', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    const textarea = (await page.$('textarea'))!;\n    await textarea.press('a', {text: ''});\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send a character with sendCharacter","suites":["Keyboard"],"updatePoint":{"line":164,"column":48},"line":164,"code":"  it('should send a character with sendCharacter', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    await page.keyboard.sendCharacter('');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('');\n    await page.evaluate(() => {\n      return window.addEventListener(\n        'keydown',\n        e => {\n          return e.preventDefault();\n        },\n        true\n      );\n    });\n    await page.keyboard.sendCharacter('a');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('textarea')!.value;\n      })\n    ).toBe('a');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should report shiftKey","suites":["Keyboard"],"updatePoint":{"line":191,"column":28},"line":191,"code":"  it('should report shiftKey', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    const keyboard = page.keyboard;\n    const codeForKey = new Map<KeyInput, number>([\n      ['Shift', 16],\n      ['Alt', 18],\n      ['Control', 17],\n    ]);\n    for (const [modifierKey, modifierCode] of codeForKey) {\n      await keyboard.down(modifierKey);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).getResult();\n        })\n      ).toBe(\n        'Keydown: ' +\n          modifierKey +\n          ' ' +\n          modifierKey +\n          'Left ' +\n          modifierCode +\n          ' [' +\n          modifierKey +\n          ']'\n      );\n      await keyboard.down('!');\n      // Shift+! will generate a keypress\n      if (modifierKey === 'Shift') {\n        expect(\n          await page.evaluate(() => {\n            return (globalThis as any).getResult();\n          })\n        ).toBe(\n          'Keydown: ! Digit1 49 [' +\n            modifierKey +\n            ']\\nKeypress: ! Digit1 33 33 [' +\n            modifierKey +\n            ']'\n        );\n      } else {\n        expect(\n          await page.evaluate(() => {\n            return (globalThis as any).getResult();\n          })\n        ).toBe('Keydown: ! Digit1 49 [' + modifierKey + ']');\n      }\n\n      await keyboard.up('!');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).getResult();\n        })\n      ).toBe('Keyup: ! Digit1 49 [' + modifierKey + ']');\n      await keyboard.up(modifierKey);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).getResult();\n        })\n      ).toBe(\n        'Keyup: ' +\n          modifierKey +\n          ' ' +\n          modifierKey +\n          'Left ' +\n          modifierCode +\n          ' []'\n      );\n    }\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should report multiple modifiers","suites":["Keyboard"],"updatePoint":{"line":262,"column":38},"line":262,"code":"  it('should report multiple modifiers', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    const keyboard = page.keyboard;\n    await keyboard.down('Control');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keydown: Control ControlLeft 17 [Control]');\n    await keyboard.down('Alt');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keydown: Alt AltLeft 18 [Alt Control]');\n    await keyboard.down(';');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keydown: ; Semicolon 186 [Alt Control]');\n    await keyboard.up(';');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keyup: ; Semicolon 186 [Alt Control]');\n    await keyboard.up('Control');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keyup: Control ControlLeft 17 [Alt]');\n    await keyboard.up('Alt');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe('Keyup: Alt AltLeft 18 []');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send proper codes while typing","suites":["Keyboard"],"updatePoint":{"line":304,"column":43},"line":304,"code":"  it('should send proper codes while typing', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    await page.keyboard.type('!');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe(\n      [\n        'Keydown: ! Digit1 49 []',\n        'Keypress: ! Digit1 33 33 []',\n        'Keyup: ! Digit1 49 []',\n      ].join('\\n')\n    );\n    await page.keyboard.type('^');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe(\n      [\n        'Keydown: ^ Digit6 54 []',\n        'Keypress: ^ Digit6 94 94 []',\n        'Keyup: ^ Digit6 54 []',\n      ].join('\\n')\n    );\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should send proper codes while typing with shift","suites":["Keyboard"],"updatePoint":{"line":333,"column":54},"line":333,"code":"  it('should send proper codes while typing with shift', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/keyboard.html');\n    const keyboard = page.keyboard;\n    await keyboard.down('Shift');\n    await page.keyboard.type('~');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toBe(\n      [\n        'Keydown: Shift ShiftLeft 16 [Shift]',\n        'Keydown: ~ Backquote 192 [Shift]', // 192 is ` keyCode\n        'Keypress: ~ Backquote 126 126 [Shift]', // 126 is ~ charCode\n        'Keyup: ~ Backquote 192 [Shift]',\n      ].join('\\n')\n    );\n    await keyboard.up('Shift');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should not type canceled events","suites":["Keyboard"],"updatePoint":{"line":354,"column":37},"line":354,"code":"  it('should not type canceled events', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    await page.evaluate(() => {\n      window.addEventListener(\n        'keydown',\n        event => {\n          event.stopPropagation();\n          event.stopImmediatePropagation();\n          if (event.key === 'l') {\n            event.preventDefault();\n          }\n          if (event.key === 'o') {\n            event.preventDefault();\n          }\n        },\n        false\n      );\n    });\n    await page.keyboard.type('Hello World!');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).textarea.value;\n      })\n    ).toBe('He Wrd!');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should specify repeat property","suites":["Keyboard"],"updatePoint":{"line":382,"column":36},"line":382,"code":"  it('should specify repeat property', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    await page.evaluate(() => {\n      return document.querySelector('textarea')!.addEventListener(\n        'keydown',\n        e => {\n          return ((globalThis as any).lastEvent = e);\n        },\n        true\n      );\n    });\n    await page.keyboard.down('a');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).lastEvent.repeat;\n      })\n    ).toBe(false);\n    await page.keyboard.press('a');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).lastEvent.repeat;\n      })\n    ).toBe(true);\n\n    await page.keyboard.down('b');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).lastEvent.repeat;\n      })\n    ).toBe(false);\n    await page.keyboard.down('b');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).lastEvent.repeat;\n      })\n    ).toBe(true);\n\n    await page.keyboard.up('a');\n    await page.keyboard.down('a');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).lastEvent.repeat;\n      })\n    ).toBe(false);\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should type all kinds of characters","suites":["Keyboard"],"updatePoint":{"line":430,"column":41},"line":430,"code":"  it('should type all kinds of characters', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    const text = 'This text goes onto two lines.\\nThis character is .';\n    await page.keyboard.type(text);\n    expect(await page.evaluate('result')).toBe(text);\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should specify location","suites":["Keyboard"],"updatePoint":{"line":439,"column":29},"line":439,"code":"  it('should specify location', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.evaluate(() => {\n      window.addEventListener(\n        'keydown',\n        event => {\n          return ((globalThis as any).keyLocation = event.location);\n        },\n        true\n      );\n    });\n    const textarea = (await page.$('textarea'))!;\n\n    await textarea.press('Digit5');\n    expect(await page.evaluate('keyLocation')).toBe(0);\n\n    await textarea.press('ControlLeft');\n    expect(await page.evaluate('keyLocation')).toBe(1);\n\n    await textarea.press('ControlRight');\n    expect(await page.evaluate('keyLocation')).toBe(2);\n\n    await textarea.press('NumpadSubtract');\n    expect(await page.evaluate('keyLocation')).toBe(3);\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should throw on unknown keys","suites":["Keyboard"],"updatePoint":{"line":466,"column":34},"line":466,"code":"  it('should throw on unknown keys', async () => {\n    const {page} = getTestState();\n\n    let error = await page.keyboard\n      // @ts-expect-error bad input\n      .press('NotARealKey')\n      .catch(error_ => {\n        return error_;\n      });\n    expect(error.message).toBe('Unknown key: \"NotARealKey\"');\n\n    // @ts-expect-error bad input\n    error = await page.keyboard.press('').catch(error_ => {\n      return error_;\n    });\n    expect(error && error.message).toBe('Unknown key: \"\"');\n\n    // @ts-expect-error bad input\n    error = await page.keyboard.press('').catch(error_ => {\n      return error_;\n    });\n    expect(error && error.message).toBe('Unknown key: \"\"');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should type emoji","suites":["Keyboard"],"updatePoint":{"line":489,"column":23},"line":489,"code":"  it('should type emoji', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.type('textarea', ' Tokyo street Japan ');\n    expect(\n      await page.$eval('textarea', textarea => {\n        return textarea.value;\n      })\n    ).toBe(' Tokyo street Japan ');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should type emoji into an iframe","suites":["Keyboard"],"updatePoint":{"line":500,"column":38},"line":500,"code":"  it('should type emoji into an iframe', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await utils.attachFrame(\n      page,\n      'emoji-test',\n      server.PREFIX + '/input/textarea.html'\n    );\n    const frame = page.frames()[1]!;\n    const textarea = (await frame.$('textarea'))!;\n    await textarea.type(' Tokyo street Japan ');\n    expect(\n      await frame.$eval('textarea', textarea => {\n        return textarea.value;\n      })\n    ).toBe(' Tokyo street Japan ');\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should press the meta key","suites":["Keyboard"],"updatePoint":{"line":518,"column":31},"line":518,"code":"  it('should press the meta key', async () => {\n    const {page, isFirefox} = getTestState();\n\n    await page.evaluate(() => {\n      (globalThis as any).result = null;\n      document.addEventListener('keydown', event => {\n        (globalThis as any).result = [event.key, event.code, event.metaKey];\n      });\n    });\n    await page.keyboard.press('Meta');\n    // Have to do this because we lose a lot of type info when evaluating a\n    // string not a function. This is why functions are recommended rather than\n    // using strings (although we'll leave this test so we have coverage of both\n    // approaches.)\n    const [key, code, metaKey] = (await page.evaluate('result')) as [\n      string,\n      string,\n      boolean\n    ];\n    if (isFirefox && os.platform() !== 'darwin') {\n      expect(key).toBe('OS');\n    } else {\n      expect(key).toBe('Meta');\n    }\n\n    if (isFirefox) {\n      expect(code).toBe('OSLeft');\n    } else {\n      expect(code).toBe('MetaLeft');\n    }\n\n    if (isFirefox && os.platform() !== 'darwin') {\n      expect(metaKey).toBe(false);\n    } else {\n      expect(metaKey).toBe(true);\n    }\n  });","file":"src/keyboard.spec.ts","skipped":false,"dir":"test"},{"name":"should download and extract chrome linux binary","suites":["Launcher specs","Puppeteer","BrowserFetcher"],"updatePoint":{"line":46,"column":57},"line":46,"code":"      it('should download and extract chrome linux binary', async () => {\n        const {server} = getTestState();\n\n        const downloadsFolder = await mkdtempAsync(TMP_FOLDER);\n        const browserFetcher = new BrowserFetcher({\n          platform: 'linux',\n          path: downloadsFolder,\n          host: server.PREFIX,\n        });\n        const expectedRevision = '123456';\n        let revisionInfo = browserFetcher.revisionInfo(expectedRevision);\n        server.setRoute(\n          revisionInfo.url.substring(server.PREFIX.length),\n          (req, res) => {\n            server.serveFile(req, res, '/chromium-linux.zip');\n          }\n        );\n\n        expect(revisionInfo.local).toBe(false);\n        expect(browserFetcher.platform()).toBe('linux');\n        expect(browserFetcher.product()).toBe('chrome');\n        expect(!!browserFetcher.host()).toBe(true);\n        expect(await browserFetcher.canDownload('100000')).toBe(false);\n        expect(await browserFetcher.canDownload(expectedRevision)).toBe(true);\n\n        revisionInfo = (await browserFetcher.download(expectedRevision))!;\n        expect(revisionInfo.local).toBe(true);\n        expect(await readFileAsync(revisionInfo.executablePath, 'utf8')).toBe(\n          'LINUX BINARY\\n'\n        );\n        const expectedPermissions = os.platform() === 'win32' ? 0o666 : 0o755;\n        expect(\n          (await statAsync(revisionInfo.executablePath)).mode & 0o777\n        ).toBe(expectedPermissions);\n        expect(await browserFetcher.localRevisions()).toEqual([\n          expectedRevision,\n        ]);\n        await browserFetcher.remove(expectedRevision);\n        expect(await browserFetcher.localRevisions()).toEqual([]);\n        await rmAsync(downloadsFolder);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should download and extract firefox linux binary","suites":["Launcher specs","Puppeteer","BrowserFetcher"],"updatePoint":{"line":87,"column":58},"line":87,"code":"      it('should download and extract firefox linux binary', async () => {\n        const {server} = getTestState();\n\n        const downloadsFolder = await mkdtempAsync(TMP_FOLDER);\n        const browserFetcher = new BrowserFetcher({\n          platform: 'linux',\n          path: downloadsFolder,\n          host: server.PREFIX,\n          product: 'firefox',\n        });\n        const expectedVersion = '75.0a1';\n        let revisionInfo = browserFetcher.revisionInfo(expectedVersion);\n        server.setRoute(\n          revisionInfo.url.substring(server.PREFIX.length),\n          (req, res) => {\n            server.serveFile(\n              req,\n              res,\n              `/firefox-${expectedVersion}.en-US.linux-x86_64.tar.bz2`\n            );\n          }\n        );\n\n        expect(revisionInfo.local).toBe(false);\n        expect(browserFetcher.platform()).toBe('linux');\n        expect(browserFetcher.product()).toBe('firefox');\n        expect(await browserFetcher.canDownload('100000')).toBe(false);\n        expect(await browserFetcher.canDownload(expectedVersion)).toBe(true);\n\n        revisionInfo = (await browserFetcher.download(expectedVersion))!;\n        expect(revisionInfo.local).toBe(true);\n        expect(await readFileAsync(revisionInfo.executablePath, 'utf8')).toBe(\n          'FIREFOX LINUX BINARY\\n'\n        );\n        const expectedPermissions = os.platform() === 'win32' ? 0o666 : 0o755;\n        expect(\n          (await statAsync(revisionInfo.executablePath)).mode & 0o777\n        ).toBe(expectedPermissions);\n        expect(await browserFetcher.localRevisions()).toEqual([\n          expectedVersion,\n        ]);\n        await browserFetcher.remove(expectedVersion);\n        expect(await browserFetcher.localRevisions()).toEqual([]);\n        await rmAsync(downloadsFolder);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject navigation when browser closes","suites":["Launcher specs","Puppeteer","Browser.disconnect"],"updatePoint":{"line":135,"column":54},"line":135,"code":"      it('should reject navigation when browser closes', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n        server.setRoute('/one-style.css', () => {});\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const page = await remote.newPage();\n        const navigationPromise = page\n          .goto(server.PREFIX + '/one-style.html', {timeout: 60000})\n          .catch(error_ => {\n            return error_;\n          });\n        await server.waitForRequest('/one-style.css');\n        remote.disconnect();\n        const error = await navigationPromise;\n        expect(\n          [\n            'Navigation failed because browser has disconnected!',\n            'Protocol error (Page.navigate): Target closed.',\n          ].includes(error.message)\n        ).toBeTruthy();\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject waitForSelector when browser closes","suites":["Launcher specs","Puppeteer","Browser.disconnect"],"updatePoint":{"line":159,"column":59},"line":159,"code":"      it('should reject waitForSelector when browser closes', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        server.setRoute('/empty.html', () => {});\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const page = await remote.newPage();\n        const watchdog = page\n          .waitForSelector('div', {timeout: 60000})\n          .catch(error_ => {\n            return error_;\n          });\n        remote.disconnect();\n        const error = await watchdog;\n        expect(error.message).toContain('Protocol error');\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should terminate network waiters","suites":["Launcher specs","Puppeteer","Browser.close"],"updatePoint":{"line":180,"column":42},"line":180,"code":"      it('should terminate network waiters', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const remote = await puppeteer.connect({\n          browserWSEndpoint: browser.wsEndpoint(),\n        });\n        const newPage = await remote.newPage();\n        const results = await Promise.all([\n          newPage.waitForRequest(server.EMPTY_PAGE).catch(error => {\n            return error;\n          }),\n          newPage.waitForResponse(server.EMPTY_PAGE).catch(error => {\n            return error;\n          }),\n          browser.close(),\n        ]);\n        for (let i = 0; i < 2; i++) {\n          const message = results[i].message;\n          expect(message).toContain('Target closed');\n          expect(message).not.toContain('Timeout');\n        }\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"can launch and close the browser","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":206,"column":42},"line":206,"code":"      it('can launch and close the browser', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject all promises when browser is closed","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":211,"column":59},"line":211,"code":"      it('should reject all promises when browser is closed', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const page = await browser.newPage();\n        let error!: Error;\n        const neverResolves = page\n          .evaluate(() => {\n            return new Promise(() => {});\n          })\n          .catch(error_ => {\n            return (error = error_);\n          });\n        await browser.close();\n        await neverResolves;\n        expect(error.message).toContain('Protocol error');\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should reject if executable path is invalid","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":227,"column":53},"line":227,"code":"      it('should reject if executable path is invalid', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        let waitError!: Error;\n        const options = Object.assign({}, defaultBrowserOptions, {\n          executablePath: 'random-invalid-path',\n        });\n        await puppeteer.launch(options).catch(error => {\n          return (waitError = error);\n        });\n        expect(waitError.message).toContain('Failed to launch');\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":239,"column":28},"line":239,"code":"      it('userDataDir option', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({userDataDir}, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        // Open a page to make sure its functional.\n        await browser.newPage();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"tmp profile should be cleaned up","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":253,"column":42},"line":253,"code":"      it('tmp profile should be cleaned up', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        // Set a custom test tmp dir so that we can validate that\n        // the profile dir is created and then cleaned up.\n        const testTmpDir = await fs.promises.mkdtemp(\n          path.join(os.tmpdir(), 'puppeteer_test_chrome_profile-')\n        );\n        const oldTmpDir = puppeteer.configuration.temporaryDirectory;\n        puppeteer.configuration.temporaryDirectory = testTmpDir;\n\n        // Path should be empty before starting the browser.\n        expect(fs.readdirSync(testTmpDir).length).toEqual(0);\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n\n        // One profile folder should have been created at this moment.\n        const profiles = fs.readdirSync(testTmpDir);\n        expect(profiles.length).toEqual(1);\n        expect(profiles[0]?.startsWith('puppeteer_dev_chrome_profile-')).toBe(\n          true\n        );\n\n        // Open a page to make sure its functional.\n        await browser.newPage();\n        await browser.close();\n        // Profile should be deleted after closing the browser\n        expect(fs.readdirSync(testTmpDir).length).toEqual(0);\n\n        // Restore env var\n        puppeteer.configuration.temporaryDirectory = oldTmpDir;\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option restores preferences","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":284,"column":49},"line":284,"code":"      it('userDataDir option restores preferences', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n\n        const prefsJSPath = path.join(userDataDir, 'prefs.js');\n        const prefsJSContent = 'user_pref(\"browser.warnOnQuit\", true)';\n        await writeFileAsync(prefsJSPath, prefsJSContent);\n\n        const options = Object.assign({userDataDir}, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        // Open a page to make sure its functional.\n        await browser.newPage();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n\n        expect(await readFileAsync(prefsJSPath, 'utf8')).toBe(prefsJSContent);\n\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir argument","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":306,"column":30},"line":306,"code":"      it('userDataDir argument', async () => {\n        const {isChrome, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({}, defaultBrowserOptions);\n        if (isChrome) {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            `--user-data-dir=${userDataDir}`,\n          ];\n        } else {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            '-profile',\n            userDataDir,\n          ];\n        }\n        const browser = await puppeteer.launch(options);\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir argument with non-existent dir","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":330,"column":52},"line":330,"code":"      it('userDataDir argument with non-existent dir', async () => {\n        const {isChrome, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        await rmAsync(userDataDir);\n        const options = Object.assign({}, defaultBrowserOptions);\n        if (isChrome) {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            `--user-data-dir=${userDataDir}`,\n          ];\n        } else {\n          options.args = [\n            ...(defaultBrowserOptions.args || []),\n            '-profile',\n            userDataDir,\n          ];\n        }\n        const browser = await puppeteer.launch(options);\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        await browser.close();\n        expect(fs.readdirSync(userDataDir).length).toBeGreaterThan(0);\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option should restore state","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":355,"column":49},"line":355,"code":"      it('userDataDir option should restore state', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({userDataDir}, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.EMPTY_PAGE);\n        await page.evaluate(() => {\n          return (localStorage['hey'] = 'hello');\n        });\n        await browser.close();\n\n        const browser2 = await puppeteer.launch(options);\n        const page2 = await browser2.newPage();\n        await page2.goto(server.EMPTY_PAGE);\n        expect(\n          await page2.evaluate(() => {\n            return localStorage['hey'];\n          })\n        ).toBe('hello');\n        await browser2.close();\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"userDataDir option should restore cookies","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":380,"column":51},"line":380,"code":"      it('userDataDir option should restore cookies', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const userDataDir = await mkdtempAsync(TMP_FOLDER);\n        const options = Object.assign({userDataDir}, defaultBrowserOptions);\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.EMPTY_PAGE);\n        await page.evaluate(() => {\n          return (document.cookie =\n            'doSomethingOnlyOnce=true; expires=Fri, 31 Dec 9999 23:59:59 GMT');\n        });\n        await browser.close();\n\n        const browser2 = await puppeteer.launch(options);\n        const page2 = await browser2.newPage();\n        await page2.goto(server.EMPTY_PAGE);\n        expect(\n          await page2.evaluate(() => {\n            return document.cookie;\n          })\n        ).toBe('doSomethingOnlyOnce=true');\n        await browser2.close();\n        // This might throw. See https://github.com/puppeteer/puppeteer/issues/2778\n        await rmAsync(userDataDir).catch(() => {});\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should return the default arguments","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":406,"column":45},"line":406,"code":"      it('should return the default arguments', async () => {\n        const {isChrome, isFirefox, puppeteer} = getTestState();\n\n        if (isChrome) {\n          expect(puppeteer.defaultArgs()).toContain('--no-first-run');\n          expect(puppeteer.defaultArgs()).toContain('--headless');\n          expect(puppeteer.defaultArgs({headless: false})).not.toContain(\n            '--headless'\n          );\n          expect(puppeteer.defaultArgs({userDataDir: 'foo'})).toContain(\n            `--user-data-dir=${path.resolve('foo')}`\n          );\n        } else if (isFirefox) {\n          expect(puppeteer.defaultArgs()).toContain('--headless');\n          expect(puppeteer.defaultArgs()).toContain('--no-remote');\n          if (os.platform() === 'darwin') {\n            expect(puppeteer.defaultArgs()).toContain('--foreground');\n          } else {\n            expect(puppeteer.defaultArgs()).not.toContain('--foreground');\n          }\n          expect(puppeteer.defaultArgs({headless: false})).not.toContain(\n            '--headless'\n          );\n          expect(puppeteer.defaultArgs({userDataDir: 'foo'})).toContain(\n            '--profile'\n          );\n          expect(puppeteer.defaultArgs({userDataDir: 'foo'})).toContain('foo');\n        } else {\n          expect(puppeteer.defaultArgs()).toContain('-headless');\n          expect(puppeteer.defaultArgs({headless: false})).not.toContain(\n            '-headless'\n          );\n          expect(puppeteer.defaultArgs({userDataDir: 'foo'})).toContain(\n            '-profile'\n          );\n          expect(puppeteer.defaultArgs({userDataDir: 'foo'})).toContain(\n            path.resolve('foo')\n          );\n        }\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should report the correct product","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":446,"column":43},"line":446,"code":"      it('should report the correct product', async () => {\n        const {isChrome, isFirefox, puppeteer} = getTestState();\n        if (isChrome) {\n          expect(puppeteer.product).toBe('chrome');\n        } else if (isFirefox) {\n          expect(puppeteer.product).toBe('firefox');\n        }\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no default arguments","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":454,"column":47},"line":454,"code":"      it('should work with no default arguments', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions);\n        options.ignoreDefaultArgs = true;\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(await page.evaluate('11 * 11')).toBe(121);\n        await page.close();\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should filter out ignored default arguments in Chrome","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":464,"column":63},"line":464,"code":"      it('should filter out ignored default arguments in Chrome', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        // Make sure we launch with `--enable-automation` by default.\n        const defaultArgs = puppeteer.defaultArgs();\n        const browser = await puppeteer.launch(\n          Object.assign({}, defaultBrowserOptions, {\n            // Ignore first and third default argument.\n            ignoreDefaultArgs: [defaultArgs[0]!, defaultArgs[2]],\n          })\n        );\n        const spawnargs = browser.process()!.spawnargs;\n        if (!spawnargs) {\n          throw new Error('spawnargs not present');\n        }\n        expect(spawnargs.indexOf(defaultArgs[0]!)).toBe(-1);\n        expect(spawnargs.indexOf(defaultArgs[1]!)).not.toBe(-1);\n        expect(spawnargs.indexOf(defaultArgs[2]!)).toBe(-1);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should filter out ignored default argument in Firefox","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":483,"column":63},"line":483,"code":"      it('should filter out ignored default argument in Firefox', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        const defaultArgs = puppeteer.defaultArgs();\n        const browser = await puppeteer.launch(\n          Object.assign({}, defaultBrowserOptions, {\n            // Only the first argument is fixed, others are optional.\n            ignoreDefaultArgs: [defaultArgs[0]!],\n          })\n        );\n        const spawnargs = browser.process()!.spawnargs;\n        if (!spawnargs) {\n          throw new Error('spawnargs not present');\n        }\n        expect(spawnargs.indexOf(defaultArgs[0]!)).toBe(-1);\n        expect(spawnargs.indexOf(defaultArgs[1]!)).not.toBe(-1);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should have default URL when launching browser","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":501,"column":56},"line":501,"code":"      it('should have default URL when launching browser', async function () {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        const browser = await puppeteer.launch(defaultBrowserOptions);\n        const pages = (await browser.pages()).map(page => {\n          return page.url();\n        });\n        expect(pages).toEqual(['about:blank']);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should have custom URL when launching browser","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":510,"column":55},"line":510,"code":"      it('should have custom URL when launching browser', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions);\n        options.args = [server.EMPTY_PAGE].concat(options.args || []);\n        const browser = await puppeteer.launch(options);\n        const pages = await browser.pages();\n        expect(pages.length).toBe(1);\n        const page = pages[0]!;\n        if (page.url() !== server.EMPTY_PAGE) {\n          await page.waitForNavigation();\n        }\n        expect(page.url()).toBe(server.EMPTY_PAGE);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should pass the timeout parameter to browser.waitForTarget","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":525,"column":68},"line":525,"code":"      it('should pass the timeout parameter to browser.waitForTarget', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          timeout: 1,\n        });\n        let error!: Error;\n        await puppeteer.launch(options).catch(error_ => {\n          return (error = error_);\n        });\n        expect(error).toBeInstanceOf(TimeoutError);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should work with timeout = 0","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":536,"column":38},"line":536,"code":"      it('should work with timeout = 0', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          timeout: 0,\n        });\n        const browser = await puppeteer.launch(options);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should set the default viewport","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":544,"column":41},"line":544,"code":"      it('should set the default viewport', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: {\n            width: 456,\n            height: 789,\n          },\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(await page.evaluate('window.innerWidth')).toBe(456);\n        expect(await page.evaluate('window.innerHeight')).toBe(789);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should disable the default viewport","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":558,"column":45},"line":558,"code":"      it('should disable the default viewport', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        expect(page.viewport()).toBe(null);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should take fullPage screenshots when defaultViewport is null","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":568,"column":71},"line":568,"code":"      it('should take fullPage screenshots when defaultViewport is null', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n        });\n        const browser = await puppeteer.launch(options);\n        const page = await browser.newPage();\n        await page.goto(server.PREFIX + '/grid.html');\n        const screenshot = await page.screenshot({\n          fullPage: true,\n        });\n        expect(screenshot).toBeInstanceOf(Buffer);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should set the debugging port","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":583,"column":39},"line":583,"code":"      it('should set the debugging port', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n          debuggingPort: 9999,\n        });\n        const browser = await puppeteer.launch(options);\n        const url = new URL(browser.wsEndpoint());\n        await browser.close();\n        expect(url.port).toBe('9999');\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should not allow setting debuggingPort and pipe","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":595,"column":57},"line":595,"code":"      it('should not allow setting debuggingPort and pipe', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n\n        const options = Object.assign({}, defaultBrowserOptions, {\n          defaultViewport: null,\n          debuggingPort: 9999,\n          pipe: true,\n        });\n\n        let error!: Error;\n        await puppeteer.launch(options).catch(error_ => {\n          return (error = error_);\n        });\n        expect(error.message).toContain('either pipe or debugging port');\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should launch Chrome properly with --no-startup-window and waitForInitialPage=false","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":610,"column":93},"line":610,"code":"      it('should launch Chrome properly with --no-startup-window and waitForInitialPage=false', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n        const options = {\n          waitForInitialPage: false,\n          // This is needed to prevent Puppeteer from adding an initial blank page.\n          // See also https://github.com/puppeteer/puppeteer/blob/ad6b736039436fcc5c0a262e5b575aa041427be3/src/node/Launcher.ts#L200\n          ignoreDefaultArgs: true,\n          ...defaultBrowserOptions,\n          args: ['--no-startup-window'],\n        };\n        const browser = await puppeteer.launch(options);\n        const pages = await browser.pages();\n        expect(pages.length).toBe(0);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to launch Firefox","suites":["Launcher specs","Puppeteer","Puppeteer.launch"],"updatePoint":{"line":636,"column":42},"line":636,"code":"      it('should be able to launch Firefox', async function () {\n        this.timeout(FIREFOX_TIMEOUT);\n        const {puppeteer} = getTestState();\n        const browser = await puppeteer.launch({product: 'firefox'});\n        const userAgent = await browser.userAgent();\n        await browser.close();\n        expect(userAgent).toContain('Firefox');\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect multiple times to the same browser","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":647,"column":70},"line":647,"code":"      it('should be able to connect multiple times to the same browser', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const otherBrowser = await puppeteer.connect({\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        });\n        const page = await otherBrowser.newPage();\n        expect(\n          await page.evaluate(() => {\n            return 7 * 8;\n          })\n        ).toBe(56);\n        otherBrowser.disconnect();\n\n        const secondPage = await originalBrowser.newPage();\n        expect(\n          await secondPage.evaluate(() => {\n            return 7 * 6;\n          })\n        ).toBe(42);\n        await originalBrowser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to close remote browser","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":670,"column":48},"line":670,"code":"      it('should be able to close remote browser', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const remoteBrowser = await puppeteer.connect({\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        });\n        await Promise.all([\n          utils.waitEvent(originalBrowser, 'disconnected'),\n          remoteBrowser.close(),\n        ]);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect to a browser with no page targets","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":682,"column":69},"line":682,"code":"      it('should be able to connect to a browser with no page targets', async () => {\n        const {defaultBrowserOptions, puppeteer} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const pages = await originalBrowser.pages();\n        await Promise.all(\n          pages.map(page => {\n            return page.close();\n          })\n        );\n        const remoteBrowser = await puppeteer.connect({\n          browserWSEndpoint: originalBrowser.wsEndpoint(),\n        });\n        await Promise.all([\n          utils.waitEvent(originalBrowser, 'disconnected'),\n          remoteBrowser.close(),\n        ]);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should support ignoreHTTPSErrors option","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":700,"column":49},"line":700,"code":"      it('should support ignoreHTTPSErrors option', async () => {\n        const {httpsServer, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const browserWSEndpoint = originalBrowser.wsEndpoint();\n\n        const browser = await puppeteer.connect({\n          browserWSEndpoint,\n          ignoreHTTPSErrors: true,\n        });\n        const page = await browser.newPage();\n        let error!: Error;\n        const [serverRequest, response] = await Promise.all([\n          httpsServer.waitForRequest('/empty.html'),\n          page.goto(httpsServer.EMPTY_PAGE).catch(error_ => {\n            return (error = error_);\n          }),\n        ]);\n        expect(error).toBeUndefined();\n        expect(response.ok()).toBe(true);\n        expect(response.securityDetails()).toBeTruthy();\n        const protocol = (serverRequest.socket as TLSSocket)\n          .getProtocol()!\n          .replace('v', ' ');\n        expect(response.securityDetails().protocol()).toBe(protocol);\n        await page.close();\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should support targetFilter option in puppeteer.launch","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":729,"column":64},"line":729,"code":"      it('should support targetFilter option in puppeteer.launch', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n        const browser = await puppeteer.launch({\n          ...defaultBrowserOptions,\n          targetFilter: target => {\n            return target.type !== 'page';\n          },\n          waitForInitialPage: false,\n        });\n        try {\n          const targets = browser.targets();\n          expect(targets.length).toEqual(1);\n          expect(\n            targets.find(target => {\n              return target.type() === 'page';\n            })\n          ).toBeUndefined();\n        } finally {\n          await browser.close();\n        }\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should support targetFilter option","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":752,"column":44},"line":752,"code":"      it('should support targetFilter option', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const browserWSEndpoint = originalBrowser.wsEndpoint();\n\n        const page1 = await originalBrowser.newPage();\n        await page1.goto(server.EMPTY_PAGE);\n\n        const page2 = await originalBrowser.newPage();\n        await page2.goto(server.EMPTY_PAGE + '?should-be-ignored');\n\n        const browser = await puppeteer.connect({\n          browserWSEndpoint,\n          targetFilter: (targetInfo: Protocol.Target.TargetInfo) => {\n            return !targetInfo.url?.includes('should-be-ignored');\n          },\n        });\n\n        const pages = await browser.pages();\n\n        await page2.close();\n        await page1.close();\n        await browser.disconnect();\n        await originalBrowser.close();\n\n        expect(\n          pages\n            .map((p: Page) => {\n              return p.url();\n            })\n            .sort()\n        ).toEqual(['about:blank', server.EMPTY_PAGE]);\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to reconnect to a disconnected browser","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":786,"column":63},"line":786,"code":"      it('should be able to reconnect to a disconnected browser', async () => {\n        const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n        const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n        const browserWSEndpoint = originalBrowser.wsEndpoint();\n        const page = await originalBrowser.newPage();\n        await page.goto(server.PREFIX + '/frames/nested-frames.html');\n        originalBrowser.disconnect();\n\n        const browser = await puppeteer.connect({browserWSEndpoint});\n        const pages = await browser.pages();\n        const restoredPage = pages.find(page => {\n          return page.url() === server.PREFIX + '/frames/nested-frames.html';\n        })!;\n        expect(utils.dumpFrames(restoredPage.mainFrame())).toEqual([\n          'http://localhost:<PORT>/frames/nested-frames.html',\n          '    http://localhost:<PORT>/frames/two-frames.html (2frames)',\n          '        http://localhost:<PORT>/frames/frame.html (uno)',\n          '        http://localhost:<PORT>/frames/frame.html (dos)',\n          '    http://localhost:<PORT>/frames/frame.html (aframe)',\n        ]);\n        expect(\n          await restoredPage.evaluate(() => {\n            return 7 * 8;\n          })\n        ).toBe(56);\n        await browser.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to connect to the same page simultaneously","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":815,"column":67},"line":815,"code":"      it('should be able to connect to the same page simultaneously', async () => {\n        const {puppeteer, defaultBrowserOptions} = getTestState();\n\n        const browserOne = await puppeteer.launch(defaultBrowserOptions);\n        const browserTwo = await puppeteer.connect({\n          browserWSEndpoint: browserOne.wsEndpoint(),\n        });\n        const [page1, page2] = await Promise.all([\n          new Promise<Page>(x => {\n            return browserOne.once('targetcreated', target => {\n              return x(target.page());\n            });\n          }),\n          browserTwo.newPage(),\n        ]);\n        expect(\n          await page1.evaluate(() => {\n            return 7 * 8;\n          })\n        ).toBe(56);\n        expect(\n          await page2.evaluate(() => {\n            return 7 * 6;\n          })\n        ).toBe(42);\n        await browserOne.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to reconnect","suites":["Launcher specs","Puppeteer","Puppeteer.connect"],"updatePoint":{"line":842,"column":37},"line":842,"code":"      it('should be able to reconnect', async () => {\n        const {puppeteer, server, defaultBrowserOptions} = getTestState();\n        const browserOne = await puppeteer.launch(defaultBrowserOptions);\n        const browserWSEndpoint = browserOne.wsEndpoint();\n        const pageOne = await browserOne.newPage();\n        await pageOne.goto(server.EMPTY_PAGE);\n        browserOne.disconnect();\n\n        const browserTwo = await puppeteer.connect({\n          browserWSEndpoint,\n        });\n        const pages = await browserTwo.pages();\n        const pageTwo = pages.find(page => {\n          return page.url() === server.EMPTY_PAGE;\n        })!;\n        await pageTwo.reload();\n        const bodyHandle = await pageTwo.waitForSelector('body', {\n          timeout: 10000,\n        });\n        await bodyHandle!.dispose();\n        await browserTwo.close();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"returns executablePath for channel","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath"],"updatePoint":{"line":873,"column":44},"line":873,"code":"      it('returns executablePath for channel', () => {\n        const {puppeteer} = getTestState();\n\n        const executablePath = puppeteer.executablePath('chrome');\n        expect(executablePath).toBeTruthy();\n      });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"its value is used","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when executable path is configured"],"updatePoint":{"line":893,"column":29},"line":893,"code":"        it('its value is used', async () => {\n          const {puppeteer} = getTestState();\n          try {\n            puppeteer.executablePath();\n          } catch (error) {\n            expect((error as Error).message).toContain(\n              'SOME_CUSTOM_EXECUTABLE'\n            );\n          }\n        });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"returns /usr/bin/chromium-browser","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when the product is chrome, platform is not darwin, and arch is arm64","and the executable exists"],"updatePoint":{"line":907,"column":47},"line":907,"code":"          it('returns /usr/bin/chromium-browser', async () => {\n            const {puppeteer} = getTestState();\n            const osPlatformStub = sinon.stub(os, 'platform').returns('linux');\n            const osArchStub = sinon.stub(os, 'arch').returns('arm64');\n            const fsExistsStub = sinon.stub(fs, 'existsSync');\n            fsExistsStub.withArgs('/usr/bin/chromium-browser').returns(true);\n\n            const executablePath = puppeteer.executablePath();\n\n            expect(executablePath).toEqual('/usr/bin/chromium-browser');\n\n            osPlatformStub.restore();\n            osArchStub.restore();\n            fsExistsStub.restore();\n          });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"its value is used","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when the product is chrome, platform is not darwin, and arch is arm64","and the executable exists","and the executable path is configured"],"updatePoint":{"line":936,"column":33},"line":936,"code":"            it('its value is used', async () => {\n              const {puppeteer} = getTestState();\n              try {\n                puppeteer.executablePath();\n              } catch (error) {\n                expect((error as Error).message).toContain(\n                  'SOME_CUSTOM_EXECUTABLE'\n                );\n              }\n            });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"does not return /usr/bin/chromium-browser","suites":["Launcher specs","Puppeteer","Puppeteer.executablePath","when the product is chrome, platform is not darwin, and arch is arm64","and the executable does not exist"],"updatePoint":{"line":949,"column":55},"line":949,"code":"          it('does not return /usr/bin/chromium-browser', async () => {\n            const {puppeteer} = getTestState();\n            const osPlatformStub = sinon.stub(os, 'platform').returns('linux');\n            const osArchStub = sinon.stub(os, 'arch').returns('arm64');\n            const fsExistsStub = sinon.stub(fs, 'existsSync');\n            fsExistsStub.withArgs('/usr/bin/chromium-browser').returns(false);\n\n            expect(() => {\n              return puppeteer.executablePath();\n            }).toThrowError();\n\n            osPlatformStub.restore();\n            osArchStub.restore();\n            fsExistsStub.restore();\n          });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Launcher specs","Browser target events"],"updatePoint":{"line":970,"column":19},"line":970,"code":"    it('should work', async () => {\n      const {server, puppeteer, defaultBrowserOptions} = getTestState();\n\n      const browser = await puppeteer.launch(defaultBrowserOptions);\n      const events: string[] = [];\n      browser.on('targetcreated', () => {\n        return events.push('CREATED');\n      });\n      browser.on('targetchanged', () => {\n        return events.push('CHANGED');\n      });\n      browser.on('targetdestroyed', () => {\n        return events.push('DESTROYED');\n      });\n      const page = await browser.newPage();\n      await page.goto(server.EMPTY_PAGE);\n      await page.close();\n      expect(events).toEqual(['CREATED', 'CHANGED', 'DESTROYED']);\n      await browser.close();\n    });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should be emitted when: browser gets closed, disconnected or underlying websocket gets closed","suites":["Launcher specs","Browser.Events.disconnected"],"updatePoint":{"line":993,"column":101},"line":993,"code":"    it('should be emitted when: browser gets closed, disconnected or underlying websocket gets closed', async () => {\n      const {puppeteer, defaultBrowserOptions} = getTestState();\n      const originalBrowser = await puppeteer.launch(defaultBrowserOptions);\n      const browserWSEndpoint = originalBrowser.wsEndpoint();\n      const remoteBrowser1 = await puppeteer.connect({\n        browserWSEndpoint,\n      });\n      const remoteBrowser2 = await puppeteer.connect({\n        browserWSEndpoint,\n      });\n\n      let disconnectedOriginal = 0;\n      let disconnectedRemote1 = 0;\n      let disconnectedRemote2 = 0;\n      originalBrowser.on('disconnected', () => {\n        return ++disconnectedOriginal;\n      });\n      remoteBrowser1.on('disconnected', () => {\n        return ++disconnectedRemote1;\n      });\n      remoteBrowser2.on('disconnected', () => {\n        return ++disconnectedRemote2;\n      });\n\n      await Promise.all([\n        utils.waitEvent(remoteBrowser2, 'disconnected'),\n        remoteBrowser2.disconnect(),\n      ]);\n\n      expect(disconnectedOriginal).toBe(0);\n      expect(disconnectedRemote1).toBe(0);\n      expect(disconnectedRemote2).toBe(1);\n\n      await Promise.all([\n        utils.waitEvent(remoteBrowser1, 'disconnected'),\n        utils.waitEvent(originalBrowser, 'disconnected'),\n        originalBrowser.close(),\n      ]);\n\n      expect(disconnectedOriginal).toBe(1);\n      expect(disconnectedRemote1).toBe(1);\n      expect(disconnectedRemote2).toBe(1);\n    });","file":"src/launcher.spec.ts","skipped":false,"dir":"test"},{"name":"should click the document","suites":["Mouse"],"updatePoint":{"line":45,"column":31},"line":45,"code":"  it('should click the document', async () => {\n    const {page} = getTestState();\n\n    await page.evaluate(() => {\n      (globalThis as any).clickPromise = new Promise(resolve => {\n        document.addEventListener('click', event => {\n          resolve({\n            type: event.type,\n            detail: event.detail,\n            clientX: event.clientX,\n            clientY: event.clientY,\n            isTrusted: event.isTrusted,\n            button: event.button,\n          });\n        });\n      });\n    });\n    await page.mouse.click(50, 60);\n    const event = await page.evaluate(() => {\n      return (globalThis as any).clickPromise;\n    });\n    expect(event.type).toBe('click');\n    expect(event.detail).toBe(1);\n    expect(event.clientX).toBe(50);\n    expect(event.clientY).toBe(60);\n    expect(event.isTrusted).toBe(true);\n    expect(event.button).toBe(0);\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should resize the textarea","suites":["Mouse"],"updatePoint":{"line":73,"column":32},"line":73,"code":"  it('should resize the textarea', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    const {x, y, width, height} = await page.evaluate(dimensions);\n    const mouse = page.mouse;\n    await mouse.move(x + width - 4, y + height - 4);\n    await mouse.down();\n    await mouse.move(x + width + 100, y + height + 100);\n    await mouse.up();\n    const newDimensions = await page.evaluate(dimensions);\n    expect(newDimensions.width).toBe(Math.round(width + 104));\n    expect(newDimensions.height).toBe(Math.round(height + 104));\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should select the text with mouse","suites":["Mouse"],"updatePoint":{"line":87,"column":39},"line":87,"code":"  it('should select the text with mouse', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/textarea.html');\n    await page.focus('textarea');\n    const text =\n      \"This is the text that we are going to try to select. Let's see how it goes.\";\n    await page.keyboard.type(text);\n    // Firefox needs an extra frame here after typing or it will fail to set the scrollTop\n    await page.evaluate(() => {\n      return new Promise(requestAnimationFrame);\n    });\n    await page.evaluate(() => {\n      return (document.querySelector('textarea')!.scrollTop = 0);\n    });\n    const {x, y} = await page.evaluate(dimensions);\n    await page.mouse.move(x + 2, y + 2);\n    await page.mouse.down();\n    await page.mouse.move(100, 100);\n    await page.mouse.up();\n    expect(\n      await page.evaluate(() => {\n        const textarea = document.querySelector('textarea')!;\n        return textarea.value.substring(\n          textarea.selectionStart,\n          textarea.selectionEnd\n        );\n      })\n    ).toBe(text);\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger hover state","suites":["Mouse"],"updatePoint":{"line":117,"column":32},"line":117,"code":"  it('should trigger hover state', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.hover('#button-6');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('button:hover')!.id;\n      })\n    ).toBe('button-6');\n    await page.hover('#button-2');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('button:hover')!.id;\n      })\n    ).toBe('button-2');\n    await page.hover('#button-91');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('button:hover')!.id;\n      })\n    ).toBe('button-91');\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger hover state with removed window.Node","suites":["Mouse"],"updatePoint":{"line":140,"column":57},"line":140,"code":"  it('should trigger hover state with removed window.Node', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.evaluate(() => {\n      // @ts-expect-error Expected.\n      return delete window.Node;\n    });\n    await page.hover('#button-6');\n    expect(\n      await page.evaluate(() => {\n        return document.querySelector('button:hover')!.id;\n      })\n    ).toBe('button-6');\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should set modifier keys on click","suites":["Mouse"],"updatePoint":{"line":155,"column":39},"line":155,"code":"  it('should set modifier keys on click', async () => {\n    const {page, server, isFirefox} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/scrollable.html');\n    await page.evaluate(() => {\n      return document.querySelector('#button-3')!.addEventListener(\n        'mousedown',\n        e => {\n          return ((globalThis as any).lastEvent = e);\n        },\n        true\n      );\n    });\n    const modifiers = new Map<KeyInput, string>([\n      ['Shift', 'shiftKey'],\n      ['Control', 'ctrlKey'],\n      ['Alt', 'altKey'],\n      ['Meta', 'metaKey'],\n    ]);\n    // In Firefox, the Meta modifier only exists on Mac\n    if (isFirefox && os.platform() !== 'darwin') {\n      modifiers.delete('Meta');\n    }\n    for (const [modifier, key] of modifiers) {\n      await page.keyboard.down(modifier);\n      await page.click('#button-3');\n      if (\n        !(await page.evaluate((mod: string) => {\n          return (globalThis as any).lastEvent[mod];\n        }, key))\n      ) {\n        throw new Error(key + ' should be true');\n      }\n      await page.keyboard.up(modifier);\n    }\n    await page.click('#button-3');\n    for (const [modifier, key] of modifiers) {\n      if (\n        await page.evaluate((mod: string) => {\n          return (globalThis as any).lastEvent[mod];\n        }, key)\n      ) {\n        throw new Error(modifiers.get(modifier) + ' should be false');\n      }\n    }\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should send mouse wheel events","suites":["Mouse"],"updatePoint":{"line":201,"column":36},"line":201,"code":"  it('should send mouse wheel events', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.PREFIX + '/input/wheel.html');\n    const elem = (await page.$('div'))!;\n    const boundingBoxBefore = (await elem.boundingBox())!;\n    expect(boundingBoxBefore).toMatchObject({\n      width: 115,\n      height: 115,\n    });\n\n    await page.mouse.move(\n      boundingBoxBefore.x + boundingBoxBefore.width / 2,\n      boundingBoxBefore.y + boundingBoxBefore.height / 2\n    );\n\n    await page.mouse.wheel({deltaY: -100});\n    const boundingBoxAfter = await elem.boundingBox();\n    expect(boundingBoxAfter).toMatchObject({\n      width: 230,\n      height: 230,\n    });\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should tween mouse movement","suites":["Mouse"],"updatePoint":{"line":224,"column":33},"line":224,"code":"  it('should tween mouse movement', async () => {\n    const {page} = getTestState();\n\n    await page.mouse.move(100, 100);\n    await page.evaluate(() => {\n      (globalThis as any).result = [];\n      document.addEventListener('mousemove', event => {\n        (globalThis as any).result.push([event.clientX, event.clientY]);\n      });\n    });\n    await page.mouse.move(200, 300, {steps: 5});\n    expect(await page.evaluate('result')).toEqual([\n      [120, 140],\n      [140, 180],\n      [160, 220],\n      [180, 260],\n      [200, 300],\n    ]);\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should work with mobile viewports and cross process navigations","suites":["Mouse"],"updatePoint":{"line":244,"column":69},"line":244,"code":"  it('should work with mobile viewports and cross process navigations', async () => {\n    const {page, server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.setViewport({width: 360, height: 640, isMobile: true});\n    await page.goto(server.CROSS_PROCESS_PREFIX + '/mobile.html');\n    await page.evaluate(() => {\n      document.addEventListener('click', event => {\n        (globalThis as any).result = {x: event.clientX, y: event.clientY};\n      });\n    });\n\n    await page.mouse.click(30, 40);\n\n    expect(await page.evaluate('result')).toEqual({x: 30, y: 40});\n  });","file":"src/mouse.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.goto"],"updatePoint":{"line":32,"column":19},"line":32,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with anchor navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":38,"column":42},"line":38,"code":"    it('should work with anchor navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      await page.goto(server.EMPTY_PAGE + '#foo');\n      expect(page.url()).toBe(server.EMPTY_PAGE + '#foo');\n      await page.goto(server.EMPTY_PAGE + '#bar');\n      expect(page.url()).toBe(server.EMPTY_PAGE + '#bar');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["navigation","Page.goto"],"updatePoint":{"line":48,"column":34},"line":48,"code":"    it('should work with redirects', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/empty.html');\n      await page.goto(server.PREFIX + '/redirect/1.html');\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to about:blank","suites":["navigation","Page.goto"],"updatePoint":{"line":56,"column":38},"line":56,"code":"    it('should navigate to about:blank', async () => {\n      const {page} = getTestState();\n\n      const response = await page.goto('about:blank');\n      expect(response).toBe(null);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return response when page changes its URL after load","suites":["navigation","Page.goto"],"updatePoint":{"line":62,"column":67},"line":62,"code":"    it('should return response when page changes its URL after load', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/historyapi.html'))!;\n      expect(response.status()).toBe(200);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with subframes return 204","suites":["navigation","Page.goto"],"updatePoint":{"line":68,"column":45},"line":68,"code":"    it('should work with subframes return 204', async () => {\n      const {page, server} = getTestState();\n\n      server.setRoute('/frames/frame.html', (_req, res) => {\n        res.statusCode = 204;\n        res.end();\n      });\n      let error!: Error;\n      await page\n        .goto(server.PREFIX + '/frames/one-frame.html')\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeUndefined();\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when server returns 204","suites":["navigation","Page.goto"],"updatePoint":{"line":83,"column":43},"line":83,"code":"    it('should fail when server returns 204', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      server.setRoute('/empty.html', (_req, res) => {\n        res.statusCode = 204;\n        res.end();\n      });\n      let error!: Error;\n      await page.goto(server.EMPTY_PAGE).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).not.toBe(null);\n      if (isChrome) {\n        expect(error.message).toContain('net::ERR_ABORTED');\n      } else {\n        expect(error.message).toContain('NS_BINDING_ABORTED');\n      }\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to empty page with domcontentloaded","suites":["navigation","Page.goto"],"updatePoint":{"line":101,"column":59},"line":101,"code":"    it('should navigate to empty page with domcontentloaded', async () => {\n      const {page, server} = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE, {\n        waitUntil: 'domcontentloaded',\n      });\n      expect(response!.status()).toBe(200);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when page calls history API in beforeunload","suites":["navigation","Page.goto"],"updatePoint":{"line":109,"column":63},"line":109,"code":"    it('should work when page calls history API in beforeunload', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        window.addEventListener(\n          'beforeunload',\n          () => {\n            return history.replaceState(null, 'initial', window.location.href);\n          },\n          false\n        );\n      });\n      const response = await page.goto(server.PREFIX + '/grid.html');\n      expect(response!.status()).toBe(200);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to empty page with networkidle0","suites":["navigation","Page.goto"],"updatePoint":{"line":125,"column":55},"line":125,"code":"    it('should navigate to empty page with networkidle0', async () => {\n      const {page, server} = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE, {\n        waitUntil: 'networkidle0',\n      });\n      expect(response!.status()).toBe(200);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to empty page with networkidle2","suites":["navigation","Page.goto"],"updatePoint":{"line":133,"column":55},"line":133,"code":"    it('should navigate to empty page with networkidle2', async () => {\n      const {page, server} = getTestState();\n\n      const response = await page.goto(server.EMPTY_PAGE, {\n        waitUntil: 'networkidle2',\n      });\n      expect(response!.status()).toBe(200);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating to bad url","suites":["navigation","Page.goto"],"updatePoint":{"line":141,"column":46},"line":141,"code":"    it('should fail when navigating to bad url', async () => {\n      const {page, isChrome} = getTestState();\n\n      let error!: Error;\n      await page.goto('asdfasdf').catch(error_ => {\n        return (error = error_);\n      });\n      if (isChrome) {\n        expect(error.message).toContain('Cannot navigate to invalid URL');\n      } else {\n        expect(error.message).toContain('Invalid url');\n      }\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating to bad SSL","suites":["navigation","Page.goto"],"updatePoint":{"line":158,"column":46},"line":158,"code":"    it('should fail when navigating to bad SSL', async () => {\n      const {page, httpsServer, isChrome} = getTestState();\n\n      // Make sure that network events do not emit 'undefined'.\n      // @see https://crbug.com/750469\n      const requests: string[] = [];\n      page.on('request', () => {\n        return requests.push('request');\n      });\n      page.on('requestfinished', () => {\n        return requests.push('requestfinished');\n      });\n      page.on('requestfailed', () => {\n        return requests.push('requestfailed');\n      });\n\n      let error!: Error;\n      await page.goto(httpsServer.EMPTY_PAGE).catch(error_ => {\n        return (error = error_);\n      });\n      if (isChrome) {\n        expect(error.message).toMatch(EXPECTED_SSL_CERT_MESSAGE_REGEX);\n      } else {\n        expect(error.message).toContain('SSL_ERROR_UNKNOWN');\n      }\n\n      expect(requests.length).toBe(2);\n      expect(requests[0]!).toBe('request');\n      expect(requests[1]!).toBe('requestfailed');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating to bad SSL after redirects","suites":["navigation","Page.goto"],"updatePoint":{"line":188,"column":62},"line":188,"code":"    it('should fail when navigating to bad SSL after redirects', async () => {\n      const {page, server, httpsServer, isChrome} = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/empty.html');\n      let error!: Error;\n      await page.goto(httpsServer.PREFIX + '/redirect/1.html').catch(error_ => {\n        return (error = error_);\n      });\n      if (isChrome) {\n        expect(error.message).toMatch(EXPECTED_SSL_CERT_MESSAGE_REGEX);\n      } else {\n        expect(error.message).toContain('SSL_ERROR_UNKNOWN');\n      }\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when main resources failed to load","suites":["navigation","Page.goto"],"updatePoint":{"line":203,"column":54},"line":203,"code":"    it('should fail when main resources failed to load', async () => {\n      const {page, isChrome} = getTestState();\n\n      let error!: Error;\n      await page\n        .goto('http://localhost:44123/non-existing-url')\n        .catch(error_ => {\n          return (error = error_);\n        });\n      if (isChrome) {\n        expect(error.message).toContain('net::ERR_CONNECTION_REFUSED');\n      } else {\n        expect(error.message).toContain('NS_ERROR_CONNECTION_REFUSED');\n      }\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding maximum navigation timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":218,"column":61},"line":218,"code":"    it('should fail when exceeding maximum navigation timeout', async () => {\n      const {page, server} = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error!: Error;\n      await page\n        .goto(server.PREFIX + '/empty.html', {timeout: 1})\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding default maximum navigation timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":232,"column":69},"line":232,"code":"    it('should fail when exceeding default maximum navigation timeout', async () => {\n      const {page, server} = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error!: Error;\n      page.setDefaultNavigationTimeout(1);\n      await page.goto(server.PREFIX + '/empty.html').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when exceeding default maximum timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":245,"column":58},"line":245,"code":"    it('should fail when exceeding default maximum timeout', async () => {\n      const {page, server} = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error!: Error;\n      page.setDefaultTimeout(1);\n      await page.goto(server.PREFIX + '/empty.html').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should prioritize default navigation timeout over default timeout","suites":["navigation","Page.goto"],"updatePoint":{"line":258,"column":73},"line":258,"code":"    it('should prioritize default navigation timeout over default timeout', async () => {\n      const {page, server} = getTestState();\n\n      // Hang for request to the empty.html\n      server.setRoute('/empty.html', () => {});\n      let error!: Error;\n      page.setDefaultTimeout(0);\n      page.setDefaultNavigationTimeout(1);\n      await page.goto(server.PREFIX + '/empty.html').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain('Navigation timeout of 1 ms exceeded');\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should disable timeout when its set to 0","suites":["navigation","Page.goto"],"updatePoint":{"line":272,"column":48},"line":272,"code":"    it('should disable timeout when its set to 0', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      let loaded = false;\n      page.once('load', () => {\n        return (loaded = true);\n      });\n      await page\n        .goto(server.PREFIX + '/grid.html', {timeout: 0, waitUntil: ['load']})\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeUndefined();\n      expect(loaded).toBe(true);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to valid url","suites":["navigation","Page.goto"],"updatePoint":{"line":288,"column":48},"line":288,"code":"    it('should work when navigating to valid url', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.ok()).toBe(true);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to data url","suites":["navigation","Page.goto"],"updatePoint":{"line":294,"column":47},"line":294,"code":"    it('should work when navigating to data url', async () => {\n      const {page} = getTestState();\n\n      const response = (await page.goto('data:text/html,hello'))!;\n      expect(response.ok()).toBe(true);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to 404","suites":["navigation","Page.goto"],"updatePoint":{"line":300,"column":42},"line":300,"code":"    it('should work when navigating to 404', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/not-found'))!;\n      expect(response.ok()).toBe(false);\n      expect(response.status()).toBe(404);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return last response in redirect chain","suites":["navigation","Page.goto"],"updatePoint":{"line":307,"column":53},"line":307,"code":"    it('should return last response in redirect chain', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/redirect/1.html', '/redirect/2.html');\n      server.setRedirect('/redirect/2.html', '/redirect/3.html');\n      server.setRedirect('/redirect/3.html', server.EMPTY_PAGE);\n      const response = (await page.goto(server.PREFIX + '/redirect/1.html'))!;\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for network idle to succeed navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":317,"column":58},"line":317,"code":"    it('should wait for network idle to succeed navigation', async () => {\n      const {page, server} = getTestState();\n\n      let responses: ServerResponse[] = [];\n      // Hold on to a bunch of requests without answering.\n      server.setRoute('/fetch-request-a.js', (_req, res) => {\n        return responses.push(res);\n      });\n      server.setRoute('/fetch-request-b.js', (_req, res) => {\n        return responses.push(res);\n      });\n      server.setRoute('/fetch-request-c.js', (_req, res) => {\n        return responses.push(res);\n      });\n      server.setRoute('/fetch-request-d.js', (_req, res) => {\n        return responses.push(res);\n      });\n      const initialFetchResourcesRequested = Promise.all([\n        server.waitForRequest('/fetch-request-a.js'),\n        server.waitForRequest('/fetch-request-b.js'),\n        server.waitForRequest('/fetch-request-c.js'),\n      ]);\n      const secondFetchResourceRequested = server.waitForRequest(\n        '/fetch-request-d.js'\n      );\n\n      // Navigate to a page which loads immediately and then does a bunch of\n      // requests via javascript's fetch method.\n      const navigationPromise = page.goto(server.PREFIX + '/networkidle.html', {\n        waitUntil: 'networkidle0',\n      });\n      // Track when the navigation gets completed.\n      let navigationFinished = false;\n      navigationPromise.then(() => {\n        return (navigationFinished = true);\n      });\n\n      // Wait for the page's 'load' event.\n      await new Promise(fulfill => {\n        return page.once('load', fulfill);\n      });\n      expect(navigationFinished).toBe(false);\n\n      // Wait for the initial three resources to be requested.\n      await initialFetchResourcesRequested;\n\n      // Expect navigation still to be not finished.\n      expect(navigationFinished).toBe(false);\n\n      // Respond to initial requests.\n      for (const response of responses) {\n        response.statusCode = 404;\n        response.end(`File not found`);\n      }\n\n      // Reset responses array\n      responses = [];\n\n      // Wait for the second round to be requested.\n      await secondFetchResourceRequested;\n      // Expect navigation still to be not finished.\n      expect(navigationFinished).toBe(false);\n\n      // Respond to requests.\n      for (const response of responses) {\n        response.statusCode = 404;\n        response.end(`File not found`);\n      }\n\n      const response = (await navigationPromise)!;\n      // Expect navigation to succeed.\n      expect(response.ok()).toBe(true);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":390,"column":51},"line":390,"code":"    it('should not leak listeners during navigation', async () => {\n      const {page, server} = getTestState();\n\n      let warning = null;\n      const warningHandler: NodeJS.WarningListener = w => {\n        return (warning = w);\n      };\n      process.on('warning', warningHandler);\n      for (let i = 0; i < 20; ++i) {\n        await page.goto(server.EMPTY_PAGE);\n      }\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during bad navigation","suites":["navigation","Page.goto"],"updatePoint":{"line":404,"column":55},"line":404,"code":"    it('should not leak listeners during bad navigation', async () => {\n      const {page} = getTestState();\n\n      let warning = null;\n      const warningHandler: NodeJS.WarningListener = w => {\n        return (warning = w);\n      };\n      process.on('warning', warningHandler);\n      for (let i = 0; i < 20; ++i) {\n        await page.goto('asdf').catch(() => {\n          /* swallow navigation error */\n        });\n      }\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should not leak listeners during navigation of 11 pages","suites":["navigation","Page.goto"],"updatePoint":{"line":420,"column":63},"line":420,"code":"    it('should not leak listeners during navigation of 11 pages', async () => {\n      const {context, server} = getTestState();\n\n      let warning = null;\n      const warningHandler: NodeJS.WarningListener = w => {\n        return (warning = w);\n      };\n      process.on('warning', warningHandler);\n      await Promise.all(\n        [...Array(20)].map(async () => {\n          const page = await context.newPage();\n          await page.goto(server.EMPTY_PAGE);\n          await page.close();\n        })\n      );\n      process.removeListener('warning', warningHandler);\n      expect(warning).toBe(null);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to dataURL and fire dataURL requests","suites":["navigation","Page.goto"],"updatePoint":{"line":438,"column":60},"line":438,"code":"    it('should navigate to dataURL and fire dataURL requests', async () => {\n      const {page} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const response = (await page.goto(dataURL))!;\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(dataURL);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to URL with hash and fire requests without hash","suites":["navigation","Page.goto"],"updatePoint":{"line":451,"column":71},"line":451,"code":"    it('should navigate to URL with hash and fire requests without hash', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      const response = (await page.goto(server.EMPTY_PAGE + '#hash'))!;\n      expect(response.status()).toBe(200);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with self requesting page","suites":["navigation","Page.goto"],"updatePoint":{"line":464,"column":45},"line":464,"code":"    it('should work with self requesting page', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/self-request.html'))!;\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('self-request.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when navigating and show the url at the error message","suites":["navigation","Page.goto"],"updatePoint":{"line":471,"column":73},"line":471,"code":"    it('should fail when navigating and show the url at the error message', async () => {\n      const {page, httpsServer} = getTestState();\n\n      const url = httpsServer.PREFIX + '/redirect/1.html';\n      let error!: Error;\n      try {\n        await page.goto(url);\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toContain(url);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer","suites":["navigation","Page.goto"],"updatePoint":{"line":483,"column":27},"line":483,"code":"    it('should send referer', async () => {\n      const {page, server} = getTestState();\n\n      const [request1, request2] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        server.waitForRequest('/digits/1.png'),\n        page.goto(server.PREFIX + '/grid.html', {\n          referer: 'http://google.com/',\n        }),\n      ]);\n      expect(request1.headers['referer']).toBe('http://google.com/');\n      // Make sure subresources do not inherit referer.\n      expect(request2.headers['referer']).toBe(server.PREFIX + '/grid.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer policy","suites":["navigation","Page.goto"],"updatePoint":{"line":498,"column":34},"line":498,"code":"    it('should send referer policy', async () => {\n      const {page, server} = getTestState();\n\n      const [request1, request2] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        server.waitForRequest('/digits/1.png'),\n        page.goto(server.PREFIX + '/grid.html', {\n          referrerPolicy: 'no-referer',\n        }),\n      ]);\n      expect(request1.headers['referer']).toBeUndefined();\n      expect(request2.headers['referer']).toBe(server.PREFIX + '/grid.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":514,"column":19},"line":514,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForNavigation(),\n        page.evaluate((url: string) => {\n          return (window.location.href = url);\n        }, server.PREFIX + '/grid.html'),\n      ]);\n      expect(response!.ok()).toBe(true);\n      expect(response!.url()).toContain('grid.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with both domcontentloaded and load","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":527,"column":55},"line":527,"code":"    it('should work with both domcontentloaded and load', async () => {\n      const {page, server} = getTestState();\n\n      let response!: ServerResponse;\n      server.setRoute('/one-style.css', (_req, res) => {\n        return (response = res);\n      });\n      const navigationPromise = page.goto(server.PREFIX + '/one-style.html');\n      const domContentLoadedPromise = page.waitForNavigation({\n        waitUntil: 'domcontentloaded',\n      });\n\n      let bothFired = false;\n      const bothFiredPromise = page\n        .waitForNavigation({\n          waitUntil: ['load', 'domcontentloaded'],\n        })\n        .then(() => {\n          return (bothFired = true);\n        });\n\n      await server.waitForRequest('/one-style.css');\n      await domContentLoadedPromise;\n      expect(bothFired).toBe(false);\n      response.end();\n      await bothFiredPromise;\n      await navigationPromise;\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking on anchor links","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":555,"column":49},"line":555,"code":"    it('should work with clicking on anchor links', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(`<a href='#foobar'>foobar</a>`);\n      const [response] = await Promise.all([\n        page.waitForNavigation(),\n        page.click('a'),\n      ]);\n      expect(response).toBe(null);\n      expect(page.url()).toBe(server.EMPTY_PAGE + '#foobar');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with history.pushState()","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":567,"column":44},"line":567,"code":"    it('should work with history.pushState()', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(`\n        <a onclick='javascript:pushState()'>SPA</a>\n        <script>\n          function pushState() { history.pushState({}, '', 'wow.html') }\n        </script>\n      `);\n      const [response] = await Promise.all([\n        page.waitForNavigation(),\n        page.click('a'),\n      ]);\n      expect(response).toBe(null);\n      expect(page.url()).toBe(server.PREFIX + '/wow.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with history.replaceState()","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":584,"column":47},"line":584,"code":"    it('should work with history.replaceState()', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(`\n        <a onclick='javascript:replaceState()'>SPA</a>\n        <script>\n          function replaceState() { history.replaceState({}, '', '/replaced.html') }\n        </script>\n      `);\n      const [response] = await Promise.all([\n        page.waitForNavigation(),\n        page.click('a'),\n      ]);\n      expect(response).toBe(null);\n      expect(page.url()).toBe(server.PREFIX + '/replaced.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with DOM history.back()/history.forward()","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":601,"column":61},"line":601,"code":"    it('should work with DOM history.back()/history.forward()', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(`\n        <a id=back onclick='javascript:goBack()'>back</a>\n        <a id=forward onclick='javascript:goForward()'>forward</a>\n        <script>\n          function goBack() { history.back(); }\n          function goForward() { history.forward(); }\n          history.pushState({}, '', '/first.html');\n          history.pushState({}, '', '/second.html');\n        </script>\n      `);\n      expect(page.url()).toBe(server.PREFIX + '/second.html');\n      const [backResponse] = await Promise.all([\n        page.waitForNavigation(),\n        page.click('a#back'),\n      ]);\n      expect(backResponse).toBe(null);\n      expect(page.url()).toBe(server.PREFIX + '/first.html');\n      const [forwardResponse] = await Promise.all([\n        page.waitForNavigation(),\n        page.click('a#forward'),\n      ]);\n      expect(forwardResponse).toBe(null);\n      expect(page.url()).toBe(server.PREFIX + '/second.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work when subframe issues window.stop()","suites":["navigation","Page.waitForNavigation"],"updatePoint":{"line":629,"column":54},"line":629,"code":"    it('should work when subframe issues window.stop()', async () => {\n      const {page, server} = getTestState();\n\n      server.setRoute('/frames/style.css', () => {});\n      const navigationPromise = page.goto(\n        server.PREFIX + '/frames/one-frame.html'\n      );\n      const frame = await utils.waitEvent(page, 'frameattached');\n      await new Promise<void>(fulfill => {\n        page.on('framenavigated', f => {\n          if (f === frame) {\n            fulfill();\n          }\n        });\n      });\n      await Promise.all([\n        frame.evaluate(() => {\n          return window.stop();\n        }),\n        navigationPromise,\n      ]);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.goBack"],"updatePoint":{"line":654,"column":19},"line":654,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.goto(server.PREFIX + '/grid.html');\n\n      let response = (await page.goBack())!;\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toContain(server.EMPTY_PAGE);\n\n      response = (await page.goForward())!;\n      expect(response.ok()).toBe(true);\n      expect(response.url()).toContain('/grid.html');\n\n      response = (await page.goForward())!;\n      expect(response).toBe(null);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work with HistoryAPI","suites":["navigation","Page.goBack"],"updatePoint":{"line":671,"column":35},"line":671,"code":"    it('should work with HistoryAPI', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        history.pushState({}, '', '/first.html');\n        history.pushState({}, '', '/second.html');\n      });\n      expect(page.url()).toBe(server.PREFIX + '/second.html');\n\n      await page.goBack();\n      expect(page.url()).toBe(server.PREFIX + '/first.html');\n      await page.goBack();\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      await page.goForward();\n      expect(page.url()).toBe(server.PREFIX + '/first.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate subframes","suites":["navigation","Frame.goto"],"updatePoint":{"line":691,"column":33},"line":691,"code":"    it('should navigate subframes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      expect(page.frames()[0]!.url()).toContain('/frames/one-frame.html');\n      expect(page.frames()[1]!.url()).toContain('/frames/frame.html');\n\n      const response = (await page.frames()[1]!.goto(server.EMPTY_PAGE))!;\n      expect(response.ok()).toBe(true);\n      expect(response.frame()).toBe(page.frames()[1]!);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should reject when frame detaches","suites":["navigation","Frame.goto"],"updatePoint":{"line":702,"column":41},"line":702,"code":"    it('should reject when frame detaches', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n\n      server.setRoute('/empty.html', () => {});\n      const navigationPromise = page\n        .frames()[1]!\n        .goto(server.EMPTY_PAGE)\n        .catch(error_ => {\n          return error_;\n        });\n      await server.waitForRequest('/empty.html');\n\n      await page.$eval('iframe', frame => {\n        return frame.remove();\n      });\n      const error = await navigationPromise;\n      expect(error.message).toBe('Navigating frame was detached');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should return matching responses","suites":["navigation","Frame.goto"],"updatePoint":{"line":722,"column":40},"line":722,"code":"    it('should return matching responses', async () => {\n      const {page, server} = getTestState();\n\n      // Disable cache: otherwise, chromium will cache similar requests.\n      await page.setCacheEnabled(false);\n      await page.goto(server.EMPTY_PAGE);\n      // Attach three frames.\n      const frames = await Promise.all([\n        utils.attachFrame(page, 'frame1', server.EMPTY_PAGE),\n        utils.attachFrame(page, 'frame2', server.EMPTY_PAGE),\n        utils.attachFrame(page, 'frame3', server.EMPTY_PAGE),\n      ]);\n      // Navigate all frames to the same URL.\n      const serverResponses: ServerResponse[] = [];\n      server.setRoute('/one-style.html', (_req, res) => {\n        return serverResponses.push(res);\n      });\n      const navigations = [];\n      for (let i = 0; i < 3; ++i) {\n        navigations.push(frames[i]!.goto(server.PREFIX + '/one-style.html'));\n        await server.waitForRequest('/one-style.html');\n      }\n      // Respond from server out-of-order.\n      const serverResponseTexts = ['AAA', 'BBB', 'CCC'];\n      for (const i of [1, 2, 0]) {\n        serverResponses[i]!.end(serverResponseTexts[i]);\n        const response = (await navigations[i])!;\n        expect(response.frame()).toBe(frames[i]);\n        expect(await response.text()).toBe(serverResponseTexts[i]);\n      }\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Frame.waitForNavigation"],"updatePoint":{"line":756,"column":19},"line":756,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      const frame = page.frames()[1]!;\n      const [response] = await Promise.all([\n        frame.waitForNavigation(),\n        frame.evaluate((url: string) => {\n          return (window.location.href = url);\n        }, server.PREFIX + '/grid.html'),\n      ]);\n      expect(response!.ok()).toBe(true);\n      expect(response!.url()).toContain('grid.html');\n      expect(response!.frame()).toBe(frame);\n      expect(page.url()).toContain('/frames/one-frame.html');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when frame detaches","suites":["navigation","Frame.waitForNavigation"],"updatePoint":{"line":772,"column":39},"line":772,"code":"    it('should fail when frame detaches', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/one-frame.html');\n      const frame = page.frames()[1]!;\n\n      server.setRoute('/empty.html', () => {});\n      let error!: Error;\n      const navigationPromise = frame.waitForNavigation().catch(error_ => {\n        return (error = error_);\n      });\n      await Promise.all([\n        server.waitForRequest('/empty.html'),\n        frame.evaluate(() => {\n          return ((window as any).location = '/empty.html');\n        }),\n      ]);\n      await page.$eval('iframe', frame => {\n        return frame.remove();\n      });\n      await navigationPromise;\n      expect(error.message).toBe('Navigating frame was detached');\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["navigation","Page.reload"],"updatePoint":{"line":798,"column":19},"line":798,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        return ((globalThis as any)._foo = 10);\n      });\n      await page.reload();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any)._foo;\n        })\n      ).toBe(undefined);\n    });","file":"src/navigation.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for navigation requests","suites":["network","Page.Events.Request"],"updatePoint":{"line":35,"column":43},"line":35,"code":"    it('should fire for navigation requests', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(requests.length).toBe(1);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for iframes","suites":["network","Page.Events.Request"],"updatePoint":{"line":45,"column":31},"line":45,"code":"    it('should fire for iframes', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      expect(requests.length).toBe(2);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire for fetches","suites":["network","Page.Events.Request"],"updatePoint":{"line":56,"column":31},"line":56,"code":"    it('should fire for fetches', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      await page.evaluate(() => {\n        return fetch('/empty.html');\n      });\n      expect(requests.length).toBe(2);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work for main frame navigation request","suites":["network","Request.frame"],"updatePoint":{"line":71,"column":53},"line":71,"code":"    it('should work for main frame navigation request', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.frame()).toBe(page.mainFrame());\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work for subframe navigation request","suites":["network","Request.frame"],"updatePoint":{"line":82,"column":51},"line":82,"code":"    it('should work for subframe navigation request', async () => {\n      const {page, server} = getTestState();\n\n      (await page.goto(server.EMPTY_PAGE))!;\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.frame()).toBe(page.frames()[1]!);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work for fetch requests","suites":["network","Request.frame"],"updatePoint":{"line":94,"column":38},"line":94,"code":"    it('should work for fetch requests', async () => {\n      const {page, server} = getTestState();\n\n      (await page.goto(server.EMPTY_PAGE))!;\n      let requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return !utils.isFavicon(request) && requests.push(request);\n      });\n      await page.evaluate(() => {\n        return fetch('/digits/1.png');\n      });\n      requests = requests.filter(request => {\n        return !request.url().includes('favicon');\n      });\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.frame()).toBe(page.mainFrame());\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should define Chrome as user agent header","suites":["network","Request.headers"],"updatePoint":{"line":114,"column":49},"line":114,"code":"    it('should define Chrome as user agent header', async () => {\n      const {page, server} = getTestState();\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.request().headers()['user-agent']).toContain('Chrome');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should define Firefox as user agent header","suites":["network","Request.headers"],"updatePoint":{"line":120,"column":50},"line":120,"code":"    it('should define Firefox as user agent header', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.request().headers()['user-agent']).toContain('Firefox');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.headers"],"updatePoint":{"line":129,"column":19},"line":129,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      server.setRoute('/empty.html', (_req, res) => {\n        res.setHeader('foo', 'bar');\n        res.end();\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.headers()['foo']).toBe('bar');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should return the initiator","suites":["network","Request.initiator"],"updatePoint":{"line":142,"column":35},"line":142,"code":"    it('should return the initiator', async () => {\n      const {page, server} = getTestState();\n\n      const initiators = new Map();\n      page.on('request', request => {\n        return initiators.set(\n          request.url().split('/').pop(),\n          request.initiator()\n        );\n      });\n      await page.goto(server.PREFIX + '/initiator.html');\n\n      expect(initiators.get('initiator.html').type).toBe('other');\n      expect(initiators.get('initiator.js').type).toBe('parser');\n      expect(initiators.get('initiator.js').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n      expect(initiators.get('frame.html').type).toBe('parser');\n      expect(initiators.get('frame.html').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n      expect(initiators.get('script.js').type).toBe('parser');\n      expect(initiators.get('script.js').url).toBe(\n        server.PREFIX + '/frames/frame.html'\n      );\n      expect(initiators.get('style.css').type).toBe('parser');\n      expect(initiators.get('style.css').url).toBe(\n        server.PREFIX + '/frames/frame.html'\n      );\n      expect(initiators.get('initiator.js').type).toBe('parser');\n      expect(initiators.get('injectedfile.js').type).toBe('script');\n      expect(initiators.get('injectedfile.js').stack.callFrames[0]!.url).toBe(\n        server.PREFIX + '/initiator.js'\n      );\n      expect(initiators.get('injectedstyle.css').type).toBe('script');\n      expect(initiators.get('injectedstyle.css').stack.callFrames[0]!.url).toBe(\n        server.PREFIX + '/initiator.js'\n      );\n      expect(initiators.get('initiator.js').url).toBe(\n        server.PREFIX + '/initiator.html'\n      );\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should return |false| for non-cached content","suites":["network","Response.fromCache"],"updatePoint":{"line":187,"column":52},"line":187,"code":"    it('should return |false| for non-cached content', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.fromCache()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.fromCache"],"updatePoint":{"line":194,"column":19},"line":194,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      const responses = new Map();\n      page.on('response', r => {\n        return (\n          !utils.isFavicon(r.request()) &&\n          responses.set(r.url().split('/').pop(), r)\n        );\n      });\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      await page.reload();\n\n      expect(responses.size).toBe(2);\n      expect(responses.get('one-style.css').status()).toBe(200);\n      expect(responses.get('one-style.css').fromCache()).toBe(true);\n      expect(responses.get('one-style.html').status()).toBe(304);\n      expect(responses.get('one-style.html').fromCache()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should return |false| for non-service-worker content","suites":["network","Response.fromServiceWorker"],"updatePoint":{"line":218,"column":60},"line":218,"code":"    it('should return |false| for non-service-worker content', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.fromServiceWorker()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Response.fromServiceWorker","suites":["network","Response.fromServiceWorker"],"updatePoint":{"line":225,"column":34},"line":225,"code":"    it('Response.fromServiceWorker', async () => {\n      const {page, server} = getTestState();\n\n      const responses = new Map();\n      page.on('response', r => {\n        return (\n          !utils.isFavicon(r) && responses.set(r.url().split('/').pop(), r)\n        );\n      });\n\n      // Load and re-load to make sure serviceworker is installed and running.\n      await page.goto(server.PREFIX + '/serviceworkers/fetch/sw.html', {\n        waitUntil: 'networkidle2',\n      });\n      await page.evaluate(async () => {\n        return await (globalThis as any).activationPromise;\n      });\n      await page.reload();\n\n      expect(responses.size).toBe(2);\n      expect(responses.get('sw.html').status()).toBe(200);\n      expect(responses.get('sw.html').fromServiceWorker()).toBe(true);\n      expect(responses.get('style.css').status()).toBe(200);\n      expect(responses.get('style.css').fromServiceWorker()).toBe(true);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Request.postData"],"updatePoint":{"line":253,"column":19},"line":253,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      (await page.goto(server.EMPTY_PAGE))!;\n      server.setRoute('/post', (_req, res) => {\n        return res.end();\n      });\n      let request!: HTTPRequest;\n      page.on('request', r => {\n        if (!utils.isFavicon(r)) {\n          request = r;\n        }\n      });\n      await page.evaluate(() => {\n        return fetch('./post', {\n          method: 'POST',\n          body: JSON.stringify({foo: 'bar'}),\n        });\n      });\n      expect(request).toBeTruthy();\n      expect(request.postData()).toBe('{\"foo\":\"bar\"}');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should be |undefined| when there is no post data","suites":["network","Request.postData"],"updatePoint":{"line":275,"column":56},"line":275,"code":"    it('should be |undefined| when there is no post data', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.request().postData()).toBe(undefined);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.text"],"updatePoint":{"line":284,"column":19},"line":284,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/simple.json'))!;\n      const responseText = (await response.text()).trimEnd();\n      expect(responseText).toBe('{\"foo\": \"bar\"}');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should return uncompressed text","suites":["network","Response.text"],"updatePoint":{"line":291,"column":39},"line":291,"code":"    it('should return uncompressed text', async () => {\n      const {page, server} = getTestState();\n\n      server.enableGzip('/simple.json');\n      const response = (await page.goto(server.PREFIX + '/simple.json'))!;\n      expect(response.headers()['content-encoding']).toBe('gzip');\n      const responseText = (await response.text()).trimEnd();\n      expect(responseText).toBe('{\"foo\": \"bar\"}');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when requesting body of redirected response","suites":["network","Response.text"],"updatePoint":{"line":300,"column":64},"line":300,"code":"    it('should throw when requesting body of redirected response', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/foo.html', '/empty.html');\n      const response = (await page.goto(server.PREFIX + '/foo.html'))!;\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(1);\n      const redirected = redirectChain[0]!.response()!;\n      expect(redirected.status()).toBe(302);\n      let error!: Error;\n      await redirected.text().catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain(\n        'Response body is unavailable for redirect responses'\n      );\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should wait until response completes","suites":["network","Response.text"],"updatePoint":{"line":317,"column":44},"line":317,"code":"    it('should wait until response completes', async () => {\n      const {page, server} = getTestState();\n\n      (await page.goto(server.EMPTY_PAGE))!;\n      // Setup server to trap request.\n      let serverResponse!: ServerResponse;\n      server.setRoute('/get', (_req, res) => {\n        serverResponse = res;\n        // In Firefox, |fetch| will be hanging until it receives |Content-Type| header\n        // from server.\n        res.setHeader('Content-Type', 'text/plain; charset=utf-8');\n        res.write('hello ');\n      });\n      // Setup page to trap response.\n      let requestFinished = false;\n      page.on('requestfinished', r => {\n        return (requestFinished = requestFinished || r.url().includes('/get'));\n      });\n      // send request and wait for server response\n      const [pageResponse] = await Promise.all([\n        page.waitForResponse(r => {\n          return !utils.isFavicon(r.request());\n        }),\n        page.evaluate(() => {\n          return fetch('./get', {method: 'GET'});\n        }),\n        server.waitForRequest('/get'),\n      ]);\n\n      expect(serverResponse).toBeTruthy();\n      expect(pageResponse).toBeTruthy();\n      expect(pageResponse.status()).toBe(200);\n      expect(requestFinished).toBe(false);\n\n      const responseText = pageResponse.text();\n      // Write part of the response and wait for it to be flushed.\n      await new Promise(x => {\n        return serverResponse.write('wor', x);\n      });\n      // Finish response.\n      await new Promise<void>(x => {\n        serverResponse.end('ld!', () => {\n          return x();\n        });\n      });\n      expect(await responseText).toBe('hello world!');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.json"],"updatePoint":{"line":367,"column":19},"line":367,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/simple.json'))!;\n      expect(await response.json()).toEqual({foo: 'bar'});\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.buffer"],"updatePoint":{"line":376,"column":19},"line":376,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      const response = (await page.goto(server.PREFIX + '/pptr.png'))!;\n      const imageBuffer = fs.readFileSync(\n        path.join(__dirname, '../assets', 'pptr.png')\n      );\n      const responseBuffer = await response.buffer();\n      expect(responseBuffer.equals(imageBuffer)).toBe(true);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work with compression","suites":["network","Response.buffer"],"updatePoint":{"line":386,"column":36},"line":386,"code":"    it('should work with compression', async () => {\n      const {page, server} = getTestState();\n\n      server.enableGzip('/pptr.png');\n      const response = (await page.goto(server.PREFIX + '/pptr.png'))!;\n      const imageBuffer = fs.readFileSync(\n        path.join(__dirname, '../assets', 'pptr.png')\n      );\n      const responseBuffer = await response.buffer();\n      expect(responseBuffer.equals(imageBuffer)).toBe(true);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if the response does not have a body","suites":["network","Response.buffer"],"updatePoint":{"line":397,"column":57},"line":397,"code":"    it('should throw if the response does not have a body', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/empty.html');\n\n      server.setRoute('/test.html', (_req, res) => {\n        res.setHeader('Access-Control-Allow-Origin', '*');\n        res.setHeader('Access-Control-Allow-Headers', 'x-ping');\n        res.end('Hello World');\n      });\n      const url = server.CROSS_PROCESS_PREFIX + '/test.html';\n      const responsePromise = new Promise<HTTPResponse>(resolve => {\n        page.on('response', response => {\n          // Get the preflight response.\n          if (\n            response.request().method() === 'OPTIONS' &&\n            response.url() === url\n          ) {\n            resolve(response);\n          }\n        });\n      });\n\n      // Trigger a request with a preflight.\n      await page.evaluate(async src => {\n        const response = await fetch(src, {\n          method: 'POST',\n          headers: {'x-ping': 'pong'},\n        });\n        return response;\n      }, url);\n\n      const response = await responsePromise;\n      await expect(response.buffer()).rejects.toThrowError(\n        'Could not load body for this request. This might happen if the request is a preflight request.'\n      );\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Response.statusText"],"updatePoint":{"line":437,"column":19},"line":437,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      server.setRoute('/cool', (_req, res) => {\n        res.writeHead(200, 'cool!');\n        res.end();\n      });\n      const response = (await page.goto(server.PREFIX + '/cool'))!;\n      expect(response.statusText()).toBe('cool!');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"handles missing status text","suites":["network","Response.statusText"],"updatePoint":{"line":448,"column":35},"line":448,"code":"    it('handles missing status text', async () => {\n      const {page, server} = getTestState();\n\n      server.setRoute('/nostatus', (_req, res) => {\n        res.writeHead(200, '');\n        res.end();\n      });\n      const response = (await page.goto(server.PREFIX + '/nostatus'))!;\n      expect(response.statusText()).toBe('');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"returns timing information","suites":["network","Response.timing"],"updatePoint":{"line":461,"column":34},"line":461,"code":"    it('returns timing information', async () => {\n      const {page, server} = getTestState();\n      const responses: HTTPResponse[] = [];\n      page.on('response', response => {\n        return responses.push(response);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(responses.length).toBe(1);\n      expect(responses[0]!.timing()!.receiveHeadersEnd).toBeGreaterThan(0);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.Request","suites":["network","Network Events"],"updatePoint":{"line":474,"column":27},"line":474,"code":"    it('Page.Events.Request', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(server.EMPTY_PAGE);\n      expect(requests[0]!.resourceType()).toBe('document');\n      expect(requests[0]!.method()).toBe('GET');\n      expect(requests[0]!.response()).toBeTruthy();\n      expect(requests[0]!.frame() === page.mainFrame()).toBe(true);\n      expect(requests[0]!.frame()!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestServedFromCache","suites":["network","Network Events"],"updatePoint":{"line":490,"column":42},"line":490,"code":"    it('Page.Events.RequestServedFromCache', async () => {\n      const {page, server} = getTestState();\n\n      const cached: string[] = [];\n      page.on('requestservedfromcache', r => {\n        return cached.push(r.url().split('/').pop()!);\n      });\n\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      expect(cached).toEqual([]);\n\n      await page.reload();\n      expect(cached).toEqual(['one-style.css']);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.Response","suites":["network","Network Events"],"updatePoint":{"line":504,"column":28},"line":504,"code":"    it('Page.Events.Response', async () => {\n      const {page, server} = getTestState();\n\n      const responses: HTTPResponse[] = [];\n      page.on('response', response => {\n        return responses.push(response);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(responses.length).toBe(1);\n      expect(responses[0]!.url()).toBe(server.EMPTY_PAGE);\n      expect(responses[0]!.status()).toBe(200);\n      expect(responses[0]!.ok()).toBe(true);\n      expect(responses[0]!.request()).toBeTruthy();\n      const remoteAddress = responses[0]!.remoteAddress();\n      // Either IPv6 or IPv4, depending on environment.\n      expect(\n        remoteAddress.ip!.includes('::1') || remoteAddress.ip === '127.0.0.1'\n      ).toBe(true);\n      expect(remoteAddress.port).toBe(server.PORT);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestFailed","suites":["network","Network Events"],"updatePoint":{"line":525,"column":33},"line":525,"code":"    it('Page.Events.RequestFailed', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (request.url().endsWith('css')) {\n          request.abort();\n        } else {\n          request.continue();\n        }\n      });\n      const failedRequests: HTTPRequest[] = [];\n      page.on('requestfailed', request => {\n        return failedRequests.push(request);\n      });\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(failedRequests.length).toBe(1);\n      expect(failedRequests[0]!.url()).toContain('one-style.css');\n      expect(failedRequests[0]!.response()).toBe(null);\n      expect(failedRequests[0]!.resourceType()).toBe('stylesheet');\n      if (isChrome) {\n        expect(failedRequests[0]!.failure()!.errorText).toBe('net::ERR_FAILED');\n      } else {\n        expect(failedRequests[0]!.failure()!.errorText).toBe(\n          'NS_ERROR_FAILURE'\n        );\n      }\n      expect(failedRequests[0]!.frame()).toBeTruthy();\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Page.Events.RequestFinished","suites":["network","Network Events"],"updatePoint":{"line":554,"column":35},"line":554,"code":"    it('Page.Events.RequestFinished', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('requestfinished', request => {\n        return requests.push(request);\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(server.EMPTY_PAGE);\n      expect(requests[0]!.response()).toBeTruthy();\n      expect(requests[0]!.frame() === page.mainFrame()).toBe(true);\n      expect(requests[0]!.frame()!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should fire events in proper order","suites":["network","Network Events"],"updatePoint":{"line":568,"column":42},"line":568,"code":"    it('should fire events in proper order', async () => {\n      const {page, server} = getTestState();\n\n      const events: string[] = [];\n      page.on('request', () => {\n        return events.push('request');\n      });\n      page.on('response', () => {\n        return events.push('response');\n      });\n      page.on('requestfinished', () => {\n        return events.push('requestfinished');\n      });\n      (await page.goto(server.EMPTY_PAGE))!;\n      expect(events).toEqual(['request', 'response', 'requestfinished']);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should support redirects","suites":["network","Network Events"],"updatePoint":{"line":584,"column":32},"line":584,"code":"    it('should support redirects', async () => {\n      const {page, server} = getTestState();\n\n      const events: string[] = [];\n      page.on('request', request => {\n        return events.push(`${request.method()} ${request.url()}`);\n      });\n      page.on('response', response => {\n        return events.push(`${response.status()} ${response.url()}`);\n      });\n      page.on('requestfinished', request => {\n        return events.push(`DONE ${request.url()}`);\n      });\n      page.on('requestfailed', request => {\n        return events.push(`FAIL ${request.url()}`);\n      });\n      server.setRedirect('/foo.html', '/empty.html');\n      const FOO_URL = server.PREFIX + '/foo.html';\n      const response = (await page.goto(FOO_URL))!;\n      expect(events).toEqual([\n        `GET ${FOO_URL}`,\n        `302 ${FOO_URL}`,\n        `DONE ${FOO_URL}`,\n        `GET ${server.EMPTY_PAGE}`,\n        `200 ${server.EMPTY_PAGE}`,\n        `DONE ${server.EMPTY_PAGE}`,\n      ]);\n\n      // Check redirect chain\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(1);\n      expect(redirectChain[0]!.url()).toContain('/foo.html');\n      expect(redirectChain[0]!.response()!.remoteAddress().port).toBe(\n        server.PORT\n      );\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":623,"column":19},"line":623,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      const requests = new Map();\n      page.on('request', request => {\n        return requests.set(request.url().split('/').pop(), request);\n      });\n      server.setRedirect('/rrredirect', '/frames/one-frame.html');\n      await page.goto(server.PREFIX + '/rrredirect');\n      expect(requests.get('rrredirect').isNavigationRequest()).toBe(true);\n      expect(requests.get('one-frame.html').isNavigationRequest()).toBe(true);\n      expect(requests.get('frame.html').isNavigationRequest()).toBe(true);\n      expect(requests.get('script.js').isNavigationRequest()).toBe(false);\n      expect(requests.get('style.css').isNavigationRequest()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work with request interception","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":638,"column":45},"line":638,"code":"    it('should work with request interception', async () => {\n      const {page, server} = getTestState();\n\n      const requests = new Map();\n      page.on('request', request => {\n        requests.set(request.url().split('/').pop(), request);\n        request.continue();\n      });\n      await page.setRequestInterception(true);\n      server.setRedirect('/rrredirect', '/frames/one-frame.html');\n      await page.goto(server.PREFIX + '/rrredirect');\n      expect(requests.get('rrredirect').isNavigationRequest()).toBe(true);\n      expect(requests.get('one-frame.html').isNavigationRequest()).toBe(true);\n      expect(requests.get('frame.html').isNavigationRequest()).toBe(true);\n      expect(requests.get('script.js').isNavigationRequest()).toBe(false);\n      expect(requests.get('style.css').isNavigationRequest()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work when navigating to image","suites":["network","Request.isNavigationRequest"],"updatePoint":{"line":655,"column":44},"line":655,"code":"    it('should work when navigating to image', async () => {\n      const {page, server} = getTestState();\n\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        return requests.push(request);\n      });\n      (await page.goto(server.PREFIX + '/pptr.png'))!;\n      expect(requests[0]!.isNavigationRequest()).toBe(true);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Page.setExtraHTTPHeaders"],"updatePoint":{"line":668,"column":19},"line":668,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should throw for non-string header values","suites":["network","Page.setExtraHTTPHeaders"],"updatePoint":{"line":680,"column":49},"line":680,"code":"    it('should throw for non-string header values', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      try {\n        // @ts-expect-error purposeful bad input\n        await page.setExtraHTTPHeaders({foo: 1});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toBe(\n        'Expected value of header \"foo\" to be String, but \"number\" is found.'\n      );\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["network","Page.authenticate"],"updatePoint":{"line":697,"column":19},"line":697,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      server.setAuth('/empty.html', 'user', 'pass');\n      let response;\n      try {\n        response = (await page.goto(server.EMPTY_PAGE))!;\n        expect(response.status()).toBe(401);\n      } catch (error) {\n        // In headful, an error is thrown instead of 401.\n        if (\n          !(error as Error).message.startsWith(\n            'net::ERR_INVALID_AUTH_CREDENTIALS'\n          )\n        ) {\n          throw error;\n        }\n      }\n      await page.authenticate({\n        username: 'user',\n        password: 'pass',\n      });\n      response = (await page.reload())!;\n      expect(response.status()).toBe(200);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if wrong credentials","suites":["network","Page.authenticate"],"updatePoint":{"line":722,"column":40},"line":722,"code":"    it('should fail if wrong credentials', async () => {\n      const {page, server} = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/empty.html', 'user2', 'pass2');\n      await page.authenticate({\n        username: 'foo',\n        password: 'bar',\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.status()).toBe(401);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should allow disable authentication","suites":["network","Page.authenticate"],"updatePoint":{"line":734,"column":43},"line":734,"code":"    it('should allow disable authentication', async () => {\n      const {page, server} = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/empty.html', 'user3', 'pass3');\n      await page.authenticate({\n        username: 'user3',\n        password: 'pass3',\n      });\n      let response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.status()).toBe(200);\n      await page.authenticate({\n        username: '',\n        password: '',\n      });\n      // Navigate to a different origin to bust Chrome's credential caching.\n      try {\n        response = (await page.goto(\n          server.CROSS_PROCESS_PREFIX + '/empty.html'\n        ))!;\n        expect(response.status()).toBe(401);\n      } catch (error) {\n        // In headful, an error is thrown instead of 401.\n        if (\n          !(error as Error).message.startsWith(\n            'net::ERR_INVALID_AUTH_CREDENTIALS'\n          )\n        ) {\n          throw error;\n        }\n      }\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should not disable caching","suites":["network","Page.authenticate"],"updatePoint":{"line":766,"column":34},"line":766,"code":"    it('should not disable caching', async () => {\n      const {page, server} = getTestState();\n\n      // Use unique user/password since Chrome caches credentials per origin.\n      server.setAuth('/cached/one-style.css', 'user4', 'pass4');\n      server.setAuth('/cached/one-style.html', 'user4', 'pass4');\n      await page.authenticate({\n        username: 'user4',\n        password: 'pass4',\n      });\n\n      const responses = new Map();\n      page.on('response', r => {\n        return responses.set(r.url().split('/').pop(), r);\n      });\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      await page.reload();\n\n      expect(responses.get('one-style.css').status()).toBe(200);\n      expect(responses.get('one-style.css').fromCache()).toBe(true);\n      expect(responses.get('one-style.html').status()).toBe(304);\n      expect(responses.get('one-style.html').fromCache()).toBe(false);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Same-origin set-cookie navigation","suites":["network","raw network headers"],"updatePoint":{"line":794,"column":41},"line":794,"code":"    it('Same-origin set-cookie navigation', async () => {\n      const {page, server} = getTestState();\n\n      const setCookieString = 'foo=bar';\n      server.setRoute('/empty.html', (_req, res) => {\n        res.setHeader('set-cookie', setCookieString);\n        res.end('hello world');\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.headers()['set-cookie']).toBe(setCookieString);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Same-origin set-cookie subresource","suites":["network","raw network headers"],"updatePoint":{"line":806,"column":42},"line":806,"code":"    it('Same-origin set-cookie subresource', async () => {\n      const {page, server} = getTestState();\n      (await page.goto(server.EMPTY_PAGE))!;\n\n      const setCookieString = 'foo=bar';\n      server.setRoute('/foo', (_req, res) => {\n        res.setHeader('set-cookie', setCookieString);\n        res.end('hello world');\n      });\n\n      const responsePromise = new Promise<HTTPResponse>(resolve => {\n        return page.on('response', response => {\n          return resolve(response);\n        });\n      });\n      page.evaluate(() => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', '/foo');\n        xhr.send();\n      });\n      const subresourceResponse = await responsePromise;\n      expect(subresourceResponse.headers()['set-cookie']).toBe(setCookieString);\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"Cross-origin set-cookie","suites":["network","raw network headers"],"updatePoint":{"line":830,"column":31},"line":830,"code":"    it('Cross-origin set-cookie', async () => {\n      const {httpsServer, puppeteer, defaultBrowserOptions} = getTestState();\n\n      const browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        ignoreHTTPSErrors: true,\n      });\n\n      const page = await browser.newPage();\n\n      try {\n        await page.goto(httpsServer.PREFIX + '/empty.html');\n\n        const setCookieString = 'hello=world';\n        httpsServer.setRoute('/setcookie.html', (_req, res) => {\n          res.setHeader('Access-Control-Allow-Origin', '*');\n          res.setHeader('set-cookie', setCookieString);\n          res.end();\n        });\n        await page.goto(httpsServer.PREFIX + '/setcookie.html');\n        const url = httpsServer.CROSS_PROCESS_PREFIX + '/setcookie.html';\n        const response = await new Promise<HTTPResponse>(resolve => {\n          page.on('response', response => {\n            if (response.url() === url) {\n              resolve(response);\n            }\n          });\n          page.evaluate(src => {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', src);\n            xhr.send();\n          }, url);\n        });\n        expect(response.headers()['set-cookie']).toBe(setCookieString);\n      } finally {\n        await page.close();\n        await browser.close();\n      }\n    });","file":"src/network.spec.ts","skipped":false,"dir":"test"},{"name":"should process extra info on multiple redirects","suites":["NetworkManager"],"updatePoint":{"line":39,"column":53},"line":39,"code":"  it('should process extra info on multiple redirects', async () => {\n    const mockCDPSession = new MockCDPSession();\n    new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/1.html',\n      request: {\n        url: 'http://localhost:8907/redirect/1.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.55635,\n      wallTime: 1637315638.473634,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: {requestTime: 2111.557593},\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: '/redirect/2.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: /redirect/2.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/2.html',\n      request: {\n        url: 'http://localhost:8907/redirect/2.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.559124,\n      wallTime: 1637315638.47642,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/1.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: '/redirect/2.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: false,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 162,\n        timing: {\n          requestTime: 2111.557593,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: 0.241,\n          dnsEnd: 0.251,\n          connectStart: 0.251,\n          connectEnd: 0.47,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.537,\n          sendEnd: 0.611,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.939,\n        },\n        responseTime: 1.637315638475744e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: {requestTime: 2111.559346},\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/redirect/3.html',\n      request: {\n        url: 'http://localhost:8907/redirect/3.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.560249,\n      wallTime: 1637315638.477543,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/2.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: '/redirect/3.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 162,\n        timing: {\n          requestTime: 2111.559346,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.15,\n          sendEnd: 0.196,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.507,\n        },\n        responseTime: 1.637315638477063e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: '/redirect/3.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: /redirect/3.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: {requestTime: 2111.560482},\n    });\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      documentURL: 'http://localhost:8907/empty.html',\n      request: {\n        url: 'http://localhost:8907/empty.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 2111.561542,\n      wallTime: 1637315638.478837,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: true,\n      redirectResponse: {\n        url: 'http://localhost:8907/redirect/3.html',\n        status: 302,\n        statusText: 'Found',\n        headers: {\n          location: 'http://localhost:8907/empty.html',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Transfer-Encoding': 'chunked',\n        },\n        mimeType: '',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 178,\n        timing: {\n          requestTime: 2111.560482,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.149,\n          sendEnd: 0.198,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.478,\n        },\n        responseTime: 1.637315638478184e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      type: 'Document',\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        location: 'http://localhost:8907/empty.html',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Transfer-Encoding': 'chunked',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 302,\n      headersText:\n        'HTTP/1.1 302 Found\\r\\nlocation: http://localhost:8907/empty.html\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      associatedCookies: [],\n      headers: {\n        Host: 'localhost:8907',\n        Connection: 'keep-alive',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/97.0.4691.0 Safari/537.36',\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-User': '?1',\n        'Sec-Fetch-Dest': 'document',\n        'Accept-Encoding': 'gzip, deflate, br',\n      },\n      connectTiming: {requestTime: 2111.561759},\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      blockedCookies: [],\n      headers: {\n        'Cache-Control': 'no-cache, no-store',\n        'Content-Type': 'text/html; charset=utf-8',\n        Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n        Connection: 'keep-alive',\n        'Keep-Alive': 'timeout=5',\n        'Content-Length': '0',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\r\\nCache-Control: no-cache, no-store\\r\\nContent-Type: text/html; charset=utf-8\\r\\nDate: Fri, 19 Nov 2021 09:53:58 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nContent-Length: 0\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: '7760711DEFCFA23132D98ABA6B4E175C',\n      loaderId: '7760711DEFCFA23132D98ABA6B4E175C',\n      timestamp: 2111.563565,\n      type: 'Document',\n      response: {\n        url: 'http://localhost:8907/empty.html',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'Cache-Control': 'no-cache, no-store',\n          'Content-Type': 'text/html; charset=utf-8',\n          Date: 'Fri, 19 Nov 2021 09:53:58 GMT',\n          Connection: 'keep-alive',\n          'Keep-Alive': 'timeout=5',\n          'Content-Length': '0',\n        },\n        mimeType: 'text/html',\n        connectionReused: true,\n        connectionId: 322,\n        remoteIPAddress: '[::1]',\n        remotePort: 8907,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 197,\n        timing: {\n          requestTime: 2111.561759,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.148,\n          sendEnd: 0.19,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 0.925,\n        },\n        responseTime: 1.637315638479928e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      hasExtraInfo: true,\n      frameId: '099A5216AF03AAFEC988F214B024DF08',\n    });\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should handle \"double pause\" (crbug.com/1196004) Fetch.requestPaused events for the same Network.requestWillBeSent event","suites":["NetworkManager"],"updatePoint":{"line":470,"column":126},"line":470,"code":"  it(`should handle \"double pause\" (crbug.com/1196004) Fetch.requestPaused events for the same Network.requestWillBeSent event`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n    manager.setRequestInterception(true);\n\n    const requests: HTTPRequest[] = [];\n    manager.on(NetworkManagerEmittedEvents.Request, (request: HTTPRequest) => {\n      request.continue();\n      requests.push(request);\n    });\n\n    /**\n     * This sequence was taken from an actual CDP session produced by the following\n     * test script:\n     *\n     * ```ts\n     * const browser = await puppeteer.launch({headless: false});\n     * const page = await browser.newPage();\n     * await page.setCacheEnabled(false);\n     *\n     * await page.setRequestInterception(true);\n     * page.on('request', interceptedRequest => {\n     *   interceptedRequest.continue();\n     * });\n     *\n     * await page.goto('https://www.google.com');\n     * await browser.close();\n     * ```\n     */\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '11ACE9783588040D644B905E8B55285B',\n      loaderId: '11ACE9783588040D644B905E8B55285B',\n      documentURL: 'https://www.google.com/',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 224604.980827,\n      wallTime: 1637955746.786191,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Fetch.requestPaused', {\n      requestId: 'interception-job-1.0',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n      },\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      resourceType: 'Document',\n      networkId: '11ACE9783588040D644B905E8B55285B',\n    });\n    mockCDPSession.emit('Fetch.requestPaused', {\n      requestId: 'interception-job-2.0',\n      request: {\n        url: 'https://www.google.com/',\n        method: 'GET',\n        headers: [Object],\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n      },\n      frameId: '84AC261A351B86932B775B76D1DD79F8',\n      resourceType: 'Document',\n      networkId: '11ACE9783588040D644B905E8B55285B',\n    });\n\n    expect(requests.length).toBe(2);\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should handle Network.responseReceivedExtraInfo event after Network.responseReceived event (github.com/puppeteer/puppeteer/issues/8234)","suites":["NetworkManager"],"updatePoint":{"line":553,"column":141},"line":553,"code":"  it(`should handle Network.responseReceivedExtraInfo event after Network.responseReceived event (github.com/puppeteer/puppeteer/issues/8234)`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n\n    const requests: HTTPRequest[] = [];\n    manager.on(\n      NetworkManagerEmittedEvents.RequestFinished,\n      (request: HTTPRequest) => {\n        requests.push(request);\n      }\n    );\n\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '1360.2',\n      loaderId: '9E86B0282CC98B77FB0ABD49156DDFDD',\n      documentURL: 'http://this.is.the.start.page.com/',\n      request: {\n        url: 'http://this.is.a.test.com:1080/test.js',\n        method: 'GET',\n        headers: {\n          'Accept-Language': 'en-US,en;q=0.9',\n          Referer: 'http://this.is.the.start.page.com/',\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'High',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: false,\n      },\n      timestamp: 10959.020087,\n      wallTime: 1649712607.861365,\n      initiator: {\n        type: 'parser',\n        url: 'http://this.is.the.start.page.com/',\n        lineNumber: 9,\n        columnNumber: 80,\n      },\n      redirectHasExtraInfo: false,\n      type: 'Script',\n      frameId: '60E6C35E7E519F28E646056820095498',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: '1360.2',\n      loaderId: '9E86B0282CC98B77FB0ABD49156DDFDD',\n      timestamp: 10959.042529,\n      type: 'Script',\n      response: {\n        url: 'http://this.is.a.test.com:1080',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          connection: 'keep-alive',\n          'content-length': '85862',\n        },\n        mimeType: 'text/plain',\n        connectionReused: false,\n        connectionId: 119,\n        remoteIPAddress: '127.0.0.1',\n        remotePort: 1080,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 66,\n        timing: {\n          requestTime: 10959.023904,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: 0.328,\n          dnsEnd: 2.183,\n          connectStart: 2.183,\n          connectEnd: 2.798,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 2.982,\n          sendEnd: 3.757,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 16.373,\n        },\n        responseTime: 1649712607880.971,\n        protocol: 'http/1.1',\n        securityState: 'insecure',\n      },\n      hasExtraInfo: true,\n      frameId: '60E6C35E7E519F28E646056820095498',\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '1360.2',\n      blockedCookies: [],\n      headers: {\n        connection: 'keep-alive',\n        'content-length': '85862',\n      },\n      resourceIPAddressSpace: 'Private',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\r\\nconnection: keep-alive\\r\\ncontent-length: 85862\\r\\n\\r\\n',\n    });\n    mockCDPSession.emit('Network.loadingFinished', {\n      requestId: '1360.2',\n      timestamp: 10959.060708,\n      encodedDataLength: 85928,\n      shouldReportCorbBlocking: false,\n    });\n\n    expect(requests.length).toBe(1);\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve the response once the late responseReceivedExtraInfo event arrives","suites":["NetworkManager"],"updatePoint":{"line":671,"column":87},"line":671,"code":"  it(`should resolve the response once the late responseReceivedExtraInfo event arrives`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n\n    const finishedRequests: HTTPRequest[] = [];\n    const pendingRequests: HTTPRequest[] = [];\n    manager.on(\n      NetworkManagerEmittedEvents.RequestFinished,\n      (request: HTTPRequest) => {\n        finishedRequests.push(request);\n      }\n    );\n\n    manager.on(NetworkManagerEmittedEvents.Request, (request: HTTPRequest) => {\n      pendingRequests.push(request);\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: 'LOADERID',\n      loaderId: 'LOADERID',\n      documentURL: 'http://10.1.0.39:42915/empty.html',\n      request: {\n        url: 'http://10.1.0.39:42915/empty.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 671.229856,\n      wallTime: 1660121157.913774,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: 'FRAMEID',\n      hasUserGesture: false,\n    });\n\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: 'LOADERID',\n      loaderId: 'LOADERID',\n      timestamp: 671.236025,\n      type: 'Document',\n      response: {\n        url: 'http://10.1.0.39:42915/empty.html',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'Cache-Control': 'no-cache, no-store',\n          Connection: 'keep-alive',\n          'Content-Length': '0',\n          'Content-Type': 'text/html; charset=utf-8',\n          Date: 'Wed, 10 Aug 2022 08:45:57 GMT',\n          'Keep-Alive': 'timeout=5',\n        },\n        mimeType: 'text/html',\n        connectionReused: true,\n        connectionId: 18,\n        remoteIPAddress: '10.1.0.39',\n        remotePort: 42915,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 197,\n        timing: {\n          requestTime: 671.232585,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.308,\n          sendEnd: 0.364,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 1.554,\n        },\n        responseTime: 1.660121157917951e12,\n        protocol: 'http/1.1',\n        securityState: 'insecure',\n      },\n      hasExtraInfo: true,\n      frameId: 'FRAMEID',\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: 'LOADERID',\n      associatedCookies: [],\n      headers: {\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding': 'gzip, deflate',\n        'Accept-Language': 'en-US,en;q=0.9',\n        Connection: 'keep-alive',\n        Host: '10.1.0.39:42915',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36',\n      },\n      connectTiming: {requestTime: 671.232585},\n    });\n\n    mockCDPSession.emit('Network.loadingFinished', {\n      requestId: 'LOADERID',\n      timestamp: 671.234448,\n      encodedDataLength: 197,\n      shouldReportCorbBlocking: false,\n    });\n\n    expect(pendingRequests.length).toBe(1);\n    expect(finishedRequests.length).toBe(0);\n    expect(pendingRequests[0]!.response()).toEqual(null);\n\n    // The extra info might arrive late.\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: 'LOADERID',\n      blockedCookies: [],\n      headers: {\n        'Cache-Control': 'no-cache, no-store',\n        Connection: 'keep-alive',\n        'Content-Length': '0',\n        'Content-Type': 'text/html; charset=utf-8',\n        Date: 'Wed, 10 Aug 2022 09:04:39 GMT',\n        'Keep-Alive': 'timeout=5',\n      },\n      resourceIPAddressSpace: 'Private',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\\\r\\\\nCache-Control: no-cache, no-store\\\\r\\\\nContent-Type: text/html; charset=utf-8\\\\r\\\\nDate: Wed, 10 Aug 2022 09:04:39 GMT\\\\r\\\\nConnection: keep-alive\\\\r\\\\nKeep-Alive: timeout=5\\\\r\\\\nContent-Length: 0\\\\r\\\\n\\\\r\\\\n',\n    });\n\n    expect(pendingRequests.length).toBe(1);\n    expect(finishedRequests.length).toBe(1);\n    expect(pendingRequests[0]!.response()).not.toEqual(null);\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should send responses for iframe that don't receive loadingFinished event","suites":["NetworkManager"],"updatePoint":{"line":823,"column":79},"line":823,"code":"  it(`should send responses for iframe that don't receive loadingFinished event`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n\n    const responses: HTTPResponse[] = [];\n    const requests: HTTPRequest[] = [];\n    manager.on(\n      NetworkManagerEmittedEvents.Response,\n      (response: HTTPResponse) => {\n        responses.push(response);\n      }\n    );\n\n    manager.on(NetworkManagerEmittedEvents.Request, (request: HTTPRequest) => {\n      requests.push(request);\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: '94051D839ACF29E53A3D1273FB20B4C4',\n      loaderId: '94051D839ACF29E53A3D1273FB20B4C4',\n      documentURL: 'http://127.0.0.1:54590/empty.html',\n      request: {\n        url: 'http://127.0.0.1:54590/empty.html',\n        method: 'GET',\n        headers: {\n          Referer: 'http://localhost:54590/',\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/105.0.5173.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: false,\n      },\n      timestamp: 504903.99901,\n      wallTime: 1660125092.026021,\n      initiator: {\n        type: 'script',\n        stack: {\n          callFrames: [\n            {\n              functionName: 'navigateFrame',\n              scriptId: '8',\n              url: 'pptr://__puppeteer_evaluation_script__',\n              lineNumber: 2,\n              columnNumber: 18,\n            },\n          ],\n        },\n      },\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: '07D18B8630A8161C72B6079B74123D60',\n      hasUserGesture: true,\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: '94051D839ACF29E53A3D1273FB20B4C4',\n      associatedCookies: [],\n      headers: {\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding': 'gzip, deflate, br',\n        Connection: 'keep-alive',\n        Host: '127.0.0.1:54590',\n        Referer: 'http://localhost:54590/',\n        'Sec-Fetch-Dest': 'iframe',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-Site': 'cross-site',\n        'Sec-Fetch-User': '?1',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/105.0.5173.0 Safari/537.36',\n      },\n      connectTiming: {requestTime: 504904.000422},\n      clientSecurityState: {\n        initiatorIsSecureContext: true,\n        initiatorIPAddressSpace: 'Local',\n        privateNetworkRequestPolicy: 'Allow',\n      },\n    });\n\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: '94051D839ACF29E53A3D1273FB20B4C4',\n      blockedCookies: [],\n      headers: {\n        'Cache-Control': 'no-cache, no-store',\n        Connection: 'keep-alive',\n        'Content-Length': '0',\n        'Content-Type': 'text/html; charset=utf-8',\n        Date: 'Wed, 10 Aug 2022 09:51:32 GMT',\n        'Keep-Alive': 'timeout=5',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\r\\nCache-Control: no-cache, no-store\\r\\nContent-Type: text/html; charset=utf-8\\r\\nDate: Wed, 10 Aug 2022 09:51:32 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nContent-Length: 0\\r\\n\\r\\n',\n    });\n\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: '94051D839ACF29E53A3D1273FB20B4C4',\n      loaderId: '94051D839ACF29E53A3D1273FB20B4C4',\n      timestamp: 504904.00338,\n      type: 'Document',\n      response: {\n        url: 'http://127.0.0.1:54590/empty.html',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'Cache-Control': 'no-cache, no-store',\n          Connection: 'keep-alive',\n          'Content-Length': '0',\n          'Content-Type': 'text/html; charset=utf-8',\n          Date: 'Wed, 10 Aug 2022 09:51:32 GMT',\n          'Keep-Alive': 'timeout=5',\n        },\n        mimeType: 'text/html',\n        connectionReused: true,\n        connectionId: 13,\n        remoteIPAddress: '127.0.0.1',\n        remotePort: 54590,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 197,\n        timing: {\n          requestTime: 504904.000422,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 0.338,\n          sendEnd: 0.413,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 1.877,\n        },\n        responseTime: 1.660125092029241e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      hasExtraInfo: true,\n      frameId: '07D18B8630A8161C72B6079B74123D60',\n    });\n\n    expect(requests.length).toBe(1);\n    expect(responses.length).toBe(1);\n    expect(requests[0]!.response()).not.toEqual(null);\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should send responses for iframe that don't receive loadingFinished event","suites":["NetworkManager"],"updatePoint":{"line":986,"column":79},"line":986,"code":"  it(`should send responses for iframe that don't receive loadingFinished event`, async () => {\n    const mockCDPSession = new MockCDPSession();\n    const manager = new NetworkManager(mockCDPSession, true, {\n      frame(): Frame | null {\n        return null;\n      },\n    });\n\n    const responses: HTTPResponse[] = [];\n    const requests: HTTPRequest[] = [];\n    manager.on(\n      NetworkManagerEmittedEvents.Response,\n      (response: HTTPResponse) => {\n        responses.push(response);\n      }\n    );\n\n    manager.on(NetworkManagerEmittedEvents.Request, (request: HTTPRequest) => {\n      requests.push(request);\n    });\n\n    mockCDPSession.emit('Network.requestWillBeSent', {\n      requestId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      loaderId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      documentURL: 'http://localhost:56295/empty.html',\n      request: {\n        url: 'http://localhost:56295/empty.html',\n        method: 'GET',\n        headers: {\n          'Upgrade-Insecure-Requests': '1',\n          'User-Agent':\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/105.0.5173.0 Safari/537.36',\n        },\n        mixedContentType: 'none',\n        initialPriority: 'VeryHigh',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        isSameSite: true,\n      },\n      timestamp: 510294.105656,\n      wallTime: 1660130482.230591,\n      initiator: {type: 'other'},\n      redirectHasExtraInfo: false,\n      type: 'Document',\n      frameId: 'F9C89A517341F1EFFE63310141630189',\n      hasUserGesture: false,\n    });\n    mockCDPSession.emit('Network.responseReceived', {\n      requestId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      loaderId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      timestamp: 510294.119816,\n      type: 'Document',\n      response: {\n        url: 'http://localhost:56295/empty.html',\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'Cache-Control': 'no-cache, no-store',\n          Connection: 'keep-alive',\n          'Content-Length': '0',\n          'Content-Type': 'text/html; charset=utf-8',\n          Date: 'Wed, 10 Aug 2022 11:21:22 GMT',\n          'Keep-Alive': 'timeout=5',\n        },\n        mimeType: 'text/html',\n        connectionReused: true,\n        connectionId: 13,\n        remoteIPAddress: '[::1]',\n        remotePort: 56295,\n        fromDiskCache: false,\n        fromServiceWorker: false,\n        fromPrefetchCache: false,\n        encodedDataLength: 197,\n        timing: {\n          requestTime: 510294.106734,\n          proxyStart: -1,\n          proxyEnd: -1,\n          dnsStart: -1,\n          dnsEnd: -1,\n          connectStart: -1,\n          connectEnd: -1,\n          sslStart: -1,\n          sslEnd: -1,\n          workerStart: -1,\n          workerReady: -1,\n          workerFetchStart: -1,\n          workerRespondWithSettled: -1,\n          sendStart: 2.195,\n          sendEnd: 2.29,\n          pushStart: 0,\n          pushEnd: 0,\n          receiveHeadersEnd: 6.493,\n        },\n        responseTime: 1.660130482238109e12,\n        protocol: 'http/1.1',\n        securityState: 'secure',\n      },\n      hasExtraInfo: true,\n      frameId: 'F9C89A517341F1EFFE63310141630189',\n    });\n    mockCDPSession.emit('Network.requestWillBeSentExtraInfo', {\n      requestId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      associatedCookies: [],\n      headers: {\n        Accept:\n          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n        'Accept-Encoding': 'gzip, deflate, br',\n        Connection: 'keep-alive',\n        Host: 'localhost:56295',\n        'Sec-Fetch-Dest': 'document',\n        'Sec-Fetch-Mode': 'navigate',\n        'Sec-Fetch-Site': 'none',\n        'Sec-Fetch-User': '?1',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/105.0.5173.0 Safari/537.36',\n      },\n      connectTiming: {requestTime: 510294.106734},\n    });\n    mockCDPSession.emit('Network.loadingFinished', {\n      requestId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      timestamp: 510294.113383,\n      encodedDataLength: 197,\n      shouldReportCorbBlocking: false,\n    });\n    mockCDPSession.emit('Network.responseReceivedExtraInfo', {\n      requestId: 'E18BEB94B486CA8771F9AFA2030FEA37',\n      blockedCookies: [],\n      headers: {\n        'Cache-Control': 'no-cache, no-store',\n        Connection: 'keep-alive',\n        'Content-Length': '0',\n        'Content-Type': 'text/html; charset=utf-8',\n        Date: 'Wed, 10 Aug 2022 11:21:22 GMT',\n        'Keep-Alive': 'timeout=5',\n      },\n      resourceIPAddressSpace: 'Local',\n      statusCode: 200,\n      headersText:\n        'HTTP/1.1 200 OK\\r\\nCache-Control: no-cache, no-store\\r\\nContent-Type: text/html; charset=utf-8\\r\\nDate: Wed, 10 Aug 2022 11:21:22 GMT\\r\\nConnection: keep-alive\\r\\nKeep-Alive: timeout=5\\r\\nContent-Length: 0\\r\\n\\r\\n',\n    });\n\n    expect(requests.length).toBe(1);\n    expect(responses.length).toBe(1);\n    expect(requests[0]!.response()).not.toEqual(null);\n  });","file":"src/NetworkManager.spec.ts","skipped":false,"dir":"test"},{"name":"should treat OOP iframes and normal iframes the same","suites":[],"updatePoint":{"line":56,"column":58},"line":56,"code":"  it('should treat OOP iframes and normal iframes the same', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return frame.url().endsWith('/empty.html');\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n    await utils.attachFrame(\n      page,\n      'frame2',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    await framePromise;\n    expect(page.mainFrame().childFrames()).toHaveLength(2);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should track navigations within OOP iframes","suites":[],"updatePoint":{"line":72,"column":49},"line":72,"code":"  it('should track navigations within OOP iframes', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    expect(frame.url()).toContain('/empty.html');\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/assets/frame.html'\n    );\n    expect(frame.url()).toContain('/assets/frame.html');\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support OOP iframes becoming normal iframes again","suites":[],"updatePoint":{"line":93,"column":62},"line":93,"code":"  it('should support OOP iframes becoming normal iframes again', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n\n    const frame = await framePromise;\n    expect(frame.isOOPFrame()).toBe(false);\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    expect(frame.isOOPFrame()).toBe(true);\n    await utils.navigateFrame(page, 'frame1', server.EMPTY_PAGE);\n    expect(frame.isOOPFrame()).toBe(false);\n    expect(page.frames()).toHaveLength(2);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support frames within OOP frames","suites":[],"updatePoint":{"line":114,"column":45},"line":114,"code":"  it('should support frames within OOP frames', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const frame1Promise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    const frame2Promise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 2;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/frames/one-frame.html'\n    );\n\n    const [frame1, frame2] = await Promise.all([frame1Promise, frame2Promise]);\n\n    expect(\n      await frame1.evaluate(() => {\n        return document.location.href;\n      })\n    ).toMatch(/one-frame\\.html$/);\n    expect(\n      await frame2.evaluate(() => {\n        return document.location.href;\n      })\n    ).toMatch(/frames\\/frame\\.html$/);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support OOP iframes getting detached","suites":[],"updatePoint":{"line":143,"column":49},"line":143,"code":"  it('should support OOP iframes getting detached', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n\n    const frame = await framePromise;\n    expect(frame.isOOPFrame()).toBe(false);\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    expect(frame.isOOPFrame()).toBe(true);\n    await utils.detachFrame(page, 'frame1');\n    expect(page.frames()).toHaveLength(1);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support wait for navigation for transitions from local to OOPIF","suites":[],"updatePoint":{"line":164,"column":76},"line":164,"code":"  it('should support wait for navigation for transitions from local to OOPIF', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n\n    const frame = await framePromise;\n    expect(frame.isOOPFrame()).toBe(false);\n    const nav = frame.waitForNavigation();\n    await utils.navigateFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    await nav;\n    expect(frame.isOOPFrame()).toBe(true);\n    await utils.detachFrame(page, 'frame1');\n    expect(page.frames()).toHaveLength(1);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should keep track of a frames OOP state","suites":[],"updatePoint":{"line":187,"column":45},"line":187,"code":"  it('should keep track of a frames OOP state', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    expect(frame.url()).toContain('/empty.html');\n    await utils.navigateFrame(page, 'frame1', server.EMPTY_PAGE);\n    expect(frame.url()).toBe(server.EMPTY_PAGE);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support evaluating in oop iframes","suites":[],"updatePoint":{"line":205,"column":46},"line":205,"code":"  it('should support evaluating in oop iframes', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    await frame.evaluate(() => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      _test = 'Test 123!';\n    });\n    const result = await frame.evaluate(() => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return window._test;\n    });\n    expect(result).toBe('Test 123!');\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should provide access to elements","suites":[],"updatePoint":{"line":230,"column":39},"line":230,"code":"  it('should provide access to elements', async () => {\n    const {server, isHeadless, headless} = getTestState();\n\n    if (!isHeadless || headless === 'new') {\n      // TODO: this test is partially blocked on crbug.com/1334119. Enable test once\n      // the upstream is fixed.\n      // TLDR: when we dispatch events to the frame the compositor might\n      // not be up-to-date yet resulting in a misclick (the iframe element\n      // becomes the event target instead of the content inside the iframe).\n      // The solution is to use InsertVisualCallback on the backend but that causes\n      // another issue that events cannot be dispatched to inactive tabs as the\n      // visual callback is never invoked.\n      // The old headless mode does not have this issue since it operates with\n      // special scheduling settings that keep even inactive tabs updating.\n      return;\n    }\n\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n\n    const frame = await framePromise;\n    await frame.evaluate(() => {\n      const button = document.createElement('button');\n      button.id = 'test-button';\n      button.innerText = 'click';\n      button.onclick = () => {\n        button.id = 'clicked';\n      };\n      document.body.appendChild(button);\n    });\n    await page.evaluate(() => {\n      document.body.style.border = '150px solid black';\n      document.body.style.margin = '250px';\n      document.body.style.padding = '50px';\n    });\n    await frame.waitForSelector('#test-button', {visible: true});\n    await frame.click('#test-button');\n    await frame.waitForSelector('#clicked');\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should report oopif frames","suites":[],"updatePoint":{"line":276,"column":32},"line":276,"code":"  it('should report oopif frames', async () => {\n    const {server} = getTestState();\n\n    const frame = page.waitForFrame(frame => {\n      return frame.url().endsWith('/oopif.html');\n    });\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n    expect(page.frames().length).toBe(2);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for inner OOPIFs","suites":[],"updatePoint":{"line":288,"column":34},"line":288,"code":"  it('should wait for inner OOPIFs', async () => {\n    const {server} = getTestState();\n    await page.goto(`http://mainframe:${server.PORT}/main-frame.html`);\n    const frame2 = await page.waitForFrame(frame => {\n      return frame.url().endsWith('inner-frame2.html');\n    });\n    expect(oopifs(context).length).toBe(2);\n    expect(\n      page.frames().filter(frame => {\n        return frame.isOOPFrame();\n      }).length\n    ).toBe(2);\n    expect(\n      await frame2.evaluate(() => {\n        return document.querySelectorAll('button').length;\n      })\n    ).toStrictEqual(1);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should load oopif iframes with subresources and request interception","suites":[],"updatePoint":{"line":307,"column":74},"line":307,"code":"  it('should load oopif iframes with subresources and request interception', async () => {\n    const {server} = getTestState();\n\n    const frame = page.waitForFrame(frame => {\n      return frame.url().endsWith('/oopif.html');\n    });\n    await page.setRequestInterception(true);\n    page.on('request', request => {\n      return request.continue();\n    });\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support frames within OOP iframes","suites":[],"updatePoint":{"line":321,"column":46},"line":321,"code":"  it('should support frames within OOP iframes', async () => {\n    const {server} = getTestState();\n\n    const oopIframePromise = page.waitForFrame(frame => {\n      return frame.url().endsWith('/oopif.html');\n    });\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    const oopIframe = await oopIframePromise;\n    await utils.attachFrame(\n      oopIframe,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n\n    const frame1 = oopIframe.childFrames()[0]!;\n    expect(frame1.url()).toMatch(/empty.html$/);\n    await utils.navigateFrame(\n      oopIframe,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/oopif.html'\n    );\n    expect(frame1.url()).toMatch(/oopif.html$/);\n    await frame1.goto(\n      server.CROSS_PROCESS_PREFIX + '/oopif.html#navigate-within-document',\n      {waitUntil: 'load'}\n    );\n    expect(frame1.url()).toMatch(/oopif.html#navigate-within-document$/);\n    await utils.detachFrame(oopIframe, 'frame1');\n    expect(oopIframe.childFrames()).toHaveLength(0);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"clickablePoint, boundingBox, boxModel should work for elements inside OOPIFs","suites":[],"updatePoint":{"line":352,"column":82},"line":352,"code":"  it('clickablePoint, boundingBox, boxModel should work for elements inside OOPIFs', async () => {\n    const {server} = getTestState();\n    await page.goto(server.EMPTY_PAGE);\n    const framePromise = page.waitForFrame(frame => {\n      return page.frames().indexOf(frame) === 1;\n    });\n    await utils.attachFrame(\n      page,\n      'frame1',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    const frame = await framePromise;\n    await page.evaluate(() => {\n      document.body.style.border = '50px solid black';\n      document.body.style.margin = '50px';\n      document.body.style.padding = '50px';\n    });\n    await frame.evaluate(() => {\n      const button = document.createElement('button');\n      button.id = 'test-button';\n      button.innerText = 'click';\n      document.body.appendChild(button);\n    });\n    const button = (await frame.waitForSelector('#test-button', {\n      visible: true,\n    }))!;\n    const result = await button.clickablePoint();\n    expect(result.x).toBeGreaterThan(150); // padding + margin + border left\n    expect(result.y).toBeGreaterThan(150); // padding + margin + border top\n    const resultBoxModel = (await button.boxModel())!;\n    for (const quad of [\n      resultBoxModel.content,\n      resultBoxModel.border,\n      resultBoxModel.margin,\n      resultBoxModel.padding,\n    ]) {\n      for (const part of quad) {\n        expect(part.x).toBeGreaterThan(150); // padding + margin + border left\n        expect(part.y).toBeGreaterThan(150); // padding + margin + border top\n      }\n    }\n    const resultBoundingBox = (await button.boundingBox())!;\n    expect(resultBoundingBox.x).toBeGreaterThan(150); // padding + margin + border left\n    expect(resultBoundingBox.y).toBeGreaterThan(150); // padding + margin + border top\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should detect existing OOPIFs when Puppeteer connects to an existing page","suites":[],"updatePoint":{"line":398,"column":79},"line":398,"code":"  it('should detect existing OOPIFs when Puppeteer connects to an existing page', async () => {\n    const {server, puppeteer} = getTestState();\n\n    const frame = page.waitForFrame(frame => {\n      return frame.url().endsWith('/oopif.html');\n    });\n    await page.goto(server.PREFIX + '/dynamic-oopif.html');\n    await frame;\n    expect(oopifs(context).length).toBe(1);\n    expect(page.frames().length).toBe(2);\n\n    const browserURL = 'http://127.0.0.1:21222';\n    const browser1 = await puppeteer.connect({browserURL});\n    const target = await browser1.waitForTarget(target => {\n      return target.url().endsWith('dynamic-oopif.html');\n    });\n    await target.page();\n    browser1.disconnect();\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should support lazy OOP frames","suites":[],"updatePoint":{"line":418,"column":36},"line":418,"code":"  it('should support lazy OOP frames', async () => {\n    const {server} = getTestState();\n\n    await page.goto(server.PREFIX + '/lazy-oopif-frame.html');\n    await page.setViewport({width: 1000, height: 1000});\n\n    expect(\n      page.frames().map(frame => {\n        return frame._hasStartedLoading;\n      })\n    ).toEqual([true, true, false]);\n  });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve immediately if the frame already exists","suites":["waitForFrame"],"updatePoint":{"line":432,"column":62},"line":432,"code":"    it('should resolve immediately if the frame already exists', async () => {\n      const {server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(\n        page,\n        'frame2',\n        server.CROSS_PROCESS_PREFIX + '/empty.html'\n      );\n\n      await page.waitForFrame(frame => {\n        return frame.url().endsWith('/empty.html');\n      });\n    });","file":"src/oopif.spec.ts","skipped":false,"dir":"test"},{"name":"should reject all promises when page is closed","suites":["Page","Page.close"],"updatePoint":{"line":37,"column":54},"line":37,"code":"    it('should reject all promises when page is closed', async () => {\n      const {context} = getTestState();\n\n      const newPage = await context.newPage();\n      let error!: Error;\n      await Promise.all([\n        newPage\n          .evaluate(() => {\n            return new Promise(() => {});\n          })\n          .catch(error_ => {\n            return (error = error_);\n          }),\n        newPage.close(),\n      ]);\n      expect(error.message).toContain('Protocol error');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should not be visible in browser.pages","suites":["Page","Page.close"],"updatePoint":{"line":54,"column":46},"line":54,"code":"    it('should not be visible in browser.pages', async () => {\n      const {browser} = getTestState();\n\n      const newPage = await browser.newPage();\n      expect(await browser.pages()).toContain(newPage);\n      await newPage.close();\n      expect(await browser.pages()).not.toContain(newPage);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should run beforeunload if asked for","suites":["Page","Page.close"],"updatePoint":{"line":62,"column":44},"line":62,"code":"    it('should run beforeunload if asked for', async () => {\n      const {context, server, isChrome} = getTestState();\n\n      const newPage = await context.newPage();\n      await newPage.goto(server.PREFIX + '/beforeunload.html');\n      // We have to interact with a page so that 'beforeunload' handlers\n      // fire.\n      await newPage.click('body');\n      const pageClosingPromise = newPage.close({runBeforeUnload: true});\n      const dialog = await waitEvent(newPage, 'dialog');\n      expect(dialog.type()).toBe('beforeunload');\n      expect(dialog.defaultValue()).toBe('');\n      if (isChrome) {\n        expect(dialog.message()).toBe('');\n      } else {\n        expect(dialog.message()).toBeTruthy();\n      }\n      await dialog.accept();\n      await pageClosingPromise;\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should *not* run beforeunload by default","suites":["Page","Page.close"],"updatePoint":{"line":82,"column":48},"line":82,"code":"    it('should *not* run beforeunload by default', async () => {\n      const {context, server} = getTestState();\n\n      const newPage = await context.newPage();\n      await newPage.goto(server.PREFIX + '/beforeunload.html');\n      // We have to interact with a page so that 'beforeunload' handlers\n      // fire.\n      await newPage.click('body');\n      await newPage.close();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should set the page close state","suites":["Page","Page.close"],"updatePoint":{"line":92,"column":39},"line":92,"code":"    it('should set the page close state', async () => {\n      const {context} = getTestState();\n\n      const newPage = await context.newPage();\n      expect(newPage.isClosed()).toBe(false);\n      await newPage.close();\n      expect(newPage.isClosed()).toBe(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should terminate network waiters","suites":["Page","Page.close"],"updatePoint":{"line":100,"column":40},"line":100,"code":"    it('should terminate network waiters', async () => {\n      const {context, server} = getTestState();\n\n      const newPage = await context.newPage();\n      const results = await Promise.all([\n        newPage.waitForRequest(server.EMPTY_PAGE).catch(error => {\n          return error;\n        }),\n        newPage.waitForResponse(server.EMPTY_PAGE).catch(error => {\n          return error;\n        }),\n        newPage.close(),\n      ]);\n      for (let i = 0; i < 2; i++) {\n        const message = results[i].message;\n        expect(message).toContain('Target closed');\n        expect(message).not.toContain('Timeout');\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire when expected","suites":["Page","Page.Events.Load"],"updatePoint":{"line":122,"column":33},"line":122,"code":"    it('should fire when expected', async () => {\n      const {page} = getTestState();\n\n      await Promise.all([\n        page.goto('about:blank'),\n        utils.waitEvent(page, 'load'),\n      ]);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly fire event handlers as they are added and then removed","suites":["Page","removing and adding event handlers"],"updatePoint":{"line":133,"column":79},"line":133,"code":"    it('should correctly fire event handlers as they are added and then removed', async () => {\n      const {page, server} = getTestState();\n\n      const handler = sinon.spy();\n      const onResponse = (response: {url: () => string}) => {\n        // Ignore default favicon requests.\n        if (!response.url().endsWith('favicon.ico')) {\n          handler();\n        }\n      };\n      page.on('response', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      expect(handler.callCount).toBe(1);\n      page.off('response', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      // Still one because we removed the handler.\n      expect(handler.callCount).toBe(1);\n      page.on('response', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      // Two now because we added the handler back.\n      expect(handler.callCount).toBe(2);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly added and removed request events","suites":["Page","removing and adding event handlers"],"updatePoint":{"line":156,"column":57},"line":156,"code":"    it('should correctly added and removed request events', async () => {\n      const {page, server} = getTestState();\n\n      const handler = sinon.spy();\n      const onResponse = (response: {url: () => string}) => {\n        // Ignore default favicon requests.\n        if (!response.url().endsWith('favicon.ico')) {\n          handler();\n        }\n      };\n\n      page.on('request', onResponse);\n      page.on('request', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      expect(handler.callCount).toBe(2);\n      page.off('request', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      // Still one because we removed the handler.\n      expect(handler.callCount).toBe(3);\n      page.off('request', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      expect(handler.callCount).toBe(3);\n      page.on('request', onResponse);\n      await page.goto(server.EMPTY_PAGE);\n      // Two now because we added the handler back.\n      expect(handler.callCount).toBe(4);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when page crashes","suites":["Page","Page.Events.error"],"updatePoint":{"line":186,"column":38},"line":186,"code":"    it('should throw when page crashes', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      page.on('error', err => {\n        return (error = err);\n      });\n      page.goto('chrome://crash').catch(() => {});\n      await waitEvent(page, 'error');\n      expect(error.message).toBe('Page crashed!');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":200,"column":19},"line":200,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.evaluate(() => {\n          return window.open('about:blank');\n        }),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with noopener","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":222,"column":33},"line":222,"code":"    it('should work with noopener', async () => {\n      const {page} = getTestState();\n\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.evaluate(() => {\n          return window.open('about:blank', undefined, 'noopener');\n        }),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and without rel=opener","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":244,"column":70},"line":244,"code":"    it('should work with clicking target=_blank and without rel=opener', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent('<a target=_blank href=\"/one-style.html\">yo</a>');\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.click('a'),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and with rel=opener","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":266,"column":67},"line":266,"code":"    it('should work with clicking target=_blank and with rel=opener', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=opener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.click('a'),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with fake-clicking target=_blank and rel=noopener","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":290,"column":69},"line":290,"code":"    it('should work with fake-clicking target=_blank and rel=noopener', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=noopener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.$eval('a', a => {\n          return (a as HTMLAnchorElement).click();\n        }),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with clicking target=_blank and rel=noopener","suites":["Page","Page.Events.Popup"],"updatePoint":{"line":316,"column":64},"line":316,"code":"    it('should work with clicking target=_blank and rel=noopener', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setContent(\n        '<a target=_blank rel=noopener href=\"/one-style.html\">yo</a>'\n      );\n      const [popup] = await Promise.all([\n        new Promise<Page>(x => {\n          return page.once('popup', x);\n        }),\n        page.click('a'),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n      expect(\n        await popup.evaluate(() => {\n          return !!window.opener;\n        })\n      ).toBe(false);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should be prompt by default","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":351,"column":35},"line":351,"code":"    it('should be prompt by default', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(await getPermission(page, 'geolocation')).toBe('prompt');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should deny permission when not listed","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":357,"column":46},"line":357,"code":"    it('should deny permission when not listed', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await context.overridePermissions(server.EMPTY_PAGE, []);\n      expect(await getPermission(page, 'geolocation')).toBe('denied');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail when bad permission is given","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":364,"column":48},"line":364,"code":"    it('should fail when bad permission is given', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error!: Error;\n      await context\n        // @ts-expect-error purposeful bad input for test\n        .overridePermissions(server.EMPTY_PAGE, ['foo'])\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toBe('Unknown permission: foo');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should grant permission when listed","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":377,"column":43},"line":377,"code":"    it('should grant permission when listed', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await context.overridePermissions(server.EMPTY_PAGE, ['geolocation']);\n      expect(await getPermission(page, 'geolocation')).toBe('granted');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should reset permissions","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":384,"column":32},"line":384,"code":"    it('should reset permissions', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await context.overridePermissions(server.EMPTY_PAGE, ['geolocation']);\n      expect(await getPermission(page, 'geolocation')).toBe('granted');\n      await context.clearPermissionOverrides();\n      expect(await getPermission(page, 'geolocation')).toBe('prompt');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger permission onchange","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":393,"column":42},"line":393,"code":"    it('should trigger permission onchange', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(() => {\n        (globalThis as any).events = [];\n        return navigator.permissions\n          .query({name: 'geolocation'})\n          .then(function (result) {\n            (globalThis as any).events.push(result.state);\n            result.onchange = function () {\n              (globalThis as any).events.push(result.state);\n            };\n          });\n      });\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).events;\n        })\n      ).toEqual(['prompt']);\n      await context.overridePermissions(server.EMPTY_PAGE, []);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).events;\n        })\n      ).toEqual(['prompt', 'denied']);\n      await context.overridePermissions(server.EMPTY_PAGE, ['geolocation']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).events;\n        })\n      ).toEqual(['prompt', 'denied', 'granted']);\n      await context.clearPermissionOverrides();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).events;\n        })\n      ).toEqual(['prompt', 'denied', 'granted', 'prompt']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should isolate permissions between browser contexts","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":432,"column":59},"line":432,"code":"    it('should isolate permissions between browser contexts', async () => {\n      const {page, server, context, browser} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const otherContext = await browser.createIncognitoBrowserContext();\n      const otherPage = await otherContext.newPage();\n      await otherPage.goto(server.EMPTY_PAGE);\n      expect(await getPermission(page, 'geolocation')).toBe('prompt');\n      expect(await getPermission(otherPage, 'geolocation')).toBe('prompt');\n\n      await context.overridePermissions(server.EMPTY_PAGE, []);\n      await otherContext.overridePermissions(server.EMPTY_PAGE, [\n        'geolocation',\n      ]);\n      expect(await getPermission(page, 'geolocation')).toBe('denied');\n      expect(await getPermission(otherPage, 'geolocation')).toBe('granted');\n\n      await context.clearPermissionOverrides();\n      expect(await getPermission(page, 'geolocation')).toBe('prompt');\n      expect(await getPermission(otherPage, 'geolocation')).toBe('granted');\n\n      await otherContext.close();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should grant persistent-storage","suites":["Page","BrowserContext.overridePermissions"],"updatePoint":{"line":455,"column":39},"line":455,"code":"    it('should grant persistent-storage', async () => {\n      const {page, server, context} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      expect(await getPermission(page, 'persistent-storage')).not.toBe(\n        'granted'\n      );\n      await context.overridePermissions(server.EMPTY_PAGE, [\n        'persistent-storage',\n      ]);\n      expect(await getPermission(page, 'persistent-storage')).toBe('granted');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setGeolocation"],"updatePoint":{"line":470,"column":19},"line":470,"code":"    it('should work', async () => {\n      const {page, server, context} = getTestState();\n\n      await context.overridePermissions(server.PREFIX, ['geolocation']);\n      await page.goto(server.EMPTY_PAGE);\n      await page.setGeolocation({longitude: 10, latitude: 10});\n      const geolocation = await page.evaluate(() => {\n        return new Promise(resolve => {\n          return navigator.geolocation.getCurrentPosition(position => {\n            resolve({\n              latitude: position.coords.latitude,\n              longitude: position.coords.longitude,\n            });\n          });\n        });\n      });\n      expect(geolocation).toEqual({\n        latitude: 10,\n        longitude: 10,\n      });\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when invalid longitude","suites":["Page","Page.setGeolocation"],"updatePoint":{"line":491,"column":43},"line":491,"code":"    it('should throw when invalid longitude', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      try {\n        await page.setGeolocation({longitude: 200, latitude: 10});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toContain('Invalid longitude \"200\"');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setOfflineMode"],"updatePoint":{"line":505,"column":19},"line":505,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setOfflineMode(true);\n      let error!: Error;\n      await page.goto(server.EMPTY_PAGE).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeTruthy();\n      await page.setOfflineMode(false);\n      const response = (await page.reload())!;\n      expect(response.status()).toBe(200);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should emulate navigator.onLine","suites":["Page","Page.setOfflineMode"],"updatePoint":{"line":518,"column":39},"line":518,"code":"    it('should emulate navigator.onLine', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return window.navigator.onLine;\n        })\n      ).toBe(true);\n      await page.setOfflineMode(true);\n      expect(\n        await page.evaluate(() => {\n          return window.navigator.onLine;\n        })\n      ).toBe(false);\n      await page.setOfflineMode(false);\n      expect(\n        await page.evaluate(() => {\n          return window.navigator.onLine;\n        })\n      ).toBe(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":542,"column":19},"line":542,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      // Create a custom class\n      const classHandle = await page.evaluateHandle(() => {\n        return class CustomClass {};\n      });\n\n      // Create an instance.\n      await page.evaluate(CustomClass => {\n        // @ts-expect-error: Different context.\n        self.customClass = new CustomClass();\n      }, classHandle);\n\n      // Validate only one has been added.\n      const prototypeHandle = await page.evaluateHandle(CustomClass => {\n        return CustomClass.prototype;\n      }, classHandle);\n      const objectsHandle = await page.queryObjects(prototypeHandle);\n      await expect(\n        page.evaluate(objects => {\n          return objects.length;\n        }, objectsHandle)\n      ).resolves.toBe(1);\n\n      // Check that instances.\n      await expect(\n        page.evaluate(objects => {\n          // @ts-expect-error: Different context.\n          return objects[0] === self.customClass;\n        }, objectsHandle)\n      ).resolves.toBeTruthy();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work for non-trivial page","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":575,"column":40},"line":575,"code":"    it('should work for non-trivial page', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n\n      // Create a custom class\n      const classHandle = await page.evaluateHandle(() => {\n        return class CustomClass {};\n      });\n\n      // Create an instance.\n      await page.evaluate(CustomClass => {\n        // @ts-expect-error: Different context.\n        self.customClass = new CustomClass();\n      }, classHandle);\n\n      // Validate only one has been added.\n      const prototypeHandle = await page.evaluateHandle(CustomClass => {\n        return CustomClass.prototype;\n      }, classHandle);\n      const objectsHandle = await page.queryObjects(prototypeHandle);\n      await expect(\n        page.evaluate(objects => {\n          return objects.length;\n        }, objectsHandle)\n      ).resolves.toBe(1);\n\n      // Check that instances.\n      await expect(\n        page.evaluate(objects => {\n          // @ts-expect-error: Different context.\n          return objects[0] === self.customClass;\n        }, objectsHandle)\n      ).resolves.toBeTruthy();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail for disposed handles","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":609,"column":40},"line":609,"code":"    it('should fail for disposed handles', async () => {\n      const {page} = getTestState();\n\n      const prototypeHandle = await page.evaluateHandle(() => {\n        return HTMLBodyElement.prototype;\n      });\n      await prototypeHandle.dispose();\n      let error!: Error;\n      await page.queryObjects(prototypeHandle).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe('Prototype JSHandle is disposed!');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fail primitive values as prototypes","suites":["Page","ExecutionContext.queryObjects"],"updatePoint":{"line":622,"column":50},"line":622,"code":"    it('should fail primitive values as prototypes', async () => {\n      const {page} = getTestState();\n\n      const prototypeHandle = await page.evaluateHandle(() => {\n        return 42;\n      });\n      let error!: Error;\n      await page.queryObjects(prototypeHandle).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toBe(\n        'Prototype JSHandle must not be referencing primitive value'\n      );\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.Events.Console"],"updatePoint":{"line":639,"column":19},"line":639,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      let message!: ConsoleMessage;\n      page.once('console', m => {\n        return (message = m);\n      });\n      await Promise.all([\n        page.evaluate(() => {\n          return console.log('hello', 5, {foo: 'bar'});\n        }),\n        waitEvent(page, 'console'),\n      ]);\n      expect(message.text()).toEqual('hello 5 JSHandle@object');\n      expect(message.type()).toEqual('log');\n      expect(message.args()).toHaveLength(3);\n      expect(message.location()).toEqual({\n        url: expect.any(String),\n        lineNumber: expect.any(Number),\n        columnNumber: expect.any(Number),\n      });\n\n      expect(await message.args()[0]!.jsonValue()).toEqual('hello');\n      expect(await message.args()[1]!.jsonValue()).toEqual(5);\n      expect(await message.args()[2]!.jsonValue()).toEqual({foo: 'bar'});\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work for different console API calls","suites":["Page","Page.Events.Console"],"updatePoint":{"line":665,"column":51},"line":665,"code":"    it('should work for different console API calls', async () => {\n      const {page} = getTestState();\n\n      const messages: any[] = [];\n      page.on('console', msg => {\n        return messages.push(msg);\n      });\n      // All console events will be reported before `page.evaluate` is finished.\n      await page.evaluate(() => {\n        // A pair of time/timeEnd generates only one Console API call.\n        console.time('calling console.time');\n        console.timeEnd('calling console.time');\n        console.trace('calling console.trace');\n        console.dir('calling console.dir');\n        console.warn('calling console.warn');\n        console.error('calling console.error');\n        console.log(Promise.resolve('should not wait until resolved!'));\n      });\n      expect(\n        messages.map(msg => {\n          return msg.type();\n        })\n      ).toEqual(['timeEnd', 'trace', 'dir', 'warning', 'error', 'log']);\n      expect(messages[0]!.text()).toContain('calling console.time');\n      expect(\n        messages.slice(1).map(msg => {\n          return msg.text();\n        })\n      ).toEqual([\n        'calling console.trace',\n        'calling console.dir',\n        'calling console.warn',\n        'calling console.error',\n        'JSHandle@promise',\n      ]);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should not fail for window object","suites":["Page","Page.Events.Console"],"updatePoint":{"line":701,"column":41},"line":701,"code":"    it('should not fail for window object', async () => {\n      const {page} = getTestState();\n\n      let message!: ConsoleMessage;\n      page.once('console', msg => {\n        return (message = msg);\n      });\n      await Promise.all([\n        page.evaluate(() => {\n          return console.error(window);\n        }),\n        waitEvent(page, 'console'),\n      ]);\n      expect(message.text()).toBe('JSHandle@object');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should trigger correct Log","suites":["Page","Page.Events.Console"],"updatePoint":{"line":716,"column":34},"line":716,"code":"    it('should trigger correct Log', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.goto('about:blank');\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.evaluate(async (url: string) => {\n          return fetch(url).catch(() => {});\n        }, server.EMPTY_PAGE),\n      ]);\n      expect(message.text()).toContain('Access-Control-Allow-Origin');\n      if (isChrome) {\n        expect(message.type()).toEqual('error');\n      } else {\n        expect(message.type()).toEqual('warn');\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should have location when fetch fails","suites":["Page","Page.Events.Console"],"updatePoint":{"line":733,"column":45},"line":733,"code":"    it('should have location when fetch fails', async () => {\n      const {page, server} = getTestState();\n\n      // The point of this test is to make sure that we report console messages from\n      // Log domain: https://vanilla.aslushnikov.com/?Log.entryAdded\n      await page.goto(server.EMPTY_PAGE);\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.setContent(`<script>fetch('http://wat');</script>`),\n      ]);\n      expect(message.text()).toContain(`ERR_NAME_NOT_RESOLVED`);\n      expect(message.type()).toEqual('error');\n      expect(message.location()).toEqual({\n        url: 'http://wat/',\n        lineNumber: undefined,\n      });\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should have location and stack trace for console API calls","suites":["Page","Page.Events.Console"],"updatePoint":{"line":750,"column":66},"line":750,"code":"    it('should have location and stack trace for console API calls', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [message] = await Promise.all([\n        waitEvent(page, 'console'),\n        page.goto(server.PREFIX + '/consolelog.html'),\n      ]);\n      expect(message.text()).toBe('yellow');\n      expect(message.type()).toBe('log');\n      expect(message.location()).toEqual({\n        url: server.PREFIX + '/consolelog.html',\n        lineNumber: 8,\n        columnNumber: isChrome ? 16 : 8, // console.|log vs |console.log\n      });\n      expect(message.stackTrace()).toEqual([\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 8,\n          columnNumber: isChrome ? 16 : 8, // console.|log vs |console.log\n        },\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 11,\n          columnNumber: 8,\n        },\n        {\n          url: server.PREFIX + '/consolelog.html',\n          lineNumber: 13,\n          columnNumber: 6,\n        },\n      ]);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when there are console messages in detached iframes","suites":["Page","Page.Events.Console"],"updatePoint":{"line":784,"column":76},"line":784,"code":"    it('should not throw when there are console messages in detached iframes', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.evaluate(async () => {\n        // 1. Create a popup that Puppeteer is not connected to.\n        const win = window.open(\n          window.location.href,\n          'Title',\n          'toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=780,height=200,top=0,left=0'\n        )!;\n        await new Promise(x => {\n          return (win.onload = x);\n        });\n        // 2. In this popup, create an iframe that console.logs a message.\n        win.document.body.innerHTML = `<iframe src='/consolelog.html'></iframe>`;\n        const frame = win.document.querySelector('iframe')!;\n        await new Promise(x => {\n          return (frame.onload = x);\n        });\n        // 3. After that, remove the iframe.\n        frame.remove();\n      });\n      const popupTarget = page\n        .browserContext()\n        .targets()\n        .find(target => {\n          return target !== page.target();\n        })!;\n      // 4. Connect to the popup and make sure it doesn't throw.\n      await popupTarget.page();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire when expected","suites":["Page","Page.Events.DOMContentLoaded"],"updatePoint":{"line":819,"column":33},"line":819,"code":"    it('should fire when expected', async () => {\n      const {page} = getTestState();\n\n      page.goto('about:blank');\n      await waitEvent(page, 'domcontentloaded');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should get metrics from a page","suites":["Page","Page.metrics"],"updatePoint":{"line":828,"column":38},"line":828,"code":"    it('should get metrics from a page', async () => {\n      const {page} = getTestState();\n\n      await page.goto('about:blank');\n      const metrics = await page.metrics();\n      checkMetrics(metrics);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"metrics event fired on console.timeStamp","suites":["Page","Page.metrics"],"updatePoint":{"line":835,"column":48},"line":835,"code":"    it('metrics event fired on console.timeStamp', async () => {\n      const {page} = getTestState();\n\n      const metricsPromise = new Promise<{metrics: Metrics; title: string}>(\n        fulfill => {\n          return page.once('metrics', fulfill);\n        }\n      );\n      await page.evaluate(() => {\n        return console.timeStamp('test42');\n      });\n      const metrics = await metricsPromise;\n      expect(metrics.title).toBe('test42');\n      checkMetrics(metrics.metrics);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":876,"column":19},"line":876,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(server.PREFIX + '/digits/2.png'),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with predicate","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":890,"column":34},"line":890,"code":"    it('should work with predicate', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(request => {\n          return request.url() === server.PREFIX + '/digits/2.png';\n        }),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with async predicate","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":906,"column":40},"line":906,"code":"    it('should work with async predicate', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(async request => {\n          return request.url() === server.PREFIX + '/digits/2.png';\n        }),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":922,"column":30},"line":922,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .waitForRequest(\n          () => {\n            return false;\n          },\n          {timeout: 1}\n        )\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":938,"column":38},"line":938,"code":"    it('should respect default timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      page.setDefaultTimeout(1);\n      await page\n        .waitForRequest(() => {\n          return false;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForRequest"],"updatePoint":{"line":952,"column":35},"line":952,"code":"    it('should work with no timeout', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        page.waitForRequest(server.PREFIX + '/digits/2.png', {timeout: 0}),\n        page.evaluate(() => {\n          return setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50);\n        }),\n      ]);\n      expect(request.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":971,"column":19},"line":971,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(server.PREFIX + '/digits/2.png'),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":985,"column":30},"line":985,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .waitForResponse(\n          () => {\n            return false;\n          },\n          {timeout: 1}\n        )\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":1001,"column":38},"line":1001,"code":"    it('should respect default timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      page.setDefaultTimeout(1);\n      await page\n        .waitForResponse(() => {\n          return false;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with predicate","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":1015,"column":34},"line":1015,"code":"    it('should work with predicate', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(response => {\n          return response.url() === server.PREFIX + '/digits/2.png';\n        }),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with async predicate","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":1031,"column":40},"line":1031,"code":"    it('should work with async predicate', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(async response => {\n          return response.url() === server.PREFIX + '/digits/2.png';\n        }),\n        page.evaluate(() => {\n          fetch('/digits/1.png');\n          fetch('/digits/2.png');\n          fetch('/digits/3.png');\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForResponse"],"updatePoint":{"line":1046,"column":35},"line":1046,"code":"    it('should work with no timeout', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const [response] = await Promise.all([\n        page.waitForResponse(server.PREFIX + '/digits/2.png', {timeout: 0}),\n        page.evaluate(() => {\n          return setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50);\n        }),\n      ]);\n      expect(response.url()).toBe(server.PREFIX + '/digits/2.png');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1065,"column":19},"line":1065,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      let res;\n      const [t1, t2] = await Promise.all([\n        page.waitForNetworkIdle().then(r => {\n          res = r;\n          return Date.now();\n        }),\n        page\n          .evaluate(() => {\n            return (async () => {\n              await Promise.all([\n                fetch('/digits/1.png'),\n                fetch('/digits/2.png'),\n              ]);\n              await new Promise(resolve => {\n                return setTimeout(resolve, 200);\n              });\n              await fetch('/digits/3.png');\n              await new Promise(resolve => {\n                return setTimeout(resolve, 200);\n              });\n              await fetch('/digits/4.png');\n            })();\n          })\n          .then(() => {\n            return Date.now();\n          }),\n      ]);\n      expect(res).toBe(undefined);\n      expect(t1).toBeGreaterThan(t2);\n      expect(t1 - t2).toBeGreaterThanOrEqual(400);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1099,"column":30},"line":1099,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n      let error!: Error;\n      await page.waitForNetworkIdle({timeout: 1}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect idleTime","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1107,"column":31},"line":1107,"code":"    it('should respect idleTime', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [t1, t2] = await Promise.all([\n        page.waitForNetworkIdle({idleTime: 10}).then(() => {\n          return Date.now();\n        }),\n        page\n          .evaluate(() => {\n            return (async () => {\n              await Promise.all([\n                fetch('/digits/1.png'),\n                fetch('/digits/2.png'),\n              ]);\n              await new Promise(resolve => {\n                return setTimeout(resolve, 250);\n              });\n            })();\n          })\n          .then(() => {\n            return Date.now();\n          }),\n      ]);\n      expect(t2).toBeGreaterThan(t1);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with no timeout","suites":["Page","Page.waitForNetworkIdle"],"updatePoint":{"line":1132,"column":35},"line":1132,"code":"    it('should work with no timeout', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const [result] = await Promise.all([\n        page.waitForNetworkIdle({timeout: 0}),\n        page.evaluate(() => {\n          return setTimeout(() => {\n            fetch('/digits/1.png');\n            fetch('/digits/2.png');\n            fetch('/digits/3.png');\n          }, 50);\n        }),\n      ]);\n      expect(result).toBe(undefined);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1150,"column":19},"line":1150,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return a * b;\n      });\n      const result = await page.evaluate(async function () {\n        return await (globalThis as any).compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw exception in page context","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1161,"column":46},"line":1161,"code":"    it('should throw exception in page context', async () => {\n      const {page} = getTestState();\n\n      await page.exposeFunction('woof', () => {\n        throw new Error('WOOF WOOF');\n      });\n      const {message, stack} = await page.evaluate(async () => {\n        try {\n          return await (globalThis as any).woof();\n        } catch (error) {\n          return {\n            message: (error as Error).message,\n            stack: (error as Error).stack,\n          };\n        }\n      });\n      expect(message).toBe('WOOF WOOF');\n      expect(stack).toContain('page.spec.ts');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should support throwing \"null\"","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1180,"column":38},"line":1180,"code":"    it('should support throwing \"null\"', async () => {\n      const {page} = getTestState();\n\n      await page.exposeFunction('woof', function () {\n        throw null;\n      });\n      const thrown = await page.evaluate(async () => {\n        try {\n          await (globalThis as any).woof();\n        } catch (error) {\n          return error;\n        }\n      });\n      expect(thrown).toBe(null);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should be callable from-inside evaluateOnNewDocument","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1195,"column":60},"line":1195,"code":"    it('should be callable from-inside evaluateOnNewDocument', async () => {\n      const {page} = getTestState();\n\n      let called = false;\n      await page.exposeFunction('woof', function () {\n        called = true;\n      });\n      await page.evaluateOnNewDocument(() => {\n        return (globalThis as any).woof();\n      });\n      await page.reload();\n      expect(called).toBe(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should survive navigation","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1208,"column":33},"line":1208,"code":"    it('should survive navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return a * b;\n      });\n\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async function () {\n        return await (globalThis as any).compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should await returned promise","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1221,"column":37},"line":1221,"code":"    it('should await returned promise', async () => {\n      const {page} = getTestState();\n\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return Promise.resolve(a * b);\n      });\n\n      const result = await page.evaluate(async function () {\n        return await (globalThis as any).compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work on frames","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1233,"column":29},"line":1233,"code":"    it('should work on frames', async () => {\n      const {page, server} = getTestState();\n\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return Promise.resolve(a * b);\n      });\n\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      const frame = page.frames()[1]!;\n      const result = await frame.evaluate(async function () {\n        return await (globalThis as any).compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work on frames before navigation","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1247,"column":47},"line":1247,"code":"    it('should work on frames before navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/frames/nested-frames.html');\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return Promise.resolve(a * b);\n      });\n\n      const frame = page.frames()[1]!;\n      const result = await frame.evaluate(async function () {\n        return await (globalThis as any).compute(3, 5);\n      });\n      expect(result).toBe(15);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when frames detach","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1261,"column":43},"line":1261,"code":"    it('should not throw when frames detach', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await page.exposeFunction('compute', function (a: number, b: number) {\n        return Promise.resolve(a * b);\n      });\n      await utils.detachFrame(page, 'frame1');\n\n      await expect(\n        page.evaluate(async function () {\n          return await (globalThis as any).compute(3, 5);\n        })\n      ).resolves.toEqual(15);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with complex objects","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1277,"column":40},"line":1277,"code":"    it('should work with complex objects', async () => {\n      const {page} = getTestState();\n\n      await page.exposeFunction(\n        'complexObject',\n        function (a: {x: any}, b: {x: any}) {\n          return {x: a.x + b.x};\n        }\n      );\n      const result = await page.evaluate(async () => {\n        return (globalThis as any).complexObject({x: 5}, {x: 2});\n      });\n      expect(result.x).toBe(7);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fallback to default export when passed a module object","suites":["Page","Page.exposeFunction"],"updatePoint":{"line":1291,"column":69},"line":1291,"code":"    it('should fallback to default export when passed a module object', async () => {\n      const {page, server} = getTestState();\n      const moduleObject = {\n        default: function (a: number, b: number) {\n          return a * b;\n        },\n      };\n      await page.goto(server.EMPTY_PAGE);\n      await page.exposeFunction('compute', moduleObject);\n      const result = await page.evaluate(async function () {\n        return await (globalThis as any).compute(9, 4);\n      });\n      expect(result).toBe(36);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should fire","suites":["Page","Page.Events.PageError"],"updatePoint":{"line":1308,"column":19},"line":1308,"code":"    it('should fire', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      page.once('pageerror', e => {\n        return (error = e);\n      });\n      await Promise.all([\n        page.goto(server.PREFIX + '/error.html'),\n        waitEvent(page, 'pageerror'),\n      ]);\n      expect(error.message).toContain('Fancy');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1324,"column":19},"line":1324,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return navigator.userAgent;\n        })\n      ).toContain('Mozilla');\n      await page.setUserAgent('foobar');\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['user-agent']).toBe('foobar');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work for subframes","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1339,"column":33},"line":1339,"code":"    it('should work for subframes', async () => {\n      const {page, server} = getTestState();\n\n      expect(\n        await page.evaluate(() => {\n          return navigator.userAgent;\n        })\n      ).toContain('Mozilla');\n      await page.setUserAgent('foobar');\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        utils.attachFrame(page, 'frame1', server.EMPTY_PAGE),\n      ]);\n      expect(request.headers['user-agent']).toBe('foobar');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should emulate device user-agent","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1354,"column":40},"line":1354,"code":"    it('should emulate device user-agent', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/mobile.html');\n      expect(\n        await page.evaluate(() => {\n          return navigator.userAgent;\n        })\n      ).not.toContain('iPhone');\n      await page.setUserAgent(KnownDevices['iPhone 6'].userAgent);\n      expect(\n        await page.evaluate(() => {\n          return navigator.userAgent;\n        })\n      ).toContain('iPhone');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with additional userAgentMetdata","suites":["Page","Page.setUserAgent"],"updatePoint":{"line":1370,"column":52},"line":1370,"code":"    it('should work with additional userAgentMetdata', async () => {\n      const {page, server} = getTestState();\n\n      await page.setUserAgent('MockBrowser', {\n        architecture: 'Mock1',\n        mobile: false,\n        model: 'Mockbook',\n        platform: 'MockOS',\n        platformVersion: '3.1',\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(\n        await page.evaluate(() => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore: userAgentData not yet in TypeScript DOM API\n          return navigator.userAgentData.mobile;\n        })\n      ).toBe(false);\n\n      const uaData = await page.evaluate(() => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: userAgentData not yet in TypeScript DOM API\n        return navigator.userAgentData.getHighEntropyValues([\n          'architecture',\n          'model',\n          'platform',\n          'platformVersion',\n        ]);\n      });\n      expect(uaData['architecture']).toBe('Mock1');\n      expect(uaData['model']).toBe('Mockbook');\n      expect(uaData['platform']).toBe('MockOS');\n      expect(uaData['platformVersion']).toBe('3.1');\n      expect(request.headers['user-agent']).toBe('MockBrowser');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setContent"],"updatePoint":{"line":1413,"column":19},"line":1413,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>hello</div>');\n      const result = await page.content();\n      expect(result).toBe(expectedOutput);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with doctype","suites":["Page","Page.setContent"],"updatePoint":{"line":1420,"column":32},"line":1420,"code":"    it('should work with doctype', async () => {\n      const {page} = getTestState();\n\n      const doctype = '<!DOCTYPE html>';\n      await page.setContent(`${doctype}<div>hello</div>`);\n      const result = await page.content();\n      expect(result).toBe(`${doctype}${expectedOutput}`);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with HTML 4 doctype","suites":["Page","Page.setContent"],"updatePoint":{"line":1428,"column":39},"line":1428,"code":"    it('should work with HTML 4 doctype', async () => {\n      const {page} = getTestState();\n\n      const doctype =\n        '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" ' +\n        '\"http://www.w3.org/TR/html4/strict.dtd\">';\n      await page.setContent(`${doctype}<div>hello</div>`);\n      const result = await page.content();\n      expect(result).toBe(`${doctype}${expectedOutput}`);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","Page.setContent"],"updatePoint":{"line":1438,"column":30},"line":1438,"code":"    it('should respect timeout', async () => {\n      const {page, server} = getTestState();\n\n      const imgPath = '/img.png';\n      // stall for image\n      server.setRoute(imgPath, () => {});\n      let error!: Error;\n      await page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`, {\n          timeout: 1,\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default navigation timeout","suites":["Page","Page.setContent"],"updatePoint":{"line":1454,"column":49},"line":1454,"code":"    it('should respect default navigation timeout', async () => {\n      const {page, server} = getTestState();\n\n      page.setDefaultNavigationTimeout(1);\n      const imgPath = '/img.png';\n      // stall for image\n      server.setRoute(imgPath, () => {});\n      let error!: Error;\n      await page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`)\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should await resources to load","suites":["Page","Page.setContent"],"updatePoint":{"line":1469,"column":38},"line":1469,"code":"    it('should await resources to load', async () => {\n      const {page, server} = getTestState();\n\n      const imgPath = '/img.png';\n      let imgResponse!: ServerResponse;\n      server.setRoute(imgPath, (_req, res) => {\n        return (imgResponse = res);\n      });\n      let loaded = false;\n      const contentPromise = page\n        .setContent(`<img src=\"${server.PREFIX + imgPath}\"></img>`)\n        .then(() => {\n          return (loaded = true);\n        });\n      await server.waitForRequest(imgPath);\n      expect(loaded).toBe(false);\n      imgResponse.end();\n      await contentPromise;\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work fast enough","suites":["Page","Page.setContent"],"updatePoint":{"line":1488,"column":31},"line":1488,"code":"    it('should work fast enough', async () => {\n      const {page} = getTestState();\n\n      for (let i = 0; i < 20; ++i) {\n        await page.setContent('<div>yo</div>');\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with tricky content","suites":["Page","Page.setContent"],"updatePoint":{"line":1495,"column":39},"line":1495,"code":"    it('should work with tricky content', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>hello world</div>' + '\\x7F');\n      expect(\n        await page.$eval('div', div => {\n          return div.textContent;\n        })\n      ).toBe('hello world');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with accents","suites":["Page","Page.setContent"],"updatePoint":{"line":1505,"column":32},"line":1505,"code":"    it('should work with accents', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>aberracin</div>');\n      expect(\n        await page.$eval('div', div => {\n          return div.textContent;\n        })\n      ).toBe('aberracin');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with emojis","suites":["Page","Page.setContent"],"updatePoint":{"line":1515,"column":31},"line":1515,"code":"    it('should work with emojis', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div></div>');\n      expect(\n        await page.$eval('div', div => {\n          return div.textContent;\n        })\n      ).toBe('');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with newline","suites":["Page","Page.setContent"],"updatePoint":{"line":1525,"column":32},"line":1525,"code":"    it('should work with newline', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>\\n</div>');\n      expect(\n        await page.$eval('div', div => {\n          return div.textContent;\n        })\n      ).toBe('\\n');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP meta tag","suites":["Page","Page.setBypassCSP"],"updatePoint":{"line":1538,"column":34},"line":1538,"code":"    it('should bypass CSP meta tag', async () => {\n      const {page, server} = getTestState();\n\n      // Make sure CSP prohibits addScriptTag.\n      await page.goto(server.PREFIX + '/csp.html');\n      await page\n        .addScriptTag({content: 'window.__injected = 42;'})\n        .catch(error => {\n          return void error;\n        });\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(undefined);\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n      await page.addScriptTag({content: 'window.__injected = 42;'});\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP header","suites":["Page","Page.setBypassCSP"],"updatePoint":{"line":1565,"column":32},"line":1565,"code":"    it('should bypass CSP header', async () => {\n      const {page, server} = getTestState();\n\n      // Make sure CSP prohibits addScriptTag.\n      server.setCSP('/empty.html', 'default-src \"self\"');\n      await page.goto(server.EMPTY_PAGE);\n      await page\n        .addScriptTag({content: 'window.__injected = 42;'})\n        .catch(error => {\n          return void error;\n        });\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(undefined);\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n      await page.addScriptTag({content: 'window.__injected = 42;'});\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass after cross-process navigation","suites":["Page","Page.setBypassCSP"],"updatePoint":{"line":1593,"column":52},"line":1593,"code":"    it('should bypass after cross-process navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.setBypassCSP(true);\n      await page.goto(server.PREFIX + '/csp.html');\n      await page.addScriptTag({content: 'window.__injected = 42;'});\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/csp.html');\n      await page.addScriptTag({content: 'window.__injected = 42;'});\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should bypass CSP in iframes as well","suites":["Page","Page.setBypassCSP"],"updatePoint":{"line":1613,"column":44},"line":1613,"code":"    it('should bypass CSP in iframes as well', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      {\n        // Make sure CSP prohibits addScriptTag in an iframe.\n        const frame = (await attachFrame(\n          page,\n          'frame1',\n          server.PREFIX + '/csp.html'\n        ))!;\n        await frame\n          .addScriptTag({content: 'window.__injected = 42;'})\n          .catch(error => {\n            return void error;\n          });\n        expect(\n          await frame.evaluate(() => {\n            return (globalThis as any).__injected;\n          })\n        ).toBe(undefined);\n      }\n\n      // By-pass CSP and try one more time.\n      await page.setBypassCSP(true);\n      await page.reload();\n\n      {\n        const frame = (await attachFrame(\n          page,\n          'frame1',\n          server.PREFIX + '/csp.html'\n        ))!;\n        await frame\n          .addScriptTag({content: 'window.__injected = 42;'})\n          .catch(error => {\n            return void error;\n          });\n        expect(\n          await frame.evaluate(() => {\n            return (globalThis as any).__injected;\n          })\n        ).toBe(42);\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if no options are provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1661,"column":56},"line":1661,"code":"    it('should throw an error if no options are provided', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      try {\n        // @ts-expect-error purposefully passing bad options\n        await page.addScriptTag('/injectedfile.js');\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toBe(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1676,"column":30},"line":1676,"code":"    it('should work with a url', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({url: '/injectedfile.js'});\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1689,"column":46},"line":1689,"code":"    it('should work with a url and type=module', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({url: '/es6/es6import.js', type: 'module'});\n      expect(\n        await page.evaluate(() => {\n          return (window as unknown as {__es6injected: number}).__es6injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1701,"column":47},"line":1701,"code":"    it('should work with a path and type=module', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        path: path.join(__dirname, '../assets/es6/es6pathimport.js'),\n        type: 'module',\n      });\n      await page.waitForFunction(() => {\n        return (window as unknown as {__es6injected: number}).__es6injected;\n      });\n      expect(\n        await page.evaluate(() => {\n          return (window as unknown as {__es6injected: number}).__es6injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a content and type=module","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1719,"column":50},"line":1719,"code":"    it('should work with a content and type=module', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        content: `import num from '/es6/es6module.js';window.__es6injected = num;`,\n        type: 'module',\n      });\n      await page.waitForFunction(() => {\n        return (window as unknown as {__es6injected: number}).__es6injected;\n      });\n      expect(\n        await page.evaluate(() => {\n          return (window as unknown as {__es6injected: number}).__es6injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if loading from url fail","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1737,"column":54},"line":1737,"code":"    it('should throw an error if loading from url fail', async () => {\n      const {page, server, isFirefox} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error!: Error;\n      try {\n        await page.addScriptTag({url: '/nonexistfile.js'});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      if (isFirefox) {\n        expect(error.message).toBeTruthy();\n      } else {\n        expect(error.message).toContain('Could not load script');\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1754,"column":31},"line":1754,"code":"    it('should work with a path', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({\n        path: path.join(__dirname, '../assets/injectedfile.js'),\n      });\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(42);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should include sourcemap when path is provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1769,"column":54},"line":1769,"code":"    it('should include sourcemap when path is provided', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({\n        path: path.join(__dirname, '../assets/injectedfile.js'),\n      });\n      const result = await page.evaluate(() => {\n        return (globalThis as any).__injectedError.stack;\n      });\n      expect(result).toContain(path.join('assets', 'injectedfile.js'));\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with content","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1782,"column":32},"line":1782,"code":"    it('should work with content', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const scriptHandle = await page.addScriptTag({\n        content: 'window.__injected = 35;',\n      });\n      expect(scriptHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).__injected;\n        })\n      ).toBe(35);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should add id when provided","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1797,"column":35},"line":1797,"code":"    it('should add id when provided', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      await page.addScriptTag({content: 'window.__injected = 1;', id: 'one'});\n      await page.addScriptTag({url: '/injectedfile.js', id: 'two'});\n      expect(await page.$('#one')).not.toBeNull();\n      expect(await page.$('#two')).not.toBeNull();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when added with content to the CSP page","suites":["Page","Page.addScriptTag"],"line":1807,"code":"    it.skip('should throw when added with content to the CSP page', async () => {","file":"src/page.spec.ts","skipped":true,"dir":"test"},{"name":"should throw when added with URL to the CSP page","suites":["Page","Page.addScriptTag"],"updatePoint":{"line":1820,"column":56},"line":1820,"code":"    it('should throw when added with URL to the CSP page', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error!: Error;\n      await page\n        .addScriptTag({url: server.CROSS_PROCESS_PREFIX + '/injectedfile.js'})\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if no options are provided","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1835,"column":56},"line":1835,"code":"    it('should throw an error if no options are provided', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      try {\n        // @ts-expect-error purposefully passing bad input\n        await page.addStyleTag('/injectedstyle.css');\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toBe(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a url","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1850,"column":30},"line":1850,"code":"    it('should work with a url', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({url: '/injectedstyle.css'});\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(255, 0, 0)');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if loading from url fail","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1863,"column":54},"line":1863,"code":"    it('should throw an error if loading from url fail', async () => {\n      const {page, server, isFirefox} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let error!: Error;\n      try {\n        await page.addStyleTag({url: '/nonexistfile.js'});\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      if (isFirefox) {\n        expect(error.message).toBeTruthy();\n      } else {\n        expect(error.message).toContain('Could not load style');\n      }\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a path","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1880,"column":31},"line":1880,"code":"    it('should work with a path', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({\n        path: path.join(__dirname, '../assets/injectedstyle.css'),\n      });\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(255, 0, 0)');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should include sourcemap when path is provided","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1895,"column":54},"line":1895,"code":"    it('should include sourcemap when path is provided', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.addStyleTag({\n        path: path.join(__dirname, '../assets/injectedstyle.css'),\n      });\n      const styleHandle = (await page.$('style'))!;\n      const styleContent = await page.evaluate((style: HTMLStyleElement) => {\n        return style.innerHTML;\n      }, styleHandle);\n      expect(styleContent).toContain(path.join('assets', 'injectedstyle.css'));\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with content","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1909,"column":32},"line":1909,"code":"    it('should work with content', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const styleHandle = await page.addStyleTag({\n        content: 'body { background-color: green; }',\n      });\n      expect(styleHandle.asElement()).not.toBeNull();\n      expect(\n        await page.evaluate(\n          `window.getComputedStyle(document.querySelector('body')).getPropertyValue('background-color')`\n        )\n      ).toBe('rgb(0, 128, 0)');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when added with content to the CSP page","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1924,"column":60},"line":1924,"code":"    it('should throw when added with content to the CSP page', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error!: Error;\n      await page\n        .addStyleTag({content: 'body { background-color: green; }'})\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when added with URL to the CSP page","suites":["Page","Page.addStyleTag"],"updatePoint":{"line":1937,"column":56},"line":1937,"code":"    it('should throw when added with URL to the CSP page', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/csp.html');\n      let error!: Error;\n      await page\n        .addStyleTag({\n          url: server.CROSS_PROCESS_PREFIX + '/injectedstyle.css',\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.url"],"updatePoint":{"line":1954,"column":19},"line":1954,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      expect(page.url()).toBe('about:blank');\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Page","Page.setJavaScriptEnabled"],"updatePoint":{"line":1964,"column":19},"line":1964,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setJavaScriptEnabled(false);\n      await page.goto(\n        'data:text/html, <script>var something = \"forbidden\"</script>'\n      );\n      let error!: Error;\n      await page.evaluate('something').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain('something is not defined');\n\n      await page.setJavaScriptEnabled(true);\n      await page.goto(\n        'data:text/html, <script>var something = \"forbidden\"</script>'\n      );\n      expect(await page.evaluate('something')).toBe('forbidden');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should enable or disable the cache based on the state passed","suites":["Page","Page.setCacheEnabled"],"updatePoint":{"line":1986,"column":68},"line":1986,"code":"    it('should enable or disable the cache based on the state passed', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      const [cachedRequest] = await Promise.all([\n        server.waitForRequest('/cached/one-style.html'),\n        page.reload(),\n      ]);\n      // Rely on \"if-modified-since\" caching in our test server.\n      expect(cachedRequest.headers['if-modified-since']).not.toBe(undefined);\n\n      await page.setCacheEnabled(false);\n      const [nonCachedRequest] = await Promise.all([\n        server.waitForRequest('/cached/one-style.html'),\n        page.reload(),\n      ]);\n      expect(nonCachedRequest.headers['if-modified-since']).toBe(undefined);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should stay disabled when toggling request interception on/off","suites":["Page","Page.setCacheEnabled"],"updatePoint":{"line":2004,"column":70},"line":2004,"code":"    it('should stay disabled when toggling request interception on/off', async () => {\n      const {page, server} = getTestState();\n\n      await page.setCacheEnabled(false);\n      await page.setRequestInterception(true);\n      await page.setRequestInterception(false);\n\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n      const [nonCachedRequest] = await Promise.all([\n        server.waitForRequest('/cached/one-style.html'),\n        page.reload(),\n      ]);\n      expect(nonCachedRequest.headers['if-modified-since']).toBe(undefined);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"can print to PDF and save to file","suites":["Page","printing to PDF"],"updatePoint":{"line":2021,"column":41},"line":2021,"code":"    it('can print to PDF and save to file', async () => {\n      // Printing to pdf is currently only supported in headless\n      const {isHeadless, page} = getTestState();\n\n      if (!isHeadless) {\n        return;\n      }\n\n      const outputFile = __dirname + '/../assets/output.pdf';\n      await page.pdf({path: outputFile});\n      expect(fs.readFileSync(outputFile).byteLength).toBeGreaterThan(0);\n      fs.unlinkSync(outputFile);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"can print to PDF and stream the result","suites":["Page","printing to PDF"],"updatePoint":{"line":2035,"column":46},"line":2035,"code":"    it('can print to PDF and stream the result', async () => {\n      // Printing to pdf is currently only supported in headless\n      const {isHeadless, page} = getTestState();\n\n      if (!isHeadless) {\n        return;\n      }\n\n      const stream = await page.createPDFStream();\n      let size = 0;\n      for await (const chunk of stream) {\n        size += chunk.length;\n      }\n      expect(size).toBeGreaterThan(0);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["Page","printing to PDF"],"updatePoint":{"line":2051,"column":30},"line":2051,"code":"    it('should respect timeout', async () => {\n      const {isHeadless, page, server} = getTestState();\n      if (!isHeadless) {\n        return;\n      }\n\n      await page.goto(server.PREFIX + '/pdf.html');\n\n      let error!: Error;\n      await page.pdf({timeout: 1}).catch(_error => {\n        return (error = _error);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the page title","suites":["Page","Page.title"],"updatePoint":{"line":2068,"column":36},"line":2068,"code":"    it('should return the page title', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/title.html');\n      expect(await page.title()).toBe('Woof-Woof');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should select single option","suites":["Page","Page.select"],"updatePoint":{"line":2077,"column":35},"line":2077,"code":"    it('should select single option', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onInput;\n        })\n      ).toEqual(['blue']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onChange;\n        })\n      ).toEqual(['blue']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should select only first option","suites":["Page","Page.select"],"updatePoint":{"line":2093,"column":39},"line":2093,"code":"    it('should select only first option', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue', 'green', 'red');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onInput;\n        })\n      ).toEqual(['blue']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onChange;\n        })\n      ).toEqual(['blue']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw when select causes navigation","suites":["Page","Page.select"],"updatePoint":{"line":2109,"column":54},"line":2109,"code":"    it('should not throw when select causes navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.$eval('select', select => {\n        return select.addEventListener('input', () => {\n          return ((window as any).location = '/empty.html');\n        });\n      });\n      await Promise.all([\n        page.select('select', 'blue'),\n        page.waitForNavigation(),\n      ]);\n      expect(page.url()).toContain('empty.html');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should select multiple options","suites":["Page","Page.select"],"updatePoint":{"line":2124,"column":38},"line":2124,"code":"    it('should select multiple options', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => {\n        return (globalThis as any).makeMultiple();\n      });\n      await page.select('select', 'blue', 'green', 'red');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onInput;\n        })\n      ).toEqual(['blue', 'green', 'red']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onChange;\n        })\n      ).toEqual(['blue', 'green', 'red']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should respect event bubbling","suites":["Page","Page.select"],"updatePoint":{"line":2143,"column":37},"line":2143,"code":"    it('should respect event bubbling', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onBubblingInput;\n        })\n      ).toEqual(['blue']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onBubblingChange;\n        })\n      ).toEqual(['blue']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when element is not a <select>","suites":["Page","Page.select"],"updatePoint":{"line":2159,"column":51},"line":2159,"code":"    it('should throw when element is not a <select>', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('body', '').catch(error_ => {\n        return (error = error_);\n      });\n      expect(error.message).toContain('Element is not a <select> element.');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return [] on no matched values","suites":["Page","Page.select"],"updatePoint":{"line":2169,"column":45},"line":2169,"code":"    it('should return [] on no matched values', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select('select', '42', 'abc');\n      expect(result).toEqual([]);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return an array of matched values","suites":["Page","Page.select"],"updatePoint":{"line":2176,"column":48},"line":2176,"code":"    it('should return an array of matched values', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => {\n        return (globalThis as any).makeMultiple();\n      });\n      const result = await page.select('select', 'blue', 'black', 'magenta');\n      expect(\n        result.reduce((accumulator, current) => {\n          return ['blue', 'black', 'magenta'].includes(current) && accumulator;\n        }, true)\n      ).toEqual(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return an array of one element when multiple is not set","suites":["Page","Page.select"],"updatePoint":{"line":2190,"column":70},"line":2190,"code":"    it('should return an array of one element when multiple is not set', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select(\n        'select',\n        '42',\n        'blue',\n        'black',\n        'magenta'\n      );\n      expect(result.length).toEqual(1);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return [] on no values","suites":["Page","Page.select"],"updatePoint":{"line":2203,"column":37},"line":2203,"code":"    it('should return [] on no values', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      const result = await page.select('select');\n      expect(result).toEqual([]);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should deselect all options when passed no values for a multiple select","suites":["Page","Page.select"],"updatePoint":{"line":2210,"column":79},"line":2210,"code":"    it('should deselect all options when passed no values for a multiple select', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => {\n        return (globalThis as any).makeMultiple();\n      });\n      await page.select('select', 'blue', 'black', 'magenta');\n      await page.select('select');\n      expect(\n        await page.$eval('select', select => {\n          return Array.from((select as HTMLSelectElement).options).every(\n            option => {\n              return !option.selected;\n            }\n          );\n        })\n      ).toEqual(true);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should deselect all options when passed no values for a select without multiple","suites":["Page","Page.select"],"updatePoint":{"line":2229,"column":87},"line":2229,"code":"    it('should deselect all options when passed no values for a select without multiple', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.select('select', 'blue', 'black', 'magenta');\n      await page.select('select');\n      expect(\n        await page.$eval('select', select => {\n          return Array.from((select as HTMLSelectElement).options).filter(\n            option => {\n              return option.selected;\n            }\n          )[0]!.value;\n        })\n      ).toEqual('');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if passed in non-strings","suites":["Page","Page.select"],"updatePoint":{"line":2245,"column":45},"line":2245,"code":"    it('should throw if passed in non-strings', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<select><option value=\"12\"/></select>');\n      let error!: Error;\n      try {\n        // @ts-expect-error purposefully passing bad input\n        await page.select('select', 12);\n      } catch (error_) {\n        error = error_ as Error;\n      }\n      expect(error.message).toContain('Values must be strings');\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work when re-defining top-level Event class","suites":["Page","Page.select"],"updatePoint":{"line":2259,"column":58},"line":2259,"code":"    it('should work when re-defining top-level Event class', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/input/select.html');\n      await page.evaluate(() => {\n        // @ts-expect-error Expected.\n        return (window.Event = undefined);\n      });\n      await page.select('select', 'blue');\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onInput;\n        })\n      ).toEqual(['blue']);\n      expect(\n        await page.evaluate(() => {\n          return (globalThis as any).result.onChange;\n        })\n      ).toEqual(['blue']);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with window.close","suites":["Page","Page.Events.Close"],"updatePoint":{"line":2282,"column":37},"line":2282,"code":"    it('should work with window.close', async () => {\n      const {page, context} = getTestState();\n\n      const newPagePromise = new Promise<Page>(fulfill => {\n        return context.once('targetcreated', target => {\n          return fulfill(target.page());\n        });\n      });\n      await page.evaluate(() => {\n        return ((window as any)['newPage'] = window.open('about:blank'));\n      });\n      const newPage = await newPagePromise;\n      const closedPromise = new Promise(x => {\n        return newPage.on('close', x);\n      });\n      await page.evaluate(() => {\n        return (window as any)['newPage'].close();\n      });\n      await closedPromise;\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should work with page.close","suites":["Page","Page.Events.Close"],"updatePoint":{"line":2302,"column":35},"line":2302,"code":"    it('should work with page.close', async () => {\n      const {context} = getTestState();\n\n      const newPage = await context.newPage();\n      const closedPromise = new Promise(x => {\n        return newPage.on('close', x);\n      });\n      await newPage.close();\n      await closedPromise;\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the correct browser instance","suites":["Page","Page.browser"],"updatePoint":{"line":2315,"column":50},"line":2315,"code":"    it('should return the correct browser instance', async () => {\n      const {page, browser} = getTestState();\n\n      expect(page.browser()).toBe(browser);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the correct browser context instance","suites":["Page","Page.browserContext"],"updatePoint":{"line":2323,"column":58},"line":2323,"code":"    it('should return the correct browser context instance', async () => {\n      const {page, context} = getTestState();\n\n      expect(page.browserContext()).toBe(context);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should return the client instance","suites":["Page","Page.client"],"updatePoint":{"line":2331,"column":41},"line":2331,"code":"    it('should return the client instance', async () => {\n      const {page} = getTestState();\n      expect((page as CDPPage)._client()).toBeInstanceOf(CDPSession);\n    });","file":"src/page.spec.ts","skipped":false,"dir":"test"},{"name":"should proxy requests when configured","suites":["request proxy"],"updatePoint":{"line":111,"column":43},"line":111,"code":"  it('should proxy requests when configured', async () => {\n    const {puppeteer, defaultBrowserOptions, server} = getTestState();\n    const emptyPageUrl = getEmptyPageUrl(server);\n\n    browser = await puppeteer.launch({\n      ...defaultBrowserOptions,\n      args: [...defaultArgs, `--proxy-server=${proxyServerUrl}`],\n    });\n\n    const page = await browser.newPage();\n    const response = (await page.goto(emptyPageUrl))!;\n\n    expect(response.ok()).toBe(true);\n\n    expect(proxiedRequestUrls).toEqual([emptyPageUrl]);\n  });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should respect proxy bypass list","suites":["request proxy"],"updatePoint":{"line":128,"column":38},"line":128,"code":"  it('should respect proxy bypass list', async () => {\n    const {puppeteer, defaultBrowserOptions, server} = getTestState();\n    const emptyPageUrl = getEmptyPageUrl(server);\n\n    browser = await puppeteer.launch({\n      ...defaultBrowserOptions,\n      args: [\n        ...defaultArgs,\n        `--proxy-server=${proxyServerUrl}`,\n        `--proxy-bypass-list=${new URL(emptyPageUrl).host}`,\n      ],\n    });\n\n    const page = await browser.newPage();\n    const response = (await page.goto(emptyPageUrl))!;\n\n    expect(response.ok()).toBe(true);\n\n    expect(proxiedRequestUrls).toEqual([]);\n  });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should proxy requests when configured at browser level","suites":["request proxy","in incognito browser context"],"updatePoint":{"line":150,"column":62},"line":150,"code":"    it('should proxy requests when configured at browser level', async () => {\n      const {puppeteer, defaultBrowserOptions, server} = getTestState();\n      const emptyPageUrl = getEmptyPageUrl(server);\n\n      browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        args: [...defaultArgs, `--proxy-server=${proxyServerUrl}`],\n      });\n\n      const context = await browser.createIncognitoBrowserContext();\n      const page = await context.newPage();\n      const response = (await page.goto(emptyPageUrl))!;\n\n      expect(response.ok()).toBe(true);\n\n      expect(proxiedRequestUrls).toEqual([emptyPageUrl]);\n    });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should respect proxy bypass list when configured at browser level","suites":["request proxy","in incognito browser context"],"updatePoint":{"line":168,"column":73},"line":168,"code":"    it('should respect proxy bypass list when configured at browser level', async () => {\n      const {puppeteer, defaultBrowserOptions, server} = getTestState();\n      const emptyPageUrl = getEmptyPageUrl(server);\n\n      browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        args: [\n          ...defaultArgs,\n          `--proxy-server=${proxyServerUrl}`,\n          `--proxy-bypass-list=${new URL(emptyPageUrl).host}`,\n        ],\n      });\n\n      const context = await browser.createIncognitoBrowserContext();\n      const page = await context.newPage();\n      const response = (await page.goto(emptyPageUrl))!;\n\n      expect(response.ok()).toBe(true);\n\n      expect(proxiedRequestUrls).toEqual([]);\n    });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should proxy requests when configured at context level","suites":["request proxy","in incognito browser context"],"updatePoint":{"line":193,"column":62},"line":193,"code":"    it('should proxy requests when configured at context level', async () => {\n      const {puppeteer, defaultBrowserOptions, server} = getTestState();\n      const emptyPageUrl = getEmptyPageUrl(server);\n\n      browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        args: defaultArgs,\n      });\n\n      const context = await browser.createIncognitoBrowserContext({\n        proxyServer: proxyServerUrl,\n      });\n      const page = await context.newPage();\n      const response = (await page.goto(emptyPageUrl))!;\n\n      expect(response.ok()).toBe(true);\n\n      expect(proxiedRequestUrls).toEqual([emptyPageUrl]);\n    });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should respect proxy bypass list when configured at context level","suites":["request proxy","in incognito browser context"],"updatePoint":{"line":213,"column":73},"line":213,"code":"    it('should respect proxy bypass list when configured at context level', async () => {\n      const {puppeteer, defaultBrowserOptions, server} = getTestState();\n      const emptyPageUrl = getEmptyPageUrl(server);\n\n      browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        args: defaultArgs,\n      });\n\n      const context = await browser.createIncognitoBrowserContext({\n        proxyServer: proxyServerUrl,\n        proxyBypassList: [new URL(emptyPageUrl).host],\n      });\n      const page = await context.newPage();\n      const response = (await page.goto(emptyPageUrl))!;\n\n      expect(response.ok()).toBe(true);\n\n      expect(proxiedRequestUrls).toEqual([]);\n    });","file":"src/proxy.spec.ts","skipped":false,"dir":"test"},{"name":"should find first element in shadow","suites":["Query handler tests","Pierce selectors"],"updatePoint":{"line":47,"column":43},"line":47,"code":"    it('should find first element in shadow', async () => {\n      const {page} = getTestState();\n      const div = (await page.$('pierce/.foo')) as ElementHandle<HTMLElement>;\n      const text = await div.evaluate(element => {\n        return element.textContent;\n      });\n      expect(text).toBe('Hello');\n    });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find all elements in shadow","suites":["Query handler tests","Pierce selectors"],"updatePoint":{"line":55,"column":42},"line":55,"code":"    it('should find all elements in shadow', async () => {\n      const {page} = getTestState();\n      const divs = (await page.$$('pierce/.foo')) as Array<\n        ElementHandle<HTMLElement>\n      >;\n      const text = await Promise.all(\n        divs.map(div => {\n          return div.evaluate(element => {\n            return element.textContent;\n          });\n        })\n      );\n      expect(text.join(' ')).toBe('Hello World');\n    });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find first child element","suites":["Query handler tests","Pierce selectors"],"updatePoint":{"line":69,"column":39},"line":69,"code":"    it('should find first child element', async () => {\n      const {page} = getTestState();\n      const parentElement = (await page.$('html > div'))!;\n      const childElement = (await parentElement.$(\n        'pierce/div'\n      )) as ElementHandle<HTMLElement>;\n      const text = await childElement.evaluate(element => {\n        return element.textContent;\n      });\n      expect(text).toBe('Hello');\n    });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should find all child elements","suites":["Query handler tests","Pierce selectors"],"updatePoint":{"line":80,"column":38},"line":80,"code":"    it('should find all child elements', async () => {\n      const {page} = getTestState();\n      const parentElement = (await page.$('html > div'))!;\n      const childElements = (await parentElement.$$('pierce/div')) as Array<\n        ElementHandle<HTMLElement>\n      >;\n      const text = await Promise.all(\n        childElements.map(div => {\n          return div.evaluate(element => {\n            return element.textContent;\n          });\n        })\n      );\n      expect(text.join(' ')).toBe('Hello World');\n    });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":99,"column":39},"line":99,"code":"      it('should query existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<section>test</section>');\n\n        expect(await page.$('text/test')).toBeTruthy();\n        expect((await page.$$('text/test')).length).toBe(1);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing element","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":107,"column":60},"line":107,"code":"      it('should return empty array for non-existing element', async () => {\n        const {page} = getTestState();\n\n        expect(await page.$('text/test')).toBeFalsy();\n        expect((await page.$$('text/test')).length).toBe(0);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return first element","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":113,"column":37},"line":113,"code":"      it('should return first element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div id=\"1\">a</div><div>a</div>');\n\n        const element = await page.$('text/a');\n        expect(\n          await element?.evaluate(e => {\n            return e.id;\n          })\n        ).toBe('1');\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return multiple elements","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":125,"column":41},"line":125,"code":"      it('should return multiple elements', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div>a</div><div>a</div>');\n\n        const elements = await page.$$('text/a');\n        expect(elements.length).toBe(2);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should pierce shadow DOM","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":133,"column":34},"line":133,"code":"      it('should pierce shadow DOM', async () => {\n        const {page} = getTestState();\n\n        await page.evaluate(() => {\n          const div = document.createElement('div');\n          const shadow = div.attachShadow({mode: 'open'});\n          const diva = document.createElement('div');\n          shadow.append(diva);\n          const divb = document.createElement('div');\n          shadow.append(divb);\n          diva.innerHTML = 'a';\n          divb.innerHTML = 'b';\n          document.body.append(div);\n        });\n\n        const element = await page.$('text/a');\n        expect(\n          await element?.evaluate(e => {\n            return e.textContent;\n          })\n        ).toBe('a');\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query deeply nested text","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":155,"column":41},"line":155,"code":"      it('should query deeply nested text', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div><div>a</div><div>b</div></div>');\n\n        const element = await page.$('text/a');\n        expect(\n          await element?.evaluate(e => {\n            return e.textContent;\n          })\n        ).toBe('a');\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query inputs","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":167,"column":29},"line":167,"code":"      it('should query inputs', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<input value=\"a\">');\n\n        const element = (await page.$(\n          'text/a'\n        )) as ElementHandle<HTMLInputElement>;\n        expect(\n          await element?.evaluate(e => {\n            return e.value;\n          })\n        ).toBe('a');\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should not query radio","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":181,"column":32},"line":181,"code":"      it('should not query radio', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<radio value=\"a\">');\n\n        expect(await page.$('text/a')).toBeNull();\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query text spanning multiple elements","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":188,"column":54},"line":188,"code":"      it('should query text spanning multiple elements', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div><span>a</span> <span>b</span><div>');\n\n        const element = await page.$('text/a b');\n        expect(\n          await element?.evaluate(e => {\n            return e.textContent;\n          })\n        ).toBe('a b');\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should clear caches","suites":["Query handler tests","Text selectors","in Page"],"updatePoint":{"line":200,"column":29},"line":200,"code":"      it('should clear caches', async () => {\n        const {page} = getTestState();\n\n        await page.setContent(\n          '<div id=target1>text</div><input id=target2 value=text><div id=target3>text</div>'\n        );\n        const div = (await page.$('#target1')) as ElementHandle<HTMLDivElement>;\n        const input = (await page.$(\n          '#target2'\n        )) as ElementHandle<HTMLInputElement>;\n\n        await div.evaluate(div => {\n          div.textContent = 'text';\n        });\n        expect(\n          await page.$eval(`text/text`, e => {\n            return e.id;\n          })\n        ).toBe('target1');\n        await div.evaluate(div => {\n          div.textContent = 'foo';\n        });\n        expect(\n          await page.$eval(`text/text`, e => {\n            return e.id;\n          })\n        ).toBe('target2');\n        await input.evaluate(input => {\n          input.value = '';\n        });\n        await input.type('foo');\n        expect(\n          await page.$eval(`text/text`, e => {\n            return e.id;\n          })\n        ).toBe('target3');\n\n        await div.evaluate(div => {\n          div.textContent = 'text';\n        });\n        await input.evaluate(input => {\n          input.value = '';\n        });\n        await input.type('text');\n        expect(\n          await page.$$eval(`text/text`, es => {\n            return es.length;\n          })\n        ).toBe(3);\n        await div.evaluate(div => {\n          div.textContent = 'foo';\n        });\n        expect(\n          await page.$$eval(`text/text`, es => {\n            return es.length;\n          })\n        ).toBe(2);\n        await input.evaluate(input => {\n          input.value = '';\n        });\n        await input.type('foo');\n        expect(\n          await page.$$eval(`text/text`, es => {\n            return es.length;\n          })\n        ).toBe(1);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["Query handler tests","Text selectors","in ElementHandles"],"updatePoint":{"line":269,"column":39},"line":269,"code":"      it('should query existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div class=\"a\"><span>a</span></div>');\n\n        const elementHandle = (await page.$('div'))!;\n        expect(await elementHandle.$(`text/a`)).toBeTruthy();\n        expect((await elementHandle.$$(`text/a`)).length).toBe(1);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["Query handler tests","Text selectors","in ElementHandles"],"updatePoint":{"line":279,"column":53},"line":279,"code":"      it('should return null for non-existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div class=\"a\"></div>');\n\n        const elementHandle = (await page.$('div'))!;\n        expect(await elementHandle.$(`text/a`)).toBeFalsy();\n        expect((await elementHandle.$$(`text/a`)).length).toBe(0);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["Query handler tests","XPath selectors","in Page"],"updatePoint":{"line":293,"column":39},"line":293,"code":"      it('should query existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<section>test</section>');\n\n        expect(await page.$('xpath/html/body/section')).toBeTruthy();\n        expect((await page.$$('xpath/html/body/section')).length).toBe(1);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing element","suites":["Query handler tests","XPath selectors","in Page"],"updatePoint":{"line":301,"column":60},"line":301,"code":"      it('should return empty array for non-existing element', async () => {\n        const {page} = getTestState();\n\n        expect(\n          await page.$('xpath/html/body/non-existing-element')\n        ).toBeFalsy();\n        expect(\n          (await page.$$('xpath/html/body/non-existing-element')).length\n        ).toBe(0);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return first element","suites":["Query handler tests","XPath selectors","in Page"],"updatePoint":{"line":311,"column":37},"line":311,"code":"      it('should return first element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div>a</div><div></div>');\n\n        const element = await page.$('xpath/html/body/div');\n        expect(\n          await element?.evaluate(e => {\n            return e.textContent === 'a';\n          })\n        ).toBeTruthy();\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return multiple elements","suites":["Query handler tests","XPath selectors","in Page"],"updatePoint":{"line":323,"column":41},"line":323,"code":"      it('should return multiple elements', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div></div><div></div>');\n\n        const elements = await page.$$('xpath/html/body/div');\n        expect(elements.length).toBe(2);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["Query handler tests","XPath selectors","in ElementHandles"],"updatePoint":{"line":333,"column":39},"line":333,"code":"      it('should query existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div class=\"a\">a<span></span></div>');\n\n        const elementHandle = (await page.$('div'))!;\n        expect(await elementHandle.$(`xpath/span`)).toBeTruthy();\n        expect((await elementHandle.$$(`xpath/span`)).length).toBe(1);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["Query handler tests","XPath selectors","in ElementHandles"],"updatePoint":{"line":343,"column":53},"line":343,"code":"      it('should return null for non-existing element', async () => {\n        const {page} = getTestState();\n\n        await page.setContent('<div class=\"a\">a</div>');\n\n        const elementHandle = (await page.$('div'))!;\n        expect(await elementHandle.$(`xpath/span`)).toBeFalsy();\n        expect((await elementHandle.$$(`xpath/span`)).length).toBe(0);\n      });","file":"src/queryhandler.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","Page.$eval"],"updatePoint":{"line":29,"column":19},"line":29,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section id=\"testAttribute\">43543</section>');\n      const idAttribute = await page.$eval('section', e => {\n        return e.id;\n      });\n      expect(idAttribute).toBe('testAttribute');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept arguments","suites":["querySelector","Page.$eval"],"updatePoint":{"line":38,"column":31},"line":38,"code":"    it('should accept arguments', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>hello</section>');\n      const text = await page.$eval(\n        'section',\n        (e, suffix) => {\n          return e.textContent! + suffix;\n        },\n        ' world!'\n      );\n      expect(text).toBe('hello world!');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandles as arguments","suites":["querySelector","Page.$eval"],"updatePoint":{"line":51,"column":49},"line":51,"code":"    it('should accept ElementHandles as arguments', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>hello</section><div> world</div>');\n      const divHandle = (await page.$('div'))!;\n      const text = await page.$eval(\n        'section',\n        (e, div) => {\n          return e.textContent! + (div as HTMLElement).textContent!;\n        },\n        divHandle\n      );\n      expect(text).toBe('hello world');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error if no element is found","suites":["querySelector","Page.$eval"],"updatePoint":{"line":65,"column":49},"line":65,"code":"    it('should throw error if no element is found', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .$eval('section', e => {\n          return e.id;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error.message).toContain(\n        'failed to find element matching selector \"section\"'\n      );\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":86,"column":19},"line":86,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCount = await page.$$eval('div', divs => {\n        return divs.length;\n      });\n      expect(divsCount).toBe(3);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept extra arguments","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":97,"column":37},"line":97,"code":"    it('should accept extra arguments', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCountPlus5 = await page.$$eval(\n        'div',\n        (divs, two, three) => {\n          return divs.length + (two as number) + (three as number);\n        },\n        2,\n        3\n      );\n      expect(divsCountPlus5).toBe(8);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandles as arguments","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":112,"column":49},"line":112,"code":"    it('should accept ElementHandles as arguments', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<section>2</section><section>2</section><section>1</section><div>3</div>'\n      );\n      const divHandle = (await page.$('div'))!;\n      const sum = await page.$$eval(\n        'section',\n        (sections, div) => {\n          return (\n            sections.reduce((acc, section) => {\n              return acc + Number(section.textContent);\n            }, 0) + Number((div as HTMLElement).textContent)\n          );\n        },\n        divHandle\n      );\n      expect(sum).toBe(8);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should handle many elements","suites":["querySelector","Page.$$eval"],"updatePoint":{"line":131,"column":35},"line":131,"code":"    it('should handle many elements', async () => {\n      const {page} = getTestState();\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 1000; i++) {\n            const section = document.createElement('section');\n            section.textContent = i;\n            document.body.appendChild(section);\n        }\n        `\n      );\n      const sum = await page.$$eval('section', sections => {\n        return sections.reduce((acc, section) => {\n          return acc + Number(section.textContent);\n        }, 0);\n      });\n      expect(sum).toBe(500500);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","Page.$"],"updatePoint":{"line":152,"column":37},"line":152,"code":"    it('should query existing element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>test</section>');\n      const element = (await page.$('section'))!;\n      expect(element).toBeTruthy();\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","Page.$"],"updatePoint":{"line":159,"column":51},"line":159,"code":"    it('should return null for non-existing element', async () => {\n      const {page} = getTestState();\n\n      const element = (await page.$('non-existing-element'))!;\n      expect(element).toBe(null);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing elements","suites":["querySelector","Page.$$"],"updatePoint":{"line":168,"column":38},"line":168,"code":"    it('should query existing elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div>A</div><br/><div>B</div>');\n      const elements = await page.$$('div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map(element => {\n        return page.evaluate((e: HTMLElement) => {\n          return e.textContent;\n        }, element);\n      });\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array if nothing is found","suites":["querySelector","Page.$$"],"updatePoint":{"line":181,"column":53},"line":181,"code":"    it('should return empty array if nothing is found', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const elements = await page.$$('div');\n      expect(elements.length).toBe(0);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","Page.$x"],"updatePoint":{"line":191,"column":37},"line":191,"code":"    it('should query existing element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<section>test</section>');\n      const elements = await page.$x('/html/body/section');\n      expect(elements[0]!).toBeTruthy();\n      expect(elements.length).toBe(1);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing element","suites":["querySelector","Page.$x"],"updatePoint":{"line":199,"column":58},"line":199,"code":"    it('should return empty array for non-existing element', async () => {\n      const {page} = getTestState();\n\n      const element = await page.$x('/html/body/non-existing-element');\n      expect(element).toEqual([]);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return multiple elements","suites":["querySelector","Page.$x"],"updatePoint":{"line":205,"column":39},"line":205,"code":"    it('should return multiple elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div></div><div></div>');\n      const elements = await page.$x('/html/body/div');\n      expect(elements.length).toBe(2);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","ElementHandle.$"],"updatePoint":{"line":215,"column":37},"line":215,"code":"    it('should query existing element', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/playground.html');\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">A</div></div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const second = (await html.$('.second'))!;\n      const inner = await second.$('.inner');\n      const content = await page.evaluate(e => {\n        return e?.textContent;\n      }, inner);\n      expect(content).toBe('A');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","ElementHandle.$"],"updatePoint":{"line":231,"column":51},"line":231,"code":"    it('should return null for non-existing element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">B</div></div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const second = await html.$('.third');\n      expect(second).toBe(null);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":243,"column":19},"line":243,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"tweet\"><div class=\"like\">100</div><div class=\"retweets\">10</div></div></body></html>'\n      );\n      const tweet = (await page.$('.tweet'))!;\n      const content = await tweet.$eval('.like', node => {\n        return (node as HTMLElement).innerText;\n      });\n      expect(content).toBe('100');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should retrieve content from subtree","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":256,"column":44},"line":256,"code":"    it('should retrieve content from subtree', async () => {\n      const {page} = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"><div class=\"a\">a-child-div</div></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = (await page.$('#myId'))!;\n      const content = await elementHandle.$eval('.a', node => {\n        return (node as HTMLElement).innerText;\n      });\n      expect(content).toBe('a-child-div');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should throw in case of missing selector","suites":["querySelector","ElementHandle.$eval"],"updatePoint":{"line":269,"column":48},"line":269,"code":"    it('should throw in case of missing selector', async () => {\n      const {page} = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = (await page.$('#myId'))!;\n      const errorMessage = await elementHandle\n        .$eval('.a', node => {\n          return (node as HTMLElement).innerText;\n        })\n        .catch(error => {\n          return error.message;\n        });\n      expect(errorMessage).toBe(\n        `Error: failed to find element matching selector \".a\"`\n      );\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":289,"column":19},"line":289,"code":"    it('should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"tweet\"><div class=\"like\">100</div><div class=\"like\">10</div></div></body></html>'\n      );\n      const tweet = (await page.$('.tweet'))!;\n      const content = await tweet.$$eval('.like', nodes => {\n        return (nodes as HTMLElement[]).map(n => {\n          return n.innerText;\n        });\n      });\n      expect(content).toEqual(['100', '10']);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should retrieve content from subtree","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":304,"column":44},"line":304,"code":"    it('should retrieve content from subtree', async () => {\n      const {page} = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"><div class=\"a\">a1-child-div</div><div class=\"a\">a2-child-div</div></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = (await page.$('#myId'))!;\n      const content = await elementHandle.$$eval('.a', nodes => {\n        return (nodes as HTMLElement[]).map(n => {\n          return n.innerText;\n        });\n      });\n      expect(content).toEqual(['a1-child-div', 'a2-child-div']);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw in case of missing selector","suites":["querySelector","ElementHandle.$$eval"],"updatePoint":{"line":319,"column":52},"line":319,"code":"    it('should not throw in case of missing selector', async () => {\n      const {page} = getTestState();\n\n      const htmlContent =\n        '<div class=\"a\">not-a-child-div</div><div id=\"myId\"></div>';\n      await page.setContent(htmlContent);\n      const elementHandle = (await page.$('#myId'))!;\n      const nodesLength = await elementHandle.$$eval('.a', nodes => {\n        return nodes.length;\n      });\n      expect(nodesLength).toBe(0);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing elements","suites":["querySelector","ElementHandle.$$"],"updatePoint":{"line":334,"column":38},"line":334,"code":"    it('should query existing elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div>A</div><br/><div>B</div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const elements = await html.$$('div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map(element => {\n        return page.evaluate((e: HTMLElement) => {\n          return e.textContent;\n        }, element);\n      });\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array for non-existing elements","suites":["querySelector","ElementHandle.$$"],"updatePoint":{"line":351,"column":59},"line":351,"code":"    it('should return empty array for non-existing elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><span>A</span><br/><span>B</span></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const elements = await html.$$('div');\n      expect(elements.length).toBe(0);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should query existing element","suites":["querySelector","ElementHandle.$x"],"updatePoint":{"line":364,"column":37},"line":364,"code":"    it('should query existing element', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.PREFIX + '/playground.html');\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">A</div></div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const second = await html.$x(`./body/div[contains(@class, 'second')]`);\n      const inner = await second[0]!.$x(`./div[contains(@class, 'inner')]`);\n      const content = await page.evaluate(e => {\n        return e.textContent;\n      }, inner[0]!);\n      expect(content).toBe('A');\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should return null for non-existing element","suites":["querySelector","ElementHandle.$x"],"updatePoint":{"line":380,"column":51},"line":380,"code":"    it('should return null for non-existing element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div class=\"second\"><div class=\"inner\">B</div></div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const second = await html.$x(`/div[contains(@class, 'third')]`);\n      expect(second).toEqual([]);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should have registered handler","suites":["querySelector","QueryAll"],"updatePoint":{"line":404,"column":38},"line":404,"code":"    it('should have registered handler', async () => {\n      expect(\n        Puppeteer.customQueryHandlerNames().includes('allArray')\n      ).toBeTruthy();\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$ should query existing elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":409,"column":41},"line":409,"code":"    it('$$ should query existing elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><div>A</div><br/><div>B</div></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const elements = await html.$$('allArray/div');\n      expect(elements.length).toBe(2);\n      const promises = elements.map(element => {\n        return page.evaluate(e => {\n          return e.textContent;\n        }, element);\n      });\n      expect(await Promise.all(promises)).toEqual(['A', 'B']);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$ should return empty array for non-existing elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":426,"column":62},"line":426,"code":"    it('$$ should return empty array for non-existing elements', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<html><body><span>A</span><br/><span>B</span></body></html>'\n      );\n      const html = (await page.$('html'))!;\n      const elements = await html.$$('allArray/div');\n      expect(elements.length).toBe(0);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should work","suites":["querySelector","QueryAll"],"updatePoint":{"line":436,"column":26},"line":436,"code":"    it('$$eval should work', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCount = await page.$$eval('allArray/div', divs => {\n        return divs.length;\n      });\n      expect(divsCount).toBe(3);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should accept extra arguments","suites":["querySelector","QueryAll"],"updatePoint":{"line":447,"column":44},"line":447,"code":"    it('$$eval should accept extra arguments', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<div>hello</div><div>beautiful</div><div>world!</div>'\n      );\n      const divsCountPlus5 = await page.$$eval(\n        'allArray/div',\n        (divs, two, three) => {\n          return divs.length + (two as number) + (three as number);\n        },\n        2,\n        3\n      );\n      expect(divsCountPlus5).toBe(8);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should accept ElementHandles as arguments","suites":["querySelector","QueryAll"],"updatePoint":{"line":462,"column":56},"line":462,"code":"    it('$$eval should accept ElementHandles as arguments', async () => {\n      const {page} = getTestState();\n      await page.setContent(\n        '<section>2</section><section>2</section><section>1</section><div>3</div>'\n      );\n      const divHandle = (await page.$('div'))!;\n      const sum = await page.$$eval(\n        'allArray/section',\n        (sections, div) => {\n          return (\n            sections.reduce((acc, section) => {\n              return acc + Number(section.textContent);\n            }, 0) + Number((div as HTMLElement).textContent)\n          );\n        },\n        divHandle\n      );\n      expect(sum).toBe(8);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"$$eval should handle many elements","suites":["querySelector","QueryAll"],"updatePoint":{"line":481,"column":42},"line":481,"code":"    it('$$eval should handle many elements', async () => {\n      const {page} = getTestState();\n      await page.evaluate(\n        `\n        for (var i = 0; i <= 1000; i++) {\n            const section = document.createElement('section');\n            section.textContent = i;\n            document.body.appendChild(section);\n        }\n        `\n      );\n      const sum = await page.$$eval('allArray/section', sections => {\n        return sections.reduce((acc, section) => {\n          return acc + Number(section.textContent);\n        }, 0);\n      });\n      expect(sum).toBe(500500);\n    });","file":"src/queryselector.spec.ts","skipped":false,"dir":"test"},{"name":"should cooperatively  by priority","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":40,"column":60},"line":40,"code":"      it(`should cooperatively ${expectedAction} by priority`, async () => {\n        const {page, server} = getTestState();\n\n        const actionResults: ActionResult[] = [];\n        await page.setRequestInterception(true);\n        page.on('request', request => {\n          if (request.url().endsWith('.css')) {\n            request.continue(\n              {headers: {...request.headers(), xaction: 'continue'}},\n              expectedAction === 'continue' ? 1 : 0\n            );\n          } else {\n            request.continue({}, 0);\n          }\n        });\n        page.on('request', request => {\n          if (request.url().endsWith('.css')) {\n            request.respond(\n              {headers: {xaction: 'respond'}},\n              expectedAction === 'respond' ? 1 : 0\n            );\n          } else {\n            request.continue({}, 0);\n          }\n        });\n        page.on('request', request => {\n          if (request.url().endsWith('.css')) {\n            request.abort('aborted', expectedAction === 'abort' ? 1 : 0);\n          } else {\n            request.continue({}, 0);\n          }\n        });\n        page.on('response', response => {\n          const {xaction} = response!.headers();\n          if (response!.url().endsWith('.css') && !!xaction) {\n            actionResults.push(xaction as ActionResult);\n          }\n        });\n        page.on('requestfailed', request => {\n          if (request.url().endsWith('.css')) {\n            actionResults.push('abort');\n          }\n        });\n\n        const response = (await (async () => {\n          if (expectedAction === 'continue') {\n            const [serverRequest, response] = await Promise.all([\n              server.waitForRequest('/one-style.css'),\n              page.goto(server.PREFIX + '/one-style.html'),\n            ]);\n            actionResults.push(\n              serverRequest.headers['xaction'] as ActionResult\n            );\n            return response;\n          } else {\n            return await page.goto(server.PREFIX + '/one-style.html');\n          }\n        })())!;\n\n        expect(actionResults.length).toBe(1);\n        expect(actionResults[0]!).toBe(expectedAction);\n        expect(response!.ok()).toBe(true);\n      });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should intercept","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":105,"column":24},"line":105,"code":"    it('should intercept', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (utils.isFavicon(request)) {\n          request.continue({}, 0);\n          return;\n        }\n        expect(request.url()).toContain('empty.html');\n        expect(request.headers()['user-agent']).toBeTruthy();\n        expect(request.method()).toBe('GET');\n        expect(request.postData()).toBe(undefined);\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.resourceType()).toBe('document');\n        expect(request.frame() === page.mainFrame()).toBe(true);\n        expect(request.frame()!.url()).toBe('about:blank');\n        request.continue({}, 0);\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response!.ok()).toBe(true);\n      expect(response!.remoteAddress().port).toBe(server.PORT);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work when POST is redirected with 302","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":129,"column":52},"line":129,"code":"    it('should work when POST is redirected with 302', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/rredirect', '/empty.html');\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      await page.setContent(`\n        <form action='/rredirect' method='post'>\n          <input type=\"hidden\" id=\"foo\" name=\"foo\" value=\"FOOBAR\">\n        </form>\n      `);\n      await Promise.all([\n        page.$eval('form', form => {\n          return (form as HTMLFormElement).submit();\n        }),\n        page.waitForNavigation(),\n      ]);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work when header manipulation headers with redirect","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":151,"column":66},"line":151,"code":"    it('should work when header manipulation headers with redirect', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/rrredirect', '/empty.html');\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n        });\n        request.continue({headers}, 0);\n\n        expect(request.continueRequestOverrides()).toEqual({headers});\n      });\n      // Make sure that the goto does not time out.\n      await page.goto(server.PREFIX + '/rrredirect');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to remove headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":168,"column":40},"line":168,"code":"    it('should be able to remove headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n          origin: undefined, // remove \"origin\" header\n        });\n        request.continue({headers}, 0);\n      });\n\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.PREFIX + '/empty.html'),\n      ]);\n\n      expect(serverRequest.headers.origin).toBe(undefined);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should contain referer header","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":187,"column":37},"line":187,"code":"    it('should contain referer header', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        if (!utils.isFavicon(request)) {\n          requests.push(request);\n        }\n        request.continue({}, 0);\n      });\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(requests[1]!.url()).toContain('/one-style.css');\n      expect(requests[1]!.headers()['referer']).toContain('/one-style.html');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should properly return navigation response when URL has cookies","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":202,"column":71},"line":202,"code":"    it('should properly return navigation response when URL has cookies', async () => {\n      const {page, server} = getTestState();\n\n      // Setup cookie.\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({name: 'foo', value: 'bar'});\n\n      // Setup request interception.\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      const response = await page.reload();\n      expect(response!.status()).toBe(200);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should stop intercepting","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":217,"column":32},"line":217,"code":"    it('should stop intercepting', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.once('request', request => {\n        return request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(false);\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should show custom HTTP headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":228,"column":39},"line":228,"code":"    it('should show custom HTTP headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        expect(request.headers()['foo']).toBe('bar');\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response!.ok()).toBe(true);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirect inside sync XHR","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":243,"column":49},"line":243,"code":"    it('should work with redirect inside sync XHR', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      server.setRedirect('/logo.png', '/pptr.png');\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      const status = await page.evaluate(async () => {\n        const request = new XMLHttpRequest();\n        request.open('GET', '/logo.png', false); // `false` makes the request synchronous\n        request.send(null);\n        return request.status;\n      });\n      expect(status).toBe(200);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with custom referer headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":260,"column":47},"line":260,"code":"    it('should work with custom referer headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({referer: server.EMPTY_PAGE});\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        expect(request.headers()['referer']).toBe(server.EMPTY_PAGE);\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response!.ok()).toBe(true);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":272,"column":27},"line":272,"code":"    it('should be abortable', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (request.url().endsWith('.css')) {\n          request.abort('failed', 0);\n        } else {\n          request.continue({}, 0);\n        }\n      });\n      let failedRequests = 0;\n      page.on('requestfailed', () => {\n        return ++failedRequests;\n      });\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response!.ok()).toBe(true);\n      expect(response!.request().failure()).toBe(null);\n      expect(failedRequests).toBe(1);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to access the error reason","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":292,"column":49},"line":292,"code":"    it('should be able to access the error reason', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.abort('failed', 0);\n      });\n      let abortReason = null;\n      page.on('request', request => {\n        abortReason = request.abortErrorReason();\n        request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(abortReason).toBe('Failed');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable with custom error codes","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":307,"column":51},"line":307,"code":"    it('should be abortable with custom error codes', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.abort('internetdisconnected', 0);\n      });\n      let failedRequest!: HTTPRequest;\n      page.on('requestfailed', request => {\n        return (failedRequest = request);\n      });\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(failedRequest).toBeTruthy();\n      expect(failedRequest.failure()!.errorText).toBe(\n        'net::ERR_INTERNET_DISCONNECTED'\n      );\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":324,"column":27},"line":324,"code":"    it('should send referer', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        referer: 'http://google.com/',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        page.goto(server.PREFIX + '/grid.html'),\n      ]);\n      expect(request.headers['referer']).toBe('http://google.com/');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should fail navigation when aborting main resource","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":340,"column":58},"line":340,"code":"    it('should fail navigation when aborting main resource', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.abort('failed', 0);\n      });\n      let error!: Error;\n      await page.goto(server.EMPTY_PAGE).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeTruthy();\n      if (isChrome) {\n        expect(error.message).toContain('net::ERR_FAILED');\n      } else {\n        expect(error.message).toContain('NS_ERROR_FAILURE');\n      }\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":358,"column":34},"line":358,"code":"    it('should work with redirects', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue({}, 0);\n        requests.push(request);\n      });\n      server.setRedirect(\n        '/non-existing-page.html',\n        '/non-existing-page-2.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-2.html',\n        '/non-existing-page-3.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-3.html',\n        '/non-existing-page-4.html'\n      );\n      server.setRedirect('/non-existing-page-4.html', '/empty.html');\n      const response = await page.goto(\n        server.PREFIX + '/non-existing-page.html'\n      );\n      expect(response!.status()).toBe(200);\n      expect(response!.url()).toContain('empty.html');\n      expect(requests.length).toBe(5);\n      expect(requests[2]!.resourceType()).toBe('document');\n      // Check redirect chain\n      const redirectChain = response!.request().redirectChain();\n      expect(redirectChain.length).toBe(4);\n      expect(redirectChain[0]!.url()).toContain('/non-existing-page.html');\n      expect(redirectChain[2]!.url()).toContain('/non-existing-page-3.html');\n      for (let i = 0; i < redirectChain.length; ++i) {\n        const request = redirectChain[i]!;\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.redirectChain().indexOf(request)).toBe(i);\n      }\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects for subresources","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":398,"column":51},"line":398,"code":"    it('should work with redirects for subresources', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue({}, 0);\n        if (!utils.isFavicon(request)) {\n          requests.push(request);\n        }\n      });\n      server.setRedirect('/one-style.css', '/two-style.css');\n      server.setRedirect('/two-style.css', '/three-style.css');\n      server.setRedirect('/three-style.css', '/four-style.css');\n      server.setRoute('/four-style.css', (_req, res) => {\n        return res.end('body {box-sizing: border-box; }');\n      });\n\n      const response = await page.goto(server.PREFIX + '/one-style.html');\n      expect(response!.status()).toBe(200);\n      expect(response!.url()).toContain('one-style.html');\n      expect(requests.length).toBe(5);\n      expect(requests[0]!.resourceType()).toBe('document');\n      expect(requests[1]!.resourceType()).toBe('stylesheet');\n      // Check redirect chain\n      const redirectChain = requests[1]!.redirectChain();\n      expect(redirectChain.length).toBe(3);\n      expect(redirectChain[0]!.url()).toContain('/one-style.css');\n      expect(redirectChain[2]!.url()).toContain('/three-style.css');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to abort redirects","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":428,"column":41},"line":428,"code":"    it('should be able to abort redirects', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRedirect('/non-existing.json', '/non-existing-2.json');\n      server.setRedirect('/non-existing-2.json', '/simple.html');\n      page.on('request', request => {\n        if (request.url().includes('non-existing-2')) {\n          request.abort('failed', 0);\n        } else {\n          request.continue({}, 0);\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async () => {\n        try {\n          return await fetch('/non-existing.json');\n        } catch (error) {\n          return (error as Error).message;\n        }\n      });\n      if (isChrome) {\n        expect(result).toContain('Failed to fetch');\n      } else {\n        expect(result).toContain('NetworkError');\n      }\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with equal requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":455,"column":39},"line":455,"code":"    it('should work with equal requests', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let responseCount = 1;\n      server.setRoute('/zzz', (_req, res) => {\n        return res.end(responseCount++ * 11 + '');\n      });\n      await page.setRequestInterception(true);\n\n      let spinner = false;\n      // Cancel 2nd request.\n      page.on('request', request => {\n        if (utils.isFavicon(request)) {\n          request.continue({}, 0);\n          return;\n        }\n        spinner ? request.abort('failed', 0) : request.continue({}, 0);\n        spinner = !spinner;\n      });\n      const results = await page.evaluate(() => {\n        return Promise.all([\n          fetch('/zzz')\n            .then(response => {\n              return response!.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n          fetch('/zzz')\n            .then(response => {\n              return response!.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n          fetch('/zzz')\n            .then(response => {\n              return response!.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n        ]);\n      });\n      expect(results).toEqual(['11', 'FAILED', '22']);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to dataURL and fire dataURL requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":502,"column":60},"line":502,"code":"    it('should navigate to dataURL and fire dataURL requests', async () => {\n      const {page} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        requests.push(request);\n        request.continue({}, 0);\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const response = await page.goto(dataURL);\n      expect(response!.status()).toBe(200);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(dataURL);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to fetch dataURL and fire dataURL requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":517,"column":65},"line":517,"code":"    it('should be able to fetch dataURL and fire dataURL requests', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        !utils.isFavicon(request) && requests.push(request);\n        request.continue({}, 0);\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const text = await page.evaluate((url: string) => {\n        return fetch(url).then(r => {\n          return r.text();\n        });\n      }, dataURL);\n      expect(text).toBe('<div>yo</div>');\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(dataURL);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to URL with hash and fire requests without hash","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":537,"column":71},"line":537,"code":"    it('should navigate to URL with hash and fire requests without hash', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        requests.push(request);\n        request.continue({}, 0);\n      });\n      const response = await page.goto(server.EMPTY_PAGE + '#hash');\n      expect(response!.status()).toBe(200);\n      expect(response!.url()).toBe(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":552,"column":39},"line":552,"code":"    it('should work with encoded server', async () => {\n      const {page, server} = getTestState();\n\n      // The requestWillBeSent will report encoded URL, whereas interception will\n      // report URL as-is. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      const response = await page.goto(\n        server.PREFIX + '/some nonexisting page'\n      );\n      expect(response!.status()).toBe(404);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with badly encoded server","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":566,"column":45},"line":566,"code":"    it('should work with badly encoded server', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRoute('/malformed?rnd=%911', (_req, res) => {\n        return res.end();\n      });\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      const response = await page.goto(server.PREFIX + '/malformed?rnd=%911');\n      expect(response!.status()).toBe(200);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server - 2","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":579,"column":43},"line":579,"code":"    it('should work with encoded server - 2', async () => {\n      const {page, server} = getTestState();\n\n      // The requestWillBeSent will report URL as-is, whereas interception will\n      // report encoded URL for stylesheet. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue({}, 0);\n        requests.push(request);\n      });\n      const response = await page.goto(\n        `data:text/html,<link rel=\"stylesheet\" href=\"${server.PREFIX}/fonts?helvetica|arial\"/>`\n      );\n      expect(response!.status()).toBe(200);\n      expect(requests.length).toBe(2);\n      expect(requests[1]!.response()!.status()).toBe(404);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw \"Invalid Interception Id\" if the request was cancelled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":597,"column":79},"line":597,"code":"    it('should not throw \"Invalid Interception Id\" if the request was cancelled', async () => {\n      const {page, server} = getTestState();\n\n      await page.setContent('<iframe></iframe>');\n      await page.setRequestInterception(true);\n      let request!: HTTPRequest;\n      page.on('request', async r => {\n        return (request = r);\n      });\n      page.$eval(\n        'iframe',\n        (frame, url) => {\n          return ((frame as HTMLIFrameElement).src = url as string);\n        },\n        server.EMPTY_PAGE\n      ),\n        // Wait for request interception.\n        await utils.waitEvent(page, 'request');\n      // Delete frame to cause request to be canceled.\n      await page.$eval('iframe', frame => {\n        return frame.remove();\n      });\n      let error!: Error;\n      await request.continue({}, 0).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeUndefined();\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if interception is not enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":625,"column":51},"line":625,"code":"    it('should throw if interception is not enabled', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      page.on('request', async request => {\n        try {\n          await request.continue({}, 0);\n        } catch (error_) {\n          error = error_ as Error;\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(error.message).toContain('Request Interception is not enabled');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with file URLs","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":639,"column":34},"line":639,"code":"    it('should work with file URLs', async () => {\n      const {page} = getTestState();\n\n      await page.setRequestInterception(true);\n      const urls = new Set();\n      page.on('request', request => {\n        urls.add(request.url().split('/').pop());\n        request.continue({}, 0);\n      });\n      await page.goto(\n        pathToFileURL(path.join(__dirname, '../assets', 'one-style.html'))\n      );\n      expect(urls.size).toBe(2);\n      expect(urls.has('one-style.html')).toBe(true);\n      expect(urls.has('one-style.css')).toBe(true);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should not cache if cache disabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":655,"column":42},"line":655,"code":"    it('should not cache if cache disabled', async () => {\n      const {page, server} = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(false);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n\n      const cached = [];\n      page.on('requestservedfromcache', r => {\n        return cached.push(r);\n      });\n\n      await page.reload();\n      expect(cached.length).toBe(0);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should cache if cache enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":675,"column":37},"line":675,"code":"    it('should cache if cache enabled', async () => {\n      const {page, server} = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n\n      const cached = [];\n      page.on('requestservedfromcache', r => {\n        return cached.push(r);\n      });\n\n      await page.reload();\n      expect(cached.length).toBe(1);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should load fonts if cache enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":695,"column":42},"line":695,"code":"    it('should load fonts if cache enabled', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n\n      await page.goto(server.PREFIX + '/cached/one-style-font.html');\n      await page.waitForResponse(r => {\n        return r.url().endsWith('/one-style.woff');\n      });\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception","Request.continue"],"updatePoint":{"line":712,"column":19},"line":712,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend HTTP headers","suites":["request interception","Request.continue"],"updatePoint":{"line":721,"column":33},"line":721,"code":"    it('should amend HTTP headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers());\n        headers['FOO'] = 'bar';\n        request.continue({headers}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz');\n        }),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect in a way non-observable to page","suites":["request interception","Request.continue"],"updatePoint":{"line":739,"column":55},"line":739,"code":"    it('should redirect in a way non-observable to page', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const redirectURL = request.url().includes('/empty.html')\n          ? server.PREFIX + '/consolelog.html'\n          : undefined;\n        request.continue({url: redirectURL}, 0);\n      });\n      let consoleMessage!: ConsoleMessage;\n      page.on('console', msg => {\n        return (consoleMessage = msg);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      expect(consoleMessage.text()).toBe('yellow');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend method","suites":["request interception","Request.continue"],"updatePoint":{"line":757,"column":27},"line":757,"code":"    it('should amend method', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({method: 'POST'}, 0);\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz');\n        }),\n      ]);\n      expect(request.method).toBe('POST');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend post data","suites":["request interception","Request.continue"],"updatePoint":{"line":774,"column":30},"line":774,"code":"    it('should amend post data', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({postData: 'doggo'}, 0);\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz', {method: 'POST', body: 'birdy'});\n        }),\n      ]);\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should amend both post data and method on navigation","suites":["request interception","Request.continue"],"updatePoint":{"line":791,"column":60},"line":791,"code":"    it('should amend both post data and method on navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({method: 'POST', postData: 'doggo'}, 0);\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(serverRequest.method).toBe('POST');\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception","Request.respond"],"updatePoint":{"line":808,"column":19},"line":808,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond(\n          {\n            status: 201,\n            headers: {\n              foo: 'bar',\n            },\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response!.status()).toBe(201);\n      expect(response!.headers()['foo']).toBe('bar');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to access the response","suites":["request interception","Request.respond"],"updatePoint":{"line":833,"column":45},"line":833,"code":"    it('should be able to access the response', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond(\n          {\n            status: 200,\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      let response = null;\n      page.on('request', request => {\n        response = request.responseForRequest();\n        request.continue({}, 0);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(response).toEqual({status: 200, body: 'Yo, page!'});\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should work with status code 422","suites":["request interception","Request.respond"],"updatePoint":{"line":854,"column":40},"line":854,"code":"    it('should work with status code 422', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond(\n          {\n            status: 422,\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response!.status()).toBe(422);\n      expect(response!.statusText()).toBe('Unprocessable Entity');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect","suites":["request interception","Request.respond"],"updatePoint":{"line":876,"column":23},"line":876,"code":"    it('should redirect', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (!request.url().includes('rrredirect')) {\n          request.continue({}, 0);\n          return;\n        }\n        request.respond(\n          {\n            status: 302,\n            headers: {\n              location: server.EMPTY_PAGE,\n            },\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.PREFIX + '/rrredirect');\n      expect(response!.request().redirectChain().length).toBe(1);\n      expect(response!.request().redirectChain()[0]!.url()).toBe(\n        server.PREFIX + '/rrredirect'\n      );\n      expect(response!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should allow mocking binary responses","suites":["request interception","Request.respond"],"updatePoint":{"line":902,"column":45},"line":902,"code":"    it('should allow mocking binary responses', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const imageBuffer = fs.readFileSync(\n          path.join(__dirname, '../assets', 'pptr.png')\n        );\n        request.respond(\n          {\n            contentType: 'image/png',\n            body: imageBuffer,\n          },\n          0\n        );\n      });\n      await page.evaluate(PREFIX => {\n        const img = document.createElement('img');\n        img.src = PREFIX + '/does-not-exist.png';\n        document.body.appendChild(img);\n        return new Promise(fulfill => {\n          return (img.onload = fulfill);\n        });\n      }, server.PREFIX);\n      const img = (await page.$('img'))!;\n      expect(await img.screenshot()).toBeGolden('mock-binary-response.png');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should stringify intercepted request response headers","suites":["request interception","Request.respond"],"updatePoint":{"line":929,"column":61},"line":929,"code":"    it('should stringify intercepted request response headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond(\n          {\n            status: 200,\n            headers: {\n              foo: true,\n            },\n            body: 'Yo, page!',\n          },\n          0\n        );\n      });\n      const response = await page.goto(server.EMPTY_PAGE);\n      expect(response!.status()).toBe(200);\n      const headers = response!.headers();\n      expect(headers['foo']).toBe('true');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should indicate already-handled if an intercept has been handled","suites":["request interception","Request.respond"],"updatePoint":{"line":955,"column":72},"line":955,"code":"    it('should indicate already-handled if an intercept has been handled', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue();\n      });\n      page.on('request', request => {\n        expect(request.isInterceptResolutionHandled()).toBeTruthy();\n      });\n      page.on('request', request => {\n        const {action} = request.interceptResolutionState();\n        expect(action).toBe(InterceptResolutionAction.AlreadyHandled);\n      });\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"src/requestinterception-experimental.spec.ts","skipped":false,"dir":"test"},{"name":"should intercept","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":33,"column":24},"line":33,"code":"    it('should intercept', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (utils.isFavicon(request)) {\n          request.continue();\n          return;\n        }\n        expect(request.url()).toContain('empty.html');\n        expect(request.headers()['user-agent']).toBeTruthy();\n        expect(request.headers()['accept']).toBeTruthy();\n        expect(request.method()).toBe('GET');\n        expect(request.postData()).toBe(undefined);\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.resourceType()).toBe('document');\n        expect(request.frame() === page.mainFrame()).toBe(true);\n        expect(request.frame()!.url()).toBe('about:blank');\n        request.continue();\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.ok()).toBe(true);\n      expect(response.remoteAddress().port).toBe(server.PORT);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work when POST is redirected with 302","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":58,"column":52},"line":58,"code":"    it('should work when POST is redirected with 302', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/rredirect', '/empty.html');\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      await page.setContent(`\n        <form action='/rredirect' method='post'>\n          <input type=\"hidden\" id=\"foo\" name=\"foo\" value=\"FOOBAR\">\n        </form>\n      `);\n      await Promise.all([\n        page.$eval('form', form => {\n          return (form as HTMLFormElement).submit();\n        }),\n        page.waitForNavigation(),\n      ]);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work when header manipulation headers with redirect","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":80,"column":66},"line":80,"code":"    it('should work when header manipulation headers with redirect', async () => {\n      const {page, server} = getTestState();\n\n      server.setRedirect('/rrredirect', '/empty.html');\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n        });\n        request.continue({headers});\n      });\n      await page.goto(server.PREFIX + '/rrredirect');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to remove headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":94,"column":40},"line":94,"code":"    it('should be able to remove headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers(), {\n          foo: 'bar',\n          origin: undefined, // remove \"origin\" header\n        });\n        request.continue({headers});\n      });\n\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.PREFIX + '/empty.html'),\n      ]);\n\n      expect(serverRequest.headers.origin).toBe(undefined);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should contain referer header","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":113,"column":37},"line":113,"code":"    it('should contain referer header', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        if (!utils.isFavicon(request)) {\n          requests.push(request);\n        }\n        request.continue();\n      });\n      await page.goto(server.PREFIX + '/one-style.html');\n      expect(requests[1]!.url()).toContain('/one-style.css');\n      expect(requests[1]!.headers()['referer']).toContain('/one-style.html');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should properly return navigation response when URL has cookies","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":128,"column":71},"line":128,"code":"    it('should properly return navigation response when URL has cookies', async () => {\n      const {page, server} = getTestState();\n\n      // Setup cookie.\n      await page.goto(server.EMPTY_PAGE);\n      await page.setCookie({name: 'foo', value: 'bar'});\n\n      // Setup request interception.\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      const response = (await page.reload())!;\n      expect(response.status()).toBe(200);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should stop intercepting","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":143,"column":32},"line":143,"code":"    it('should stop intercepting', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.once('request', request => {\n        return request.continue();\n      });\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(false);\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should show custom HTTP headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":154,"column":39},"line":154,"code":"    it('should show custom HTTP headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        foo: 'bar',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        expect(request.headers()['foo']).toBe('bar');\n        request.continue();\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.ok()).toBe(true);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirect inside sync XHR","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":169,"column":49},"line":169,"code":"    it('should work with redirect inside sync XHR', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      server.setRedirect('/logo.png', '/pptr.png');\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      const status = await page.evaluate(async () => {\n        const request = new XMLHttpRequest();\n        request.open('GET', '/logo.png', false); // `false` makes the request synchronous\n        request.send(null);\n        return request.status;\n      });\n      expect(status).toBe(200);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with custom referer headers","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":186,"column":47},"line":186,"code":"    it('should work with custom referer headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({referer: server.EMPTY_PAGE});\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        expect(request.headers()['referer']).toBe(server.EMPTY_PAGE);\n        request.continue();\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.ok()).toBe(true);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":198,"column":27},"line":198,"code":"    it('should be abortable', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (request.url().endsWith('.css')) {\n          request.abort();\n        } else {\n          request.continue();\n        }\n      });\n      let failedRequests = 0;\n      page.on('requestfailed', () => {\n        return ++failedRequests;\n      });\n      const response = (await page.goto(server.PREFIX + '/one-style.html'))!;\n      expect(response.ok()).toBe(true);\n      expect(response.request().failure()).toBe(null);\n      expect(failedRequests).toBe(1);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be abortable with custom error codes","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":218,"column":51},"line":218,"code":"    it('should be abortable with custom error codes', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.abort('internetdisconnected');\n      });\n      let failedRequest!: HTTPRequest;\n      page.on('requestfailed', request => {\n        return (failedRequest = request);\n      });\n      await page.goto(server.EMPTY_PAGE).catch(() => {});\n      expect(failedRequest).toBeTruthy();\n      expect(failedRequest.failure()!.errorText).toBe(\n        'net::ERR_INTERNET_DISCONNECTED'\n      );\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should send referer","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":235,"column":27},"line":235,"code":"    it('should send referer', async () => {\n      const {page, server} = getTestState();\n\n      await page.setExtraHTTPHeaders({\n        referer: 'http://google.com/',\n      });\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/grid.html'),\n        page.goto(server.PREFIX + '/grid.html'),\n      ]);\n      expect(request.headers['referer']).toBe('http://google.com/');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail navigation when aborting main resource","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":251,"column":58},"line":251,"code":"    it('should fail navigation when aborting main resource', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.abort();\n      });\n      let error!: Error;\n      await page.goto(server.EMPTY_PAGE).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeTruthy();\n      if (isChrome) {\n        expect(error.message).toContain('net::ERR_FAILED');\n      } else {\n        expect(error.message).toContain('NS_ERROR_FAILURE');\n      }\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":269,"column":34},"line":269,"code":"    it('should work with redirects', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue();\n        requests.push(request);\n      });\n      server.setRedirect(\n        '/non-existing-page.html',\n        '/non-existing-page-2.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-2.html',\n        '/non-existing-page-3.html'\n      );\n      server.setRedirect(\n        '/non-existing-page-3.html',\n        '/non-existing-page-4.html'\n      );\n      server.setRedirect('/non-existing-page-4.html', '/empty.html');\n      const response = (await page.goto(\n        server.PREFIX + '/non-existing-page.html'\n      ))!;\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('empty.html');\n      expect(requests.length).toBe(5);\n      expect(requests[2]!.resourceType()).toBe('document');\n      // Check redirect chain\n      const redirectChain = response.request().redirectChain();\n      expect(redirectChain.length).toBe(4);\n      expect(redirectChain[0]!.url()).toContain('/non-existing-page.html');\n      expect(redirectChain[2]!.url()).toContain('/non-existing-page-3.html');\n      for (let i = 0; i < redirectChain.length; ++i) {\n        const request = redirectChain[i]!;\n        expect(request.isNavigationRequest()).toBe(true);\n        expect(request.redirectChain().indexOf(request)).toBe(i);\n      }\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with redirects for subresources","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":309,"column":51},"line":309,"code":"    it('should work with redirects for subresources', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue();\n        if (!utils.isFavicon(request)) {\n          requests.push(request);\n        }\n      });\n      server.setRedirect('/one-style.css', '/two-style.css');\n      server.setRedirect('/two-style.css', '/three-style.css');\n      server.setRedirect('/three-style.css', '/four-style.css');\n      server.setRoute('/four-style.css', (_req, res) => {\n        return res.end('body {box-sizing: border-box; }');\n      });\n\n      const response = (await page.goto(server.PREFIX + '/one-style.html'))!;\n      expect(response.status()).toBe(200);\n      expect(response.url()).toContain('one-style.html');\n      expect(requests.length).toBe(5);\n      expect(requests[0]!.resourceType()).toBe('document');\n      expect(requests[1]!.resourceType()).toBe('stylesheet');\n      // Check redirect chain\n      const redirectChain = requests[1]!.redirectChain();\n      expect(redirectChain.length).toBe(3);\n      expect(redirectChain[0]!.url()).toContain('/one-style.css');\n      expect(redirectChain[2]!.url()).toContain('/three-style.css');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to abort redirects","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":339,"column":41},"line":339,"code":"    it('should be able to abort redirects', async () => {\n      const {page, server, isChrome} = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRedirect('/non-existing.json', '/non-existing-2.json');\n      server.setRedirect('/non-existing-2.json', '/simple.html');\n      page.on('request', request => {\n        if (request.url().includes('non-existing-2')) {\n          request.abort();\n        } else {\n          request.continue();\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const result = await page.evaluate(async () => {\n        try {\n          return await fetch('/non-existing.json');\n        } catch (error) {\n          return (error as Error).message;\n        }\n      });\n      if (isChrome) {\n        expect(result).toContain('Failed to fetch');\n      } else {\n        expect(result).toContain('NetworkError');\n      }\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with equal requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":366,"column":39},"line":366,"code":"    it('should work with equal requests', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      let responseCount = 1;\n      server.setRoute('/zzz', (_req, res) => {\n        return res.end(responseCount++ * 11 + '');\n      });\n      await page.setRequestInterception(true);\n\n      let spinner = false;\n      // Cancel 2nd request.\n      page.on('request', request => {\n        if (utils.isFavicon(request)) {\n          request.continue();\n          return;\n        }\n        spinner ? request.abort() : request.continue();\n        spinner = !spinner;\n      });\n      const results = await page.evaluate(() => {\n        return Promise.all([\n          fetch('/zzz')\n            .then(response => {\n              return response.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n          fetch('/zzz')\n            .then(response => {\n              return response.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n          fetch('/zzz')\n            .then(response => {\n              return response.text();\n            })\n            .catch(() => {\n              return 'FAILED';\n            }),\n        ]);\n      });\n      expect(results).toEqual(['11', 'FAILED', '22']);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to dataURL and fire dataURL requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":413,"column":60},"line":413,"code":"    it('should navigate to dataURL and fire dataURL requests', async () => {\n      const {page} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        requests.push(request);\n        request.continue();\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const response = (await page.goto(dataURL))!;\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(dataURL);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to fetch dataURL and fire dataURL requests","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":428,"column":65},"line":428,"code":"    it('should be able to fetch dataURL and fire dataURL requests', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        !utils.isFavicon(request) && requests.push(request);\n        request.continue();\n      });\n      const dataURL = 'data:text/html,<div>yo</div>';\n      const text = await page.evaluate((url: string) => {\n        return fetch(url).then(r => {\n          return r.text();\n        });\n      }, dataURL);\n      expect(text).toBe('<div>yo</div>');\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(dataURL);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should navigate to URL with hash and fire requests without hash","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":448,"column":71},"line":448,"code":"    it('should navigate to URL with hash and fire requests without hash', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        requests.push(request);\n        request.continue();\n      });\n      const response = (await page.goto(server.EMPTY_PAGE + '#hash'))!;\n      expect(response.status()).toBe(200);\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n      expect(requests.length).toBe(1);\n      expect(requests[0]!.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":463,"column":39},"line":463,"code":"    it('should work with encoded server', async () => {\n      const {page, server} = getTestState();\n\n      // The requestWillBeSent will report encoded URL, whereas interception will\n      // report URL as-is. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      const response = (await page.goto(\n        server.PREFIX + '/some nonexisting page'\n      ))!;\n      expect(response.status()).toBe(404);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with badly encoded server","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":477,"column":45},"line":477,"code":"    it('should work with badly encoded server', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      server.setRoute('/malformed?rnd=%911', (_req, res) => {\n        return res.end();\n      });\n      page.on('request', request => {\n        return request.continue();\n      });\n      const response = (await page.goto(\n        server.PREFIX + '/malformed?rnd=%911'\n      ))!;\n      expect(response.status()).toBe(200);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with encoded server - 2","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":492,"column":43},"line":492,"code":"    it('should work with encoded server - 2', async () => {\n      const {page, server} = getTestState();\n\n      // The requestWillBeSent will report URL as-is, whereas interception will\n      // report encoded URL for stylesheet. @see crbug.com/759388\n      await page.setRequestInterception(true);\n      const requests: HTTPRequest[] = [];\n      page.on('request', request => {\n        request.continue();\n        requests.push(request);\n      });\n      const response = (await page.goto(\n        `data:text/html,<link rel=\"stylesheet\" href=\"${server.PREFIX}/fonts?helvetica|arial\"/>`\n      ))!;\n      expect(response.status()).toBe(200);\n      expect(requests.length).toBe(2);\n      expect(requests[1]!.response()!.status()).toBe(404);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should not throw \"Invalid Interception Id\" if the request was cancelled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":510,"column":79},"line":510,"code":"    it('should not throw \"Invalid Interception Id\" if the request was cancelled', async () => {\n      const {page, server} = getTestState();\n\n      await page.setContent('<iframe></iframe>');\n      await page.setRequestInterception(true);\n      let request!: HTTPRequest;\n      page.on('request', async r => {\n        return (request = r);\n      });\n      page.$eval(\n        'iframe',\n        (frame, url) => {\n          return ((frame as HTMLIFrameElement).src = url as string);\n        },\n        server.EMPTY_PAGE\n      ),\n        // Wait for request interception.\n        await utils.waitEvent(page, 'request');\n      // Delete frame to cause request to be canceled.\n      await page.$eval('iframe', frame => {\n        return frame.remove();\n      });\n      let error!: Error;\n      await request.continue().catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeUndefined();\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if interception is not enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":538,"column":51},"line":538,"code":"    it('should throw if interception is not enabled', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      page.on('request', async request => {\n        try {\n          await request.continue();\n        } catch (error_) {\n          error = error_ as Error;\n        }\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(error.message).toContain('Request Interception is not enabled');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with file URLs","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":552,"column":34},"line":552,"code":"    it('should work with file URLs', async () => {\n      const {page} = getTestState();\n\n      await page.setRequestInterception(true);\n      const urls = new Set();\n      page.on('request', request => {\n        urls.add(request.url().split('/').pop());\n        request.continue();\n      });\n      await page.goto(\n        pathToFileURL(path.join(__dirname, '../assets', 'one-style.html'))\n      );\n      expect(urls.size).toBe(2);\n      expect(urls.has('one-style.html')).toBe(true);\n      expect(urls.has('one-style.css')).toBe(true);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should not cache if cache disabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":568,"column":42},"line":568,"code":"    it('should not cache if cache disabled', async () => {\n      const {page, server} = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(false);\n      page.on('request', request => {\n        return request.continue();\n      });\n\n      const cached = [];\n      page.on('requestservedfromcache', r => {\n        return cached.push(r);\n      });\n\n      await page.reload();\n      expect(cached.length).toBe(0);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should cache if cache enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":588,"column":37},"line":588,"code":"    it('should cache if cache enabled', async () => {\n      const {page, server} = getTestState();\n\n      // Load and re-load to make sure it's cached.\n      await page.goto(server.PREFIX + '/cached/one-style.html');\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n\n      const cached = [];\n      page.on('requestservedfromcache', r => {\n        return cached.push(r);\n      });\n\n      await page.reload();\n      expect(cached.length).toBe(1);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should load fonts if cache enabled","suites":["request interception","Page.setRequestInterception"],"updatePoint":{"line":608,"column":42},"line":608,"code":"    it('should load fonts if cache enabled', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      await page.setCacheEnabled(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n\n      const responsePromise = page.waitForResponse(r => {\n        return r.url().endsWith('/one-style.woff');\n      });\n      await page.goto(server.PREFIX + '/cached/one-style-font.html');\n      await responsePromise;\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception","Request.continue"],"updatePoint":{"line":626,"column":19},"line":626,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        return request.continue();\n      });\n      await page.goto(server.EMPTY_PAGE);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend HTTP headers","suites":["request interception","Request.continue"],"updatePoint":{"line":635,"column":33},"line":635,"code":"    it('should amend HTTP headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const headers = Object.assign({}, request.headers());\n        headers['FOO'] = 'bar';\n        request.continue({headers});\n      });\n      await page.goto(server.EMPTY_PAGE);\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz');\n        }),\n      ]);\n      expect(request.headers['foo']).toBe('bar');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect in a way non-observable to page","suites":["request interception","Request.continue"],"updatePoint":{"line":653,"column":55},"line":653,"code":"    it('should redirect in a way non-observable to page', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const redirectURL = request.url().includes('/empty.html')\n          ? server.PREFIX + '/consolelog.html'\n          : undefined;\n        request.continue({url: redirectURL});\n      });\n      let consoleMessage!: ConsoleMessage;\n      page.on('console', msg => {\n        return (consoleMessage = msg);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(page.url()).toBe(server.EMPTY_PAGE);\n      expect(consoleMessage.text()).toBe('yellow');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend method","suites":["request interception","Request.continue"],"updatePoint":{"line":671,"column":27},"line":671,"code":"    it('should amend method', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({method: 'POST'});\n      });\n      const [request] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz');\n        }),\n      ]);\n      expect(request.method).toBe('POST');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend post data","suites":["request interception","Request.continue"],"updatePoint":{"line":688,"column":30},"line":688,"code":"    it('should amend post data', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({postData: 'doggo'});\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/sleep.zzz'),\n        page.evaluate(() => {\n          return fetch('/sleep.zzz', {method: 'POST', body: 'birdy'});\n        }),\n      ]);\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should amend both post data and method on navigation","suites":["request interception","Request.continue"],"updatePoint":{"line":705,"column":60},"line":705,"code":"    it('should amend both post data and method on navigation', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.continue({method: 'POST', postData: 'doggo'});\n      });\n      const [serverRequest] = await Promise.all([\n        server.waitForRequest('/empty.html'),\n        page.goto(server.EMPTY_PAGE),\n      ]);\n      expect(serverRequest.method).toBe('POST');\n      expect(await serverRequest.postBody).toBe('doggo');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if the header value is invalid","suites":["request interception","Request.continue"],"updatePoint":{"line":719,"column":50},"line":719,"code":"    it('should fail if the header value is invalid', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      await page.setRequestInterception(true);\n      page.on('request', async request => {\n        await request\n          .continue({\n            headers: {\n              'X-Invalid-Header': 'a\\nb',\n            },\n          })\n          .catch(error_ => {\n            error = error_ as Error;\n          });\n        await request.continue();\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(error.message).toMatch(/Invalid header/);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["request interception","Request.respond"],"updatePoint":{"line":742,"column":19},"line":742,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond({\n          status: 201,\n          headers: {\n            foo: 'bar',\n          },\n          body: 'Yo, page!',\n        });\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.status()).toBe(201);\n      expect(response.headers()['foo']).toBe('bar');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work with status code 422","suites":["request interception","Request.respond"],"updatePoint":{"line":764,"column":40},"line":764,"code":"    it('should work with status code 422', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond({\n          status: 422,\n          body: 'Yo, page!',\n        });\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.status()).toBe(422);\n      expect(response.statusText()).toBe('Unprocessable Entity');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should redirect","suites":["request interception","Request.respond"],"updatePoint":{"line":783,"column":23},"line":783,"code":"    it('should redirect', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        if (!request.url().includes('rrredirect')) {\n          request.continue();\n          return;\n        }\n        request.respond({\n          status: 302,\n          headers: {\n            location: server.EMPTY_PAGE,\n          },\n        });\n      });\n      const response = (await page.goto(server.PREFIX + '/rrredirect'))!;\n      expect(response.request().redirectChain().length).toBe(1);\n      expect(response.request().redirectChain()[0]!.url()).toBe(\n        server.PREFIX + '/rrredirect'\n      );\n      expect(response.url()).toBe(server.EMPTY_PAGE);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should allow mocking multiple headers with same key","suites":["request interception","Request.respond"],"updatePoint":{"line":806,"column":59},"line":806,"code":"    it('should allow mocking multiple headers with same key', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond({\n          status: 200,\n          headers: {\n            foo: 'bar',\n            arr: ['1', '2'],\n            'set-cookie': ['first=1', 'second=2'],\n          },\n          body: 'Hello world',\n        });\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      const cookies = await page.cookies();\n      const firstCookie = cookies.find(cookie => {\n        return cookie.name === 'first';\n      });\n      const secondCookie = cookies.find(cookie => {\n        return cookie.name === 'second';\n      });\n      expect(response.status()).toBe(200);\n      expect(response.headers()['foo']).toBe('bar');\n      expect(response.headers()['arr']).toBe('1\\n2');\n      // request.respond() will not trigger Network.responseReceivedExtraInfo\n      // fail to get 'set-cookie' header from response\n      expect(firstCookie?.value).toBe('1');\n      expect(secondCookie?.value).toBe('2');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should allow mocking binary responses","suites":["request interception","Request.respond"],"updatePoint":{"line":837,"column":45},"line":837,"code":"    it('should allow mocking binary responses', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        const imageBuffer = fs.readFileSync(\n          path.join(__dirname, '../assets', 'pptr.png')\n        );\n        request.respond({\n          contentType: 'image/png',\n          body: imageBuffer,\n        });\n      });\n      await page.evaluate(PREFIX => {\n        const img = document.createElement('img');\n        img.src = PREFIX + '/does-not-exist.png';\n        document.body.appendChild(img);\n        return new Promise(fulfill => {\n          return (img.onload = fulfill);\n        });\n      }, server.PREFIX);\n      const img = (await page.$('img'))!;\n      expect(await img.screenshot()).toBeGolden('mock-binary-response.png');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should stringify intercepted request response headers","suites":["request interception","Request.respond"],"updatePoint":{"line":861,"column":61},"line":861,"code":"    it('should stringify intercepted request response headers', async () => {\n      const {page, server} = getTestState();\n\n      await page.setRequestInterception(true);\n      page.on('request', request => {\n        request.respond({\n          status: 200,\n          headers: {\n            foo: true,\n          },\n          body: 'Yo, page!',\n        });\n      });\n      const response = (await page.goto(server.EMPTY_PAGE))!;\n      expect(response.status()).toBe(200);\n      const headers = response.headers();\n      expect(headers['foo']).toBe('true');\n      expect(\n        await page.evaluate(() => {\n          return document.body.textContent;\n        })\n      ).toBe('Yo, page!');\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should fail if the header value is invalid","suites":["request interception","Request.respond"],"updatePoint":{"line":884,"column":50},"line":884,"code":"    it('should fail if the header value is invalid', async () => {\n      const {page, server} = getTestState();\n\n      let error!: Error;\n      await page.setRequestInterception(true);\n      page.on('request', async request => {\n        await request\n          .respond({\n            headers: {\n              'X-Invalid-Header': 'a\\nb',\n            },\n          })\n          .catch(error_ => {\n            error = error_ as Error;\n          });\n        await request.respond({\n          status: 200,\n          body: 'Hello World',\n        });\n      });\n      await page.goto(server.PREFIX + '/empty.html');\n      expect(error.message).toMatch(/Invalid header/);\n    });","file":"src/requestinterception.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":29,"column":19},"line":29,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot();\n      expect(screenshot).toBeGolden('screenshot-sanity.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should clip rect","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":37,"column":24},"line":37,"code":"    it('should clip rect', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        clip: {\n          x: 50,\n          y: 100,\n          width: 150,\n          height: 100,\n        },\n      });\n      expect(screenshot).toBeGolden('screenshot-clip-rect.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should use scale for clip","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":52,"column":33},"line":52,"code":"    it('should use scale for clip', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        clip: {\n          x: 50,\n          y: 100,\n          width: 150,\n          height: 100,\n          scale: 2,\n        },\n      });\n      expect(screenshot).toBeGolden('screenshot-clip-rect-scale2.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should get screenshot bigger than the viewport","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":68,"column":54},"line":68,"code":"    it('should get screenshot bigger than the viewport', async () => {\n      const {page, server} = getTestState();\n      await page.setViewport({width: 50, height: 50});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        clip: {\n          x: 25,\n          y: 25,\n          width: 100,\n          height: 100,\n        },\n      });\n      expect(screenshot).toBeGolden('screenshot-offscreen-clip.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":82,"column":30},"line":82,"code":"    it('should run in parallel', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const promises = [];\n      for (let i = 0; i < 3; ++i) {\n        promises.push(\n          page.screenshot({\n            clip: {\n              x: 50 * i,\n              y: 0,\n              width: 50,\n              height: 50,\n            },\n          })\n        );\n      }\n      const screenshots = await Promise.all(promises);\n      expect(screenshots[1]!).toBeGolden('grid-cell-1.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should take fullPage screenshots","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":103,"column":40},"line":103,"code":"    it('should take fullPage screenshots', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        fullPage: true,\n      });\n      expect(screenshot).toBeGolden('screenshot-grid-fullpage.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should run in parallel in multiple pages","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":113,"column":48},"line":113,"code":"    it('should run in parallel in multiple pages', async () => {\n      const {server, context} = getTestState();\n\n      const N = 2;\n      const pages = await Promise.all(\n        Array(N)\n          .fill(0)\n          .map(async () => {\n            const page = await context.newPage();\n            await page.goto(server.PREFIX + '/grid.html');\n            return page;\n          })\n      );\n      const promises = [];\n      for (let i = 0; i < N; ++i) {\n        promises.push(\n          pages[i]!.screenshot({\n            clip: {x: 50 * i, y: 0, width: 50, height: 50},\n          })\n        );\n      }\n      const screenshots = await Promise.all(promises);\n      for (let i = 0; i < N; ++i) {\n        expect(screenshots[i]).toBeGolden(`grid-cell-${i}.png`);\n      }\n      await Promise.all(\n        pages.map(page => {\n          return page.close();\n        })\n      );\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should allow transparency","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":144,"column":33},"line":144,"code":"    it('should allow transparency', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 100, height: 100});\n      await page.goto(server.EMPTY_PAGE);\n      const screenshot = await page.screenshot({omitBackground: true});\n      expect(screenshot).toBeGolden('transparent.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should render white background on jpeg file","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":152,"column":51},"line":152,"code":"    it('should render white background on jpeg file', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 100, height: 100});\n      await page.goto(server.EMPTY_PAGE);\n      const screenshot = await page.screenshot({\n        omitBackground: true,\n        type: 'jpeg',\n      });\n      expect(screenshot).toBeGolden('white.jpg');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work with webp","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":163,"column":29},"line":163,"code":"    it('should work with webp', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 100, height: 100});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        type: 'webp',\n      });\n\n      expect(screenshot).toBeInstanceOf(Buffer);\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work with odd clip size on Retina displays","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":174,"column":57},"line":174,"code":"    it('should work with odd clip size on Retina displays', async () => {\n      const {page} = getTestState();\n\n      const screenshot = await page.screenshot({\n        clip: {\n          x: 0,\n          y: 0,\n          width: 11,\n          height: 11,\n        },\n      });\n      expect(screenshot).toBeGolden('screenshot-clip-odd-size.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should return base64","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":187,"column":28},"line":187,"code":"    it('should return base64', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        encoding: 'base64',\n      });\n      // TODO (@jackfranklin): improve the screenshot types.\n      // - if we pass encoding: 'base64', it returns a string\n      // - else it returns a buffer.\n      // If we can fix that we can avoid this \"as string\" here.\n      expect(Buffer.from(screenshot as string, 'base64')).toBeGolden(\n        'screenshot-sanity.png'\n      );\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work in \"fromSurface: false\" mode","suites":["Screenshots","Page.screenshot"],"updatePoint":{"line":203,"column":48},"line":203,"code":"    it('should work in \"fromSurface: false\" mode', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      const screenshot = await page.screenshot({\n        fromSurface: false,\n      });\n      expect(screenshot).toBeDefined(); // toBeGolden('screenshot-fromsurface-false.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":216,"column":19},"line":216,"code":"    it('should work', async () => {\n      const {page, server} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.goto(server.PREFIX + '/grid.html');\n      await page.evaluate(() => {\n        return window.scrollBy(50, 100);\n      });\n      const elementHandle = (await page.$('.box:nth-of-type(3)'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-bounding-box.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a null viewport","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":228,"column":40},"line":228,"code":"    it('should work with a null viewport', async () => {\n      const {defaultBrowserOptions, puppeteer, server} = getTestState();\n\n      const browser = await puppeteer.launch({\n        ...defaultBrowserOptions,\n        defaultViewport: null,\n      });\n\n      try {\n        const page = await browser.newPage();\n        await page.goto(server.PREFIX + '/grid.html');\n        await page.evaluate(() => {\n          return window.scrollBy(50, 100);\n        });\n        const elementHandle = (await page.$('.box:nth-of-type(3)'))!;\n        const screenshot = await elementHandle.screenshot();\n        expect(screenshot).toBeTruthy();\n      } finally {\n        await browser.close();\n      }\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should take into account padding and border","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":249,"column":51},"line":249,"code":"    it('should take into account padding and border', async () => {\n      const {page} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.setContent(`\n        something above\n        <style>div {\n          border: 2px solid blue;\n          background: green;\n          width: 50px;\n          height: 50px;\n        }\n        </style>\n        <div></div>\n      `);\n      const elementHandle = (await page.$('div'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-padding-border.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should capture full element when larger than viewport","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":268,"column":61},"line":268,"code":"    it('should capture full element when larger than viewport', async () => {\n      const {page} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n\n      await page.setContent(`\n          something above\n          <style>\n          div.to-screenshot {\n            border: 1px solid blue;\n            width: 600px;\n            height: 600px;\n            margin-left: 50px;\n          }\n          ::-webkit-scrollbar{\n            display: none;\n          }\n          </style>\n          <div class=\"to-screenshot\"></div>\n        `);\n      const elementHandle = (await page.$('div.to-screenshot'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden(\n        'screenshot-element-larger-than-viewport.png'\n      );\n\n      expect(\n        await page.evaluate(() => {\n          return {\n            w: window.innerWidth,\n            h: window.innerHeight,\n          };\n        })\n      ).toEqual({w: 500, h: 500});\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should scroll element into view","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":303,"column":39},"line":303,"code":"    it('should scroll element into view', async () => {\n      const {page} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.setContent(`\n        something above\n        <style>div.above {\n          border: 2px solid blue;\n          background: red;\n          height: 1500px;\n        }\n        div.to-screenshot {\n          border: 2px solid blue;\n          background: green;\n          width: 50px;\n          height: 50px;\n        }\n        </style>\n        <div class=\"above\"></div>\n        <div class=\"to-screenshot\"></div>\n      `);\n      const elementHandle = (await page.$('div.to-screenshot'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden(\n        'screenshot-element-scrolled-into-view.png'\n      );\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work with a rotated element","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":330,"column":42},"line":330,"code":"    it('should work with a rotated element', async () => {\n      const {page} = getTestState();\n\n      await page.setViewport({width: 500, height: 500});\n      await page.setContent(`<div style=\"position:absolute;\n                                        top: 100px;\n                                        left: 100px;\n                                        width: 100px;\n                                        height: 100px;\n                                        background: green;\n                                        transform: rotateZ(200deg);\">&nbsp;</div>`);\n      const elementHandle = (await page.$('div'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-rotate.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should fail to screenshot a detached element","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":345,"column":52},"line":345,"code":"    it('should fail to screenshot a detached element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<h1>remove this</h1>');\n      const elementHandle = (await page.$('h1'))!;\n      await page.evaluate((element: HTMLElement) => {\n        return element.remove();\n      }, elementHandle);\n      const screenshotError = await elementHandle.screenshot().catch(error => {\n        return error;\n      });\n      expect(screenshotError.message).toBe(\n        'Node is either not visible or not an HTMLElement'\n      );\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should not hang with zero width/height element","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":360,"column":54},"line":360,"code":"    it('should not hang with zero width/height element', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div style=\"width: 50px; height: 0\"></div>');\n      const div = (await page.$('div'))!;\n      const error = await div.screenshot().catch(error_ => {\n        return error_;\n      });\n      expect(error.message).toBe('Node has 0 height.');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work for an element with fractional dimensions","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":370,"column":61},"line":370,"code":"    it('should work for an element with fractional dimensions', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<div style=\"width:48.51px;height:19.8px;border:1px solid black;\"></div>'\n      );\n      const elementHandle = (await page.$('div'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-fractional.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"should work for an element with an offset","suites":["Screenshots","ElementHandle.screenshot"],"updatePoint":{"line":380,"column":49},"line":380,"code":"    it('should work for an element with an offset', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(\n        '<div style=\"position:absolute; top: 10.3px; left: 20.4px;width:50.3px;height:20.2px;border:1px solid black;\"></div>'\n      );\n      const elementHandle = (await page.$('div'))!;\n      const screenshot = await elementHandle.screenshot();\n      expect(screenshot).toBeGolden('screenshot-element-fractional-offset.png');\n    });","file":"src/screenshot.spec.ts","skipped":false,"dir":"test"},{"name":"Browser.targets should return all of the targets","suites":["Target"],"updatePoint":{"line":35,"column":54},"line":35,"code":"  it('Browser.targets should return all of the targets', async () => {\n    const {browser} = getTestState();\n\n    // The pages will be the testing page and the original newtab page\n    const targets = browser.targets();\n    expect(\n      targets.some(target => {\n        return target.type() === 'page' && target.url() === 'about:blank';\n      })\n    ).toBeTruthy();\n    expect(\n      targets.some(target => {\n        return target.type() === 'browser';\n      })\n    ).toBeTruthy();\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"Browser.pages should return all of the pages","suites":["Target"],"updatePoint":{"line":51,"column":50},"line":51,"code":"  it('Browser.pages should return all of the pages', async () => {\n    const {page, context} = getTestState();\n\n    // The pages will be the testing page\n    const allPages = await context.pages();\n    expect(allPages.length).toBe(1);\n    expect(allPages).toContain(page);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should contain browser target","suites":["Target"],"updatePoint":{"line":59,"column":35},"line":59,"code":"  it('should contain browser target', async () => {\n    const {browser} = getTestState();\n\n    const targets = browser.targets();\n    const browserTarget = targets.find(target => {\n      return target.type() === 'browser';\n    });\n    expect(browserTarget).toBeTruthy();\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to use the default page in the browser","suites":["Target"],"updatePoint":{"line":68,"column":59},"line":68,"code":"  it('should be able to use the default page in the browser', async () => {\n    const {page, browser} = getTestState();\n\n    // The pages will be the testing page and the original newtab page\n    const allPages = await browser.pages();\n    const originalPage = allPages.find(p => {\n      return p !== page;\n    })!;\n    expect(\n      await originalPage.evaluate(() => {\n        return ['Hello', 'world'].join(' ');\n      })\n    ).toBe('Hello world');\n    expect(await originalPage.$('body')).toBeTruthy();\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should be able to use async waitForTarget","suites":["Target"],"updatePoint":{"line":83,"column":47},"line":83,"code":"  it('should be able to use async waitForTarget', async () => {\n    const {page, server, context} = getTestState();\n\n    const [otherPage] = await Promise.all([\n      context\n        .waitForTarget(target => {\n          return target.page().then(page => {\n            return page!.url() === server.CROSS_PROCESS_PREFIX + '/empty.html';\n          });\n        })\n        .then(target => {\n          return target.page();\n        }),\n      page.evaluate((url: string) => {\n        return window.open(url);\n      }, server.CROSS_PROCESS_PREFIX + '/empty.html'),\n    ]);\n    expect(otherPage!.url()).toEqual(\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    expect(page).not.toEqual(otherPage);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should report when a new page is created and closed","suites":["Target"],"updatePoint":{"line":105,"column":57},"line":105,"code":"  it('should report when a new page is created and closed', async () => {\n    const {page, server, context} = getTestState();\n\n    const [otherPage] = await Promise.all([\n      context\n        .waitForTarget(target => {\n          return target.url() === server.CROSS_PROCESS_PREFIX + '/empty.html';\n        })\n        .then(target => {\n          return target.page();\n        }),\n      page.evaluate((url: string) => {\n        return window.open(url);\n      }, server.CROSS_PROCESS_PREFIX + '/empty.html'),\n    ]);\n    expect(otherPage!.url()).toContain(server.CROSS_PROCESS_PREFIX);\n    expect(\n      await otherPage!.evaluate(() => {\n        return ['Hello', 'world'].join(' ');\n      })\n    ).toBe('Hello world');\n    expect(await otherPage!.$('body')).toBeTruthy();\n\n    let allPages = await context.pages();\n    expect(allPages).toContain(page);\n    expect(allPages).toContain(otherPage);\n\n    const closePagePromise = new Promise(fulfill => {\n      return context.once('targetdestroyed', target => {\n        return fulfill(target.page());\n      });\n    });\n    await otherPage!.close();\n    expect(await closePagePromise).toBe(otherPage);\n\n    allPages = (await Promise.all(\n      context.targets().map(target => {\n        return target.page();\n      })\n    )) as Page[];\n    expect(allPages).toContain(page);\n    expect(allPages).not.toContain(otherPage);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should report when a service worker is created and destroyed","suites":["Target"],"updatePoint":{"line":148,"column":66},"line":148,"code":"  it('should report when a service worker is created and destroyed', async () => {\n    const {page, server, context} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const createdTarget = new Promise<Target>(fulfill => {\n      return context.once('targetcreated', target => {\n        return fulfill(target);\n      });\n    });\n\n    await page.goto(server.PREFIX + '/serviceworkers/empty/sw.html');\n\n    expect((await createdTarget).type()).toBe('service_worker');\n    expect((await createdTarget).url()).toBe(\n      server.PREFIX + '/serviceworkers/empty/sw.js'\n    );\n\n    const destroyedTarget = new Promise(fulfill => {\n      return context.once('targetdestroyed', target => {\n        return fulfill(target);\n      });\n    });\n    await page.evaluate(() => {\n      return (\n        globalThis as unknown as {\n          registrationPromise: Promise<{unregister: () => void}>;\n        }\n      ).registrationPromise.then((registration: any) => {\n        return registration.unregister();\n      });\n    });\n    expect(await destroyedTarget).toBe(await createdTarget);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should create a worker from a service worker","suites":["Target"],"updatePoint":{"line":181,"column":50},"line":181,"code":"  it('should create a worker from a service worker', async () => {\n    const {page, server, context} = getTestState();\n\n    await page.goto(server.PREFIX + '/serviceworkers/empty/sw.html');\n\n    const target = await context.waitForTarget(target => {\n      return target.type() === 'service_worker';\n    });\n    const worker = (await target.worker())!;\n    expect(\n      await worker.evaluate(() => {\n        return self.toString();\n      })\n    ).toBe('[object ServiceWorkerGlobalScope]');\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should create a worker from a shared worker","suites":["Target"],"updatePoint":{"line":196,"column":49},"line":196,"code":"  it('should create a worker from a shared worker', async () => {\n    const {page, server, context} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    await page.evaluate(() => {\n      new SharedWorker('data:text/javascript,console.log(\"hi\")');\n    });\n    const target = await context.waitForTarget(target => {\n      return target.type() === 'shared_worker';\n    });\n    const worker = (await target.worker())!;\n    expect(\n      await worker.evaluate(() => {\n        return self.toString();\n      })\n    ).toBe('[object SharedWorkerGlobalScope]');\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should report when a target url changes","suites":["Target"],"updatePoint":{"line":213,"column":45},"line":213,"code":"  it('should report when a target url changes', async () => {\n    const {page, server, context} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    let changedTarget = new Promise<Target>(fulfill => {\n      return context.once('targetchanged', target => {\n        return fulfill(target);\n      });\n    });\n    await page.goto(server.CROSS_PROCESS_PREFIX + '/');\n    expect((await changedTarget).url()).toBe(server.CROSS_PROCESS_PREFIX + '/');\n\n    changedTarget = new Promise(fulfill => {\n      return context.once('targetchanged', target => {\n        return fulfill(target);\n      });\n    });\n    await page.goto(server.EMPTY_PAGE);\n    expect((await changedTarget).url()).toBe(server.EMPTY_PAGE);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should not report uninitialized pages","suites":["Target"],"updatePoint":{"line":233,"column":43},"line":233,"code":"  it('should not report uninitialized pages', async () => {\n    const {context} = getTestState();\n\n    let targetChanged = false;\n    const listener = () => {\n      return (targetChanged = true);\n    };\n    context.on('targetchanged', listener);\n    const targetPromise = new Promise<Target>(fulfill => {\n      return context.once('targetcreated', target => {\n        return fulfill(target);\n      });\n    });\n    const newPagePromise = context.newPage();\n    const target = await targetPromise;\n    expect(target.url()).toBe('about:blank');\n\n    const newPage = await newPagePromise;\n    const targetPromise2 = new Promise<Target>(fulfill => {\n      return context.once('targetcreated', target => {\n        return fulfill(target);\n      });\n    });\n    const evaluatePromise = newPage.evaluate(() => {\n      return window.open('about:blank');\n    });\n    const target2 = await targetPromise2;\n    expect(target2.url()).toBe('about:blank');\n    await evaluatePromise;\n    await newPage.close();\n    expect(targetChanged).toBe(false);\n    context.removeListener('targetchanged', listener);\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should not crash while redirecting if original request was missed","suites":["Target"],"updatePoint":{"line":266,"column":71},"line":266,"code":"  it('should not crash while redirecting if original request was missed', async () => {\n    const {page, server, context} = getTestState();\n\n    let serverResponse!: ServerResponse;\n    server.setRoute('/one-style.css', (_req, res) => {\n      return (serverResponse = res);\n    });\n    // Open a new page. Use window.open to connect to the page later.\n    await Promise.all([\n      page.evaluate((url: string) => {\n        return window.open(url);\n      }, server.PREFIX + '/one-style.html'),\n      server.waitForRequest('/one-style.css'),\n    ]);\n    // Connect to the opened page.\n    const target = await context.waitForTarget(target => {\n      return target.url().includes('one-style.html');\n    });\n    const newPage = (await target.page())!;\n    // Issue a redirect.\n    serverResponse.writeHead(302, {location: '/injectedstyle.css'});\n    serverResponse.end();\n    // Wait for the new page to load.\n    await waitEvent(newPage, 'load');\n    // Cleanup.\n    await newPage.close();\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should have an opener","suites":["Target"],"updatePoint":{"line":293,"column":27},"line":293,"code":"  it('should have an opener', async () => {\n    const {page, server, context} = getTestState();\n\n    await page.goto(server.EMPTY_PAGE);\n    const [createdTarget] = await Promise.all([\n      new Promise<Target>(fulfill => {\n        return context.once('targetcreated', target => {\n          return fulfill(target);\n        });\n      }),\n      page.goto(server.PREFIX + '/popup/window-open.html'),\n    ]);\n    expect((await createdTarget.page())!.url()).toBe(\n      server.PREFIX + '/popup/popup.html'\n    );\n    expect(createdTarget.opener()).toBe(page.target());\n    expect(page.target().opener()).toBeUndefined();\n  });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for a target","suites":["Target","Browser.waitForTarget"],"updatePoint":{"line":313,"column":32},"line":313,"code":"    it('should wait for a target', async () => {\n      const {browser, server} = getTestState();\n\n      let resolved = false;\n      const targetPromise = browser.waitForTarget(target => {\n        return target.url() === server.EMPTY_PAGE;\n      });\n      targetPromise\n        .then(() => {\n          return (resolved = true);\n        })\n        .catch(error => {\n          resolved = true;\n          if (error instanceof TimeoutError) {\n            console.error(error);\n          } else {\n            throw error;\n          }\n        });\n      const page = await browser.newPage();\n      expect(resolved).toBe(false);\n      await page.goto(server.EMPTY_PAGE);\n      try {\n        const target = await targetPromise;\n        expect(await target.page()).toBe(page);\n      } catch (error) {\n        if (error instanceof TimeoutError) {\n          console.error(error);\n        } else {\n          throw error;\n        }\n      }\n      await page.close();\n    });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should timeout waiting for a non-existent target","suites":["Target","Browser.waitForTarget"],"updatePoint":{"line":347,"column":56},"line":347,"code":"    it('should timeout waiting for a non-existent target', async () => {\n      const {browser, server} = getTestState();\n\n      let error!: Error;\n      await browser\n        .waitForTarget(\n          target => {\n            return target.url() === server.EMPTY_PAGE;\n          },\n          {\n            timeout: 1,\n          }\n        )\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n    });","file":"src/target.spec.ts","skipped":false,"dir":"test"},{"name":"should handle targets","suites":["TargetManager"],"updatePoint":{"line":57,"column":27},"line":57,"code":"  it('should handle targets', async () => {\n    const {server} = getTestState();\n\n    const targetManager = browser._targetManager();\n    expect(targetManager.getAvailableTargets().size).toBe(2);\n\n    expect(await context.pages()).toHaveLength(0);\n    expect(targetManager.getAvailableTargets().size).toBe(2);\n\n    const page = await context.newPage();\n    expect(await context.pages()).toHaveLength(1);\n    expect(targetManager.getAvailableTargets().size).toBe(3);\n\n    await page.goto(server.EMPTY_PAGE);\n    expect(await context.pages()).toHaveLength(1);\n    expect(targetManager.getAvailableTargets().size).toBe(3);\n\n    // attach a local iframe.\n    let framePromise = page.waitForFrame(frame => {\n      return frame.url().endsWith('/empty.html');\n    });\n    await utils.attachFrame(page, 'frame1', server.EMPTY_PAGE);\n    await framePromise;\n    expect(await context.pages()).toHaveLength(1);\n    expect(targetManager.getAvailableTargets().size).toBe(3);\n    expect(page.frames()).toHaveLength(2);\n\n    // // attach a remote frame iframe.\n    framePromise = page.waitForFrame(frame => {\n      return frame.url() === server.CROSS_PROCESS_PREFIX + '/empty.html';\n    });\n    await utils.attachFrame(\n      page,\n      'frame2',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    await framePromise;\n    expect(await context.pages()).toHaveLength(1);\n    expect(targetManager.getAvailableTargets().size).toBe(4);\n    expect(page.frames()).toHaveLength(3);\n\n    framePromise = page.waitForFrame(frame => {\n      return frame.url() === server.CROSS_PROCESS_PREFIX + '/empty.html';\n    });\n    await utils.attachFrame(\n      page,\n      'frame3',\n      server.CROSS_PROCESS_PREFIX + '/empty.html'\n    );\n    await framePromise;\n    expect(await context.pages()).toHaveLength(1);\n    expect(targetManager.getAvailableTargets().size).toBe(5);\n    expect(page.frames()).toHaveLength(4);\n  });","file":"src/TargetManager.spec.ts","skipped":false,"dir":"test"},{"name":"should tap the button","suites":["Touchscreen"],"updatePoint":{"line":29,"column":27},"line":29,"code":"  it('should tap the button', async () => {\n    const {page, server} = getTestState();\n    const iPhone = KnownDevices['iPhone 6']!;\n    await page.emulate(iPhone);\n    await page.goto(server.PREFIX + '/input/button.html');\n    await page.tap('button');\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).result;\n      })\n    ).toBe('Clicked');\n  });","file":"src/touchscreen.spec.ts","skipped":false,"dir":"test"},{"name":"should report touches","suites":["Touchscreen"],"updatePoint":{"line":41,"column":27},"line":41,"code":"  it('should report touches', async () => {\n    const {page, server} = getTestState();\n    const iPhone = KnownDevices['iPhone 6']!;\n    await page.emulate(iPhone);\n    await page.goto(server.PREFIX + '/input/touches.html');\n    const button = (await page.$('button'))!;\n    await button.tap();\n    expect(\n      await page.evaluate(() => {\n        return (globalThis as any).getResult();\n      })\n    ).toEqual(['Touchstart: 0', 'Touchend: 0']);\n  });","file":"src/touchscreen.spec.ts","skipped":false,"dir":"test"},{"name":"should output a trace","suites":["Tracing"],"updatePoint":{"line":46,"column":27},"line":46,"code":"  it('should output a trace', async () => {\n    const {server} = getTestState();\n\n    await page.tracing.start({screenshots: true, path: outputFile});\n    await page.goto(server.PREFIX + '/grid.html');\n    await page.tracing.stop();\n    expect(fs.existsSync(outputFile)).toBe(true);\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should run with custom categories if provided","suites":["Tracing"],"updatePoint":{"line":55,"column":51},"line":55,"code":"  it('should run with custom categories if provided', async () => {\n    await page.tracing.start({\n      path: outputFile,\n      categories: ['-*', 'disabled-by-default-devtools.timeline.frame'],\n    });\n    await page.tracing.stop();\n\n    const traceJson = JSON.parse(\n      fs.readFileSync(outputFile, {encoding: 'utf8'})\n    );\n    const traceConfig = JSON.parse(traceJson.metadata['trace-config']);\n    expect(traceConfig.included_categories).toEqual([\n      'disabled-by-default-devtools.timeline.frame',\n    ]);\n    expect(traceConfig.excluded_categories).toEqual(['*']);\n    expect(traceJson.traceEvents).not.toContainEqual(\n      expect.objectContaining({\n        cat: 'toplevel',\n      })\n    );\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should run with default categories","suites":["Tracing"],"updatePoint":{"line":77,"column":40},"line":77,"code":"  it('should run with default categories', async () => {\n    await page.tracing.start({\n      path: outputFile,\n    });\n    await page.tracing.stop();\n\n    const traceJson = JSON.parse(\n      fs.readFileSync(outputFile, {encoding: 'utf8'})\n    );\n    expect(traceJson.traceEvents).toContainEqual(\n      expect.objectContaining({\n        cat: 'toplevel',\n      })\n    );\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should throw if tracing on two pages","suites":["Tracing"],"updatePoint":{"line":92,"column":42},"line":92,"code":"  it('should throw if tracing on two pages', async () => {\n    await page.tracing.start({path: outputFile});\n    const newPage = await browser.newPage();\n    let error!: Error;\n    await newPage.tracing.start({path: outputFile}).catch(error_ => {\n      return (error = error_);\n    });\n    await newPage.close();\n    expect(error).toBeTruthy();\n    await page.tracing.stop();\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should return a buffer","suites":["Tracing"],"updatePoint":{"line":103,"column":28},"line":103,"code":"  it('should return a buffer', async () => {\n    const {server} = getTestState();\n\n    await page.tracing.start({screenshots: true, path: outputFile});\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = (await page.tracing.stop())!;\n    const buf = fs.readFileSync(outputFile);\n    expect(trace.toString()).toEqual(buf.toString());\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should work without options","suites":["Tracing"],"updatePoint":{"line":112,"column":33},"line":112,"code":"  it('should work without options', async () => {\n    const {server} = getTestState();\n\n    await page.tracing.start();\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = await page.tracing.stop();\n    expect(trace).toBeTruthy();\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined in case of Buffer error","suites":["Tracing"],"updatePoint":{"line":121,"column":53},"line":121,"code":"  it('should return undefined in case of Buffer error', async () => {\n    const {server} = getTestState();\n\n    await page.tracing.start({screenshots: true});\n    await page.goto(server.PREFIX + '/grid.html');\n    const oldBufferConcat = Buffer.concat;\n    Buffer.concat = () => {\n      throw 'error';\n    };\n    const trace = await page.tracing.stop();\n    expect(trace).toEqual(undefined);\n    Buffer.concat = oldBufferConcat;\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should support a buffer without a path","suites":["Tracing"],"updatePoint":{"line":135,"column":44},"line":135,"code":"  it('should support a buffer without a path', async () => {\n    const {server} = getTestState();\n\n    await page.tracing.start({screenshots: true});\n    await page.goto(server.PREFIX + '/grid.html');\n    const trace = (await page.tracing.stop())!;\n    expect(trace.toString()).toContain('screenshot');\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should properly fail if readProtocolStream errors out","suites":["Tracing"],"updatePoint":{"line":144,"column":59},"line":144,"code":"  it('should properly fail if readProtocolStream errors out', async () => {\n    await page.tracing.start({path: __dirname});\n\n    let error!: Error;\n    try {\n      await page.tracing.stop();\n    } catch (error_) {\n      error = error_ as Error;\n    }\n    expect(error).toBeDefined();\n  });","file":"src/tracing.spec.ts","skipped":false,"dir":"test"},{"name":"should accept a string","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":33,"column":30},"line":33,"code":"    it('should accept a string', async () => {\n      const {page} = getTestState();\n\n      const watchdog = page.waitForFunction('self.__FOO === 1');\n      await page.evaluate(() => {\n        return ((self as unknown as {__FOO: number}).__FOO = 1);\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work when resolved right before execution context disposal","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":42,"column":73},"line":42,"code":"    it('should work when resolved right before execution context disposal', async () => {\n      const {page} = getTestState();\n\n      await page.evaluateOnNewDocument(() => {\n        return ((globalThis as any).__RELOADED = true);\n      });\n      await page.waitForFunction(() => {\n        if (!(globalThis as any).__RELOADED) {\n          window.location.reload();\n          return false;\n        }\n        return true;\n      });\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on interval","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":56,"column":31},"line":56,"code":"    it('should poll on interval', async () => {\n      const {page} = getTestState();\n      const startTime = Date.now();\n      const polling = 100;\n      const watchdog = page.waitForFunction(\n        () => {\n          return (globalThis as any).__FOO === 'hit';\n        },\n        {polling}\n      );\n      await page.evaluate(() => {\n        setTimeout(() => {\n          (globalThis as any).__FOO = 'hit';\n        }, 50);\n      });\n      await watchdog;\n      expect(Date.now() - startTime).not.toBeLessThan(polling / 2);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on mutation","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":74,"column":31},"line":74,"code":"    it('should poll on mutation', async () => {\n      const {page} = getTestState();\n\n      let success = false;\n      const watchdog = page\n        .waitForFunction(\n          () => {\n            return (globalThis as any).__FOO === 'hit';\n          },\n          {\n            polling: 'mutation',\n          }\n        )\n        .then(() => {\n          return (success = true);\n        });\n      await page.evaluate(() => {\n        return ((globalThis as any).__FOO = 'hit');\n      });\n      expect(success).toBe(false);\n      await page.evaluate(() => {\n        return document.body.appendChild(document.createElement('div'));\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on mutation async","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":99,"column":37},"line":99,"code":"    it('should poll on mutation async', async () => {\n      const {page} = getTestState();\n\n      let success = false;\n      const watchdog = page\n        .waitForFunction(\n          async () => {\n            return (globalThis as any).__FOO === 'hit';\n          },\n          {\n            polling: 'mutation',\n          }\n        )\n        .then(() => {\n          return (success = true);\n        });\n      await page.evaluate(async () => {\n        return ((globalThis as any).__FOO = 'hit');\n      });\n      expect(success).toBe(false);\n      await page.evaluate(async () => {\n        return document.body.appendChild(document.createElement('div'));\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on raf","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":124,"column":26},"line":124,"code":"    it('should poll on raf', async () => {\n      const {page} = getTestState();\n\n      const watchdog = page.waitForFunction(\n        () => {\n          return (globalThis as any).__FOO === 'hit';\n        },\n        {\n          polling: 'raf',\n        }\n      );\n      await page.evaluate(() => {\n        return ((globalThis as any).__FOO = 'hit');\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should poll on raf async","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":140,"column":32},"line":140,"code":"    it('should poll on raf async', async () => {\n      const {page} = getTestState();\n\n      const watchdog = page.waitForFunction(\n        async () => {\n          return (globalThis as any).__FOO === 'hit';\n        },\n        {\n          polling: 'raf',\n        }\n      );\n      await page.evaluate(async () => {\n        return ((globalThis as any).__FOO = 'hit');\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work with strict CSP policy","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":156,"column":42},"line":156,"code":"    it('should work with strict CSP policy', async () => {\n      const {page, server} = getTestState();\n\n      server.setCSP('/empty.html', 'script-src ' + server.PREFIX);\n      await page.goto(server.EMPTY_PAGE);\n      let error!: Error;\n      await Promise.all([\n        page\n          .waitForFunction(\n            () => {\n              return (globalThis as any).__FOO === 'hit';\n            },\n            {\n              polling: 'raf',\n            }\n          )\n          .catch(error_ => {\n            return (error = error_);\n          }),\n        page.evaluate(() => {\n          return ((globalThis as any).__FOO = 'hit');\n        }),\n      ]);\n      expect(error).toBeUndefined();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw negative polling interval","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":181,"column":46},"line":181,"code":"    it('should throw negative polling interval', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      try {\n        await page.waitForFunction(\n          () => {\n            return !!document.body;\n          },\n          {polling: -10}\n        );\n      } catch (error_) {\n        if (isErrorLike(error_)) {\n          error = error_ as Error;\n        }\n      }\n      expect(error?.message).toContain(\n        'Cannot poll with non-positive interval'\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the success value as a JSHandle","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":201,"column":53},"line":201,"code":"    it('should return the success value as a JSHandle', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await (\n          await page.waitForFunction(() => {\n            return 5;\n          })\n        ).jsonValue()\n      ).toBe(5);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the window as a success value","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":212,"column":51},"line":212,"code":"    it('should return the window as a success value', async () => {\n      const {page} = getTestState();\n\n      expect(\n        await page.waitForFunction(() => {\n          return window;\n        })\n      ).toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should accept ElementHandle arguments","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":221,"column":45},"line":221,"code":"    it('should accept ElementHandle arguments', async () => {\n      const {page} = getTestState();\n\n      await page.setContent('<div></div>');\n      const div = (await page.$('div'))!;\n      let resolved = false;\n      const waitForFunction = page\n        .waitForFunction(\n          (element: Element) => {\n            return element.localName === 'div' && !element.parentElement;\n          },\n          {},\n          div\n        )\n        .then(() => {\n          return (resolved = true);\n        });\n      expect(resolved).toBe(false);\n      await page.evaluate((element: HTMLElement) => {\n        return element.remove();\n      }, div);\n      await waitForFunction;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":244,"column":30},"line":244,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page\n        .waitForFunction(\n          () => {\n            return false;\n          },\n          {timeout: 10}\n        )\n        .catch(error_ => {\n          return (error = error_);\n        });\n\n      expect(error).toBeInstanceOf(TimeoutError);\n      expect(error?.message).toContain('Waiting failed: 10ms exceeded');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect default timeout","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":262,"column":38},"line":262,"code":"    it('should respect default timeout', async () => {\n      const {page} = getTestState();\n\n      page.setDefaultTimeout(1);\n      let error!: Error;\n      await page\n        .waitForFunction(() => {\n          return false;\n        })\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeInstanceOf(TimeoutError);\n      expect(error?.message).toContain('Waiting failed: 1ms exceeded');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should disable timeout when its set to 0","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":277,"column":48},"line":277,"code":"    it('should disable timeout when its set to 0', async () => {\n      const {page} = getTestState();\n\n      const watchdog = page.waitForFunction(\n        () => {\n          (globalThis as any).__counter =\n            ((globalThis as any).__counter || 0) + 1;\n          return (globalThis as any).__injected;\n        },\n        {timeout: 0, polling: 10}\n      );\n      await page.waitForFunction(() => {\n        return (globalThis as any).__counter > 10;\n      });\n      await page.evaluate(() => {\n        return ((globalThis as any).__injected = true);\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":296,"column":47},"line":296,"code":"    it('should survive cross-process navigation', async () => {\n      const {page, server} = getTestState();\n\n      let fooFound = false;\n      const waitForFunction = page\n        .waitForFunction(() => {\n          return (globalThis as unknown as {__FOO: number}).__FOO === 1;\n        })\n        .then(() => {\n          return (fooFound = true);\n        });\n      await page.goto(server.EMPTY_PAGE);\n      expect(fooFound).toBe(false);\n      await page.reload();\n      expect(fooFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      expect(fooFound).toBe(false);\n      await page.evaluate(() => {\n        return ((globalThis as any).__FOO = 1);\n      });\n      await waitForFunction;\n      expect(fooFound).toBe(true);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive navigations","suites":["waittask specs","Frame.waitForFunction"],"updatePoint":{"line":319,"column":34},"line":319,"code":"    it('should survive navigations', async () => {\n      const {page, server} = getTestState();\n\n      const watchdog = page.waitForFunction(() => {\n        return (globalThis as any).__done;\n      });\n      await page.goto(server.EMPTY_PAGE);\n      await page.goto(server.PREFIX + '/consolelog.html');\n      await page.evaluate(() => {\n        return ((globalThis as any).__done = true);\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"waits for the given timeout before resolving","suites":["waittask specs","Page.waitForTimeout"],"updatePoint":{"line":335,"column":52},"line":335,"code":"    it('waits for the given timeout before resolving', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const startTime = Date.now();\n      await page.waitForTimeout(1000);\n      const endTime = Date.now();\n      /* In a perfect world endTime - startTime would be exactly 1000 but we\n       * expect some fluctuations and for it to be off by a little bit. So to\n       * avoid a flaky test we'll make sure it waited for roughly 1 second.\n       */\n      expect(endTime - startTime).toBeGreaterThan(700);\n      expect(endTime - startTime).toBeLessThan(1300);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"waits for the given timeout before resolving","suites":["waittask specs","Frame.waitForTimeout"],"updatePoint":{"line":351,"column":52},"line":351,"code":"    it('waits for the given timeout before resolving', async () => {\n      const {page, server} = getTestState();\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const startTime = Date.now();\n      await frame.waitForTimeout(1000);\n      const endTime = Date.now();\n      /* In a perfect world endTime - startTime would be exactly 1000 but we\n       * expect some fluctuations and for it to be off by a little bit. So to\n       * avoid a flaky test we'll make sure it waited for roughly 1 second\n       */\n      expect(endTime - startTime).toBeGreaterThan(700);\n      expect(endTime - startTime).toBeLessThan(1300);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should immediately resolve promise if node exists","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":372,"column":57},"line":372,"code":"    it('should immediately resolve promise if node exists', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      await frame.waitForSelector('*');\n      await frame.evaluate(addElement, 'div');\n      await frame.waitForSelector('div');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work with removed MutationObserver","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":382,"column":49},"line":382,"code":"    it('should work with removed MutationObserver', async () => {\n      const {page} = getTestState();\n\n      await page.evaluate(() => {\n        // @ts-expect-error We want to remove it for the test.\n        return delete window.MutationObserver;\n      });\n      const [handle] = await Promise.all([\n        page.waitForSelector('.zombo'),\n        page.setContent(`<div class='zombo'>anything</div>`),\n      ]);\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, handle)\n      ).toBe('anything');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve promise when node is added","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":400,"column":49},"line":400,"code":"    it('should resolve promise when node is added', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const frame = page.mainFrame();\n      const watchdog = frame.waitForSelector('div');\n      await frame.evaluate(addElement, 'br');\n      await frame.evaluate(addElement, 'div');\n      const eHandle = (await watchdog)!;\n      const tagName = await (await eHandle.getProperty('tagName')).jsonValue();\n      expect(tagName).toBe('DIV');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should work when node is added through innerHTML","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":413,"column":56},"line":413,"code":"    it('should work when node is added through innerHTML', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      const watchdog = page.waitForSelector('h3 div');\n      await page.evaluate(addElement, 'span');\n      await page.evaluate(() => {\n        return (document.querySelector('span')!.innerHTML =\n          '<h3><div></div></h3>');\n      });\n      await watchdog;\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"Page.waitForSelector is shortcut for main frame","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":426,"column":55},"line":426,"code":"    it('Page.waitForSelector is shortcut for main frame', async () => {\n      const {page, server} = getTestState();\n\n      await page.goto(server.EMPTY_PAGE);\n      await attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const otherFrame = page.frames()[1]!;\n      const watchdog = page.waitForSelector('div');\n      await otherFrame.evaluate(addElement, 'div');\n      await page.evaluate(addElement, 'div');\n      const eHandle = await watchdog;\n      expect(eHandle?.frame).toBe(page.mainFrame());\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should run in specified frame","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":439,"column":37},"line":439,"code":"    it('should run in specified frame', async () => {\n      const {page, server} = getTestState();\n\n      await attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await attachFrame(page, 'frame2', server.EMPTY_PAGE);\n      const frame1 = page.frames()[1]!;\n      const frame2 = page.frames()[2]!;\n      const waitForSelectorPromise = frame2.waitForSelector('div');\n      await frame1.evaluate(addElement, 'div');\n      await frame2.evaluate(addElement, 'div');\n      const eHandle = await waitForSelectorPromise;\n      expect(eHandle?.frame).toBe(frame2);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when frame is detached","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":453,"column":43},"line":453,"code":"    it('should throw when frame is detached', async () => {\n      const {page, server} = getTestState();\n\n      await attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const frame = page.frames()[1]!;\n      let waitError: Error | undefined;\n      const waitPromise = frame.waitForSelector('.box').catch(error => {\n        return (waitError = error);\n      });\n      await detachFrame(page, 'frame1');\n      await waitPromise;\n      expect(waitError).toBeTruthy();\n      expect(waitError?.message).toContain(\n        'waitForFunction failed: frame got detached.'\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should survive cross-process navigation","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":469,"column":47},"line":469,"code":"    it('should survive cross-process navigation', async () => {\n      const {page, server} = getTestState();\n\n      let boxFound = false;\n      const waitForSelector = page.waitForSelector('.box').then(() => {\n        return (boxFound = true);\n      });\n      await page.goto(server.EMPTY_PAGE);\n      expect(boxFound).toBe(false);\n      await page.reload();\n      expect(boxFound).toBe(false);\n      await page.goto(server.CROSS_PROCESS_PREFIX + '/grid.html');\n      await waitForSelector;\n      expect(boxFound).toBe(true);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be visible (display)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":484,"column":55},"line":484,"code":"    it('should wait for element to be visible (display)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {visible: true});\n      await page.setContent('<div style=\"display: none\">text</div>');\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.removeProperty('display');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be visible (visibility)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":500,"column":58},"line":500,"code":"    it('should wait for element to be visible (visibility)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {visible: true});\n      await page.setContent('<div style=\"visibility: hidden\">text</div>');\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.setProperty('visibility', 'collapse');\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.removeProperty('visibility');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be visible (bounding box)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":522,"column":60},"line":522,"code":"    it('should wait for element to be visible (bounding box)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {visible: true});\n      await page.setContent('<div style=\"width: 0\">text</div>');\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.setProperty('height', '0');\n        e.style.removeProperty('width');\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.removeProperty('height');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be visible recursively","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":545,"column":57},"line":545,"code":"    it('should wait for element to be visible recursively', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div#inner', {\n        visible: true,\n      });\n      await page.setContent(\n        `<div style='display: none; visibility: hidden;'><div id=\"inner\">hi</div></div>`\n      );\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        return e.style.removeProperty('display');\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        return e.style.removeProperty('visibility');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be hidden (visibility)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":571,"column":57},"line":571,"code":"    it('should wait for element to be hidden (visibility)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {hidden: true});\n      await page.setContent(`<div style='display: block;'>text</div>`);\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        return e.style.setProperty('visibility', 'hidden');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be hidden (display)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":587,"column":54},"line":587,"code":"    it('should wait for element to be hidden (display)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {hidden: true});\n      await page.setContent(`<div style='display: block;'>text</div>`);\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        return e.style.setProperty('display', 'none');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be hidden (bounding box)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":603,"column":59},"line":603,"code":"    it('should wait for element to be hidden (bounding box)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {hidden: true});\n      await page.setContent('<div>text</div>');\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40)])\n      ).resolves.toBeFalsy();\n      await element.evaluate(e => {\n        e.style.setProperty('height', '0');\n      });\n      await expect(promise).resolves.toBeTruthy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should wait for element to be hidden (removal)","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":619,"column":54},"line":619,"code":"    it('should wait for element to be hidden (removal)', async () => {\n      const {page} = getTestState();\n\n      const promise = page.waitForSelector('div', {hidden: true});\n      await page.setContent(`<div>text</div>`);\n      const element = await page.evaluateHandle(() => {\n        return document.getElementsByTagName('div')[0]!;\n      });\n      await expect(\n        Promise.race([promise, createTimeout(40, true)])\n      ).resolves.toBeTruthy();\n      await element.evaluate(e => {\n        e.remove();\n      });\n      await expect(promise).resolves.toBeFalsy();\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return null if waiting to hide non-existing element","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":635,"column":66},"line":635,"code":"    it('should return null if waiting to hide non-existing element', async () => {\n      const {page} = getTestState();\n\n      const handle = await page.waitForSelector('non-existing', {\n        hidden: true,\n      });\n      expect(handle).toBe(null);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":643,"column":30},"line":643,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.waitForSelector('div', {timeout: 10}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n      expect(error?.message).toContain(\n        'Waiting for selector `div` failed: Waiting failed: 10ms exceeded'\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should have an error message specifically for awaiting an element to be hidden","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":655,"column":86},"line":655,"code":"    it('should have an error message specifically for awaiting an element to be hidden', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div>text</div>`);\n      let error!: Error;\n      await page\n        .waitForSelector('div', {hidden: true, timeout: 10})\n        .catch(error_ => {\n          return (error = error_);\n        });\n      expect(error).toBeTruthy();\n      expect(error?.message).toContain(\n        'Waiting for selector `div` failed: Waiting failed: 10ms exceeded'\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respond to node attribute mutation","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":671,"column":49},"line":671,"code":"    it('should respond to node attribute mutation', async () => {\n      const {page} = getTestState();\n\n      let divFound = false;\n      const waitForSelector = page.waitForSelector('.zombo').then(() => {\n        return (divFound = true);\n      });\n      await page.setContent(`<div class='notZombo'></div>`);\n      expect(divFound).toBe(false);\n      await page.evaluate(() => {\n        return (document.querySelector('div')!.className = 'zombo');\n      });\n      expect(await waitForSelector).toBe(true);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":685,"column":40},"line":685,"code":"    it('should return the element handle', async () => {\n      const {page} = getTestState();\n\n      const waitForSelector = page.waitForSelector('.zombo');\n      await page.setContent(`<div class='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, await waitForSelector)\n      ).toBe('anything');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should have correct stack trace for timeout","suites":["waittask specs","Frame.waitForSelector"],"updatePoint":{"line":696,"column":51},"line":696,"code":"    it('should have correct stack trace for timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.waitForSelector('.zombo', {timeout: 10}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error?.stack).toContain(\n        'Waiting for selector `.zombo` failed: Waiting failed: 10ms exceeded'\n      );\n      // The extension is ts here as Mocha maps back via sourcemaps.\n      expect(error?.stack).toContain('WaitTask.ts');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should support some fancy xpath","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":716,"column":39},"line":716,"code":"    it('should support some fancy xpath', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<p>red herring</p><p>hello  world  </p>`);\n      const waitForXPath = page.waitForXPath(\n        '//p[normalize-space(.)=\"hello world\"]'\n      );\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, await waitForXPath)\n      ).toBe('hello  world  ');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should respect timeout","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":729,"column":30},"line":729,"code":"    it('should respect timeout', async () => {\n      const {page} = getTestState();\n\n      let error!: Error;\n      await page.waitForXPath('//div', {timeout: 10}).catch(error_ => {\n        return (error = error_);\n      });\n      expect(error).toBeInstanceOf(TimeoutError);\n      expect(error?.message).toContain('Waiting failed: 10ms exceeded');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should run in specified frame","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":739,"column":37},"line":739,"code":"    it('should run in specified frame', async () => {\n      const {page, server} = getTestState();\n\n      await attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      await attachFrame(page, 'frame2', server.EMPTY_PAGE);\n      const frame1 = page.frames()[1]!;\n      const frame2 = page.frames()[2]!;\n      const waitForXPathPromise = frame2.waitForXPath('//div');\n      await frame1.evaluate(addElement, 'div');\n      await frame2.evaluate(addElement, 'div');\n      const eHandle = await waitForXPathPromise;\n      expect(eHandle?.frame).toBe(frame2);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should throw when frame is detached","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":752,"column":43},"line":752,"code":"    it('should throw when frame is detached', async () => {\n      const {page, server} = getTestState();\n\n      await attachFrame(page, 'frame1', server.EMPTY_PAGE);\n      const frame = page.frames()[1]!;\n      let waitError: Error | undefined;\n      const waitPromise = frame\n        .waitForXPath('//*[@class=\"box\"]')\n        .catch(error => {\n          return (waitError = error);\n        });\n      await detachFrame(page, 'frame1');\n      await waitPromise;\n      expect(waitError).toBeTruthy();\n      expect(waitError?.message).toContain(\n        'waitForFunction failed: frame got detached.'\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should wait for display: none","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":770,"column":44},"line":770,"code":"    it('hidden should wait for display: none', async () => {\n      const {page} = getTestState();\n\n      let divHidden = false;\n      await page.setContent(`<div style='display: block;'>text</div>`);\n      const waitForXPath = page\n        .waitForXPath('//div', {hidden: true})\n        .then(() => {\n          return (divHidden = true);\n        });\n      await page.waitForXPath('//div'); // do a round trip\n      expect(divHidden).toBe(false);\n      await page.evaluate(() => {\n        return document\n          .querySelector('div')\n          ?.style.setProperty('display', 'none');\n      });\n      expect(await waitForXPath).toBe(true);\n      expect(divHidden).toBe(true);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should return null if the element is not found","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":790,"column":61},"line":790,"code":"    it('hidden should return null if the element is not found', async () => {\n      const {page} = getTestState();\n\n      const waitForXPath = await page.waitForXPath('//div', {hidden: true});\n\n      expect(waitForXPath).toBe(null);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"hidden should return an empty element handle if the element is found","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":797,"column":76},"line":797,"code":"    it('hidden should return an empty element handle if the element is found', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div style='display: none;'>text</div>`);\n\n      const waitForXPath = await page.waitForXPath('//div', {hidden: true});\n\n      expect(waitForXPath).toBeInstanceOf(ElementHandle);\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should return the element handle","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":806,"column":40},"line":806,"code":"    it('should return the element handle', async () => {\n      const {page} = getTestState();\n\n      const waitForXPath = page.waitForXPath('//*[@class=\"zombo\"]');\n      await page.setContent(`<div class='zombo'>anything</div>`);\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, await waitForXPath)\n      ).toBe('anything');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should allow you to select a text node","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":817,"column":46},"line":817,"code":"    it('should allow you to select a text node', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div>some text</div>`);\n      const text = await page.waitForXPath('//div/text()');\n      expect(await (await text!.getProperty('nodeType')!).jsonValue()).toBe(\n        3 /* Node.TEXT_NODE */\n      );\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"should allow you to select an element with single slash","suites":["waittask specs","Frame.waitForXPath"],"updatePoint":{"line":826,"column":63},"line":826,"code":"    it('should allow you to select an element with single slash', async () => {\n      const {page} = getTestState();\n\n      await page.setContent(`<div>some text</div>`);\n      const waitForXPath = page.waitForXPath('/html/body/div');\n      expect(\n        await page.evaluate(x => {\n          return x?.textContent;\n        }, await waitForXPath)\n      ).toBe('some text');\n    });","file":"src/waittask.spec.ts","skipped":false,"dir":"test"},{"name":"Page.workers","suites":["Workers"],"updatePoint":{"line":30,"column":18},"line":30,"code":"  it('Page.workers', async () => {\n    const {page, server} = getTestState();\n\n    await Promise.all([\n      new Promise(x => {\n        return page.once('workercreated', x);\n      }),\n      page.goto(server.PREFIX + '/worker/worker.html'),\n    ]);\n    const worker = page.workers()[0]!;\n    expect(worker?.url()).toContain('worker.js');\n\n    expect(\n      await worker?.evaluate(() => {\n        return (globalThis as any).workerFunction();\n      })\n    ).toBe('worker function result');\n\n    await page.goto(server.EMPTY_PAGE);\n    expect(page.workers().length).toBe(0);\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"},{"name":"should emit created and destroyed events","suites":["Workers"],"updatePoint":{"line":51,"column":46},"line":51,"code":"  it('should emit created and destroyed events', async () => {\n    const {page} = getTestState();\n\n    const workerCreatedPromise = new Promise<WebWorker>(x => {\n      return page.once('workercreated', x);\n    });\n    const workerObj = await page.evaluateHandle(() => {\n      return new Worker('data:text/javascript,1');\n    });\n    const worker = await workerCreatedPromise;\n    const workerThisObj = await worker.evaluateHandle(() => {\n      return this;\n    });\n    const workerDestroyedPromise = new Promise(x => {\n      return page.once('workerdestroyed', x);\n    });\n    await page.evaluate((workerObj: Worker) => {\n      return workerObj.terminate();\n    }, workerObj);\n    expect(await workerDestroyedPromise).toBe(worker);\n    const error = await workerThisObj.getProperty('self').catch(error => {\n      return error;\n    });\n    expect(error.message).toContain('Most likely the worker has been closed.');\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"},{"name":"should report console logs","suites":["Workers"],"updatePoint":{"line":76,"column":32},"line":76,"code":"  it('should report console logs', async () => {\n    const {page} = getTestState();\n\n    const [message] = await Promise.all([\n      waitEvent(page, 'console'),\n      page.evaluate(() => {\n        return new Worker(`data:text/javascript,console.log(1)`);\n      }),\n    ]);\n    expect(message.text()).toBe('1');\n    expect(message.location()).toEqual({\n      url: '',\n      lineNumber: 0,\n      columnNumber: 8,\n    });\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"},{"name":"should have JSHandles for console logs","suites":["Workers"],"updatePoint":{"line":92,"column":44},"line":92,"code":"  it('should have JSHandles for console logs', async () => {\n    const {page} = getTestState();\n\n    const logPromise = new Promise<ConsoleMessage>(x => {\n      return page.on('console', x);\n    });\n    await page.evaluate(() => {\n      return new Worker(`data:text/javascript,console.log(1,2,3,this)`);\n    });\n    const log = await logPromise;\n    expect(log.text()).toBe('1 2 3 JSHandle@object');\n    expect(log.args().length).toBe(4);\n    expect(await (await log.args()[3]!.getProperty('origin')).jsonValue()).toBe(\n      'null'\n    );\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"},{"name":"should have an execution context","suites":["Workers"],"updatePoint":{"line":108,"column":38},"line":108,"code":"  it('should have an execution context', async () => {\n    const {page} = getTestState();\n\n    const workerCreatedPromise = new Promise<WebWorker>(x => {\n      return page.once('workercreated', x);\n    });\n    await page.evaluate(() => {\n      return new Worker(`data:text/javascript,console.log(1)`);\n    });\n    const worker = await workerCreatedPromise;\n    expect(await (await worker.executionContext()).evaluate('1+1')).toBe(2);\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"},{"name":"should report errors","suites":["Workers"],"updatePoint":{"line":120,"column":26},"line":120,"code":"  it('should report errors', async () => {\n    const {page} = getTestState();\n\n    const errorPromise = new Promise<Error>(x => {\n      return page.on('pageerror', x);\n    });\n    await page.evaluate(() => {\n      return new Worker(\n        `data:text/javascript, throw new Error('this is my error');`\n      );\n    });\n    const errorLog = await errorPromise;\n    expect(errorLog.message).toContain('this is my error');\n  });","file":"src/worker.spec.ts","skipped":false,"dir":"test"}]}